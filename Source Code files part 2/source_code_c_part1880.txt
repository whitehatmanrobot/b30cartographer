--
HRESULT CreateDialogClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvObject)
{
    CDialog * pdialog;
    HRESULT hr;

    InitPv(ppvObject);

    pdialog = new CDialog(hwnd, idChildCur);
    if (!pdialog)
        return(E_OUTOFMEMORY);

    hr = pdialog->QueryInterface(riid, ppvObject);
    if (!SUCCEEDED(hr))
        delete pdialog;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CDialog::CDialog()
//
// --------------------------------------------------------------------------
CDialog::CDialog(HWND hwnd, long idChildCur)
    : CClient( CLASS_DialogClient )
{
    Initialize(hwnd, idChildCur);
}



// --------------------------------------------------------------------------
//
//  CDialog::get_accRole()
//
//  Currently does NOT accept child IDs
//
// --------------------------------------------------------------------------
STDMETHODIMP CDialog::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    long    lStyle;

    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    if ((lStyle & WS_CHILD) && (lStyle & DS_CONTROL))
        pvarRole->lVal = ROLE_SYSTEM_PROPERTYPAGE;
    else
        pvarRole->lVal = ROLE_SYSTEM_DIALOG;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CDialog::get_accDefaultAction()
//
//  The default action is the name of the default push button.
//
// --------------------------------------------------------------------------
STDMETHODIMP CDialog::get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction)
{
    HRESULT hr;
    long    idDef;
    HWND    hwndDef;
    IAccessible * poleacc;

    InitPv(pszDefAction);

    //
    // Validate--use ValidateChild so only 0 is allowed.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // Get the default ID
    //
    idDef = SendMessageINT(m_hwnd, DM_GETDEFID, 0, 0);
    if (HIWORD(idDef) == DC_HASDEFID)
        idDef &= 0x0000FFFF;
    else
        idDef = IDOK;

    //
    // Get the item with this ID
    //
    hwndDef = GetDlgItem(m_hwnd, idDef);
    if (!hwndDef)
        return(S_FALSE);

    //
    // Get this thing's name.
    //
    poleacc = NULL;
    hr = AccessibleObjectFromWindow(hwndDef, OBJID_CLIENT, IID_IAccessible,
        (void**)&poleacc);
    if (!SUCCEEDED(hr))
        return(hr);

    //
    // varChild is empty of course
    //
    hr = poleacc->get_accName(varChild, pszDefAction);
    poleacc->Release();

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CDialog::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CDialog::accDoDefaultAction(VARIANT varChild)
{
    HRESULT hr;
    long    idDef;
    HWND    hwndDef;
    IAccessible * poleacc;

    //
    // Validate 
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // Get the default ID
    //
    idDef = SendMessageINT(m_hwnd, DM_GETDEFID, 0, 0);
    if (HIWORD(idDef) == DC_HASDEFID)
        idDef &= 0x0000FFFF;
    else
        idDef = IDOK;

    //
    // Get the child with this ID
    //
    hwndDef = GetDlgItem(m_hwnd, idDef);
    if (!hwndDef)
        return(S_FALSE);

    //
    // Ask the child to do its default action.  Yes, we could send a 
    // WM_COMMAND message directly, but this lets non-push buttons hook
    // into the action.
    //
    poleacc = NULL;
    hr = AccessibleObjectFromWindow(hwndDef, OBJID_CLIENT, IID_IAccessible,
        (void**)&poleacc);
    if (!SUCCEEDED(hr))
        return(hr);

    hr = poleacc->accDoDefaultAction(varChild);
    poleacc->Release();

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\header.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  HEADER.CPP
//
//  This knows how to talk to COMCTL32's header control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "header.h"
#include "Win64Helper.h"

#define MAX_HEADER_TEXT 80

// --------------------------------------------------------------------------
//
//  CreateHeaderClient()
//
// --------------------------------------------------------------------------
HRESULT CreateHeaderClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvHeader)
{
    CHeader32 * pheader;
    HRESULT     hr;

    InitPv(ppvHeader);

    pheader = new CHeader32(hwnd, idChildCur);
    if (!pheader)
        return(E_OUTOFMEMORY);

    hr = pheader->QueryInterface(riid, ppvHeader);
    if (!SUCCEEDED(hr))
        delete pheader;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CHeader32::CHeader32()
//
// --------------------------------------------------------------------------
CHeader32::CHeader32(HWND hwnd, long idChildCur)
    : CClient( CLASS_HeaderClient )
{
    Initialize(hwnd, idChildCur);
}



// --------------------------------------------------------------------------
//
//  CHeader32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accName(varChild, pszName));

	TCHAR tchText[MAX_HEADER_TEXT + 1] = {0};
	HDITEM hdi;
	memset(&hdi, 0, sizeof(HDITEM));
	hdi.mask = HDI_TEXT;
	hdi.pszText = tchText;
	hdi.cchTextMax = MAX_HEADER_TEXT;

	if (SUCCEEDED(XSend_HeaderCtrl_GetItem(m_hwnd, HDM_GETITEM, varChild.lVal-1, &hdi)))
	{
        if (*hdi.pszText)
            *pszName = TCharSysAllocString(hdi.pszText);

    }
    //
    // BOGUS!  On failure, use tooltip trick like toolbar.
    //
    return(*pszName ? S_OK : S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CHeader32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    if (!varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_LIST;
    else
        pvarRole->lVal = ROLE_SYSTEM_COLUMNHEADER;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CHeader32::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    WINDOWINFO wi;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

	pvarState->lVal |= STATE_SYSTEM_READONLY;

    if (!MyGetWindowInfo(m_hwnd, &wi))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_OK);
    }
    
	if (!(wi.dwStyle & WS_VISIBLE))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

	if (wi.dwStyle & HDS_HIDDEN)
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    // Check for clipped, but only if this is a child item, and it's not
    // already invisible...
    if( varChild.lVal != CHILDID_SELF
     && ! ( pvarState->lVal & STATE_SYSTEM_INVISIBLE )
     && IsClippedByWindow( this, varChild, m_hwnd ) )
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
    }

	if (wi.dwStyle & HDS_BUTTONS)
        pvarState->lVal |= 0;		// BOGUS! Indicate whether you can click or not.

    return(S_OK);
}

// --------------------------------------------------------------------------
//
//  CHeader32::get_accDefaultAction()
//
//  Since the default action for a header is really determined by the
//  creator of the header control, the best we can do is click on
//  the thing, and return "click" as the default action string.
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction)
{
WINDOWINFO wi;

    InitPv(pszDefAction);

    //
    // Validate.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (MyGetWindowInfo(m_hwnd, &wi))
    {
    	if (wi.dwStyle & WS_VISIBLE)
        {
            if (!(wi.dwStyle & HDS_HIDDEN))
            {
                if (wi.dwStyle & HDS_BUTTONS)
                    return (HrCreateString(STR_CLICK, pszDefAction));
            }
        }
    }

    return(E_NOT_APPLICABLE);
}

// --------------------------------------------------------------------------
//
//  CHeader32::accDoDefaultAction()
//
//  As noted above, we really don't know what the default action for a 
//  header is, so unless the parent overrides us, we'll just do a
//  click on the thing.
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::accDoDefaultAction(VARIANT varChild)
{
WINDOWINFO wi;
RECT		rcLoc;
HRESULT		hr;

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (MyGetWindowInfo(m_hwnd, &wi))
    {
    	if (wi.dwStyle & WS_VISIBLE)
        {
            if (!(wi.dwStyle & HDS_HIDDEN))
            {
                if (wi.dwStyle & HDS_BUTTONS)
                {
	                hr = accLocation(&rcLoc.left,&rcLoc.top,&rcLoc.right,&rcLoc.bottom,varChild);
	                if (!SUCCEEDED (hr))
		                return (hr);

	                if (ClickOnTheRect(&rcLoc,m_hwnd,FALSE))
		                return (S_OK);
                }
            }
        }
    }
    return(E_NOT_APPLICABLE);
}

// --------------------------------------------------------------------------
//
//  CHeader32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
LPRECT  lprc;
HANDLE  hProcess;
RECT    rcItem;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    //
    // Allocate a shared memory LPRECT and get the item's rectangle.
    //
    lprc = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
    if (!lprc)
        return(E_OUTOFMEMORY);

    if (SendMessage(m_hwnd, HDM_GETITEMRECT, varChild.lVal-1, (LPARAM)lprc))
    {
        SharedRead (lprc,&rcItem,sizeof(RECT),hProcess);

        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcItem, 2);

        *pxLeft = rcItem.left;
        *pyTop = rcItem.top;
        *pcxWidth = rcItem.right - rcItem.left;
        *pcyHeight = rcItem.bottom - rcItem.top;
    }

    SharedFree(lprc,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CHeader32::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
LPINT   lpiShared;
LPINT   lpiLocal;
long    lPosition = 0;
int     iOrder;
HANDLE  hProcess;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    Assert(NAVDIR_LASTCHILD > NAVDIR_FIRSTCHILD);
    Assert(NAVDIR_MAX == NAVDIR_LASTCHILD+1);

    // Peer navigation among frame elements
    if ((!varStart.lVal) && (dwNavDir < NAVDIR_FIRSTCHILD))
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

    //
    // Get the order array.
    //
    lpiShared = (LPINT)SharedAlloc((m_cChildren*sizeof(INT)),m_hwnd,&hProcess);
    if (!lpiShared)
        return(E_OUTOFMEMORY);

    lpiLocal = (LPINT)LocalAlloc (LPTR,(m_cChildren*sizeof(INT)));
    if (!lpiLocal)
    {
        SharedFree (lpiShared,hProcess);
        return(E_OUTOFMEMORY);
    }

    SendMessage(m_hwnd, HDM_GETORDERARRAY, m_cChildren, (LPARAM)lpiShared);

    //
    // BOGUS!  Only works for column headers (horizontal), not row
    // headers (vertical).
    // 
    SharedRead (lpiShared,lpiLocal,(m_cChildren*sizeof(INT)),hProcess);

    // Get the position of the item we want to move to
    switch (dwNavDir)
    {
        case NAVDIR_FIRSTCHILD:
            lPosition = 0;
            break;

        case NAVDIR_LASTCHILD:
            if (!m_cChildren)
                goto NavigateEnd;
            lPosition = m_cChildren - 1;
            break;

        case NAVDIR_NEXT:
        case NAVDIR_RIGHT:
            lPosition = lpiLocal[varStart.lVal-1];
            ++lPosition;
            if (lPosition >= m_cChildren)
                goto NavigateEnd;
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_LEFT:
            lPosition = lpiLocal[varStart.lVal-1];
            if (!lPosition)
                goto NavigateEnd;
            --lPosition;
            break;

        case NAVDIR_UP:
        case NAVDIR_DOWN:
            goto NavigateEnd;
            break;
    }

    //
    // Find the item with this positional value
    //
    for (iOrder = 0; iOrder < m_cChildren; iOrder++)
    {
        if (lpiLocal[iOrder] == lPosition)
        {
            pvarEnd->vt = VT_I4;
            pvarEnd->lVal = iOrder+1;
            break;
        }
    }

NavigateEnd:
    SharedFree(lpiShared,hProcess);
    LocalFree (lpiLocal);

    return((pvarEnd->vt == VT_EMPTY) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CHeader32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHeader32::accHitTest(long x, long y, VARIANT* pvarEnd)
{
HRESULT         hr;
LPHDHITTESTINFO lphi;
HANDLE          hProcess;
POINT           ptTest;

    InitPvar(pvarEnd);
    SetupChildren();

    //
    // Is the point in our client?  If not, bail.
    //
    hr = CClient::accHitTest(x, y, pvarEnd);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarEnd->vt != VT_I4) || (pvarEnd->lVal != 0))
        return(hr);

    //
    // It is.  Do hit test stuff.
    //
    lphi = (LPHDHITTESTINFO)SharedAlloc(sizeof(HDHITTESTINFO),m_hwnd,&hProcess);
    if (!lphi)
        return(E_OUTOFMEMORY);

    ptTest.x = x;
    ptTest.y = y;
    ScreenToClient(m_hwnd, &ptTest);

    SharedWrite (&ptTest,&lphi->pt,sizeof(POINT),hProcess);

    if (SendMessage(m_hwnd, HDM_HITTEST, 0, (LPARAM)lphi) != -1)
    {
        SharedRead (&lphi->iItem,&pvarEnd->lVal,sizeof(int),hProcess);
        pvarEnd->lVal++;
    }

    SharedFree(lphi,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CHeader32::SetupChildren()
//
// --------------------------------------------------------------------------
void CHeader32::SetupChildren(void)
{
    m_cChildren = SendMessageINT(m_hwnd, HDM_GETITEMCOUNT, 0, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\header.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  HEADER.H
//
//  Knows how to talk to COMCTL32's header control
//
// --------------------------------------------------------------------------

class CHeader32 : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accName(VARIANT, BSTR*);
        STDMETHODIMP    get_accRole(VARIANT, VARIANT*);
		STDMETHODIMP	get_accState(VARIANT, VARIANT*);
        STDMETHODIMP    get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP    accDoDefaultAction(VARIANT);
        STDMETHODIMP    accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP    accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP    accHitTest(long, long, VARIANT*);

        CHeader32(HWND, long);
        void        SetupChildren(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\dialog.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  DIALOG.H
//
//  Dialog object
//
// --------------------------------------------------------------------------

class   CDialog :   public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT* pvarRole);
        STDMETHODIMP    get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction);
        STDMETHODIMP    accDoDefaultAction(VARIANT varChild);
        
        CDialog(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\edit.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  EDIT.H
//
//  Edit field
//
// --------------------------------------------------------------------------

class   CEdit : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP        get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accValue(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        virtual STDMETHODIMP        get_accKeyboardShortcut(VARIANT, BSTR*);
        virtual STDMETHODIMP        put_accValue(VARIANT, BSTR);
        virtual STDMETHODIMP        get_accDescription(VARIANT varChild, BSTR* pszDescription);

        CEdit(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\guids.c ===
// Copyright (c) 1996-1999 Microsoft Corporation

// ===========================================================================
// File: G U I D S . C
// 
// Used to define all MSAA GUIDs for OLEACC.  By compiling this file w/o 
// precompiled headers, we are allowing the MSAA GUIDs to be defined and stored
// in OLEACC.DLLs data or code segments.  This is necessary for OLEACC.DLL to 
// be built.
// 
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
// Microsoft Confidential.
// ===========================================================================

// disable warnings to placate compiler wjen compiling included ole headers
#pragma warning(disable:4201)	// allows nameless structs and unions
#pragma warning(disable:4514)	// don't care when unreferenced inline functions are removed
#pragma warning(disable:4706)	// we are allowed to assign within a conditional
#pragma warning(disable:4214)	// ignore nonstandard extensions
#pragma warning(disable:4115)	// named type definition in parenthesis

#include <objbase.h>

#include <initguid.h>

// All the GUIDs we want are in oleacc.h as DEFINE_GUID's...
#include "com_external.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\edit.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  EDIT.CPP
//
//  BOGUS!  This should support ITextDocument or something
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "classmap.h"
#include "ctors.h"
#include "window.h"
#include "client.h"
#include "edit.h"



BOOL GetRichEditText( HWND hwnd, LPWSTR pWStr, int cchWStrMax );

BOOL GetObjectText( IUnknown * punk, LPWSTR * ppWStr, int * pcchWStrMax );

HRESULT InvokeMethod( IDispatch * pDisp, LPCWSTR pName, VARIANT * pvarResult, int cArgs, ... );

HRESULT GetProperty( IDispatch * pDisp, LPCWSTR pName, VARIANT * pvarResult );



// --------------------------------------------------------------------------
//
//  CreateEditClient()
//
// --------------------------------------------------------------------------
HRESULT CreateEditClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvEdit)
{
    CEdit * pedit;
    HRESULT hr;

    InitPv(ppvEdit);

    pedit = new CEdit(hwnd, idChildCur);
    if (!pedit)
        return(E_OUTOFMEMORY);

    hr = pedit->QueryInterface(riid, ppvEdit);
    if (!SUCCEEDED(hr))
        delete pedit;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CEdit::CEdit()
//
// --------------------------------------------------------------------------
CEdit::CEdit(HWND hwnd, long idChildCur)
    : CClient( CLASS_EditClient )
{
    Initialize(hwnd, idChildCur);
    m_fUseLabel = TRUE;
}



// --------------------------------------------------------------------------
//
//  CEdit::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    // Is this edit in a combo or an IP control? If so, use the parent's
    // name (which it gets from its label) as our own.

    // Using CompareWindowClasses is safer than checking the ES_COMBOBOX style bit,
    // since that bit is not used when the edit is in a combo in a comboex32.
    // was:   if (GetWindowLong(m_hwnd, GWL_STYLE) & ES_COMBOBOX)
    HWND hwndParent = MyGetAncestor(m_hwnd, GA_PARENT);
    const CLASS_ENUM ceClass = GetWindowClass( hwndParent );
    
    if( hwndParent && ( CLASS_ComboClient == ceClass || CLASS_IPAddressClient == ceClass ) )
    {
        IAccessible* pacc = NULL;
        HRESULT hr = AccessibleObjectFromWindow( hwndParent,
                    OBJID_CLIENT, IID_IAccessible, (void**)&pacc );
        if( ! SUCCEEDED( hr ) || ! pacc )
            return S_FALSE;

        VariantInit(&varChild);
        varChild.vt = VT_I4;
        varChild.lVal = CHILDID_SELF;
        hr = pacc->get_accName(varChild, pszName);
        pacc->Release();

        return hr;
    }
    else
        return(CClient::get_accName(varChild, pszName));
}



// --------------------------------------------------------------------------
//
//  CEdit::get_accValue()
//
//  Gets the text contents.
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    InitPv(pszValue);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return E_INVALIDARG;

    // if this is a password edit control, return a NULL pointer
    DWORD dwPasswordChar = Edit_GetPasswordChar( m_hwnd );
    if( dwPasswordChar != '\0' )
    {
        return E_ACCESSDENIED;
    }


    // Try getting text (plus object text) using the RichEdit/TOM
    // technique...
    {
        WCHAR szText[ 4096 ];
        if( GetRichEditText( m_hwnd, szText, ARRAYSIZE( szText ) ) )
        {
            *pszValue = SysAllocString( szText );
            return S_OK;
        }
    }

    LPTSTR lpszValue = GetTextString(m_hwnd, TRUE);
    if (!lpszValue)
        return S_FALSE;

    *pszValue = TCharSysAllocString(lpszValue);
    LocalFree((HANDLE)lpszValue);

    if (! *pszValue)
        return E_OUTOFMEMORY;

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CEdit::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_TEXT;

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CEdit::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    // 
    // Get default client state
    //
    HRESULT hr = CClient::get_accState(varChild, pvarState);
    if (!SUCCEEDED(hr))
        return hr;

    //
    // Add on extra styles for edit field
    //
    Assert(pvarState->vt == VT_I4);

    LONG lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    if (lStyle & ES_READONLY)
    {
        pvarState->lVal |= STATE_SYSTEM_READONLY;
    }

    DWORD dwPasswordChar = Edit_GetPasswordChar( m_hwnd );
    if( dwPasswordChar != '\0' )
    {
        pvarState->lVal |= STATE_SYSTEM_PROTECTED;
    }

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CEdit::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);


    // If in a combo or IP control, use its shortcut key...
    HWND hwndParent = MyGetAncestor(m_hwnd, GA_PARENT);
    const CLASS_ENUM ceClass = GetWindowClass( hwndParent );
    
    if( hwndParent && ( CLASS_ComboClient == ceClass || CLASS_IPAddressClient == ceClass ) )
    {
        IAccessible* pacc = NULL;
        HRESULT hr = AccessibleObjectFromWindow( hwndParent,
                    OBJID_CLIENT, IID_IAccessible, (void**)&pacc );
        if( ! SUCCEEDED( hr ) || ! pacc )
            return S_FALSE;

        VariantInit(&varChild);
        varChild.vt = VT_I4;
        varChild.lVal = CHILDID_SELF;
        hr = pacc->get_accKeyboardShortcut(varChild, pszShortcut);
        pacc->Release();

        return hr;
    }
    else
        return(CClient::get_accKeyboardShortcut(varChild, pszShortcut));
}


// --------------------------------------------------------------------------
//
//  CEdit::put_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::put_accValue(VARIANT varChild, BSTR szValue)
{
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    LPTSTR  lpszValue;

#ifdef UNICODE

	// If unicode, use the BSTR directly...
	lpszValue = szValue;

#else

	// If not UNICODE, allocate a temp string and convert to multibyte...

    // We may be dealing with DBCS chars - assume worst case where every character is
    // two bytes...
    UINT cchValue = SysStringLen(szValue) * 2;
    lpszValue = (LPTSTR)LocalAlloc(LPTR, (cchValue+1)*sizeof(TCHAR));
    if (!lpszValue)
        return(E_OUTOFMEMORY);

    WideCharToMultiByte(CP_ACP, 0, szValue, -1, lpszValue, cchValue+1, NULL,
        NULL);

#endif


    SendMessage(m_hwnd, WM_SETTEXT, 0, (LPARAM)lpszValue);

#ifndef UNICODE

	// If non-unicode, free the temp string we allocated above
    LocalFree((HANDLE)lpszValue);

#endif

    return(S_OK);
}

// --------------------------------------------------------------------------
//
//  CEdit::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CEdit::get_accDescription(VARIANT varChild, BSTR* pszDescription)
{
    InitPv(pszDescription);
	
    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return E_INVALIDARG;

    // Is this an IP control?  Add a description to specify whitch part it is

    HWND hwndParent = MyGetAncestor(m_hwnd, GA_PARENT);
    if( hwndParent && CLASS_IPAddressClient == GetWindowClass( hwndParent ) ) 
    {
		HWND hwndChild = ::GetWindow( hwndParent, GW_CHILD );

		for ( int i = 4; i > 0 && hwndChild; i-- )
		{
			if ( hwndChild == m_hwnd )
			{
				TCHAR szIP[32], szPart[32];
				
				if ( !LoadString(hinstResDll, STR_DESC_IP_PART, szPart, ARRAYSIZE(szPart) - 1 ) )
				    return E_FAIL;
				    
				wsprintf( szIP, szPart, i );
				*pszDescription = TCharSysAllocString( szIP );
				break;
			}

			hwndChild = ::GetWindow( hwndChild, GW_HWNDNEXT );
		} 
    }

	return S_OK;
}



















// --------------------------------------------------------------------------
//
//  StrAddW
//
//  Helper function to append a string to another.
//  Ensures that it does not overrun target buffer.
//
//  ppStr is ptr to buffer ptr where string is to be appended. On exit, the
//  pointer-to-buffer is updated to point to one past the end of the newly
//  appended text (ie. at the terminating NUL character).
//
//  pchLeft is a ptr to a count of the available characters in the
//  destination buffer. On exit, this is updated to reflect the amount
//  of characters available after the string has been appended.
//
//  There are two versions of StrAddW - one takes a string pointer and a
//  length (in WCHARS), the other just takes a string pointer, and assumes
//  that the string is NUL-terminated.
//
// --------------------------------------------------------------------------


void StrAddW( LPWSTR * ppStr, int * pchLeft, LPCWSTR pStrAdd, int cchAddLen )
{
    // Make sure there's at least 1 char space (for NUL)
    if( *pchLeft <= 0 )
        return;
    // Get min of target string, space left...
    if( cchAddLen > *pchLeft - 1 )
        cchAddLen = *pchLeft - 1;
    // This copies up to but not including the NUL char in the terget string...
    memcpy( *ppStr, pStrAdd, cchAddLen * sizeof( WCHAR ) );
    // Advance pointer, devrement space remaining count...
    *ppStr += cchAddLen;
    *pchLeft -= cchAddLen;
    // Add terminating NUL...
    **ppStr = '\0';
}


void StrAddW( LPWSTR * ppStr, int * pchLeft, LPCWSTR pStrAdd )
{
    StrAddW( ppStr, pchLeft, pStrAdd, lstrlenW( pStrAdd ) );
}





// --------------------------------------------------------------------------
//
//  GetRichEditText
//
//  Gets full text - including text from objects - from a rich edit control.
//
//  hwnd is handle to the richedit control.
//  pWStr and cchWStrMax are the destination buffer and available space (in
//  WCHARs, includes space for terminating NUL).
//
//  Returns TRUE if text could be retrieved.
//
// --------------------------------------------------------------------------


BOOL GetRichEditText( HWND hwnd, LPWSTR pWStr, int cchWStrMax )
{
    BOOL fGot = FALSE;

    //
    //  Get a pointer to the TOM automation object...
    //
    IDispatch * pdispDoc = NULL;
    HRESULT hr = AccessibleObjectFromWindow( hwnd, OBJID_NATIVEOM, IID_IDispatch, (void **) & pdispDoc );
    if( hr != S_OK || pdispDoc == NULL )
    {
        TraceErrorHR( hr, TEXT("GetRichEditText: AccessibleObjectFromWindow failed") );
        return FALSE;
    }

    //
    // Get a range representing the entire doc...
    //

    // This gets an empty range at the start of the doc. We later Expand it to entire doc...

    VARIANT varRange;
    hr = InvokeMethod( pdispDoc, L"Range", & varRange, 2,
                       VT_I4, 0,
                       VT_I4, 0 );
    if( hr != S_OK )
    {
        TraceErrorHR( hr, TEXT("GetRichEditText: Range method failed") );
    }
    else if( varRange.vt != VT_DISPATCH || varRange.pdispVal == NULL )
    {
        VariantClear( & varRange );
        TraceError( TEXT("GetRichEditText: Range method failed returned non-disp, or NULL-disp") );
    }
    else
    {
        IDispatch * pdispRange = varRange.pdispVal;

        // Set range to entire story...
        VARIANT varDelta;
        hr = InvokeMethod( pdispRange, L"Expand", & varDelta, 1, VT_I4, 6 /*tomStory*/ );
        if( hr != S_OK )
        {
            TraceErrorHR( hr, TEXT("GetRichEditText: Range::GetStoryLength failed or returned non-VT_I4") );
        }
        else
        {
            //
            // Get all text from the range...
            //

            VARIANT varText;
            hr = GetProperty( pdispRange, L"Text", & varText );
            if( hr != S_OK || varText.vt != VT_BSTR || varText.bstrVal == NULL )
            {
                TraceError( TEXT("GetRichEditText: Text property failed / is non-BSTR / is NULL") );
            }
            else
            {
                // At this stage, we've got the text. We may not be able to expand
                // the objects, but we can at least use a '?' for those that don't
                // support the object->text technique.
                fGot = TRUE;

                //
                // Scan through the text - copy regular text to the output buffer,
                // also look for the object replacement char (0xFFFC), and attempt
                // to get the corresponding object and its text, and copy to
                // buffer.
                //

                LPCWSTR pScan = varText.bstrVal;
                for( ; ; )
                {
                    // Rember start of this block of plain text...
                    LPCWSTR pStart = pScan;

                    // Look for end of string, or object replacement char...
                    while( *pScan != '\0' && *pScan != 0xFFFC )
                    {                    
                        pScan++;
                    }

                    // Copy plain text so far to output buffer...
                    StrAddW( & pWStr, & cchWStrMax, pStart, (int)(pScan - pStart) );

                    // If this is the end of the string, bail out of loop...
                    if( *pScan == '\0' )
                    {
                        break;
                    }

                    //
                    //  Found an object replacement char - set a range to this
                    //  position, then use it to get the object...
                    //

                    // Set range to point to the obj repl char...
                    hr = InvokeMethod( pdispRange, L"SetRange", NULL, 2,
                                       VT_I4, pScan - varText.bstrVal,
                                       VT_I4, pScan - varText.bstrVal );

                    // Skip over the object replacement char...
                    pScan++;

                    // If we have problems getting the object's text, use a
                    // '?' character instead.
                    if( hr != S_OK )
                    {
                        StrAddW( & pWStr, & cchWStrMax, L"?" );
                        TraceErrorHR( hr, TEXT("GetRichEditText: SetRange failed") );
                    }
                    else
                    {
                        //
                        // Try to get the object...
                        //

                        VARIANT varObject;
                        hr = InvokeMethod( pdispRange, L"GetEmbeddedObject", & varObject, 0 );
                        if( hr != S_OK || varObject.vt != VT_UNKNOWN || varObject.punkVal == NULL )
                        {
                            StrAddW( & pWStr, & cchWStrMax, L"?" );
                            TraceError( TEXT("GetRichEditText: GetEmbeddedObject failed or returned NULL") );
                        }
                        else
                        {
                            //
                            // Got the object - now get its text...
                            //

                            if( ! GetObjectText( varObject.pdispVal, & pWStr, & cchWStrMax ) )
                            {
                                StrAddW( & pWStr, & cchWStrMax, L"?" );
                            }

                            varObject.pdispVal->Release();
                        }
                    }

                    // end of for(;;) loop, start over to look for next object replacement char.
                }
            }
        }

        pdispRange->Release();
    }

    pdispDoc->Release();

    return fGot;
}



// --------------------------------------------------------------------------
//
//  GetObjectText
//
//
//  Attempts to get text from an object, by asking for a IDataObject
//  and querying for text clipboard format.
//
// --------------------------------------------------------------------------

BOOL GetObjectText( IUnknown * punk, LPWSTR * ppWStr, int * pcchWStrMax )
{
    // Try IAccessible first...
    IAccessible * pAcc = NULL;
	HRESULT hr = punk->QueryInterface( IID_IAccessible, (void **) & pAcc );
    if( hr == S_OK && pAcc != NULL )
    {
        VARIANT varChild;
        varChild.vt = VT_EMPTY;
        varChild.lVal = CHILDID_SELF;
        BSTR bstrName = NULL;
        hr = pAcc->get_accName( varChild, & bstrName );
        pAcc->Release();

        if( SUCCEEDED( hr ) && bstrName )
        {
            StrAddW( ppWStr, pcchWStrMax, bstrName );
            SysFreeString( bstrName );

            return TRUE;
        }
    }

    // Didn't get IAccessible (or didn't get a name from it).
    // Try the IDataObject technique instead...

    IDataObject * pdataobj = NULL;
    IOleObject * poleobj = NULL;

    // Try IOleObject::GetClipboardData (which returns an IDataObject) first...
	hr = punk->QueryInterface( IID_IOleObject, (void **) & poleobj );
	if( hr == S_OK )
	{
		hr = poleobj->GetClipboardData( 0, & pdataobj );

        poleobj->Release();
	}

    // If that didn't work (either the QI or the GetClipboardData), try
    // to QI for IDataObject instead...
	if( FAILED( hr ) )
	{
		hr = punk->QueryInterface( IID_IDataObject, (void **)&pdataobj );
	    if( hr != S_OK )
	    {
            return FALSE;
		}
	}

    // Got the IDataObject. Now query it for text formats. Try Unicode first...

    BOOL fGotUnicode = TRUE;

    STGMEDIUM med;
	med.tymed = TYMED_HGLOBAL;
	med.pUnkForRelease = NULL;
	med.hGlobal = NULL;

    FORMATETC fetc;
    fetc.cfFormat = CF_UNICODETEXT;
    fetc.ptd = NULL;
    fetc.dwAspect = DVASPECT_CONTENT;
    fetc.lindex = -1;
    fetc.tymed = TYMED_HGLOBAL;

    hr = pdataobj->GetData( & fetc, & med );

	if( hr != S_OK || med.hGlobal == NULL )
    {
        // If we didn't get Unicode, try for ANSI instead...
        fetc.cfFormat = CF_TEXT;
        fGotUnicode = FALSE;

	    hr = pdataobj->GetData( & fetc, & med );
    }

    // Did we get anything?
	if( hr != S_OK || med.hGlobal == NULL )
    {
        return FALSE;
    }

    // Got the text data. Lock the handle...
    void * pv = GlobalLock( med.hGlobal );

    // Copy the text (convert to Unicode if it's ANSI)...
    if( fGotUnicode )
    {
        StrAddW( ppWStr, pcchWStrMax, (LPWSTR) pv );
    }
    else
    {
        // Don't call MultiByteToWideChar if len is == 0, because then it will
        // return length required, not length copied.
        if( *pcchWStrMax > 0 )
        {
            int len = MultiByteToWideChar( CP_ACP, 0, (LPSTR) pv, -1, *ppWStr, *pcchWStrMax );
            // len includes terminating NUL, which we don't want to count...
            if( len > 0 )
                len--;
            if( len > *pcchWStrMax )
                len = *pcchWStrMax;
            *ppWStr += len;
            *pcchWStrMax += len;
        }
    }

    // Unlock resources and return...
    GlobalUnlock( med.hGlobal ); 

	ReleaseStgMedium( & med );

    pdataobj->Release();

    return TRUE;
}



// --------------------------------------------------------------------------
//
//  InvokeMethod
//
//  Helper for IDispatch::Invoke. Assumes exactly one [out,retval] param.
//  Currently only accepts VT_I4 args.
//
//  pDisp is IDispatch to call method on, pName is Unicode name of method.
//  pvarResult is set to the [out,retval] param.
//  cArgs is number of arguments, is followed by type-value pairs - eg.
//
//  Eg. This calls SetRange( 3, 4 )...
//      InvokeMethod( pdisp, L"SetRange", NULL, 2, VT_I4, 3, VT_I4, 4 );
//
// --------------------------------------------------------------------------


HRESULT InvokeMethod( IDispatch * pDisp, LPCWSTR pName, VARIANT * pvarResult, int cArgs, ... )
{
    // Get dispid for this method name...
    DISPID dispid;
    HRESULT hr = pDisp->GetIDsOfNames( IID_NULL, const_cast< LPWSTR * >( & pName ), 1, LOCALE_SYSTEM_DEFAULT, & dispid );
    if( hr != S_OK )
        return hr;

    // Fill in the arguments...

    VARIANT * pvarArgs = new VARIANT [ cArgs ];
    if( ! pvarArgs )
    {
        return E_OUTOFMEMORY;
    }

    va_list arglist;
    va_start( arglist, cArgs );

    for( int i = 0 ; i < cArgs ; i++ )
    {
        int type = va_arg( arglist, int );

        switch( type )
        {
            case VT_I4:
            {
                pvarArgs[ i ].vt = VT_I4;
                pvarArgs[ i ].lVal = va_arg( arglist, DWORD );
                break;
            }

            default:
            {
                TraceError( TEXT("InvokeMethod passed non-VT_I4 argument.") );
                // Since other args are just VT_I4, we don't need to VariantClear them.
                delete [ ] pvarArgs;
                va_end( arglist );
                return E_INVALIDARG;
            }
        }
    }

    va_end( arglist );


    if( pvarResult )
    {
        pvarResult->vt = VT_EMPTY;
    }

    // Make the call to Invoke...

    DISPPARAMS dispparams;
    dispparams.rgvarg = pvarArgs;
    dispparams.rgdispidNamedArgs = NULL;
    dispparams.cArgs = cArgs;
    dispparams.cNamedArgs = 0;         

    hr = pDisp->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_METHOD,
                        & dispparams, pvarResult, NULL, NULL );

    // Cleanup. (Not much needed - VT_I4's dont need to be VariantClear'd.)

    delete [ ] pvarArgs;

    return hr;
}




// --------------------------------------------------------------------------
//
//  GetProperty
//
//  Helper for IDispatch::Invoke. Returns a property.
//
//  pDisp is IDispatch to call method on, pName is Unicode name of property.
//  pvarResult is set to value of property.
//
// --------------------------------------------------------------------------

HRESULT GetProperty( IDispatch * pDisp, LPCWSTR pName, VARIANT * pvarResult )
{
    // Get dispid for this method name...
    DISPID dispid;
    HRESULT hr = pDisp->GetIDsOfNames( IID_NULL, const_cast< LPWSTR * >( & pName ), 1, LOCALE_SYSTEM_DEFAULT, & dispid );
    if( hr != S_OK )
        return hr;

    pvarResult->vt = VT_EMPTY;

    // Make the call to Invoke...

    DISPPARAMS dispparams;
    dispparams.cArgs = 0;
    dispparams.cNamedArgs = 0;
    dispparams.rgvarg = NULL;
    dispparams.rgdispidNamedArgs = NULL;

    hr = pDisp->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT, DISPATCH_PROPERTYGET,
                        & dispparams, pvarResult, NULL, NULL );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\imports.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  imports
//
//  GetProcAddress'd APIs
//
// --------------------------------------------------------------------------


void InitImports();

#ifdef _DEBUG

void ReportMissingImports( LPTSTR pStr );

#endif // _DEBUG


BOOL    MyGetGUIThreadInfo(DWORD, PGUITHREADINFO);
BOOL    MyGetCursorInfo(LPCURSORINFO);
BOOL    MyGetWindowInfo(HWND, LPWINDOWINFO);
BOOL    MyGetTitleBarInfo(HWND, LPTITLEBARINFO);
BOOL    MyGetScrollBarInfo(HWND, LONG, LPSCROLLBARINFO);
BOOL    MyGetComboBoxInfo(HWND, LPCOMBOBOXINFO);
BOOL    MyGetAltTabInfo(HWND, int, LPALTTABINFO, LPTSTR, UINT);
BOOL    MyGetMenuBarInfo(HWND, long, long, LPMENUBARINFO);
HWND    MyGetAncestor(HWND, UINT);
HWND    MyGetFocus(void);
HWND    MyRealChildWindowFromPoint(HWND, POINT);
UINT    MyGetWindowClass(HWND, LPTSTR, UINT);
DWORD   MyGetListBoxInfo(HWND);
void    MyGetRect(HWND, LPRECT, BOOL);
DWORD   MyGetModuleFileName(HMODULE hModule,LPTSTR lpFilename,DWORD nSize);
PVOID   MyInterlockedCompareExchange(PVOID *,PVOID,PVOID);
LPVOID  MyVirtualAllocEx(HANDLE,LPVOID,DWORD,DWORD,DWORD);
BOOL    MyVirtualFreeEx(HANDLE,LPVOID,DWORD,DWORD);
BOOL    MyBlockInput(BOOL);
BOOL    MySendInput(UINT cInputs, LPINPUT pInputs, INT cbSize);
LONG	MyNtQueryInformationProcess(HANDLE, INT, PVOID, ULONG, PULONG);


// These two are used directly in sdm.h - all other imports are used via the MyXXX wrappers.
typedef LPVOID (STDAPICALLTYPE* LPFNMAPLS)(LPVOID);
typedef VOID (STDAPICALLTYPE* LPFNUNMAPLS)(LPVOID);
extern LPFNMAPLS               lpfnMapLS;          // KERNEL32 MapLS()
extern LPFNUNMAPLS             lpfnUnMapLS;        // KERNEL32 UnMapLS()



void * Alloc_32BitCompatible( SIZE_T cbSize );
void Free_32BitCompatible( void * pv );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\imports.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  imports
//
//  GetProcAddress'd APIs
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"

// #include "imports.h" - already in oleacc_p.h

#include "w95trace.h"

typedef BOOL (STDAPICALLTYPE *LPFNGETGUITHREADINFO)(DWORD, PGUITHREADINFO);
typedef BOOL (STDAPICALLTYPE *LPFNGETCURSORINFO)(LPCURSORINFO);
typedef BOOL (STDAPICALLTYPE *LPFNGETWINDOWINFO)(HWND, LPWINDOWINFO);
typedef BOOL (STDAPICALLTYPE *LPFNGETTITLEBARINFO)(HWND, LPTITLEBARINFO);
typedef BOOL (STDAPICALLTYPE *LPFNGETSCROLLBARINFO)(HWND, LONG, LPSCROLLBARINFO);
typedef BOOL (STDAPICALLTYPE *LPFNGETCOMBOBOXINFO)(HWND, LPCOMBOBOXINFO);
typedef HWND (STDAPICALLTYPE *LPFNGETANCESTOR)(HWND, UINT);
typedef HWND (STDAPICALLTYPE *LPFNREALCHILDWINDOWFROMPOINT)(HWND, POINT);
typedef UINT (STDAPICALLTYPE *LPFNREALGETWINDOWCLASS)(HWND, LPTSTR, UINT);
typedef BOOL (STDAPICALLTYPE *LPFNGETALTTABINFO)(HWND, int, LPALTTABINFO, LPTSTR, UINT);
typedef BOOL (STDAPICALLTYPE *LPFNGETMENUBARINFO)(HWND, LONG, LONG, LPMENUBARINFO);
typedef DWORD (STDAPICALLTYPE* LPFNGETLISTBOXINFO)(HWND);
typedef BOOL (STDAPICALLTYPE *LPFNSENDINPUT)(UINT, LPINPUT, INT);
typedef BOOL (STDAPICALLTYPE *LPFNBLOCKINPUT)(BOOL);
typedef DWORD (STDAPICALLTYPE* LPFNGETMODULEFILENAME)(HMODULE,LPTSTR,DWORD); 
typedef PVOID (STDAPICALLTYPE* LPFNINTERLOCKCMPEXCH)(PVOID *,PVOID,PVOID);
typedef LPVOID (STDAPICALLTYPE* LPFNVIRTUALALLOCEX)(HANDLE,LPVOID,DWORD,DWORD,DWORD);
typedef BOOL (STDAPICALLTYPE* LPFNVIRTUALFREEEX)(HANDLE,LPVOID,DWORD,DWORD);
typedef LONG (STDAPICALLTYPE* LPFNNTQUERYINFORMATIONPROCESS)(HANDLE,INT,PVOID,ULONG,PULONG);
typedef LONG (STDAPICALLTYPE* LPFNNTALLOCATEVIRTUALMEMORY)(HANDLE,PVOID *,ULONG_PTR,PSIZE_T,ULONG,ULONG);
typedef LONG (STDAPICALLTYPE* LPFNNTFREEVIRTUALMEMORY)(HANDLE,PVOID *,PSIZE_T,ULONG);




LPFNGETGUITHREADINFO    lpfnGuiThreadInfo;  // USER32 GetGUIThreadInfo()
LPFNGETCURSORINFO       lpfnCursorInfo;     // USER32 GetCursorInfo()
LPFNGETWINDOWINFO       lpfnWindowInfo;     // USER32 GetWindowInfo()
LPFNGETTITLEBARINFO     lpfnTitleBarInfo;   // USER32 GetTitleBarInfo()
LPFNGETSCROLLBARINFO    lpfnScrollBarInfo;  // USER32 GetScrollBarInfo()
LPFNGETCOMBOBOXINFO     lpfnComboBoxInfo;   // USER32 GetComboBoxInfo()
LPFNGETANCESTOR         lpfnGetAncestor;    // USER32 GetAncestor()
LPFNREALCHILDWINDOWFROMPOINT    lpfnRealChildWindowFromPoint;   // USER32 RealChildWindowFromPoint
LPFNREALGETWINDOWCLASS  lpfnRealGetWindowClass; // USER32 RealGetWindowClass()
LPFNGETALTTABINFO       lpfnAltTabInfo;     // USER32 GetAltTabInfo()
LPFNGETLISTBOXINFO      lpfnGetListBoxInfo; // USER32 GetListBoxInfo()
LPFNGETMENUBARINFO      lpfnMenuBarInfo;    // USER32 GetMenuBarInfo()
LPFNSENDINPUT           lpfnSendInput;      // USER32 SendInput()
LPFNBLOCKINPUT          lpfnBlockInput;      // USER32 BlockInput()
LPFNGETMODULEFILENAME   lpfnGetModuleFileName;	// KERNEL32 GetModuleFileName()

LPFNMAPLS               lpfnMapLS;          // KERNEL32 MapLS()
LPFNUNMAPLS             lpfnUnMapLS;        // KERNEL32 UnMapLS()

LPFNINTERLOCKCMPEXCH    lpfnInterlockedCompareExchange;  // NT KERNEL32 InterlockedCompareExchange
LPFNVIRTUALALLOCEX      lpfnVirtualAllocEx; // NT KERNEL32 VirtualAllocEx
LPFNVIRTUALFREEEX       lpfnVirtualFreeEx;  // NT KERNEL32 VirtualFreeEx

LPFNNTQUERYINFORMATIONPROCESS lpfnNtQueryInformationProcess; // NTDLL NtQueryInformationProcess
LPFNNTALLOCATEVIRTUALMEMORY   lpfnNtAllocateVirtualMemory; // NTDLL NtAllocateVirtualMemory
LPFNNTFREEVIRTUALMEMORY       lpfnNtFreeVirtualMemory; // NTDLL NtAllocateVirtualMemory



// Try getting pName1 first; if that fails, try pName2 instead.
// Both names are in ANSI, since GetProcAddress always takes ANSI names.
struct ImportInfo
{
    void *  ppfn;
    int     iModule;
    BOOL    fNTOnly;
    LPCSTR  pName1;
    LPCSTR  pName2;
};


enum {
    M_USER, // 0
    M_KERN, // 1
	M_NTDLL,// 2
};

// _AW_ means add the ...A or ...W suffix as appropriate, for Ansi or Unicode compiles.
// _AONLY_ means only do this on Ansi builds - evaluates to NULL on Unicode compiles.

#ifdef UNICODE
#define _AW_ "W"
#define _AONLY_( str ) NULL
#else
#define _AW_ "A"
#define _AONLY_( str ) str
#endif

ImportInfo g_Imports [ ] =
{
    // USER Imports...
    { & lpfnGuiThreadInfo,              M_USER,  FALSE,  "GetGUIThreadInfo"            },
    { & lpfnCursorInfo,                 M_USER,  FALSE,  "GetAccCursorInfo",           "GetCursorInfo"                 },
    { & lpfnWindowInfo,                 M_USER,  FALSE,  "GetWindowInfo"               },
    { & lpfnTitleBarInfo,               M_USER,  FALSE,  "GetTitleBarInfo"             },
    { & lpfnScrollBarInfo,              M_USER,  FALSE,  "GetScrollBarInfo"            },
    { & lpfnComboBoxInfo,               M_USER,  FALSE,  "GetComboBoxInfo"             },
    { & lpfnGetAncestor,                M_USER,  FALSE,  "GetAncestor"                 },
    { & lpfnRealChildWindowFromPoint,   M_USER,  FALSE,  "RealChildWindowFromPoint"    },
    { & lpfnRealGetWindowClass,         M_USER,  FALSE,  "RealGetWindowClass" _AW_,    _AONLY_( "RealGetWindowClass" ) },
    { & lpfnAltTabInfo,                 M_USER,  FALSE,  "GetAltTabInfo" _AW_,         _AONLY_( "GetAltTabInfo" )      },
    { & lpfnGetListBoxInfo,             M_USER,  FALSE,  "GetListBoxInfo"              },
    { & lpfnMenuBarInfo,                M_USER,  FALSE,  "GetMenuBarInfo"              },
    { & lpfnSendInput,                  M_USER,  FALSE,  "SendInput"                   },
    { & lpfnBlockInput,                 M_USER,  FALSE,  "BlockInput"                  },

    // KERNEL imports...
    { & lpfnMapLS,                      M_KERN,  FALSE,  "MapLS"                       },
    { & lpfnUnMapLS,                    M_KERN,  FALSE,  "UnMapLS"                     },
    { & lpfnGetModuleFileName,          M_KERN,  FALSE,  "GetModuleFileName" _AW_      },

    // KERNEL imports - NT only...
    { & lpfnInterlockedCompareExchange, M_KERN,  TRUE,   "InterlockedCompareExchange"  },
    { & lpfnVirtualAllocEx,             M_KERN,  TRUE,   "VirtualAllocEx"              },
    { & lpfnVirtualFreeEx,              M_KERN,  TRUE,   "VirtualFreeEx"               },

	// NTDLL imports - NT only...
	{ & lpfnNtQueryInformationProcess,  M_NTDLL, TRUE,   "NtQueryInformationProcess"   },
	{ & lpfnNtAllocateVirtualMemory,    M_NTDLL, TRUE,   "NtAllocateVirtualMemory"     },
	{ & lpfnNtFreeVirtualMemory,        M_NTDLL, TRUE,   "NtFreeVirtualMemory"         },
};




#ifdef _DEBUG
LPCTSTR g_ImportNames [ ] =
{
    // USER Imports...
    TEXT("GetGUIThreadInfo"),
    TEXT("GetAccCursorInfo"),
    TEXT("GetWindowInfo"),
    TEXT("GetTitleBarInfo"),
    TEXT("GetScrollBarInfo"),
    TEXT("GetComboBoxInfo"),
    TEXT("GetAncestor"),
    TEXT("RealChildWindowFromPoint"),
    TEXT("RealGetWindowClass"),
    TEXT("GetAltTabInfo"),
    TEXT("GetListBoxInfo"),
    TEXT("GetMenuBarInfo"),
    TEXT("SendInput"),
    TEXT("BlockInput"),

    // KERNEL imports...
    TEXT("MapLS"),
    TEXT("UnMapLS"),
    TEXT("GetModuleFileName"),

    // KERNEL imports - NT only...
    TEXT("InterlockedCompareExchange"),
    TEXT("VirtualAllocEx"),
    TEXT("VirtualFreeEx"),

	// NTDLL imports - NT only...
	TEXT("NtQueryInformationProcess"),
	TEXT("NtAllocateVirtualMemory"),
};
#endif // _DEBUG







void ImportFromModule( HMODULE * pahModule, ImportInfo * pInfo, int cInfo )
{
    for( ; cInfo ; pInfo++, cInfo-- )
    {
        HMODULE hModule = pahModule[ pInfo->iModule ];

        FARPROC pfnAddress = GetProcAddress( hModule, pInfo->pName1 );

        // If that didn't work, try the alternate name, if it exists...
        if( ! pfnAddress && pInfo->pName2 )
        {
            pfnAddress = GetProcAddress( hModule, pInfo->pName2 );
        }

        *( (FARPROC *) pInfo->ppfn ) = pfnAddress;
    }
}


void InitImports()
{
    HMODULE hModules[ 3 ];

    hModules[ 0 ] = GetModuleHandle( TEXT("USER32.DLL") );
    hModules[ 1 ] = GetModuleHandle( TEXT("KERNEL32.DLL") );
	hModules[ 2 ] = GetModuleHandle( TEXT("NTDLL.DLL") );

    ImportFromModule( hModules, g_Imports, ARRAYSIZE( g_Imports ) );
}


#ifdef _DEBUG

void ReportMissingImports( LPTSTR pStr )
{
    *pStr = '\0';

    for( int c = 0 ; c < ARRAYSIZE( g_Imports ) ; c++ )
    {
        if( * (FARPROC *) g_Imports[ c ].ppfn == NULL )
        {
            // Only report the NT-only ones when on 9x...
#ifdef _X86_
            if( ! g_Imports[ c ].fNTOnly || ! fWindows95 )
#endif // _X86_
            {
                lstrcat( pStr, g_ImportNames[ c ] );
                lstrcat( pStr, TEXT("\r\n") );
            }
        }
    }
}

#endif // _DEBUG



// --------------------------------------------------------------------------
//
//  MyGetGUIThreadInfo()
//
//  Calls USER32 function if present.  Fills in cbSize field to save callers
//  some code.
//
// --------------------------------------------------------------------------
BOOL MyGetGUIThreadInfo(DWORD idThread, PGUITHREADINFO lpGui)
{
    if (! lpfnGuiThreadInfo)
        return(FALSE);

    lpGui->cbSize = sizeof(GUITHREADINFO);
    return((* lpfnGuiThreadInfo)(idThread, lpGui));
}


// --------------------------------------------------------------------------
//
//  MyGetCursorInfo()
//
//  Calls USER32 function if present.  Fills in cbSize field to save callers
//  some code.
//
// --------------------------------------------------------------------------
BOOL MyGetCursorInfo(LPCURSORINFO lpci)
{
    if (! lpfnCursorInfo)
        return(FALSE);

    lpci->cbSize = sizeof(CURSORINFO);
    return((* lpfnCursorInfo)(lpci));
}


// --------------------------------------------------------------------------
//
//  MyGetWindowInfo()
//
//  Calls USER32 function if present.  Fills in cbSize field to save callers
//  some code.
//
// --------------------------------------------------------------------------
BOOL MyGetWindowInfo(HWND hwnd, LPWINDOWINFO lpwi)
{
    if (!IsWindow(hwnd))
    {
        DBPRINTF (TEXT("OLEACC: warning - calling MyGetWindowInfo for bad hwnd 0x%x\r\n"),hwnd);
        return (FALSE);
    }

    if (! lpfnWindowInfo)
    {
        // BOGUS
        // beginning of a hack for NT4
        {
            GetWindowRect(hwnd,&lpwi->rcWindow);
            GetClientRect( hwnd, & lpwi->rcClient );
			// Convert client rect to screen coords...
			MapWindowPoints( hwnd, NULL, (POINT *) & lpwi->rcClient, 2 );
            lpwi->dwStyle = GetWindowLong (hwnd,GWL_STYLE);
            lpwi->dwExStyle = GetWindowLong (hwnd,GWL_EXSTYLE);
            lpwi->dwWindowStatus = 0; // should have WS_ACTIVECAPTION in here if active
            lpwi->cxWindowBorders = 0; // wrong
            lpwi->cyWindowBorders = 0; // wrong
            lpwi->atomWindowType = 0;  // wrong, but not used anyways
            lpwi->wCreatorVersion = 0; // wrong, only used in SDM proxy. The "WINVER"
            return (TRUE);

        } // end hack for NT4
        return(FALSE);
    }

    lpwi->cbSize = sizeof(WINDOWINFO);
    return((* lpfnWindowInfo)(hwnd, lpwi));
}



// --------------------------------------------------------------------------
//
//  MyGetMenuBarInfo()
//
//  Calls USER32 function if present.  Fills in cbSize field to save callers
//  some code.
//
// --------------------------------------------------------------------------
BOOL MyGetMenuBarInfo(HWND hwnd, long idObject, long idItem, LPMENUBARINFO lpmbi)
{
    if( ! lpfnMenuBarInfo )
        return FALSE;

    // Get the hMenu, and then check that it is valid...
    // We can only do this for _MENU and _CLIENT.
    // Can't use GetSystemMenu for _SYSMENU, since that API *modifies* the
    // system menu of the given hwnd.
    if( idObject == OBJID_MENU || 
        idObject == OBJID_CLIENT )
    {
        HMENU hMenu;

        if( idObject == OBJID_MENU )
        {
            // GetMenu is not defined for child windows
            DWORD dwStyle = GetWindowLong( hwnd, GWL_STYLE );
            if( dwStyle & WS_CHILD )
            {
                hMenu = 0;
            }
            else
            {
        	    hMenu = GetMenu( hwnd );
            }
        }
        else
        {
		    hMenu = (HMENU)SendMessage( hwnd, MN_GETHMENU, 0, 0 );
        }


        if( ! hMenu || ! IsMenu( hMenu ) )
        {
            // If we didn't get a valid menu, quit now...
            return FALSE;
        }
    }
    else if( idObject != OBJID_SYSMENU )
    {
    	return FALSE;
    }


	lpmbi->cbSize = sizeof( MENUBARINFO );
	return lpfnMenuBarInfo( hwnd, idObject, idItem, lpmbi );
}



// --------------------------------------------------------------------------
//
//  MyGetTitleBarInfo()
//
//  Calls USER32 function if present.  Fills in cbSize field to save callers
//  some code.
//
// --------------------------------------------------------------------------
BOOL MyGetTitleBarInfo(HWND hwnd, LPTITLEBARINFO lpti)
{
    if (! lpfnTitleBarInfo)
        return(FALSE);

    lpti->cbSize = sizeof(TITLEBARINFO);
    return((* lpfnTitleBarInfo)(hwnd, lpti));
}


// --------------------------------------------------------------------------
//
//  MyGetScrollBarInfo
//
//  Calls USER32 function if present.  Fills in cbSize field to save callers
//  some code.
//
// --------------------------------------------------------------------------
BOOL MyGetScrollBarInfo(HWND hwnd, LONG idObject, LPSCROLLBARINFO lpsbi)
{
    if (! lpfnScrollBarInfo)
        return(FALSE);

    lpsbi->cbSize = sizeof(SCROLLBARINFO);
    return((* lpfnScrollBarInfo)(hwnd, idObject, lpsbi));
}


// --------------------------------------------------------------------------
//
//  MyGetComboBoxInfo()
//
//  Calls USER32 if present.  Fills in cbSize field for callers.
//
// --------------------------------------------------------------------------
BOOL MyGetComboBoxInfo(HWND hwnd, LPCOMBOBOXINFO lpcbi)
{
    if (! lpfnComboBoxInfo)
        return(FALSE);

    lpcbi->cbSize = sizeof(COMBOBOXINFO);
    BOOL b = ((* lpfnComboBoxInfo)(hwnd, lpcbi));

    // Some comboxes (eg. comctlV6 port) without edits return a hwndItem
    // equal to the combo hwnd instead of NULL (Their logic is that they are
    // using themselves as the edit...) We compensate for this here...
    if( lpcbi->hwndItem == lpcbi->hwndCombo )
    {
        // item == combo means this combo doesn't have an edit...
        lpcbi->hwndItem = NULL;
    }

    // ComboEx's have their own child edit that the real COMBO doesn't
    // know about - try and find it...
    // (This may also be called on a ComboLBox list - but we're safe here
    // since it won't have children anyway.)
    if( b && lpcbi->hwndItem == NULL )
    {
        lpcbi->hwndItem = FindWindowEx( hwnd, NULL, TEXT("EDIT"), NULL );
        if( lpcbi->hwndItem )
        {
            // Get real item area from area of Edit.
            // (In a ComboEx, there's a gap between the left edge of the
            // combo and the left edge of the Edit, where an icon is drawn)
            GetWindowRect( lpcbi->hwndItem, & lpcbi->rcItem );
            MapWindowPoints( HWND_DESKTOP, hwnd, (POINT*)& lpcbi->rcItem, 2 );
        }
    }

    return b;
}


// --------------------------------------------------------------------------
//
//  MyGetAncestor()
//
//  This gets the ancestor window where
//      GA_PARENT   gets the "real" parent window
//      GA_ROOT     gets the "real" top level parent window (not inc. owner)
//      GA_ROOTOWNER    gets the "real" top level parent owner
//
//      * The _real_ parent.  This does NOT include the owner, unlike
//          GetParent().  Stops at a top level window unless we start with
//          the desktop.  In which case, we return the desktop.
//      * The _real_ root, caused by walking up the chain getting the
//          ancestor.
//      * The _real_ owned root, caused by GetParent()ing up.
//
//  Note: On Win98, USER32's winable.c:GetAncestor(GA_ROOT) faults is called
//  on the invisible alt-tab or system pupop windows. To work-around, we're
//  simulating GA_ROOT by looping GA_PARENT (which is actually what winable.c
//  does, only we're more careful about checking for NULL handles...)
//  - see MSAA bug #891
// --------------------------------------------------------------------------
HWND MyGetAncestor(HWND hwnd, UINT gaFlags)
{
    if (! lpfnGetAncestor)
    {
        // BOGUS        
        // This block is here to work around the lack of this function in NT4.
        // It is modeled on the code in winable2.c in USER. 
        {
            HWND	hwndParent;
            HWND	hwndDesktop;
            DWORD   dwStyle;
            
            if (!IsWindow(hwnd))
            {
                //DebugErr(DBF_ERROR, "MyGetAncestor: Bogus window");
                return(NULL);
            }
            
            if ((gaFlags < GA_MIN) || (gaFlags > GA_MAX))
            {
                //DebugErr(DBF_ERROR, "MyGetAncestor: Bogus flags");
                return(NULL);
            }
            
            hwndDesktop = GetDesktopWindow();
            if (hwnd == hwndDesktop)
                return(NULL);
            dwStyle = GetWindowLong (hwnd,GWL_STYLE);
            
            switch (gaFlags)
            {
            case GA_PARENT:
                if (dwStyle & WS_CHILD)
                    hwndParent = GetParent(hwnd);
                else
                    hwndParent = GetWindow (hwnd,GW_OWNER);
				hwnd = hwndParent;
                break;
                
            case GA_ROOT:
                if (dwStyle & WS_CHILD)
                    hwndParent = GetParent(hwnd);
                else
                    hwndParent = GetWindow (hwnd,GW_OWNER);
                while (hwndParent != hwndDesktop &&
                    hwndParent != NULL)
                {
                    hwnd = hwndParent;
                    dwStyle = GetWindowLong(hwnd,GWL_STYLE);
                    if (dwStyle & WS_CHILD)
                        hwndParent = GetParent(hwnd);
                    else
                        hwndParent = GetWindow (hwnd,GW_OWNER);
                }
                break;
                
            case GA_ROOTOWNER:
                while (hwndParent = GetParent(hwnd))
                    hwnd = hwndParent;
                break;
            }
            
            return(hwnd);
        } // end of the workaround block for NT4
        
        return(FALSE);
    }
	else if( gaFlags == GA_ROOT )
	{
		// BOGUS
		// work-around for win98-user inability to handle GA_ROOT
		// correctly on alt-tab (WinSwitch) and Popup windows
		// - see MSAA bug #891

		// (Asise: we *could* special-case 98vs95 - ie. call
		// GA_ROOT as usual on 95 and special case only on 98...
		// Non special-case-ing may be slightly more inefficient, but
		// means that when testing, there's only *one* code path,
		// so we don't have to worry about ensuring that the
		// win95 version behaves the same as the win98 one.)
        HWND hwndDesktop = GetDesktopWindow();

        if( ! IsWindow( hwnd ) )
            return NULL;

		// Climb up through parents - stop if parent is desktop - or NULL...
		for( ; ; )
		{
			HWND hwndParent = lpfnGetAncestor( hwnd, GA_PARENT );
			if( hwndParent == NULL || hwndParent == hwndDesktop )
				break;
			hwnd = hwndParent;
		}

		return hwnd;
	}
	else
	{
        return lpfnGetAncestor(hwnd, gaFlags);
	}
}


// --------------------------------------------------------------------------
//
//  MyRealChildWindowFromPoint()
//
// --------------------------------------------------------------------------
#if 0
// Old version - called USER's 'RealChildWindowFromPoint'.
HWND MyRealChildWindowFromPoint(HWND hwnd, POINT pt)
{
    if (! lpfnRealChildWindowFromPoint)
    {
        // BOGUS
        // beginning of a hack for NT4
        {
            return (ChildWindowFromPoint(hwnd,pt));
        } // end of a hack for NT4
        return(NULL);
    }

    return((* lpfnRealChildWindowFromPoint)(hwnd, pt));
}
#endif

/*
 *  Similar to USER's ChildWindowFromPoint, except this
 *  checks the HT_TRANSPARENT bit.
 *  USER's ChildWindowFromPoint can't "see through" groupboxes or
 *      other HTTRANSPARENT things,
 *  USER's RealChildWindowFromPoint can "see through" groupboxes but
 *      not other HTTRANSPARENT things (it special cases only groupboxes!)
 *  This can see through anything that responds to WM_NCHITTEST with
 *      HTTRANSPARENT.
 */
HWND MyRealChildWindowFromPoint( HWND hwnd,
                                 POINT pt )
{
    HWND hBestFitTransparent = NULL;
    RECT rcBest;

    // Translate hwnd-relative points to screen-relative...
    MapWindowPoints( hwnd, NULL, & pt, 1 );

    // Infinite looping is 'possible' (though unlikely) when
    // using GetWindow(...NEXT), so we counter-limit this loop...
    int SanityLoopCount = 1024;
    for( HWND hChild = GetWindow( hwnd, GW_CHILD ) ;
         hChild && --SanityLoopCount ;
         hChild = GetWindow( hChild, GW_HWNDNEXT ) )
    {
        // Skip invisible...
        if( ! IsWindowVisible( hChild ) )
            continue;

        // Check for rect...
        RECT rc;
        GetWindowRect( hChild, & rc );
        if( ! PtInRect( & rc, pt ) )
            continue;

        // Try for transparency...
        LRESULT lr = SendMessage( hChild, WM_NCHITTEST, 0, MAKELPARAM( pt.x, pt.y ) );
        if( lr == HTTRANSPARENT )
        {
            // For reasons best known to the writers of USER, statics - used
            // as labels - claim to be transparent. So that we do hit-test
            // to these, we remember the hwnd here, so if nothing better
            // comes along, we'll use this.

            // If we come accross two or more of these, we remember the
            // one that fts inside the other - if any. That way,
            // we hit-test to siblings 'within' siblings - eg. statics in
            // a groupbox.

            if( ! hBestFitTransparent )
            {
                hBestFitTransparent = hChild;
                GetWindowRect( hChild, & rcBest );
            }
            else
            {
                // Is this child within the last remembered transparent?
                // If so, remember it instead.
                RECT rcChild;
                GetWindowRect( hChild, & rcChild );
                if( rcChild.left >= rcBest.left &&
                    rcChild.top >= rcBest.top &&
                    rcChild.right <= rcBest.right &&
                    rcChild.bottom <= rcBest.bottom )
                {
                    hBestFitTransparent = hChild;
                    rcBest = rcChild;
                }
            }

            continue;
        }

        // Got the window!
        return hChild;
    }

    if( SanityLoopCount == 0 )
        return NULL;

    // Did we find a transparent (eg. a static) on our travels? If so, since
    // we couldn't find anything better, may as well use it.
    if( hBestFitTransparent )
        return hBestFitTransparent;

    // Otherwise return the original window (not NULL!) if no child found...
    return hwnd;
}

// --------------------------------------------------------------------------
//
//  MyGetWindowClass()
//
//  Gets the "real" window type, works for superclassers like "ThunderEdit32"
//  and so on.
//
// --------------------------------------------------------------------------
UINT MyGetWindowClass(HWND hwnd, LPTSTR lpszName, UINT cchName)
{
    *lpszName = 0;

    if (! lpfnRealGetWindowClass)
	{
		// BOGUS 
        // Hack for NT 4
        {
		    return (GetClassName(hwnd,lpszName,cchName));
        } // end of hack for NT 4
        return(0);
	}

    return((* lpfnRealGetWindowClass)(hwnd, lpszName, cchName));
}


// --------------------------------------------------------------------------
//
//  MyGetAltTabInfo()
//
//  Gets the alt tab information
//
// --------------------------------------------------------------------------
BOOL MyGetAltTabInfo(HWND hwnd, int iItem, LPALTTABINFO lpati, LPTSTR lpszItem,
    UINT cchItem)
{
    if (! lpfnAltTabInfo)
        return(FALSE);

    lpati->cbSize = sizeof(ALTTABINFO);

    return((* lpfnAltTabInfo)(hwnd, iItem, lpati, lpszItem, cchItem));
}



// --------------------------------------------------------------------------
//
//  MyGetListBoxInfo()
//
//  Gets the # of items per column currently in a listbox
//
// --------------------------------------------------------------------------
DWORD MyGetListBoxInfo(HWND hwnd)
{
    if (! lpfnGetListBoxInfo)
        return(0);

    return((* lpfnGetListBoxInfo)(hwnd));
}
                                         

// --------------------------------------------------------------------------
//
//  MySendInput()
//
//  Calls USER32 function if present.
//
// --------------------------------------------------------------------------
BOOL MySendInput(UINT cInputs, LPINPUT pInputs, INT cbSize)
{
    if (! lpfnSendInput)
        return(FALSE);

    return((* lpfnSendInput)(cInputs,pInputs,cbSize));
}

//--------------------------------------------------------
// [v-jaycl, 6/7/97] Added MyBlockInput support for NT 4.0 
//--------------------------------------------------------

// --------------------------------------------------------------------------
//
//  MyBlockInput()
//
//  Calls USER32 function if present.
//
// --------------------------------------------------------------------------
BOOL MyBlockInput(BOOL bBlock)
{
    if (! lpfnBlockInput)
        return(FALSE);

    return((* lpfnBlockInput)( bBlock ) );
}

// --------------------------------------------------------------------------
//  MyInterlockedCompareExchange
//
//  Calls the function when we are running on NT
// --------------------------------------------------------------------------
PVOID MyInterlockedCompareExchange(PVOID *Destination,PVOID Exchange,PVOID Comperand)
{
    if (!lpfnInterlockedCompareExchange)
        return (NULL);

    return ((* lpfnInterlockedCompareExchange)(Destination,Exchange,Comperand));
}

// --------------------------------------------------------------------------
//  MyVirtualAllocEx
//
//  Calls the function when we are running on NT
// --------------------------------------------------------------------------
LPVOID MyVirtualAllocEx(HANDLE hProcess,LPVOID lpAddress,DWORD dwSize,DWORD flAllocationType,DWORD flProtect)
{
    if (!lpfnVirtualAllocEx)
        return (NULL);

    return ((* lpfnVirtualAllocEx)(hProcess,lpAddress,dwSize,flAllocationType,flProtect));
}

// --------------------------------------------------------------------------
//  MyVirtualFreeEx
//
//  Calls the function when we are running on NT.
// --------------------------------------------------------------------------
BOOL MyVirtualFreeEx(HANDLE hProcess,LPVOID lpAddress,DWORD dwSize,DWORD dwFreeType)
{
    if (!lpfnVirtualFreeEx)
        return (FALSE);

    return ((* lpfnVirtualFreeEx)(hProcess,lpAddress,dwSize,dwFreeType));
}

// --------------------------------------------------------------------------
//  MyGetModuleFileName
// --------------------------------------------------------------------------
DWORD MyGetModuleFileName(HMODULE hModule,LPTSTR lpFilename,DWORD nSize)
{
    if (!lpfnGetModuleFileName)
        return (0);

    return ((* lpfnGetModuleFileName)(hModule,lpFilename,nSize));
}

// --------------------------------------------------------------------------
//  MyNtQueryInformationProcess
//
//  Calls the function when we are running on NT.
// --------------------------------------------------------------------------
LONG MyNtQueryInformationProcess(HANDLE hProcess, INT iProcInfo, PVOID pvBuf, ULONG ccbBuf, PULONG pulRetLen)
{
	if (!lpfnNtQueryInformationProcess)
		return -1;

	return (* lpfnNtQueryInformationProcess)(hProcess, iProcInfo, pvBuf, ccbBuf, pulRetLen);
}




void * Alloc_32BitCompatible( SIZE_T cbSize )
{

#ifndef _WIN64

    return new BYTE [ cbSize ];

#else

    if( ! lpfnNtAllocateVirtualMemory
     || ! lpfnNtFreeVirtualMemory )
    {
        return new BYTE [ cbSize ];
    }

    // Note that the mask-style of the ZeroBits param only works on Win64. This
    // mask specifies which bits may be used in the address. 7FFFFFFF -> 31-bit
    // address

    // ISSUE-2000/08/11-brendanm
    // Since granularity of returned blocks is 64k, we should do some sort of
    // block suballocation to avoid wasting memory.

    PVOID pBaseAddress = NULL;
    LONG ret = lpfnNtAllocateVirtualMemory( GetCurrentProcess(),
                                            & pBaseAddress,
                                            0x7FFFFFFF,
                                            & cbSize,
                                            MEM_COMMIT,
                                            PAGE_READWRITE );

    if( ret < 0 )
    {
        return NULL;
    }

    return pBaseAddress;

#endif

}


void Free_32BitCompatible( void * pv )
{

#ifndef _WIN64

    delete [ ] (BYTE *) pv;

#else

    if( ! lpfnNtAllocateVirtualMemory
     || ! lpfnNtFreeVirtualMemory )
    {
        delete [ ] (BYTE *) pv;
    }

    DWORD_PTR cbSize = 0;
    lpfnNtFreeVirtualMemory( GetCurrentProcess(), & pv, & cbSize, MEM_RELEASE );

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\hotkey.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  HOTKEY.CPP
//
//  This knows how to talk to COMCTL32's HOTKEY control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "hotkey.h"


#define NOTOOLBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOPROGRESS
#define NOSTATUSBAR
#define NOHEADER
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTABCONTROL
#define NOANIMATE
#include <commctrl.h>




// --------------------------------------------------------------------------
//
//  CreateHotKeyClient()
//
//  Called by CreateClientObject() and Clone()
//
// --------------------------------------------------------------------------
HRESULT CreateHotKeyClient(HWND hwnd, long idChildCur, REFIID riid,
    void** ppvHotKey)
{
    CHotKey32* photkey;
    HRESULT    hr;

    InitPv(ppvHotKey);

    photkey = new CHotKey32(hwnd, idChildCur);
    if (!photkey)
        return(E_OUTOFMEMORY);

    hr = photkey->QueryInterface(riid, ppvHotKey);
    if (!SUCCEEDED(hr))
        delete photkey;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CHotKey32::CHotKey32()
//
// --------------------------------------------------------------------------
CHotKey32::CHotKey32(HWND hwnd, long idChildCur)
    : CClient( CLASS_HotKeyClient )
{
    Initialize(hwnd, idChildCur);
    m_fUseLabel = TRUE;
}



// --------------------------------------------------------------------------
//
//  CHotKey32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CHotKey32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_HOTKEYFIELD;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CHotKey32::get_accValue()
//
//  The value of the hotkey field control is the currently typed-in contents.
//
// --------------------------------------------------------------------------
STDMETHODIMP CHotKey32::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    DWORD   dwHotKey;
    long    lScan;
    LPTSTR  lpszMods;
    TCHAR   szModifiers[32];
    TCHAR   szKey[32];
    TCHAR   szResult[64];

    InitPv(pszValue);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    // Get the hotkey and turn into a string.
    dwHotKey = SendMessageINT(m_hwnd, HKM_GETHOTKEY, 0, 0);
    if (!dwHotKey)
        return(HrCreateString(STR_HOTKEY_NONE, pszValue));

    //
    // The HIBYTE of the LOWORD is the HOTKEYF_ flags.
    // The LOBYTE of the LOWORD is the VK_.
    //

    // Get the VK_ name.
    lScan = ((LONG)MapVirtualKey(LOBYTE(dwHotKey), 0) << 16);
    if (HIBYTE(dwHotKey) & HOTKEYF_EXT)
        lScan |= 0x01000000L;

    if (!GetKeyNameText(lScan, szKey, ARRAYSIZE(szKey)))
        return(S_FALSE);

    //
    // Make a string of the modifiers.  Do it in the order the shell does.
    // Namely, Ctrl + Shift + Alt + key.
    //
    lpszMods = szModifiers;

    if (HIBYTE(LOWORD(dwHotKey)) & HOTKEYF_CONTROL)
    {
        LoadString(hinstResDll, STR_CONTROL, szResult, ARRAYSIZE(szResult));
        lstrcpy(lpszMods, szResult);
        lpszMods += lstrlen(lpszMods);
        *lpszMods = '+';
        lpszMods++;
        *lpszMods = 0;
    }

    if (HIBYTE(LOWORD(dwHotKey)) & HOTKEYF_SHIFT)
    {
        LoadString(hinstResDll, STR_SHIFT, szResult, ARRAYSIZE(szResult));
        lstrcpy(lpszMods, szResult);
        lpszMods += lstrlen(lpszMods);
        *lpszMods = '+';
        lpszMods++;
        *lpszMods = 0;
    }

    if (HIBYTE(LOWORD(dwHotKey)) & HOTKEYF_ALT)
    {
        LoadString(hinstResDll, STR_ALT, szResult, ARRAYSIZE(szResult));
        lstrcpy(lpszMods, szResult);
        lpszMods += lstrlen(lpszMods);
        *lpszMods = '+';
        lpszMods++;
        *lpszMods = 0;
    }

    if (lpszMods == szModifiers)
        lstrcpy(szResult, szKey);
    else
    {
        lstrcpy(szResult, szModifiers);
        lpszMods = szResult + lstrlen(szResult);
        lstrcpy(lpszMods, szKey);
    }

    *pszValue = TCharSysAllocString(szResult);
    if (! *pszValue)
        return(E_OUTOFMEMORY);

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\ipaddress.cpp ===
// Copyright (c) 2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  IPAddress.CPP
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "classmap.h"
#include "ctors.h"
#include "window.h"
#include "client.h"
#include "ipaddress.h"



// --------------------------------------------------------------------------
//
//  CreateIPAddressClient()
//
// --------------------------------------------------------------------------
HRESULT CreateIPAddressClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvIPAddr)
{
    CIPAddress * pipaddr;
    HRESULT hr;

    InitPv(ppvIPAddr);

    pipaddr = new CIPAddress(hwnd, idChildCur);
    if (!pipaddr)
        return(E_OUTOFMEMORY);

    hr = pipaddr->QueryInterface(riid, ppvIPAddr);
    if (!SUCCEEDED(hr))
        delete pipaddr;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CIPAddress::CIPAddress()
//
// --------------------------------------------------------------------------
CIPAddress::CIPAddress(HWND hwnd, long idChildCur)
    : CClient( CLASS_IPAddressClient )
{
    Initialize(hwnd, idChildCur);
    m_fUseLabel = TRUE;
}


// --------------------------------------------------------------------------
//
//  CIPAddress::get_accValue()
//
//  Gets the text contents.
//
// --------------------------------------------------------------------------
STDMETHODIMP CIPAddress::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    InitPv(pszValue);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return E_INVALIDARG;

    LPTSTR lpszValue = GetTextString(m_hwnd, TRUE);
    if (!lpszValue)
        return S_FALSE;

    *pszValue = TCharSysAllocString(lpszValue);
    LocalFree((HANDLE)lpszValue);

    if (! *pszValue)
        return E_OUTOFMEMORY;

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CIPAddress::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CIPAddress::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_IPADDRESS; 

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CIPAddress::put_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CIPAddress::put_accValue(VARIANT varChild, BSTR szValue)
{
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    LPTSTR  lpszValue;

#ifdef UNICODE

	// If unicode, use the BSTR directly...
	lpszValue = szValue;

#else

	// If not UNICODE, allocate a temp string and convert to multibyte...

    // We may be dealing with DBCS chars - assume worst case where every character is
    // two bytes...
    UINT cchValue = SysStringLen(szValue) * 2;
    lpszValue = (LPTSTR)LocalAlloc(LPTR, (cchValue+1)*sizeof(TCHAR));
    if (!lpszValue)
        return(E_OUTOFMEMORY);

    WideCharToMultiByte(CP_ACP, 0, szValue, -1, lpszValue, cchValue+1, NULL,
        NULL);

#endif


    SendMessage(m_hwnd, WM_SETTEXT, 0, (LPARAM)lpszValue);

#ifndef UNICODE

	// If non-unicode, free the temp string we allocated above
    LocalFree((HANDLE)lpszValue);

#endif

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\ipaddress.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  IPAddress.H
//
//  IP Address control
//
// --------------------------------------------------------------------------

class   CIPAddress : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP        get_accValue(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP        put_accValue(VARIANT, BSTR);

        CIPAddress(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\listbox.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  LISTBOX.H
//
//  Default listbox OLE ACC Client
//
// --------------------------------------------------------------------------


class CListBox : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accName(VARIANT varChild, BSTR *pszName);
        STDMETHODIMP        get_accRole(VARIANT varChild, VARIANT* pvarRole);
        STDMETHODIMP        get_accState(VARIANT varChild, VARIANT* pvarState);
        STDMETHODIMP        get_accKeyboardShortcut(VARIANT, BSTR*);
        STDMETHODIMP        get_accFocus(VARIANT * pvarFocus);
        STDMETHODIMP        get_accSelection(VARIANT *pvarSelection);
        STDMETHODIMP        get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction);

        STDMETHODIMP        accDoDefaultAction(VARIANT varChild);
        STDMETHODIMP        accSelect(long flagsSel, VARIANT varChild);
        STDMETHODIMP        accLocation(long* pxLeft, long *pyTop, long *pcxWidth,
            long *pcyHeight, VARIANT varChild);
        STDMETHODIMP        accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd);
        STDMETHODIMP        accHitTest(long xLeft, long yTop, VARIANT *pvarHit);

        void SetupChildren(void);
        CListBox(HWND, long);

    protected:
        BOOL    m_fComboBox;
        BOOL    m_fDropDown;
};


class CListBoxFrame : public CWindow
{
    public:
        // IAccessible
        STDMETHODIMP        get_accParent(IDispatch **ppdispParent);
        STDMETHODIMP        get_accState(VARIANT varStart, VARIANT* pvarState);

        // This has the wrong signature, and is never used.
        // STDMETHODIMP        accNavigate(VARIANT varStart, long dwNavDir, VARIANT* pvarEnd);

        CListBoxFrame(HWND, long);

    protected:
        BOOL    m_fComboBox;
        BOOL    m_fDropDown;
};



// --------------------------------------------------------------------------
//
//  Although CListBoxSelection() is based off of CAccessibleObject, it only
//  supports IDispatch and IEnumVARIANT.  It will hand back the proper IDs
//  so you can pass them to the real listbox parent object.
//
// --------------------------------------------------------------------------
class CListBoxSelection : public IEnumVARIANT
{
    public:
        // IUnknown
        virtual STDMETHODIMP            QueryInterface(REFIID, void**);
        virtual STDMETHODIMP_(ULONG)    AddRef(void);
        virtual STDMETHODIMP_(ULONG)    Release(void);

        // IEnumVARIANT
        virtual STDMETHODIMP            Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP            Skip(ULONG celt);
        virtual STDMETHODIMP            Reset(void);
        virtual STDMETHODIMP            Clone(IEnumVARIANT ** ppenum);

        CListBoxSelection(int, int, LPINT);
        ~CListBoxSelection();

    protected:
        int     m_cRef;
        int     m_idChildCur;
        int     m_cSelected;
        LPINT   m_lpSelected;
};


extern HRESULT GetListBoxSelection(HWND hwnd, VARIANT * pvarSelection);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\listbox.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  LISTBOX.CPP
//
//  Listbox client class.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "window.h"
#include "listbox.h"

const TCHAR szComboExName[] = TEXT("ComboBoxEx32");

STDAPI_(LPTSTR) MyPathFindFileName(LPCTSTR pPath);


BOOL IsTridentControl( HWND hWnd, BOOL fCombo, BOOL fComboList );


// --------------------------------------------------------------------------
//
//  CreateListBoxClient()
//
//  EXTERNAL for CClient.
//
// --------------------------------------------------------------------------
HRESULT CreateListBoxClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvListBox)
{
    CListBox * plist;
    HRESULT hr;

    InitPv(ppvListBox);

    plist = new CListBox(hwnd, idChildCur);
    if (!plist)
        return(E_OUTOFMEMORY);

    hr = plist->QueryInterface(riid, ppvListBox);
    if (!SUCCEEDED(hr))
        delete plist;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CListBox::CListBox()
//
// --------------------------------------------------------------------------
CListBox::CListBox(HWND hwnd, long idChildCur)
    : CClient( CLASS_ListBoxClient )
{
    Initialize(hwnd, idChildCur);

    //
    // Check both the style and the CBOX data--SQL srvr creates controls
    // with bogus styles sometimes and could fool us into thinking this
    // was a combo.  USER's listbox creation code does the same check.
    //
    if (GetWindowLong(hwnd, GWL_STYLE) & LBS_COMBOBOX)
    {
        COMBOBOXINFO    cbi;

        if (MyGetComboBoxInfo(hwnd, &cbi))
        {
            m_fComboBox = TRUE;
            if (!(cbi.stateButton & STATE_SYSTEM_INVISIBLE))
                m_fDropDown = TRUE;
        }
    }

    m_fUseLabel = !m_fComboBox;
}


// --------------------------------------------------------------------------
//
//  CListBox::SetupChildren()
//
//  Sets the # of items we have.
//
// --------------------------------------------------------------------------
void CListBox::SetupChildren(void)
{
    m_cChildren = SendMessageINT(m_hwnd, LB_GETCOUNT, 0, 0L);
}



// --------------------------------------------------------------------------
//
//  CListBox::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accName(VARIANT varChild, BSTR *pszName)
{
    InitPv(pszName);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        if (m_fComboBox)
        {
            IAccessible* pacc;
            HRESULT hr;
            COMBOBOXINFO    cbi;

            //
            // Forward request up to combobox to get its name.
            //
            if (!MyGetComboBoxInfo(m_hwnd, &cbi))
                return(S_FALSE);

            pacc = NULL;
            hr = AccessibleObjectFromWindow(cbi.hwndCombo, OBJID_CLIENT,
                IID_IAccessible, (void**)&pacc);
            if (!SUCCEEDED(hr) || !pacc)
                return(S_FALSE);

            Assert(varChild.lVal == 0);
            hr = pacc->get_accName(varChild, pszName);
            pacc->Release();

            return(hr);
        }
        else
            return(CClient::get_accName(varChild, pszName));
    }
    else
    {
        UINT    cch;
        COMBOBOXINFO    cbi;
        UINT    msgLen;
        UINT    msgText;
        HWND    hwndAsk;

        //
        // For a combobox, ask the COMBO for its text.  A lot of apps have
        // ownerdraw items, but actually subclass combos and return real
        // text for the items.
        //
        if (m_fComboBox && MyGetComboBoxInfo(m_hwnd, &cbi))
        {
            HWND    hwndT;

            hwndAsk = cbi.hwndCombo;
            if (hwndT = IsInComboEx(cbi.hwndCombo))
                hwndAsk = hwndT;

            msgLen = CB_GETLBTEXTLEN;
            msgText = CB_GETLBTEXT;
        }
        else
        {
            hwndAsk = m_hwnd;
            msgLen = LB_GETTEXTLEN;
            msgText = LB_GETTEXT;
        }

        //
        // Get the item text.
        //
        cch = SendMessageINT(hwndAsk, msgLen, varChild.lVal-1, 0);

        // Some apps do not handle LB_GETTEXTLEN correctly, and
        // always return a small number, like 2.
        if (cch < 1024)
            cch = 1024;

        if (cch)
        {
            // HACK ALERT
            // The IE4 listbox is a superclassed standard listbox,
            // but if I use SendMessageA (which I do) to get the
            // text, I just get back one character. They keep everything
            // in Unicode. It is a bug in the Trident MSHTML
            // implementation, but even if they fixed it and gave me
            // back an ANSI string, I wouldn't know what code page to
            // use to convert the ANSI string to Unicode - web pages
            // can be in a different language than the one the user's
            // computer uses! Since they already have everything in
            // Unicode, we decided on a private message that will fill
            // in the Unicode string, and I use that just like I would
            // normally use LB_GETTEXT.
            // I was going to base this on the classname of the listbox
            // window, which is "Internet Explorer_TridentLstBox", but
            // the list part of a combo doesn't have a special class
            // name, so instead I am going to base the special case on
            // the file name of the module that owns the window.

            // TCHAR   szModuleName[MAX_PATH];
            // LPTSTR  lpszModuleName;
            // GetWindowModuleFileName(hwndAsk,szModuleName,ARRAYSIZE(szModuleName));
            // lpszModuleName = MyPathFindFileName (szModuleName);
            // if (0 == lstrcmp(lpszModuleName,TEXT("MSHTML.DLL")))

            // Update: (BrendanM)
            // GetWindowModuleFilename is broken on Win2k...
            // IsTridentControl goes back to using classnames, and knows
            // how to cope with ComboLBoxes...

            if( IsTridentControl( m_hwnd, m_fComboBox, m_fComboBox ) )
            {
                OLECHAR*    lpszUnicodeText = NULL;
                OLECHAR*    lpszLocalText = NULL;
                HANDLE      hProcess;

                if (msgText == LB_GETTEXT)
                    msgText = WM_USER+LB_GETTEXT;
                else if (msgText == CB_GETLBTEXT)
                    msgText = WM_USER+CB_GETLBTEXT;

                lpszUnicodeText = (OLECHAR *)SharedAlloc((cch+1)*sizeof(OLECHAR),
                                                         hwndAsk,
                                                         &hProcess);
                lpszLocalText = (OLECHAR*)LocalAlloc(LPTR,(cch+1)*sizeof(OLECHAR));

                if (!lpszUnicodeText || !lpszLocalText)
                    return(E_OUTOFMEMORY);

                cch = SendMessageINT(hwndAsk, msgText, varChild.lVal-1, (LPARAM)lpszUnicodeText);
                SharedRead (lpszUnicodeText,lpszLocalText,(cch+1)*sizeof(OLECHAR),hProcess);

                *pszName = SysAllocString(lpszLocalText);

                SharedFree(lpszUnicodeText,hProcess);
                LocalFree(lpszLocalText);
            }
            else // normal, non IE4 code here:
            {
                LPTSTR lpszText;

                lpszText = (LPTSTR)LocalAlloc(LPTR, (cch+1)*sizeof(TCHAR));
                if (!lpszText)
                    return(E_OUTOFMEMORY);

                SendMessage(hwndAsk, msgText, varChild.lVal-1, (LPARAM)lpszText);
                *pszName = TCharSysAllocString(lpszText);

                LocalFree((HANDLE)lpszText);
            }
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBox::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    if (varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_LISTITEM;
    else
        pvarRole->lVal = ROLE_SYSTEM_LIST;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBox::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    RECT    rcItem;
    long    lStyle;

    InitPvar(pvarState);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(CClient::get_accState(varChild, pvarState));


    --varChild.lVal;

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    //
    // Is this item selected?
    //
    if (SendMessage(m_hwnd, LB_GETSEL, varChild.lVal, 0))
        pvarState->lVal |= STATE_SYSTEM_SELECTED;

    //
    // Does it have the focus?  Remember that we decremented the lVal so it
    // is zero-based like listbox indeces.
    //
    if (MyGetFocus() == m_hwnd)
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        if (SendMessage(m_hwnd, LB_GETCARETINDEX, 0, 0) == varChild.lVal)
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;
    }
    else if (m_fComboBox)
    {
    COMBOBOXINFO    cbi;
        if (MyGetComboBoxInfo(m_hwnd, &cbi))
        {
            // if this list is part of a combo box, AND the list
            // is showing (m_fDropdown is true), then say we are
            // focusable.
            if (m_fDropDown)
            {
                pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
                if (MyGetFocus() == cbi.hwndCombo && IsWindowVisible( m_hwnd ) )
                {
                    if (SendMessage(m_hwnd, LB_GETCARETINDEX, 0, 0) == varChild.lVal)
                        pvarState->lVal |= STATE_SYSTEM_FOCUSED;
                }
            } // end if it is dropped
        } // end if we got combo box info
    } // end if this is a combox box list

    //
    // Is the listbox read-only?
    //
    lStyle = GetWindowLong(m_hwnd, GWL_STYLE);

    if (lStyle & LBS_NOSEL)
        pvarState->lVal |= STATE_SYSTEM_READONLY;
    else
    {
        pvarState->lVal |= STATE_SYSTEM_SELECTABLE;

        //
        // Is the listbox multiple and/or extended sel?  NOTE:  We have
        // no way to implement accSelect() EXTENDSELECTION so don't.
        //
        if (lStyle & LBS_MULTIPLESEL)
            pvarState->lVal |= STATE_SYSTEM_MULTISELECTABLE;
    }

    //
    // Is the item in view?
    //
    // SMD 09/16/97 Offscreen things are things never on the screen,
    // and that doesn't apply to this. Changed from OFFSCREEN to
    // INVISIBLE.
    if( ! IsWindowVisible( m_hwnd ) )
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
    }
    else if( ! SendMessage(m_hwnd, LB_GETITEMRECT, varChild.lVal, (LPARAM)&rcItem))
    {
        // LB_GETITEMRECT returns FALSE if the item is clipped...
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBox::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    //
    // Validate
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if ((varChild.lVal == 0) && !m_fComboBox)
        return(CClient::get_accKeyboardShortcut(varChild, pszShortcut));

    return(E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CListBox::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accFocus(VARIANT *pvarChild)
{
    InitPvar(pvarChild);

    //
    // Are we the focus?
    //
    if (MyGetFocus() == m_hwnd)
    {
        long    lCaret;

        pvarChild->vt = VT_I4;

        lCaret = SendMessageINT(m_hwnd, LB_GETCARETINDEX, 0, 0L);
        if (lCaret != LB_ERR)
            pvarChild->lVal = lCaret+1;
        else
            pvarChild->lVal = 0;

        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CListBox::get_accSelection()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accSelection(VARIANT *pvarSelection)
{
    return(GetListBoxSelection(m_hwnd, pvarSelection));
}


// --------------------------------------------------------------------------
//
//  CListBox::get_accDefaultAction()
//
//  Since the default action for a listbox item is really determined by the
//  creator of the listbox control, the best we can do is double click on
//  the thing, and return "double click" as the default action string.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction)
{
    InitPv(pszDefAction);

    //
    // Validate.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return (HrCreateString(STR_DOUBLE_CLICK, pszDefAction));

    return(E_NOT_APPLICABLE);
}

// --------------------------------------------------------------------------
//
//  CListBox::accDoDefaultAction()
//
//  As noted above, we really don't know what the default action for a list
//  box item is, so unless the parent overrides us, we'll just do a double
//  click on the thing.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::accDoDefaultAction(VARIANT varChild)
{
    RECT        rcLoc;
    HRESULT     hr;

    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
    {
        hr = accLocation(&rcLoc.left,&rcLoc.top,&rcLoc.right,&rcLoc.bottom,varChild);
        if (!SUCCEEDED (hr))
            return (hr);

        // this will check if WindowFromPoint at the click point is the same
        // as m_hwnd, and if not, it won't click. Cool!
        if (ClickOnTheRect(&rcLoc,m_hwnd,TRUE))
            return (S_OK);
    }
    return(E_NOT_APPLICABLE);
}


// --------------------------------------------------------------------------
//
//  CListBox::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::accSelect(long selFlags, VARIANT varChild)
{
    long    lStyle;
    int     nFocusedItem;

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild)   ||
        ! ValidateSelFlags(selFlags))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accSelect(selFlags, varChild));

    varChild.lVal--;

    lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    if (lStyle & LBS_NOSEL)
        return(E_NOT_APPLICABLE);


    if (selFlags & SELFLAG_TAKEFOCUS)
    {
        MySetFocus(m_hwnd);
    }


    // note that LB_SETCURSEL doesn't work for extended or multi-select
    // listboxes, have to use LB_SELITEMRANGE or LB_SETSEL.
    if ((lStyle & LBS_MULTIPLESEL) ||
        (lStyle & LBS_EXTENDEDSEL))
    {
        // get the focused item here in case we change it.
        nFocusedItem = SendMessageINT(m_hwnd,LB_GETCARETINDEX,0,0);

        if (selFlags & SELFLAG_TAKEFOCUS)
        {
            if (MyGetFocus() != m_hwnd)
                return(S_FALSE);
            SendMessage (m_hwnd, LB_SETCARETINDEX,varChild.lVal,0);
        }

        // These seem to be weird - when you tell it to set the selection, it
        // also sets the focus. So we remember focus and reset it at the end.
        if (selFlags & SELFLAG_TAKESELECTION)
        {
            // deselect the whole range of items
            SendMessage(m_hwnd, LB_SETSEL,FALSE,-1);
            // Select this one
            SendMessage(m_hwnd, LB_SETSEL, TRUE, varChild.lVal);
        }

        if (selFlags & SELFLAG_EXTENDSELECTION)
        {
        BOOL    bSelected;

            if ((selFlags & SELFLAG_ADDSELECTION) || (selFlags & SELFLAG_REMOVESELECTION))
                SendMessage (m_hwnd,LB_SELITEMRANGE,(selFlags & SELFLAG_ADDSELECTION),MAKELPARAM(nFocusedItem,varChild.lVal));
            else
            {
                bSelected = SendMessageINT(m_hwnd,LB_GETSEL,nFocusedItem,0);
                SendMessage (m_hwnd,LB_SELITEMRANGE,bSelected,MAKELPARAM(nFocusedItem,varChild.lVal));
            }
        }
        else // not extending, check add/remove
        {
            if ((selFlags & SELFLAG_ADDSELECTION) || (selFlags & SELFLAG_REMOVESELECTION))
                SendMessage(m_hwnd, LB_SETSEL, (selFlags & SELFLAG_ADDSELECTION),varChild.lVal);
        }
        // set focus to where it was before if SELFLAG_TAKEFOCUS not set
        if ((selFlags & SELFLAG_TAKEFOCUS) == 0)
            SendMessage (m_hwnd, LB_SETCARETINDEX,nFocusedItem,0);
    }
    else // listbox is single select
    {
        if (selFlags & (SELFLAG_ADDSELECTION |
                        SELFLAG_REMOVESELECTION |
                        SELFLAG_EXTENDSELECTION))
            return (E_INVALIDARG);

        // single select listboxes do not allow you to set the
        // focus independently of the selection, so we send a
        // LB_SETCURSEL for both TAKESELECTION and TAKEFOCUS
        if ((selFlags & SELFLAG_TAKESELECTION) ||
            (selFlags & SELFLAG_TAKEFOCUS))
            SendMessage(m_hwnd, LB_SETCURSEL, varChild.lVal, 0);
    } // end if listbox is single select

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBox::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::accLocation(long* pxLeft, long *pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    RECT    rc;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate params
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    //
    // Get item rect.
    //
    if (SendMessage(m_hwnd, LB_GETITEMRECT, varChild.lVal-1, (LPARAM)&rc))
    {
        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rc, 2);

        *pxLeft = rc.left;
        *pyTop = rc.top;
        *pcxWidth = rc.right - rc.left;
        *pcyHeight = rc.bottom - rc.top;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBox::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::accNavigate(long dwNavDir, VARIANT varStart, VARIANT *pvarEnd)
{
    long lEnd;
    long lRows;

    InitPvar(pvarEnd);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varStart)   ||
        ! ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    //
    // Is this something for the client (or combobox) to handle?
    //
    if (dwNavDir == NAVDIR_FIRSTCHILD)
    {
        lEnd = 1;
        if (lEnd > m_cChildren)
            lEnd = 0;
    }
    else if (dwNavDir == NAVDIR_LASTCHILD)
        lEnd = m_cChildren;
    else if (varStart.lVal == CHILDID_SELF)
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));
    else
    {
        long    lT;

        lRows = MyGetListBoxInfo(m_hwnd);
        if (!lRows)
            return(S_FALSE);

        lEnd = 0;

        lT = varStart.lVal - 1;

        switch (dwNavDir)
        {
            case NAVDIR_LEFT:
                //
                // Are there any items to the left of us?
                //
                if (lT >= lRows)
                    lEnd = varStart.lVal - lRows;
                break;

            case NAVDIR_RIGHT:
                //
                // Are there are any items to the right of us?
                //
                if (lT + lRows < m_cChildren)
                    lEnd = varStart.lVal + lRows;
                break;

            case NAVDIR_UP:
                //
                // Are we in the top-most row?
                //
                if ((lT % lRows) != 0)
                    lEnd = varStart.lVal - 1;
                break;

            case NAVDIR_DOWN:
                //
                // Are we the last item or in the bottom-most row?
                //
                if (((lT+1) % lRows) != 0)
                {
                    lEnd = varStart.lVal + 1;
                    if (lEnd > m_cChildren)
                        lEnd = 0;
                }
                break;

            case NAVDIR_PREVIOUS:
                lEnd = varStart.lVal - 1;
                break;

            case NAVDIR_NEXT:
                lEnd = varStart.lVal + 1;
                if (lEnd > m_cChildren)
                    lEnd = 0;
                break;
        }
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
    }

    return(lEnd ? S_OK : S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CListBox::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBox::accHitTest(long xLeft, long yTop, VARIANT *pvarHit)
{
    POINT   pt;
    RECT    rc;
    long    l;

    InitPvar(pvarHit);

    //
    // Is the point in our client area?
    //
    pt.x = xLeft;
    pt.y = yTop;
    ScreenToClient(m_hwnd, &pt);

    MyGetRect(m_hwnd, &rc, FALSE);

    if (!PtInRect(&rc, pt))
        return(S_FALSE);

    //
    // What item is here?
    //
    l = SendMessageINT(m_hwnd, LB_ITEMFROMPOINT, 0, MAKELONG(pt.x, pt.y));

    pvarHit->vt = VT_I4;

    if (HIWORD(l))
    {
        // Outside bounds, in white space.
        pvarHit->lVal = 0;
    }
    else
    {
        pvarHit->lVal = (int)(short)LOWORD(l) + 1;
    }


    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CreateListBoxWindow()
//
// --------------------------------------------------------------------------
HRESULT CreateListBoxWindow(HWND hwnd, long idChildCur, REFIID riid, void** ppvListBoxW)
{
    HRESULT hr;

    CListBoxFrame * plframe;

    InitPv(ppvListBoxW);

    plframe = new CListBoxFrame(hwnd, idChildCur);
    if (!plframe)
        return(E_OUTOFMEMORY);

    hr = plframe->QueryInterface(riid, ppvListBoxW);
    if (!SUCCEEDED(hr))
        delete plframe;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CListBoxFrame::CListBoxFrame()
//
// --------------------------------------------------------------------------
CListBoxFrame::CListBoxFrame(HWND hwnd, long iChildCur)
    : CWindow( CLASS_ListBoxWindow )
{
    Initialize(hwnd, iChildCur);

    if (GetWindowLong(hwnd, GWL_STYLE) & LBS_COMBOBOX)
    {
        COMBOBOXINFO    cbi;

        if (MyGetComboBoxInfo(hwnd, &cbi))
        {
            m_fComboBox = TRUE;
            if (!(cbi.stateButton & STATE_SYSTEM_INVISIBLE))
                m_fDropDown = TRUE;
        }
    }
}



// --------------------------------------------------------------------------
//
//  CListBoxFrame::get_accParent()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxFrame::get_accParent(IDispatch** ppdispParent)
{
    InitPv(ppdispParent);

    //
    // We need to handle combo dropdowns specially, since they are made
    // children of the desktop for free floating.
    //
    if (m_fComboBox && m_fDropDown)
    {
        COMBOBOXINFO    cbi;

        if (!MyGetComboBoxInfo(m_hwnd, &cbi))
            return(S_FALSE);

        //
        // Get the combo info and create our combobox parent.
        //
        return(AccessibleObjectFromWindow(cbi.hwndCombo, OBJID_CLIENT,
            IID_IDispatch, (void**)ppdispParent));
    }
    else
        return(CWindow::get_accParent(ppdispParent));
}



// --------------------------------------------------------------------------
//
//  CListBoxFrame::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxFrame::get_accState(VARIANT varStart, VARIANT *pvarState)
{
    HRESULT hr;

    InitPvar(pvarState);

    if (! ValidateChild(&varStart))
        return(E_INVALIDARG);

    //
    // Get the window's state
    //
    hr = CWindow::get_accState(varStart, pvarState);
    if (SUCCEEDED(hr) && m_fComboBox && m_fDropDown && (varStart.lVal == 0))
    {
        pvarState->lVal |= STATE_SYSTEM_FLOATING;
    }
    return(hr);

}




// Note: this code was never used - the signature of accNavigate here is
// incorrect - it should be (long dwNavDir, VARIANT varStart, VARIANT *pVarEnd).
//
// However, while enabling this version does solve some problems, it introduces
// more of its own.
//
// eg. while navigating through top-level windows, if you hit a combolbox window,
// you get stuck, and can't navigate back out again.
//
// So, for the moment, it's being left disabled; but remains here for reference.
// It may be possible to re-enable it, but other code would have to be altered
// to make it work consistently.
#if 0

// --------------------------------------------------------------------------
//
//  CListBoxFrame::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxFrame::accNavigate(VARIANT varStart, long dwNavDir,
    VARIANT* pvarEnd)
{
    COMBOBOXINFO    cbi;

    InitPvar(pvarEnd);

    //
    // Validate.
    //
    if (! ValidateChild(&varStart)   ||
        ! ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    //
    // Hand off to CWindow if (1) first child, (2) non-zero start.
    //
    Assert(NAVDIR_LASTCHILD > NAVDIR_FIRSTCHILD);

    if (!m_fComboBox || (dwNavDir >= NAVDIR_FIRSTCHILD) || varStart.lVal)
        return(CWindow::accNavigate(dwNavDir, varStart, pvarEnd));

    //
    // Get our parent window
    //
    if (! MyGetComboBoxInfo(m_hwnd, &cbi))
        return(S_FALSE);

    return(GetParentToNavigate(INDEX_COMBOBOX_LIST, cbi.hwndCombo,
        OBJID_CLIENT, dwNavDir, pvarEnd));
}
// Unused CListBoxFrame::accNavigate implementation
// See comment at top for more information.
#endif




/////////////////////////////////////////////////////////////////////////////
//
//  MULTIPLE SELECTION LISTBOX SUPPORT
//
//  If a listbox has more than one item selected, we create an object
//  that is a clone.  It keeps a list of the selected items.  Its sole
//  purpose is to respond to IEnumVARIANT, a collection.  The caller should
//  either
//      (a) Pass the child ID to the parent object to get acc info
//      (b) Call the child directly if VT_DISPATCH.
//
/////////////////////////////////////////////////////////////////////////////


// --------------------------------------------------------------------------
//
//  GetListBoxSelection()
//
// --------------------------------------------------------------------------
HRESULT GetListBoxSelection(HWND hwnd, VARIANT* pvarSelection)
{
    int cSelected;
    LPINT lpSelected;
    long lRet;
    CListBoxSelection * plbs;

    InitPvar(pvarSelection);

    cSelected = SendMessageINT(hwnd, LB_GETSELCOUNT, 0, 0);

    if (cSelected <= 1)
    {
        //
        // cSelected is -1, 0, or 1.
        //      -1 means this is a single sel listbox.
        //      0 or 1 means this is multisel
        //
        lRet = SendMessageINT(hwnd, LB_GETCURSEL, 0, 0);
        if (lRet == -1)
            return(S_FALSE);

        pvarSelection->vt = VT_I4;
        pvarSelection->lVal = lRet+1;
        return(S_OK);
    }

    //
    // Multiple items; must make a collection
    //

    //
    // Allocate memory for the list of item IDs
    //
    lpSelected = (LPINT)LocalAlloc(LPTR, cSelected*sizeof(INT));
    if (!lpSelected)
        return(E_OUTOFMEMORY);

    //
    // Get the list of selected item IDs
    //
    plbs = NULL;

    lRet = SendMessageINT(hwnd, LB_GETSELITEMS, cSelected, (LPARAM)lpSelected);
    if (lRet != LB_ERR)
    {
        plbs = new CListBoxSelection(0, lRet, lpSelected);
        if (plbs)
        {
            pvarSelection->vt = VT_UNKNOWN;
            plbs->QueryInterface(IID_IUnknown, (void**)&(pvarSelection->punkVal));
        }
    }

    //
    // Free the list memory; the constructor will make a copy.  This is
    // because the constructor is called both from create and clone.
    //
    LocalFree((HANDLE)lpSelected);

    if (!plbs)
        return(E_OUTOFMEMORY);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::CListBoxSelection()
//
//  We AddRef() once plistFrom so that it won't go away out from us.  When
//  we are destroyed, we will Release() it.
//
// --------------------------------------------------------------------------
CListBoxSelection::CListBoxSelection(int iChildCur, int cSelected, LPINT lpSelection)
{
    m_idChildCur = iChildCur;

    m_lpSelected = (LPINT)LocalAlloc(LPTR, cSelected*sizeof(int));
    if (!m_lpSelected)
        m_cSelected = 0;
    else
    {
        m_cSelected = cSelected;
        CopyMemory(m_lpSelected, lpSelection, cSelected*sizeof(int));
    }
}




// --------------------------------------------------------------------------
//
//  CListBoxSelection::~CListBoxSelection()
//
// --------------------------------------------------------------------------
CListBoxSelection::~CListBoxSelection()
{
    //
    // Free item memory
    //
    if (m_lpSelected)
    {
        LocalFree((HANDLE)m_lpSelected);
        m_lpSelected = NULL;
    }
}




// --------------------------------------------------------------------------
//
//  CListBoxSelection::QueryInterface()
//
//  We only respond to IUnknown and IEnumVARIANT!  It is the responsibility
//  of the caller to loop through the items using IEnumVARIANT interfaces,
//  and get the child IDs to then pass to the parent object (or call
//  directly if VT_DISPATCH--not in this case they aren't though).
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::QueryInterface(REFIID riid, void** ppunk)
{
    *ppunk = NULL;

    if ((riid == IID_IUnknown)  ||
        (riid == IID_IEnumVARIANT))
    {
        *ppunk = this;
    }
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN) *ppunk)->AddRef();
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::AddRef()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListBoxSelection::AddRef(void)
{
    return(++m_cRef);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Release()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListBoxSelection::Release(void)
{
    if ((--m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return(m_cRef);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Next()
//
//  This returns a VT_I4 which is the child ID for the parent listbox that
//  returned this object for the selection collection.  The caller turns
//  around and passes this variant to the listbox object to get acc info
//  about it.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Next(ULONG celt, VARIANT* rgvar, ULONG *pceltFetched)
{
    VARIANT* pvar;
    long    cFetched;
    long    iCur;

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    //
    // Initialize VARIANTs
    // This is so bogus
    //
    pvar = rgvar;
    for (iCur = 0; iCur < (long)celt; iCur++, pvar++)
        VariantInit(pvar);

    pvar = rgvar;
    cFetched = 0;
    iCur = m_idChildCur;

    //
    // Loop through our items
    //
    while ((cFetched < (long)celt) && (iCur < m_cSelected))
    {
        pvar->vt = VT_I4;
        pvar->lVal = m_lpSelected[iCur] + 1;

        ++cFetched;
        ++iCur;
        ++pvar;
    }

    //
    // Advance the current position
    //
    m_idChildCur = iCur;

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched = cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Skip()
//
// -------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Skip(ULONG celt)
{
    m_idChildCur += celt;
    if (m_idChildCur > m_cSelected)
        m_idChildCur = m_cSelected;

    //
    // We return S_FALSE if at the end.
    //
    return((m_idChildCur >= m_cSelected) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Reset()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Reset(void)
{
    m_idChildCur = 0;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListBoxSelection::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListBoxSelection::Clone(IEnumVARIANT **ppenum)
{
    CListBoxSelection * plistselnew;

    InitPv(ppenum);

    plistselnew = new CListBoxSelection(m_idChildCur, m_cSelected, m_lpSelected);
    if (!plistselnew)
        return(E_OUTOFMEMORY);

    return(plistselnew->QueryInterface(IID_IEnumVARIANT, (void**)ppenum));
}



// --------------------------------------------------------------------------
//
//  IsComboEx()
//
//  Returns TRUE if this window is a comboex32
//
// --------------------------------------------------------------------------
BOOL IsComboEx(HWND hwnd)
{
    TCHAR   szClass[128];

    return MyGetWindowClass(hwnd, szClass, ARRAYSIZE(szClass) ) &&
                ! lstrcmpi(szClass, szComboExName);
}


// --------------------------------------------------------------------------
//
//  IsInComboEx()
//
//  Returns the COMBOEX window if the combo is embedded in a COMBOEX (like
//  on the toolbar).
//
// --------------------------------------------------------------------------
HWND IsInComboEx(HWND hwnd)
{
    HWND hwndParent = MyGetAncestor(hwnd, GA_PARENT);
    if( hwndParent && IsComboEx(hwndParent) )
        return hwndParent;
    else
        return NULL;
}


// --------------------------------------------------------------------------
// Copied from shlwapi\path.c
//
// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo
// --------------------------------------------------------------------------

STDAPI_(LPTSTR)
MyPathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT;

    for (pT = pPath; *pPath; pPath = CharNext(pPath)) {
        if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':') || pPath[0] == TEXT('/'))
            && pPath[1] &&  pPath[1] != TEXT('\\')  &&   pPath[1] != TEXT('/'))
            pT = pPath + 1;
    }

    return (LPTSTR)pT;   // const -> non const
}


/*
 *  IsTridentControl
 *
 *  HWND hWnd
 *      window to test against
 *  BOOL fCombo
 *      TRUE if this is a combo or a combolbox
 *  BOOL fComboList
 *      TRUE if this is a combolbox (the drop-down list box associated with a combo)
 *
 *  This works by comparing class names - "Internet Explorer_TridentCmboBx"
 *  for combos, and "Internet Explorer_TridentLstBox" for listboxes.
 *  The drop-lists of combos don't have a special class, so instead we get
 *  the 'parent' combo, and check it against "Internet Explorer_TridentCmboBx".
 *
 */
BOOL IsTridentControl( HWND hWnd, BOOL fCombo, BOOL fComboList )
{
    // If this is a drop-list, get the associated combo...
    if( fComboList )
    {
        COMBOBOXINFO cbi;
        if( ! MyGetComboBoxInfo( hWnd, & cbi ) || cbi.hwndCombo == NULL )
        {
            return FALSE;
        }

        hWnd = cbi.hwndCombo;
    }

    // Get class name...
    TCHAR szClass[64];
    szClass[0] = '\0';
    GetClassName( hWnd, szClass, ARRAYSIZE( szClass ) );

    // Compare against expected string...
    TCHAR * pszCompare;
    if( fCombo )
        pszCompare = TEXT("Internet Explorer_TridentCmboBx");
    else
        pszCompare = TEXT("Internet Explorer_TridentLstBox");


    return lstrcmp( szClass, pszCompare ) == 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\hotkey.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  HOTKEY.H
//
//  This knows how to talk to COMCTL32's hotkey control.
//
// --------------------------------------------------------------------------


class CHotKey32 : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP    get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP    get_accValue(VARIANT, BSTR*);

        CHotKey32(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\mdicli.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  MDICLI.CPP
//
//  MDI Client class.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "window.h"
#include "client.h"
#include "mdicli.h"



// --------------------------------------------------------------------------
//
//  CreateMDIClient()
//
//  EXTERNAL for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateMDIClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvMdi)
{
    CMdiClient * pmdicli;
    HRESULT hr;

    InitPv(ppvMdi);

    pmdicli = new CMdiClient(hwnd, idChildCur);
    if (!pmdicli)
        return(E_OUTOFMEMORY);

    hr = pmdicli->QueryInterface(riid, ppvMdi);
    if (!SUCCEEDED(hr))
        delete pmdicli;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CMdiClient::CMdiClient()
//
// --------------------------------------------------------------------------
CMdiClient::CMdiClient(HWND hwndSelf, long idChild)
    : CClient( CLASS_MDIClient )
{
    Initialize(hwndSelf, idChild);
}



// --------------------------------------------------------------------------
//
//  CMdiClient::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMdiClient::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    //
    // Validate -- does NOT accept child IDs (yet)
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(HrCreateString(STR_MDICLI_NAME, pszName));
}



// --------------------------------------------------------------------------
//
//  CMdiClient::get_accFocus()
//
//  Both the focus and the selection return back the "active" mdi child.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMdiClient::get_accFocus(VARIANT* pvarFocus)
{
    return(get_accSelection(pvarFocus));
}



// --------------------------------------------------------------------------
//
//  CMdiClient::get_accSelection()
//
//  Both the focus and the selection return back the "active" mdi child.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMdiClient::get_accSelection(VARIANT* pvarSel)
{
    HWND    hwndChild;

    InitPvar(pvarSel);

    hwndChild = (HWND)SendMessage(m_hwnd, WM_MDIGETACTIVE, 0, 0);
    if (!hwndChild)
        return(S_FALSE);

    return(GetWindowObject(hwndChild, pvarSel));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\memchk.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  MEMCHK.H
//
//  Simple new/delete counting error ehecking library
//
// -------------------------------------------------------------------------=


// Call this at DLL_PROCESS_ATTACH time...
void InitMemChk();

// ... and this at DLL_PROCESS_DETACH time - number of 
// outstanding delete's will be reported by DBPRINTF.
void UninitMemChk();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\mdicli.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  MDICLI.H
//
//  MDI Client support
//
// --------------------------------------------------------------------------


class CMdiClient : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP        get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP        get_accFocus(VARIANT*);
        virtual STDMETHODIMP        get_accSelection(VARIANT*);

        CMdiClient(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\listview.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  LISTVIEW.H
//
//  Knows how to talk to COMCTL32's listview control.
//
// --------------------------------------------------------------------------

class CListView32 : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accDescription(VARIANT, BSTR*);
		STDMETHODIMP        get_accHelp(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        STDMETHODIMP        get_accFocus(VARIANT*);
        STDMETHODIMP        get_accSelection(VARIANT*);
        STDMETHODIMP        get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP        accDoDefaultAction(VARIANT);
        STDMETHODIMP        accSelect(long, VARIANT);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);

        void    SetupChildren(void);
        void    RemoveCurrentSelFocus(long);
        CListView32(HWND, long);
};



class CListViewSelection : public IEnumVARIANT
{
    public:
        // IUnknown
        virtual STDMETHODIMP            QueryInterface(REFIID, void**);
        virtual STDMETHODIMP_(ULONG)    AddRef(void);
        virtual STDMETHODIMP_(ULONG)    Release(void);

        // IEnumVARIANT
        virtual STDMETHODIMP            Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP            Skip(ULONG celt);
        virtual STDMETHODIMP            Reset(void);
        virtual STDMETHODIMP            Clone(IEnumVARIANT ** ppenum);

        CListViewSelection(int, int, LPINT);
        ~CListViewSelection();

    protected:
        int     m_cRef;
        int     m_idChildCur;
        int     m_cSelected;
        LPINT   m_lpSelected;
};


extern HRESULT GetListViewSelection(HWND hwnd, VARIANT * pvarSelection);

// CWO:  Copied from latest COMMCTRL.H to support new functionality
#ifndef LVM_GETHEADER
    #define LVM_GETHEADER               (LVM_FIRST + 31)
    #define ListView_GetHeader(hwnd)\
        (HWND)SNDMSG((hwnd), LVM_GETHEADER, 0, 0L)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\menu.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  MENU.CPP
//
//  Menu class, for system menus and app menus.
//
//	There are four classes here. 
//	CMenu is the class that knows how to deal with menu bar objects. These
//	have children that are CMenuItem objects, or just children (rare - 
//	this is when you have a command right on the menu bar).
//	CMenuItem is something that when you click on it opens a popup.
//	It has 1 child that is a CMenuPopupFrame.
//	CMenuPopupFrame is the HWND that pops up when you click on a CMenuItem. It
//	has 1 child, a CMenuPopup.
//  CMenuPopup objects represent the client area of a CMenuPopupFrame HWND.
//  It has children that are menu items (little m, little i), separators, and 
//	CMenuItems (when you have cascading menus).
//
//  Issues that came up during design/implementation:
//      (1) How do we select/focus menu items while in menu mode?
//      (2) How do we choose an item (default action)?
//          For menu bars, we use SendInput to send Alt+Shortcut key to 
//          open or execute an item or command. Send just Alt to close 
//          an item that is already open.
//      (3) How do we handle popup menus?  
//          As discussed above, we treat them very strangely. There are ways
//          to get the children in a popup whether it is visible or not.
//      (4) What about "system menu" popups on tray?
//          
//		(5) In general, what about "context menus"? This may need to be
//			exposed by the app itself. We can't do everything!
// 
//  History:
//	written by Laura Butler, early 1996
//	complete re-write by Steve Donie, August 1996-January 1997
//  doDefaultAction changed to use keypresses rather than mouse clicks 3-97
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "classmap.h"
#include "ctors.h"
#include "window.h"
#include "client.h"
#include "menu.h"

#include "propmgr_util.h"

#define MI_NONE         -1

#ifndef MFS_HOTTRACK
#define MFS_HOTTRACK        0x00000100L
#endif // !MFS_HOTTRACK





// --------------------------------------------------------------------------
// prototypes for local functions
// --------------------------------------------------------------------------
HWND GetSubMenuWindow (HMENU hSubMenuToFind);
long FindItemIDThatOwnsThisMenu (HMENU hMenuOwned,HWND* phwndOwner,
                                 BOOL* pfPopup,BOOL* pfSysMenu);
STDAPI  WindowFromAccessibleObjectEx(IAccessible* pacc, HWND* phwnd);

BOOL    MyGetMenuString( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, long id, LPTSTR lpszBuf, UINT cchMax, BOOL fAllowGenerated );

BOOL    TryMSAAMenuHack( IAccessible * pTheObj, HWND hWnd, DWORD_PTR dwItemData, LPTSTR lpszBuf, UINT cchMax );
BOOL    GetShellOwnerDrawMenu( HWND hwnd, DWORD_PTR dwItemData, LPTSTR lpszBuf, UINT cchMax );

UINT    GetMDIButtonIndex( HMENU hMenu, DWORD idPos );
BOOL    GetMDIMenuDescriptionString( HMENU hMenu, DWORD idPos, BSTR * pbstr );
BOOL    GetMDIMenuString( HWND hwnd, HMENU hMenu, DWORD idPos, LPTSTR lpszBuf, UINT cchMax );

HMENU   MyGetSystemMenu( HWND hwnd );

HRESULT GetMenuItemName( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, LONG id, BSTR * pszName );
TCHAR   GetMenuItemHotkey( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, LONG id, DWORD fOptions );
HRESULT GetMenuItemShortcut( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, LONG id,
                             BOOL fIsMenuBar, BSTR * pszShortcut );

enum
{
    GMIH_ALLOW_INITIAL     = 0x01,
    GMIH_ALLOW_SYS_SPACE   = 0x02
};



// --------------------------------------------------------------------------
//
//  CreateSysMenuBarObject()
//
//  EXTERNAL for CreateStdAcessibleObject
//
//	Parameters: 
//	hwnd		IN		window handle of the window that owns this menu
//	idChildCur	IN		id of the current child. Will be 0 when creating the 
//						system menu bar and application menu bar. Will be the 
//						id of a child when calling CMenu::Clone()
//	riid		IN		the id of the interface asked for
//	ppvMenu		OUT		ppvMenu holds the indirect pointer to the menu 
//						object. 
//
//	Return Value:
//		S_OK if the interface is supported, E_NOINTERFACE if not, 
//		E_OUTOFMEMORY if not enough memory to create the menu object,
//		E_FAIL if the hwnd is invalid.
//
// --------------------------------------------------------------------------
HRESULT CreateSysMenuBarObject(HWND hwnd, long idObject, REFIID riid,
    void** ppvMenu)
{
    UNUSED(idObject);

    if (!IsWindow(hwnd))
        return(E_FAIL);

    return(CreateMenuBar(hwnd, TRUE, 0, riid, ppvMenu));
}

// --------------------------------------------------------------------------
//
//  CreateMenuBarObject()
//
//  EXTERNAL for CreateStdAcessibleObject
//
//	Parameters: 
//	hwnd		IN		window handle of the window that owns this menu
//	idChildCur	IN		id of the current child. Will be 0 when creating the 
//						system menu bar and application menu bar. Will be the 
//						id of a child when calling CMenu::Clone()
//	riid		IN		the id of the interface asked for (like IAccessible,
//						IEnumVARIANT,IDispatch...)
//	ppvMenu		OUT		ppvMenu is where QueryInterface will return the 
//						indirect pointer to the menu object (caller casts
//						this to be a pointer to the interface they asked for)
//
//	Return Value:
//		S_OK if the interface is supported, E_NOINTERFACE if not, 
//		E_OUTOFMEMORY if not enough memory to create the menu object,
//		E_FAIL if the hwnd is invalid.
//
// --------------------------------------------------------------------------
HRESULT CreateMenuBarObject(HWND hwnd, long idObject, REFIID riid, void** ppvMenu)
{
    UNUSED(idObject);

    if (!IsWindow(hwnd))
        return(E_FAIL);

    return(CreateMenuBar(hwnd, FALSE, 0, riid, ppvMenu));
}



// --------------------------------------------------------------------------
//
//  CreateMenuBar()
//
//	Parameters: 
//	hwnd		IN		window handle of the window that owns this menu
//	fSysMenu	IN		true if this is a system menu, false if app menu
//	idChildCur	IN		id of the current child. Will be 0 when creating the 
//						system menu bar and application menu bar. Will be the 
//						id of a child when calling CMenu::Clone()
//	riid		IN		the id of the interface asked for
//	ppvMenu		OUT		ppvMenu is where QueryInterface will return the 
//						indirect pointer to the menu object
//
//	Return Value:
//		S_OK if the interface is supported, E_NOINTERFACE if not, 
//		E_OUTOFMEMORY if not enough memory to create the menu object.
//
//	Called By:
//	CreateMenuBarObject and CMenu::Clone
// --------------------------------------------------------------------------
HRESULT CreateMenuBar(HWND hwnd, BOOL fSysMenu, long idChildCur,
    REFIID riid, void** ppvMenu)
{
HRESULT     hr;
CMenu*      pmenu;

    InitPv(ppvMenu);

    pmenu = new CMenu(hwnd, fSysMenu, idChildCur);
    if (!pmenu)
        return(E_OUTOFMEMORY);

    hr = pmenu->QueryInterface(riid, ppvMenu);
    if (!SUCCEEDED(hr))
        delete pmenu;

    return(hr);
}

// --------------------------------------------------------------------------
//
//  CMenu::CMenu()
//
//	Constructor for the CMenu class. Initializes the member variables with
//	the passed in parameters. It is only called by CreateMenuBar.
//
// --------------------------------------------------------------------------
CMenu::CMenu(HWND hwnd, BOOL fSysMenu, long idChildCur)
    : CAccessible( CLASS_MenuObject )
{
    m_hwnd = hwnd;
    m_fSysMenu = fSysMenu;
    m_idChildCur = idChildCur;
	m_hMenu = NULL;
	// m_hMenu is filled in by SetupChildren()
	// m_cChildren is filled in by SetupChildren()
}

// --------------------------------------------------------------------------
//
//  CMenu::SetupChildren()
//
//	This uses the object's window handle to get the handle to the appropriate
//	menu (hmenu type menu handle) and the count of the children in that menu.
//	It uses GetMenuBarInfo, a private function in USER, to do this.
//	These values are kept as member variables of the CMenu object.
//
// --------------------------------------------------------------------------
void CMenu::SetupChildren(void)
{
MENUBARINFO mbi;

    if (!MyGetMenuBarInfo(m_hwnd, (m_fSysMenu ? OBJID_SYSMENU : OBJID_MENU), 
        0, &mbi))
    {
        m_hMenu = NULL;
    }
    else
    {
        m_hMenu = mbi.hMenu;
    }

    if (!m_hMenu)
        m_cChildren = 0;
    else
    {
        m_cChildren = GetMenuItemCount(m_hMenu);

        if( m_cChildren == -1 )
        {
            // Paranoia in case we get an invalid HMENU
            m_cChildren = 0;
        }
    }
}

// --------------------------------------------------------------------------
//
//  CMenu::get_accChild()
//
//	What we want this do do is return (in ppdisp) an IDispatch pointer to 
//  the child specified by varChild. The children of a CMenu are either
//	menu commands (rare to have a command on the menu bar) and CMenuItems.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accChild(VARIANT varChild, IDispatch** ppdisp)
{
HMENU	hSubMenu;

    InitPv(ppdisp);

    if (!ValidateChild(&varChild))
        return (E_INVALIDARG);
    
    if (varChild.lVal == CHILDID_SELF)
        return(E_INVALIDARG);

	Assert (m_hMenu);

    hSubMenu = GetSubMenu(m_hMenu, varChild.lVal-1);

	if (hSubMenu == NULL)
	{
        // This returns false - for commands on the menu bar, we do not create a child
        // object - the parent is able to answer all the questions.
		return (S_FALSE);
	}

    return(CreateMenuItem((IAccessible*)this, m_hwnd, m_hMenu,hSubMenu,
        varChild.lVal,  0, TRUE, IID_IDispatch, (void**)ppdisp));
}

// --------------------------------------------------------------------------
//
//  CMenu::get_accName()
//
//	Pass in a VARIANT with type VT_I4 and lVal equal to the 1-based position
// of the item you want the name for. Pass in a pointer to a string and the
// string will be filled with the name.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

	if (varChild.lVal != CHILDID_SELF)
	{
        return GetMenuItemName( this, m_hwnd, m_hMenu, varChild.lVal, pszName );
	}

    if (m_fSysMenu)
        return HrCreateString(STR_SYSMENU_NAME, pszName);	// in English = "System"
    else
        return HrCreateString(STR_MENUBAR_NAME, pszName);	// in English, this is "Application"
}

// --------------------------------------------------------------------------
//
//  CMenu::get_accDescription()
//
// get a string with the description of this menu item. For CMenu, this
// is something like "contains commands to manipulate the window" or
// "Contains commands to manipulate the current view or document" 
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{

    InitPv(pszDesc);

    if (! ValidateChild(&varChild))
        return E_INVALIDARG;

	// Check if they are asking about the menu bar itself or a child.
    // If asking about a child, return S_FALSE, because we don't have 
    // descriptions for items, just the system and app menu bars.
    //
	if (varChild.lVal != CHILDID_SELF)
    {
        if( GetMDIMenuDescriptionString( m_hMenu, varChild.lVal - 1, pszDesc ) )
        {
            return S_OK;
        }

		return S_FALSE;
    }
    else if (m_fSysMenu)
    {
        return HrCreateString(STR_SYSMENUBAR_DESCRIPTION, pszDesc);
    }
    else
    {
        return HrCreateString(STR_MENUBAR_DESCRIPTION, pszDesc);
    }
}




// --------------------------------------------------------------------------
//
//  CMenu::get_accRole()
//
// get the role - this is either menu item or menu bar
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

	if (varChild.lVal != CHILDID_SELF)
    {
        if( GetMDIButtonIndex( m_hMenu, varChild.lVal - 1 ) != 0 )
        {
            // Special case for MDI child buttons - they are actually implemented
            // as menu items, but appear as buttons.
    		pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
        }
        else
        {
    		pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
        }
    }
	else
		pvarRole->lVal = ROLE_SYSTEM_MENUBAR;

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CMenu::get_accState()
//
// get the state of the child specified. returned in a variant VT_I4
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    MENUBARINFO mbi;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (!m_hMenu || !MyGetMenuBarInfo(m_hwnd, (m_fSysMenu ? OBJID_SYSMENU : OBJID_MENU),
        varChild.lVal, &mbi))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
    }
    else if( varChild.lVal && GetMDIButtonIndex( m_hMenu, varChild.lVal - 1 ) != 0 )
    {
        // For MDI button elements, just leave the state as normal, to be consistent
        // with the top-level restore/close/minimize buttons.

        // Do nothing here.
    }
    else
    {
        // Non-MDI-button menu items, or CHILDID_SELF...

        // smd 1-29-97 - change from OFFSCREEN to INVISIBLE
        if (IsRectEmpty(&mbi.rcBar))
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

        if (GetForegroundWindow() == m_hwnd)
            pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        if (mbi.fFocused)
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;
        
        if (varChild.lVal)
        {
            MENUITEMINFO    mi;

            //
            // Get menu item flags.  NOTE:  Can't use GetMenuState().  It whacks
            // random stuff in for hierarchicals.
            //
            mi.cbSize = SIZEOF_MENUITEMINFO;
            mi.fMask = MIIM_STATE | MIIM_SUBMENU;

            if (!GetMenuItemInfo(m_hMenu, varChild.lVal-1, TRUE, &mi))
            {
                pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
                return(S_FALSE);
            }

            if (mi.fState & MFS_GRAYED)
                pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

            if (mi.fState & MFS_CHECKED)
                pvarState->lVal |= STATE_SYSTEM_CHECKED;

            if (mi.fState & MFS_DEFAULT)
                pvarState->lVal |= STATE_SYSTEM_DEFAULT;

            if (mbi.fFocused)
            {
                pvarState->lVal |= STATE_SYSTEM_HOTTRACKED;
			    if (mi.fState & MFS_HILITE)
                    pvarState->lVal |= STATE_SYSTEM_FOCUSED;
            }

            if (mi.hSubMenu)
                pvarState->lVal |= STATE_SYSTEM_HASPOPUP;
        
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenu::get_accKeyboardShortcut()
//
// returns a string with the menu shortcut to the child asked for
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    if (varChild.lVal == CHILDID_SELF)
    {
        if (!m_hMenu)
            return S_FALSE;

        if (m_fSysMenu)
        {
            // Alt+Space/Hyphen is the system menu...
            TCHAR szFormat[16];
            LoadString(hinstResDll, STR_MENU_SHORTCUT_FORMAT, szFormat, ARRAYSIZE(szFormat));

            TCHAR szKey[16];
            LoadString(hinstResDll, ((GetWindowLong(m_hwnd, GWL_STYLE) & WS_CHILD) ?
                STR_CHILDSYSMENU_KEY : STR_SYSMENU_KEY), szKey, ARRAYSIZE(szKey));

            TCHAR szHotKey[32];
            szHotKey[ 0 ] = '\0';
            wsprintf(szHotKey, szFormat, szKey);

            if (*szHotKey)
            {
                *pszShortcut = TCharSysAllocString(szHotKey);
                if (! *pszShortcut)
                    return E_OUTOFMEMORY;

                return S_OK;
            }

            return S_FALSE;
        }
        else
        {
            // "Alt" is the menu bar
            return HrCreateString(STR_MENU_SHORTCUT, pszShortcut);
        }
    }
    else
    {
        // Get menu item shortcut - TRUE means use "Alt+" format.
        return GetMenuItemShortcut( this, m_hwnd, m_hMenu, varChild.lVal, TRUE, pszShortcut );
    }
}



// --------------------------------------------------------------------------
//
//  CMenu::get_accFocus()
//
//  This fills in pvarFocus with the ID of the child that has the focus.
//	So when say you just hit "Alt" (File is now highlighted) and then call 
//	get_accFocus(), pvarFocus will have VT_I4 and lVal = 1.
//
//	If we are not in menu mode, then we certainly don't have the focus. 
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accFocus(VARIANT* pvarFocus)
{
GUITHREADINFO	GuiThreadInfo;
MENUITEMINFO	mii;
int				i;

	// set it to empty
    InitPvar(pvarFocus);

    //
    // Are we in menu mode?  If not, nothing.
    //
	if (!MyGetGUIThreadInfo (NULL,&GuiThreadInfo))
		return(S_FALSE);

	if (GuiThreadInfo.flags & GUI_INMENUMODE)
	{
		// do I have to loop through all of them to see which
		// one is hilited?? Looks like it...
		mii.cbSize = SIZEOF_MENUITEMINFO;
		mii.fMask = MIIM_STATE;

		SetupChildren();
		for (i=0;i < m_cChildren;i++)
		{
			GetMenuItemInfo (m_hMenu,i,TRUE,&mii);
			if (mii.fState & MFS_HILITE)
			{
				pvarFocus->vt = VT_I4;
				pvarFocus->lVal = i+1;
				return (S_OK);
			}
		}

		// I don't think this should happen
		return(S_FALSE);
	}

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CMenu::get_accDefaultAction()
//
//  Menu bars have no defaults.  However, items do.  Hierarchical items
//  drop down/pop up their hierarchical.  Non-hierarchical items execute
//  their command.
//
//  doDefaultAction follows from this. It has to do whatever getDefaultAction
//  says it is going to do. We use keystrokes to do this for menu bars. 
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::get_accDefaultAction(VARIANT varChild, BSTR* pszDefA)
{
GUITHREADINFO   gui;
HMENU           hSubMenu;

    InitPv(pszDefA);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(E_NOT_APPLICABLE);


    if( GetMDIButtonIndex( m_hMenu, varChild.lVal - 1 ) != 0 )
    {
        // Special case for MDI child buttons - they are actually implemented
        // as menu items, but appear as buttons.
        return HrCreateString(STR_BUTTON_PUSH, pszDefA);
    }


    // Only if this window is active can we do the default.
    // There is a slight danger here that an Always On Top window
    // could be covering us, but this is small.
    //
    if (!MyGetGUIThreadInfo(0, &gui))
        return(E_NOT_APPLICABLE);

    if (m_hwnd != gui.hwndActive)
        return(E_NOT_APPLICABLE);

    varChild.lVal--;

    // Is this item enabled?
    if (GetMenuState(m_hMenu, varChild.lVal, MF_BYPOSITION) & MFS_GRAYED)
        return(E_NOT_APPLICABLE);

    // Now check if this item has a submenu that is displayed.
    // If there is, the action is hide, if not, the action is show. 
    // If it doesn't have a submenu, the action is execute.
    if (hSubMenu = GetSubMenu(m_hMenu, varChild.lVal))
    {
        if (GetSubMenuWindow(hSubMenu))
            return(HrCreateString(STR_DROPDOWN_HIDE, pszDefA));
        else
            return(HrCreateString(STR_DROPDOWN_SHOW, pszDefA));
    }
    else
        return(HrCreateString(STR_EXECUTE, pszDefA));
}

// --------------------------------------------------------------------------
//
//  CMenu::accSelect()
//
//  We only accept TAKE_FOCUS. What I wanted this to do is to just put the
//  app into menu mode (if it isn't already - more on this later) and then
//  select the item specified - don't open it or anything, just select it.
//
//  But that was a pain in the butt, so no I just use doDefaultAction to
//  do the work. Maybe I'll fix it for 1.1
//
//  If we are already in menu mode, and a popup is open, then we should 
//  close the popup(s) and select the item. If in menu mode and no popups
//  are up, just select the item. 
//
//  If the app is just setting focus to the menu bar itself, and not already
//  in menu mode, just put us into menu mode (automatically selects first
//  item). If we are already in menu mode, do nothing.
//
//  I want to try to do all this without generating a whole mess of extra
//  events!
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::accSelect(long flagsSel, VARIANT varChild)
{
LPARAM          lParam;
GUITHREADINFO   GuiThreadInfo;

    if (!ValidateChild(&varChild) || !ValidateSelFlags(flagsSel))
        return(E_INVALIDARG);

    if (flagsSel != SELFLAG_TAKEFOCUS)
        return(E_NOT_APPLICABLE);

    // if this window is not the active window, fail.
	MyGetGUIThreadInfo (NULL,&GuiThreadInfo);
    if (GuiThreadInfo.hwndActive != m_hwnd)
        return (E_NOT_APPLICABLE);

#ifdef _DEBUG
    if (!m_hMenu)
    {
        //DBPRINTF (TEXT("null hmenu at 1\r\n"));
        Assert (m_hMenu);
    }
#endif

    if (varChild.lVal == CHILDID_SELF)
    {
        if (!m_fSysMenu)
            lParam = NULL;
        else if (GetWindowLong(m_hwnd, GWL_STYLE) & WS_CHILD)
            lParam = MAKELONG('-', 0);
        else
            lParam = MAKELONG(' ', 0);

        PostMessage(m_hwnd, WM_SYSCOMMAND, SC_KEYMENU, lParam);
        return (S_OK);
    }
    else if (GetSubMenu(m_hMenu, varChild.lVal-1))
    {
        // for version 1.0, I'll just do this. Safe, even though it's not 100%
        // what I want it to do.
        return (accDoDefaultAction (varChild));
    }

    return (E_FAIL);
}



// --------------------------------------------------------------------------
//
//  CMenu::accLocation()
//
// get the location of the child. left,top,width,height
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    MENUBARINFO mbi;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

	if (!MyGetMenuBarInfo(m_hwnd, (m_fSysMenu ? OBJID_SYSMENU : OBJID_MENU),
        varChild.lVal, &mbi))
        return(S_FALSE);

    *pcxWidth = mbi.rcBar.right - mbi.rcBar.left;
    *pcyHeight = mbi.rcBar.bottom - mbi.rcBar.top;

    *pxLeft = mbi.rcBar.left;
    *pyTop = mbi.rcBar.top;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenu::accHitTest()
//
// if the point is in a menu bar, return the child the point is over
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::accHitTest(long x, long y, VARIANT* pvarHit)
{
    InitPvar(pvarHit);
    SetupChildren();

    if (SendMessage(m_hwnd, WM_NCHITTEST, 0, MAKELONG(x, y)) == (m_fSysMenu ? HTSYSMENU : HTMENU))
    {
        pvarHit->vt = VT_I4;
        pvarHit->lVal = 0;

        if (m_cChildren)
        {
            if (m_fSysMenu)
                pvarHit->lVal = 1;
            else
            {
                POINT   pt;

                pt.x = x;
                pt.y = y;

				// MenuItemFromPoint conveniently returns -1 if we are not
				// over any menu item, so that gets returned as 0 (CHILDID_SELF)
				// while others get bumped by 1 to be 1..n. Cool!
                pvarHit->lVal = MenuItemFromPoint(m_hwnd, m_hMenu, pt) + 1;
            }

            if (pvarHit->lVal)
            {
                IDispatch* pdispChild;

                pdispChild = NULL;
                get_accChild(*pvarHit, &pdispChild);
                if (pdispChild)
                {
                    pvarHit->vt = VT_DISPATCH;
                    pvarHit->pdispVal = pdispChild;
                }
            }
        }

        return(S_OK);
    }

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CMenu::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd)
{
long		lEnd = 0;
HMENU		hSubMenu;

    InitPvar(pvarEnd);	

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        varStart.lVal = m_cChildren + 1;
        dwNavDir = NAVDIR_PREVIOUS;
    }
    else if (varStart.lVal == CHILDID_SELF)
        return(GetParentToNavigate((m_fSysMenu ? OBJID_SYSMENU : OBJID_MENU),
            m_hwnd, OBJID_WINDOW, dwNavDir, pvarEnd));

	// when we get to here, navdir was either firstchild
	// or lastchild (now changed to either next or previous)
	// OR
	// we were starting from something other than the parent object
    switch (dwNavDir)
    {
        case NAVDIR_RIGHT:
        case NAVDIR_NEXT:
            lEnd = varStart.lVal + 1;
            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_LEFT:
        case NAVDIR_PREVIOUS:
            lEnd = varStart.lVal - 1;
            break;

        case NAVDIR_UP:
        case NAVDIR_DOWN:
            lEnd = 0;
            break;
    }

    if (lEnd)
    {
		// we should give the child object back!!
#ifdef _DEBUG
        if (!m_hMenu)
        {
            //DBPRINTF (TEXT("null hmenu at 2\r\n"));
            Assert (m_hMenu);
        }
#endif

		hSubMenu = GetSubMenu (m_hMenu,lEnd-1);
		if (hSubMenu)
		{
			pvarEnd->vt=VT_DISPATCH;
			return(CreateMenuItem((IAccessible*)this, m_hwnd, m_hMenu, hSubMenu,
				lEnd,  0, FALSE, IID_IDispatch, (void**)&pvarEnd->pdispVal));
		}
		// just return VT_I4 if it does not have a submenu.
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;

        return(S_OK);
    }

    return(S_FALSE);
}




// --------------------------------------------------------------------------
//
//  CMenu::accDoDefaultAction()
//
//  Menu bars have no defaults.  However, items do.  Hierarchical items
//  drop down/pop up their hierarchical.  Non-hierarchical items execute
//  their command. To Open something that is closed or to Execute a command, 
//  we use SendInput to send Alt+ShortcutKey. To Close something, we just 
//  send Alt.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::accDoDefaultAction(VARIANT varChild)
{
GUITHREADINFO   gui;
TCHAR           chHotKey;
HMENU	        hSubMenu;
int             i,n;
int             nTries;
#define MAX_TRIES 20

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(E_NOT_APPLICABLE);


    if( GetMDIButtonIndex( m_hMenu, varChild.lVal - 1 ) != 0 )
    {
        // Special case for MDI child buttons - they are actually implemented
        // as menu items, but appear as buttons.

        // Active them by posting a WM_COMMAND with the command id of the
        // corresponding menu item.
        //
        // This WM_COMMAND gets picked up by the MDIClient window, and it then
        // minimizes/restores/closes the currently active child. (If we did
        // a WM_SYSCOMMAND instead of WM_COMMAND, the overall app window
        // would minimize/restore/close instead!)
        int id = GetMenuItemID( m_hMenu, varChild.lVal - 1 );
        PostMessage(m_hwnd, WM_COMMAND, id, 0L);
        return S_OK;
    }


    //
    // Only if this window is active can we do the default.
	//
    if (!MyGetGUIThreadInfo(0, &gui))
        return(E_FAIL);

    if (m_hwnd != gui.hwndActive)
        return(E_NOT_APPLICABLE);

    // If disabled, fail
    if (GetMenuState(m_hMenu, varChild.lVal-1, MF_BYPOSITION) & MFS_GRAYED)
        return(E_NOT_APPLICABLE);

#ifdef _DEBUG
    if (!m_hMenu)
    {
        //DBPRINTF (TEXT("null hmenu at 3\r\n"));
        Assert (m_hMenu);
    }
#endif

    // First check if this item has a sub menu, and if it is open.
    // If it has, and it is, then close it.
    if (hSubMenu = GetSubMenu(m_hMenu, varChild.lVal-1))
    {
        if (GetSubMenuWindow(hSubMenu))
        {
            MyBlockInput (TRUE);
            SendKey (KEYPRESS,VK_VIRTUAL,VK_MENU,0);
            SendKey (KEYRELEASE,VK_VIRTUAL,VK_MENU,0);
            MyBlockInput (FALSE);
            return (S_OK);
        }
    }

    // when we get here, either it doesn't have a submenu and we need
    // to execute, or the submenu is closed and we need to open it.
    // Our actions are the same in either case. - send Alt+Letter if
    // there is a letter, if not a letter....

    // special case for system menus
    if (m_fSysMenu)
    {
    LPARAM  lParam;

        if (GetWindowLong(m_hwnd, GWL_STYLE) & WS_CHILD)
            lParam = MAKELONG('-', 0);
        else
            lParam = MAKELONG(' ', 0);

        PostMessage(m_hwnd, WM_SYSCOMMAND, SC_KEYMENU, lParam);
        return (S_OK);
    }

    //
    // Get menu item string; get & character.
    //

    chHotKey = GetMenuItemHotkey( this, m_hwnd, m_hMenu, varChild.lVal, 0 );

    if (chHotKey)
    {
        MyBlockInput (TRUE);
        SendKey (KEYPRESS,VK_VIRTUAL,VK_MENU,0);
        SendKey (KEYPRESS,VK_CHAR,0,chHotKey);
        SendKey (KEYRELEASE,VK_CHAR,0,chHotKey);
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_MENU,0);
        MyBlockInput (FALSE);
        return (S_OK);
    }
    else
    {
        // Bad Apps don't define hot keys. We can try to move the selection
        // to that item and then hit enter. An easier way would be to just
        // hit Alt+FirstLetter, but if there are more than 1 item with that
        // letter, it will always do the first one. Not optimal, may lead to
        // unexpected side-effects. Better to do nothing than to do that.
        //
        // We need to put ourselves in menu mode if we aren't already, then
        // send right arrow keys to put us on the right one, then hit Enter.
        // If we are already in menu mode, take us out of menu mode to close
        // the heirarchy, then go back into menu mode and continue.
        MyBlockInput (TRUE);
        if (gui.flags & GUI_INMENUMODE)
        {
            SendKey (KEYPRESS,VK_VIRTUAL,VK_MENU,0);
            SendKey (KEYRELEASE,VK_VIRTUAL,VK_MENU,0);
        }

        // now go into menu mode and send right arrows until the one we 
        // want is highlighted.
        SendKey (KEYPRESS,VK_VIRTUAL,VK_MENU,0);
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_MENU,0);

        // calculate how many right arrows to hit:
        n = varChild.lVal-1;
        // if this menu is the menu of an MDI window and the window
        // is maximized, then the thing now highlighted is the MDI
        // Doc Sys menu, and we'll have to go 1 farther than we think.
        // To see if this is the case, we'll check if the first item
        // in the menu is something with a submenu and it is a bitmap menu.
        if (GetSubMenu(m_hMenu,0) &&
            (GetMenuState(m_hMenu, 0, MF_BYPOSITION) & MF_BITMAP))
            n++;

        for (i = 0; i < n;i++)
        {
            SendKey (KEYPRESS,VK_VIRTUAL,VK_RIGHT,0);
            SendKey (KEYRELEASE,VK_VIRTUAL,VK_RIGHT,0);
        }
        MyBlockInput (FALSE);        

        // check if it is highlighted now. If so, hit enter to activate.
        // try several times - 
        nTries = 0;
        while ( ((GetMenuState(m_hMenu, varChild.lVal-1, MF_BYPOSITION) & MF_HILITE) == 0) &&
                (nTries < MAX_TRIES))
        {
            Sleep(55);
            nTries++;
        }

        if (GetMenuState(m_hMenu, varChild.lVal-1, MF_BYPOSITION) & MF_HILITE)
        {
            MyBlockInput (TRUE);        
            SendKey (KEYPRESS,VK_VIRTUAL,VK_RETURN,0);
            SendKey (KEYRELEASE,VK_VIRTUAL,VK_RETURN,0);
            MyBlockInput (FALSE);        
            return (S_OK);
        }
        else
            return (E_FAIL);
    }
}



// --------------------------------------------------------------------------
//
//  CMenu::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenu::Clone(IEnumVARIANT** ppenum)
{
    return(CreateMenuBar(m_hwnd, m_fSysMenu, m_idChildCur, IID_IEnumVARIANT,
            (void**)ppenum));
}


STDMETHODIMP CMenu::GetIdentityString (
    DWORD	    dwIDChild,
    BYTE **     ppIDString,
    DWORD *     pdwIDStringLen
)
{
    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    BYTE * pKeyData = (BYTE *) CoTaskMemAlloc( HMENUKEYSIZE );
    if( ! pKeyData )
    {
        return E_OUTOFMEMORY;
    }

    DWORD dwpid;
    GetWindowThreadProcessId( m_hwnd, & dwpid );
    MakeHmenuKey( pKeyData, dwpid, m_hMenu, dwIDChild );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HMENUKEYSIZE;

    return S_OK;
}




/////////////////////////////////////////////////////////////////////////////
//
//  MENU ITEMS
//
/////////////////////////////////////////////////////////////////////////////


// --------------------------------------------------------------------------
//
//  CreateMenuItem()
//
//  This creates a child object for a menu item that has a sub menu.
//
//	Parameters:
//	paccMenu	IN		pointer to the parent's IAccessible
//	hwnd		IN		the hwnd of the window that owns the parent menu
//	hMenu		IN		the hmenu of the menu that owns this item.
//	hSubMenu	IN		the hMenu of the submenu this menu item opens
//	ItemID		IN		the menu item ID. Position (1..n).
//	iCurChild	IN		ID of the current child in the enumeration
//	fPopup		IN		is this menu item in a popup or on a menu bar?
//	riid		IN		what interface are we asking for on this item?
//	ppvItem		OUT		the pointer to the interface asked for.
//
// --------------------------------------------------------------------------
HRESULT CreateMenuItem(IAccessible* paccMenu, HWND hwnd, HMENU hMenu, 
	HMENU hSubMenu, long ItemID, long iCurChild, BOOL fPopup, REFIID riid, 
	void** ppvItem)
{
    HRESULT hr;
    CMenuItem* pmenuitem;

    InitPv(ppvItem);

    pmenuitem = new CMenuItem(paccMenu, hwnd, hMenu, hSubMenu, ItemID, iCurChild, fPopup);
    if (! pmenuitem)
        return(E_OUTOFMEMORY);

    hr = pmenuitem->QueryInterface(riid, ppvItem);
    if (!SUCCEEDED(hr))
        delete pmenuitem;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CMenuItem::CMenuItem()
//
//  We hang on to our parent object so we can forward methods up to him.
//  Therefore we must bump up the ref count.
//
// --------------------------------------------------------------------------
CMenuItem::CMenuItem(IAccessible* paccParent, HWND hwnd, HMENU hMenu,
    HMENU hSubMenu, long ItemID, long iCurChild, BOOL fPopup)
    : CAccessible( CLASS_MenuItemObject )
{
    m_hwnd = hwnd;
    m_hMenu = hMenu;
	m_hSubMenu = hSubMenu;
    m_ItemID = ItemID;
    m_idChildCur = iCurChild;
    m_fInAPopup = fPopup;

    m_paccParent = paccParent;
    paccParent->AddRef();
}



// --------------------------------------------------------------------------
//
//  CMenuItem::~CMenuItem()
//
//  We hung on to our parent, so we must release it on destruction.
//
// --------------------------------------------------------------------------
CMenuItem::~CMenuItem()
{
    m_paccParent->Release();
}


// --------------------------------------------------------------------------
//
//  SetupChildren()
//
//  CMenuItems have 1 child. That one child is either a CMenuPopupFrame or
//  a CMenuPopup (depending if the menu is visible).
//
// --------------------------------------------------------------------------
void CMenuItem::SetupChildren(void)
{
    m_cChildren = 1;
}

// --------------------------------------------------------------------------
//
//  CMenuItem::get_accParent()
//
// Pass it on back to the parent.
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accParent(IDispatch** ppdispParent)
{
    InitPv(ppdispParent);

    return(m_paccParent->QueryInterface(IID_IDispatch, (void**)ppdispParent));
}



// --------------------------------------------------------------------------
//
//  CMenuItem::get_accChild()
//
//  The menu item's child is either a CMenuPopupFrame (if the popup window
//  is visible and belongs to this CMenuItem) or a CMenuPopup. This allows
//  someone to enumerate the commands whether or not the popup is visible.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accChild(VARIANT varChild, IDispatch** ppdispChild)
{
HWND    hwndSubMenu;
HRESULT hr;

    InitPv(ppdispChild);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);
	
    if (varChild.lVal != CHILDID_SELF)
    {
        // In order to create the accessible object representing the child,
        // we have to find the popup menu window.
        // Once we have found it, we check if it is visible. If so, then
        // our child is a CMenuPopupFrame, which we will create by
        // calling CreateMenuPopupWindow.
        // If the popup window is not visible, or if it does not belong
        // to this CMenuItem, then our child is a CMenuPopup, which we
        // will create by calling CreateMenuPopup.
        //
        hwndSubMenu = GetSubMenuWindow (m_hSubMenu);
        if (hwndSubMenu)
            return (CreateMenuPopupWindow (hwndSubMenu,0,IID_IDispatch, (void**)ppdispChild));
        else
        {
            // this is where we create 'invisible' popups so apps can
            // walk down and see all of the commands (most, at least).
            // Since it is invisible, we have to tell it more about who
            // it's parent is.
            hr = CreateMenuPopupClient (NULL,0,IID_IDispatch,(void**)ppdispChild);
            if (SUCCEEDED (hr))
                ((CMenuPopup*)*ppdispChild)->SetParentInfo((IAccessible*)this,
                        m_hSubMenu,varChild.lVal);

            return(hr);
        }
    }

    return(E_INVALIDARG);
}


// --------------------------------------------------------------------------
//
//  CMenuItem::get_accName()
//
//  The name for the child (CMenuPopup or CMenuPopupFrame) is the same as
//  the name of the Parent/Self, so whether we are asked for id=self or
//  id = child (1), we return the same thing.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    return GetMenuItemName( this, m_hwnd, m_hMenu, m_ItemID, pszName );
}



// --------------------------------------------------------------------------
//
//  CMenuItem::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
MENUITEMINFO mi;

    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    if (varChild.lVal == CHILDID_SELF)
    {
        mi.cbSize = SIZEOF_MENUITEMINFO;
        mi.fMask = MIIM_TYPE | MIIM_SUBMENU;
        mi.cch = 0;
        mi.dwTypeData = 0;

        GetMenuItemInfo(m_hMenu, m_ItemID-1, TRUE, &mi);
        if (mi.fType & MFT_SEPARATOR)
            pvarRole->lVal = ROLE_SYSTEM_SEPARATOR;
        else
            pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
    }
    else
    {
        pvarRole->lVal = ROLE_SYSTEM_MENUPOPUP;
    }
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenuItem::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accState(VARIANT varChild, VARIANT* pvarState)
{
HWND    hwndSubMenu;

    InitPvar(pvarState);

	if (!ValidateChild (&varChild))
        return(E_INVALIDARG);

	// We do this because sometimes we'll be asked for our own info,
	// and the caller will just call us item 0 (CHILDID_SELF) and we 
	// have to make sure when we call our parent to tell her who
	// we are (m_ItemID). 
	if (varChild.lVal == CHILDID_SELF)
    {
		varChild.lVal = m_ItemID;
        return(m_paccParent->get_accState(varChild, pvarState));
    }
    else
    {
        // If the popup (our only child) is not showing or it belongs to 
        // another menu item, set the state to invisible.
        // If it is showing and belongs to us, set the state to normal.
        
        // This starts by assuming that it is invisible, and clearing the
        // state if we find a visible menu that belongs to us.
        pvarState->vt = VT_I4;
        pvarState->lVal = 0 | STATE_SYSTEM_INVISIBLE;

        hwndSubMenu = GetSubMenuWindow (m_hSubMenu);
        if (hwndSubMenu)
            pvarState->lVal = 0;
    }
    return (S_OK);
}

// --------------------------------------------------------------------------
//
//  CMenuItem::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    if (! ValidateChild(&varChild))
        return E_INVALIDARG;

    if (varChild.lVal == CHILDID_SELF)
    {
        // Get menu item shortcut - use "Alt+" format for menu bars...
        BOOL fIsMenuBar = m_hwnd && ::GetMenu( m_hwnd ) == m_hMenu;

        return GetMenuItemShortcut( this, m_hwnd, m_hMenu, m_ItemID, fIsMenuBar, pszShortcut );
    }

    return S_FALSE;

}



// --------------------------------------------------------------------------
//
//  CMenuItem::get_accFocus()
//
//  If focus is us or our popup, great.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accFocus(VARIANT* pvarFocus)
{
HRESULT         hr;
HWND            hwndSubMenu;
IDispatch*      pdispChild;

    // Ask our parent who has the focus.  Is it us?
    hr = m_paccParent->get_accFocus(pvarFocus);
    if (!SUCCEEDED(hr))
        return(hr);

    // No, so return nothing.
    if ((pvarFocus->vt != VT_I4) || (pvarFocus->lVal != m_ItemID))
    {
        VariantClear(pvarFocus);
        pvarFocus->vt = VT_EMPTY;
        return(S_FALSE);
    }

    // Is the currently active popup our child?
    // If so, then we should return an IDispatch to
    // the window frame object.
    hwndSubMenu = GetSubMenuWindow (m_hSubMenu);
    if (hwndSubMenu)
    {
        hr = CreateMenuPopupWindow (hwndSubMenu,0,IID_IDispatch,(void**)&pdispChild);

        if (!SUCCEEDED(hr))
            return (hr);
        pvarFocus->vt = VT_DISPATCH;
        pvarFocus->pdispVal = pdispChild;
        return (S_OK);
    }
    
    pvarFocus->lVal = 0;
    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CMenuItem::get_accDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::get_accDefaultAction(VARIANT varChild, BSTR* pszDefA)
{
    InitPv(pszDefA);

	if (!ValidateChild (&varChild))
        return(E_INVALIDARG);

	// We do this because sometimes we'll be asked for our own info,
	// and the caller will just call us item 0 (CHILDID_SELF) and we 
	// have to make sure when we call our parent to tell her who
	// we are (m_ItemID). 
    // But sometimes, we will be asked for info about our child - There 
    // is no default action for our child.
	if (varChild.lVal == CHILDID_SELF)
    {
		varChild.lVal = m_ItemID;
        return(m_paccParent->get_accDefaultAction(varChild, pszDefA));
    }
    return (E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CMenuItem::accSelect()
//
//  We just let our parent take care of this for us. Tell her who we are by
//  setting varChild.lVal to our ItemID.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::accSelect(long flagsSel, VARIANT varChild)
{
    if (!ValidateChild (&varChild) ||
        !ValidateSelFlags(flagsSel))
        return (E_INVALIDARG);

	if (varChild.lVal == CHILDID_SELF)
		varChild.lVal = m_ItemID;
    return(m_paccParent->accSelect(flagsSel, varChild));
}

// --------------------------------------------------------------------------
//
//  CMenuItem::accLocation()
//
//  Sometimes we are asked for the location of a peer object. This is 
//  kinda screwy. This happens when we are asked to navigate next or prev,
//	and then let our parent navigate for us. The caller then starts thinking
//	we know about our peers. 
//  Since this is the only case where something like this happens, we'll
//	have to do some sort of hack. 
//  Problem is, when they ask for a child 0 (self) we are OK.
//	But when we are asked for child 1, is it the popup or peer 1?
//  I am going to assume that it is always the peer.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
	// we just call this to translate empty values - not going to 
	// check the return value.
	ValidateChild (&varChild);

	if (varChild.lVal == CHILDID_SELF)
		varChild.lVal = m_ItemID;

    return(m_paccParent->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));
}



// --------------------------------------------------------------------------
//
//  CMenuItem::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
HWND        hwndSubMenu;

	InitPvar(pvarEnd);

    if (!ValidateChild(&varStart))
        return (E_INVALIDARG);

    if (!ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir >= NAVDIR_FIRSTCHILD) // this means firstchild or lastchild
    {
        hwndSubMenu = GetSubMenuWindow (m_hSubMenu);
        if (hwndSubMenu)
        {
            pvarEnd->vt = VT_DISPATCH;
            return (CreateMenuPopupWindow (hwndSubMenu,0,IID_IDispatch, (void**)&(pvarEnd->pdispVal)));
        }

        return(S_FALSE);
    }
    else
    {
		if (varStart.lVal == CHILDID_SELF)
			varStart.lVal = m_ItemID;
        return(m_paccParent->accNavigate(dwNavDir, varStart, pvarEnd));
    }
}



// --------------------------------------------------------------------------
//
//  CMenuItem::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::accHitTest(long x, long y, VARIANT* pvarHit)
{
HRESULT hr;
HWND    hwndSubMenu;
RECT    rc;
POINT   pt;

    InitPvar(pvarHit);

    hwndSubMenu = GetSubMenuWindow (m_hSubMenu);
    if (hwndSubMenu)
    {
        // Is point in our popup menu window child?
        MyGetRect(hwndSubMenu, &rc, TRUE);

        pt.x = x;
        pt.y = y;

        if (PtInRect(&rc, pt))
        {
            // need to set the parent
            pvarHit->vt = VT_DISPATCH;
            return (CreateMenuPopupWindow (hwndSubMenu,0,IID_IDispatch, (void**)pvarHit->pdispVal));
        }
    }

    // Is point in us?
    hr = m_paccParent->accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/24/97, changed from !SUCCEEDED to !S_OK
    if ((hr != S_OK) || (pvarHit->vt == VT_EMPTY))
        return(hr);

	pvarHit->vt = VT_I4;
	pvarHit->lVal = CHILDID_SELF;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenuItem::accDoDefaultAction()
//
//  We just let our parent take care of this for us. Tell her who we are by
//  setting varChild.lVal to our ItemID.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::accDoDefaultAction(VARIANT varChild)
{
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    Assert(varChild.vt == VT_I4);
	if (varChild.lVal == CHILDID_SELF)
		varChild.lVal = m_ItemID;
    return(m_paccParent->accDoDefaultAction(varChild));
}



// --------------------------------------------------------------------------
//
//  CMenuItem::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuItem::Clone(IEnumVARIANT** ppenum)
{
    return(CreateMenuItem(m_paccParent, m_hwnd, m_hMenu, m_hSubMenu,m_ItemID, 
		m_idChildCur, FALSE, IID_IEnumVARIANT, (void**)ppenum));
}


STDMETHODIMP CMenuItem::GetIdentityString (
    DWORD	    dwIDChild,
    BYTE **     ppIDString,
    DWORD *     pdwIDStringLen
)
{
    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    if( dwIDChild != CHILDID_SELF )
    {
        // CMenuItems have 1 child - that one child is either a CMenuPopupFrame or
        // a CMenuPopup (depending if the menu is visible).
        // We're not going to support geting the IDs of these thourhg the parent,
        // a client should get the interface pointers to those objects themselves,
        // and ask them for their string.
        return E_INVALIDARG;
    }



    // Weird stuff alert:
    //
    // CMenuItem repesents a menu item that has an associated popup. (ie. it is
    // not a command leaf node) There are two options for representing this item:
    //
    //     as a child of its parent menu,
    // or
    //     as the parent (CHILDID_SELF) of its own submenu
    //
    // While the HWND-based controls use the latter option, here we are going for
    // the former - this keeps the menu item with its siblings, regardless of
    // whether they are menu items with popups, or leaf-node commands.
    // We can do this here since we do know what our parent HMENU is and what our
    // child id is in that parent menu.
    // HWND-based proxies as generally don't have this information available to them,
    // so the former option is not really an option for them.

    // This request is for the item itself - represent it as a child of
    // our parent menu

    BYTE * pKeyData = (BYTE *) CoTaskMemAlloc( HMENUKEYSIZE );
    if( ! pKeyData )
    {
        return E_OUTOFMEMORY;
    }

    // Need to find pid of process that the menu belongs to. Can't use the
    // pid of the popup menu, since that's a shared/reused system window.
    // Instead, we assume that since the menu is present, it belongs to the
    // current foreground thread, which is what GetGUIThreadInfo(NULL) gets us.
    GUITHREADINFO	GuiThreadInfo;
    if( ! MyGetGUIThreadInfo( NULL, & GuiThreadInfo ) )
        return E_FAIL;
    DWORD dwPid = 0;
    GetWindowThreadProcessId( GuiThreadInfo.hwndActive, & dwPid );
    if( dwPid == 0 )
        return E_FAIL;

    MakeHmenuKey( pKeyData, dwPid, m_hMenu, m_ItemID );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HMENUKEYSIZE;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
//
//  MENU POPUPS
//
/////////////////////////////////////////////////////////////////////////////



// --------------------------------------------------------------------------
//
//  CreateMenuPopupClient()
//
//  EXTERNAL for CreateClientObject...
//
// --------------------------------------------------------------------------
HRESULT CreateMenuPopupClient(HWND hwnd, long idChildCur,
    REFIID riid, void** ppvPopup)
{
    CMenuPopup*     ppopup;
    HRESULT         hr;

    ppopup = new CMenuPopup(hwnd, idChildCur);
    if (!ppopup)
        return(E_OUTOFMEMORY);

    hr = ppopup->QueryInterface(riid, ppvPopup);
    if (!SUCCEEDED(hr))
        delete ppopup;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::CMenuPopup()
//
// --------------------------------------------------------------------------
CMenuPopup::CMenuPopup(HWND hwnd, long idChildCur)
    : CClient( CLASS_MenuPopupClient )
{
    Initialize(hwnd, idChildCur);
    m_hMenu = NULL;
    m_ItemID = 0;
    m_hwndParent = NULL;
    m_fSonOfPopup = 0;
    m_fSysMenu = 0;

    // this only works if there is a window handle.
    if (hwnd)
    {
        m_hMenu = (HMENU)SendMessage (m_hwnd,MN_GETHMENU,0,0);
        // if we didn't get back an HMENU, that means that the window
        // is probably invisible. Don't try to set other values. 
        // SetupChildren will see this and set m_cChildren to 0.
        if (m_hMenu)
        {
	        m_ItemID = FindItemIDThatOwnsThisMenu (m_hMenu,&m_hwndParent,
                &m_fSonOfPopup,&m_fSysMenu);
        }
    }
}

// --------------------------------------------------------------------------
//
// The CMenuPopup objects need to know their parent when they are invisible, 
// so after one is created, the creator should call SetParentInfo.
//
// --------------------------------------------------------------------------
void CMenuPopup::SetParentInfo(IAccessible* paccParent,HMENU hMenu,long ItemID)
{
    m_paccParent = paccParent;
    m_hMenu = hMenu;
    m_ItemID= ItemID;
    if (paccParent)
        paccParent->AddRef();
}

// --------------------------------------------------------------------------
//
//  CMenuPopup::~CMenuPopup()
//
// --------------------------------------------------------------------------
CMenuPopup::~CMenuPopup(void)
{
    if (m_paccParent)
        m_paccParent->Release();
}

// --------------------------------------------------------------------------
//
//  CMenuPopup::SetupChildren()
//
// --------------------------------------------------------------------------
void CMenuPopup::SetupChildren(void)
{
    // we need to be able to set up our children whether the popup is 
    // displayed or not. So we have a m_hMenu variable, it just needs
    // to be set when the thing is made - It is either set by the 
    // constructor (if we are visible) or by the dude that called the create
    // function if we are invisible.
    // PROBLEM - sometimes CMenuPopups are created by a call to 
    // AccessibleObjectFromEvent, and the hwnd isn't always able to 
    // give us back a good m_hMenu. So we will just set m_cChildren to 0.
    if (m_hMenu)
    {
        m_cChildren = GetMenuItemCount(m_hMenu);

        if( m_cChildren == -1 )
        {
            // Paranoia in case we get an invalid HMENU
            m_cChildren = 0;
        }
    }
    else
        m_cChildren = 0;
}

// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accParent()
//
//  The parent of a CMenuPopup is either a CMenuPopupFrame or a CMenuItem.
//  If the popup is visible, it will have an hwnd, and lots of other stuff
//  will also be set. If it is not visible, it will not have an hwnd.
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accParent(IDispatch** ppdispParent)
{
    if (m_paccParent)
    {
        return (m_paccParent->QueryInterface(IID_IDispatch,(void**)ppdispParent));
    }
    else if (m_hwnd)
    {
        // try to create a parent for us...
        return (CreateMenuPopupWindow (m_hwnd,0,IID_IDispatch,(void**)ppdispParent));
    }
    else
        return (E_FAIL);
}

// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accChild()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accChild(VARIANT varChild, IDispatch** ppdispChild)
{
HMENU	hSubMenu;

    InitPv(ppdispChild);

    if (!ValidateChild(&varChild) || varChild.lVal == CHILDID_SELF)
        return(E_INVALIDARG);

    //
    // Is this item a hierarchical?
    //
    Assert (m_hMenu);
	hSubMenu = GetSubMenu(m_hMenu, varChild.lVal-1);
    if (!hSubMenu)
        return(S_FALSE);

    //
    // Yes.
    //
	return(CreateMenuItem((IAccessible*)this, m_hwnd, m_hMenu, hSubMenu,
		varChild.lVal,  0, FALSE, IID_IDispatch, (void**)ppdispChild));
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accName()
//
//  The name of the popup is the name of the item it hangs off of.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accName(VARIANT varChild, BSTR* pszName)
{
HWND            hwndOwner;
TCHAR           szClassName[50];
HRESULT         hr;
IAccessible*    paccParent;

    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        // If we popped up from a menu bar or as another popup,
		// then our name is the name of the thing that popped us
		// up. If we are a floating popup, then our name is...?
		//
        // We implement this by either:
        // 1. calling our parent object, OR
        // 2. creating a parent object on the fly that we can 
        //    ask the name of, OR
		// 3. Looking for the name of the owner window, OR
        // 4. Checking if we are the child of the start button. 
        // If all else fails, we'll just call ourselves "context menu".
        if (m_paccParent && m_ItemID)
        {
            varChild.vt = VT_I4;
            varChild.lVal = m_ItemID;
            return (m_paccParent->get_accName (varChild,pszName));
        }
        if (m_hwndParent && m_ItemID)
        {
            varChild.vt = VT_I4;
            varChild.lVal = m_ItemID;

            if (m_fSonOfPopup)
                hr = CreateMenuPopupClient(m_hwndParent,0,IID_IAccessible,(void**)&paccParent);
            else if (m_fSysMenu)
                hr = CreateSysMenuBarObject(m_hwndParent,0,IID_IAccessible,(void**)&paccParent);
            else
                hr = CreateMenuBarObject(m_hwndParent,0,IID_IAccessible,(void**)&paccParent);

            if (SUCCEEDED(hr))
            {
                hr = paccParent->get_accName (varChild,pszName);
                paccParent->Release();
            }
            return (hr);
        }
        else
		{
			// Try to get the owner window and use that for a name
			// This doesn't seem to work on anything I have ever found,
            // but it should work if anything has an owner, so i'll
            //leav it in. If it starts breaking, just rip it out.
			if (m_hwnd)
			{
			IAccessible*	pacc;
			HRESULT			hr;

				hwndOwner = ::GetWindow (m_hwnd,GW_OWNER);
				hr = AccessibleObjectFromWindow (hwndOwner, OBJID_WINDOW, IID_IAccessible, (void**)&pacc);
				if (SUCCEEDED(hr))
				{
					hr = pacc->get_accName(varChild,pszName);
                    pacc->Release();
					if (SUCCEEDED(hr))
                    {
						return (hr);
                    }
				}
			}

			// check if the start button has focus
			hwndOwner = MyGetFocus();
			if (InTheShell(hwndOwner, SHELL_TRAY))
			{
                GetClassName(hwndOwner,szClassName,ARRAYSIZE(szClassName));
                if (lstrcmp(szClassName,TEXT("Button")) == 0)
                {
                    return (HrCreateString(STR_STARTBUTTON,pszName));
                }
			}
			// at least return this for a name
            return (HrCreateString (STR_CONTEXT_MENU,pszName));
		} // end else we don't have m_paccparent && m_itemid
    } // end if childid_self
    else // not childid self, childid > 0
    {
        return GetMenuItemName( this, m_hwnd, m_hMenu, varChild.lVal, pszName );
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{
    InitPv(pszDesc);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(CClient::get_accDescription(varChild, pszDesc));

    return(E_NOT_APPLICABLE);
}




// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    if (varChild.lVal == CHILDID_SELF)
        pvarRole->lVal = ROLE_SYSTEM_MENUPOPUP;
    else
    {
        MENUITEMINFO mi;

        mi.cbSize = SIZEOF_MENUITEMINFO;
        mi.fMask = MIIM_TYPE;
        mi.cch = 0;
        mi.dwTypeData = 0;

        if (GetMenuItemInfo(m_hMenu, varChild.lVal-1, TRUE, &mi) &&
               (mi.fType & MFT_SEPARATOR))
            pvarRole->lVal = ROLE_SYSTEM_SEPARATOR;
        else
            pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
    }

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (varChild.lVal == CHILDID_SELF)
        return(CClient::get_accState(varChild, pvarState));
    else
    {
        // GetMenuBarInfo fails if the menu isn't currently present.
        // We don't fail outright when this happens, since we still want
        // to collect other info using GetMenuItemInfo below.
        MENUBARINFO     mbi;
        if( MyGetMenuBarInfo(m_hwnd, OBJID_CLIENT, varChild.lVal, &mbi) )
        {
            if (mbi.fFocused)
            {
                pvarState->lVal |= STATE_SYSTEM_FOCUSED | STATE_SYSTEM_HOTTRACKED;
            }
        }

        //
        // Get menu item flags.  NOTE:  Can't use GetMenuState().  It whacks
        // random stuff in for hierarchicals.
        //
        MENUITEMINFO    mi;
        mi.cbSize = SIZEOF_MENUITEMINFO;
        mi.fMask = MIIM_STATE | MIIM_SUBMENU;

        if (!GetMenuItemInfo(m_hMenu, varChild.lVal-1, TRUE, &mi))
        {
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
            return(S_FALSE);
        }

        if (mi.fState & MFS_GRAYED)
            pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

        if (mi.fState & MFS_CHECKED)
            pvarState->lVal |= STATE_SYSTEM_CHECKED;

        if (mi.fState & MFS_DEFAULT)
            pvarState->lVal |= STATE_SYSTEM_DEFAULT;

        if (mi.hSubMenu)
            pvarState->lVal |= STATE_SYSTEM_HASPOPUP;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    InitPv(pszShortcut);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    if (varChild.lVal == CHILDID_SELF)
        return CClient::get_accKeyboardShortcut(varChild, pszShortcut);

    // Get menu item shortcut. FALSE means don't use ALT+ form.
    return GetMenuItemShortcut( this, m_hwnd, m_hMenu, varChild.lVal, FALSE, pszShortcut );
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accFocus(VARIANT* pvarFocus)
{
GUITHREADINFO	GuiThreadInfo;
MENUITEMINFO	mii;
int				i;

	// set it to empty
    if (IsBadWritePtr(pvarFocus,sizeof(VARIANT*)))
        return (E_INVALIDARG);

    InitPvar(pvarFocus);

    //
    // Are we in menu mode?  If not, nothing.
    //
	if (!MyGetGUIThreadInfo (NULL,&GuiThreadInfo))
		return(S_FALSE);

	if (GuiThreadInfo.flags & GUI_INMENUMODE)
	{
		// do I have to loop through all of them to see which
		// one is hilited?? Looks like it...
		mii.cbSize = SIZEOF_MENUITEMINFO;
		mii.fMask = MIIM_STATE;

		SetupChildren();
		for (i=0;i < m_cChildren;i++)
		{
			GetMenuItemInfo (m_hMenu,i,TRUE,&mii);
			if (mii.fState & MFS_HILITE)
			{
				pvarFocus->vt = VT_I4;
				pvarFocus->lVal = i+1;
				return (S_OK);
			}
		}

		// I don't think this should happen
		return(S_FALSE);
	}

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::get_accDefaultAction()
//
//  Popups have no defaults.  However, items do.  Hierarchical items
//  drop down/pop up their hierarchical.  Non-hierarchical items execute
//  their command.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::get_accDefaultAction(VARIANT varChild, BSTR* pszDefA)
{
HMENU   hSubMenu;

    InitPv(pszDefA);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(E_NOT_APPLICABLE);

    varChild.lVal--;

    // Is this item enabled?
    if (GetMenuState(m_hMenu, varChild.lVal, MF_BYPOSITION) & MFS_GRAYED)
        return(E_NOT_APPLICABLE);


    // Now check if this item has a submenu that is displayed.
    // If there is, the action is hide, if not, the action is show. 
    // If it doesn't have a submenu, the action is execute.
#ifdef _DEBUG
    if (!m_hMenu)
    {
        //DBPRINTF ("null hmenu at 4\r\n");
        Assert (m_hMenu);
    }
#endif

    if (hSubMenu = GetSubMenu(m_hMenu, varChild.lVal))
    {
        if (GetSubMenuWindow(hSubMenu))
            return(HrCreateString(STR_DROPDOWN_HIDE, pszDefA));
        else
            return(HrCreateString(STR_DROPDOWN_SHOW, pszDefA));
    }
    else
        return(HrCreateString(STR_EXECUTE, pszDefA));
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::accSelect()
//
//  We only accept TAKEFOCUS.  
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::accSelect(long flagsSel, VARIANT varChild)
{
    if (!ValidateChild(&varChild) || !ValidateSelFlags(flagsSel))
        return E_INVALIDARG;

    if (flagsSel != SELFLAG_TAKEFOCUS)
        return E_NOT_APPLICABLE;

    return E_NOTIMPL;
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
MENUBARINFO mbi;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    if (!MyGetMenuBarInfo(m_hwnd, OBJID_CLIENT, varChild.lVal, &mbi))
        return(S_FALSE);

    *pcyHeight = mbi.rcBar.bottom - mbi.rcBar.top;
    *pcxWidth = mbi.rcBar.right - mbi.rcBar.left;

    *pyTop = mbi.rcBar.top;
    *pxLeft = mbi.rcBar.left;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::accHitTest(long x, long y, VARIANT* pvarHit)
{
HRESULT hr;

    // first make sure we are pointing to our own client area
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0))
        return(hr);

    // now we can see which child is at this point.
    SetupChildren();

    if (m_cChildren)
    {
        POINT   pt;

        pt.x = x;
        pt.y = y;

        pvarHit->lVal = MenuItemFromPoint(m_hwnd, m_hMenu, pt) + 1;

        if (pvarHit->lVal)
        {
            IDispatch* pdispChild;

            pdispChild = NULL;
            get_accChild(*pvarHit, &pdispChild);
            if (pdispChild)
            {
                pvarHit->vt = VT_DISPATCH;
                pvarHit->pdispVal = pdispChild;
            }
        }
            
        return(S_OK);
    }

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd)
{
long            lEnd = 0;
MENUITEMINFO    mi;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        varStart.lVal = m_cChildren + 1;
        dwNavDir = NAVDIR_PREVIOUS;
    }
    else if (!varStart.lVal)
	{
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));
	}

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
        case NAVDIR_DOWN:
            lEnd = varStart.lVal + 1;
            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_UP:
            lEnd = varStart.lVal - 1;
            break;

        case NAVDIR_LEFT:
        case NAVDIR_RIGHT:
            lEnd = 0;
            break;
    }

    if (lEnd)
    {
		// we should give the child object back!!
		// can't use getSubMenu here because it seems to ignore
		// separators??
		//hSubMenu = GetSubMenu (m_hMenu,lEnd-1);

        mi.cbSize = SIZEOF_MENUITEMINFO;
        mi.fMask = MIIM_SUBMENU;
        mi.cch = 0;
        mi.dwTypeData = 0;
		GetMenuItemInfo (m_hMenu,lEnd-1,TRUE,&mi);
		if (mi.hSubMenu)
		{
			pvarEnd->vt=VT_DISPATCH;
			return(CreateMenuItem((IAccessible*)this, m_hwnd, m_hMenu, mi.hSubMenu,
				lEnd,  0, FALSE, IID_IDispatch, (void**)&pvarEnd->pdispVal));
		}
		// just return VT_I4 if it does not have a submenu.
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;

        return(S_OK);
    }

    return(S_FALSE);
}




// --------------------------------------------------------------------------
//
//  CMenuPopup::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::accDoDefaultAction(VARIANT varChild)
{
RECT		rcLoc;
HRESULT		hr;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(CClient::accDoDefaultAction(varChild));

    // If disabled, fail
    if (GetMenuState(m_hMenu, varChild.lVal-1, MF_BYPOSITION) & MFS_GRAYED)
        return(E_NOT_APPLICABLE);

	hr = accLocation(&rcLoc.left,&rcLoc.top,&rcLoc.right,&rcLoc.bottom,varChild);
	if (!SUCCEEDED (hr))
		return (hr);
	
	// this will check if WindowFromPoint at the click point is the same
	// as m_hwnd, and if not, it won't click. Cool!
	if (ClickOnTheRect(&rcLoc,m_hwnd,FALSE))
		return (S_OK);
	else
		return (E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CMenuPopup::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopup::Clone(IEnumVARIANT **ppenum)
{
HRESULT hr;

    hr = CreateMenuPopupClient(m_hwnd, m_idChildCur, IID_IEnumVARIANT,
        (void**)ppenum);
    if (SUCCEEDED(hr))
        ((CMenuPopup*)*ppenum)->SetParentInfo((IAccessible*)this,m_hMenu,m_ItemID);
    return(hr);
}



STDMETHODIMP CMenuPopup::GetIdentityString (
    DWORD	    dwIDChild,
    BYTE **     ppIDString,
    DWORD *     pdwIDStringLen
)
{
    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    BYTE * pKeyData = (BYTE *) CoTaskMemAlloc( HMENUKEYSIZE );
    if( ! pKeyData )
    {
        return E_OUTOFMEMORY;
    }

    // Need to find pid of process that the menu belongs to. Can't use the
    // pid of the popup menu, since that's a shared/reused system window.
    // Instead, we assume that since the menu is present, it belongs to the
    // current foreground thread, which is what GetGUIThreadInfo(NULL) gets us.
    GUITHREADINFO	GuiThreadInfo;
    if( ! MyGetGUIThreadInfo( NULL, & GuiThreadInfo ) )
        return E_FAIL;
    DWORD dwPid = 0;
    GetWindowThreadProcessId( GuiThreadInfo.hwndActive, & dwPid );
    if( dwPid == 0 )
        return E_FAIL;

    MakeHmenuKey( pKeyData, dwPid, m_hMenu, dwIDChild );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HMENUKEYSIZE;

    return S_OK;
}









// ==========================================================================
//
//  POPUP WINDOW FRAMES 
//
// ==========================================================================

// --------------------------------------------------------------------------
//
//  CreateMenuPopupWindow()
//
//  This creates a child object that represents the Window object for a 
//  popup menu. It has no members, but has one child (a cMenuPopup)
//
// --------------------------------------------------------------------------
HRESULT CreateMenuPopupWindow(HWND hwnd, long idChildCur, REFIID riid, void** ppvMenuPopupW)
{
CMenuPopupFrame*    pPopupFrame;
HRESULT             hr;

    InitPv(ppvMenuPopupW);

    pPopupFrame = new CMenuPopupFrame(hwnd,idChildCur);
    if (!pPopupFrame)
        return(E_OUTOFMEMORY);

    hr = pPopupFrame->QueryInterface(riid, ppvMenuPopupW);
    if (!SUCCEEDED(hr))
        delete pPopupFrame;

    return(hr);
}


// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::CMenuPopupFrame()
//
// --------------------------------------------------------------------------
CMenuPopupFrame::CMenuPopupFrame(HWND hwnd,long idChildCur)
    : CWindow( CLASS_MenuPopupWindow )
{

    Initialize(hwnd, idChildCur);
    m_hMenu = NULL;
    m_ItemID = 0;
    m_hwndParent = NULL;
    m_fSonOfPopup = 0;
    m_fSysMenu = 0;

	m_hMenu = (HMENU)SendMessage (m_hwnd,MN_GETHMENU,0,0);
	m_ItemID = FindItemIDThatOwnsThisMenu (m_hMenu,&m_hwndParent,
        &m_fSonOfPopup,&m_fSysMenu);
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::~CMenuPopupFrame()
//
// --------------------------------------------------------------------------
CMenuPopupFrame::~CMenuPopupFrame()
{
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::SetupChildren()
//
//  Frames have 1 child. That one child is the CMenuPopup.
//
// --------------------------------------------------------------------------
void CMenuPopupFrame::SetupChildren(void)
{
	m_cChildren = 1;
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::get_accParent()
//
//  Parent of a popupmenuframe is the CMenuItem that created it (if any).
//  To create one of those we need the grandparent. So we will create the 
//  grandparent (either a CMenuPopup, or a CMenu) temporarily, then we will 
//  create our parent CMenuItem based on that.
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::get_accParent(IDispatch** ppdispParent)
{
IAccessible* paccGrandParent;
HRESULT      hr;
CMenu*       pMenu;
CMenuPopup*  pMenuPopup;

    InitPv(ppdispParent);

    if (m_fSonOfPopup)
    {
        hr = CreateMenuPopupClient(m_hwndParent,0,IID_IAccessible,(void**)&paccGrandParent);
        if (SUCCEEDED(hr))
        {
            pMenuPopup = (CMenuPopup*)paccGrandParent;
            hr = CreateMenuItem (paccGrandParent,   //	paccMenu	IN		pointer to the parent's IAccessible
                                 m_hwndParent,      //	hwnd		IN		the hwnd of the window that owns the parent menu
                                 pMenuPopup->GetMenu(), //	hMenu		IN		the hmenu of the menu that owns this item.
                                 m_hMenu,           //	hSubMenu	IN		the hMenu of the submenu this menu item opens
                                 m_ItemID,          //	ItemID		IN		the menu item ID. Position (1..n).
                                 0,                 //	iCurChild	IN		ID of the current child in the enumeration
                                 m_fSonOfPopup,     //	fPopup		IN		is this menu item in a popup or on a menu bar?
                                 IID_IDispatch,     //	riid		IN		what interface are we asking for on this item?
                                 (void**)ppdispParent); //	ppvItem		OUT		the pointer to the interface asked for.
            paccGrandParent->Release();
            return (hr);
        }
    }
    else if (m_fSysMenu)
    {
        hr = CreateSysMenuBarObject(m_hwndParent,0,IID_IAccessible,(void**)&paccGrandParent);
        if (SUCCEEDED(hr))
        {
            pMenu = (CMenu*)paccGrandParent;
            pMenu->SetupChildren();
            hr = CreateMenuItem (paccGrandParent,   //	paccMenu	IN		pointer to the parent's IAccessible
                                 m_hwndParent,      //	hwnd		IN		the hwnd of the window that owns the parent menu
                                 pMenu->GetMenu(), //	hMenu		IN		the hmenu of the menu that owns this item.
                                 m_hMenu,           //	hSubMenu	IN		the hMenu of the submenu this menu item opens
                                 m_ItemID,          //	ItemID		IN		the menu item ID. Position (1..n).
                                 0,                 //	iCurChild	IN		ID of the current child in the enumeration
                                 m_fSonOfPopup,     //	fPopup		IN		is this menu item in a popup or on a menu bar?
                                 IID_IDispatch,     //	riid		IN		what interface are we asking for on this item?
                                 (void**)ppdispParent); //	ppvItem		OUT		the pointer to the interface asked for.
            paccGrandParent->Release();
            return (hr);
        }
    }
    else
    {
        hr = CreateMenuBarObject(m_hwndParent,0,IID_IAccessible,(void**)&paccGrandParent);
        if (SUCCEEDED(hr))
        {
            pMenu = (CMenu*)paccGrandParent;
            pMenu->SetupChildren();
            hr = CreateMenuItem (paccGrandParent,   //	paccMenu	IN		pointer to the parent's IAccessible
                                 m_hwndParent,      //	hwnd		IN		the hwnd of the window that owns the parent menu
                                 pMenu->GetMenu(), //	hMenu		IN		the hmenu of the menu that owns this item.
                                 m_hMenu,           //	hSubMenu	IN		the hMenu of the submenu this menu item opens
                                 m_ItemID,          //	ItemID		IN		the menu item ID. Position (1..n).
                                 0,                 //	iCurChild	IN		ID of the current child in the enumeration
                                 m_fSonOfPopup,     //	fPopup		IN		is this menu item in a popup or on a menu bar?
                                 IID_IDispatch,     //	riid		IN		what interface are we asking for on this item?
                                 (void**)ppdispParent); //	ppvItem		OUT		the pointer to the interface asked for.
            paccGrandParent->Release();
            return (hr);
        }
    }
    return (hr);
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::get_accChild()
//
//	What we want this do do is return (in ppdisp) an IDispatch pointer to 
//  the child specified by varChild. The 1 child of a CMenuPopupFrame is
//  a cMenuPopup.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::get_accChild(VARIANT varChild, IDispatch** ppdisp)
{
    InitPv(ppdisp);

    if (!ValidateChild(&varChild) || varChild.lVal == CHILDID_SELF)
        return(E_INVALIDARG);

    return (CreateMenuPopupClient(m_hwnd, 0,IID_IDispatch, (void**)ppdisp));
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::get_accName
//
//  Has very similar logic to CMenuPopup::get_accName
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::get_accName(VARIANT varChild, BSTR* pszName)
{
HWND            hwndOwner;
TCHAR           szClassName[50];
HRESULT         hr;
IAccessible*    paccParent;

    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        // If we popped up from a menu bar or as another popup,
		// then our name is the name of the thing that popped us
		// up. If we are a floating popup, then our name is...?
		//
        // We implement this by either:
        // 1. creating a parent object on the fly that we can 
        //    ask the name of, OR
		// 2. Looking for the name of the owner window, OR
        // 3. Checking if we are the child of the start button. 
        // If all else fails, we'll just call ourselves "context menu".
        if (m_hwndParent && m_ItemID)
        {
            varChild.vt = VT_I4;
            varChild.lVal = m_ItemID;

            if (m_fSonOfPopup)
                hr = CreateMenuPopupClient(m_hwndParent,0,IID_IAccessible,(void**)&paccParent);
            else if (m_fSysMenu)
                hr = CreateSysMenuBarObject(m_hwndParent,0,IID_IAccessible,(void**)&paccParent);
            else
                hr = CreateMenuBarObject(m_hwndParent,0,IID_IAccessible,(void**)&paccParent);
            if (SUCCEEDED(hr))
            {
                hr = paccParent->get_accName (varChild,pszName);
                paccParent->Release();
            }
            return (hr);
        }
        else
		{
			// Try to get the owner window and use that for a name
			// This doesn't seem to work on anything I have ever found,
            // but it should work if anything has an owner, so i'll
            //leave it in. If it starts breaking, just rip it out.
			if (m_hwnd)
			{
			IAccessible*	pacc;
			HRESULT			hr;

				hwndOwner = ::GetWindow (m_hwnd,GW_OWNER);
				hr = AccessibleObjectFromWindow (hwndOwner, OBJID_WINDOW, IID_IAccessible, (void**)&pacc);
				if (SUCCEEDED(hr))
				{
					hr = pacc->get_accName(varChild,pszName);
                    pacc->Release();
					if (SUCCEEDED(hr))
						return (hr);
				}
			}
			// check if the start button has focus
			hwndOwner = MyGetFocus();
			if (InTheShell(hwndOwner, SHELL_TRAY))
			{
                GetClassName(hwndOwner,szClassName,ARRAYSIZE(szClassName));
                if (lstrcmp(szClassName,TEXT("Button")) == 0)
                    return (HrCreateString(STR_STARTBUTTON,pszName));
			}
			// at least return this for a name
            return (HrCreateString (STR_CONTEXT_MENU,pszName));
		} // end else we don't have m_paccparent && m_itemid
    } // end if childid_self
    else
    {
        // not asking for name of the menupopupframe itself. We do not support asking for
        // name of our child - have to talk to the child itself
        return (E_INVALIDARG);
    }

}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::accHitTest()
//
//  We just need to return VARIANT with var.pDispVal set to be our one child, 
//  the CMenuPopup.
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::accHitTest(long x, long y, VARIANT* pvarHit)
{
IDispatch*  pdispChild;
HRESULT     hr;

    InitPvar(pvarHit);
    SetupChildren();

    pvarHit->vt = VT_I4;
    pvarHit->lVal = CHILDID_SELF;

    if (SendMessage(m_hwnd, WM_NCHITTEST, 0, MAKELONG(x, y)) == HTCLIENT)
    {
        hr = CreateMenuPopupClient (m_hwnd,0,IID_IDispatch,(void**)&pdispChild);
        if (SUCCEEDED (hr))
        {
            pvarHit->vt = VT_DISPATCH;
            pvarHit->pdispVal = pdispChild;
        }
        return(hr);
    }

    return(S_OK);
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::get_accFocus()
//
// This fills in pvarFocus with the child that has the focus.
// Since we only have one child, We'll return an IDispatch to that child.
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::get_accFocus(VARIANT* pvarFocus)
{
HRESULT     hr;
IDispatch*  pdispChild;

    InitPvar(pvarFocus);
    hr = CreateMenuPopupClient(m_hwnd, 0,IID_IDispatch, (void**)&pdispChild);
    if (!SUCCEEDED(hr))
        return (hr);

    pvarFocus->vt = VT_DISPATCH;
    pvarFocus->pdispVal = pdispChild;
    return (S_OK);
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::accLocation()
//
//  Location of Self and Child is the same.
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(CWindow::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd)
{
    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD || dwNavDir == NAVDIR_LASTCHILD)
    {
        pvarEnd->vt = VT_DISPATCH;
        return (CreateMenuPopupClient (m_hwnd,0,IID_IDispatch, (void**)&(pvarEnd->pdispVal)));
    }

    return (S_FALSE);
}
                                          
// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::Clone(IEnumVARIANT **ppenum)
{
    return (CreateMenuPopupWindow(m_hwnd, m_idChildCur, IID_IEnumVARIANT,
        (void**)ppenum));
}

// --------------------------------------------------------------------------
//
//  CMenuPopupFrame::Next()
//
// --------------------------------------------------------------------------
STDMETHODIMP CMenuPopupFrame::Next(ULONG celt, VARIANT* rgvar, ULONG* pceltFetched)
{
    VARIANT* pvar;
    long    cFetched;

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    pvar = rgvar;
    cFetched = 0;

    // we only have one child, so we can only return it if m_idChildCur == 0
    if (m_idChildCur == 0)
    {
        cFetched++;
        m_idChildCur++;
        pvar->vt = VT_DISPATCH;
        CreateMenuPopupClient (m_hwnd,0,IID_IDispatch, (void**)&(pvar->pdispVal));
    }

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched = cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
// This is a private function used to get the window handle that contains
// a given hSubMenu.
//
// --------------------------------------------------------------------------

HWND GetSubMenuWindow (HMENU hSubMenuToFind)
{
HWND    hwndSubMenu;
BOOL    bFound;
HMENU   hSubMenuTemp;

    hwndSubMenu = FindWindow (TEXT("#32768"),NULL);
    if (hwndSubMenu == NULL)
        return (NULL);    // random error condition - shouldn't happen
    
    if (!IsWindowVisible(hwndSubMenu))
        return (NULL);

    bFound = FALSE;
    while (hwndSubMenu)
    {
        hSubMenuTemp = (HMENU)SendMessage (hwndSubMenu,MN_GETHMENU,0,0);
        if (hSubMenuTemp == hSubMenuToFind)
        {
            bFound = TRUE;
            break;
        }
        hwndSubMenu = FindWindowEx (NULL,hwndSubMenu,TEXT("#32768"),NULL);
    } // end while hwndSubMenu

    if (bFound)
    {
        return(hwndSubMenu);
    }
    return (NULL);
}



// --------------------------------------------------------------------------
// This looks at each item in the Active window's menu and any other menu 
// windows, until it finds one that has an hSubMenu that matches the hMenu 
// we are trying to find. It then returns the ID of that thing (1..n) and
// fills in the window handle of the owner, and whether that window is a top
// level window or a popup menu.
// --------------------------------------------------------------------------
long FindItemIDThatOwnsThisMenu (HMENU hMenuOwned,HWND* phwndOwner,
                                 BOOL* pfPopup,BOOL *pfSysMenu)
{
HWND            hwndMenu;
HMENU           hMenu;
int             cItems;
int             i;

    if (IsBadWritePtr(phwndOwner,sizeof(HWND*)) || 
        IsBadWritePtr (pfPopup,sizeof(BOOL*))   ||
        IsBadWritePtr (pfSysMenu,sizeof(BOOL*)))
        return 0;

    *pfPopup = FALSE;
    *pfSysMenu = FALSE;
    *phwndOwner = NULL;

    GUITHREADINFO	GuiThreadInfo;
    if( ! MyGetGUIThreadInfo (NULL,&GuiThreadInfo) )
        return 0;
    
    // check if it is from the sys menu first
    MENUBARINFO     mbi;
    if( MyGetMenuBarInfo(GuiThreadInfo.hwndActive, OBJID_SYSMENU, 0, &mbi) 
        && mbi.hMenu != NULL )
    {
        hMenu = mbi.hMenu;

        if (GetSubMenu(hMenu,0) == hMenuOwned)
        {
            *pfSysMenu = TRUE;
            *pfPopup = FALSE;
            *phwndOwner = GuiThreadInfo.hwndActive;
            return (1);
        }
    }

    // if not from the sys menu, check the window's menu bar
    hMenu = GetMenu (GuiThreadInfo.hwndActive);
    if (hMenu)
    {
        cItems = GetMenuItemCount (hMenu);
        for (i=0;i<cItems;i++)
        {
#ifdef _DEBUG
            if (!hMenu)
            {
                //DBPRINTF ("null hmenu at 5\r\n");
                Assert (hMenu);
            }
#endif

            if (GetSubMenu(hMenu,i) == hMenuOwned)
            {
                *pfPopup = FALSE;
                *phwndOwner = GuiThreadInfo.hwndActive;
                return (i+1);
            }
        }
    }

	// Okay, it doesn't belong to the active window's menu bar, maybe
	// it belongs to a submenu of that...
    hwndMenu = FindWindow (TEXT("#32768"),NULL);
    while (hwndMenu)
    {
        hMenu = (HMENU)SendMessage (hwndMenu,MN_GETHMENU,0,0);
        if (hMenu)
        {
            cItems = GetMenuItemCount (hMenu);
            for (i=0;i<cItems;i++)
            {
                if (GetSubMenu(hMenu,i) == hMenuOwned)
			    {
                    *pfPopup = TRUE;
                    *phwndOwner = hwndMenu;
                    return (i+1);
                }
            }
        }
        hwndMenu = FindWindowEx (NULL,hwndMenu,TEXT("#32768"),NULL);
    } // end while hwndMenu
	
	// if we still haven't returned, then this menu is either a context
	// menu, or belongs to the start button
	return 0;
}



// --------------------------------------------------------------------------
//
//  INTERNAL
//  MyGetMenuString()
//
//  This tries to get the text of menu items.  If they are ownerdraw, this
//  will hack around in shell structures to get the text.
//
//  Parameters:
//  hwnd            IN  the hwnd that owns the menu 
//  hMenu           IN  the hMenu to talk to
//  id              IN  the ID of the item to get (1..n)
//  fShell          IN  TRUE if this is a shell owned menu - tells the function
//                      to hack into the shell's memory
//  lpszBuf         OUT gets filled in with the string
//  cchMax          IN  number of characters in lpszBuf
//  fAllowGenerated IN  If TRUE, generated names (eg. those for MDI items)
//                      are allowed.
//
//  Returns:
//  TRUE if string was filled in, FALSE otherwise
//
//  Returns:
//  S_OK if string returned, S_FALSE for missing string, COM error code
//  otherwise.
//
//  'Generated names' are menu item names that do not actually correspond
//  to text on the menu item - eg. "Close"/"Restore" for the MDI buttons.
//  Typically you do want this text if you are looking for the name, but you
//  do not want this text if you are looking to extract a shortcut key.
// --------------------------------------------------------------------------

BOOL MyGetMenuString( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, long id, 
                      LPTSTR lpszBuf, UINT cchMax, BOOL fAllowGenerated )
{
    --id;
    *lpszBuf = 0;

    MENUITEMINFO mii;
    mii.cbSize = SIZEOF_MENUITEMINFO;
    mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_DATA | MIIM_ID;
    mii.dwTypeData = NULL;
    mii.cch = 0;

    if (!GetMenuItemInfo(hMenu, id, TRUE, &mii))
        return FALSE;

    // Is this a separator?  If so, bail.
    if (mii.fType & MFT_SEPARATOR)
        return FALSE;

    // For MDI windows - the min/restore/close buttons of the child window are
    // actually menu items. Have to check for them here...
    if( fAllowGenerated && hwnd && GetMDIMenuString( hwnd, hMenu, id, lpszBuf, cchMax ) )
        return TRUE;

    // If it's owner-draw, check if it supports the the 'dwData is ptr to
    // MSAA data' workaround.
    if( ( mii.fType & MFT_OWNERDRAW )
        && TryMSAAMenuHack( pTheObj, hwnd, mii.dwItemData, lpszBuf, cchMax ) )
        return TRUE;

    // Try to get the text.
    //
    // GetMenuString does the right thing for Win95/NT close/min/max
    // system menu items - whereas mii.dwTypeData only contains a bitmap
    // number (apparently - although cchSize does give the character
    // count as though it were a string...)
    if (GetMenuString(hMenu, id, lpszBuf, cchMax, MF_BYPOSITION))
        return TRUE;

    // is this a shell owner menu item?
    // Check that (a) this is a shell menu, (b) it's ownerdraw, and
    // (c) it has non-0 ownerdraw itemdata,
    if ( InTheShell( hwnd, SHELL_PROCESS ) && ( mii.fType & MFT_OWNERDRAW ) && mii.dwItemData )
    {
        if( GetShellOwnerDrawMenu( hwnd, mii.dwItemData, lpszBuf, cchMax ) )
            return TRUE;
    }

    // We've tried everything, but didn't get any name...
    return FALSE;
}




// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetShellOwnerDrawMenu
//
//  Pull text out of shell's internal data structs.
//  This is used by the SendTo menu. (Also used to be used by the old
//  pre-IE4 start menus, before they changed to being Toolbar32 based.)
//
//	Parameters:
//	hwnd	IN		hwnd of menu
//	dwItemData	IN	dwItemData from the menu
//	lpszBuf	IN/OUT	gets filled in with the string
//	cchMax	in		number of characters in lpszBuf
//
//	Returns:
//	TRUE if string was filled in, FALSE otherwise
// --------------------------------------------------------------------------

BOOL GetShellOwnerDrawMenu( HWND hwnd, DWORD_PTR dwItemData, LPTSTR lpszBuf, UINT cchMax )
{
    DWORD idProcess = 0;
    GetWindowThreadProcessId(hwnd, &idProcess);
    if (!idProcess)
        return FALSE;

    HANDLE hProcess = OpenProcess(PROCESS_VM_READ, FALSE, idProcess);
    if (!hProcess)
        return FALSE;

    //
    // Try to read FILEMENUITEM's worth of stuff.
    //
    FILEMENUITEM  fmi;
    SIZE_T        cbRead;
    if (ReadProcessMemory(hProcess, (LPCVOID)dwItemData, &fmi, sizeof(fmi), &cbRead) &&
        (cbRead == sizeof(fmi)))
    {
        //
        // Is there a string pointer in here?
        //
        if (fmi.psz)
        {
            ReadProcessMemory(hProcess, fmi.psz, lpszBuf, cchMax, &cbRead);
            lpszBuf[cchMax-1] = 0;
        }
        else if (fmi.pidl)
        {
            ITEMIDLIST id;

            // No, we have to grovel inside of the PIDL
            if (ReadProcessMemory(hProcess, fmi.pidl, &id, sizeof(ITEMIDLIST), &cbRead) &&
                (cbRead == sizeof(id)))
            {
                id.cbTotal -= OFFSET_SZFRIENDLYNAME;
                cchMax = min((DWORD)id.cbTotal, cchMax);
                cchMax = max(cchMax, 1);

                ReadProcessMemory(hProcess, (LPBYTE)fmi.pidl + OFFSET_SZFRIENDLYNAME,
                    lpszBuf, cchMax, &cbRead);
                lpszBuf[cchMax-1] = 0;

                //
                // Are the last 4 characters ".lnk"? or ".pif"?
                // or .??? - we'll cut 'em all off.
                //
                cchMax = lstrlen(lpszBuf);
                if ((cchMax >= 4) && (lpszBuf[cchMax-4] == '.'))
                    lpszBuf[cchMax-4] = 0;
            }
        }
    }

    CloseHandle(hProcess);

    return *lpszBuf != 0;
}





// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetMDIButtonIndex
//
//  Returns appropritate INDEX_TITLEBAR_nnn for the given menu item, if it
//  is really an MDI child button (restore/minimize/close).
//
//  Returns 0 otherwise.
//
// --------------------------------------------------------------------------


UINT GetMDIButtonIndex( HMENU hMenu, DWORD idPos )
{
    switch( GetMenuItemID( hMenu, idPos ) )
    {
        case SC_MINIMIZE:   return INDEX_TITLEBAR_MINBUTTON;
        case SC_RESTORE:    return INDEX_TITLEBAR_RESTOREBUTTON;
        case SC_CLOSE:      return INDEX_TITLEBAR_CLOSEBUTTON;
        default:            return 0; // INDEX_TITLEBAR_SELF
    }
}


// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetMDIChildMenuString
//
//  Check if this is a MDI menu - return strings for the document menu,
//  and the min/restore/close buttons
//
//	Parameters:
//	hmenu   IN	    handle of menu
//	id      IN	    0-based index of the menu item
//	lpszBuf	IN/OUT	gets filled in with the string
//	cchMax	in		number of characters in lpszBuf
//
//	Returns:
//	TRUE if string was filled in, FALSE otherwise
// --------------------------------------------------------------------------

BOOL GetMDIMenuString( HWND hwnd, HMENU hMenu, DWORD idPos, LPTSTR lpszBuf, UINT cchMax )
{
    // For MDI windows - the min/restore/close buttons of the child window are
    // actually owner-draw menu items. Have to check for them here...

    UINT iIndex = GetMDIButtonIndex( hMenu, idPos );
    if( iIndex )
    {
        return LoadString( hinstResDll, iIndex + STR_TITLEBAR_NAME, lpszBuf, cchMax ) != 0;
    }

    // Detect the document system menu by checking that it has a submenu
    // which contains the Restore item (GetMenuState returns -1 if not found...)
    // but which is not the actual system menu (since that also has a restore item).
    HMENU hSub = GetSubMenu( hMenu, idPos );
    if( hSub && GetMenuState( hSub, SC_RESTORE, MF_BYCOMMAND ) != -1
        && hSub != MyGetSystemMenu( hwnd ) )
    {
        return LoadString( hinstResDll, STR_DOCMENU_NAME, lpszBuf, cchMax ) != 0;
    }

    return FALSE;
}




// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetMDIMenuDescriptionString
//
//  Check if this is a MDI menu - return description strings for the document
//  menu, and the min/restore/close buttons
//
//	Parameters:
//	hmenu   IN	    handle of menu
//	idPos   IN	    0-based index of the menu item
//	pbstr   OUT     returns the description of the item
//
//	Returns:
//	TRUE if item is a MDI element and pbstr was set, FALSE otherwise.
// --------------------------------------------------------------------------

BOOL GetMDIMenuDescriptionString( HMENU hMenu, DWORD idPos, BSTR * pbstr )
{
    UINT iIndex = GetMDIButtonIndex( hMenu, idPos );
    if( iIndex )
    {
        return HrCreateString( iIndex + STR_TITLEBAR_DESCRIPTION, pbstr ) == S_OK;
    }
    else
    {
        return FALSE;
    }
}


// --------------------------------------------------------------------------
//
//  INTERNAL
//  TryMSAAMenuHack()
//
//  Checks if a menu supports the 'dwData is ptr to MSAA data' workaround.
//
//	Parameters:
//	pTheObj	IN		the hwnd that owns the menu (used to get window handle
//                  if hWnd is NULL)
//	hWnd	IN		hwnd of menu, NULL if not known (eg. invisible 'fake'
//                  popups)
//	dwItemData	IN	dwItemData from the menu
//	lpszBuf	IN/OUT	gets filled in with the string
//	cchMax	in		number of characters in lpszBuf
//
//	Returns:
//	TRUE if string was filled in, FALSE otherwise
// --------------------------------------------------------------------------

BOOL TryMSAAMenuHack( IAccessible *  pTheObj,
                      HWND           hWnd,
                      DWORD_PTR      dwItemData,
                      LPTSTR         lpszBuf,
                      UINT           cchMax )
{
    BOOL bGotIt = FALSE;

    if( ! hWnd )
    {
        // It's an invisible 'fake' popup menu (CPopuMenu created to expose
        // a HMENU, but no menu, and therefore no popup window, is currenly
        // visible).
        // Need a window handle so we can get the process id...
        if( WindowFromAccessibleObjectEx( pTheObj, & hWnd ) != S_OK || hWnd == NULL )
            return FALSE;
    }

    // ...now get process id...
    DWORD idProcess = 0;
    GetWindowThreadProcessId( hWnd, &idProcess );
    if( !idProcess )
        return FALSE;

    // Open that process so we can read its memory...
    HANDLE hProcess = OpenProcess( PROCESS_VM_READ, FALSE, idProcess );
    if( hProcess )
    {
        // Treat dwItemData as an address, and try to read a
        // MSAAMENUINFO struct from there...
        MSAAMENUINFO menuinfo;
        SIZE_T cbRead;

        if( ReadProcessMemory( hProcess, (LPCVOID)dwItemData, (LPVOID) & menuinfo, sizeof( menuinfo ), &cbRead ) 
            && ( cbRead == sizeof( menuinfo ) ) )
        {

            // Check signature...
            if( menuinfo.dwMSAASignature == MSAA_MENU_SIG )
            {
                // Work out len of UNICODE string to copy (+1 for terminating NUL)
                DWORD copyLen = ( menuinfo.cchWText + 1 ) * sizeof( WCHAR );

                WCHAR * pAlloc = (LPWSTR) LocalAlloc( LPTR, copyLen );
                if( pAlloc )
                {

                    // Do the copy... also fail if we read less than expected, or terminating NUL missing...
                    if( ReadProcessMemory( hProcess, (LPCVOID)menuinfo.pszWText, pAlloc, copyLen, &cbRead ) 
                            && ( cbRead == copyLen )
                            && ( pAlloc[ menuinfo.cchWText ] == '\0' ) )
                    {

#ifdef UNICODE
						// Copy text to output buffer...
						if( cchMax > 0 )
						{
							UINT cchCopy = menuinfo.cchWText;
							if( cchCopy > cchMax - 1 )
								cchCopy = cchMax - 1; // -1 for terminating NUL
							memcpy( lpszBuf, pAlloc, cchCopy * sizeof( TCHAR ) );
							lpszBuf[ cchCopy ] = L'\0';
							bGotIt = TRUE;
						}
#else
                        // Convert (and copy) UNICODE to ANSI...
                        if( WideCharToMultiByte( CP_ACP, 0, pAlloc, -1, lpszBuf, cchMax, NULL, NULL ) != 0 )
                        {
                            bGotIt = TRUE;
                        }
#endif
                    }

                    LocalFree( pAlloc );
                } // pAlloc
            } // m_Signature
        } // ReadProcessMemory

        CloseHandle( hProcess );
    } // hProcess

    return bGotIt;
}






// --------------------------------------------------------------------------
//
//  WindowFromAccessibleObjectEx()
//
//  This walks UP the ancestor chain until we find something who responds to
//  IOleWindow().  Then we get the HWND from it.
//
//  This is effectively a local version of WindowFromAccessibleObject
//  This version doesn't stop till it runs out of objects, it gets a valid
//  hwnd. The non-ex version stops even if it getgs a NULL hwnd.
//  This allows us to navigate up through menupopups which have no hwnd
//  (return NULL), but which do have parents, which eventually leads us to
//  the owning hWnd.
//
// --------------------------------------------------------------------------
STDAPI WindowFromAccessibleObjectEx( IAccessible* pacc, HWND* phwnd )
{
IAccessible* paccT;
IOleWindow* polewnd;
IDispatch* pdispParent;
HRESULT     hr;

    //CWO: 12/4/96, Added check for NULL object
    //CWO: 12/13/96, Removed NULL check, replaced with IsBadReadPtr check (#10342)
    if (IsBadWritePtr(phwnd,sizeof(HWND*)) || IsBadReadPtr(pacc, sizeof(void*)))
        return (E_INVALIDARG);

    *phwnd = NULL;
    paccT = pacc;
    hr = S_OK;

    while (paccT && SUCCEEDED(hr))
    {
        polewnd = NULL;
        hr = paccT->QueryInterface(IID_IOleWindow, (void**)&polewnd);
        if (SUCCEEDED(hr) && polewnd)
        {
            hr = polewnd->GetWindow(phwnd);
            polewnd->Release();

            // Don't quit if we just got a NULL hwnd...
            // (this is the only change from WindowFromAccessibleObject(), which
            // just unconditionally returned when it got here...)
            if( *phwnd != NULL )
            {
                //
                // Release an interface we obtained on our own, but not the one
                // passed in.
                //
                if (paccT != pacc)
                {
                    paccT->Release();
                    paccT = NULL;
                }
                break;
            }
        }

        //
        // Get our parent.
        //
        pdispParent = NULL;
        hr = paccT->get_accParent(&pdispParent);

        //
        // Release an interface we obtained on our own, but not the one
        // passed in.
        //
        if (paccT != pacc)
        {
            paccT->Release();
        }

        paccT = NULL;

        if (SUCCEEDED(hr) && pdispParent)
        {
            hr = pdispParent->QueryInterface(IID_IAccessible, (void**)&paccT);
            pdispParent->Release();
        }
    }

    return(hr);
}






// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetMenuItemName()
//
//  Returns the BSTR name for a menu item.
//
//  Parameters:
//  pTheObj         IN      the hwnd that owns the menu (used to get window
//                          handle if hWnd is NULL)
//  hWnd            IN      hwnd of menu, NULL if not known (eg. invisible
//                          'fake' popups)
//  hMenu           IN      Menu handle
//  id              IN      1-based id of the menu item (idChild)
//  pszName         OUT     returns string containing text for menu item.
//
//  Returns:
//  S_OK if string returned, S_FALSE for missing string, COM error code
//  otherwise.
//
//  Catches special cases " " and "-", which get mapped to "System" and
//  "Document window" respectively. These are the top-level and child window
//  system menus.
//
// --------------------------------------------------------------------------

HRESULT GetMenuItemName( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, LONG id, BSTR * pszName )
{
    Assert( hMenu );

    TCHAR szItemName[256];

    // TRUE -> allow generated names (eg. for MDI buttons)
    if( MyGetMenuString( pTheObj, hwnd, hMenu, id, szItemName, ARRAYSIZE( szItemName ), TRUE ) )
    {
        StripMnemonic( szItemName );

        if( lstrcmp( szItemName, TEXT(" ") ) == 0 )
        {
            return HrCreateString( STR_SYSMENU_NAME, pszName ); // "System"
        }

        if( lstrcmp( szItemName, TEXT("-") ) == 0 )
        {
            return HrCreateString( STR_DOCMENU_NAME, pszName ); // "Document window"
        }

        *pszName = TCharSysAllocString(szItemName);
        if( ! *pszName )
            return E_OUTOFMEMORY;

        return S_OK;
    }
    else
    {
        *szItemName = '\0';
        *pszName = NULL;
        return S_FALSE;
    }
}




// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetMenuItemShortcut()
//
//  Returns the BSTR name for a menu shortcut.
//
//  Parameters:
//  pTheObj     IN      the hwnd that owns the menu (used to get window
//                      handle if hWnd is NULL)
//  hWnd        IN      hwnd of menu, NULL if not known (eg. invisible
//                      'fake' popups)
//  hMenu       IN      Menu handle
//  id          IN      1-based id of the menu item (idChild)
//  fIsMenuBar  IN      TRUE if the menu is a menubar; false for a popup
//  pszShortcut OUT     returns string containing kbshortcut for menu item.
//
//  Returns:
//  S_OK if string returned, S_FALSE for missing string, COM error code
//  otherwise.
//
//  Catches special case " " for system menu.
//  If fMenuBar is TRUE, uses "Alt+%c" form.
//
// --------------------------------------------------------------------------

HRESULT GetMenuItemShortcut( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, LONG id,
                             BOOL fIsMenuBar, BSTR * pszShortcut )
{
    TCHAR szHotKey[32];
    szHotKey[0] = GetMenuItemHotkey( pTheObj, hwnd, hMenu, id,
                                     GMIH_ALLOW_INITIAL | GMIH_ALLOW_SYS_SPACE );
    szHotKey[1] = 0;

    if ( szHotKey[0] == ' ' )
    {
        // Expand space character ' ' to the string "Space"
        szHotKey[ 0 ] = '\0';
        LoadString( hinstResDll, STR_SYSMENU_KEY, szHotKey, ARRAYSIZE( szHotKey ) );
    }

    // Fall through... This gives us c -> Alt+c if it was a single char,
    // or ' ' -> "Space" -> "Alt+Space" if it was a space char (for sys menu).

    if ( *szHotKey )
    {
        // If this is a menu bar, use the ALT+ form...
        if ( fIsMenuBar )
        {
            // Make a string of the form "Alt+ch".
            return HrMakeShortcut( szHotKey, pszShortcut );
        }
        else
        {
            // otherwise use just the key
            *pszShortcut = TCharSysAllocString( szHotKey );
            if ( ! *pszShortcut )
            {
                return E_OUTOFMEMORY;
            }

            return S_OK;
        }
    }

    *pszShortcut = NULL;
    return S_FALSE;
}





// --------------------------------------------------------------------------
//
//  INTERNAL
//  GetMenuItemHotkey()
//
//  Returns the TCHAR hotkey for a menu, if one exists.
//
//  Parameters:
//  pTheObj     IN      the hwnd that owns the menu (used to get window
//                      handle if hWnd is NULL)
//  hWnd        IN      hwnd of menu, NULL if not known (eg. invisible
//                      'fake' popups)
//  hMenu       IN      Menu handle
//  id          IN      1-based id of the menu item (idChild)
//  fOption     IN      Option flags - see below.
//
//  Returns:
//  Hotkey character of menu item, or '\0' if item has no hotkey.
//
//  Options:
//
//    GMIH_ALLOW_INITIAL
//      If set, allows the initial character of the menu item string to be
//      returned as the shortcut key (provided that no other items also use
//      that key as their menonic.)
//
//    GMIH_ALLOW_SYS_SPACE   = 0x02
//      If set, returns ' ' as the shortcut key of the system menu item.
//
// --------------------------------------------------------------------------

TCHAR GetMenuItemHotkey( IAccessible * pTheObj, HWND hwnd, HMENU hMenu, LONG id, DWORD fOptions )
{
    TCHAR szItemName[ 256 ];

    // FALSE -> disallow generated names (eg. for MDI buttons)
    if( ! MyGetMenuString( pTheObj, hwnd, hMenu, id, szItemName, ARRAYSIZE( szItemName ), FALSE ) )
    {
        return '\0';
    }

    // Check for menu name being " " - caller will want to treat this as a special hotkey of "Space".
    // (eg. givein "Alt+Space" as the entire hotkey string.)
    if( ( fOptions & GMIH_ALLOW_SYS_SPACE )
        && lstrcmp( szItemName, TEXT(" ") ) == 0 )
    {
        return ' ';
    }

    TCHAR ch = StripMnemonic( szItemName );

    // Can stop here if caller doesn't want initial chars (ie. &-mnemonics only)
    if( ! ( fOptions & GMIH_ALLOW_INITIAL ) )
    {
        return ch;
    }



    // Did we get a hot-key? If so, use it.
    if( ch != '\0' )
    {
        return ch;
    }

    // Try initial letter instead...
    LPTSTR pScanCh = szItemName;
    while( *pScanCh == ' ' )
    {
        *pScanCh++;
    }

    // Obscure USER32 menu thing - was used to right-justify Help items in a previous version?
    // Anyhow, USER skips over it to find the real first letter. So we do likewise...
    if( *pScanCh == '\x08' )
    {
        pScanCh++;
    }

    // Just in case there's no initial letter... (all spaces)
    if( *pScanCh == '\0' )
    {
        return '\0';
    }

    // Hotkeys are always returned as lowercase...
    CharLowerBuff( pScanCh, 1 );
    ch = *pScanCh;



    // Now compare against all other menu items - if one other item has this
    // initial letter as its mnemonic, then we can't use it for this one.
    // (Mnemonic takes precedence over initial letters)

    // GetMenuItemHotkey index is 1-based (ie. idChild), as is id, so also
    // using a 1-based index here.
    int cItems = GetMenuItemCount( hMenu );
    for( int iScan = 1 ; iScan <= cItems ; iScan++ )
    {
        // Don't compare against this item!
        if( iScan != id )
        {
            if( ch == GetMenuItemHotkey( pTheObj, hwnd, hMenu, iScan, NULL ) )
            {
                // Some other item has a mnemonic that is the same as this
                // item's initial char - it mnemonic takes precedence, so
                // this item has no kbshortcut.
                return '\0';
            }
        }
    }

    // No item use this item's initial char as a mnemonic - we're clear to use
    // it as this item's kbshortcut.
    return ch;
}


// --------------------------------------------------------------------------
//
//  INTERNAL
//  MyGetSystemMenu()
//
//  Returns the system HMENU for the given HWND.
//
//  Can't use the Win32 API GetSystemMenu, since that modifies the system
//  HMENU for the window.
//
// --------------------------------------------------------------------------

HMENU MyGetSystemMenu( HWND hwnd )
{
    MENUBARINFO mbi;
    if ( ! MyGetMenuBarInfo( hwnd, OBJID_SYSMENU, 0, &mbi ) )
    {
        return NULL;
    }
    // GetMenuBarInfo returns a menu containing the sysmenu as its only
    // submenu. Use GetSubMenu to access that...
    return GetSubMenu( mbi.hMenu, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\listview.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  LISTVIEW.CPP
//
//  Wrapper for COMCTL32's listview control
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "listview.h"
#include "RemoteProxy6432.h"
#include "propmgr_util.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOTOOLBAR
#define NOHOTKEY
#define NOPROGRESS
#define NOTREEVIEW
#define NOANIMATE
#include <commctrl.h>
#include "Win64Helper.h"


#ifndef LVM_GETSELECTEDCOLUMN

#define LVM_GETVIEW         (LVM_FIRST + 143)
#define ListView_GetView(hwnd) \
    SNDMSG((hwnd), LVM_GETVIEW, 0, 0)

#define LVM_GETSELECTEDCOLUMN   (LVM_FIRST + 174)
#define ListView_GetSelectedColumn(hwnd) \
    (UINT)SNDMSG((hwnd), LVM_GETSELECTEDCOLUMN, 0, 0)

#define LV_VIEW_ICON        0x0000
#define LV_VIEW_DETAILS     0x0001
#define LV_VIEW_SMALLICON   0x0002
#define LV_VIEW_LIST        0x0003
#define LV_VIEW_TILE        0x0004

#endif








#define MAX_NAME_TEXT   256


enum
{
    LV_IMGIDX_Image,
    LV_IMGIDX_State,
    LV_IMGIDX_Overlay,
    LV_IMGIDX_COUNT
};

BOOL LVGetImageIndex( HWND hwnd, int id, int aKeys[ LV_IMGIDX_COUNT ] );

HRESULT LVBuildDescriptionString( HWND hwnd, int iItem, int * pCols, int cCols, BSTR * pszDesc );

HRESULT LVGetDescription_ReportView( HWND hwnd, int iItem, BSTR * pszDesc );

HRESULT LVGetDescription_TileView( HWND hwnd, int iItem, BSTR * pszDesc );


extern "C" {
// in outline.cpp...
BOOL GetRoleFromStateImageMap( HWND hwnd, int iImage, DWORD * pdwRole );
BOOL GetStateFromStateImageMap( HWND hwnd, int iImage, DWORD * pdwState );
}



// --------------------------------------------------------------------------
//
//  CreateListViewClient()
//
// --------------------------------------------------------------------------
HRESULT CreateListViewClient(HWND hwnd, long idChildCur, REFIID riid,
    void** ppvList)
{
    CListView32 * plist;
    HRESULT     hr;

    InitPv(ppvList);

    plist = new CListView32(hwnd, idChildCur);
    if (!plist)
        return(E_OUTOFMEMORY);

    hr = plist->QueryInterface(riid, ppvList);
    if (!SUCCEEDED(hr))
        delete plist;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CListView32::CListView32()
//
// --------------------------------------------------------------------------
CListView32::CListView32(HWND hwnd, long idChildCur)
    : CClient( CLASS_ListViewClient )
{
    Initialize(hwnd, idChildCur);
    m_fUseLabel = TRUE;
}



// --------------------------------------------------------------------------
//
//  CListView32::SetupChildren()
//
// --------------------------------------------------------------------------
void CListView32::SetupChildren(void)
{
    m_cChildren = SendMessageINT(m_hwnd, LVM_GETITEMCOUNT, 0, 0L);
}



// --------------------------------------------------------------------------
//
//  CListView32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
    {
        if (InTheShell(m_hwnd, SHELL_DESKTOP))
            return(HrCreateString(STR_DESKTOP_NAME, pszName));
        else
            return(CClient::get_accName(varChild, pszName));
    }

	TCHAR tchText[MAX_NAME_TEXT + 1] = {0};
	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.mask = LVIF_TEXT;
	lvi.pszText = tchText;
	lvi.cchTextMax = MAX_NAME_TEXT;
	lvi.iItem = varChild.lVal - 1;

	if (SUCCEEDED(XSend_ListView_GetItem(m_hwnd, LVM_GETITEM, 0, &lvi)))
	{
		if (*lvi.pszText)
			*pszName = TCharSysAllocString(lvi.pszText);
	}

    return(*pszName ? S_OK : S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CListView32::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{
    InitPv(pszDesc);
    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    if (!varChild.lVal)
        return CClient::get_accDescription(varChild, pszDesc);

    // Special cases for details (report) and tile views.
    

    DWORD dwView = ListView_GetView( m_hwnd );

    DWORD dwStyle = GetWindowLong( m_hwnd, GWL_STYLE );

    // Have to check for report/details view in two ways: 
    // - check the style for LVS_REPORT (pre-V6)
    // - check LVM_GETVIEW for LV_VIEW_DETAILS (V6+)
    if( ( dwStyle & LVS_TYPEMASK ) == LVS_REPORT 
        || dwView == LV_VIEW_DETAILS )
    {
        return LVGetDescription_ReportView( m_hwnd, varChild.lVal - 1, pszDesc );
    }

    if( dwView == LV_VIEW_TILE )
    {
        return LVGetDescription_TileView( m_hwnd, varChild.lVal - 1, pszDesc );
    }

    return E_NOT_APPLICABLE;
}


// --------------------------------------------------------------------------
//
//  CListView32::get_accHelp()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    if ( pszHelp == NULL )
        return E_POINTER;
    
    InitPv(pszHelp);
    if (!ValidateChild(&varChild))
        return E_INVALIDARG;
    
    if (!varChild.lVal)
        return(S_FALSE);

    LVITEM_V6 lvi;
    lvi.iItem = varChild.lVal -1;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_GROUPID;
    lvi.cColumns = 0;
    lvi.puColumns = NULL;

    HRESULT hr;
    
    hr = XSend_ListView_V6_GetItem( m_hwnd, LVM_GETITEM, 0, &lvi );
    if( hr != S_OK || lvi.iGroupId <= 0 )
    {
        DBPRINTF( TEXT("XSend_ListView_V6_GetItem hr = %x, lvi.iGroupId = %d\r\n"), hr,  lvi.iGroupId );
        return E_NOT_APPLICABLE;
    }

    
    LVGROUP_V6 grp;
	memset(&grp, 0, sizeof(LVGROUP_V6));
	TCHAR szHeader[MAX_NAME_TEXT + 1] = {0};
	
    grp.cbSize = sizeof(LVGROUP_V6);
    grp.mask = LVGF_HEADER;
	grp.pszHeader = szHeader;
	grp.cchHeader = MAX_NAME_TEXT;
	grp.iGroupId = lvi.iGroupId;

    hr = XSend_ListView_V6_GetGroupInfo( m_hwnd, LVM_GETGROUPINFO, lvi.iGroupId, &grp );
    if( FAILED( hr ) )
        return hr;
    
    *pszHelp = TCharSysAllocString( grp.pszHeader );
    
    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CListView32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    if (varChild.lVal)
    {
        DWORD dwRole;
        BOOL fGotRole = FALSE;

        int aKeys[ LV_IMGIDX_COUNT ];
        if( LVGetImageIndex( m_hwnd, varChild.lVal - 1, aKeys ) )
        {
            if( CheckDWORDMap( m_hwnd, OBJID_CLIENT, CHILDID_SELF,
                               PROPINDEX_ROLEMAP,
                               aKeys, ARRAYSIZE( aKeys ),
                               & dwRole ) )
            {
                pvarRole->lVal = dwRole;
                fGotRole = TRUE;
            }
            else if( GetRoleFromStateImageMap( m_hwnd, aKeys[ LV_IMGIDX_Image ], & dwRole ) )
            {
                pvarRole->lVal = dwRole;
                fGotRole = TRUE;
            }
        }

        if( ! fGotRole )
        {
            //
            //  Note that just because the listview has LVS_EX_CHECKBOXES
            //  doesn't mean that every item is itself a checkbox.  We
            //  need to sniff at the item, too, to see if it has a state
            //  image.
            //
            DWORD dwExStyle = SendMessageINT(m_hwnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);
            if ((dwExStyle & LVS_EX_CHECKBOXES) &&
                ListView_GetItemState(m_hwnd, varChild.lVal-1, LVIS_STATEIMAGEMASK))
            {
                pvarRole->lVal = ROLE_SYSTEM_CHECKBUTTON;
            }
            else
            {
                pvarRole->lVal = ROLE_SYSTEM_LISTITEM;
            }
        }
    }
    else
        pvarRole->lVal = ROLE_SYSTEM_LIST;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListView32::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accState(VARIANT varChild, VARIANT* pvarState)
{
long    lState;
DWORD   dwStyle;
DWORD   dwExStyle;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accState(varChild, pvarState));

    lState = SendMessageINT(m_hwnd, LVM_GETITEMSTATE, varChild.lVal-1, 0xFFFFFFFF);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (MyGetFocus() == m_hwnd)
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        if (lState & LVIS_FOCUSED)
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;
    }

    pvarState->lVal |= STATE_SYSTEM_SELECTABLE;

    dwStyle = GetWindowLong (m_hwnd,GWL_STYLE);
    if (!(dwStyle & LVS_SINGLESEL))
        pvarState->lVal |= STATE_SYSTEM_MULTISELECTABLE;

    if (lState & LVIS_SELECTED)
        pvarState->lVal |= STATE_SYSTEM_SELECTED;

    if (lState & LVIS_DROPHILITED)
        pvarState->lVal |= STATE_SYSTEM_HOTTRACKED;

    // If this is a checkbox listview, then look at the checkbox state.
    // State 0 = no checkbox, State 1 = unchecked, State 2 = checked
    dwExStyle = SendMessageINT(m_hwnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);
    if ((dwExStyle & LVS_EX_CHECKBOXES) &&
        (lState & LVIS_STATEIMAGEMASK) == INDEXTOSTATEIMAGEMASK(2))
        pvarState->lVal |= STATE_SYSTEM_CHECKED;

    if( IsClippedByWindow( this, varChild, m_hwnd ) )
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
    }

    int aKeys[ LV_IMGIDX_COUNT ];
    if( LVGetImageIndex( m_hwnd, varChild.lVal - 1, aKeys ) )
    {
        DWORD dwState;
        if( CheckDWORDMap( m_hwnd, OBJID_CLIENT, CHILDID_SELF,
                           PROPINDEX_STATEMAP,
                           aKeys, ARRAYSIZE( aKeys ),
                           & dwState ) )
        {
            pvarState->lVal |= dwState;
        }
        else if( GetStateFromStateImageMap( m_hwnd, aKeys[ LV_IMGIDX_Image ], & dwState ) )
        {
            pvarState->lVal |= dwState;
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListView32::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accFocus(VARIANT* pvarFocus)
{
    long    lFocus;
    HRESULT hr;

    //
    // Do we have the focus?
    //
    hr = CClient::get_accFocus(pvarFocus);
    if (!SUCCEEDED(hr) || (pvarFocus->vt != VT_I4) || (pvarFocus->lVal != 0))
        return(hr);

    //
    // We do.  What item is focused?
    //
    lFocus = SendMessageINT(m_hwnd, LVM_GETNEXTITEM, 0xFFFFFFFF, LVNI_FOCUSED);

    if (lFocus != -1)
        pvarFocus->lVal = lFocus+1;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CListView32::get_accDefaultAction()
//
//  Since the default action for a listview item is really determined by the
//  creator of the listview control, the best we can do is double click on
//  the thing, and return "double click" as the default action string.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction)
{
    InitPv(pszDefAction);

    //
    // Validate.
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    DWORD dwExStyle = ListView_GetExtendedListViewStyle( m_hwnd );
    if (varChild.lVal)
    {
        if ( dwExStyle & LVS_EX_ONECLICKACTIVATE )
            return HrCreateString(STR_CLICK, pszDefAction);
        else
            return HrCreateString(STR_DOUBLE_CLICK, pszDefAction);
    }
    return(E_NOT_APPLICABLE);
}

// --------------------------------------------------------------------------
//
//  CListView32::accDoDefaultAction()
//
//  As noted above, we really don't know what the default action for a list
//  view item is, so unless the parent overrides us, we'll just do a double
//  click on the thing.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::accDoDefaultAction(VARIANT varChild)
{
	LPRECT		lprcLoc;
    RECT        rcLocal;
    HANDLE      hProcess;
	
    //
    // Validate
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
    {
        // Can't just use accLocation, since that gives back the rectangle
        // for the whole line in details view, but you can only click on 
        // a certain part - icon and text. So we'll just ask the control
        // for that rectangle.
        lprcLoc = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
        if (!lprcLoc)
            return(E_OUTOFMEMORY);

        //lprcLoc->left = LVIR_ICON;
        rcLocal.left = LVIR_ICON;
        SharedWrite (&rcLocal,lprcLoc,sizeof(RECT),hProcess);

        if (SendMessage(m_hwnd, LVM_GETITEMRECT, varChild.lVal-1, (LPARAM)lprcLoc))
        {
            SharedRead (lprcLoc,&rcLocal,sizeof(RECT),hProcess);
            MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcLocal, 2);
            // convert to width and height
            rcLocal.right = rcLocal.right - rcLocal.left;
            rcLocal.bottom = rcLocal.bottom - rcLocal.top;

            BOOL fDoubleClick = TRUE;
            DWORD dwExStyle = ListView_GetExtendedListViewStyle( m_hwnd );
            if ( dwExStyle & LVS_EX_ONECLICKACTIVATE )
                fDoubleClick = FALSE;
            
            // this will check if WindowFromPoint at the click point is the same
	        // as m_hwnd, and if not, it won't click. Cool!
	        if ( ClickOnTheRect( &rcLocal, m_hwnd, fDoubleClick ) )
            {
                SharedFree(lprcLoc,hProcess);
		        return (S_OK);
            }
        }
        SharedFree(lprcLoc,hProcess);
    }
    return(E_NOT_APPLICABLE);
}


// --------------------------------------------------------------------------
//
//  CListView32::get_accSelection()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::get_accSelection(VARIANT* pvarSelection)
{
    return(GetListViewSelection(m_hwnd, pvarSelection));
}



// --------------------------------------------------------------------------
//
//  CListView32::accSelect()
//
// Selection Flags can be OR'ed together, with certain limitations. So we 
// need to check each flag and do appropriate action.
//
//  Selection flags:
//  SELFLAG_TAKEFOCUS               
//  SELFLAG_TAKESELECTION           
//  SELFLAG_EXTENDSELECTION         
//  SELFLAG_ADDSELECTION            
//  SELFLAG_REMOVESELECTION         
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::accSelect(long selFlags, VARIANT varChild)
{
long     lState;
long     lStateMask;
long     lFocusedItem;

    if (!ValidateChild(&varChild) || !ValidateSelFlags(selFlags))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accSelect(selFlags, varChild));


    if (selFlags & SELFLAG_TAKEFOCUS) 
    {
        MySetFocus(m_hwnd);
    }

    // get the thing with focus (anchor point)
    // if no focus, use first one
    // have to get it here because we might clear it b4 we need it.
    lFocusedItem = ListView_GetNextItem(m_hwnd, -1,LVNI_FOCUSED);
    if (lFocusedItem == -1)
        lFocusedItem = 0;
        
    varChild.lVal--;

    // First check if there can be more than one item selected.
	if ((selFlags & SELFLAG_ADDSELECTION) || 
        (selFlags & SELFLAG_REMOVESELECTION) ||
        (selFlags & SELFLAG_EXTENDSELECTION))
	{
		// LVM_GETITEMSTATE doesn't compare 0xFFFFFFFF so don't worry about sign extension
		if (SendMessage(m_hwnd, LVM_GETITEMSTATE, varChild.lVal, 0xFFFFFFFF) & LVS_SINGLESEL)
			return (E_NOT_APPLICABLE);
	}

    // If the take focus flag is set, check if it can get focus &
    // remove focus from other items
	if (selFlags & SELFLAG_TAKEFOCUS)
	{
        if (MyGetFocus() != m_hwnd)
        {
            return(S_FALSE);
        }
        RemoveCurrentSelFocus(SELFLAG_TAKEFOCUS);
	}

    // If the take selection flag is set, remove selection from other items
    if (selFlags & SELFLAG_TAKESELECTION)
        RemoveCurrentSelFocus(SELFLAG_TAKESELECTION);

	lState = 0;
    lStateMask = 0;

	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.mask = LVM_SETITEMSTATE;

    // now is where the real work starts. If they are just taking
    // selection, adding a selection, or removing a selection, it is
    // pretty easy. But if they are extending the selection, we'll have
    // to loop through from where the focus is to this one and select or
    // deselect each one.
    if ((selFlags & SELFLAG_EXTENDSELECTION) == 0) // not extending (easy)
    {
        if (selFlags & SELFLAG_ADDSELECTION ||
            selFlags & SELFLAG_TAKESELECTION)
        {
            lState |= LVIS_SELECTED;
            lStateMask |= LVIS_SELECTED;
        }

        if (selFlags & SELFLAG_REMOVESELECTION)
            lStateMask |= LVIS_SELECTED;

        if (selFlags & SELFLAG_TAKEFOCUS)
        {
	        lState |= LVIS_FOCUSED;
            lStateMask |= LVIS_FOCUSED;
        }

		lvi.state = lState;
		lvi.stateMask  = lStateMask;

		// TODO (micw) Dumpty doesn't test this function
		XSend_ListView_SetItem(m_hwnd, LVM_SETITEMSTATE, varChild.lVal, &lvi);
    }
    else // we are extending the selection (hard work)
    {
    long        i;
    long        nIncrement;

        // we are always selecting or deselecting, so statemask
        // always has LVIS_SELECTED.
        lStateMask = LVIS_SELECTED;

        // if neither ADDSELECTION or REMOVESELECTION is set, then we are
        // supposed to do something based on the selection state of whatever
        // has the focus.
        if (selFlags & SELFLAG_ADDSELECTION)
            lState |= LVIS_SELECTED;
        
        if (((selFlags & SELFLAG_REMOVESELECTION) == 0) &&
            ((selFlags & SELFLAG_ADDSELECTION) == 0))
        {
            // if focused item is selected, lState to have selected also
    		if (SendMessage(m_hwnd, LVM_GETITEMSTATE, lFocusedItem, 0xFFFFFFFF) 
                & LVIS_SELECTED)
                lState |= LVIS_SELECTED;
        }

		lvi.state = lState;
		lvi.stateMask  = lStateMask;

        // Now walk through from focused to current, setting the state.
        // Set increment and last one depending on direction
        if (lFocusedItem > varChild.lVal)
        {
            nIncrement = -1;
            varChild.lVal--;
        }
        else
        {
            nIncrement = 1;
            varChild.lVal++;
        }

        for (i=lFocusedItem; i!=varChild.lVal; i+=nIncrement)
			XSend_ListView_SetItem(m_hwnd, LVM_SETITEMSTATE, i, &lvi);

        // focus the last one if needed
        if (selFlags & SELFLAG_TAKEFOCUS)
        {
            lStateMask |= LVIS_FOCUSED;
            lState |= LVIS_FOCUSED;

			lvi.state = lState;
			lvi.stateMask  = lStateMask;
			XSend_ListView_SetItem(m_hwnd, LVM_SETITEMSTATE, i-nIncrement, &lvi);
        }
    }
    
	return (S_OK);
}

// --------------------------------------------------------------------------
//
//  CListView32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    LPRECT  lprc;
    RECT    rcLocal;
    HANDLE  hProcess;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    // Get the listview item rect.
    lprc = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
    if (!lprc)
        return(E_OUTOFMEMORY);

    rcLocal.left = LVIR_BOUNDS;
    SharedWrite (&rcLocal,lprc,sizeof(RECT),hProcess);

    if (SendMessage(m_hwnd, LVM_GETITEMRECT, varChild.lVal-1, (LPARAM)lprc))
    {
        SharedRead (lprc,&rcLocal,sizeof(RECT),hProcess);
        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcLocal, 2);

        *pxLeft = rcLocal.left;
        *pyTop = rcLocal.top;
        *pcxWidth = rcLocal.right - rcLocal.left;
        *pcyHeight = rcLocal.bottom - rcLocal.top;
    }

    SharedFree(lprc,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListView32::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
    long    lEnd = 0;
    int     lvFlags;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        varStart.lVal = m_cChildren + 1;
        dwNavDir = NAVDIR_PREVIOUS;
    }
    else if (!varStart.lVal)
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

    DWORD dwStyle = GetWindowLong(m_hwnd, GWL_STYLE); 


    //
    // Gotta love those listview dudes!  They have all the messages we need
    // to do hittesting, location, and navigation easily.  And those are
    // by far the hardest things to manually implement.  
    //
    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
            lEnd = varStart.lVal + 1;
            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
            lEnd = varStart.lVal - 1;
            break;

        case NAVDIR_LEFT:
            
            if( ( dwStyle & LVS_TYPEMASK ) == LVS_REPORT 
                || ListView_GetView( m_hwnd ) == LV_VIEW_DETAILS )
            {
                break;  // in report view there is nothing to the left
            }

            lvFlags = LVNI_TOLEFT;
            goto Navigate;

        case NAVDIR_RIGHT:

            if( ( dwStyle & LVS_TYPEMASK ) == LVS_REPORT 
                || ListView_GetView( m_hwnd ) == LV_VIEW_DETAILS )
            {
                break;  // in report view there is nothing to the right
            }

            lvFlags = LVNI_TORIGHT;
            goto Navigate;

        case NAVDIR_UP:
            lvFlags = LVNI_ABOVE;
            goto Navigate;

        case NAVDIR_DOWN:
            lvFlags = LVNI_BELOW;
Navigate:
            // Note that if nothing is there, COMCTL32 will return -1, and -1+1 is
            // zero, meaning nothing in our land also.
            lEnd = SendMessageINT(m_hwnd, LVM_GETNEXTITEM, varStart.lVal-1, lvFlags);
            ++lEnd;
            break;
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
        
        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CListView32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListView32::accHitTest(long x, long y, VARIANT* pvarHit)
{
    HRESULT     hr;
    HANDLE      hProcess;
    int         nSomeInt;
    POINT       ptLocal;
    LPLVHITTESTINFO lpht;

    SetupChildren();
    
    //
    // Is the point in the listview at all?
    //
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0))
        return(hr);

    //
    // Now find out what item this point is on.
    //
    lpht = (LPLVHITTESTINFO)SharedAlloc(sizeof(LVHITTESTINFO),m_hwnd,&hProcess);
    if (!lpht)
        return(E_OUTOFMEMORY);

    //lpht->iItem = -1;
    nSomeInt = -1;
    SharedWrite (&nSomeInt,&lpht->iItem,sizeof(int),hProcess);
    ptLocal.x = x;
    ptLocal.y = y;
    ScreenToClient(m_hwnd, &ptLocal);
    SharedWrite (&ptLocal,&lpht->pt,sizeof(POINT),hProcess);

    //
    // LVM_SUBHITTEST will return -1 if the point isn't over an item.  And -1
    // + 1 is zero, which is self.  So that works great for us.
    //
    SendMessage(m_hwnd, LVM_SUBITEMHITTEST, 0, (LPARAM)lpht);
    SharedRead (&lpht->iItem,&pvarHit->lVal,sizeof(int),hProcess);
    pvarHit->lVal++;

    SharedFree(lpht,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  RemoveCurrentSelFocus()
//
//  This removes all selected/focused items.
//
// -------------------------------------------------------------------------
void CListView32::RemoveCurrentSelFocus(long lState)
{
	// Set up LVITEM struct

	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.stateMask = lState;
	lvi.state = 0;

    //
    // Loop through all focused/selected items.
    //
    long lNext = ListView_GetNextItem(m_hwnd, -1,
        ((lState == LVIS_FOCUSED) ? LVNI_FOCUSED : LVNI_SELECTED));
    while (lNext != -1)
    {
		// TODO (micw) Dumpty doesn't call this function
		if (FAILED(XSend_ListView_SetItem(m_hwnd, LVM_SETITEMSTATE, lNext, &lvi)))
			return;

        lNext = ListView_GetNextItem(m_hwnd, lNext,
            ((lState == LVIS_FOCUSED) ? LVNI_FOCUSED : LVNI_SELECTED));
    }
}


/////////////////////////////////////////////////////////////////////////////
//
//  MULTIPLE SELECTION LISTVIEW SUPPORT
//
//  If a listview has more than one item selected, we create an object that
//  is a clone.  It supports merely IUnknown and IEnumVARIANT, and is a 
//  collection.  The caller should take the returned item IDs and pass them
//  in a VARIANT (VT_I4, ID as lVal) to the parent object.
//
/////////////////////////////////////////////////////////////////////////////


// --------------------------------------------------------------------------
//
//  GetListViewSelection()
//
// --------------------------------------------------------------------------
HRESULT GetListViewSelection(HWND hwnd, VARIANT* pvarSelection)
{
    int     cSelected;
    LPINT   lpSelected;
    long    lRet;
    int     iSelected;
    CListViewSelection * plvs;

    InitPvar(pvarSelection);

    cSelected = SendMessageINT(hwnd, LVM_GETSELECTEDCOUNT, 0, 0L);

    //
    // No selection.
    //
    if (!cSelected)
        return(S_FALSE);

    //
    // Single item.
    //
    if (cSelected == 1)
    {
        pvarSelection->vt = VT_I4;
        pvarSelection->lVal = ListView_GetNextItem(hwnd, -1, LVNI_SELECTED) + 1;
        return(S_OK);
    }

    //
    // Multiple items, must make a collection object.
    //

    // Allocate the list.
    lpSelected = (LPINT)LocalAlloc(LPTR, cSelected*sizeof(INT));
    if (!lpSelected)
        return(E_OUTOFMEMORY);

    plvs = NULL;

    // Get the list of selected items.
    lRet = -1;
    for (iSelected = 0; iSelected < cSelected; iSelected++)
    {
        lRet = ListView_GetNextItem(hwnd, lRet, LVNI_SELECTED);
        if (lRet == -1)
            break;

        lpSelected[iSelected] = lRet;
    }

    //
    // Did something go wrong in the middle?
    //
    cSelected = iSelected;
    if (cSelected)
    {
        plvs = new CListViewSelection(0, cSelected, lpSelected);
        if (plvs)
        {
            pvarSelection->vt = VT_UNKNOWN;
            plvs->QueryInterface(IID_IUnknown, (void**)&(pvarSelection->punkVal));
        }
    }

    //
    // Free the list memory no matter what, the constructor will make a copy.
    //
    if (lpSelected)
        LocalFree((HANDLE)lpSelected);

    if (!plvs)
        return(E_OUTOFMEMORY);
    else
        return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::CListViewSelection()
//
// --------------------------------------------------------------------------
CListViewSelection::CListViewSelection(int iChildCur, int cTotal, LPINT lpItems)
{
    m_idChildCur = iChildCur;

    m_lpSelected = (LPINT)LocalAlloc(LPTR, cTotal*sizeof(int));
    if (!m_lpSelected)
        m_cSelected = 0;
    else
    {
        m_cSelected = cTotal;
        CopyMemory(m_lpSelected, lpItems, cTotal*sizeof(int));
    }
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::~CListViewSelection()
//
// --------------------------------------------------------------------------
CListViewSelection::~CListViewSelection()
{
    //
    // Free selection list
    //
    if (m_lpSelected)
    {
        LocalFree((HANDLE)m_lpSelected);
        m_cSelected = 0;
        m_lpSelected = NULL;
    }
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::QueryInterface()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListViewSelection::QueryInterface(REFIID riid, void** ppunk)
{
    InitPv(ppunk);

    if ((riid == IID_IUnknown)  ||
        (riid == IID_IEnumVARIANT))
    {
        *ppunk = this;
    }
    else
        return(E_NOINTERFACE);

    ((LPUNKNOWN) *ppunk)->AddRef();
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::AddRef()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListViewSelection::AddRef(void)
{
    return(++m_cRef);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::Release()
//
// --------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CListViewSelection::Release(void)
{
    if ((--m_cRef) == 0)
    {
        delete this;
        return 0;
    }

    return(m_cRef);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::Next()
//
//  This returns a VT_I4 which is the child ID for the parent ListView that
//  returned this object for the selection collection.  The caller turns
//  around and passes this variant to the ListView object to get acc info
//  about it.
//
// --------------------------------------------------------------------------
STDMETHODIMP CListViewSelection::Next(ULONG celt, VARIANT* rgvar, ULONG *pceltFetched)
{
    VARIANT* pvar;
    long    cFetched;
    long    iCur;

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    //
    // Initialize VARIANTs
    // This is so bogus
    //
    pvar = rgvar;
    for (iCur = 0; iCur < (long)celt; iCur++, pvar++)
        VariantInit(pvar);

    pvar = rgvar;
    cFetched = 0;
    iCur = m_idChildCur;

    //
    // Loop through our items
    //
    while ((cFetched < (long)celt) && (iCur < m_cSelected))
    {
        pvar->vt = VT_I4;
        pvar->lVal = m_lpSelected[iCur] + 1;

        ++cFetched;
        ++iCur;
        ++pvar;
    }

    //
    // Advance the current position
    //
    m_idChildCur = iCur;

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched = cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::Skip()
//
// -------------------------------------------------------------------------
STDMETHODIMP CListViewSelection::Skip(ULONG celt)
{
    m_idChildCur += celt;
    if (m_idChildCur > m_cSelected)
        m_idChildCur = m_cSelected;

    //
    // We return S_FALSE if at the end.
    //
    return((m_idChildCur >= m_cSelected) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::Reset()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListViewSelection::Reset(void)
{
    m_idChildCur = 0;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CListViewSelection::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CListViewSelection::Clone(IEnumVARIANT **ppenum)
{
    CListViewSelection * plistselnew;

    InitPv(ppenum);

    plistselnew = new CListViewSelection(m_idChildCur, m_cSelected, m_lpSelected);
    if (!plistselnew)
        return(E_OUTOFMEMORY);

    return(plistselnew->QueryInterface(IID_IEnumVARIANT, (void**)ppenum));
}



BOOL LVGetImageIndex( HWND hwnd, int id, int aKeys[ LV_IMGIDX_COUNT ] )
{
	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.mask = LVIF_IMAGE | LVIF_STATE;
	lvi.iItem = id;

	// TODO (micw) Dumpty doesn't call this function
	if (SUCCEEDED(XSend_ListView_GetItem(hwnd, LVM_GETITEM, 0, &lvi)))
    {
        aKeys[ LV_IMGIDX_Image ]   = lvi.iImage;
        aKeys[ LV_IMGIDX_Overlay ] = ( lvi.state >> 8 ) & 0xF;
        aKeys[ LV_IMGIDX_State ]   = ( lvi.state >> 12 ) & 0xF;

		return TRUE;
    }
    else
    {
        return FALSE;
    }
}




















#define COLONSEP TEXT(": ")

HRESULT LVBuildDescriptionString( HWND hwnd, int iItem, int * pCols, int cCols, BSTR * pszDesc )
{
    // Declare ListView Structure plus a string to hold description.
	TCHAR tchText[81];

	LVITEM lvi;
	memset(&lvi, 0, sizeof(LVITEM));
	lvi.mask = LVIF_TEXT;
	lvi.pszText = tchText;
	lvi.cchTextMax = ARRAYSIZE( tchText ) - 1; // -1 for NUL
	lvi.iItem = iItem;

    TCHAR tchColText[81];
    LVCOLUMN lvc;
    lvc.mask = LVCF_TEXT;
    lvc.pszText = tchColText;
    lvc.cchTextMax = ARRAYSIZE( tchColText ) - 1; // -1 for NUL

    // Space for the locale-specific separator. (Usually ", " for English)
    TCHAR szSep[ 16 ];

    // Now allocate a local string to hold everything. Its length will be:
    // number of cols * ( coltext + ": " + text + separator )
    //
    // sizeof(COLONSEP) incluses the terminating NUL in that string; but it's ok
    // to overestimate. Because we use sizeof, we don't need to multiply by sizeof(TCHAR).
    int len = cCols * ( sizeof( tchColText ) + sizeof( COLONSEP )
                      + sizeof( tchText ) + sizeof( szSep ) );

    LPTSTR lpszLocal = (LPTSTR)LocalAlloc ( LPTR, len );
    if (!lpszLocal)
    {
        return E_OUTOFMEMORY;
    }

    // This points to the 'current write position' as we build up the string
    LPTSTR lpszTempLocal = lpszLocal;


    // Get the list separator string. The -1 allows us to append
    // a space char if we need it.
    int nSepLen = GetLocaleInfo( GetThreadLocale(), LOCALE_SLIST, szSep, ARRAYSIZE( szSep ) - 1 );
    if( ! nSepLen || szSep[ 0 ] == '\0' )
    {
        // Default to using ", "...
        lstrcpy( szSep, TEXT(", ") );
        nSepLen = 2;
    }
    else
    {
        // GetLocalInfo return value includes terminating NUL... don't want
        // to include that in our length.
        nSepLen = lstrlen( szSep );

        // Add extra space at end, if necessary.
        if( szSep[ nSepLen - 1 ] != ' ' )
        {
            lstrcat( szSep, TEXT(" ") );
            nSepLen++;
        }
    }

    //
    // Traverse the description order array sequentially to get each item
    //

    // Flag used to remember not to add separator when adding first item
    BOOL fFirstItem = TRUE;
    for ( int iOrder = 0; iOrder < cCols; iOrder++ )
    {
        INT iCol = pCols[iOrder];

        // Skip subitem 0, that is the 'name'.
        // Also skip negative numbers, just in case.
        if ( iCol <= 0 )
            continue;

        // Try and get the column value text...
		lvi.iSubItem = iCol;
		*lvi.pszText = '\0';
		if( FAILED(XSend_ListView_GetItem( hwnd, LVM_GETITEM, 0, &lvi ) ) )
            continue;

        // Skip empty strings...
		if( *lvi.pszText == '\0' )
            continue;


        // Add separator if necessary...
        if( ! fFirstItem )
        {
            lstrcpy(lpszTempLocal, szSep);
            lpszTempLocal += nSepLen;
        }
        else
        {
            fFirstItem = FALSE;
        }

        // Try to get column header string...
        lvc.iSubItem = iCol;
		*lvc.pszText = '\0';
		if( SUCCEEDED(XSend_ListView_GetColumn( hwnd, LVM_GETCOLUMN, iCol, &lvc ) )
            && *lvc.pszText != '\0' )
        {
			lstrcpy(lpszTempLocal, lvc.pszText);
            lpszTempLocal += lstrlen(lpszTempLocal);

			lstrcpy(lpszTempLocal, TEXT(": "));
            lpszTempLocal += 2;
        }

        // Now add the column value to string...
		lstrcpy(lpszTempLocal, lvi.pszText);
        lpszTempLocal += lstrlen(lpszTempLocal);
    }

    // Convert to BSTR...
    if (lpszTempLocal != lpszLocal)
    {
        *pszDesc = TCharSysAllocString(lpszLocal);
    }

    LocalFree (lpszLocal);

    return *pszDesc ? S_OK : S_FALSE;
}



HRESULT LVGetDescription_ReportView( HWND hwnd, int iItem, BSTR * pszDesc )
{
    //
    // Is there a header control?
    //
    HWND hwndHeader = ListView_GetHeader(hwnd);
    if (!hwndHeader)
        return E_NOT_APPLICABLE ;

    //
    // Is there more than one column?
    //
    int cColumns = SendMessageINT(hwndHeader, HDM_GETITEMCOUNT, 0, 0L);
    if (cColumns < 2)
        return E_NOT_APPLICABLE;

    //
    // Get the order to traverse these columns in.
    //
    HANDLE hProcess;
    LPINT lpColumnOrderShared = (LPINT)SharedAlloc( 2 * cColumns * sizeof(INT),
                                                    hwnd, & hProcess );
    if (!lpColumnOrderShared)
        return E_OUTOFMEMORY;

    // Now allocate a local array twice as big, so we can do our sorting 
    // in the second half.    
    LPINT lpColumnOrder = (LPINT)LocalAlloc (LPTR,2 * cColumns * sizeof(INT));
    if (!lpColumnOrder)
    {
        SharedFree (lpColumnOrderShared,hProcess);
        return E_OUTOFMEMORY;
    }

    LPINT lpDescOrder = lpColumnOrder + cColumns;

    if (!SendMessage(hwnd, LVM_GETCOLUMNORDERARRAY, cColumns, (LPARAM)lpColumnOrderShared))
    {
        SharedFree(lpColumnOrderShared,hProcess);
        LocalFree (lpColumnOrder);
        return(E_OUTOFMEMORY);
    }

    SharedRead (lpColumnOrderShared,lpColumnOrder,cColumns*sizeof(INT),hProcess);

    //
    // lpColumnOrder is currently an array where index == iSubItem, value == order.
    // Change this into an array where index == order, value == iSubItem.
    // That way we can sit in a loop using the value as the iSubItem,
    // knowing we are composing the pieces of the description in the proper
    // order.
    //              

    for (int iOrder = 0; iOrder < cColumns; iOrder++)
    {
        lpDescOrder[lpColumnOrder[iOrder]] = iOrder;
    }

    HRESULT hr = LVBuildDescriptionString( hwnd, iItem, lpDescOrder, cColumns, pszDesc );

    SharedFree(lpColumnOrderShared,hProcess);
    LocalFree (lpColumnOrder);

    return hr;
}


HRESULT LVGetDescription_TileView( HWND hwnd, int iItem, BSTR * pszDesc )
{
    // Get the 'sorted' column...
    int iColSorted = ListView_GetSelectedColumn( hwnd );

    // Normalize to 0 if negative. We don't use col 0, since that's the name.
    if( iColSorted < 0 )
        iColSorted = 0;

    // First, get number of cols...
    LVITEM_V6 lvi;
    lvi.iItem = iItem;
    lvi.iSubItem = 0;
    lvi.mask = LVIF_COLUMNS;
    lvi.cColumns = 0;
    lvi.puColumns = NULL;

    HRESULT hr = XSend_ListView_V6_GetItem( hwnd, LVM_GETITEM, 0, &lvi );

    if( FAILED( hr ) )
        return hr;

    int cCols = lvi.cColumns;
    if( cCols < 0 )
        cCols = 0;

    // If we get back 0 columns, we still have to display the sorted column, if there is one.
    // But if there are no cols, and no sorted col, then there's no description.
    if( cCols == 0 && iColSorted == 0 )
        return S_FALSE;


    // Allocate space for those cols - with space for the sorted column at the head.
    int * pCols = new int [ cCols + 1 ];
    if( ! pCols ) 
        return E_OUTOFMEMORY;

    pCols [ 0 ] = iColSorted;

    if( cCols )
    {
        // Now get them...
        lvi.puColumns = (UINT *)(pCols + 1);

        hr = XSend_ListView_V6_GetItem( hwnd, LVM_GETITEM, 0, &lvi );
        if( FAILED( hr ) )
        {
            delete [ ] pCols;
            return hr;
        }

        // Scan remainder of columns for the sorted column - if found, set that
        // entry to 0, so it will be skipped when building the string.
        // (Neater than moving all the entries down by one.)
        for( int iScan = 1 ; iScan < cCols + 1 ; iScan++ )
        {
            if( pCols[ iScan ] == iColSorted )
            {
                pCols[ iScan ] = 0;
            }
        }
    }

    // Finally, build the description string using those columns.
    // If we didn't get any cols above, this will end up using just the
    // sorted col - if there is one.
    hr = LVBuildDescriptionString( hwnd, iItem, pCols, cCols + 1, pszDesc );

    delete [ ] pCols;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\lresobj.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  lresobj
//
//  LresultFromObject and ObjectFromLresult.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"


#ifndef WMOBJ_SAMETHREAD
#define WMOBJ_SAMETHREAD  0xFFFFFFFF
#endif



//  This structure is used by the NT version of SharedBuffer_Allocate/Free,
//  it acts as a header, and is followed immedialtey by the marshal data.
//
//  (The 9x version of SharedBuffer_Allocate currently stores the data
//  without a header.) 
//
//  Be careful with packing and alignment here - this needs to look the same
//  on 32bit and 64-bit compiles.
// 
typedef struct {
    DWORD       m_dwSig;
    DWORD       m_dwSrcPID;
    DWORD       m_dwDstPID;
    DWORD       m_cbSize;
} XFERDATA, *PXFERDATA;

#define MSAAXFERSIG     0xAA1CF00D



static BOOL ParseHexStr( LPCTSTR pStr, DWORD * pdw );

static BOOL EncodeToAtom( DWORD dwSrcPID, HANDLE dwSrcHandle, DWORD * pdw );
static BOOL DecodeFromAtom( DWORD dw, DWORD * pdwSrcPID, HANDLE * pdwSrcHandle );



//
//  Note on SharedBuffer_Allocate and SharedBuffer_Free:
//
//  LresultFromObject and ObjectFromLresult call SharedBuffer_Allocate and
//  SharedBuffer_Free respectively to do the actual work of transferring
//  memory between processes.
//
//
//  SharedBuffer_Allocate is given a pointer to the marshalled interface data,
//  and its length (pData, cbData), and the pid of the process that wants the
//  object (dwDstPID, which may be 0 if the destination is unknown - while
//  Oleacc's AccessibleObjectFromWindow sends WM_GETOBJECT with wParam as the
//  pid, some legacy code already out there sends WM_GETOBJECT directly with
//  wParam = 0.)
//
//  SharedBuffer_Allocate then stores that marshalled data however it needs
//  to, and returns an LRESULT that can later be used to get back to that data.
//  Note that since this LRESULT may be used by a 32-bit process, it must be
//  only 32-bit significant. Also, it must look like a SUCCESS HRESULT - ie.
//  bit 31 must be 0.
//
//
//  SharedBuffer_Free is given a DWORD ref - which is the LRESULT that
//  SharedBuffer_Allocate previously returned - the destination process pid -
//  which may be 0 if ObjectFromLresult was called directly by legacy code -
//  and also an riid.
//
//  SharedBuffer_Free needs to use that DWORD ref to get at the memory that
//  SharedBuffer_Allocate set up, and then call the utility function
//  UnmarshalInterface() on that memory with the riid to return an interface
//  pointer. SharedBuffer_Free must also deallocate the associated memory as
//  appropriate.
//
//  Different versions of _Allocate and _Free exist on 9x and NT, denoted by
//  _Win95 and _NT suffixes. A generic _Allocate and _Free called the
//  appropriate one based on compile options and the global fWindows95 flag.
//

static LRESULT WINAPI SharedBuffer_Allocate_NT( const BYTE * pData, DWORD cbData, DWORD dwDstPID );
static HRESULT WINAPI SharedBuffer_Free_NT( DWORD ref, DWORD dwDstPID, REFIID riid, LPVOID * ppv );

#ifndef NTONLYBUILD
static LRESULT WINAPI SharedBuffer_Allocate_Win95( const BYTE * pData, DWORD cbData, DWORD dwDstPID );
static HRESULT WINAPI SharedBuffer_Free_Win95( DWORD ref, DWORD dwDstPID, REFIID riid, LPVOID * ppv );
#endif // NTONLYBUILD


static inline
LRESULT WINAPI SharedBuffer_Allocate( const BYTE * pData, DWORD cbData, DWORD dwDstPID )
{
#ifndef NTONLYBUILD
    if( fWindows95 ) 
    {
        return SharedBuffer_Allocate_Win95( pData, cbData, dwDstPID );
    }  
    else 
#endif // NTONLYBUILD
    {
        return SharedBuffer_Allocate_NT( pData, cbData, dwDstPID );
    }
}


static inline
HRESULT WINAPI SharedBuffer_Free( DWORD ref, DWORD dwDstPID, REFIID riid, LPVOID * ppv )
{
#ifndef NTONLYBUILD
    if( fWindows95 ) 
    {
        return SharedBuffer_Free_Win95( ref, dwDstPID, riid, ppv );
    }  
    else 
#endif // NTONLYBUILD
    {
        return SharedBuffer_Free_NT( ref, dwDstPID, riid, ppv );
    }
}



// --------------------------------------------------------------------------
//
//  LresultFromObject_Local(), ObjectFromLresult_Local()
//
//  These are the same-thread optimizations of LFromO and OFromL.
//
//  The key thing is to bit-twiddle the interface pointer so that it does
//  not look like an error HRESULT - ie. bit31 must be 0.
//  We take advantage of the fact that since these are pointers, bit 0 will
//  be 0, and we are free to use it for our own use in our encoding.
//
//  The mapping scheme is as follows:
//
//  Mapping to Lresult from Object, punk -> LRESULT
//
//    top 32 bits unchanged
//    bit 31 set to 0 (so that it looks like a success HRESULT)
//    bits 30..0 correspond to bits 31..1 of the input value.
//    bit 0 of the original value is lost; assumed to be 0.
//
//  Mapping to Object from Lresult, LRESULT -> punk
//
//    top 32 bits unchanged
//    bits 31..1 correspond to bits 30..0 of the input value.
//    bit 0 set to 0
//
//  This will work on Win64, and on Win32 with memory above 2G enabled.
//
// --------------------------------------------------------------------------

static
LRESULT LresultFromObject_Local( IUnknown * punk )
{
    // Do the work using DWORD_PTRs - thery're unsigned, so we don't get
    // unexpected nasty sign-extension effects, esp. when shifting...
    DWORD_PTR in = (DWORD_PTR) punk;

    // Mask off lower 32 bits to get the upper 32 bits (NOP on W32)...
    DWORD_PTR out = in & ~(DWORD_PTR)0xFFFFFFFF;

    // Now add in the lower 31 bits (excluding bit 0) shifted by one so
    // that bit 31 is 0...
    out |= ( in & (DWORD_PTR)0xFFFFFFFF ) >> 1;

    return (LRESULT) out;
}

static
IUnknown * ObjectFromLresult_Local( LRESULT lres )
{
    Assert( SUCCEEDED( lres ) );

    DWORD_PTR in = (DWORD_PTR) lres;

    // Mask off lower 32 bits to get the upper 32 bits (NOP on W32)...
    DWORD_PTR out = in & ~(DWORD_PTR)0xFFFFFFFF;

    // Now add in the lower 31 bits, shifted back to their original
    // position...
    out |= ( in & (DWORD_PTR)0x7FFFFFFF ) << 1;

    return (IUnknown *) out;
}





// --------------------------------------------------------------------------
//
//  LresultFromObject()
//
//  Encodes an interface pointer into an LRESULT.
//
//  If the client and server are on the same thread, an optimized version is
//  used; the pointer is effectively AddRef()'d and returned as the LRESULT.
//  (some bit-shifting takes place to prevent it looking like an error HRESULT,
//  ObjectFromLresult reverses this bit=shifting.)
//
//  If the client and server are not on the same thread, the interface is
//  marshaled, and Shared_Allocate is used to save a copy of that marshaled
//  data, returning an opaque 32-bit identifier that the client process can
//  pass to ObjectFromLresult to get back the interface.
//
// --------------------------------------------------------------------------

EXTERN_C LRESULT WINAPI LresultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN punk) 
{
    SMETHOD( TEXT("LresultFromObject"), TEXT("wParam=%d punk=%p"), wParam, punk );

    // Optimization for when client and server are the same thread; no need to
    // marshal/unmarshal, we can pass the pointer directly.
    
    // Casting to DWORD to avoid sign extention issues - WMOBJ_SAMETHREAD is a
    // 32-bit value, but wParam is 64-bit on 64.
    if( (DWORD)wParam == (DWORD)WMOBJ_SAMETHREAD )
    { 
        // We addref here to hold onto the object on behalf of the client caller.
        // This allows the server to safely release() the object after they've used
        // LresultfromObject to 'convert' it into a LRESULT
        punk->AddRef();

        return LresultFromObject_Local( punk );
    }

    // Cross-proc or cross-thread case, need to marshal the interface, save it
    // to a buffer, and return some sort of reference to that buffer...

    const BYTE * pData;
    DWORD cbData;
    MarshalState mstate;

    HRESULT hr = MarshalInterface( riid, punk, MSHCTX_LOCAL, MSHLFLAGS_NORMAL,
                                   & pData, & cbData, & mstate );
    if( FAILED( hr ) )
    {
        return hr;
    }

    DWORD dwDestPid = (DWORD) wParam;

    // Got the marhalled data, now call SharedBuffer_Allocate to wrap it into
    // some short of shared memory and return a suitable reference to that.
    LRESULT lResult = SharedBuffer_Allocate( pData, cbData, dwDestPid );

    MarshalInterfaceDone( & mstate );

    return lResult;
}




// --------------------------------------------------------------------------
//
//  ObjectFromLresult()
//
//  This function converts the 32-bit opaque value returned from LresultFromObject
//  into a marshalled interface pointer.  
//
// --------------------------------------------------------------------------

EXTERN_C HRESULT WINAPI ObjectFromLresult( LRESULT ref, REFIID riid, WPARAM wParam, void **ppvObject ) 
{
    SMETHOD( TEXT("ObjectFromLResult"), TEXT("ref=%p wParam=%d"), ref, wParam );

    // Do a basic sanity check on parameters
    if( ppvObject == NULL )
    {
        TraceParam( TEXT("ObjectFromLresult: ppvObject should be non-NULL") );
        return E_POINTER;
    }

    *ppvObject = NULL;

    if( FAILED( ref ) ) 
    { 
        TraceParam( TEXT("ObjectFromLresult: failure lResult was passed in (%08lx)"), ref );
        return E_INVALIDARG; 
    }

    // If the client and server are in the same thread, LresultFromObject is
    // optimized to return the original interface pointer since no marshalling 
    // is needed.

    // Casts used to avoid any 32/64 sign extension issues. We only use the low
    // DWORD of wParam, even on w64.
    if( (DWORD)wParam == (DWORD)WMOBJ_SAMETHREAD )
    {
        // Use the bit-mangling in-proc optimization...
        IUnknown * punk = ObjectFromLresult_Local( ref );

        if( punk == NULL )
        {
            TraceError( TEXT("ObjectFromLresult: (inproc case) lresult translates to NULL pointer") );
            return E_INVALIDARG;
        }

		// Some apps was responding to WM_GETOBJECT message with 1. This can cause
		// a problem for folks responding to events in-context, since we expect
        // it to be a pointer - so need to check that it's valid...

		if( IsBadReadPtr( punk, 1 ) )
        {
            TraceError( TEXT("ObjectFromLresult: (inproc case) lresult translates to invalid pointer (%p)"), punk );
            return E_INVALIDARG;
        }

    	HRESULT hr = punk->QueryInterface( riid, ppvObject );
        if( FAILED( hr ) )
        {
            TraceErrorHR( hr, TEXT("ObjectFromLresult: (inproc case) QI'ing translated pointer") );
        }

        punk->Release();
    	return hr;
    }

    // cross-proc case, call SharedBuffer_Free to access the buffer indicated by
    // ref, and to unmarshal the interface...

    // (The cast is for when we're on W64 - convert from (64/42-bit) LRESULT to
    // 32-bit buffer reference...)
    return SharedBuffer_Free( (DWORD) ref, (DWORD) wParam, riid, ppvObject );
}




// --------------------------------------------------------------------------
// Following static functions are local to this module
// --------------------------------------------------------------------------





// --------------------------------------------------------------------------
//
//  LRESULT WINAPI SharedBuffer_Allocate_NT( const BYTE * pData,
//                                           DWORD cbData,
//                                           DWORD dwDstPID );
//
//  IN const BYTE * pData
//    pointer to marshal data to store
//
//  IN DWORD cbData
//    length of marshaled data
//
//  IN DWORD dwDstPID
//    process id of processing requesting the data. May be 0 if not known
//
//  Returns LRESULT
//    32-bit opaque token (with bit 31 clear) that can be passed to
//    SharedBuffer_Free to get back the interface pointer.
//
//
//  See notes near top of file on how SharedBuffer_Alocate/Free works.
//
//  The NT version uses memory-mapped files - we create a file mapping,
//  copy the marshal data into it, and then return the handle.
//
//  If we know the caller'd pid, we DuplicateHandle() the handle to them,
//  and return the duplicated handle.
//
//  If we don't know their pid, we encode the handle and our pid as a string,
//  and convert that to an atom, and return the atom. (This is a 'clever'
//  way of squeezing two 32-bit pieces of information into a single 32-bit
//  LRESULT!)
//
// --------------------------------------------------------------------------

static
LRESULT WINAPI SharedBuffer_Allocate_NT( const BYTE * pData, DWORD cbData, DWORD dwDstPID ) 
{
    HRESULT hr = E_FAIL; // if things don't work out...

    // Note that we don't Close this handle explicitly here,
    // DuplicateHandle(DUPLICATE_CLOSE_SOURCE) will code it, whether it is duplicated
    // here (if we know the caller's pid), or in SharedBuffer_Free (if dwDstPID is 0).
    HANDLE hfm = CreateFileMapping( INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 
                                    0, cbData + sizeof( XFERDATA ), NULL );
    if( hfm == NULL )
    {
        TraceErrorW32( TEXT("SharedBuffer_Allocate_NT: CreateFileMapping failed") );
        return E_FAIL;
    }

    PXFERDATA pxd = (PXFERDATA) MapViewOfFile( hfm, FILE_MAP_WRITE, 0, 0, 0 );
    if( pxd == NULL ) 
    {
        TraceErrorW32( TEXT("SharedBuffer_Allocate_NT: MapViewOfFile failed") );
        return E_FAIL;
    }

    // Got a pointer to the memory. Fill in the header, and copy the marshal data...
    pxd->m_dwSig = MSAAXFERSIG;
    pxd->m_dwSrcPID = GetCurrentProcessId();  // Don't actually need this...
    pxd->m_dwDstPID = dwDstPID;
    pxd->m_cbSize = cbData;

    memcpy( pxd + 1, pData, cbData );

    UnmapViewOfFile( pxd );

    // If we know who the caller is, we can just DUP a handle to them, closing our
    // side, and and return them the DUP's handle...
    if( dwDstPID )
    {

        HANDLE hDstProc = OpenProcess( PROCESS_DUP_HANDLE, FALSE, dwDstPID );
        if( ! hDstProc )
        {
            TraceErrorW32( TEXT("SharedBuffer_Allocate_NT: OpenProcess(pid=%d) failed"), dwDstPID );
            CloseHandle( hfm );
            return E_FAIL;
        }
    
        HANDLE hTarget = NULL;
        BOOL b = DuplicateHandle( GetCurrentProcess(), hfm, hDstProc, & hTarget, 0, FALSE, DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS );
        CloseHandle( hDstProc );

        if( ! b )
        {
            TraceErrorW32( TEXT("SharedBuffer_Allocate_NT: DuplicateHandle (to pid=%d) failed"), dwDstPID );

            // No tidy up to do at this stage. The mapping has been unmapped above; and
            // DuplicateHandle with _CLOSE_SOURCE always closes the source handle, even
            // if it failes to dup it.
            return E_FAIL;
        }

        // Shift right by one to ensure hight-bit is clear (to avoid looking like an error
        // HRESULT). Client will shift-back before use in SharedBuffer_Free.
        hr = (DWORD)HandleToLong(hTarget) >> 1;
    }
    else
    {
        // wParam == 0 means we don't know the caller's PID - encode our pid and the handle
        // is an atom and send that back instead. See comments near EncodeToAtom for full
        // explanation.
        DWORD dwRet;
        if( ! EncodeToAtom( GetCurrentProcessId(), hfm, & dwRet ) )
        {
            TraceError( TEXT("SharedBuffer_Allocate_NT: EncodeToAtom failed") );
            return E_FAIL;
        }

        // Succeeded - so return the atom as the lresult. Atoms are 16-bit, so we don't
        // have to worry about colliding with error HRESULTs.
        hr = dwRet;
    }

    return hr;
}



// --------------------------------------------------------------------------
//
//  LRESULT WINAPI SharedBuffer_Free_NT( DWORD ref,
//                                       DWORD dwDstPID,
//                                       REFIID riid,
//                                       LPVOID * ppv );
//
//  IN DWORD ref
//    Cookie from SharedBuffer_Allocate
//
//  IN DWORD dwDstPID
//    process id of processing requesting the data. May be 0 if not known
//
//  IN REFIID riid
//    desired interface to be returned
//
//  OUT LPVOID * ppv
//    returned interface pointer
//
//  Returns HRESULT
//    S_OK on success.
//
//
//  See notes near top of file on how SharedBuffer_Alocate/Free works.
//
//  Basic alg: the ref is either a handle to shared memory, or an atom referencing
//  a handle in another process to shared memory, and that pid. In the latter case,
//  we need to DuplicateHandle that handle to one that we can use.
//
//  Once we've got the handle, map it, check the header of the buffer, and then
//  unmarshal the data to get the interface pointer.
//
// --------------------------------------------------------------------------

static
HRESULT WINAPI SharedBuffer_Free_NT( DWORD ref, DWORD dwDstPID, REFIID riid, LPVOID * ppv ) 
{
    // sanity check on ref parameter...
    if( FAILED( ref ) ) 
    { 
        TraceError( TEXT("SharedBuffer_Free_NT: ref is failure HRESULT") );
        return E_INVALIDARG; 
    }

    HRESULT hr;
    HANDLE hfm;

    // Extract the handle from ref - two different ways this can happen...

    if( dwDstPID != 0 )
    {
        // Normal case - where we've sent the server our pid and it send us back
        // a handle it has dup'd for us.
        // Server shifted the handle right by one to avoid clashing with error HRESULTS -
        // shift it back before we use it...

        hfm = LongToHandle( ref << 1 );
    }
    else
    {
        // dwDstPid - which is the wParam passed to ObjectFromLresut - is 0, so we don't
        // know the source process's pid. Treat the lresult 'ref' as an atom, and decode
        // that to get the source pid and handle...

        // Extract the source process's PID and its handle from the atom name...
        DWORD dwSrcPID;
        HANDLE hRemoteHandle;

        if( ! DecodeFromAtom( ref, & dwSrcPID, & hRemoteHandle ) )
        {
            return E_FAIL;
        }

        // Now use DuplicateHandle plus the src's pid to convert its src-relative handle
        // to one we can use...

        HANDLE hSrcProc = OpenProcess( PROCESS_DUP_HANDLE, FALSE, dwSrcPID );
        if( ! hSrcProc )
        {
            TraceErrorW32( TEXT("SharedBuffer_Free_NT: OpenProcess(pid=%d) failed"), dwSrcPID );
            return E_FAIL;
        }

        BOOL fDupHandle = DuplicateHandle( hSrcProc, hRemoteHandle,
                                           GetCurrentProcess(), & hfm,
                                           0, FALSE, DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS );
        CloseHandle( hSrcProc );

        if( ! fDupHandle || ! hfm )
        {
            TraceErrorW32( TEXT("SharedBuffer_Free_NT: DuplicateHandle(from pid=%d) failed"), dwSrcPID );
            return E_FAIL;
        }

        // Got it! Now carry on as normal, with hfm == our handle.
    }



    // At this stage, we have the handle. Now map it, so we can extract the data...

    PXFERDATA pxd = (PXFERDATA) MapViewOfFile( hfm, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( pxd == NULL ) 
    {
        TraceErrorW32( TEXT("SharedBuffer_Free_NT: MapViewOfFile failed") );

        // We should only close the handle if it turns out to point to valid
        // shared memory. Otherwise a rogue client could return a handle value
        // that refers to an existing handle in this process - and we'd close
        // that instead.
        UnmapViewOfFile( pxd );
        return E_FAIL;
    }

    // Sanity-check the data:
    // Verify that dest is what we expect them to be.
    // Only check the dstpid if it's non-0...
    if( pxd->m_dwSig != MSAAXFERSIG ||
        ( dwDstPID != 0 && pxd->m_dwDstPID != GetCurrentProcessId() ) )
    {
        TraceError( TEXT("SharedBuffer_Free_NT: Signature of shared mem block is invalid") );

        // don't close handle - see note above...
        UnmapViewOfFile( pxd );
        return E_FAIL;
    }

    BYTE * pData = (BYTE *) ( pxd + 1 );
    DWORD cbData = pxd->m_cbSize;

    // We have the size of the data and the address of the data, unmarshal it
    // make a stream out of it.

    hr = UnmarshalInterface( pData, cbData, riid, ppv );

    UnmapViewOfFile( pxd );
    CloseHandle( hfm );

    return hr;
}


#ifndef NTONLYBUILD




// --------------------------------------------------------------------------
//
//  LRESULT WINAPI SharedBuffer_Allocate_Win95( const BYTE * pData,
//                                              DWORD cbData,
//                                              DWORD dwDstPID );
//
//  IN const BYTE * pData
//    pointer to marshal data to store
//
//  IN DWORD cbData
//    length of marshaled data
//
//  IN DWORD dwDstPID
//    process id of processing requesting the data. May be 0 if not known
//
//  Returns LRESULT
//    32-bit opaque token (with bit 31 clear) that can be passed to
//    SharedBuffer_Free to get back the interface pointer.
//
//
//  See notes near top of file on how SharedBuffer_Alocate/Free works.
//
//  The 9x version uses SharedAlloc, and returns a bit-mangled pointer to
//  the shared buffer.
//
// --------------------------------------------------------------------------

static
LRESULT WINAPI SharedBuffer_Allocate_Win95( const BYTE * pData, DWORD cbData, DWORD unused( dwDstPID ) ) 
{
    // Since we know we are on Win95, we can specify NULL for
    // the hwnd and hProcess parameters here.
    PVOID pv = SharedAlloc( cbData, NULL, NULL );
    if( pv == NULL )
    {
        TraceErrorW32( TEXT("SharedBuffer_Allocate_Win95: SharedAlloc failed") );
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    memcpy( pv, pData, cbData );

    // Force the high-bit off to indicate a successful return value
    return (LRESULT) ((DWORD) pv) & ~HEAP_GLOBAL; 
}


// --------------------------------------------------------------------------
//
//  LRESULT WINAPI SharedBuffer_Free_NT( DWORD ref,
//                                       DWORD dwDstPID,
//                                       REFIID riid,
//                                       LPVOID * ppv );
//
//  IN DWORD ref
//    Cookie from SharedBuffer_Allocate
//
//  IN DWORD dwDstPID
//    process id of processing requesting the data. May be 0 if not known
//
//  IN REFIID riid
//    desired interface to be returned
//
//  OUT LPVOID * ppv
//    returned interface pointer
//
//  Returns HRESULT
//    S_OK on success.
//
//
//  See notes near top of file on how SharedBuffer_Alocate/Free works.
//
//  The 9x version un-mangles the pointer to the shared buffer, unmarshalls the marshal
//  data, then frees the shared buffer.
//
// --------------------------------------------------------------------------

static
HRESULT WINAPI SharedBuffer_Free_Win95(DWORD ref, DWORD unused( dwDstPID ), REFIID riid, LPVOID * ppv )
{
    // Get address of shared memory block
    BYTE * pData = (BYTE *) (ref | HEAP_GLOBAL);  // Turn the high-bit back on

    // Get the size of the block in the shared heap.
    DWORD cbData = HeapSize( hheapShared, 0, pData );

    HRESULT hr = UnmarshalInterface( pData, cbData, riid, ppv );

    // we know we are on Win95, can use NULL hProcess...
    SharedFree( pData, NULL);

    return hr;
}

#endif // NTONLYBUILD




// --------------------------------------------------------------------------
//
//  BOOL ParseHexStr( LPCTSTR pStr, DWORD * pdw )
//
//
//  IN LPCTSTR pStr
//    pointer to string to parse
//
//  OUT DWORD * pdw
//    returns the hex value of the string.
//
//  Returns BOOL
//    TRUE on success.
//
//
//  Decodes a string of 8 hex digits. This uses EXACTLY 8 hex didits, and
//  fails (returns FALSE) if any invalid (non 0..9A..F) char is encountered.
//
//  Used by DecodeFromAtom().
//
// --------------------------------------------------------------------------

static
BOOL ParseHexStr( LPCTSTR pStr, DWORD * pdw )
{
    DWORD dw = 0;
    for( int c = 0 ; c < 8 ; c++, pStr++ )
    {
        dw <<= 4;
        if( *pStr >= '0' && *pStr <= '9' )
        {
            dw += *pStr - '0';
        }
        else if( *pStr >= 'A' && *pStr <= 'F' )
        {
            dw += *pStr - 'A' + 10;
        }
        else if( *pStr >= 'a' && *pStr <= 'f' )
        {
            dw += *pStr - 'a' + 10;
        }
        else
        {
            // invalid hex digit
            return FALSE;
        }
    }

    *pdw = dw;

    return TRUE;
}



//  What this 'atom encoding' is all about...
//
//  If the WM_GETOBJECT is being sent from OLEACC (AccessibleObjectFromWindow),
//  OLEACC will send the pid of the client process in the wParam. The server can
//  use this with DuplicateHandle to create a handle that the destination/client
//  process can use, which the server then returns.
//
//  However, some clients send WM_GETOBJECT directly with wParam == 0; or,
//  in the case of Trident, a provate registered message "WM_HTML_GETOBJECT"
//  is used, with wParam == 0.
//  In this case, the server doesn't know who the client is, so can't Dup a
//  handle to it (in LresultFromObject). Also, the client code, (in
//  ObjectFromLresult) doesn't know who the server is - all it has is the
//  returned DWORD (and a wParam of 0!) - so even if it had a server-relative
//  handle, it couldn't DuplicateHandle it to one that it could use, since that
//  requires knowing the server's pid.
//
//  The solution/workaround here is to special-case the case where wParam is 0.
//  If wParam is non-0 (and is not the SAMETHREAD special value), we use it as the
//  pid and the server dups the handle to one that the cient can use and returns it.
//
//  If the wParam is 0, the server instead builds a string containing the server's
//  pid and the handle, in the following format:
//
//    "MSAA:00000000:00000000:"
//
//  The first 8-digit hex number is the server's pid; the second 8-digit hex number
//  is the server's handle to the memory. (Handles are only 32-bit significant, even
//  on Win64.)
//
//  The server then adds this to the global atom table, using GlobalAddAtom, which
//  returns an ATOM. (Atoms are typedef'd a SHORTs, and will comfortably fit inside
//  the returned DWORD, leaving the high bit 0, avoinding confusion with error
//  HRESULTS.)
//
//  The server returns the atom back to the client.
//  The client code in ObjectFromLresult notices that wParam is 0, so treats the
//  lresult as an Atom, uses globalGetAtomName() to retreive the above string,
//  checks that is has the expected format, and decodes the two hex numbers.
//
//  The client now has the server's PID and the server-relative handle to the 
//  memory containing the marshalled interface pointer. The client can then use
//  these with DuplicateHandle to generate a handle that it can use.
//
//  Now that the client has a handle to the marshalled interface memory, it can
//  continue on as usual to unmarshal the interface which it returns to the caller.
//



// Expected format: "MSAA:00000000:00000000:"

// Defines for offsets into this string. Lengths do not include terminating NULs.
#define ATOM_STRING_LEN         (4 + 1 + 8 + 1 + 8 + 1)

#define ATOM_STRING_PREFIX      TEXT("MSAA:")
#define ATOM_STRING_PREFIX_LEN  5
#define ATOM_PID_OFFSET         5
#define ATOM_COLON2_OFFSET      13
#define ATOM_HANDLE_OFFSET      14
#define ATOM_COLON3_OFFSET      22
#define ATOM_NUL_OFFSET         23



// --------------------------------------------------------------------------
//
//  BOOL EncodeToAtom( DWORD dwSrcPID, HANDLE dwSrcHandle, DWORD * pdw )
//
//
//  IN DWORD dwSrcPID
//    process id to encode
//
//  IN HANDLE dwSrcHandle
//    handle in source process to encode
//
//  OUT DWORD * pdw
//    returns the resulting atom value
//
//  Returns BOOL
//    TRUE on success.
//
//
//  Encodes the dwSrcPID and dwSrcHandle into a string of the form:
//
//      "MSAA:00000000:00000000:"
//  
//  where the first part is the pid and the second part is the handle, and
//  then gets an atom for this string, and returns the atom.
//
// --------------------------------------------------------------------------

static
BOOL EncodeToAtom( DWORD dwSrcPID, HANDLE dwSrcHandle, DWORD * pdw )
{
    TCHAR szAtomName[ ATOM_STRING_LEN + 1 ]; // +1 for terminating NUL

    wsprintf( szAtomName, TEXT("MSAA:%08X:%08X:"), dwSrcPID, dwSrcHandle );
    ATOM atom = GlobalAddAtom( szAtomName );

    // atoms are unsigned words - make sure they get converted properly to
    // unsigned DWORD/HRESULTs...
    // At least bit32 must be clear, to avoid confusion with error hresults.
    // (Also, atoms are never 0, so no ambiguity over hr=0 return value, which
    // indicates WM_GETOBJECT not supported.)
    *pdw = (DWORD) atom;
    return TRUE;
}



// --------------------------------------------------------------------------
//
//  BOOL DecodeFromAtom( DWORD dw, DWORD * pdwSrcPID, HANDLE * pdwSrcHandle )
//
//
//  IN DWORD dw
//    specifies the atom to be decoded
//
//  OUT DWORD * pdwSrcPID
//    returns the source process id
//
//  OUT HANDLE * pdwSrcHandle
//    returns the handle in source process
//
//  Returns BOOL
//    TRUE on success.
//
//
//  Gets ths string for the atom represented by dw, and decodes it to get
//  the source process id and handle value.
//
// --------------------------------------------------------------------------

static
BOOL DecodeFromAtom( DWORD dw, DWORD * pdwSrcPID, HANDLE * pdwSrcHandle )
{
    // Sanity check that dw looks like an atom - it's a short (WORD), so high word
    // should be zero...

    if( HIWORD( dw ) != 0 || LOWORD( dw ) == 0 )
    {
        TraceError( TEXT("DecodeFromAtom: value doesn't look like atom (%08lx) - high word should be clear"), dw );
        return FALSE;
    }

    ATOM atom = (ATOM)dw;

    TCHAR szAtomName[ ATOM_STRING_LEN + 1 ]; // +1 for terminating NUL

    int len = GlobalGetAtomName( atom, szAtomName, ARRAYSIZE( szAtomName ) );
    if( len != ATOM_STRING_LEN )
    {
        TraceError( TEXT("DecodeFromAtom: atom string is incorrect length - %d instead of %d"), len, ATOM_STRING_LEN );
        return FALSE;
    }

    // Check for expected format...
    if( memcmp( szAtomName, ATOM_STRING_PREFIX, ATOM_STRING_PREFIX_LEN * sizeof( TCHAR ) ) != 0
        || szAtomName[ ATOM_COLON2_OFFSET ] != ':'
        || szAtomName[ ATOM_COLON3_OFFSET ] != ':'
        || szAtomName[ ATOM_NUL_OFFSET ] != '\0' )
    {
        TraceError( TEXT("DecodeFromAtom: atom string has incorrect format (%s)"), szAtomName );
        return FALSE;
    }

    // Extract the source process's PID and its handle from the atom name...
    DWORD dwSrcPID;
    DWORD dwRemoteHandle;

    if( ! ParseHexStr( & szAtomName[ 5 ], & dwSrcPID )
     || ! ParseHexStr( & szAtomName[ 14 ], & dwRemoteHandle ) )
    {
        TraceError( TEXT("DecodeFromAtom: atom string contains bad hex (%s)"), szAtomName );
        return FALSE;
    }

    // Done with the atom - can delete it now...
    GlobalDeleteAtom( atom );

    *pdwSrcPID = dwSrcPID;
    *pdwSrcHandle = LongToHandle( dwRemoteHandle );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\memchk.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  MEMCHK.CPP
//
//  Simple new/delete counting error checking library
//
// --------------------------------------------------------------------------
#include "oleacc_p.h"
#include "default.h"
#include "w95trace.h"
#include "memchk.h"


#ifdef _DEBUG

struct MemInfo
{
	LONG    m_NumAlloc;
	LONG    m_NumFree;
};

// Two MemInfo structures - one for allocations through new/delete,
// one for allocations through SharedAlloc/SharedFree
MemInfo g_MemInfo;
MemInfo g_SharedMemInfo;

#endif // _DEBUG



#ifndef _DEBUG

// Non-_DEBUG new/delete call-through to LocalAlloc/Free...

// --------------------------------------------------------------------------
//
//  new()
//
//  We implement this ourself to avoid pulling in the C++ runtime.
//
// --------------------------------------------------------------------------

void *  __cdecl operator new(size_t nSize)
{
    // Zero init just to save some headaches
    return (void *)LocalAlloc(LPTR, nSize);
}


// --------------------------------------------------------------------------
//
//  delete()
//
//  We implement this ourself to avoid pulling in the C++ runtime.
//
// --------------------------------------------------------------------------
void  __cdecl operator delete(void *pv)
{
    LocalFree((HLOCAL)pv);
}


// --------------------------------------------------------------------------
//
//  SharedAlloc()
//
//  This allocates out of the shared heap on Win '95. On NT, we need to
//  use VirtualAllocEx to allocate memory in the other process. The caller
//  of SharedAlloc will need to then use ReadProcessMemory to read the data
//  from the VirtualAlloc'ed memory. What I am going to do is create 2 new
//  functions - SharedRead and SharedWrite, that will read and write shared
//  memory. On Win95, they will just use CopyMemory, but on NT they will use
//  ReadProcessMemory and WriteProcessMemory.
//
//  Parameters:
//      UINT    cbSize      Size of the memory block required
//      HWND    hwnd        Window handle in the process to allocate
//                          the shared memory in.
//      HANDLE* pProcHandle Pointer to a handle that has the process
//                          handle filled in on return. This must be saved
//                          for use in calls to SharedRead, SharedWrite,
//                          and SharedFree.
//
//  Returns:
//      Pointer to the allocated memory, or NULL if it fails. Access to the
//      memory must be done using SharedRead and SharedWrite. On success,
//      pProcHandle is filled in as well.
//
// --------------------------------------------------------------------------
LPVOID SharedAlloc(UINT cbSize,HWND hwnd,HANDLE *pProcessHandle)
{
#ifndef NTONLYBUILD
    if (fWindows95)
        return(HeapAlloc(hheapShared, HEAP_ZERO_MEMORY, cbSize));
    else
#endif // NTONLYBUILD
    {
        DWORD dwProcessId;
        if( ! GetWindowThreadProcessId( hwnd, & dwProcessId ) )
            return NULL;

        HANDLE hProcess = OpenProcess( PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
									   FALSE,dwProcessId );
        if( ! hProcess )
            return NULL;

        LPVOID pv = MyVirtualAllocEx( hProcess, NULL, cbSize, MEM_COMMIT, PAGE_READWRITE );
        if( ! pv )
        {
            CloseHandle( hProcess );
            return NULL;
        }

        if( pProcessHandle )
            *pProcessHandle = hProcess;

        return pv;
    }
}


// --------------------------------------------------------------------------
//
//  SharedFree()
//
//  This frees shared memory.
//
// --------------------------------------------------------------------------
VOID SharedFree(LPVOID lpv,HANDLE hProcess)
{
#ifndef NTONLYBUILD
    if (fWindows95)
        HeapFree(hheapShared, 0, lpv);
    else
#endif // NTONLYBUILD
    {
        MyVirtualFreeEx(hProcess,lpv,0,MEM_RELEASE);
        CloseHandle (hProcess);
    }
}


// 'Empty' functions to keep compiler/linker happy in case client
// calls these in non _DEBUG code...
// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
void InitMemChk()
{
	// Do nothing
}

// --------------------------------------------------------------------------
// --------------------------------------------------------------------------
void UninitMemChk()
{
	// Do nothing
}



#else // _DEBUG #############################################################

// --------------------------------------------------------------------------
// DEBUG new - increments new count, calls through to LocalAlloc...
// --------------------------------------------------------------------------
void *  __cdecl operator new(unsigned int nSize)
{
    // Zero init just to save some headaches
    void * pv = (void *)LocalAlloc(LPTR, nSize);

	if( ! pv )
	{
		return NULL;
	}

	// Update statistics...
	InterlockedIncrement( & g_MemInfo.m_NumAlloc );

	// return pointer to alloc'd space...
	return pv;
}


// --------------------------------------------------------------------------
// DEBUG delete - increments delete count, calls through to LocalFree...
// --------------------------------------------------------------------------
void  __cdecl operator delete(void *pv)
{
	// C++ allows 'delete NULL'...
	if( pv == NULL )
		return;

    // Update statistics...
	InterlockedIncrement( & g_MemInfo.m_NumFree );

    LocalFree((HLOCAL)pv);
}

// --------------------------------------------------------------------------
//
//  DEBUG SharedAlloc()
//
//  Does alloc, updates count.
// --------------------------------------------------------------------------
LPVOID SharedAlloc(UINT cbSize,HWND hwnd,HANDLE *pProcessHandle)
{
#ifndef NTONLYBUILD
    if (fWindows95)
	{
		// Update statistics...
		InterlockedIncrement( & g_SharedMemInfo.m_NumAlloc );

        return(HeapAlloc(hheapShared, HEAP_ZERO_MEMORY, cbSize));
	}
    else
#endif // NTONLYBUILD
    {
        DWORD dwProcessId;
        if( ! GetWindowThreadProcessId( hwnd, & dwProcessId ) )
            return NULL;

        HANDLE hProcess = OpenProcess( PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE,
									   FALSE,dwProcessId );
        if( ! hProcess )
            return NULL;

        LPVOID pv = MyVirtualAllocEx( hProcess, NULL, cbSize, MEM_COMMIT, PAGE_READWRITE );
        if( ! pv )
        {
            CloseHandle( hProcess );
            return NULL;
        }

		// Update statistics...
		InterlockedIncrement( & g_SharedMemInfo.m_NumAlloc );

        if( pProcessHandle )
            *pProcessHandle = hProcess;

        return pv;
    }
}



// --------------------------------------------------------------------------
//
//  DEBUG SharedFree()
//
//  frees shared memory, updates free count.
//
// --------------------------------------------------------------------------
VOID SharedFree(LPVOID lpv,HANDLE hProcess)
{
	// Update statistics...
	InterlockedIncrement( & g_SharedMemInfo.m_NumFree );

#ifndef NTONLYBUILD
    if (fWindows95)
        HeapFree(hheapShared, 0, lpv);
    else
#endif // NTONLYBUILD
    {
        MyVirtualFreeEx(hProcess,lpv,0,MEM_RELEASE);
        CloseHandle (hProcess);
    }
}


// --------------------------------------------------------------------------
// InitMemChk - sets alloc/free counts to zero.
// --------------------------------------------------------------------------
void InitMemChk()
{
	g_MemInfo.m_NumAlloc = 0;
	g_MemInfo.m_NumFree = 0;

	g_SharedMemInfo.m_NumAlloc = 0;
	g_SharedMemInfo.m_NumFree = 0;
}

// --------------------------------------------------------------------------
// UninitMemChk - outputs stats including number of unfree'd objects...
//
// Note that Shared memory is often allocated from one process and free'd
// from another, so when a process detatches the numbers may not match up.
// At some point in time it might be more useful to keep this as a global
// across all instances of the DLL.
// --------------------------------------------------------------------------
void UninitMemChk()
{
    DBPRINTF( TEXT("Total objects: %d, unfreed: %d\n"),
    	g_MemInfo.m_NumAlloc,
    	g_MemInfo.m_NumAlloc - g_MemInfo.m_NumFree );

    DBPRINTF( TEXT("Total Shared objects: %d, unfreed: %d\n"),
    	g_SharedMemInfo.m_NumAlloc,
    	g_SharedMemInfo.m_NumAlloc - g_SharedMemInfo.m_NumFree );
}

#endif // _DEBUG











// --------------------------------------------------------------------------
//
//  SharedRead
//
//  This reads shared memory.
//
// --------------------------------------------------------------------------

BOOL SharedRead(LPVOID lpvSharedSource,LPVOID lpvDest,DWORD cbSize,HANDLE hProcess)
{
#ifdef _X86_
    if (fWindows95)
    {
        CopyMemory (lpvDest,lpvSharedSource,cbSize);
        return TRUE;
    }
    else
#endif // _X86_
    {
        return (ReadProcessMemory (hProcess,lpvSharedSource,lpvDest,cbSize,NULL));
    }
}


// --------------------------------------------------------------------------
//
//  SharedWrite
//
//  This writes into shared memory.
//
// --------------------------------------------------------------------------

BOOL SharedWrite(LPVOID lpvSource,LPVOID lpvSharedDest,DWORD cbSize,HANDLE hProcess)
{
#ifdef _X86_
    if (fWindows95)
    {
        CopyMemory(lpvSharedDest,lpvSource,cbSize);
        return TRUE;
    }
    else
#endif // _X86_
    {
        return (WriteProcessMemory (hProcess,lpvSharedDest,lpvSource,cbSize,NULL));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\oleacc_p.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  oleacc_p
//
//  Constants, Definitions, Types, and Classes private to the OLEACC
//  implementation. This header file is part of the OLEACC project.
//  OLEACC.H (included here) is machine-generated from OLEACC.IDL via
//  the MIDL compiler.
//
// --------------------------------------------------------------------------


#define INC_OLE2

#pragma warning(disable:4201)	// allows nameless structs and unions
#pragma warning(disable:4514)	// don't care when unreferenced inline functions are removed
#pragma warning(disable:4706)	// we are allowed to assign within a conditional

#include <windows.h>
#include <windowsx.h>

#if (_WIN32_WINNT < 0x0403)		// on Win95 compile, we need stuff in winable.h and userole.h,
#include <winable.h>			// but for NT build, this is included in winuserp.h
#include <userole.h>			// TODO? Change win95 to be more like NT to keep in ssync 
#else							// more easily!
#include <winuserp.h>
#endif

#include <limits.h>


#include "types6432.h"

#include "com_external.h" // this includes oleacc.h, since internal.idl includes oleacc.idl


#include "debug.h"
#include "w95trace.h"   // eventually deprecate this in favor of debug.h

#include "strtable.h"

#include "imports.h"

#include "util.h"
#include "accutil.h"

#include "classinfo.h"


// If this is being built as UNICODE, then assume that this build is NT-Only
// (eg. buildlab); so omit all 9x-specific code.
// (If some version of 9x ever supports Unicode, we may want to change how
// this gets defined.)
#ifdef UNICODE
#define NTONLYBUILD
#endif



//
// Constants
//

#define HEAP_SHARED     0x04000000      // Win95 only
#define HEAP_GLOBAL     0x80000000      // Win95 only


// Should we return DISP_E_MEMBERNOTFOUND explicitly instead of this?
// It's confusing because someone reading the code won't know that
// E_NOT_APPLICABLE is a local define, not a real code...
#define E_NOT_APPLICABLE            DISP_E_MEMBERNOTFOUND



//
// Handy #define's
//

#define ARRAYSIZE(n)    (sizeof(n)/sizeof(n[0]))

#define unused( param )

// TODO - replace this style with the proper version above.
#define UNUSED(param)   (param)




//
// Variables
//
extern HINSTANCE	hinstResDll;	// instance of the resource library
#ifdef _X86_ 
extern HANDLE       hheapShared;    // handle to the shared heap (Windows '95 only)
extern BOOL         fWindows95;     // running on Windows '95?
#endif // _X86_
extern BOOL         fCreateDefObjs; // running with new USER32?


// These all live in memchk.cpp
// SharedAlloc ZEROES OUT THE ALLOCATED MEMORY - we rely on this for class member initialization.
LPVOID   SharedAlloc(UINT cbSize,HWND hwnd,HANDLE *pProcessHandle);
VOID     SharedFree(LPVOID lpv,HANDLE hProcess);
BOOL     SharedRead(LPVOID lpvSharedSource,LPVOID lpvDest,DWORD cbSize,HANDLE hProcess);
BOOL     SharedWrite(LPVOID lpvSource,LPVOID lpvSharedDest,DWORD cbSize,HANDLE hProcess);

// Make sure this function gets called before using oleacc (can be called multiple times)
BOOL     InitOleacc();



// Bit manipultation - a bit more readable than all those |'s and &'s and ~'s and <<'s...
//
// iBit is an index (0 for least significant bit, 1 for second bit, and so on), not a mask.

template <class T>
inline void SetBit( T * pval, int iBit )
{
    *pval |= ( (T)1 << iBit );
}

template <class T>
inline void ClearBit( T * pval, int iBit )
{
    *pval &= ~ ( (T)1 << iBit );
}

template <class T>
inline BOOL IsBitSet( T val, int iBit )
{
    return  val & ( (T)1 << iBit );
}


// Sizes...
//
// Some structs have grown between releases. Typically APIs from later
// releases will accept the previous smaller sizes; but the earlier
// APIs will not accept the new larger sizes.
// So, instead of using sizeof(...), we use this define. This takes
// as an additional argument the last used field in the struct, and
// evalueates to the size of the struct up to and including that field.
//
// We currently use this on an as-needed basis, instead of using it
// everywhere.
//
// Notable structs that got bigger:
// LVITEM - in comctlV6
// TTTOOLINFO - in comctlV6
// MENUITEMINFO - in Win2K
//
// This is based on the CCSIZEOF_STRUCT macro in commctrl.h.
// It's similar to the classic 'offsetof' macro, but it also adds in the
// size of the last field.

#define SIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))


#define SIZEOF_TOOLINFO     SIZEOF_STRUCT( TOOLINFO, lParam )

#if !defined(_WIN64)
#define SIZEOF_MENUITEMINFO SIZEOF_STRUCT( MENUITEMINFO, cch )
#else
// Win64 only accepts the full-sized struct, not any earlier smaller versions.
#define SIZEOF_MENUITEMINFO sizeof( MENUITEMINFO )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\menu.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  MENU.H
//
//  Menu bar Active Accessibility implementation
//
//	There are four classes here. 
//	CMenu is the class that knows how to deal with menu bar objects. These
//	have children that are CMenuItem objects, or just children (rare - 
//	this is when you have a command right on the menu bar).
//	CMenuItem is something that when you click on it opens a popup.
//	It has 1 child that is a CMenuPopupFrame.
//	CMenuPopupFrame is the HWND that pops up when you click on a CMenuItem. It
//	has 1 child, a CMenuPopup.
//  CMenuPopup objects represent the client area of a CMenuPopupFrame HWND.
//  It has children that are menu items (little m, little i), separators, and 
//	CMenuItems (when you have cascading menus).
//
//	This results in a heirarchy that looks like this:
//	menu bar
//		file menu item
//		edit menu item
//          edit menu popup frame (when droppped down)
//			    edit menu popup 
//				    cut menu item
//				    copy menu item
//      view menu item
//          view menu popup (invisible)
//              this menu item
//              that menu item
//      etc.
//
// -------------------------------------------------------------------------=

extern HRESULT CreateMenuBar(HWND hwnd, BOOL fSysMenu, LONG idCur, REFIID riid, void**ppvMenu);
extern HRESULT CreateMenuItem(IAccessible*, HWND, HMENU, HMENU, long, long, BOOL, REFIID, void**);

//
// This is the CMenuClass. It inherits from CAccessible directly since it is a child
// object of a CWindow object.
//
class CMenu : public CAccessible 
{
    public:
        // IAccessible
        STDMETHODIMP        get_accChild(VARIANT, IDispatch**);

        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accDescription(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        STDMETHODIMP        get_accKeyboardShortcut(VARIANT, BSTR*);
        STDMETHODIMP        get_accFocus(VARIANT*);
        STDMETHODIMP        get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP        accSelect(long, VARIANT);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);
        STDMETHODIMP        accDoDefaultAction(VARIANT);

        // IEnumVARIANT
        STDMETHODIMP        Clone(IEnumVARIANT ** ppenum);

        /*CTOR*/            CMenu(HWND, BOOL, long);
        void                SetupChildren(void);
        HMENU               GetMenu(void) {return m_hMenu;}

        // IAccIdentity

        STDMETHODIMP        GetIdentityString(
            DWORD	    dwIDChild,
            BYTE **     ppIDString,
            DWORD *     pdwIDStringLen
        );

    protected:
        BOOL                m_fSysMenu;		// TRUE if this is a system menu
        HMENU               m_hMenu;		// the menu handle
};

//
// This is the CMenuItem class. It inherits from CAccessible because it is
// a child of the CMenu object or the CMenuPopup object.
//
class CMenuItem : public CAccessible
{
    public:
        // IAccessible
        STDMETHODIMP        get_accParent(IDispatch** ppdispParent);
        STDMETHODIMP        get_accChild(VARIANT, IDispatch**);

        STDMETHODIMP        get_accName(VARIANT varChild, BSTR* pszName);
        STDMETHODIMP        get_accRole(VARIANT varChild, VARIANT* pvarRole);
        STDMETHODIMP        get_accState(VARIANT varChild, VARIANT* pvarState);
        STDMETHODIMP        get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut);
        STDMETHODIMP        get_accFocus(VARIANT* pvarFocus);
        STDMETHODIMP        get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction);

        STDMETHODIMP        accSelect(long flagsSel, VARIANT varChild);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long x, long y, VARIANT* pvarHit);
        STDMETHODIMP        accDoDefaultAction(VARIANT varChild);

        // IEnumVARIANT
        STDMETHODIMP        Clone(IEnumVARIANT** ppenum);

        /*CTOR*/            CMenuItem(IAccessible*, HWND, HMENU, HMENU, long, long, BOOL);
        /*DTOR*/            ~CMenuItem();
        void                SetupChildren(void);
        HMENU               GetMenu(void) {return m_hMenu;}

        // IAccIdentity

        STDMETHODIMP        GetIdentityString(
            DWORD	    dwIDChild,
            BYTE **     ppIDString,
            DWORD *     pdwIDStringLen
        );
		
    protected:
        IAccessible*    m_paccParent;   // Parent menu object
		HMENU			m_hMenu;		// menu we are in
		HMENU			m_hSubMenu;		// hMenu of the popup!
        BOOL            m_fInAPopup;    // TRUE - this item is in a popup. False - in a menu bar
        long            m_ItemID;       // Item we are. This will be like 1..n
};

//
// This is the CMenuPopupFrame class. It inherits from the CWindow class
// because it is a thing that has an HWND. We have to override some of the
// methods because it is not a normal window at all.
// It will create a CMenuPopup inside itself as its only child.
//
class CMenuPopupFrame : public CWindow
{
    public:
        // IAccessible
        STDMETHODIMP    get_accParent(IDispatch ** ppdispParent);
        STDMETHODIMP    get_accChild (VARIANT, IDispatch**);
        STDMETHODIMP    get_accName(VARIANT varChild, BSTR* pszName);
        STDMETHODIMP    accHitTest(long x, long y, VARIANT* pvarHit);
        STDMETHODIMP    get_accFocus(VARIANT* pvarFocus);
        STDMETHODIMP    accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP    accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd);

        // IEnumVARIANT
        STDMETHODIMP    Clone(IEnumVARIANT **ppenum);
        STDMETHODIMP    Next(ULONG celt, VARIANT* rgvar, ULONG* pceltFetched);

        /*CTOR*/        CMenuPopupFrame(HWND hwnd,long idChildCur);
        /*DTOR*/        ~CMenuPopupFrame(void);
        void            SetupChildren(void);

    protected:
        long            m_ItemID;       // What is the ID for the parent item that created us?
        HMENU           m_hMenu;        // what hmenu are we?
        HWND            m_hwndParent;   // what hwnd do we descend from?
        BOOL            m_fSonOfPopup;  // are we descended from a popup?
        BOOL            m_fSysMenu;     // are we descended from a sys menu?
};

//
// This is the CMenuPopup class. It inherits from the CClient class because
// it represents the client area of the popup window (HWND type window).
//
class CMenuPopup :  public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accParent(IDispatch** ppdispParent);
        STDMETHODIMP        get_accChild(VARIANT, IDispatch**);

        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accDescription(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        STDMETHODIMP        get_accKeyboardShortcut(VARIANT, BSTR*);
        STDMETHODIMP        get_accFocus(VARIANT*);
        STDMETHODIMP        get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP        accSelect(long, VARIANT);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);
        STDMETHODIMP        accDoDefaultAction(VARIANT);

        // IEnumVARIANT
        STDMETHODIMP        Clone(IEnumVARIANT** ppenum);

        /*CTOR*/            CMenuPopup(HWND, long);
        /*DTOR*/            ~CMenuPopup(void);
        void                SetupChildren(void);
        void                SetParentInfo(IAccessible* paccParent,HMENU hMenu,long ItemID);
        HMENU               GetMenu(void) {return m_hMenu;}

		// IAccIdentity

        STDMETHODIMP        GetIdentityString(
            DWORD	    dwIDChild,
            BYTE **     ppIDString,
            DWORD *     pdwIDStringLen
        );


    protected:
        long                m_ItemID;       // what is the id our parent gave us?
        HMENU               m_hMenu;        // what hmenu are we?
        HWND                m_hwndParent;   // what hwnd do we descend from?
        BOOL                m_fSonOfPopup;  // are we descended from a popup?
        BOOL                m_fSysMenu;     // are we descended from a sys menu?
        IAccessible*        m_paccParent;   // only set if we are invisible, so we know our parent
};

//
// Special system HBITMAP values
//
#define MENUHBM_SYSTEM      1
#define MENUHBM_RESTORE     2
#define MENUHBM_MINIMIZE    3
#define MENUHBM_BULLET      4
#define MENUHBM_CLOSE       5
#define MENUHBM_CLOSE_D     6
#define MENUHBM_MINIMIZE_D  7


// --------------------------------------------------------------------------
//
//  SHELL MENU ITEMS (ownerdraw hack-o-rama parsing)
//
//  The Start menu and other context menus that are ownerdraw in the shell
//  have been inaccessible up til now.
//
//  We are going to hack it and fix it.  If we come across an OWNERDRAW menu
//  item in a popup in the shell process, we will get the item data from
//  it and grovel it.  If there is a string pointer, great.  If not, we will
//  grovel the ITEMIDLIST to pull the string out of there.
//
//  NOTE:  Be careful, massive validation and maybe even try-except would 
//  not be a bad idea.
//
//  ALSO:  This needs to work on Win '95 and Nashville.
//
// --------------------------------------------------------------------------

typedef enum
{
    FMI_NULL            = 0x0000,
    FMI_MARKER          = 0x0001,
    FMI_FOLDER          = 0x0002,
    FMI_EXPAND          = 0x0004,
    FMI_EMPTY           = 0x0008,
    FMI_SEPARATOR       = 0x0010,
    FMI_DISABLED        = 0x0020,     // Enablingly Challenged ???
    FMI_ON_MENU         = 0x0040,
    FMI_IGNORE_PIDL     = 0x0080,
    FMI_FILESYSTEM      = 0x0100,
    FMI_MARGIN          = 0x0200,
    FMI_MAXTIPWIDTH     = 0x0400,
    FMI_TABSTOP         = 0x0800,
    FMI_DRAWFLAGS       = 0x1000,
} FILEMENUITEMFLAGS;


//
// In reality, this is a variable structure, with szFriendlyName null-termed
// followed by sz8.3Name null-termed.
//
typedef struct tagITEMIDLIST
{
    SHORT   cbTotal;
    BYTE    aID[12];
    TCHAR   szFriendlyName[1];
} ITEMIDLIST, *LPITEMIDLIST;


// sizeof(cbTotal) is 2 + sizeof(aID) is 12 
#define OFFSET_SZFRIENDLYNAME   14


//
// One of these per file menu.
//
typedef struct
{
    void *psf;                      // Shell Folder.
    HMENU hmenu;                    // Menu.
    LPITEMIDLIST pidlFolder;        // Pidl for the folder.
    DWORD hdpaFMI;                  // List of items (see below).
    UINT idItems;                   // Command.
    UINT fmf;                       // Header flags.
    UINT fFSFilter;                 // file system enum filter
    HBITMAP hbmp;                   // Background bitmap.
    UINT cxBmp;                     // Width of bitmap.
    UINT cyBmp;                     // Height of bitmap.
    UINT cxBmpGap;                  // Gap for bitmap.
    UINT yBmp;                      // Cached Y coord.
    COLORREF clrBkg;                // Background color.
    UINT cySel;                     // Prefered height of selection.
    DWORD pfncb;                    // Callback function.
} FILEMENUHEADER, *PFILEMENUHEADER;

//
// One of these for each file menu item.
//
typedef struct
{
    PFILEMENUHEADER pFMH;           // The header.
    int iImage;                     // Image index to use.
    FILEMENUITEMFLAGS Flags;        // Misc flags above.
    LPITEMIDLIST pidl;              // IDlist for item.
    LPTSTR psz;                     // Text when not using pidls.
} FILEMENUITEM, *PFILEMENUITEM;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\oleacc.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  OLEACC
//
//  DllMain and other entry points.
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"
#include "classmap.h"
#include "w95trace.h"
#include "memchk.h"
#include "fwd_macros.h"

#include "PropMgr_Client.h"


// Define this locally instead of #including "PropMgr_Impl", since that
// drags in lots of ATL goo.
void PropMgrImpl_Uninit();

//
// Shared Globals
//
// Note that these are only used when running on 9x; and are not even present
// on builds which are specifically for W2K.
//

#ifndef NTONLYBUILD
#pragma data_seg("Shared")
LONG        g_cProcessesMinus1 = -1;    // number of attached processes minus 1 (the Interlocked APIs don't work well with 0 as a base)
HANDLE      hheapShared = NULL;         // handle to the shared heap (Win95 only)
#pragma data_seg()
#pragma comment(linker, "/Section:Shared,RWS")
#endif // NTONLYBUILD


//
// Globals
//

HANDLE      g_hLoadedMutex;             // Useful mutex - by using oh.exe to look for this,
                                        // we can see who's loaded our .dll.
HINSTANCE   g_hinstDll;                 // instance of this library - nothing actually uses this at the moment.
HINSTANCE   hinstResDll;		        // instance of resource library
BOOL        fCreateDefObjs;             // running with new USER32?
BOOL        g_fInitedOleacc = FALSE;    // Set by InitOleacc()
#ifdef _X86_
BOOL        fWindows95;                 // running on Windows '95?
#endif // _X86_


//
// Forward decls...
//


//
// DLL rountines that we chain - we combine:
// * Core oleacc (only DllMan, reg and unreg)
// * RemoteProxyFactory6432
// * Proxy/Stubs fpr the PropMgr
//
extern "C" {
BOOL    WINAPI Oleacc_DllMain( HINSTANCE hinst, DWORD dwReason, LPVOID pvReserved );
HRESULT WINAPI Oleacc_DllRegisterServer();
HRESULT WINAPI Oleacc_DllUnregisterServer();

BOOL    WINAPI ProxyStub_DllMain( HINSTANCE hinst, DWORD dwReason, LPVOID pvReserved );
HRESULT WINAPI ProxyStub_DllRegisterServer();
HRESULT WINAPI ProxyStub_DllUnregisterServer();
HRESULT WINAPI ProxyStub_DllCanUnloadNow();
HRESULT WINAPI ProxyStub_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);

BOOL    WINAPI ComATLMain_DllMain( HINSTANCE hinst, DWORD dwReason, LPVOID pvReserved );
HRESULT WINAPI ComATLMain_DllRegisterServer();
HRESULT WINAPI ComATLMain_DllUnregisterServer();
HRESULT WINAPI ComATLMain_DllCanUnloadNow();
HRESULT WINAPI ComATLMain_DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
};


// This one is called from DLLMain... (not safe to use LoadLibrary etc.)
static BOOL InitOleaccDLL( HINSTANCE hInstance );

// And this one is called in DLLMain when exiting...
static void UninitOleacc();


// This displays a "oleacc version xxxxxx loading/unloading from process xxxx" message
#ifdef _DEBUG
static void DisplayLoadUnloadString( LPCTSTR pszAction );
#endif // _DEBUG





// if this W2K and not ALPHA enable 64b/32b interoperability
#if defined(UNICODE) && !defined(_M_AXP64)
#define ENABLE6432_INTEROP
#endif


BOOL WINAPI DllMain( HINSTANCE hinst, DWORD dwReason, LPVOID pvReserved )
{
#ifdef _WIN64
    DBPRINTF(TEXT("******** Hello from 64-bit OLEACC! ******** \r\n"));
#else
    DBPRINTF(TEXT("******** Hello from 32-bit OLEACC! ******** \r\n"));
#endif
    if( ! Oleacc_DllMain( hinst, dwReason, pvReserved ) )
    {
        DBPRINTF(TEXT("Oleacc_DllMain FAILED\r\n"));
        return FALSE;
    }

	// Call the remote proxy factory for 64/32 bit interop DllMain
	// TODO Possible performance improvement:  only call ProxyFactoryDllMain if loaded by DLLHost32/64
    if( ! ComATLMain_DllMain( hinst, dwReason, pvReserved ) )
    {
        DBPRINTF(TEXT("ComATLMain_DllMain FAILED\r\n"));
        return FALSE;
    }

    if( ! ProxyStub_DllMain( hinst, dwReason, pvReserved ) )
    {
        DBPRINTF(TEXT("ProxyStub_DllMain FAILED\r\n"));
        return FALSE;
    }

    return TRUE;
}




//
// Note about what gets registered:
//
// Oleacc_DllRegisterServer regiters the main typelib - this registers the
// IAccessible interfaces, and sets them to use typelib marshalling.
//
// ProxyStub_DllRegisterServer re-registers the IAccessible interface, also
// registers the IAccProp* annotation interfaces, and sets all those
// interfaces to use proxy/stub marshalling, overwriting the previous
// typelib marshalling, if any.
//
// Oleacc's DLLMain calls Oleacc_DllRegisterServer, which again
// re-registers the interfaces, and sets IAccessible back to using
// typelib marshalling.
//
// Bottom line is that all the interfaces do get registered, though
// some may use typelib marshalling, some may use proxy/stub marshalling.
// Doesn't really matter which is used; both marshalling techniques
// have the same end result.
//
// 
//
// When unregistering, Oleacc_DllUnregisterServer calls the typelib
// unregistration function, which removes the entries for all the IAccessible
// interfaces.
//
// ProxyStub_DllUnregister tries to unregister all the IAccessible and IAccProp
// interfaces - it will successfully remove all those that exist, but on 9x,
// it will return an error hresult because some of those have already been
// unregistered by Oleacc_DllUnregisterServer. (W2K doesn't complain about
// this.) We can safely ignore this error.
//
//
// One possible alternative to all the above would be to just use the
// proxy/stub registration and marshalling, and remove the IAccessible
// typelib stuff completely. This would simplify this code, and simplify
// the data in the registry. However, the typelib approach was kept
// just in case there is some code or tool out there that expects to
// be able to find a typelib for IAccessible via the registry.
//
//
// (Note that the ComATL_* registers/unregisters the Win64 helper
// classes, and that always uses typelib marshalling - using the
// second typelib in oleacc.dll. See those functions for more info.)
//
// 
HRESULT WINAPI DllRegisterServer()
{
    HRESULT hrRet = Oleacc_DllRegisterServer();

    HRESULT hr = ComATLMain_DllRegisterServer();
    if( hrRet == S_OK )
        hrRet = hr;
    
    hr = ProxyStub_DllRegisterServer();
    if( hrRet == S_OK )
        hrRet = hr;

    return hrRet; 
}

HRESULT WINAPI DllUnregisterServer()
{
    HRESULT hrRet = Oleacc_DllUnregisterServer();

    HRESULT hr = ComATLMain_DllUnregisterServer();
    if( hrRet == S_OK )
        hrRet = hr;
    
    // We ignore the 'file not found' error returned by the proxy/stub unregistration
    // code. It tries to unreg all interfaces mentioned in oleacc.idl - but most of those
    // have already been unregd by Oleacc_DllUnregisterServer above. On 9x, it returns
    // this error, which we must ignore. (The w2k version doesn't return this error - 
    // it looks like it ignores it internally.)
    hr = ProxyStub_DllUnregisterServer();
    if( hr != HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) && hrRet == S_OK )
        hrRet = hr;

    return hrRet;
}


HRESULT WINAPI DllCanUnloadNow()
{
    HRESULT hr = ComATLMain_DllCanUnloadNow();
    if( hr != S_OK )
        return hr;

    return ProxyStub_DllCanUnloadNow();
}



HRESULT WINAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr = ComATLMain_DllGetClassObject(rclsid, riid, ppv);
    if( hr == S_OK )
        return hr;

    return ProxyStub_DllGetClassObject(rclsid, riid, ppv);
}










//
// DLLMain
//


BOOL WINAPI Oleacc_DllMain( HINSTANCE hinst, DWORD dwReason, LPVOID unused( pvReserved ) )
{
    if( dwReason == DLL_PROCESS_ATTACH )
    {
        // We don't need DLL_THREAD_XXX notifications - more efficient to not have them...
        DisableThreadLibraryCalls( hinst );

        if( ! InitOleaccDLL( hinst ) )
            return FALSE;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        UninitOleacc();
    }

    return TRUE;
} 


//
//  Oleacc_DllRegisterServer
//

#define TYPELIB_MAJORVER    1
#define TYPELIB_MINORVER    1

HRESULT WINAPI Oleacc_DllRegisterServer()
{
	ITypeLib	*pTypeLib = NULL;
	HRESULT		hr;
    OLECHAR		wszOleAcc[] = L"oleacc.dll";

	hr = LoadTypeLib( wszOleAcc, &pTypeLib );

	if ( SUCCEEDED(hr) )
	{
		hr = RegisterTypeLib( pTypeLib, wszOleAcc, NULL );
		if ( FAILED(hr) )
			DBPRINTF (TEXT("OLEACC: DllRegisterServer could not register type library hr=%lX\r\n"),hr);
		pTypeLib->Release();
	}
	else
	{
		DBPRINTF (TEXT("OLEACC: DllRegisterServer could not load type library hr=%lX\r\n"),hr);
	}

    return S_OK;
}



HRESULT WINAPI Oleacc_DllUnregisterServer()
{
	// The major/minor typelib version number determine
	//	which regisered version of OLEACC.DLL will get
	//	unregistered.

	return UnRegisterTypeLib( LIBID_Accessibility, TYPELIB_MAJORVER, TYPELIB_MINORVER, 0, SYS_WIN32 );
}














// --------------------------------------------------------------------------
//
//  Stubs for the exported APIs.
//
//  The .def file references these (instead of referencing the exported APIs
//  directly) - and these currently just call through to the API code.
//  We can change these to pre/post process or jump elsewhere if necessary.
//
// --------------------------------------------------------------------------

#define FORWARD( ret, name, c, params ) /**/\
    extern "C" ret WINAPI EXTERNAL_ ## name AS_DECL( c, params )\
    {\
        if( ! g_fInitedOleacc )\
            InitOleacc();\
        return name AS_CALL( c, params );\
    }

#define FORWARD_VOID( name, c, params ) /**/\
    extern "C" VOID WINAPI EXTERNAL_ ## name AS_DECL( c, params )\
    {\
        if( ! g_fInitedOleacc )\
            InitOleacc();\
        name AS_CALL( c, params );\
    }


FORWARD( LRESULT,   LresultFromObject,          3,  ( REFIID, riid, WPARAM, wParam, LPUNKNOWN, punk ) )
FORWARD( HRESULT,   ObjectFromLresult,          4,  ( LRESULT, lResult, REFIID, riid, WPARAM, wParam, void**, ppvObject ) )
FORWARD( HRESULT,   WindowFromAccessibleObject, 2,  ( IAccessible *, ppAcc, HWND *, phwnd ) )
FORWARD( HRESULT,   AccessibleObjectFromWindow, 4,  ( HWND, hwnd, DWORD, dwId, REFIID, riid, void **, ppvObject ) )
FORWARD( HRESULT,   AccessibleObjectFromEvent,  5,  ( HWND, hwnd, DWORD, dwId, DWORD, dwChildId, IAccessible **, ppacc, VARIANT *, pvarChild ) )
FORWARD( HRESULT,   AccessibleObjectFromPoint,  3,  ( POINT, ptScreen, IAccessible **, ppacc, VARIANT *, pvarChild ) )
FORWARD( HRESULT,   AccessibleChildren,         5,  ( IAccessible *, paccContainer, LONG, iChildStart, LONG, cChildren, VARIANT *, rgvarChildren, LONG *, pcObtained ) )
FORWARD( UINT,      GetRoleTextA,               3,  ( DWORD, lRole, LPSTR, lpszRole, UINT, cchRoleMax ) )
FORWARD( UINT,      GetRoleTextW,               3,  ( DWORD, lRole, LPWSTR, lpszRole, UINT, cchRoleMax ) )
FORWARD( UINT,      GetStateTextA,              3,  ( DWORD, lStateBit, LPSTR, lpszState, UINT, cchState ) )
FORWARD( UINT,      GetStateTextW,              3,  ( DWORD, lStateBit, LPWSTR, lpszState, UINT, cchState ) )
FORWARD( HRESULT,   CreateStdAccessibleObject,  4,  ( HWND, hwnd, LONG, idObject, REFIID, riid, void **, ppvObject ) )
FORWARD( HRESULT,   CreateStdAccessibleProxyA,  5,  ( HWND, hwnd, LPCSTR, pClassName, LONG, idObject, REFIID, riid, void **, ppvObject ) )
FORWARD( HRESULT,   CreateStdAccessibleProxyW,  5,  ( HWND, hwnd, LPCWSTR, pClassName, LONG, idObject, REFIID, riid, void **, ppvObject ) )

FORWARD_VOID(       GetOleaccVersionInfo,       2,  ( DWORD *, pVer, DWORD *, pBuild ) )





//
//  InitOleaccDLL
//
//  Called from DLLMain - only do bare minimum init here - leave proper initing
//  to InitOleacc(), which is called the first time one of the APIs is called.
//
//  Since this is called from DLLMain, we can't use LoadLibrary() (or anything
//  that uses that) here. See the docs on DLLMain for additional restrictions.
//
//  Anything that can affect the success of this DLL loading/unloading should
//  also go here.
//
static
BOOL InitOleaccDLL( HINSTANCE hInstance )
{

    g_hLoadedMutex = CreateMutex(NULL,NULL,__TEXT("oleacc-msaa-loaded"));
    
    
    g_hinstDll = hInstance;

    // check platform version information
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionEx(&osvi);

    // refuse to run on Win32s
    if (osvi.dwPlatformId == VER_PLATFORM_WIN32s)
        return FALSE;

#ifdef _X86_
    fWindows95 = (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
#endif // _X86_

	// Load the resource-only DLL. We're not supposed to use regular
    // LoadLibary from within DLLMain, but LoadLibraryEx is safe,
    // since it only maps the file, and doesn't exec any code (that
    // lib's DLLMain).
	hinstResDll = LoadLibraryEx( TEXT("OLEACCRC.DLL"), NULL, LOAD_LIBRARY_AS_DATAFILE );
	if( ! hinstResDll )
	{
		// Refuse to load if oleaccrc isn't present
		return FALSE;
	}


    // Use the counter g_cProcessesMinus1 to figure out if this is the 
    // first time this DLL is loaded. If so, do any necessary once-off
    // setup - eg. setting up values in the (9x-only) shared segment.

    // InterlockedIncrement() and Decrement() return 1 if the result is 
    // positive, 0 if  zero, and -1 if negative.  Therefore, the only
    // way to use them practically is to start with a counter at -1.  
    // Then incrementing from -1 to 0, the first time, will give you
    // a unique value of 0.  And decrementing the last time from 0 to -1
    // will give you a unique value of -1.

#ifndef NTONLYBUILD
#ifdef _X86_
    if( InterlockedIncrement( & g_cProcessesMinus1 ) == 0 )
    {
        // if on Win95, create a shared heap to use when
        // communicating with controls in other processes
        if( fWindows95 )
        {
            hheapShared = HeapCreate( HEAP_SHARED, 0, 0 );
            if( hheapShared == NULL )
                return FALSE;
        }
    }
#endif // _X86_
#endif // NTONLYBUILD


    return TRUE;
}



//
//  InitOleacc
//
//  Called when any of our APIs is called for the first time. Proper initialization
//  happens here.  Also called in DllGetClassObject.
//
BOOL InitOleacc()
{
    if (g_fInitedOleacc)
        return TRUE;

    g_fInitedOleacc = TRUE;

    // set the flag that causes proxies to work.
    fCreateDefObjs = TRUE;

    // Init any GetProcAddress'd imports
    InitImports();


#ifdef _DEBUG

	// Initialize the new/delete checker...
	InitMemChk();

    DisplayLoadUnloadString( TEXT("loading") );

#ifndef NTONLYBUILD

    // On first load, show dialog with names of any imports not found...
    if( g_cProcessesMinus1 == 0 )
    {
        TCHAR szErrorMsg[1024];
        lstrcpy( szErrorMsg,TEXT("WARNING: the following functions were not found:\r\n") );

        LPTSTR pEnd = szErrorMsg + lstrlen( szErrorMsg );
        ReportMissingImports( pEnd );

        if( *pEnd )
        {
            MessageBeep( MB_ICONEXCLAMATION );
            MessageBox( NULL, szErrorMsg, TEXT("OLEACC.DLL"), MB_OK | MB_ICONEXCLAMATION );
			DBPRINTF( szErrorMsg );
        }
    }

#endif // NTONLYBUILD

#endif // _DEBUG


    // Everything that follows is done for every process attach.

    // do a LoadLibrary of OLEAUT32.DLL to ensure that it stays
    // loaded in every process that OLEACC is attched to.
    // There is a slight chance of a crash. From Paul Vick:
    // The problem occurs when oleaut32.dll is loaded into a process, 
    // used, unloaded and then loaded again. When you try to use 
    // oleaut32.dll in this case, you crash because of a problem 
    // manging state between us (oleaut32) and OLE. What happens is that when 
    // oleaut32.dll is loaded, we register some state with OLE so 
    // we are notified when OLE is uninitialized. In some cases 
    // (esp. multithreading), we are not able to clean up this 
    // state when were unloaded. When you reload oleaut32.dll, 
    // we try to set the state in OLE again and OLE tries to free 
    // the old (invalid) state, causing a crash later on.
    LoadLibrary( TEXT("OLEAUT32.DLL") );

    InitWindowClasses();

    // Since Office 97 can mess up the registration, 
    // we'll call our self-registration function.
    // may be slight perf hit on load, but not that big a deal,
    // and this way we know we are always correctly registered..
    Oleacc_DllRegisterServer();

    // Initialize the property/annotation client
    PropMgrClient_Init();

    return TRUE;
}



//
//  UninitOleacc
//
//  Called on DLL Detach time from DLLMain. Any necessary cleanup happens here.
//
static
void UninitOleacc()
{
    PropMgrImpl_Uninit();

    PropMgrClient_Uninit();

	// Release the resource DLL. Usually FreeLibrary isn't safe, but it's OK
    // here since this is a resource-only DLL that was loaded _AS_DATAFILE.
	if( hinstResDll )
		FreeLibrary( hinstResDll );

#ifdef _DEBUG
	// This reports the number of outstanding delete's, if any...
	UninitMemChk();
    DisplayLoadUnloadString( TEXT("unloading") );
#endif // _DEBUG


#ifndef NTONLYBUILD
    // stuff that needs to be cleaned up on the last detach - clean
    // up stuff in the shared data segment.
    if (InterlockedDecrement(&g_cProcessesMinus1) == -1)
    {
#ifdef _X86_
        if (fWindows95)
        {
            if (hheapShared)
                HeapDestroy(hheapShared);
            hheapShared = NULL;
        }
#endif // _X86_
		UnInitWindowClasses();
    }
#endif // NTONLYBUILD

    if( g_hLoadedMutex )
        CloseHandle( g_hLoadedMutex );
}





#ifdef _DEBUG

void DisplayLoadUnloadString( LPCTSTR pszAction )
{
    TCHAR szModName[255];
    TCHAR szVer[1024] = TEXT("???");

	// Output to debug terminal - oleacc was attached to process x,
	// show which oleacc version is running, what directory it was
	// loaded from, etc.

    // NULL -> get application's name (not oleacc)
    MyGetModuleFileName( NULL, szModName, ARRAYSIZE( szModName ) );
    DBPRINTF( TEXT("'%s' is %s "),szModName, pszAction );

    MyGetModuleFileName( g_hinstDll, szModName, ARRAYSIZE( szModName ) );

    DWORD dwUseless;
    DWORD dwSize = GetFileVersionInfoSize( szModName, & dwUseless );
    if( dwSize )
    {
        LPVOID lpVersionData = LocalAlloc( LPTR, (UINT) dwSize );
        if( GetFileVersionInfo( szModName, dwUseless, dwSize, lpVersionData ) )
        {
            VS_FIXEDFILEINFO * lpVersionInfo;
            DWORD dwBytes;
            VerQueryValue( lpVersionData, TEXT("\\"), (void**)&lpVersionInfo, (UINT*)&dwBytes );
            wsprintf( szVer, TEXT("%d.%d.%d.%d"), HIWORD( lpVersionInfo->dwFileVersionMS ),
                                                  LOWORD( lpVersionInfo->dwFileVersionMS ),
                                                  HIWORD( lpVersionInfo->dwFileVersionLS ),
                                                  LOWORD( lpVersionInfo->dwFileVersionLS ) );
        }
		LocalFree( (HLOCAL) lpVersionData );
    }

	DBPRINTF( TEXT("%s version %s\r\n"), szModName, szVer );
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\progress.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PROGRESS.CPP
//
//  Wrapper for COMCTL32's progress bar
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "progress.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOTOOLBAR
#define NOHOTKEY
#define NOHEADER
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTABCONTROL
#define NOANIMATE
#include <commctrl.h>



// --------------------------------------------------------------------------
//
//  CreateProgressBarClient()
//
//  EXTERNAL for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateProgressBarClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvProgress)
{
    CProgressBar*   pprogress;
    HRESULT         hr;

    InitPv(ppvProgress);

    pprogress = new CProgressBar(hwnd, idChildCur);
    if (!pprogress)
        return(E_OUTOFMEMORY);

    hr = pprogress->QueryInterface(riid, ppvProgress);
    if (!SUCCEEDED(hr))
        delete pprogress;

    return(hr);
}




// --------------------------------------------------------------------------
//
//  CProgressBar::CProgressBar()
//
// --------------------------------------------------------------------------
CProgressBar::CProgressBar(HWND hwnd, long idChildCur)
    : CClient( CLASS_ProgressBarClient )
{
    Initialize(hwnd, idChildCur);
    m_fUseLabel = TRUE;
}



// --------------------------------------------------------------------------
//
//  CProgressBar::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CProgressBar::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_PROGRESSBAR;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CProgressBar::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CProgressBar::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    LONG    lCur;
    LONG    lMin;
    LONG    lMax;
    TCHAR   szPercentage[16];
    TCHAR   szFormat[8];

    InitPv(pszValue);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // The value of the progress bar is the current percent complete.  This is
    // cur pos - low pos / high pos - low pos.
    //

    //
    // We can now get the range and the position without changing them,
    // Thank you CheeChew!
    //
    lCur = SendMessageINT(m_hwnd, PBM_GETPOS, 0, 0);
    lMin = SendMessageINT(m_hwnd, PBM_GETRANGE, TRUE, 0);
    lMax = SendMessageINT(m_hwnd, PBM_GETRANGE, FALSE, 0);

    //
    // Don't want to divide by zero.
    //
    if (lMin == lMax)
        lCur = 100;
    else
    {
        //
        // Convert to a percentage.
        //
        lCur = max(lCur, lMin);
        lCur = min(lMax, lCur);
        
        lCur = (100 * (lCur - lMin)) / (lMax - lMin);
    }

    // Make a string
    LoadString(hinstResDll, STR_PERCENTAGE_FORMAT, szFormat, ARRAYSIZE(szFormat));
    wsprintf(szPercentage, szFormat, lCur);

    *pszValue = TCharSysAllocString(szPercentage);
    if (! *pszValue)
        return(E_OUTOFMEMORY);
    else
        return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\propmgr_client.cpp ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Client
//
//  Property manager / annotation client. Uses the shared memory component 
//  (PropMgr_MemStream.*) to read properties directly w/o cross-proc com overhead
//  to the annotation server.
//
//  This is effectively a singleton - Init/Uninit called at startup/shutdown,
//  plus one method to get properties.
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"

#include "PropMgr_Client.h"

#include "PropMgr_Util.h"
#include "PropMgr_Mem.h"


// Note: See PropMgr_Impl.cpp for a description of the shared memory
// layout.


// class MapReaderMgr
//
// This class manages looking up properties.
//
// This class is private to this file; its functionality is exposed by the
// PropMgr_ APIs near the bottom of this file.
//
// This class is a singleton, a single instance, g_MapReader, exists.

class MapReaderMgr
{



    // _ReadCallbackProperty
    //
    // Given a pointer to the start of a marshaled object reference pInfo,
    // it unmarshalls the callback object and calls it to get the property
    // corresponding to the given child key.
    // Returns TRUE if all goes well, and if the callback knows about this
    // property.
    BOOL _ReadCallbackProperty( MemStream pInfo,
                                const BYTE * pChildKey, DWORD dwChildKeyLen, 
                                PROPINDEX idxProp,
                                VARIANT * pvar )
    {
        // Read length of marshalled data...
        DWORD dwLen;
        if( ! MemStreamRead_DWORD( pInfo, & dwLen ) )
        {
            return FALSE;
        }

        const BYTE * pData = MemStream_GetBinaryPtr( pInfo, dwLen );
        if( ! pData )
        {
            return FALSE;
        }

        IAccPropServer * pServer = NULL;
        HRESULT hr = UnmarshalInterface( pData, dwLen, IID_IAccPropServer, (void **) & pServer );
        if( hr != S_OK )
        {
            return FALSE;
        }

        // Got it - ask it for the property...
        BOOL fGotProp = FALSE;
        hr = pServer->GetPropValue( pChildKey, dwChildKeyLen,
                                    *g_PropInfo[ idxProp ].m_idProp,
                                    pvar,
                                    & fGotProp );
        pServer->Release();

        // Did the call succeed, and did the server return a value?
        if( hr != S_OK || fGotProp == FALSE )
        {
            return FALSE;
        }

        return TRUE;
    }
        


    // Read a specific property from a record .
    // (a record contains all properties about a given object)
    BOOL _ReadPropertyFromEntry( MemStream pEntryInfo,
                                 const BYTE * pChildKey, DWORD dwChildKeyLen, 
                                 PROPINDEX idxProp,
                                 BOOL fWantContainerOnly,
                                 VARIANT * pvar )
    {
        // Skip over the size at start of info block
        if( ! MemStreamSkip_DWORD( pEntryInfo ) )
        {
            return FALSE;
        }

        // Extract the bitmasks:
        // Which properties are present, which are variants, and which are scoped...
        DWORD dwUsedBits;
        DWORD dwVariantBits;
        DWORD dwScopeBits;

        if( ! MemStreamRead_DWORD( pEntryInfo, & dwUsedBits )
         || ! MemStreamRead_DWORD( pEntryInfo, & dwVariantBits )
         || ! MemStreamRead_DWORD( pEntryInfo, & dwScopeBits ) )
        {
            return FALSE;
        }

        // Is the property we're looking for present at all?
        // (Note - if we decide to allow other GUIDS other than those in the array,
        // we'll have to skip over the indexed ones and then search through any
        // guid/val pairs after that. Could use one bit of this mask to indicate
        // 'there are other // GUID properties present', though.)
        if( ! IsBitSet( dwUsedBits, idxProp ) )
        {
            // Property not present - return false.
            return FALSE;
        }

        // The property is present - but are we specifically looking for
        // container-scoped properties? If so, bail out if the bit isn't set...
        if( fWantContainerOnly && ! IsBitSet( dwScopeBits, idxProp ) )
        {
            return FALSE;
        }

        // Property is present - now we have to skip over the other present
        // properties to get to the one we want...
        for( int i = 0 ; i < idxProp ; i++ )
        {
            // Only haqve to skip over properties that are actually present...
            if( IsBitSet( dwUsedBits, i ) )
            {
                if( IsBitSet( dwVariantBits, i ) )
                {
                    // Skip over variant...
                    if( ! MemStreamSkip_VARIANT( pEntryInfo ) )
                        return FALSE;
                }
                else
                {
                    // Skip over object reference...
                    DWORD dwLen;
                    if( ! MemStreamRead_DWORD( pEntryInfo, & dwLen ) )
                        return FALSE;

                    if( ! MemStreamSkip_Binary( pEntryInfo, dwLen ) )
                        return FALSE;
                }
            }
        }

        // Now we're at the one we want. Extract it...

        // Is it a variant or a server object?
        if( IsBitSet( dwVariantBits, idxProp ) )
        {
            // variant - return it...
            return MemStreamRead_VARIANT( pEntryInfo, pvar );
        }
        else
        {
            // server object - use and return what it returns...
            return _ReadCallbackProperty( pEntryInfo,
                                          pChildKey, dwChildKeyLen, 
                                          idxProp,
                                          pvar );
        }
    }



    HWND PropHwndFromKey( const BYTE * pKey, DWORD dwKeyLen )
    {
        HWND hwndProp;
        if( DecodeHwndKey( pKey, dwKeyLen, & hwndProp, NULL, NULL ) )
        {
            return hwndProp;
        }

        // If it's a HMENU key, find the PID, then find window using window name
        // generated using that PID...
        DWORD dwPid;
        if( DecodeHmenuKey( pKey, dwKeyLen, & dwPid, NULL, NULL ) )
        {
            TCHAR szWindowName[ 64 ];
            wsprintf( szWindowName, TEXT("MSAA_DA_%lx"), dwPid );

            hwndProp = FindWindow( TEXT("MSAA_DA_Class"), szWindowName );

            return hwndProp;
        }

        return NULL;
    }


    // _LookupProp
    //
    // 
    // fWantContainerOnly means we're only interested in props markes with the
    // 'container' scope. This happens when we search for a prop for a child,
    // don't find anything there - so also check parent to see if it is a parent
    // and has a property set for it and its children. (These props are currently
    // always server callback props)
    BOOL _LookupProp( const BYTE * pKey, DWORD dwKeyLen, 
                      const BYTE * pChildKey, DWORD dwChildKeyLen, 
                      PROPINDEX idxProp, BOOL fWantContainerOnly, VARIANT * pvar )
    {
        HWND hwndProp = PropHwndFromKey( pKey, dwKeyLen );
        if( ! hwndProp )
        {
            return FALSE;
        }

        LPTSTR pKeyString = MakeKeyString( pKey, dwKeyLen );
        if( ! pKeyString  )
        {
            return FALSE;
        }

        void * pvProp = GetProp( hwndProp, pKeyString );

        delete [ ] pKeyString;


        if( ! pvProp )
        {
            return FALSE;
        }

        DWORD pid = 0;
        GetWindowThreadProcessId( hwndProp, & pid );
        if( ! pid )
        {
            return FALSE;
        }
        HANDLE hProcess = OpenProcess( PROCESS_VM_READ, FALSE, pid );
        if( ! hProcess )
        {
            return FALSE;
        }

        DWORD dwSize;
        SIZE_T cbBytesRead = 0;
        if( ! ReadProcessMemory( hProcess, pvProp, & dwSize, sizeof( dwSize ), & cbBytesRead )
                || cbBytesRead != sizeof( dwSize ) )
        {
            CloseHandle( hProcess );
            return FALSE;
        }


        BYTE * pBuffer = new BYTE [ dwSize ];
        if( ! pBuffer )
        {
            CloseHandle( hProcess );
            return FALSE;
        }

        cbBytesRead = 0;
        if( ! ReadProcessMemory( hProcess, pvProp, pBuffer, dwSize, & cbBytesRead )
                || cbBytesRead != dwSize )
        {
            delete [ ] pBuffer;
            CloseHandle( hProcess );
            return FALSE;
        }

        CloseHandle( hProcess );

        
        MemStream p( pBuffer, dwSize );


        BOOL fGotProp = _ReadPropertyFromEntry( p,
                                                pChildKey, dwChildKeyLen, 
                                                idxProp,
                                                fWantContainerOnly,
                                                pvar );

        delete [ ] pBuffer;

        return fGotProp;
    }




public:

    BOOL LookupProp( const BYTE * pKey,
                     DWORD dwKeyLen,
                     PROPINDEX idxProp,
                     VARIANT * pvar )
    {
        BOOL bRetVal = _LookupProp( pKey, dwKeyLen,
                                    pKey, dwKeyLen,
                                    idxProp, FALSE, pvar );

        if( ! bRetVal )
        {
            // Is this a leaf-node element? If so, try the parent for a 'container
            // scope' property.
            // This is what allows a callback-annotation on a parent to apply
            // to all its simple-element children
            // If we later extend this to allow for pluggable namespaces, we'd
            // need to change this to be non-HWND-specific (eg. call a
            // IAccNamespece::GetParentKey() or similar method)
            HWND hwnd;
            DWORD idObject;
            DWORD idChild;
            if( DecodeHwndKey( pKey, dwKeyLen, & hwnd, & idObject, & idChild )
             && idChild != CHILDID_SELF )
            {
                BYTE ParentKey[ HWNDKEYSIZE ];
                MakeHwndKey( ParentKey, hwnd, idObject, CHILDID_SELF );
                bRetVal = _LookupProp( ParentKey, HWNDKEYSIZE,
                                       pKey, dwKeyLen,
                                       idxProp, TRUE, pvar );
            }
            else
            {
                HMENU hmenu;
                DWORD idChild;
                DWORD dwpid;
                if( DecodeHmenuKey( pKey, dwKeyLen, & dwpid, & hmenu, & idChild )
                 && idChild != CHILDID_SELF )
                {
                    BYTE ParentKey[ HMENUKEYSIZE ];
                    MakeHmenuKey( ParentKey, dwpid, hmenu, CHILDID_SELF );
                    bRetVal = _LookupProp( ParentKey, HMENUKEYSIZE,
                                           pKey, dwKeyLen,
                                           idxProp, TRUE, pvar );
                }
            }
        }

        return bRetVal;
    }
};



MapReaderMgr g_MapReader;






BOOL PropMgrClient_Init()
{
    // no-op
    return TRUE;
}

void PropMgrClient_Uninit()
{
    // no-op
}

BOOL PropMgrClient_CheckAlive()
{
    // no-op
    return TRUE;
}

BOOL PropMgrClient_LookupProp( const BYTE * pKey,
                               DWORD dwKeyLen,
                               PROPINDEX idxProp,
                               VARIANT * pvar )
{
    return g_MapReader.LookupProp( pKey, dwKeyLen, idxProp, pvar );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\outline.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  OUTLINE.H
//
//  Knows how to talk to COMCTL32's TreeView control.
//
//  NOTE:  The VALUE is the indent level.  This lets us treat the children
//  like peers (otherwise, the elements of a node would be children but not
//  contained, really weird).
//
//  NOTE:  The child id is the HTREEITEM.  There is no index support for
//  treeview.  Hence we must do our own validation and IEnumVARIANT handling.
//
// --------------------------------------------------------------------------


class COutlineView32 :  public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accValue(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP        get_accState(VARIANT, VARIANT*);
        STDMETHODIMP        get_accDescription(VARIANT, BSTR*);
        STDMETHODIMP        get_accFocus(VARIANT*);
        STDMETHODIMP        get_accSelection(VARIANT*);
        STDMETHODIMP        get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP        accSelect(long, VARIANT);
        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);
        STDMETHODIMP        accDoDefaultAction(VARIANT varChild);

        // IEnumVARIANT
        STDMETHODIMP        Next(ULONG, VARIANT*, ULONG*);
        STDMETHODIMP        Skip(ULONG);
        STDMETHODIMP        Reset(void);

        
        BOOL        ValidateChild(VARIANT*);
        void        SetupChildren(void);
        COutlineView32(HWND, long);

    private:
        HTREEITEM   NextLogicalItem(HTREEITEM);
        HTREEITEM   PrevLogicalItem(HTREEITEM);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\outline.cpp ===
// --------------------------------------------------------------------------
//
//  OUTLINE.CPP
//
//  Wrapper for COMCTL32's treeview control
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "RemoteProxy6432.h"
#include "propmgr_util.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOTOOLBAR
#define NOHOTKEY
#define NOPROGRESS
//#define NOLISTVIEW            // INDEXTOSTATEIMAGEMASK needs LISTVIEW
#define NOANIMATE
#include <commctrl.h>
#include "Win64Helper.h"
#include "w95trace.h"

#include "outline.h"

struct MSAASTATEIMAGEMAPENT
{
    DWORD   dwRole;
    DWORD   dwState;
};


enum
{
    TV_IMGIDX_Image,
    TV_IMGIDX_State,
    TV_IMGIDX_Overlay,
    TV_IMGIDX_COUNT
};

BOOL TVGetImageIndex( HWND hwnd, HTREEITEM id, int aKeys[ TV_IMGIDX_COUNT ] );


extern "C" {
BOOL GetRoleFromStateImageMap( HWND hwnd, int iImage, DWORD * pdwRole );
BOOL GetStateFromStateImageMap( HWND hwnd, int iImage, DWORD * pdwState );
BOOL GetStateImageMapEnt_SameBitness( HWND hwnd, int iImage, DWORD * pdwState, DWORD * pdwRole );
}


// These convert between the DWORD childIDs and HTREEITEMS.
//
// Pre-win64, HTREEITEMS were cast to DWORDs, but that doesn't work on
// Win64 since HTREEITEMS are pointers, and no longer fit into a plain
// DWORD. Instead, the treeview supplies messages to map between
// an internal DWORD id and HTREEITEMS; these functions wrap that
// functionality.

HTREEITEM TVItemFromChildID( HWND hwnd, DWORD idChild );

DWORD ChildIDFromTVItem( HWND hwnd, HTREEITEM htvi );




// Template-based shared read/write/alloc
//
// Notes:
//
//   Read/Write each have two versions; one reads/writes a single item,
//   the other allows a count to be specified. Count specifies number
//   of items, not the number of bytes (unless the type is actually byte!).
//
//   Order or arguments is ( dest, souce ) - this is consistent with memcpy,
//   strcpy and regular assignments (dest = source).
//
//   In TSharedWrite, the source arg is an actual value, not a pointer to one.
//   (This avoids having to use a dummy variable to contain the value you want
//   to use.)

template< typename T >
BOOL TSharedWrite( T * pRemote, const T & Local, HANDLE hProcess )
{
    return SharedWrite( const_cast< T * >( & Local ), pRemote, sizeof( T ), hProcess );
}

template< typename T >
BOOL TSharedRead( T * pLocal, const T * pRemote, HANDLE hProcess )
{
    return SharedRead( const_cast< T * >( pRemote ), pLocal, sizeof( T ), hProcess );
}

template< typename T >
BOOL TSharedRead( T * pLocal, const T * pRemote, int count, HANDLE hProcess )
{
    return SharedRead( const_cast< T * >( pRemote ), pLocal, sizeof( T ) * count, hProcess );
}

template< typename T >
T * TSharedAlloc( HWND hwnd, HANDLE * pProcessHandle )
{
    return (T *) SharedAlloc( sizeof( T ), hwnd, pProcessHandle );
}

template< typename T >
T * TSharedAllocExtra( HWND hwnd, HANDLE * pProcessHandle, UINT cbExtra )
{
    return (T *) SharedAlloc( sizeof( T ) + cbExtra, hwnd, pProcessHandle );
}





#define MAX_NAME_SIZE   255

// these are in a newer version of comctl.h
#ifndef TVM_GETITEMSTATE

#define TVM_GETITEMSTATE        (TV_FIRST + 39)

#define TreeView_GetItemState(hwndTV, hti, mask) \
   (UINT)SNDMSG((hwndTV), TVM_GETITEMSTATE, (WPARAM)hti, (LPARAM)mask)

#define TreeView_GetCheckState(hwndTV, hti) \
   ((((UINT)(SNDMSG((hwndTV), TVM_GETITEMSTATE, (WPARAM)hti, TVIS_STATEIMAGEMASK))) >> 12) -1)

#endif // ifndef TVM_GETITEMSTATE


// --------------------------------------------------------------------------
//
//  CreateTreeViewClient()
//
// --------------------------------------------------------------------------
HRESULT CreateTreeViewClient(HWND hwnd, long idChildCur, REFIID riid,
    void** ppvTreeView)
{
    COutlineView32 * poutline;
    HRESULT         hr;

    InitPv(ppvTreeView);

    poutline = new COutlineView32(hwnd, idChildCur);
    if (!poutline)
        return(E_OUTOFMEMORY);

    hr = poutline->QueryInterface(riid, ppvTreeView);
    if (!SUCCEEDED(hr))
        delete poutline;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::COutlineView32()
//
// --------------------------------------------------------------------------
COutlineView32::COutlineView32(HWND hwnd, long idChildCur)
    : CClient( CLASS_TreeViewClient )
{
    m_fUseLabel = TRUE;
    Initialize(hwnd, idChildCur);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::SetupChildren()
//
// --------------------------------------------------------------------------
void COutlineView32::SetupChildren(void)
{
    m_cChildren = SendMessageINT(m_hwnd, TVM_GETCOUNT, 0, 0);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::ValidateChild()
//
//  We have no index-ID support in tree view.  Hence, the HTREEITEM is the
//  child ID, only thing we can do.  We don't bother validating it except
//  to make sure it is less than 0x80000000.
//
// --------------------------------------------------------------------------
BOOL COutlineView32::ValidateChild(VARIANT* pvar)
{
TryAgain:
    switch (pvar->vt)
    {
        case VT_VARIANT | VT_BYREF:
            VariantCopy(pvar, pvar->pvarVal);
            goto TryAgain;

        case VT_ERROR:
            if (pvar->scode != DISP_E_PARAMNOTFOUND)
                return(FALSE);
            // FALL THRU

        case VT_EMPTY:
            pvar->vt = VT_I4;
            pvar->lVal = 0;
            break;

        case VT_I4:
//BRENDANM - high bit set is valid, on 3G systems plus this can also happen on w64?
//            if (pvar->lVal < 0)
//                return(FALSE);

            //
            // Assume it's a valid HTREEITEM!
            //
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::NextLogicalItem()
//
// --------------------------------------------------------------------------
HTREEITEM COutlineView32::NextLogicalItem(HTREEITEM ht)
{
    HTREEITEM htNext;

    //
    // We see if this item has a child.  If so, we are done.  If not,
    // we get the next sibling.  If that fails, we move back to the parent,
    // and try the next sibling thing again.  And so on until we reach the
    // root.
    //
    htNext = TreeView_GetChild(m_hwnd, ht);
    if (htNext)
        return(htNext);

    while (ht)
    {
        htNext = TreeView_GetNextSibling(m_hwnd, ht);
        if (htNext)
            return(htNext);

        ht = TreeView_GetParent(m_hwnd, ht);
    }

    return(NULL);
}

// --------------------------------------------------------------------------
//
//  COutlineView32::PrevLogicalItem()
//
// --------------------------------------------------------------------------
HTREEITEM COutlineView32::PrevLogicalItem(HTREEITEM ht)
{
    HTREEITEM htPrev;

    //
    // If this item has no previous sibling return the parent.
    // Then if the so, see if run done the first children.  
    // Then get the previous sibling has no children return that.
    // Otherwise march down the tre find the last sibling of the last child
    //
    htPrev = TreeView_GetPrevSibling(m_hwnd, ht);
    if ( !htPrev )
    {
        return TreeView_GetParent(m_hwnd, ht);
    }
    else
    {   
        HTREEITEM htTest = TreeView_GetChild(m_hwnd, htPrev);
		if ( !htTest )
		{
            return htPrev;
		}
		else
		{
			htPrev = htTest;
		    // We are at the first child of the previous sibling
			for ( ;; )
			{
				htTest = TreeView_GetNextSibling(m_hwnd, htPrev);
				if ( !htTest )
			    {
    				htTest = TreeView_GetChild(m_hwnd, htPrev);
    				if ( !htTest )
    				    break;
    			}	

                htPrev = htTest;
			}

			return htPrev;
		}
    }
}


// --------------------------------------------------------------------------
//
//  COutlineView32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accName(VARIANT varChild, BSTR* pszName)
{
    TVITEM* lptvShared;
    LPTSTR  lpszShared;
    HANDLE  hProcess;
    LPTSTR  lpszLocal;

    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    if (!varChild.lVal)
        return CClient::get_accName(varChild, pszName);

    HTREEITEM htItem = TVItemFromChildID( m_hwnd, varChild.lVal );
    if( ! htItem )
    {
        return E_INVALIDARG;
    }

    //
    // Try getting the item's text the easy way, by asking first. Since the
    // file system limits us to 255 character names, assume items aren't
    // bigger than that.
    //
    lptvShared = TSharedAllocExtra<TVITEM>( m_hwnd, & hProcess,
                                            (MAX_NAME_SIZE+2)*sizeof(TCHAR) );
    if (!lptvShared)
        return(E_OUTOFMEMORY);

    lpszLocal = (LPTSTR)LocalAlloc(LPTR,((MAX_NAME_SIZE+2)*sizeof(TCHAR)));
    if (!lpszLocal)
    {
        SharedFree (lptvShared,hProcess);
        return(E_OUTOFMEMORY);
    }

    lpszShared = (LPTSTR)(lptvShared+1);

    // (UINT) cast converts plain int to same type as ->mask, which is UINT.
    TSharedWrite( & lptvShared->mask,       (UINT)TVIF_TEXT,    hProcess );
    TSharedWrite( & lptvShared->hItem,      htItem,             hProcess );
    TSharedWrite( & lptvShared->pszText,    lpszShared,         hProcess );
    TSharedWrite( & lptvShared->cchTextMax, MAX_NAME_SIZE + 1,  hProcess );

    if (TreeView_GetItem(m_hwnd, lptvShared))
    {
        TSharedRead( lpszLocal, lpszShared, MAX_NAME_SIZE + 2, hProcess );
        if (*lpszLocal)
            *pszName = TCharSysAllocString(lpszLocal);
    }

    SharedFree(lptvShared,hProcess);
    LocalFree (lpszLocal);

    return(*pszName ? S_OK : S_FALSE);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::get_accValue()
//
//  This returns back the indent level for a child item.
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    InitPv(pszValue);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    if (!varChild.lVal)
        return E_NOT_APPLICABLE;

    HTREEITEM htParent = TVItemFromChildID( m_hwnd, varChild.lVal );
	if( ! htParent )
	{
		return E_INVALIDARG;
	}

    long lValue = 0;
    while( htParent = TreeView_GetParent( m_hwnd, htParent ) )
	{
        lValue++;
	}

    return VarBstrFromI4( lValue, 0, 0, pszValue );
}

// --------------------------------------------------------------------------
//
//  COutlineView32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    pvarRole->vt = VT_I4;

    if (varChild.lVal)
    {
		HTREEITEM htItem = TVItemFromChildID( m_hwnd, varChild.lVal );
		if( ! htItem )
		{
			return E_INVALIDARG;
		}

        DWORD dwRole;
        BOOL fGotRole = FALSE;

        int aKeys[ TV_IMGIDX_COUNT ];
        if( TVGetImageIndex( m_hwnd, htItem, aKeys ) )
        {
            if( CheckDWORDMap( m_hwnd, OBJID_CLIENT, CHILDID_SELF,
                               PROPINDEX_ROLEMAP,
                               aKeys, ARRAYSIZE( aKeys ),
                               & dwRole ) )
            {
                pvarRole->lVal = dwRole;
                fGotRole = TRUE;
            }
            else if( GetRoleFromStateImageMap( m_hwnd, aKeys[ TV_IMGIDX_Image ], & dwRole ) )
            {
                pvarRole->lVal = dwRole;
                fGotRole = TRUE;
            }
        }

        if( ! fGotRole )
        {
            //
            //  Note that just because the treeview has TVS_CHECKBOXES
            //  doesn't mean that every item is itself a checkbox.  We
            //  need to sniff at the item, too, to see if it has a state
            //  image.
            //
            if ((GetWindowLong (m_hwnd,GWL_STYLE) & TVS_CHECKBOXES) &&
                TreeView_GetItemState(m_hwnd, htItem, TVIS_STATEIMAGEMASK))
            {
                pvarRole->lVal = ROLE_SYSTEM_CHECKBUTTON;
            }
            else
            {
                pvarRole->lVal = ROLE_SYSTEM_OUTLINEITEM;
            }
        }
    }
    else
	{
        pvarRole->lVal = ROLE_SYSTEM_OUTLINE;
	}

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  COutlineView32::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    LPTVITEM    lptvShared;
    HANDLE      hProcess;
    TVITEM      tvLocal;
    DWORD       dwStyle;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accState(varChild, pvarState));

    HTREEITEM htItem = TVItemFromChildID( m_hwnd, varChild.lVal );
    if( htItem == NULL )
    {
        return E_INVALIDARG;
    }

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (MyGetFocus() == m_hwnd)
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

    if( IsClippedByWindow( this, varChild, m_hwnd ) )
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
    }

    lptvShared = TSharedAlloc< TVITEM >( m_hwnd, & hProcess );
    if (!lptvShared)
        return(E_OUTOFMEMORY);

    // (UINT) cast converts plain int to same type as ->mask, which is UINT.
    TSharedWrite( & lptvShared->mask,   (UINT)(TVIF_STATE | TVIF_CHILDREN), hProcess );
    TSharedWrite( & lptvShared->hItem,  htItem,                             hProcess );

    if (TreeView_GetItem(m_hwnd, lptvShared))
    {
        TSharedRead( & tvLocal, lptvShared, hProcess );

        if (tvLocal.state & TVIS_SELECTED)
        {
            pvarState->lVal |= STATE_SYSTEM_SELECTED;
            if (pvarState->lVal & STATE_SYSTEM_FOCUSABLE)
                pvarState->lVal |= STATE_SYSTEM_FOCUSED;
        }

        pvarState->lVal |= STATE_SYSTEM_SELECTABLE;

        if (tvLocal.state & TVIS_DROPHILITED)
            pvarState->lVal |= STATE_SYSTEM_HOTTRACKED;

        //
        // If it isn't expanded and it has children, then it must be
        // collapsed.
        //
        if (tvLocal.state & (TVIS_EXPANDED | TVIS_EXPANDPARTIAL))
            pvarState->lVal |= STATE_SYSTEM_EXPANDED;
        else if (tvLocal.cChildren)
            pvarState->lVal |= STATE_SYSTEM_COLLAPSED;

        // If the treeview has checkboxes, then see if it's checked.
        // State 0 = no checkbox, State 1 = unchecked, State 2 = checked
        dwStyle = GetWindowLong (m_hwnd,GWL_STYLE);
        if ((dwStyle & TVS_CHECKBOXES) &&
            (tvLocal.state & TVIS_STATEIMAGEMASK) == INDEXTOSTATEIMAGEMASK(2))
            pvarState->lVal |= STATE_SYSTEM_CHECKED;


        int aKeys[ TV_IMGIDX_COUNT ];
        if( TVGetImageIndex( m_hwnd, htItem, aKeys ) )
        {
            DWORD dwState;
            if( CheckDWORDMap( m_hwnd, OBJID_CLIENT, CHILDID_SELF,
                               PROPINDEX_STATEMAP,
                               aKeys, ARRAYSIZE( aKeys ), & dwState ) )
            {
                pvarState->lVal |= dwState;
            }
            else if( GetStateFromStateImageMap( m_hwnd, aKeys[ TV_IMGIDX_Image ], & dwState ) )
            {
                pvarState->lVal |= dwState;
            }
        }
    }

    SharedFree(lptvShared,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{
    InitPv(pszDesc);

    if (! ValidateChild(&varChild))
        return E_INVALIDARG;


    if (varChild.lVal)
    {
        HTREEITEM htItem = TVItemFromChildID( m_hwnd, varChild.lVal );
        if( ! htItem )
        {
            return E_INVALIDARG;
        }

        int aKeys[ TV_IMGIDX_COUNT ];
        if( TVGetImageIndex( m_hwnd, htItem, aKeys ) )
        {
            if( CheckStringMap( m_hwnd, OBJID_CLIENT, CHILDID_SELF, PROPINDEX_DESCRIPTIONMAP,
                                aKeys, ARRAYSIZE( aKeys ), pszDesc ) )
            {
                return S_OK;
            }
        }
    }

    return S_FALSE;
}


// --------------------------------------------------------------------------
//
//  COutlineView32::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accFocus(VARIANT* pvarFocus)
{
    HRESULT hr;

    //
    // Do we have the focus?
    //
    hr = CClient::get_accFocus(pvarFocus);
    if (!SUCCEEDED(hr) || (pvarFocus->vt != VT_I4) || (pvarFocus->lVal != 0))
        return hr;

    //
    // We do.  What item is focused?
    //
    return COutlineView32::get_accSelection(pvarFocus);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::get_accSelection()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accSelection(VARIANT* pvarSelection)
{
    InitPvar(pvarSelection);

    HTREEITEM ht = TreeView_GetSelection(m_hwnd);
    if (ht)
    {
        pvarSelection->vt = VT_I4;
        pvarSelection->lVal = ChildIDFromTVItem( m_hwnd, ht );
        if( pvarSelection->lVal == 0 )
            return E_FAIL;
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}



// --------------------------------------------------------------------------
//
//  COutlineView32::get_accDefaultAction()
//
//  The default action of a node with children is:
//      * Expand one level if it is fully collapsed
//      * Collapse if it is partly or completely expanded
//
//  The reason for not expanding fully is that it is slow and there is no
//  keyboard shortcut or mouse click that will do it.  You can use a menu
//  command to do so if you want.
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::get_accDefaultAction(VARIANT varChild, BSTR* pszDefA)
{
    VARIANT varState;
    HRESULT hr;

    InitPv(pszDefA);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accDefaultAction(varChild, pszDefA));

    //
    // Get our state.  NOTE that we will not get back STATE_SYSTEM_COLLAPSED
    // if the item doesn't have children.
    //
    VariantInit(&varState);
    hr = get_accState(varChild, &varState);
    if (!SUCCEEDED(hr))
        return(hr);

    if (varState.lVal & STATE_SYSTEM_EXPANDED)
        return(HrCreateString(STR_TREE_COLLAPSE, pszDefA));
    else if (varState.lVal & STATE_SYSTEM_COLLAPSED)
        return(HrCreateString(STR_TREE_EXPAND, pszDefA));
    else
        return(E_NOT_APPLICABLE);
}


// --------------------------------------------------------------------------
//
//  COutlineView32::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::accSelect(long selFlags, VARIANT varChild)
{
    if (!ValidateChild(&varChild) || !ValidateSelFlags(selFlags))
        return E_INVALIDARG;

    if (!varChild.lVal)
        return CClient::accSelect(selFlags, varChild);

	HTREEITEM htItem = TVItemFromChildID( m_hwnd, varChild.lVal );
	if( htItem == NULL )
	{
		return E_INVALIDARG;
	}

    if (selFlags & SELFLAG_TAKEFOCUS) 
    {
        MySetFocus(m_hwnd);
    }

	if ((selFlags & SELFLAG_TAKEFOCUS) || (selFlags & SELFLAG_TAKESELECTION))
	{
		TreeView_SelectItem(m_hwnd, htItem);
		return S_OK;
	}
	else
	{
		return E_NOT_APPLICABLE;
	}

}



// --------------------------------------------------------------------------
//
//  COutlineView32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    if (!varChild.lVal)
        return CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);

    HTREEITEM htItem = TVItemFromChildID( m_hwnd, varChild.lVal );
    if( htItem == NULL )
    {
        return E_INVALIDARG;
    }

    // Get the listview item rect.
    HANDLE hProcess;
    LPRECT lprcShared = TSharedAlloc< RECT >( m_hwnd, & hProcess );
    if (!lprcShared)
        return E_OUTOFMEMORY;

    // can't use the TreeView_GetItemRect macro, because it does a behind-the-scenes
    // assignment of the item id into the rect, which blows on shared memory.
    // TVM_GETITEMRECT is weird: it's a ptr to a RECT, which, on input, contains
    // the HTREEITEM of the item; on output it contains that item's rect.

    TSharedWrite( (HTREEITEM *)lprcShared, htItem, hProcess);

    if (SendMessage (m_hwnd, TVM_GETITEMRECT, TRUE, (LPARAM)lprcShared))
    {
        RECT rcLocal;
        TSharedRead( & rcLocal, lprcShared, hProcess );

        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcLocal, 2);

        *pxLeft = rcLocal.left;
        *pyTop = rcLocal.top;
        *pcxWidth = rcLocal.right - rcLocal.left;
        *pcyHeight = rcLocal.bottom - rcLocal.top;
    }

    SharedFree(lprcShared,hProcess);

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  COutlineView32::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
	HTREEITEM   htItem;
    HTREEITEM   htNewItem = 0;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir >= NAVDIR_FIRSTCHILD)
    {
        htNewItem = TreeView_GetRoot(m_hwnd);

        if ((dwNavDir == NAVDIR_LASTCHILD) && htNewItem)
        {
            HTREEITEM   htNext;

            // make sure we are at the last root sibling
            htNext = TreeView_GetNextSibling(m_hwnd, htNewItem);
            while (htNext)
            {
                htNewItem = htNext;
                htNext = TreeView_GetNextSibling(m_hwnd, htNewItem);
            }
            
RecurseAgain:
            //
            // Keep recursing down all the way to the last ancestor of the
            // last item under the root.
            //
            htNext = TreeView_GetChild(m_hwnd, htNewItem);
            if (htNext)
            {
                while (htNext)
                {
                    htNewItem = htNext;
                    htNext = TreeView_GetNextSibling(m_hwnd, htNewItem);
                }

                goto RecurseAgain;
            }
        }

        goto AllDone;
    }
    else if (!varStart.lVal)
	{
        return CClient::accNavigate(dwNavDir, varStart, pvarEnd);
	}


	htItem = TVItemFromChildID( m_hwnd, varStart.lVal );
	if( htItem == NULL )
	{
		return E_INVALIDARG;
	}


    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
            // Next logical item, peer or child
            htNewItem = NextLogicalItem(htItem);
            break;

        case NAVDIR_PREVIOUS:
            // Previous logical item, peer or parent
            htNewItem = PrevLogicalItem(htItem);
            break;

        case NAVDIR_UP:
            // Previous sibling!
            htNewItem = TreeView_GetPrevSibling(m_hwnd, htItem);
            break;

        case NAVDIR_DOWN:
            // Next sibling!
            htNewItem = TreeView_GetNextSibling(m_hwnd, htItem);
            break;

        case NAVDIR_LEFT:
            // Get parent!
            htNewItem = TreeView_GetParent(m_hwnd, htItem);
            break;

        case NAVDIR_RIGHT:
            // Get first child!
            htNewItem = TreeView_GetChild(m_hwnd, htItem);
            break;
    }

AllDone:
    if (htNewItem)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = ChildIDFromTVItem( m_hwnd, htNewItem );
        if( pvarEnd->lVal == 0 )
            return E_FAIL;
        
        return S_OK;
    }
    else
	{
        return S_FALSE;
	}
}



// --------------------------------------------------------------------------
//
//  COutlineView32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::accHitTest(long x, long y, VARIANT* pvarHit)
{
    HRESULT         hr;
    LPTVHITTESTINFO lptvhtShared;
    HANDLE          hProcess;
    POINT           ptLocal;

    SetupChildren();
    
    //
    // Is the point in the listview at all?
    //
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0))
        return(hr);

    //
    // Now find out what item this point is on.
    //
    lptvhtShared = TSharedAlloc< TVHITTESTINFO >( m_hwnd, & hProcess );
    if (!lptvhtShared)
        return(E_OUTOFMEMORY);

    // Cast keeps templates happy - NULL on its own is #define'd as 0 and has no type.
    TSharedWrite( & lptvhtShared->hItem, (HTREEITEM)NULL, hProcess );
    
    ptLocal.x = x;
    ptLocal.y = y;
    ScreenToClient(m_hwnd, &ptLocal);

    TSharedWrite( & lptvhtShared->pt, ptLocal, hProcess );

    SendMessage(m_hwnd, TVM_HITTEST, 0, (LPARAM)lptvhtShared);

    HTREEITEM hItem;
    TSharedRead( &hItem, & lptvhtShared->hItem, hProcess );
    SharedFree(lptvhtShared,hProcess);

    if( hItem )
    {
        pvarHit->lVal = ChildIDFromTVItem( m_hwnd, hItem );
        if( pvarHit->lVal == 0 )
            return E_FAIL;
    }
    else
    {
        // if hItem is NULL, then point is over the treeview itself
        pvarHit->lVal = CHILDID_SELF;
    }


    return S_OK;
}



// --------------------------------------------------------------------------
//
//  COutlineView32::accDoDefaultAction()
//
//  This expands collapsed items and collapses expanded items.
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::accDoDefaultAction(VARIANT varChild)
{
    VARIANT varState;
    HRESULT hr;
    UINT    tve;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accDoDefaultAction(varChild));

    //
    // Get the item's state.
    //
    VariantInit(&varState);
    hr = get_accState(varChild, &varState);
    if (!SUCCEEDED(hr))
        return(hr);

    if (varState.lVal & STATE_SYSTEM_COLLAPSED)
        tve = TVE_EXPAND;
    else if (varState.lVal & STATE_SYSTEM_EXPANDED)
        tve = TVE_COLLAPSE;
    else
        return(E_NOT_APPLICABLE);

    PostMessage(m_hwnd, TVM_EXPAND, tve, (LPARAM)varChild.lVal);
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  COutlineView32::Reset()
//
//  Sets the "current" HTREEITEM to NULL so we know we are at the beginning.
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::Reset()
{
    m_idChildCur = 0;
    return S_OK;
}



// --------------------------------------------------------------------------
//
//  COutlineView32::Next()
//
//  We descend into children, among siblings, and back up as necessary.
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::Next(ULONG celt, VARIANT* rgvarFetch, ULONG* pceltFetch)
{
    SetupChildren();

    if (pceltFetch)
        InitPv(pceltFetch);

    HTREEITEM htCur;
    HTREEITEM htNext;
    if( m_idChildCur == 0 )
    {
        htCur = NULL;
        htNext = TreeView_GetRoot(m_hwnd);
    }
    else
    {
        htCur = TVItemFromChildID( m_hwnd, m_idChildCur );
        if( ! htCur )
        {
            return E_FAIL;
        }
        htNext = NextLogicalItem(htCur);
    }

    VARIANT * pvar = rgvarFetch;
    ULONG cFetched = 0;
    while( (cFetched < celt) && htNext )
    {
        htCur = htNext;

        cFetched++;

        pvar->vt = VT_I4;
        pvar->lVal = ChildIDFromTVItem( m_hwnd, htCur );
        if( pvar->lVal == 0 )
            return E_FAIL;
        pvar++;

        htNext = NextLogicalItem(htCur);
    }

    // if htCur is still NULL, then the treeview has 0 items, and
    // m_idChildCur is still 0, at the start of the (empty) list.
    // - safe to leave as is.
    if( htCur )
    {
        m_idChildCur = ChildIDFromTVItem( m_hwnd, htCur );
        if( m_idChildCur == 0 )
            return E_FAIL;
    }

    if (pceltFetch)
        *pceltFetch = cFetched;

    return (cFetched < celt) ? S_FALSE : S_OK;
}



// --------------------------------------------------------------------------
//
//  COutlineView32::Skip()
//
// --------------------------------------------------------------------------
STDMETHODIMP COutlineView32::Skip(ULONG celtSkip)
{
    SetupChildren();

    HTREEITEM htCur;
    HTREEITEM htNext;
    if( m_idChildCur == 0 )
    {
        htCur = NULL;
        htNext = TreeView_GetRoot(m_hwnd);
    }
    else
    {
        htCur = TVItemFromChildID( m_hwnd, m_idChildCur );
        if( ! htCur )
        {
            return E_FAIL;
        }
        htNext = NextLogicalItem(htCur);
    }

    while ((celtSkip > 0) && htNext)
    {
        --celtSkip;

        htCur = htNext;
        htNext = NextLogicalItem(htCur);
    }

    // if htCur is still NULL, then the treeview has 0 items, and
    // m_idChildCur is still 0, at the start of the (empty) list.
    // - safe to leave as is.
    if( htCur )
    {
        m_idChildCur = ChildIDFromTVItem( m_hwnd, htCur );
        if( m_idChildCur == 0 )
            return E_FAIL;
    }

    return htNext ? S_OK : S_FALSE;
}




BOOL TVGetImageIndex( HWND hwnd, HTREEITEM id, int aKeys[ TV_IMGIDX_COUNT ] )
{
    HANDLE  hProcess;
    TVITEM * lptvShared = TSharedAlloc< TVITEM >( hwnd, & hProcess );
    if (!lptvShared)
        return FALSE;

    // (UINT) cast converts plain int to same type as ->mask, which is UINT.
    TSharedWrite( &lptvShared->mask,    (UINT)(TVIF_IMAGE | LVIF_STATE),    hProcess );
    TSharedWrite( &lptvShared->hItem,   id,                                 hProcess );

    BOOL fRet;
    if (TreeView_GetItem(hwnd, lptvShared))
    {
        INT iImage;
        UINT state;
        TSharedRead( & iImage,  & lptvShared->iImage,   hProcess );
        TSharedRead( & state,   & lptvShared->state,    hProcess );

        aKeys[ TV_IMGIDX_Image ]   = iImage;
        aKeys[ TV_IMGIDX_Overlay ] = ( state >> 8 ) & 0x0F;
        aKeys[ TV_IMGIDX_State ]   = ( state >> 12 ) & 0x0F;
        
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }

    SharedFree( lptvShared, hProcess );

    return fRet;
}





// This reads from the process associated with the given
// hwnd, and does the necessary OpenProcess/CloseHandle
// tidyup and checks....
BOOL ReadProcessMemoryHWND( HWND hwnd, void * pSrc, void * pDst, DWORD len )
{
    DWORD idProcess = 0;
    GetWindowThreadProcessId(hwnd, &idProcess);
    if( ! idProcess )
        return FALSE;

    HANDLE hProcess = OpenProcess( PROCESS_VM_READ, FALSE, idProcess );
    if( ! hProcess )
        return FALSE;

    SIZE_T cbActual = 0;
    BOOL retval = ReadProcessMemory( hProcess, pSrc, pDst, len, & cbActual )
            && len == cbActual;

    CloseHandle( hProcess );

    return retval;
}


BOOL GetStateImageMapEnt_SameBitness( HWND hwnd, int iImage, DWORD * pdwState, DWORD * pdwRole )
{
    void * pAddress = (void *) GetProp( hwnd, TEXT("MSAAStateImageMapAddr") );
    if( ! pAddress )
        return FALSE;

    int NumStates = PtrToInt( GetProp( hwnd, TEXT("MSAAStateImageMapCount") ) );
    if( NumStates == 0 )
        return FALSE;

    // <= used since number is a 1-based count, iImage is a 0-based index.
    // If iImage is 0, should be at least one state.
    if( NumStates <= iImage )
        return FALSE;

    // Adjust to iImage into array...
    pAddress = (void*)( (MSAASTATEIMAGEMAPENT*)pAddress + iImage );

    MSAASTATEIMAGEMAPENT ent;
    if( ! ReadProcessMemoryHWND( hwnd, pAddress, & ent, sizeof(ent) ) )
        return FALSE;

    *pdwState = ent.dwState;
    *pdwRole = ent.dwRole;
    return TRUE;
}



BOOL GetStateImageMapEnt( HWND hwnd, int iImage, DWORD * pdwState, DWORD * pdwRole )
{
    // Quick shortcut - if this property isn't present, then don't even bother
    // going further...
    if( ! GetProp( hwnd, TEXT("MSAAStateImageMapCount") ) )
        return FALSE;


	// First determine if hwnd is a process with the same bitness as this DLL
	BOOL fIsSameBitness;
	if (FAILED(SameBitness(hwnd, &fIsSameBitness)))
		return FALSE;	// this case should never happen


    if( fIsSameBitness )
    {
        return GetStateImageMapEnt_SameBitness( hwnd, iImage, pdwState, pdwRole );
    }
    else
    {
		// The server (hwnd) is not the same bitness so get a remote proxy
		// factory object and call GetRoleFromStateImageMap thru it.
		IRemoteProxyFactory *p;
		if (FAILED(GetRemoteProxyFactory(&p)))
        {
			return FALSE;
        }

		HRESULT hr = p->GetStateImageMapEnt(
				          HandleToLong( hwnd )
				        , iImage
				        , pdwState
				        , pdwRole );

        p->Release();

        return hr == S_OK;
	}
}


BOOL GetRoleFromStateImageMap( HWND hwnd, int iImage, DWORD * pdwRole )
{
    DWORD dwState;
    return GetStateImageMapEnt( hwnd, iImage, & dwState, pdwRole );
}

BOOL GetStateFromStateImageMap( HWND hwnd, int iImage, DWORD * pdwState )
{
    DWORD dwRole;
    return GetStateImageMapEnt( hwnd, iImage, pdwState, & dwRole );
}






// These are defined in the latest commctrl.h...
#ifndef TVM_MAPACCIDTOHTREEITEM

#define TVM_MAPACCIDTOHTREEITEM     (TV_FIRST + 42)
#define TreeView_MapAccIDToHTREEITEM(hwnd, id) \
    (HTREEITEM)SNDMSG((hwnd), TVM_MAPACCIDTOHTREEITEM, id, 0)

#define TVM_MAPHTREEITEMTOACCID     (TV_FIRST + 43)
#define TreeView_MapHTREEITEMToAccID(hwnd, htreeitem) \
    (UINT)SNDMSG((hwnd), TVM_MAPHTREEITEMTOACCID, (WPARAM)htreeitem, 0)

#endif



// TODO - need to handle the case where the treeview is 64-bit, the
// client is 32. SendMessage will truncate the retuend HTREEITEM,
// and the 32-bit client has no way of sending a 64-bit value to the
// 64-bit tree anyhow.
// Need to detect that case, and get the 64-bit helper server to help
// out.

// This should work tree-client 32t-32c, 64t-64c and 32t-64c.

HTREEITEM TVItemFromChildID( HWND hwnd, DWORD idChild )
{
    Assert( idChild );
    if( idChild == 0 )
        return NULL;

    HTREEITEM hItem = TreeView_MapAccIDToHTREEITEM( hwnd, idChild );

    if( hItem )
    {
        return hItem;
    }

#ifdef _WIN64
    return NULL;
#else
    // Fallback for older 32-bit comctls that don't implement the mapping
    // message
    return (HTREEITEM) idChild;
#endif

}


DWORD ChildIDFromTVItem( HWND hwnd, HTREEITEM htvi )
{
    Assert( htvi != NULL );
    if( htvi == NULL )
        return 0;

    DWORD dwid = TreeView_MapHTREEITEMToAccID( hwnd, htvi );

    if( dwid != 0 )
    {
        return dwid;
    }

#ifdef _WIN64
    return 0;
#else
    // Fallback for older 32-bit comctls that don't implement the mapping
    // message
    return (DWORD) htvi;
#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\progress.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PROGRESS.H
//
// --------------------------------------------------------------------------

class   CProgressBar :     public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT* pvarRole);
        STDMETHODIMP    get_accValue(VARIANT varChild, BSTR* pszValue);

        CProgressBar(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\propmgr_client.h ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Client
//
//  Property manager / annotation client. Uses the shared memory component 
//  (PropMgr_Mem.*) to read properties directly w/o cross-proc com overhead
//  to the annotation server.
//
//  This is effectively a singleton - Init/Uninit called at startup/shutdown,
//  one method to get properties.
//
// --------------------------------------------------------------------------



// Must be called before any other PropMgrClient_ APIs are used
BOOL PropMgrClient_Init();

// Call at shutdown to release resources
void PropMgrClient_Uninit();

// Checks if there is a live server out there - if not, a client
// can short-circuit getting the key and calling LookupProp.
BOOL PropMgrClient_CheckAlive();

// Look up a property a key.
BOOL PropMgrClient_LookupProp( const BYTE * pKey,
                               DWORD dwKeyLen,
                               PROPINDEX idxProp,
                               VARIANT * pvar );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\propmgr_impl.h ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Impl
//
//  Property manager class
//
// --------------------------------------------------------------------------



// PropMgrImpl.h : Declaration of the CPropMgr

#ifndef __PROPMGR_H_
#define __PROPMGR_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPropMgr

// Internal class CPropMgrImpl does all the real work, CPropMgr just wraps it,
// and provides extra 'convenience' methods which are implemented in terms
// of CPropMgrImpl's core set of methods.

class CPropMgrImpl;

class ATL_NO_VTABLE CPropMgr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPropMgr, &CLSID_AccPropServices>,

    public IAccPropServices
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_PROPMGR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPropMgr)
	COM_INTERFACE_ENTRY(IAccPropServices)
END_COM_MAP()


	CPropMgr();
	~CPropMgr();

    // IAccPropServices

    HRESULT STDMETHODCALLTYPE SetPropValue (
        const BYTE *        pIDString,
        DWORD               dwIDStringLen,

        MSAAPROPID          idProp,
        VARIANT             var
    );


    HRESULT STDMETHODCALLTYPE SetPropServer (
        const BYTE *        pIDString,
        DWORD               dwIDStringLen,

        const MSAAPROPID *  paProps,
        int                 cProps,

        IAccPropServer *    pServer,
        AnnoScope           annoScope
    );


    HRESULT STDMETHODCALLTYPE ClearProps (
        const BYTE *        pIDString,
        DWORD               dwIDStringLen,

        const MSAAPROPID *  paProps,
        int                 cProps
    );

    // Quick OLEACC/HWND-based functionality

    HRESULT STDMETHODCALLTYPE SetHwndProp (
        HWND                hwnd,
        DWORD               idObject,
        DWORD               idChild,
        MSAAPROPID          idProp,
        VARIANT             var
    );

    HRESULT STDMETHODCALLTYPE SetHwndPropStr (
        HWND                hwnd,
        DWORD               idObject,
        DWORD               idChild,
        MSAAPROPID          idProp,
        LPCWSTR             bstr
    );

    HRESULT STDMETHODCALLTYPE SetHwndPropServer (
        HWND                hwnd,
        DWORD               idObject,
        DWORD               idChild,

        const MSAAPROPID *  paProps,
        int                 cProps,

        IAccPropServer *    pServer,
        AnnoScope           annoScope
    );

    HRESULT STDMETHODCALLTYPE ClearHwndProps (
        HWND                hwnd,
        DWORD               idObject,
        DWORD               idChild,

        const MSAAPROPID *  paProps,
        int                 cProps
    );



    // Methods for composing/decomposing a HWND based IdentityString...

    HRESULT STDMETHODCALLTYPE ComposeHwndIdentityString (
        HWND                hwnd,
        DWORD               idObject,
        DWORD               idChild,

        BYTE **             ppIDString,
        DWORD *             pdwIDStringLen
    );


    HRESULT STDMETHODCALLTYPE DecomposeHwndIdentityString (
        const BYTE *        pIDString,
        DWORD               dwIDStringLen,

        HWND *              phwnd,
        DWORD *             pidObject,
        DWORD *             pidChild
    );


    // Quick OLEACC/HMENU-based functionality

    HRESULT STDMETHODCALLTYPE SetHmenuProp (
        HMENU               hmenu,
        DWORD               idChild,
        MSAAPROPID          idProp,
        VARIANT             var
    );

    HRESULT STDMETHODCALLTYPE SetHmenuPropStr (
        HMENU               hmenu,
        DWORD               idChild,
        MSAAPROPID          idProp,
        LPCWSTR             bstr
    );

    HRESULT STDMETHODCALLTYPE SetHmenuPropServer (
        HMENU               hmenu,
        DWORD               idChild,

        const MSAAPROPID *  paProps,
        int                 cProps,

        IAccPropServer *    pServer,
        AnnoScope           annoScope
    );

    HRESULT STDMETHODCALLTYPE ClearHmenuProps (
        HMENU               hmenu,
        DWORD               idChild,

        const MSAAPROPID *  paProps,
        int                 cProps
    );

    // Methods for composing/decomposing a HMENU based IdentityString...

    HRESULT STDMETHODCALLTYPE ComposeHmenuIdentityString (
        HMENU               hmenu,
        DWORD               idChild,

        BYTE **             ppIDString,
        DWORD *             pdwIDStringLen
    );

    HRESULT STDMETHODCALLTYPE DecomposeHmenuIdentityString (
        const BYTE *        pIDString,
        DWORD               dwIDStringLen,

        HMENU *             phmenu,
        DWORD *             pidChild
    );


private:

    CPropMgrImpl *          m_pMgrImpl;
};




void PropMgrImpl_Uninit();


#endif //__PROPMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\propmgr_impl.cpp ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Impl
//
//  Property manager server class
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"


#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>


#include "PropMgr_Util.h"
#include "PropMgr_Impl.h"
#include "PropMgr_Mem.h"

#pragma warning(push, 3)
#pragma warning(disable: 4530)
#include <map>
#include <vector>
#pragma warning(pop) 


#include "debug.h"


/*
 
Format of item record:

    * size prefix

    * 'Properties present' bitmask
      Indicates that the property is present for this key

    * 'Property is a variant' bitmask
      For present properties, indicates whether the property is a VARIANT
      versus an object reference.

    * 'Property has container scope' bitmask
      Indicates that the property applies to this key, and to all that element's
      simple children.


    * Property data: For each property which is present (see 'property present'
      bitmask), there is:
      
        either 


        * a serialized VARIANT

        or

        * a serialized/marshalled callback object reference (IAccPropServer)


        - depending on whether the 'property is variant' bitmask is set for this property.




Variants are serialized as a leading SHORT indicating the type (VT_???), followed by:
    DWORD for I4s,
    DWORD length followed by unicode chars for BSTR

A marshalled callback reference is serialized as:
    DWORD for length of marshalled data,
    BYTEs of the marshalled data.



*/















BOOL IsKeyAlive( const BYTE * pKeyData, DWORD dwKeyLen )
{
    // For the moment, assume it uses either the HWND or HMENU naming scheme.
    // (Later on, if we extend this to allow pluggable namespaces, we'd use something
    // like IAccNamespace::IsKeyAlive() instead.)

    HWND hwnd;
    if( DecodeHwndKey( pKeyData, dwKeyLen, & hwnd, NULL, NULL ) )
    {
        return IsWindow( hwnd );
    }

    HMENU hmenu;
    if( DecodeHmenuKey( pKeyData, dwKeyLen, NULL, & hmenu, NULL ) )
    {
        return IsMenu( hmenu );
    }

    Assert( FALSE );
    return FALSE;
}



// This is a reference to a key (aka id string) - it does not own or contain
// the key.
//
// When used in the object map, (which contains {AccObjKeyRef, AccInfo*} pairs),
// m_pKeyData points to the key data in the corresponding AccInfo. This object
// and the corresponding AccInfo have identical lifetimes.
//
// In other cases - for example, when used as a value to look up in the map -
// m_pKeyData points to an already existing key string - possibly the id string
// specified by the caller of one of the IAccPropServer methods. In this usage,
// the AccObjKeyRef is really being used as a temporary adapter to allow the
// existing string to be used to look up a value in the map.
class AccObjKeyRef
{
    const BYTE *  m_pKeyData;
    DWORD         m_dwKeyLen;

    // Disable default ctor
    AccObjKeyRef();

public:

    // copy ctor
    AccObjKeyRef( const BYTE * pKeyData, DWORD dwKeyLen )
        : m_pKeyData( pKeyData ),
          m_dwKeyLen( dwKeyLen ) 
    {
    }

    // use default member-wise assignment

    
    // Comparisons - used in map lookup

    bool operator < ( const AccObjKeyRef & x ) const
    {
        if( m_dwKeyLen != x.m_dwKeyLen )
            return m_dwKeyLen < x.m_dwKeyLen;

        return memcmp( m_pKeyData, x.m_pKeyData, m_dwKeyLen ) < 0;
    }

    bool operator == ( const AccObjKeyRef & x ) const
    {
        if( m_dwKeyLen != x.m_dwKeyLen )
            return false;

        return memcmp( m_pKeyData, x.m_pKeyData, m_dwKeyLen ) == 0;
    }

    bool operator != ( const AccObjKeyRef & x ) const
    {
        return ! operator == ( x );
    }
};








struct AccInfo
{
private:

    // disable copy ctor
    AccInfo( const AccInfo & x );

private:

    struct PropInfo
    {
        union {
            VARIANT             m_var;

            struct
            {
                BYTE *      m_pMarshalData;
                DWORD       m_dwMarshalDataLen;
            } m_ServerInfo;
        };
    };


    BYTE *      m_pKeyData;
    DWORD       m_dwKeyLen;


    DWORD       m_fPropInUseBits; 
    DWORD       m_fPropIsVariantBits;   // 1-bit indicates the property is VARIANT - otherwise it's a IAccPropServer
    DWORD       m_fContainerScopeBits;  // 1-bit indicates that the property is a IAccPropServer, and should also
                                        // be used for the children of this node. (annoScope was CONTAINER).

    PropInfo    m_Props[ NUMPROPS ];


    HWND        m_hwndProp;
    LPTSTR      m_pKeyString;

    BYTE *      m_pBlob;


public:

    AccInfo()
    {
        m_fPropInUseBits = 0;
        m_fPropIsVariantBits = 0;
        m_fContainerScopeBits = 0;
        m_pKeyString = NULL;
        m_hwndProp = NULL;
        m_pBlob = NULL;
    }


    ~AccInfo()
    {
        ClearBlob();

        for( int i = 0 ; i < NUMPROPS ; i++ )
        {
            ClearProp( i );
        }

        delete [ ] m_pKeyData;
        delete [ ] m_pKeyString;
    }


    BOOL Init( const BYTE * pKeyData, DWORD dwKeyLen, HWND hwndProp )
    {
        m_pKeyData = new BYTE [ dwKeyLen ];
        if( ! m_pKeyData )
        {
            TraceError( TEXT("AccInfo::Init: new returned NULL") );
            return FALSE;
        }
        memcpy( m_pKeyData, pKeyData, dwKeyLen );
        m_dwKeyLen = dwKeyLen;

        m_pKeyString = MakeKeyString( pKeyData, dwKeyLen );

        m_hwndProp = hwndProp;

        return TRUE;
    }

    const AccObjKeyRef GetKeyRef()
    {
        return AccObjKeyRef( m_pKeyData, m_dwKeyLen );
    }


	BOOL SetPropValue (
		int             iProp,
		VARIANT *		pvarValue )
    {
        ClearProp( iProp );

        SetBit( & m_fPropIsVariantBits, iProp );
        SetBit( & m_fPropInUseBits, iProp );
        ClearBit( & m_fContainerScopeBits, iProp );
        m_Props[ iProp ].m_var.vt = VT_EMPTY;

        // We'll accept any type here. It's up to the caller of this to enforce
        // any property-vs-type policies (eg. only allow I4's for ROLE, etc.)
        VariantCopy( & m_Props[ iProp ].m_var, pvarValue );

        return TRUE;
    }


    BOOL SetPropServer (
        int                 iProp,
        const BYTE *        pMarshalData,
        int                 dwMarshalDataLen,
        AnnoScope           annoScope )
    {
        if( dwMarshalDataLen == 0 )
        {
            TraceError( TEXT("AccInfo::SetPropServer: dwMarshalDataLen param = 0") );
            return FALSE;
        }

        BYTE * pCopyData = new BYTE [ dwMarshalDataLen ];
        if( ! pCopyData )
        {
            TraceError( TEXT("AccInfo::SetPropServer: new returned NULL") );
            return FALSE;
        }

        ClearProp( iProp );

        ClearBit( & m_fPropIsVariantBits, iProp );
        SetBit( & m_fPropInUseBits, iProp );

        if( annoScope == ANNO_CONTAINER )
        {
            SetBit( & m_fContainerScopeBits, iProp );
        }
        else
        {
            ClearBit( & m_fContainerScopeBits, iProp );
        }

        m_Props[ iProp ].m_ServerInfo.m_dwMarshalDataLen = dwMarshalDataLen;
        memcpy( pCopyData, pMarshalData, dwMarshalDataLen );
        m_Props[ iProp ].m_ServerInfo.m_pMarshalData = pCopyData;

        return TRUE;
    }
  


    void ClearProp( int i )
    {
        // Does this property need to be cleared?
        if( IsBitSet( m_fPropInUseBits, i ) )
        {
            // Is it a simple variant, or a callback reference?
            if( IsBitSet( m_fPropIsVariantBits, i ) )
            {
                // Simple variant...
                VariantClear( & m_Props[ i ].m_var );
            }
            else
            {
                BYTE * pMarshalData = m_Props[ i ].m_ServerInfo.m_pMarshalData;
                DWORD dwMarshalDataLen = m_Props[ i ].m_ServerInfo.m_dwMarshalDataLen;

                // Callback reference...
                Assert( dwMarshalDataLen );
                if( dwMarshalDataLen && pMarshalData )
                {
                    // This releases the object reference, byt we have to delete the buffer
                    // ourselves...
                    ReleaseMarshallData( pMarshalData, dwMarshalDataLen );

                    delete [ ] pMarshalData;
                    m_Props[ i ].m_ServerInfo.m_pMarshalData = NULL;
                    m_Props[ i ].m_ServerInfo.m_dwMarshalDataLen = 0;
                }
            }

            ClearBit( & m_fPropInUseBits, i );
        }
    }

    BOOL IsEmpty()
    {
        return m_fPropInUseBits == 0;
    }


    BOOL Alive()
    {
        return IsKeyAlive( m_pKeyData, m_dwKeyLen );
    }


    BOOL Sync()
    {
        return UpdateBlob();
    }


private:


    BYTE * AllocBlob( SIZE_T cbSize )
    {
        return (BYTE *) Alloc_32BitCompatible( cbSize );
    }

    void DeallocBlob( BYTE * pBlob )
    {
        Free_32BitCompatible( pBlob );
    }



    void ClearBlob()
    {
        if( m_pBlob )
        {
            RemoveProp( m_hwndProp, m_pKeyString );
            DeallocBlob( m_pBlob );
            m_pBlob = NULL;
        }
    }

    BOOL UpdateBlob()
    {
        BYTE * pOldBlob = m_pBlob;
        BYTE * pNewBlob = CalcBlob();


        // We always update - even if pNewblob is NULL (ie. Calc failed)...
        if( pNewBlob )
        {
            SetProp( m_hwndProp, m_pKeyString, pNewBlob );
        }
        else
        {
            RemoveProp( m_hwndProp, m_pKeyString );
        }

        if( pOldBlob )
        {
            DeallocBlob( pOldBlob );
        }

        m_pBlob = pNewBlob;

        return TRUE;
    }

    BYTE * CalcBlob()
    {
        // If there are no properties being used, then we don't need anything at all.
        if( ! m_fPropInUseBits )
        {
            return NULL;
        }

        // First, measure how much space we need...
        
        // three constants...
        SIZE_T dwSize = sizeof( DWORD ) * 4; // size header, m_fPropInUseBits, m_fPropIsVariantBits, m_fContainerScopeBits
        
        // for each present property...
        for( int i = 0 ; i < NUMPROPS ; i++ )
        {
            if( IsBitSet( m_fPropInUseBits, i ) )
            {
                if( IsBitSet( m_fPropIsVariantBits, i ) )
                {
                    MemStreamMeasure_VARIANT( & dwSize, m_Props[ i ].m_var );
                }
                else
                {
                    MemStreamMeasure_DWORD( & dwSize );
                    MemStreamMeasure_Binary( & dwSize, m_Props[ i ].m_ServerInfo.m_dwMarshalDataLen );
                }
            }
        }

        // Now allocate space...
        BYTE * pBlob = AllocBlob( dwSize );
        if( ! pBlob )
        {
            TraceError( TEXT("AccInfo::CalcBloc: AllocBlob returned NULL") );
            return NULL;
        }

        // Finally write the data to the allocated space...

        MemStream p( pBlob, dwSize );

        MemStreamWrite_DWORD( p, (DWORD) dwSize );
        MemStreamWrite_DWORD( p, m_fPropInUseBits );
        MemStreamWrite_DWORD( p, m_fPropIsVariantBits );
        MemStreamWrite_DWORD( p, m_fContainerScopeBits );

        for( int j = 0 ; j < NUMPROPS ; j++ )
        {
            if( IsBitSet( m_fPropInUseBits, j ) )
            {
                if( IsBitSet( m_fPropIsVariantBits, j ) )
                {
                    MemStreamWrite_VARIANT( p, m_Props[ j ].m_var );
                }
                else
                {
                    MemStreamWrite_DWORD( p, m_Props[ j ].m_ServerInfo.m_dwMarshalDataLen );
                    MemStreamWrite_Binary( p, m_Props[ j ].m_ServerInfo.m_pMarshalData, m_Props[ j ].m_ServerInfo.m_dwMarshalDataLen );
                }
            }
        }
        // If we later decide to allow any GUIDs (other than the well-known ones which have indices) as props,
        // we could add them here as GUID/VARIANT pairs.

        return pBlob;
    }


};


#define HWND_MESSAGE     ((HWND)-3)

typedef std::map< AccObjKeyRef, AccInfo * > AccInfoMapType;




class CPropMgrImpl
{

    AccInfoMapType      m_Map;

    BOOL                m_fSelfLocked;

    HWND                m_hwnd;

    int                 m_ref;

    static
    CPropMgrImpl * s_pThePropMgrImpl;

    friend void PropMgrImpl_Uninit();

public:

    CPropMgrImpl()
        : m_fSelfLocked( FALSE ),
          m_hwnd( NULL ),
          m_ref( 1 )
    {
        _Module.Lock();
    }

    BOOL Init()
    {
        TCHAR szWindowName[ 32 ];
        wsprintf( szWindowName, TEXT("MSAA_DA_%lx"), GetCurrentProcessId() );

        WNDCLASS wc;

        wc.style = 0;
        wc.lpfnWndProc = StaticWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = _Module.GetModuleInstance();
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
        wc.lpszMenuName = NULL;
        wc.lpszClassName = TEXT("MSAA_DA_Class");

        RegisterClass( & wc );

        CreateWindow( TEXT("MSAA_DA_Class"),
                      szWindowName,
                      0,
                      0, 0, 128, 128,
                      NULL, NULL, _Module.GetModuleInstance(), this );

        // Make this a message only window.  We don't care if it fails, win9x case.
        SetParent( m_hwnd, HWND_MESSAGE );

        SetTimer( m_hwnd, 1, 5 * 1000, NULL );

        return TRUE;
    }

    ~CPropMgrImpl()
    {
        s_pThePropMgrImpl = NULL;

        KillTimer( NULL, 1 );

        if( m_hwnd )
        {
            SetWindowLongPtr( m_hwnd, GWLP_USERDATA, NULL );
            DestroyWindow( m_hwnd );
        }

        _Module.Unlock();
    }


    void AddRef()
    {
        m_ref++;
    }

    void Release()
    {
        m_ref--;
        if( m_ref == 0 )
        {
            delete this;
        }
    }


    static
    CPropMgrImpl * GetThePropMgrImpl()
    {
        if( ! s_pThePropMgrImpl )
        {
            s_pThePropMgrImpl = new CPropMgrImpl();
            if( ! s_pThePropMgrImpl )
            {
                TraceError( TEXT("CPropMgrImpl::GetThePropMgrImpl: new returned NULL") );
                return NULL;
            }

            if( ! s_pThePropMgrImpl->Init() )
            {
                delete s_pThePropMgrImpl;
                s_pThePropMgrImpl = NULL;
                TraceError( TEXT("CPropMgrImpl::GetThePropMgrImpl: s_pThePropMgrImpl->Init() returned FALSE") );
                return NULL;
            }
        }
        else
        {
            // We only addref the second and subsequent times that we
            // hand out a pointer.
            // The first time, we use the ref the the object had when it
            // was created.
            // (This static ptr s_pThePropMgrImpl is a weak reference.)
            s_pThePropMgrImpl->AddRef();
        }

        return s_pThePropMgrImpl;
    }




    void Clean()
    {
        // Go through the elements in the map...

        for( AccInfoMapType::iterator i = m_Map.begin() ; i != m_Map.end() ; )
        {
            // check if the key is still valid...
            if( ! i->second->Alive() )
            {
                AccInfoMapType::iterator t = i;
                i++;

                AccInfo * pInfo = t->second;
                m_Map.erase( t );

                delete pInfo;
            }
            else
            {
                i++;
            }
        }

        // Unload if necessary
        CheckRef();
    }

    void ClearAll()
    {
        for( AccInfoMapType::iterator i = m_Map.begin() ; i != m_Map.end() ; )
        {
            AccInfoMapType::iterator t = i;
            i++;

            AccInfo * pInfo = t->second;
            m_Map.erase( t );

            delete pInfo;
        }

        // Unload if necessary
        CheckRef();
    }


    void CheckRef()
    {
        if( m_Map.empty() )
        {
            if( m_fSelfLocked )
            {
                m_fSelfLocked = FALSE;
                Release();
            }
        }
        else
        {
            if( ! m_fSelfLocked )
            {
                m_fSelfLocked = TRUE;
                AddRef();
            }
        }
    }


    AccInfo * LookupKey( const BYTE * pKeyData, DWORD dwKeyLen, BOOL fCreate )
    {
        AccInfoMapType::iterator i;

        AccObjKeyRef keyref( pKeyData, dwKeyLen );
    
        i = m_Map.find( keyref );

        if( i == m_Map.end() || i->first != keyref )
        {
            // insert...
            if( fCreate )
            {
                AccInfo * pInfo = new AccInfo;
                if( ! pInfo )
                {
                    TraceError( TEXT("CPropMgrImpl::LookupKey: new returned NULL") );
                    return NULL;
                }

                // If the key is associated with a HWND, use that; otherwise attach the key to our own window.
                HWND hwndProp;
                if( ! DecodeHwndKey( pKeyData, dwKeyLen, & hwndProp, NULL, NULL ) )
                {
                    hwndProp = m_hwnd;
                }

                pInfo->Init( pKeyData, dwKeyLen, hwndProp );

                m_Map.insert( std::make_pair( pInfo->GetKeyRef(), pInfo ) );

                // make sure we're locked...
                CheckRef();

                return pInfo;
            }
            else
            {
                return NULL;
            }
        }
        else
        {
            return i->second;
        }
    }

    void RemoveEntry( AccInfo * pInfo )
    {
        m_Map.erase( pInfo->GetKeyRef() );

        // if we're empty, we can unlock the module...
        CheckRef();
    }


    HRESULT ValidateArray( const void * pvStart, int cLen, int elsize, LPCTSTR pMethodName, LPCTSTR pPtrName, LPCTSTR pLenName )
    {
        // Parameter checking...

        if( ! pvStart )
        {
            TraceParam( TEXT("%s: %s is NULL"), pMethodName, pPtrName );
            return E_POINTER;
        }
        if( cLen <= 0 )
        {
            TraceParam( TEXT("%s: %s is <= 0"), pMethodName, pLenName );
            return E_INVALIDARG;
        }
        if( IsBadReadPtr( pvStart, cLen * elsize ) )
        {
            TraceParam( TEXT("%s: %s/%s points to non-readable memory"), pMethodName, pPtrName, pLenName );
            return E_POINTER;
        }

        return S_OK;
    }



    HRESULT SetPropValue( const BYTE * pKeyData,
                          DWORD dwKeyLen,
                          MSAAPROPID   idProp,
                          VARIANT *    pvarValue )
    {
        // Parameter checking...

        HRESULT hr = ValidateArray( pKeyData, dwKeyLen, sizeof(BYTE), TEXT("SetPropValue"), TEXT("pKeyData"), TEXT("dwKeyLen") );
        if( hr != S_OK )
            return hr;

        if( pvarValue == NULL )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: pvarValue is NULL") );
            return E_POINTER;
        }



        AccInfo * pInfo = LookupKey( pKeyData, dwKeyLen, TRUE );
        Assert( pInfo );
        if( ! pInfo )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: key not found") );
            return E_INVALIDARG;
        }

        int idxProp = IndexFromProp( idProp );
        if( idxProp == -1 )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: unknown prop") );
            return E_INVALIDARG;
        }

        // check type...
        if( pvarValue->vt != g_PropInfo[ idxProp ].m_Type )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: incorrect type for property") );
            return E_INVALIDARG;
        }

        // Do we support setting this property directly?
        // (Some can be returned via callbacks only, not set directly)
        if( ! g_PropInfo[ idxProp ].m_fSupportSetValue )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: prop does not support direct set") );
            return E_INVALIDARG;
        }

        if( ! pInfo->SetPropValue( idxProp, pvarValue ) )
        {
            return E_FAIL;
        }

        pInfo->Sync();

        return S_OK;
    }


    HRESULT ClearProps( const BYTE * pKeyData,
                        DWORD dwKeyLen,
                        const MSAAPROPID *  paProps,
                        int                 cProps )
    {
        // Parameter checking...

        HRESULT hr = ValidateArray( pKeyData, dwKeyLen, sizeof(BYTE), TEXT("ClearProps"), TEXT("pKeyData"), TEXT("dwKeyLen") );
        if( hr != S_OK )
            return hr;

        hr = ValidateArray( paProps, cProps, sizeof(MSAAPROPID), TEXT("ClearProps"), TEXT("paProps"), TEXT("cProps") );
        if( hr != S_OK )
            return hr;



        AccInfo * pInfo = LookupKey( pKeyData, dwKeyLen, FALSE );
        Assert( pInfo );
        if( ! pInfo )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: key not found") );
            return E_INVALIDARG;
        }

        BOOL fUnknownProp = FALSE;

        for( int i = 0 ; i < cProps ; i++ )
        {
            int idxProp = IndexFromProp( paProps[ i ] );
            if( idxProp == -1 )
            {
                TraceParam( TEXT("CPropMgrImpl::ClearProps: unknown prop") );
                fUnknownProp = TRUE;
                // Continue and clear the other props that we do recognize...
            }
            else
            {
                pInfo->ClearProp( idxProp );
            }
        }

        pInfo->Sync();

        if( pInfo->IsEmpty() )
        {
            RemoveEntry( pInfo );
        }

        return fUnknownProp ? E_INVALIDARG : S_OK;
    }


    HRESULT SetPropServer( const BYTE *         pKeyData,
                           DWORD                dwKeyLen,

                           const MSAAPROPID *   paProps,
                           int                  cProps,

                           const BYTE *         pMarshalData,
                           int                  dwMarshalDataLen,

                           AnnoScope            annoScope )
    {

        // Parameter checking...

        HRESULT hr = ValidateArray( pKeyData, dwKeyLen, sizeof(BYTE), TEXT("SetPropServer"), TEXT("pKeyData"), TEXT("dwKeyLen") );
        if( hr != S_OK )
            return hr;

        hr = ValidateArray( paProps, cProps, sizeof(MSAAPROPID), TEXT("SetPropServer"), TEXT("paProps"), TEXT("cProps") );
        if( hr != S_OK )
            return hr;


        AccInfo * pInfo = LookupKey( pKeyData, dwKeyLen, TRUE );
        Assert( pInfo );
        if( ! pInfo )
        {
            TraceParam( TEXT("CPropMgrImpl::SetPropValue: key not found") );
            return E_INVALIDARG;
        }

        // TODO - make this two-pass - validate props first,
        // add them later - to make this atomic.
        // (either all or none of the props should be registered)
        for( int i = 0 ; i < cProps ; i++ )
        {
            int idxProp = IndexFromProp( paProps[ i ] );
            if( idxProp == -1 )
            {
                TraceParam( TEXT("CPropMgrImpl::SetPropServer: unknown prop") );
                return E_INVALIDARG;
            }

            if( ! pInfo->SetPropServer( idxProp, pMarshalData, dwMarshalDataLen, annoScope ) )
            {
                return E_FAIL;
            }
        }

        pInfo->Sync();

        return S_OK;
    }


    LRESULT WndProc( HWND hwnd,
                     UINT uMsg,
                     WPARAM wParam,
                     LPARAM lParam )
    {
        if( uMsg == WM_TIMER )
        {
            Clean();
        }

        return DefWindowProc( hwnd, uMsg, wParam, lParam );
    }

    static
    LRESULT CALLBACK StaticWndProc( HWND hwnd,
                                    UINT uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam )
    {
        CPropMgrImpl * pThis = (CPropMgrImpl *) GetWindowLongPtr( hwnd, GWLP_USERDATA );
        if( pThis )
        {
            return pThis->WndProc( hwnd, uMsg, wParam, lParam );
        }
        else if( uMsg == WM_NCCREATE )
        {
            LPCREATESTRUCT lpcs = (LPCREATESTRUCT) lParam;
            pThis = (CPropMgrImpl *)lpcs->lpCreateParams;
            SetWindowLongPtr( hwnd, GWLP_USERDATA, (DWORD_PTR) pThis );
            pThis->m_hwnd = hwnd;
            return pThis->WndProc( hwnd, uMsg, wParam, lParam );
        }

        return DefWindowProc( hwnd, uMsg, wParam, lParam );
    }

};



CPropMgrImpl * CPropMgrImpl::s_pThePropMgrImpl = NULL;






// If all annotated windows disappear before the app shuts down, or if all
// annotations are cleared, then everything gets cleaned up nicely.
//
// However, if CoUninitialize is called while controls are still annotated,
// we will need to explicitly clean up before COM unloads our dll.
//
// (If we don't, then (a) we leak memory, and (b) the DA window will
// still receive WM_TIMER messages to a wndproc that has been unloaded
// causin ga fault.)
//
// This is called from DLLMain's PROCESS_DETACH.

void PropMgrImpl_Uninit()
{
    // Check if there is a Mgr in the first place...
    CPropMgrImpl * pTheMgr = CPropMgrImpl::s_pThePropMgrImpl;

    // No mgr - nothing to clean up.
    if( ! pTheMgr )
        return;

    // AddRef it, to keep it alive while we're using it.
    pTheMgr->AddRef();

    // Clear all properties
    pTheMgr->ClearAll();

    // This release will cause the mgr to delete itself, since it is now empty.
    pTheMgr->Release();
}






CPropMgr::CPropMgr()
{
    IMETHOD( TEXT("CPropMgr::CPropMgr") );

    m_pMgrImpl = CPropMgrImpl::GetThePropMgrImpl();
    if( ! m_pMgrImpl )
    {
        TraceError( TEXT("CPropMgr::CPropMgr: CPropMgrImpl::GetThePropMgrImpl returned NULL") );
    }
}


CPropMgr::~CPropMgr()
{
    IMETHOD( TEXT("CPropMgr::~CPropMgr") );

    if( m_pMgrImpl )
    {
        m_pMgrImpl->Release();
    }
}



HRESULT STDMETHODCALLTYPE
CPropMgr::SetPropValue (
    const BYTE *        pIDString,
    DWORD               dwIDStringLen,

    MSAAPROPID          idProp,
    VARIANT             var
)
{
    IMETHOD( TEXT("CPropMgr::SetPropValue") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    return m_pMgrImpl->SetPropValue( pIDString, dwIDStringLen, idProp, & var );
}



HRESULT STDMETHODCALLTYPE
CPropMgr::SetPropServer (
    const BYTE *        pIDString,
    DWORD               dwIDStringLen,

    const MSAAPROPID *  paProps,
    int                 cProps,

    IAccPropServer *    pServer,
    AnnoScope           annoScope
)
{
    IMETHOD( TEXT("CPropMgr::SetPropServer"), TEXT("cProps=%d"), cProps );

    if( ! m_pMgrImpl )
        return E_FAIL;


    const BYTE * pData;
    DWORD dwDataLen;
    MarshalState mstate;

    // We use strong table marshalling to keep the object alive until we free it.
    // (Ownership is actually transferred to the property manager, which will release it when
    // either the property is cleared explicity, or after the HWND dies and it gets swept away.)
    HRESULT hr = MarshalInterface( IID_IAccPropServer, pServer, MSHCTX_LOCAL, MSHLFLAGS_TABLESTRONG,
                                   & pData, & dwDataLen, & mstate );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("CPropMgr::SetPropServer: MarshalInterface failed") );
        return hr;
    }


    hr = m_pMgrImpl->SetPropServer( pIDString, dwIDStringLen, paProps, cProps, pData, dwDataLen, annoScope );

    MarshalInterfaceDone( & mstate );

    return hr;
}



HRESULT STDMETHODCALLTYPE
CPropMgr::ClearProps (
    const BYTE *        pIDString,
    DWORD               dwIDStringLen,

    const MSAAPROPID *  paProps,
    int                 cProps
)
{
    IMETHOD( TEXT("CPropMgr::ClearProps"), TEXT("cProps=%d"), cProps );

    if( ! m_pMgrImpl )
        return E_FAIL;

    return m_pMgrImpl->ClearProps( pIDString, dwIDStringLen, paProps, cProps );
}


// Quick OLEACC/HWND-based functionality

HRESULT STDMETHODCALLTYPE
CPropMgr::SetHwndProp (
    HWND                hwnd,
    DWORD               idObject,
    DWORD               idChild,
    MSAAPROPID          idProp,
    VARIANT             var
)
{
    IMETHOD( TEXT("CPropMgr::SetHwndProp") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    BYTE HwndKey [ HWNDKEYSIZE ];
    MakeHwndKey( HwndKey, hwnd, idObject, idChild );

    return m_pMgrImpl->SetPropValue( HwndKey, HWNDKEYSIZE, idProp, & var );
}


HRESULT STDMETHODCALLTYPE
CPropMgr::SetHwndPropStr (
    HWND                hwnd,
    DWORD               idObject,
    DWORD               idChild,
    MSAAPROPID          idProp,
    LPCWSTR             str
)
{
    IMETHOD( TEXT("CPropMgr::SetHwndPropStr") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    // Need to convert the LPCWSTR to a BSTR before we can put it into a variant...
    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString( str );
    if( ! var.bstrVal )
    {
        TraceError( TEXT("CPropMgr::SetHwndPropStr: SysAllocString failed") );
        return E_OUTOFMEMORY;
    }

    BYTE HwndKey [ HWNDKEYSIZE ];
    MakeHwndKey( HwndKey, hwnd, idObject, idChild );
    
    HRESULT hr = m_pMgrImpl->SetPropValue( HwndKey, HWNDKEYSIZE, idProp, & var );
    SysFreeString( var.bstrVal );
    return hr;
}




HRESULT STDMETHODCALLTYPE
CPropMgr::SetHwndPropServer (
    HWND                hwnd,
    DWORD               idObject,
    DWORD               idChild,

    const MSAAPROPID *  paProps,
    int                 cProps,

    IAccPropServer *    pServer,
    AnnoScope           annoScope
)
{
    IMETHOD( TEXT("CPropMgr::SetHwndPropServer") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    BYTE HwndKey [ HWNDKEYSIZE ];
    MakeHwndKey( HwndKey, hwnd, idObject, idChild );

    return SetPropServer( HwndKey, HWNDKEYSIZE, paProps, cProps, pServer, annoScope );
}

HRESULT STDMETHODCALLTYPE
CPropMgr::ClearHwndProps (
    HWND                hwnd,
    DWORD               idObject,
    DWORD               idChild,

    const MSAAPROPID *  paProps,
    int                 cProps
)
{
    IMETHOD( TEXT("CPropMgr::ClearHwndProps") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    BYTE HwndKey [ HWNDKEYSIZE ];
    MakeHwndKey( HwndKey, hwnd, idObject, idChild );

    return ClearProps( HwndKey, HWNDKEYSIZE, paProps, cProps );
}



// Methods for composing/decomposing a HWND-based key...

HRESULT STDMETHODCALLTYPE
CPropMgr::ComposeHwndIdentityString (
    HWND                hwnd,
    DWORD               idObject,
    DWORD               idChild,

    BYTE **             ppIDString,
    DWORD *             pdwIDStringLen
)
{
    IMETHOD( TEXT("CPropMgr::ComposeHwndIdentityString") );

    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    BYTE * pKeyData = (BYTE *)CoTaskMemAlloc( HWNDKEYSIZE );
    if( ! pKeyData )
    {
        TraceError( TEXT("CPropMgr::ComposeHwndIdentityString: CoTaskMemAlloc failed") );
        return E_OUTOFMEMORY;
    }

    MakeHwndKey( pKeyData, hwnd, idObject, idChild );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HWNDKEYSIZE;

    return S_OK;
}



HRESULT STDMETHODCALLTYPE
CPropMgr::DecomposeHwndIdentityString (
    const BYTE *        pIDString,
    DWORD               dwIDStringLen,

    HWND *              phwnd,
    DWORD *             pidObject,
    DWORD *             pidChild
)
{
    IMETHOD( TEXT("CPropMgr::DecomposeHwndIdentityString") );

    if( ! DecodeHwndKey( pIDString, dwIDStringLen, phwnd, pidObject, pidChild ) )
    {
        TraceParam( TEXT("CPropMgr::DecomposeHwndIdentityString: not a valid HWND id string") );
        return E_INVALIDARG;
    }

    return S_OK;
}



// Quick OLEACC/HMENU-based functionality

HRESULT STDMETHODCALLTYPE
CPropMgr::SetHmenuProp (
    HMENU               hmenu,
    DWORD               idChild,
    MSAAPROPID          idProp,
    VARIANT             var
)
{
    IMETHOD( TEXT("CPropMgr::SetHmenuProp") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    BYTE HmenuKey [ HMENUKEYSIZE ];
    MakeHmenuKey( HmenuKey, GetCurrentProcessId(), hmenu, idChild );

    return m_pMgrImpl->SetPropValue( HmenuKey, HMENUKEYSIZE, idProp, & var );
}


HRESULT STDMETHODCALLTYPE
CPropMgr::SetHmenuPropStr (
    HMENU               hmenu,
    DWORD               idChild,
    MSAAPROPID          idProp,
    LPCWSTR             str
)
{
    IMETHOD( TEXT("CPropMgr::SetHmenuPropStr") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    // Need to convert the LPCWSTR to a BSTR before we can put it into a variant...
    VARIANT var;
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString( str );
    if( ! var.bstrVal )
    {
        TraceError( TEXT("CPropMgr::SetHmenuPropStr: SysAllocString failed") );
        return E_OUTOFMEMORY;
    }

    BYTE HmenuKey [ HMENUKEYSIZE ];
    MakeHmenuKey( HmenuKey, GetCurrentProcessId(), hmenu, idChild );
    
    HRESULT hr = m_pMgrImpl->SetPropValue( HmenuKey, HMENUKEYSIZE, idProp, & var );
    SysFreeString( var.bstrVal );
    return hr;
}




HRESULT STDMETHODCALLTYPE
CPropMgr::SetHmenuPropServer (
    HMENU               hmenu,
    DWORD               idChild,

    const MSAAPROPID *  paProps,
    int                 cProps,

    IAccPropServer *    pServer,
    AnnoScope           annoScope
)
{
    IMETHOD( TEXT("CPropMgr::SetHmenuPropServer") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    BYTE HmenuKey [ HMENUKEYSIZE ];
    MakeHmenuKey( HmenuKey, GetCurrentProcessId(), hmenu, idChild );

    return SetPropServer( HmenuKey, HMENUKEYSIZE, paProps, cProps, pServer, annoScope );
}

HRESULT STDMETHODCALLTYPE
CPropMgr::ClearHmenuProps (
    HMENU               hmenu,
    DWORD               idChild,

    const MSAAPROPID *  paProps,
    int                 cProps
)
{
    IMETHOD( TEXT("CPropMgr::ClearHmenuProps") );

    if( ! m_pMgrImpl )
        return E_FAIL;

    BYTE HmenuKey [ HMENUKEYSIZE ];
    MakeHmenuKey( HmenuKey, GetCurrentProcessId(), hmenu, idChild );

    return ClearProps( HmenuKey, HMENUKEYSIZE, paProps, cProps );
}


// Methods for composing/decomposing a HMENU-based key...


HRESULT STDMETHODCALLTYPE
CPropMgr::ComposeHmenuIdentityString (
    HMENU               hmenu,
    DWORD               idChild,

    BYTE **             ppIDString,
    DWORD *             pdwIDStringLen
)
{
    IMETHOD( TEXT("CPropMgr::ComposeHmenuIdentityString") );

    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    BYTE * pKeyData = (BYTE *)CoTaskMemAlloc( HMENUKEYSIZE );
    if( ! pKeyData )
    {
        TraceError( TEXT("CPropMgr::ComposeHmenuIdentityString: CoTaskMemAlloc failed") );
        return E_OUTOFMEMORY;
    }

    MakeHmenuKey( pKeyData, GetCurrentProcessId(), hmenu, idChild );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HMENUKEYSIZE;

    return S_OK;
}



HRESULT STDMETHODCALLTYPE
CPropMgr::DecomposeHmenuIdentityString (
    const BYTE *        pIDString,
    DWORD               dwIDStringLen,

    HMENU *             phmenu,
    DWORD *             pidChild
)
{
    IMETHOD( TEXT("CPropMgr::DecomposeHmenuIdentityString") );

    if( ! DecodeHmenuKey( pIDString, dwIDStringLen, NULL, phmenu, pidChild ) )
    {
        TraceParam( TEXT("CPropMgr::DecomposeHmenuIdentityString: not a valid HMENU id string") );
        return E_INVALIDARG;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\propmgr_util.cpp ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Util
//
//  Utility and shared code and data used by both the exe-server and the
//  shared memory client.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"

#include "PropMgr_Util.h"


// Note: Keep this array's size in sync with NUMPROPS #defined in the .h file
PropInfo g_PropInfo [ NUMPROPS ] =
{
    { & PROPID_ACC_NAME             , VT_BSTR,      TRUE    },
    { & PROPID_ACC_VALUE            , VT_BSTR,      TRUE    },
    { & PROPID_ACC_DESCRIPTION      , VT_BSTR,      TRUE    },
    { & PROPID_ACC_ROLE             , VT_I4,        TRUE    },
    { & PROPID_ACC_STATE            , VT_I4,        TRUE    },
    { & PROPID_ACC_HELP             , VT_BSTR,      TRUE    },
    { & PROPID_ACC_KEYBOARDSHORTCUT , VT_BSTR,      TRUE    },
    { & PROPID_ACC_DEFAULTACTION    , VT_BSTR,      TRUE    },

    { & PROPID_ACC_HELPTOPIC        , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_FOCUS            , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_SELECTION        , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_PARENT           , VT_EMPTY,     FALSE   },

    { & PROPID_ACC_NAV_UP           , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_DOWN         , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_LEFT         , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_RIGHT        , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_PREV         , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_NEXT         , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_FIRSTCHILD   , VT_EMPTY,     FALSE   },
    { & PROPID_ACC_NAV_LASTCHILD    , VT_EMPTY,     FALSE   },

    { & PROPID_ACC_VALUEMAP         , VT_BSTR,      TRUE    },
    { & PROPID_ACC_ROLEMAP          , VT_BSTR,      TRUE    },
    { & PROPID_ACC_STATEMAP         , VT_BSTR,      TRUE    },
    { & PROPID_ACC_DESCRIPTIONMAP   , VT_BSTR,      TRUE    },

    { & PROPID_ACC_DODEFAULTACTION  , VT_EMPTY,     FALSE   },
};










int IndexFromProp( const MSAAPROPID & idProp )
{
    for( int i = 0 ; i < NUMPROPS ; i++ )
    {
        if( *g_PropInfo[ i ].m_idProp == idProp )
            return i;
    }

    return -1;
}








LPTSTR MakeKeyString( const BYTE * pKeyData, DWORD dwKeyLen )
{
    const LPCTSTR szHexChars = TEXT("0123456789ABCDEF");

    LPTSTR pStart = new TCHAR [ ( dwKeyLen * 2 ) + 5 + 1 ]; // +5 for MSAA_, +1 for NUL
    if( pStart == NULL )
    {
        return NULL;
    }

    memcpy( pStart, TEXT("MSAA_"), sizeof(TCHAR) * 5 );
    LPTSTR pScan = pStart + 5;

    while( dwKeyLen-- )
    {
        *pScan++ = szHexChars[ *pKeyData >> 4 ];   // High nybble
        *pScan++ = szHexChars[ *pKeyData & 0x0F ]; // Low nybble
        pKeyData++;
    }

    *pScan = '\0';

    return pStart;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\remoteproxyfactory.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// RemoteProxyFactory.h : Declaration of the CRemoteProxyFactory

#ifndef __REMOTEPROXYFACTORY_H_
#define __REMOTEPROXYFACTORY_H_

#include "resource.h"       // main symbols
#include "oleacc_p.h"

extern "C" {
BOOL GetStateImageMapEnt_SameBitness( HWND hwnd, int iImage, DWORD * pdwState, DWORD * pdwRole );
}

/////////////////////////////////////////////////////////////////////////////
// CRemoteProxyFactory
class ATL_NO_VTABLE CRemoteProxyFactory : 
	public CComObjectRootEx<CComSingleThreadModel>,
#ifdef _WIN64
	public CComCoClass<CRemoteProxyFactory, &CLSID_RemoteProxyFactory64>,
#else
	public CComCoClass<CRemoteProxyFactory, &CLSID_RemoteProxyFactory32>,
#endif
	public IDispatchImpl<IRemoteProxyFactory, &IID_IRemoteProxyFactory, &LIBID_REMOTEPROXY6432Lib>
{
public:
	CRemoteProxyFactory(){}

#ifdef _WIN64
DECLARE_REGISTRY_RESOURCEID( IDR_REMOTEPROXYFACTORY64 )
#else
DECLARE_REGISTRY_RESOURCEID( IDR_REMOTEPROXYFACTORY32 )
#endif
DECLARE_NOT_AGGREGATABLE(CRemoteProxyFactory)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRemoteProxyFactory)
	COM_INTERFACE_ENTRY(IRemoteProxyFactory)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IRemoteProxyFactory
public:

    STDMETHOD(AccessibleProxyFromWindow)(
		/*[in]*/ DWORD dwhwnd, 
		/*[in]*/ long lObjectId, 
		/*[out]*/ IUnknown **ppUnk
	)
	{
		return CreateStdAccessibleObject(
			  (HWND)LongToHandle( dwhwnd )
			, lObjectId
			, IID_IUnknown
			, reinterpret_cast<void **>(ppUnk));
	}

	STDMETHOD(GetStateImageMapEnt)(
        /* [in] */ DWORD dwhwnd,
        /* [in] */ long iImage,
        /* [out] */ DWORD *pdwState,
        /* [out] */ DWORD *pdwRole
	)
	{
        if( GetStateImageMapEnt_SameBitness( (HWND)LongToHandle( dwhwnd ), iImage,
                                             pdwState,
                                             pdwRole ) )
        {
            return S_OK;
        }
        else
        {
            return S_FALSE;
        }
	}
};

#endif //__REMOTEPROXYFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\propmgr_util.h ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Util
//
//  Utility and shared code and data used by both the exe-server and the
//  shared memory client.
//
// --------------------------------------------------------------------------




// All identity strings start with a DWORD to indicate the naming scheme...

enum
{
    MSAA_ID_HWND  = 0x80000001,    // OLEACC's HWND naming scheme
    MSAA_ID_HMENU = 0x80000002,    // OLEACC's HMENU naming scheme
};




// Note: Keep this in sync with size of the g_PropInfo array in the .cpp file
// Also: We use these as bit-indices into a DWORD (see dwUsedBits in
// PropMgr_Client.cpp), so we're limited to 32 for the moment.
enum PROPINDEX
{
    PROPINDEX_NAME,
    PROPINDEX_VALUE,
    PROPINDEX_DESCRIPTION,
    PROPINDEX_ROLE,
    PROPINDEX_STATE,
    PROPINDEX_HELP,
    PROPINDEX_KEYBOARDSHORTCUT,
    PROPINDEX_DEFAULTACTION,

    PROPINDEX_HELPTOPIC,
    PROPINDEX_FOCUS,
    PROPINDEX_SELECTION,
    PROPINDEX_PARENT,

    PROPINDEX_NAV_UP,
    PROPINDEX_NAV_DOWN,
    PROPINDEX_NAV_LEFT,
    PROPINDEX_NAV_RIGHT,
    PROPINDEX_NAV_PREV,
    PROPINDEX_NAV_NEXT,
    PROPINDEX_NAV_FIRSTCHILD,
    PROPINDEX_NAV_LASTCHILD,

    PROPINDEX_VALUEMAP,
    PROPINDEX_ROLEMAP,
    PROPINDEX_STATEMAP,
    PROPINDEX_DESCRIPTIONMAP,

    PROPINDEX_DODEFAULTACTION,

    // By the magic of enums (they start with 0), this entry will have a value
    // equal to the number of entries before it.
    NUMPROPS
};



// If m_fSupportSetValue is false, then the property can only be returned from
// a server callback; it can't be set using SetPropValue().
struct PropInfo
{
    const MSAAPROPID *  m_idProp;
    short               m_Type;
    BOOL                m_fSupportSetValue;
};

extern PropInfo g_PropInfo [ NUMPROPS ];



// returns -1 if not found
int IndexFromProp( const MSAAPROPID & idProp );






// Utility for generating Win32/HWND/OLEACC keys...
#define HWNDKEYSIZE    (sizeof(DWORD)*4)

inline
void MakeHwndKey( BYTE * pDest, HWND hwnd, DWORD idObject, DWORD idChild )
{
    DWORD adw [ 4 ] = { (DWORD)MSAA_ID_HWND, (DWORD) HandleToLong( hwnd ), idObject, idChild };
    memcpy( pDest, adw, sizeof( adw ) );
}

inline 
BOOL DecodeHwndKey( BYTE const * pSrc, DWORD dwLen, HWND * phwnd, DWORD * pidObject, DWORD * pidChild )
{
    if( dwLen != HWNDKEYSIZE )
    {
        return FALSE;
    }

    DWORD adw [ 4 ];
    memcpy( adw, pSrc, HWNDKEYSIZE );

    if( adw[ 0 ] != MSAA_ID_HWND )
    {
        return FALSE;
    }

    if( phwnd )
    {
        *phwnd = (HWND)LongToHandle(adw[ 1 ]);
    }

    if( pidObject )
    {
        *pidObject = adw[ 2 ];
    }

    if( pidChild )
    {
        *pidChild = adw[ 3 ];
    }

    return TRUE;   
}




// Utility for generating OLEACC's HMENU keys...
#define HMENUKEYSIZE    (sizeof(DWORD)*4)

inline
void MakeHmenuKey( BYTE * pDest, DWORD dwpid, HMENU hmenu, DWORD idChild )
{
    DWORD adw [ 4 ] = { (DWORD)MSAA_ID_HMENU, dwpid, (DWORD) HandleToLong( hmenu ), idChild };
    memcpy( pDest, adw, sizeof( adw ) );
}

inline 
BOOL DecodeHmenuKey( BYTE const * pSrc, DWORD dwLen, DWORD * pdwpid, HMENU * phmenu, DWORD * pidChild )
{
    if( dwLen != HMENUKEYSIZE )
    {
        return FALSE;
    }

    DWORD adw [ 4 ];
    memcpy( adw, pSrc, HMENUKEYSIZE );

    if( adw[ 0 ] != MSAA_ID_HMENU )
    {
        return FALSE;
    }

    if( pdwpid )
    {
        *pdwpid = adw[ 1 ];
    }

    if( phmenu )
    {
        *phmenu = (HMENU)LongToHandle(adw[ 2 ]);
    }

    if( pidChild )
    {
        *pidChild = adw[ 3 ];
    }

    return TRUE;   
}




//  Returns a ASCII-fied version of the given key - eg.
//  something like "MSAA_001110034759FAE03...."
//  Caller's responsibility to release with  delete [ ].
//
//  eg.
//      LPTSTR pStr = MakeKeyString( pKeyData, dwKeyLen );
//      if( pStr )
//      {
//          ... do stuff with pStr here ...
//          delete [ ] pStr;
//      }
//

LPTSTR MakeKeyString( const BYTE * pKeyData, DWORD dwKeyLen );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\propmgr_mem.h ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  PropMgr_Mem
//
//  Helper classes/routines for accessing serialized memory
//
// --------------------------------------------------------------------------




inline
SIZE_T AlignUp( SIZE_T s, SIZE_T alignment )
{
    // alignment must be a power of 2...
    Assert( alignment == 1      // byte
         || alignment == 2      // word
         || alignment == 4      // dword
         || alignment == 8 );   // 64bit
                                // Shouldn't need any others for the moment.

    return ( s + alignment - 1 ) & ~ ( alignment - 1 );
}


inline
BYTE * AlignUp( BYTE * p, SIZE_T alignment )
{
    return (BYTE *) AlignUp( (SIZE_T) p, (SIZE_T) alignment );
}







#ifndef UNICODE
inline
int WStrLen( LPCWSTR pWStr )
{
    LPCWSTR pWScan = pWStr;
    while( *pWScan != '\0' )
        pWScan++;
    return pWScan - pWStr;
}
#endif



class MemStream
{
//    friend class MemStream;

    BYTE *  m_pCurPos;
    SIZE_T  m_cbRemaining;



    BOOL Check( SIZE_T unit_size, int count = 1 )
    {
        // Check that we're aligned properly... - do this *before*
        // checking size left...
        BYTE * pNewPos = AlignUp( m_pCurPos, unit_size );

        // Work out how much would remain, after aligning...
        // (This can be negative, eg. if aligning pushes us over end...)
        SIZE_T cbNewRemaining = m_cbRemaining - ( pNewPos - m_pCurPos );

        if( unit_size * count <= cbNewRemaining )
        {
            // There's space available...
            m_cbRemaining = cbNewRemaining;
            m_pCurPos = pNewPos;
            return TRUE;
        }
        else
        {
            // No space left
            m_cbRemaining = 0;
            return FALSE;
        }
    }

    void Advance( SIZE_T size, int count = 1 )
    {
        m_pCurPos += size * count;
        m_cbRemaining -= size * count;
    }



public:


    MemStream( BYTE * pBlock, SIZE_T cbSize )
    {
        m_pCurPos = pBlock;
        m_cbRemaining = cbSize;
    }


    MemStream( const MemStream & x )
    {
        m_pCurPos = x.m_pCurPos;
        m_cbRemaining = x.m_cbRemaining;
    }


    //
    // Basic unit read/write operations...
    //

    BOOL Write_DWORD( DWORD x )
    {
        if( ! Check( sizeof( x ) ) )
            return FALSE;
        *((DWORD *) m_pCurPos ) = x;
        Advance( sizeof( x ) );
        return TRUE;
    }

    BOOL Read_DWORD( DWORD * px )
    {
        if( ! Check( sizeof( *px ) ) )
            return FALSE;
        *px = *((DWORD *) m_pCurPos );
        Advance( sizeof( *px ) );
        return TRUE;
    }


    BOOL Skip_DWORD()
    {
        if( ! Check( sizeof( DWORD ) ) )
            return FALSE;
        Advance( sizeof( DWORD ) );
        return TRUE;
    }


    BOOL Write_WORD( WORD x )
    {
        if( ! Check( sizeof( x ) ) )
            return FALSE;
        *((WORD *) m_pCurPos ) = x;
        Advance( sizeof( x ) );
        return TRUE;
    }

    BOOL Read_WORD( WORD * px )
    {
        if( ! Check( sizeof( *px ) ) )
            return FALSE;
        *px = *((WORD *) m_pCurPos );
        Advance( sizeof( *px ) );
        return TRUE;
    }

    BOOL Skip_WORD()
    {
        if( ! Check( sizeof( WORD ) ) )
            return FALSE;
        Advance( sizeof( WORD ) );
        return TRUE;
    }


    BOOL Write_Binary( const BYTE * pData, int len )
    {
        if( ! Check( sizeof( BYTE ), len ) )
            return FALSE;

        memcpy( m_pCurPos, pData, len );
        Advance( len );
        return TRUE;
    }

    BOOL Read_Binary( BYTE * pData, int len )
    {
        if( ! Check( sizeof( BYTE ), len ) )
            return FALSE;

        memcpy( pData, m_pCurPos, len );
        Advance( len );
        return TRUE;
    }

    BOOL Skip_Binary( int len )
    {
        if( ! Check( sizeof( BYTE ), len ) )
            return FALSE;
        Advance( len );
        return TRUE;
    }

    const BYTE * GetBinaryPtr( int len )
    {
        if( ! Check( sizeof( BYTE ), len ) )
            return NULL;

        return m_pCurPos;
    }
};



inline BOOL MemStreamWrite_DWORD    ( MemStream & ptr, DWORD x )     {   return ptr.Write_DWORD( x );    }
inline BOOL MemStreamRead_DWORD     ( MemStream & ptr, DWORD * px )  {   return ptr.Read_DWORD( px );    }
inline BOOL MemStreamSkip_DWORD     ( MemStream & ptr )              {   return ptr.Skip_DWORD(); }

inline BOOL MemStreamWrite_WORD     ( MemStream & ptr, WORD x )      {   return ptr.Write_WORD( x );     }
inline BOOL MemStreamRead_WORD      ( MemStream & ptr, WORD * px )   {   return ptr.Read_WORD( px );     }
inline BOOL MemStreamSkip_WORD      ( MemStream & ptr )              {   return ptr.Skip_WORD();         }

inline BOOL MemStreamWrite_Binary   ( MemStream & ptr, const BYTE * pData, int Len ) {   return ptr.Write_Binary( pData, Len );  }
inline BOOL MemStreamRead_Binary    ( MemStream & ptr, BYTE * pData, int Len )       {   return ptr.Read_Binary( pData, Len );   }
inline BOOL MemStreamSkip_Binary    ( MemStream & ptr, int Len )                     {   return ptr.Skip_Binary( Len );          }

inline const BYTE * MemStream_GetBinaryPtr( MemStream & ptr, int len ) {    return ptr.GetBinaryPtr( len ); }


// pcbSize is an in/out parameter; it is adjusted to account for allignmenmt plus the addition of an item of the given type.
inline
void MemStreamMeasure_DWORD ( SIZE_T * pcbSize, int count = 1 )
{
    *pcbSize = AlignUp( *pcbSize, sizeof( DWORD ) ) + sizeof( DWORD ) * count;
}

inline
void MemStreamMeasure_WORD ( SIZE_T * pcbSize, int count = 1 )
{
    *pcbSize = AlignUp( *pcbSize, sizeof( WORD ) ) + sizeof( WORD ) * count;
}

inline
void MemStreamMeasure_Binary ( SIZE_T * pcbSize, int Len )
{
    *pcbSize += Len;
}





inline
BOOL MemStreamWrite_VARIANT( MemStream & ptr, VARIANT & x )
{
    if( ! MemStreamWrite_WORD( ptr, x.vt ) )
        return FALSE;
    switch( x.vt )
    {
        case VT_EMPTY:
            // nothing to do
            break;

        case VT_BSTR:
        {
#ifdef UNICODE
            DWORD len = lstrlen( x.bstrVal );
#else
            DWORD len = WStrLen( x.bstrVal );
#endif
            // Note - does not include terminating NUL...
            if( ! MemStreamWrite_DWORD( ptr, len ) ||
                ! MemStreamWrite_Binary( ptr, (BYTE *) x.bstrVal, len * sizeof( WCHAR ) ) )
                return FALSE;
            break;
        }

        case VT_I4:
        {
            if( ! MemStreamWrite_DWORD( ptr, x.lVal ) )
                return FALSE;
            break;
        }

        // Can add support for other VT_ types here. 

        default:
            Assert( FALSE );
    }

    return TRUE;
}


inline
BOOL MemStreamRead_VARIANT( MemStream & ptr, VARIANT * px )
{
    if( ! MemStreamRead_WORD( ptr, & px->vt ) )
        return FALSE;

    switch( px->vt )
    {
        case VT_EMPTY:
            // nothing to do
            break;

        case VT_BSTR:
        {
            DWORD len;
            if( ! MemStreamRead_DWORD( ptr, & len ) )
                return FALSE;

            px->bstrVal = SysAllocStringLen( NULL, len ); // 1 for NUL is added automatically by SysAllocStringLen
            if( ! MemStreamRead_Binary( ptr, (BYTE *) px->bstrVal, len * sizeof( WCHAR ) ) )
            {
                SysFreeString( px->bstrVal );
                return FALSE;
            }

            px->bstrVal[ len ] = '\0';

            break;
        }

        case VT_I4:
        {
            if( ! MemStreamRead_DWORD( ptr, reinterpret_cast< DWORD * >( & px->lVal ) ) )
                return FALSE;
            break;
        }

        // Can add support for other VT_ types here. 

        default:
            Assert( FALSE );
    }

    return TRUE;
}


inline
BOOL MemStreamSkip_VARIANT( MemStream & ptr )
{
    WORD vt;
    if( ! MemStreamRead_WORD( ptr, & vt ) )
        return FALSE;

    switch( vt )
    {
        case VT_EMPTY:
            // nothing to do
            break;

        case VT_BSTR:
        {
            DWORD len;
            if( ! MemStreamRead_DWORD( ptr, & len ) ||
                ! MemStreamSkip_Binary( ptr, len * sizeof( WCHAR ) ) )
                return FALSE;
            break;
        }

        case VT_I4:
        {
            if( ! MemStreamSkip_DWORD( ptr ) )
                return FALSE;
            break;
        }

        // Can add support for other VT_ types here. 

        default:
            Assert( FALSE );
    }

    return TRUE;
}



inline
void MemStreamMeasure_VARIANT( SIZE_T * pSize, VARIANT & x )
{
    MemStreamMeasure_WORD( pSize );
    switch( x.vt )
    {
        case VT_EMPTY:
            // nothing to do
            break;

        case VT_BSTR:
        {
#ifdef UNICODE
            DWORD len = lstrlen( x.bstrVal );
#else
            DWORD len = WStrLen( x.bstrVal );
#endif
            MemStreamMeasure_DWORD( pSize );
            MemStreamMeasure_Binary( pSize, len * sizeof( WCHAR ) );
            break;
        }

        case VT_I4:
        {
            MemStreamMeasure_DWORD( pSize );
            break;
        }

        // Can add support for other VT_ types here. 

        default:
            Assert( FALSE );
    }
}



inline
BOOL MemStreamWrite_GUID( MemStream & ptr, const GUID & x )
{
    return MemStreamWrite_DWORD( ptr, x.Data1 )
        && MemStreamWrite_WORD( ptr, x.Data2 )
        && MemStreamWrite_WORD( ptr, x.Data3 )
        && MemStreamWrite_Binary( ptr, x.Data4, 8 );
}

inline
BOOL MemStreamRead_GUID( MemStream & ptr, GUID * px )
{
    return MemStreamRead_DWORD( ptr, & px->Data1 )
        && MemStreamRead_WORD( ptr, & px->Data2 )
        && MemStreamRead_WORD( ptr, & px->Data3 )
        && MemStreamRead_Binary( ptr, px->Data4, 8 );
}

inline
void MemStreamMeasure_GUID( SIZE_T * pSize )
{
    MemStreamMeasure_DWORD( pSize, 3 );
    MemStreamMeasure_Binary( pSize, 8 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\resource.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by oleacc.rc
//
#define IDR_TYPELIB1                    101
#define IDR_REMOTEPROXYFACTORY32        102
#define IDR_REMOTEPROXYFACTORY64        103
#define IDR_PROPMGR                     104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\sdm95.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

//----------------------------------------------------------------------//
// WARNING! DANGER! WARNING! DANGER! WARNING! DANGER! WARNING!  DANGER! //
// DANGER! WARNING! DANGER! WARNING! DANGER! WARNING!  DANGER! WARNING! //
// WARNING! DANGER! WARNING! DANGER! WARNING! DANGER! WARNING!  DANGER! //
//----------------------------------------------------------------------//
//                                                                      //
// WARNING!       This file is part of the SDM project.         DANGER! //
// WARNING!    Do not modify it!  If you change this file       DANGER! //
// WARNING!   you will break the build when SDM is updated!     DANGER! //
// WARNING!   If you need to make changes, make them in the     DANGER! //
// WARNING!   SDM project.  If you don't know where that is     DANGER! //
// WARNING!    contact NeilH.  In fact, contact NeilH           DANGER! //
// WARNING!   anyway, to make sure your change doesn't break    DANGER! //
// WARNING!    a version that you're not using.  Thank you.     DANGER! //
//                                                                      //
//----------------------------------------------------------------------//
// WARNING! DANGER! WARNING! DANGER! WARNING! DANGER! WARNING!  DANGER! //
// DANGER! WARNING! DANGER! WARNING! DANGER! WARNING!  DANGER! WARNING! //
// WARNING! DANGER! WARNING! DANGER! WARNING! DANGER! WARNING!  DANGER! //
//----------------------------------------------------------------------//

//------------------------------------------------------------------------
// SDMTOWCT.H - include file containing the interface to be used for
// communication from outside applications with SDM dialogs.
//------------------------------------------------------------------------

#ifndef SDM_WCT_DEFINED
#define SDM_WCT_DEFINED

//------------------------------------------------------------------------
// WCT/SDM Values - Definitions and descriptions
//------------------------------------------------------------------------
#define wVerWord		2		// WinWord format


// A pointer to an array of WCTL structures is passed as the lParam
//  in a WM_GETCONTROLS message when wParam is wVerWord.
//

// 32-bit structure
typedef struct _wctl32
{
	WORD wtp;				// Item type
	WORD wId;				// Unique identifier within this dialog (TMC)
	WORD wState;			// Current value if fHasState
	WORD cchText;			// Size of text value, if fHasText
	WORD cchTitle;			// Size of title, if fHasTitle
    WORD wPad1;             // First padding word for WIN32
#ifdef MAC
	Rect rect;				// Rectangle in dialog window
#else
	RECT rect;				// Rectangle in dialog window
#endif
	LONG fHasState:1;		// Can this type of item have a numeric state?
	LONG fHasText:1;		// Can this type of item have a text value?
	LONG fHasTitle:1;		// Does the item have a title?
	LONG fEnabled:1;		// Is the item currently enabled?
	LONG fVisible:1;		// Is the item visible?
	LONG fCombo:1;			// Is the item a combo edit or listbox?
	LONG fSpin:1;			// Is the item a spin edit?
	LONG fOwnerDraw:1;		// Is the item owner-draw (or extended listbox)?
	LONG fCanFocus:1;		// Can the item receive focus?
	LONG fHasFocus:1;		// Does the item have focus?
	LONG fList:1;			// Supports wtxi.wIndex, WM_GETLISTCOUNT
	LONG lReserved:21;		// A bunch o' bits
	WORD wParam1;			// for tmtStaticText, tmtFormattedText
	WORD wParam2;			// as above
	WORD wParam3;			// yet another spare value for drawing routines
    WORD wPad2;             // Second padding word for WIN32
} WCTL32, *PWCTL32, FAR *LPWCTL32;


#pragma pack(1)
// 16-bit structure
typedef struct _wctl16
{
	WORD wtp;				// Item type
	WORD wId;				// Unique identifier within this dialog (TMC)
	WORD wState;			// Current value if fHasState
	WORD cchText;			// Size of text value, if fHasText
	WORD cchTitle;			// Size of title, if fHasTitle
#ifdef MAC
	Rect rect;				// Rectangle in dialog window
#else
    short   left;
    short   top;
    short   right;
    short   bottom;
#endif
	LONG fHasState:1;		// Can this type of item have a numeric state?
	LONG fHasText:1;		// Can this type of item have a text value?
	LONG fHasTitle:1;		// Does the item have a title?
	LONG fEnabled:1;		// Is the item currently enabled?
	LONG fVisible:1;		// Is the item visible?
	LONG fCombo:1;			// Is the item a combo edit or listbox?
	LONG fSpin:1;			// Is the item a spin edit?
	LONG fOwnerDraw:1;		// Is the item owner-draw (or extended listbox)?
	LONG fCanFocus:1;		// Can the item receive focus?
	LONG fHasFocus:1;		// Does the item have focus?
	LONG fList:1;			// Supports wtxi.wIndex, WM_GETLISTCOUNT
	LONG lReserved:21;		// A bunch o' bits
} WCTL16, *PWCTL16, FAR *LPWCTL16;
#pragma pack()


/* Possible values for wctl.wtp */
#define wtpMin				1
#define wtpStaticText		1
#define wtpPushButton		2
#define wtpCheckBox			3
#define wtpRadioButton		4
#define wtpGroupBox			5
#define wtpEdit				6
#define wtpFormattedText	7
#define wtpListBox			8
#define	wtpDropList			9
#define wtpBitmap			10
#define wtpGeneralPicture	11
#define wtpScroll			12
#define wtpMax				13

// A pointer to a WTXI structure is passed as the lParam of
//  a WM_GETCTLTEXT or WM_GETCTLTITLE message.
//

// Win32 structure
typedef struct _wtxi32		// WinWord text info
{
#ifdef MAC
	char*	lpszBuffer;		// Buffer to receive string
#else
	LPSTR	lpszBuffer;		// Buffer to receive string
#endif
	WORD	cch;			// Size of buffer to receive string, in chars
	WORD	wId;			// Item identifier (TMC) (as in wctl.wId)
#ifdef MAC
	Rect	rect;			// Only used for WM_GETCTLTITLE
#else
	RECT	rect;			// Only used for WM_GETCTLTITLE
#endif
	WORD	wIndex;			// Only used for WM_GETCTLTEXT on ListBoxes
    WORD    wPad1;          // Padding for Win32
} WTXI32, *PWTXI32, FAR *LPWTXI32;


// Win16 structure
#pragma pack(1)
typedef struct _wtxi16
{
#ifdef MAC
	char*	lpszBuffer;		// Buffer to receive string
#else
	LPSTR	lpszBuffer;		// Buffer to receive string
#endif
	WORD	cch;			// Size of buffer to receive string, in chars
	WORD	wId;			// Item identifier (TMC) (as in wctl.wId)
#ifdef MAC
	Rect	rect;			// Only used for WM_GETCTLTITLE
#else
    short   left;
    short   top;
    short   right;
    short   bottom;
#endif
	WORD	wIndex;			// Only used for WM_GETCTLTEXT on ListBoxes
} WTXI16, *PWTXI16, FAR *LPWTXI16;
#pragma pack()


//------------------------------------------------------------------------
// WCT/SDM MESSAGES - Definitions and descriptions
//------------------------------------------------------------------------

#define WM_GETCOUNT		0x7FFE
	// Returns the number of bytes needed to store control info.
	//	wParam	- the version id
	//		Must be wVerWord
	//	lParam	- Unused
	//		Must be 0

#define WM_GETCONTROLSSHAREDMEM 0x7FF6
#define WM_GETCONTROLS	0x7FF7
	// Retrieves control information for the dialog.
	//	wParam	- the version id
	//		Must be wVerWord
	//	lParam	- LPWCTL
	//		Must be at least the size returned by WM_GETCOUNT
	// Return value is the number of WCTL structures filled.

#define WM_GETCTLTEXT	0x7FFD
	// Retrieves the text value for the specified control
	//	wParam	- the version id
	//		Must be wVerWord
	//	lParam	- LPWTXI
	//		(*lParam)->wId is the wctl.wId retrieved by WM_GETCONTROLS.
	//		For a listbox (wtpListBox or wtpDropList) (*lParam)->wIndex
	//		  must be the index of the listbox entry to be retrieved.

#define WM_GETCTLTITLE	0x7FFC
	// Retrieves the title of the specified control
	//	wParam	- the version id
	//		Must be wVerWord
	//	lParam	- LPWTXI
	//		(*lParam)->wId is the wctl.wId retrieved by WM_GETCONTROLS

#define WM_GETCTLFOCUS	0x7FFB
	// Returns the wId (TMC) (as in wctl.wId) of the control with focus.
	//	wParam	- the version id
	//		Must be wVerWord
	//	lParam	- Unused
	//		Must be 0

#define WM_SETCTLFOCUS	0x7FFA
	// Sets focus to the specified control
	//	wParam	- the version id
	//		Must be wVerWord
	//	lParam	- a wId value as retrieved by WM_GETCONTROLS

#define WM_GETLISTCOUNT 0x7FF9
	// Returns the number of entries in a listbox
	// wParam	- the version id
	//		Must be wVerWord
	//	lParam	- a wId value as retrieved by WM_GETCONTROLS
	//		Must be a listbox (wtpListBox or wtpDropList)

#define WM_GETHELPID	0x7FF8
	// Returns the dialog's Help ID
	// wParam	- the version id
	//		Must be wVerWord
	//	lParam	- Unused
	//		Must be 0

#define WM_GETCONTROLSMOUSEDRV 0x7FFF
	// special "light" version of GETCONTROLS
	// used by the mouse 9.01 driver

#define WM_GETDROPDOWNID 0x7FF5
	//Returns the item identifier (TMC) of the control that currently owns the dropdown list window
	//This message should be sent directly to the dropdown list window.
	// wParam	- the version id
	//		Must be wVerAnsi or wVerUnicode
	//	lParam	- Unused
	//		Must be 0

#endif //SDM_WCT_DEFINED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\slider.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  SLIDER.H
//
//  Knows how to talk to COMCTL32's TRACKBAR control.
//
// --------------------------------------------------------------------------


class   CSlider32 : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP        get_accName(VARIANT varChild, BSTR* pszName);
        STDMETHODIMP        get_accValue(VARIANT varChild, BSTR* pszValue);
        STDMETHODIMP        get_accRole(VARIANT varChild, VARIANT* pvarRole);
        STDMETHODIMP        get_accState(VARIANT varChild, VARIANT* pvarState);

        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);

        STDMETHODIMP        put_accValue(VARIANT, BSTR szValue);

        CSlider32(HWND, long);

    protected:
        BOOL    m_fVertical;
};


#define INDEX_SLIDER_SELF           0
#define INDEX_SLIDER_PAGEUPLEFT     1
#define INDEX_SLIDER_THUMB          2
#define INDEX_SLIDER_PAGEDOWNRIGHT  3
#define CCHILDREN_SLIDER            3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\scroll.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  SCROLLBAR.H
//
//  Scrollbar ole accessibility implementation
//
// --------------------------------------------------------------------------


//
// Scrollbar
//
class   CScrollBar : public CAccessible
{
    public:
        
        CScrollBar()
            : CAccessible( CLASS_ScrollBarObject )
        {
            // Done.
        }

        // IAccessible
        STDMETHODIMP            get_accName(VARIANT varChild, BSTR* pszName);
        STDMETHODIMP            get_accValue(VARIANT varChild, BSTR* pszValue);
        STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR * pszDescription);
        STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT *pvarRole);
        STDMETHODIMP            get_accState(VARIANT varChild, VARIANT *pvarState);
        STDMETHODIMP			get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

        STDMETHODIMP			accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        STDMETHODIMP			accNavigate(long navDir, VARIANT varChild, VARIANT* pvarEndUpAt);
        STDMETHODIMP			accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
        STDMETHODIMP            accDoDefaultAction(VARIANT varChild);

        STDMETHODIMP			put_accValue(VARIANT varChild, BSTR pszValue);

        // IEnumVARIANT
        STDMETHODIMP            Clone(IEnumVARIANT** ppenum);

        // This is virtual, since each type of sys object implements this.
        BOOL                    FInitialize(HWND hwnd, LONG idObject, LONG iChildCur);


        // IAccIdentity (overidden from base class CAccessible)
        STDMETHODIMP CScrollBar::GetIdentityString (
            DWORD	    dwIDChild,
            BYTE **     ppIDString,
            DWORD *     pdwIDStringLen
        );

    protected:
        BOOL    m_fVertical;      // Vertical or horizontal
};



//
// Scrollbar control
//
class   CScrollCtl : public CClient
{
    public:

        // IAccessible
        STDMETHODIMP            get_accName(VARIANT varChild, BSTR* pszName);
        STDMETHODIMP            get_accValue(VARIANT varChild, BSTR* pszValue);
        STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR * pszDescription);
        STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT *pvarRole);
        STDMETHODIMP            get_accState(VARIANT varChild, VARIANT *pvarState);
        STDMETHODIMP			get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

        STDMETHODIMP			accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        STDMETHODIMP			accNavigate(long navDir, VARIANT varChild, VARIANT* pvarEndUpAt);
        STDMETHODIMP			accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
        STDMETHODIMP            accDoDefaultAction(VARIANT varChild);

        STDMETHODIMP			put_accValue(VARIANT varChild, BSTR pszValue);

        // This is virtual, since each type of sys object implements this.
        CScrollCtl(HWND, long);

    protected:
        BOOL    m_fGrip;            // Sizebox instead of bar
        BOOL    m_fVertical;        // Vertical or horizontal
};



//
// Size grip
//
class   CSizeGrip : public CAccessible
{
        BOOL                    IsActive();

    public:

        CSizeGrip()
            : CAccessible( CLASS_SizeGripObject )
        {
            // Done.
        }
        
        // IAccessible
        STDMETHODIMP            get_accName(VARIANT varChild, BSTR * pszNaem);
        STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR * pszDesc);
        STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT * pvarRole);
        STDMETHODIMP            get_accState(VARIANT varChild, VARIANT * pvarState);
        
        STDMETHODIMP            accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        STDMETHODIMP            accNavigate(long dwNavFlags, VARIANT varStart, VARIANT * pvarEnd);
        STDMETHODIMP            accHitTest(long xLeft, long yTop, VARIANT * pvarHit);

        // IEnumVARIANT
        STDMETHODIMP            Clone(IEnumVARIANT * * ppenum);

        BOOL                    FInitialize(HWND hwnd);
};


HRESULT CreateScrollBarThing(HWND hwnd, LONG idObj, LONG iItem, REFIID riid, void** ppvScroll);
void            FixUpScrollBarInfo(LPSCROLLBARINFO);

HRESULT CreateSizeGripThing(HWND hwnd, LONG idObj, REFIID riid, void** ppvObject);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\scroll.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  SCROLL.CPP
//
//  Scroll bar class.
//
//  OUTSTANDING ISSUES:
//  Internationalize scrollbar placement for RtoL languages in window.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "window.h"
#include "client.h"
#include "scroll.h"

#include "propmgr_util.h"


/////////////////////////////////////////////////////////////////////////////
//
//  SCROLLBAR (in a Window)
//
/////////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------------
//
//  CreateScrollBarObject()
//
// --------------------------------------------------------------------------
HRESULT CreateScrollBarObject(HWND hwnd, long idObject, REFIID riid, void** ppvScroll)
{
    return(CreateScrollBarThing(hwnd, idObject, 0, riid, ppvScroll));
}



// --------------------------------------------------------------------------
//
//  CreateScrollBarThing()
//
// --------------------------------------------------------------------------
HRESULT CreateScrollBarThing(HWND hwnd, long idObject, long iItem, REFIID riid, void** ppvScroll)
{
    CScrollBar * pscroll;
    HRESULT     hr;

    InitPv(ppvScroll);

    pscroll = new CScrollBar();
    if (pscroll)
    {
        if (! pscroll->FInitialize(hwnd, idObject, iItem))
        {
            delete pscroll;
            return(E_FAIL);
        }
    }
    else
        return(E_OUTOFMEMORY);

    hr = pscroll->QueryInterface(riid, ppvScroll);
    if (!SUCCEEDED(hr))
        delete pscroll;

    return(hr);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::Clone(IEnumVARIANT** ppenum)
{
    return(CreateScrollBarThing(m_hwnd, (m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
        m_idChildCur, IID_IEnumVARIANT, (void**)ppenum));
}



// --------------------------------------------------------------------------
//
//  CScrollBar::FInitialize()
//
// --------------------------------------------------------------------------
BOOL CScrollBar::FInitialize(HWND hwndScrollBar, LONG idObject, LONG iChildCur)
{
    if (! IsWindow(hwndScrollBar))
        return(FALSE);

    m_hwnd = hwndScrollBar;

    m_cChildren = CCHILDREN_SCROLLBAR;
    m_idChildCur = iChildCur;

    m_fVertical = (idObject == OBJID_VSCROLL);

    return(TRUE);
}


// --------------------------------------------------------------------------
//
//  GetScrollMask()
//
//  Gets present elements (may or may not be offscreen)
//
// --------------------------------------------------------------------------
void FixUpScrollBarInfo(LPSCROLLBARINFO lpsbi)
{
    if (lpsbi->rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_UNAVAILABLE)
    {
        lpsbi->rgstate[INDEX_SCROLLBAR_UPPAGE] |= STATE_SYSTEM_INVISIBLE;
        lpsbi->rgstate[INDEX_SCROLLBAR_THUMB] |= STATE_SYSTEM_INVISIBLE;
        lpsbi->rgstate[INDEX_SCROLLBAR_DOWNPAGE] |= STATE_SYSTEM_INVISIBLE;
    }
}



// --------------------------------------------------------------------------
//
//  CScrollBar::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(HrCreateString(STR_SCROLLBAR_NAME + varChild.lVal +
        (m_fVertical ? 0 : INDEX_SCROLLBAR_HORIZONTAL), pszName));
}



// --------------------------------------------------------------------------
//
//  CScrollBar::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    long    lPos;

    InitPv(pszValue);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return(E_NOT_APPLICABLE);

    //
    // The value is the position.
    //
    lPos = GetScrollPos(m_hwnd, (m_fVertical ? SB_VERT : SB_HORZ));

    int Min, Max;
    GetScrollRange( m_hwnd, (m_fVertical ? SB_VERT : SB_HORZ), & Min, & Max );

    // work out a percent value...
    if( Min != Max )
        lPos = ( ( lPos - Min ) * 100 ) / ( Max - Min );
    else
        lPos = 0; // Prevent div-by-0

    return(VarBstrFromI4(lPos, 0, 0, pszValue));
}




// --------------------------------------------------------------------------
//
//  CScrollBar::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{
    InitPv(pszDesc);

    //
    // Validate the params
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(HrCreateString(STR_SCROLLBAR_DESCRIPTION + varChild.lVal +
        (m_fVertical ? 0 : INDEX_SCROLLBAR_HORIZONTAL), pszDesc));
}


// --------------------------------------------------------------------------
//
//  CScrollBar::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_SELF:
            pvarRole->lVal = ROLE_SYSTEM_SCROLLBAR;
            break;

        case INDEX_SCROLLBAR_UP:
        case INDEX_SCROLLBAR_DOWN:
        case INDEX_SCROLLBAR_UPPAGE:
        case INDEX_SCROLLBAR_DOWNPAGE:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case INDEX_SCROLLBAR_THUMB:
            pvarRole->lVal = ROLE_SYSTEM_INDICATOR;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of scroll bar") );
    }

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    SCROLLBARINFO   sbi;

    InitPvar(pvarState);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    //
    // Get our information
    //
    if (! MyGetScrollBarInfo(m_hwnd, (m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
            &sbi)       ||
        (sbi.rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_INVISIBLE))
    {
        //
        // If scrollbar isn't there period, fail.
        //
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_OK);
    }

    //
    // If unavailable or offscreen, everything is.
    //
    FixUpScrollBarInfo(&sbi);

    pvarState->lVal |= sbi.rgstate[INDEX_SCROLLBAR_SELF];
    pvarState->lVal |= sbi.rgstate[varChild.lVal];

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::get_accDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::get_accDefaultAction(VARIANT varChild,
    BSTR * pszDefAction)
{
    InitPv(pszDefAction);

    //
    // Validate the params
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_UP:
        case INDEX_SCROLLBAR_UPPAGE:
        case INDEX_SCROLLBAR_DOWNPAGE:
        case INDEX_SCROLLBAR_DOWN:
            return(HrCreateString(STR_BUTTON_PUSH, pszDefAction));
    }

    return(E_NOT_APPLICABLE);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    SCROLLBARINFO   sbi;
    int             dxyButton;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate params
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! MyGetScrollBarInfo(m_hwnd, (m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
            &sbi)       ||
        (sbi.rgstate[INDEX_TITLEBAR_SELF] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN)))
    {
        return(S_FALSE);
    }

    FixUpScrollBarInfo(&sbi);
    if (sbi.rgstate[varChild.lVal] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN))
        return(S_FALSE);

    if (m_fVertical)
        dxyButton = sbi.rcScrollBar.right - sbi.rcScrollBar.left;
    else
        dxyButton = sbi.rcScrollBar.bottom - sbi.rcScrollBar.top;
            
    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_SELF:
            *pxLeft = sbi.rcScrollBar.left;
            *pyTop = sbi.rcScrollBar.top;
            *pcxWidth = sbi.rcScrollBar.right - sbi.rcScrollBar.left;
            *pcyHeight = sbi.rcScrollBar.bottom - sbi.rcScrollBar.top;
            break;

        case INDEX_SCROLLBAR_UP:
        case INDEX_SCROLLBAR_DOWN:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;
                *pcyHeight = sbi.dxyLineButton;

                if (varChild.lVal == INDEX_SCROLLBAR_UP)
                    *pyTop = sbi.rcScrollBar.top;
                else
                    *pyTop = sbi.rcScrollBar.bottom - *pcyHeight;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;
                *pcxWidth = sbi.dxyLineButton;

                if (varChild.lVal == INDEX_SCROLLBAR_UP)
                    *pxLeft = sbi.rcScrollBar.left;
                else
                    *pxLeft = sbi.rcScrollBar.right - *pcxWidth;
            }
            break;

        case INDEX_SCROLLBAR_UPPAGE:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;

                *pyTop = sbi.rcScrollBar.top + sbi.dxyLineButton;
                *pcyHeight = sbi.xyThumbTop - sbi.dxyLineButton;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;

                *pxLeft = sbi.rcScrollBar.left + sbi.dxyLineButton;
                *pcxWidth = sbi.xyThumbTop - sbi.dxyLineButton;
            }
            break;

        case INDEX_SCROLLBAR_DOWNPAGE:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;

                *pyTop = sbi.rcScrollBar.top + sbi.xyThumbBottom;
                *pcyHeight = (sbi.rcScrollBar.bottom - sbi.rcScrollBar.top) -
                    sbi.xyThumbBottom - sbi.dxyLineButton;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;

                *pxLeft = sbi.rcScrollBar.left + sbi.xyThumbBottom;
                *pcxWidth = (sbi.rcScrollBar.right - sbi.rcScrollBar.left) -
                    sbi.xyThumbBottom - sbi.dxyLineButton;
            }
            break;

        case INDEX_SCROLLBAR_THUMB:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;

                *pyTop = sbi.rcScrollBar.top + sbi.xyThumbTop;
                *pcyHeight = sbi.xyThumbBottom - sbi.xyThumbTop;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;

                *pxLeft = sbi.rcScrollBar.left + sbi.xyThumbTop;
                *pcxWidth = sbi.xyThumbBottom - sbi.xyThumbTop;
            }
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of scroll bar") );
    }

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT * pvarEnd)
{
    long    lEndUp = 0;
    SCROLLBARINFO sbi;

    InitPvar(pvarEnd);

    //
    // Validate params
    //
    if (! ValidateChild(&varStart)   ||
        ! ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (! MyGetScrollBarInfo(m_hwnd, (m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
        &sbi))
    {
        return(S_FALSE);
    }

    if (dwNavDir == NAVDIR_FIRSTCHILD)
    {
        dwNavDir = NAVDIR_NEXT;
    }
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        dwNavDir = NAVDIR_PREVIOUS;
        varStart.lVal = m_cChildren + 1;
    }
    else if (varStart.lVal == INDEX_SCROLLBAR_SELF)
        return(GetParentToNavigate((m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
            m_hwnd, OBJID_WINDOW, dwNavDir, pvarEnd));

    FixUpScrollBarInfo(&sbi);

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
FindNext:
            lEndUp = varStart.lVal;

            while (++lEndUp <= INDEX_SCROLLBAR_MAC)
            {
                if (!(sbi.rgstate[lEndUp] & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEndUp > INDEX_SCROLLBAR_MAC)
                lEndUp = 0;
            break;

        case NAVDIR_PREVIOUS:
FindPrevious:
            lEndUp = varStart.lVal;

            while (--lEndUp >= INDEX_SCROLLBAR_MIC)
            {
                if (!(sbi.rgstate[lEndUp] & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEndUp < INDEX_SCROLLBAR_MIC)
                lEndUp = 0;
            break;

        case NAVDIR_UP:
            lEndUp = 0;
            if (m_fVertical)
                goto FindPrevious;
            break;

        case NAVDIR_LEFT:
            lEndUp = 0;
            if (!m_fVertical)
                goto FindPrevious;
            break;

        case NAVDIR_DOWN:
            lEndUp = 0;
            if (m_fVertical)
                goto FindNext;
            break;

        case NAVDIR_RIGHT:
            lEndUp = 0;
            if (!m_fVertical)
                goto FindNext;
            break;

        default:
            AssertStr( TEXT("Invalid NavDir") );
    }

    if (lEndUp != INDEX_SCROLLBAR_SELF)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEndUp;
        return(S_OK);
    }
    else
        return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::accHitTest(long xLeft, long yTop, VARIANT * pvarChild)
{
    POINT pt;
    SCROLLBARINFO sbi;
    int   xyPtAxis;
    int   xyScrollEnd;
    long  lHit;

    InitPvar(pvarChild);

    if (! MyGetScrollBarInfo(m_hwnd, (m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
          &sbi)   ||
        (sbi.rgstate[INDEX_SCROLLBAR_SELF] & (STATE_SYSTEM_OFFSCREEN | STATE_SYSTEM_INVISIBLE)))
    {
        return(S_FALSE);
    }

    pt.x = xLeft;
    pt.y = yTop;
    if (! PtInRect(&sbi.rcScrollBar, pt))
        return(S_FALSE);

    FixUpScrollBarInfo(&sbi);

    //
    // Convert to scrollbar coords.
    //
    if (m_fVertical)
    {
        xyPtAxis = yTop - sbi.rcScrollBar.top;
        xyScrollEnd = sbi.rcScrollBar.bottom - sbi.rcScrollBar.top;
    }
    else
    {
        xyPtAxis = xLeft - sbi.rcScrollBar.left;
        xyScrollEnd = sbi.rcScrollBar.right - sbi.rcScrollBar.left;
    }

    lHit = INDEX_SCROLLBAR_SELF;

    if (xyPtAxis < sbi.dxyLineButton)
    {
        Assert(!(sbi.rgstate[INDEX_SCROLLBAR_UP] & STATE_SYSTEM_INVISIBLE));
        lHit = INDEX_SCROLLBAR_UP;
    }
    else if (xyPtAxis >= xyScrollEnd - sbi.dxyLineButton)
    {
        Assert(!(sbi.rgstate[INDEX_SCROLLBAR_DOWN] & STATE_SYSTEM_INVISIBLE));
        lHit = INDEX_SCROLLBAR_DOWN;
    }
    else if (!(sbi.rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_UNAVAILABLE))
    {
        if (xyPtAxis < sbi.xyThumbTop)
        {
            Assert(!(sbi.rgstate[INDEX_SCROLLBAR_UPPAGE] & STATE_SYSTEM_INVISIBLE));
            lHit = INDEX_SCROLLBAR_UPPAGE;
        }
        else if (xyPtAxis >= sbi.xyThumbBottom)
        {
            Assert(!(sbi.rgstate[INDEX_SCROLLBAR_DOWNPAGE] & STATE_SYSTEM_INVISIBLE));
            lHit = INDEX_SCROLLBAR_DOWNPAGE;
        }
        else
        {
            Assert(!(sbi.rgstate[INDEX_SCROLLBAR_THUMB] & STATE_SYSTEM_INVISIBLE));
            lHit = INDEX_SCROLLBAR_THUMB;
        }
    }

    pvarChild->vt = VT_I4;
    pvarChild->lVal = lHit;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CScrollBar::accDoDefaultAction()
//
//  Only works if the element is visible and available!
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::accDoDefaultAction(VARIANT varChild)
{
    WPARAM  wpAction;
    SCROLLBARINFO sbi;

    //
    // Validate params
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // Is child available and present?
    //
    if (!MyGetScrollBarInfo(m_hwnd, (m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL),
        &sbi)   ||
        (sbi.rgstate[INDEX_SCROLLBAR_SELF] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_UNAVAILABLE)))
    {
        return(S_FALSE);
    }

    FixUpScrollBarInfo(&sbi);

    if (sbi.rgstate[varChild.lVal] & STATE_SYSTEM_UNAVAILABLE)
        return(S_FALSE);

    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_UP:
            wpAction = SB_LINEUP;
            break;

        case INDEX_SCROLLBAR_UPPAGE:
            wpAction = SB_PAGEUP;
            break;

        case INDEX_SCROLLBAR_DOWNPAGE:
            wpAction = SB_PAGEDOWN;
            break;

        case INDEX_SCROLLBAR_DOWN:
            wpAction = SB_LINEDOWN;
            break;

        default:
            return(E_NOT_APPLICABLE);
    }

    PostMessage(m_hwnd, (m_fVertical ? WM_VSCROLL : WM_HSCROLL),
        wpAction, (LPARAM)m_hwnd);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CScrollBar::put_accValue()
//
//  CALLER frees the string
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollBar::put_accValue(VARIANT varChild, BSTR szValue)
{
    long    lPos;
    HRESULT hr;

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return(E_NOT_APPLICABLE);

    hr = VarI4FromStr(szValue, 0, 0, &lPos);
    if (!SUCCEEDED(hr))
        return(hr);

    // Verify that we've got a valid percent value
    if( lPos < 0 || lPos > 100 )
        return E_INVALIDARG;

    int Min, Max;
    GetScrollRange( m_hwnd, SB_CTL, & Min, & Max );

    // work out value from percentage...
    lPos = Min + ( ( Max - Min ) * lPos ) / 100;

    SetScrollPos(m_hwnd, (m_fVertical ? SB_VERT : SB_HORZ), lPos, TRUE);

    return(S_OK);
}






STDMETHODIMP CScrollBar::GetIdentityString (
    DWORD	    dwIDChild,
    BYTE **     ppIDString,
    DWORD *     pdwIDStringLen
)
{
    // Unlike the other HWND-based proxies, this one has two associated
    // objids - OBJID_VSCROLL or OBJID_HSCROLL, dpending on whether it represents
    // the horizontal or vertival non-client scrollbar.
    // Because of this, the default implementation of GetIdentityString in
    // the CAccessible base class can't handle this for us, since it can't
    // determin that this is a CScrollBar nor check what our m_fVertical flag is.
    //
    // Instead, we override GetIdentityString, and implement it here where we
    // have the information we need.

    // TODO - should probably verify that idChild is valid.
    // (we can do this for some classes - eg. where the number of children is
    // fixed and known - but it may not be preactical to do it in general.)

    *ppIDString = NULL;
    *pdwIDStringLen = 0;

    BYTE * pKeyData = (BYTE *) CoTaskMemAlloc( HWNDKEYSIZE );
    if( ! pKeyData )
    {
        return E_OUTOFMEMORY;
    }

    DWORD idObject = m_fVertical ? OBJID_VSCROLL : OBJID_HSCROLL;
    MakeHwndKey( pKeyData, m_hwnd, idObject, dwIDChild );

    *ppIDString = pKeyData;
    *pdwIDStringLen = HWNDKEYSIZE;

    return S_OK;
}




/////////////////////////////////////////////////////////////////////////////
//
//  GRIP
//
/////////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------------
//
//  CreateSizeGripObject()
//
//  EXTERNAL
//
// --------------------------------------------------------------------------
HRESULT CreateSizeGripObject(HWND hwnd, long idObject, REFIID riid, void** ppvGrip)
{
    return(CreateSizeGripThing(hwnd, idObject, riid, ppvGrip));
}


// --------------------------------------------------------------------------
//
//  CreateSizeGripThing()
//
//  INTERNAL
//
// --------------------------------------------------------------------------
HRESULT CreateSizeGripThing(HWND hwnd, long idObject, REFIID riid, void** ppvGrip)
{
    CSizeGrip * psizegrip;
    HRESULT     hr;

    UNUSED(idObject);

    InitPv(ppvGrip);

    psizegrip = new CSizeGrip();
    if (psizegrip)
    {
        if (! psizegrip->FInitialize(hwnd))
        {
            delete psizegrip;
            return(E_FAIL);
        }
    }
    else
        return(E_OUTOFMEMORY);

    hr = psizegrip->QueryInterface(riid, ppvGrip);
    if (!SUCCEEDED(hr))
        delete psizegrip;

    return(hr);
}




// --------------------------------------------------------------------------
//
//  CSizeGrip::FInitialize()
//
// --------------------------------------------------------------------------
BOOL CSizeGrip::FInitialize(HWND hwnd)
{
    m_hwnd = hwnd;

    return(IsWindow(hwnd));
}


// --------------------------------------------------------------------------
//
//  CSizeGrip::IsActive()
//
//  Returns TRUE if the size grip can actually be used to size a window.
//  Sometimes size grips are present, but do not allow sizing - eg.
//  present on a control because horiz+vert scrollbars are present, but the
//  control is fixed in a dialog.
//
//  See ntuser\rtl\winmgr.c:SizeBoxHwnd() for the corresponding USER code
//  that does this.
//
// --------------------------------------------------------------------------
BOOL CSizeGrip::IsActive()
{
    // sizable if:

    // size grip is present...
    WINDOWINFO wi;
    if( ! MyGetWindowInfo( m_hwnd, & wi )
     || ! ( wi.dwStyle & WS_VSCROLL )
     || ! ( wi.dwStyle & WS_HSCROLL ) )
    {
        return FALSE;
    }

    // Find first ancestor or self that is sizable and non-maximized...

    HWND hwndSizable = m_hwnd;
    HWND hwndDesktop = GetDesktopWindow();
    for( ; ; )
    {
        DWORD dwStyle = GetWindowLong( hwndSizable, GWL_STYLE );
        if( dwStyle & WS_THICKFRAME )
        {
            // Got it!
            break;
        }

        // try next level up...
        hwndSizable = MyGetAncestor( hwndSizable, GA_PARENT ); 
        if( ! hwndSizable || hwndSizable == hwndDesktop )
        {
            // Didn't find any sizable ancestors - so not active.
            return FALSE;
        }
    }

    // We should really do this check along with checking the THICKFRAME
    // abive - ie. "find the first sizable and non-zoomed window"; instead of
    // this which is "find the first sizable window, and then check that it
    // is non-zoomed".
    // This version is consistent with USER's behavior, which disallows a
    // maximized MDI child from sizing its parent.
    if( IsZoomed( hwndSizable ) )
    {
        return FALSE;
    }


    // If the window we're sizing is different than this window, then check
    // that the size grip is within SM_C[X|Y]EDGE of the sizable window...
    if( hwndSizable != m_hwnd )
    {
        // sizable window's scrollbars must NOT be showing...
        if( ! MyGetWindowInfo( hwndSizable, & wi )
         || ( wi.dwStyle & WS_VSCROLL )
         || ( wi.dwStyle & WS_HSCROLL ) )
        {
            return FALSE;
        }

        // check if bottom-right aligns with top-level window...
        RECT rcInner;
        GetWindowRect( m_hwnd, & rcInner );
        RECT rcTopLevel;
        GetClientRect( hwndSizable, & rcTopLevel );
        MapWindowPoints( NULL, hwndSizable, (POINT *) & rcInner, 2 );

        if( rcInner.right < rcTopLevel.right - GetSystemMetrics( SM_CXEDGE )
            || rcInner.bottom < rcTopLevel.bottom - GetSystemMetrics( SM_CYEDGE ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::get_accName(VARIANT varChild, BSTR * pszName)
{
    InitPv(pszName);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if( IsActive() )
    {
        return HrCreateString( STR_SCROLLBAR_NAME + INDEX_SCROLLBAR_GRIP, pszName );
    }
    else
    {
        return S_FALSE;
    }
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::get_accDescription(VARIANT varChild, BSTR * pszDesc)
{
    InitPv(pszDesc);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if( IsActive() )
    {
        return HrCreateString( STR_SCROLLBAR_DESCRIPTION + INDEX_SCROLLBAR_GRIP, pszDesc );
    }
    else
    {
        return S_FALSE;
    }
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::get_accRole(VARIANT varChild, VARIANT * pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    pvarRole->lVal = ROLE_SYSTEM_GRIP;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::get_accState(VARIANT varChild, VARIANT * pvarState)
{
    WINDOWINFO  wi;

    InitPvar(pvarState);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    //
    // We are only visible if both scrollbars are present.
    //
    if (! MyGetWindowInfo(m_hwnd, &wi)      ||
        !(wi.dwStyle & WS_VSCROLL)          ||
        !(wi.dwStyle & WS_HSCROLL))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_UNAVAILABLE;
    }
    else if( ! IsActive() )
    {
        pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;
    }

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    WINDOWINFO  wi;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (MyGetWindowInfo(m_hwnd, &wi)    &&
        (wi.dwStyle & WS_VSCROLL)       &&
        (wi.dwStyle & WS_HSCROLL))
    {
        *pxLeft = wi.rcClient.right;
        *pyTop = wi.rcClient.bottom;
        *pcxWidth = GetSystemMetrics(SM_CXVSCROLL);
        *pcyHeight = GetSystemMetrics(SM_CYHSCROLL);
    }
    else
        return(S_FALSE);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::accHitTest(long xLeft, long yTop, VARIANT * pvarChild)
{
    WINDOWINFO wi;

    InitPvar(pvarChild);

    if (MyGetWindowInfo(m_hwnd, &wi)  &&
        (wi.dwStyle & WS_VSCROLL)     &&
        (wi.dwStyle & WS_HSCROLL))
    {
        if ((xLeft >= wi.rcClient.right) &&
            (xLeft < wi.rcClient.right + GetSystemMetrics(SM_CXVSCROLL)) &&
            (yTop >= wi.rcClient.bottom) &&
            (yTop < wi.rcClient.bottom + GetSystemMetrics(SM_CYHSCROLL)))
        {
            pvarChild->vt = VT_I4;
            pvarChild->lVal = CHILDID_SELF;
            return(S_OK);
        }
    }

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::accNavigate(long dwNavFlags, VARIANT varStart,
    VARIANT * pvarEnd)
{
    InitPvar(pvarEnd);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varStart)   ||
        ! ValidateNavDir(dwNavFlags, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavFlags >= NAVDIR_FIRSTCHILD)
        return(S_FALSE);

    //
    // Navigation among peers only
    //
    return(GetParentToNavigate(OBJID_SIZEGRIP, m_hwnd, OBJID_WINDOW,
        dwNavFlags, pvarEnd));
}



// --------------------------------------------------------------------------
//
//  CSizeGrip::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSizeGrip::Clone(IEnumVARIANT** ppenum)
{
    return(CreateSizeGripThing(m_hwnd, OBJID_SIZEGRIP, IID_IEnumVARIANT, (void**)ppenum));
}




/////////////////////////////////////////////////////////////////////////////
//
//  SCROLL CONTROL (Can be bar or grip)
//
/////////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------------
//
//  CreateScrollBarClient()
//
//  Called from CClient creation
//
// --------------------------------------------------------------------------
HRESULT CreateScrollBarClient(HWND hwnd, long idChildCur, REFIID riid,
    void** ppvScroll)
{
    CScrollCtl * pscroll;
    HRESULT hr;

    InitPv(ppvScroll);

    pscroll = new CScrollCtl(hwnd, idChildCur);
    if (!pscroll)
        return(E_OUTOFMEMORY);

    hr = pscroll->QueryInterface(riid, ppvScroll);
    if (!SUCCEEDED(hr))
        delete pscroll;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::CScrollCtl
//
// --------------------------------------------------------------------------
CScrollCtl::CScrollCtl(HWND hwnd, long idChildCur)
    : CClient( CLASS_ScrollBarClient )
{
    long    lStyle;

    Initialize(hwnd, idChildCur);

    lStyle = GetWindowLong(hwnd, GWL_STYLE);
    if (lStyle & (SBS_SIZEBOX| SBS_SIZEGRIP))
    {
        m_fGrip = TRUE;
        m_cChildren = 0;
    }
    else
    {
        m_fUseLabel = TRUE;
        m_cChildren = CCHILDREN_SCROLLBAR;

        if (lStyle & SBS_VERT)
            m_fVertical = TRUE;
    }
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accName(varChild, pszName));

    Assert(!m_fGrip);

    return(HrCreateString(STR_SCROLLBAR_NAME + varChild.lVal +
        (m_fVertical ? 0 : INDEX_SCROLLBAR_HORIZONTAL), pszName));
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    long    lPos;

    InitPv(pszValue);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal || m_fGrip)
        return(E_NOT_APPLICABLE);

    lPos = GetScrollPos(m_hwnd, SB_CTL);
    int Min, Max;
    GetScrollRange( m_hwnd, SB_CTL, & Min, & Max );

    // work out a percent value...
    if( Min != Max )
        lPos = ( ( lPos - Min ) * 100 ) / ( Max - Min );
    else
        lPos = 0; // Prevent div-by-0

    return(VarBstrFromI4(lPos, 0, 0, pszValue));
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{
    InitPv(pszDesc);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accDescription(varChild, pszDesc));

    Assert(!m_fGrip);

    return(HrCreateString(STR_SCROLLBAR_DESCRIPTION + varChild.lVal +
        (m_fVertical ? 0 : INDEX_SCROLLBAR_HORIZONTAL), pszDesc));
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    switch (varChild.lVal)
    {
        case 0:
            if (m_fGrip)
                pvarRole->lVal = ROLE_SYSTEM_GRIP;
            else
                pvarRole->lVal = ROLE_SYSTEM_SCROLLBAR;
            break;

        case INDEX_SCROLLBAR_UP:
        case INDEX_SCROLLBAR_DOWN:
        case INDEX_SCROLLBAR_UPPAGE:
        case INDEX_SCROLLBAR_DOWNPAGE:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case INDEX_SCROLLBAR_THUMB:
            pvarRole->lVal = ROLE_SYSTEM_INDICATOR;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of scroll bar") );
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    SCROLLBARINFO   sbi;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accState(varChild, pvarState));

    Assert(!m_fGrip);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (!MyGetScrollBarInfo(m_hwnd, OBJID_CLIENT, &sbi))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_OK);
    }

    FixUpScrollBarInfo(&sbi);

    pvarState->lVal |= sbi.rgstate[INDEX_SCROLLBAR_SELF];
    pvarState->lVal |= sbi.rgstate[varChild.lVal];

    if ((varChild.lVal == INDEX_SCROLLBAR_THUMB) && (MyGetFocus() == m_hwnd))
        pvarState->lVal |= STATE_SYSTEM_FOCUSED;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::get_accDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::get_accDefaultAction(VARIANT varChild, BSTR* pszDefA)
{
    InitPv(pszDefA);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_UP:
        case INDEX_SCROLLBAR_UPPAGE:
        case INDEX_SCROLLBAR_DOWNPAGE:
        case INDEX_SCROLLBAR_DOWN:
            return(HrCreateString(STR_BUTTON_PUSH, pszDefA));
    }

    return(E_NOT_APPLICABLE);
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    SCROLLBARINFO   sbi;
    int             dxyButton;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    Assert(!m_fGrip);

    if (!MyGetScrollBarInfo(m_hwnd, OBJID_CLIENT, &sbi))
        return(S_FALSE);

    FixUpScrollBarInfo(&sbi);
    if (sbi.rgstate[varChild.lVal] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN))
        return(S_FALSE);

    if (m_fVertical)
        dxyButton = sbi.rcScrollBar.right - sbi.rcScrollBar.left;
    else
        dxyButton = sbi.rcScrollBar.bottom - sbi.rcScrollBar.top;
            
    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_UP:
        case INDEX_SCROLLBAR_DOWN:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;
                *pcyHeight = sbi.dxyLineButton;

                if (varChild.lVal == INDEX_SCROLLBAR_UP)
                    *pyTop = sbi.rcScrollBar.top;
                else
                    *pyTop = sbi.rcScrollBar.bottom - *pcyHeight;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;
                *pcxWidth = sbi.dxyLineButton;

                if (varChild.lVal == INDEX_SCROLLBAR_UP)
                    *pxLeft = sbi.rcScrollBar.left;
                else
                    *pxLeft = sbi.rcScrollBar.right - *pcxWidth;
            }
            break;

        case INDEX_SCROLLBAR_UPPAGE:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;

                *pyTop = sbi.rcScrollBar.top + sbi.dxyLineButton;
                *pcyHeight = sbi.xyThumbTop - sbi.dxyLineButton;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;

                *pxLeft = sbi.rcScrollBar.left + sbi.dxyLineButton;
                *pcxWidth = sbi.xyThumbTop - sbi.dxyLineButton;
            }
            break;

        case INDEX_SCROLLBAR_DOWNPAGE:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;

                *pyTop = sbi.rcScrollBar.top + sbi.xyThumbBottom;
                *pcyHeight = (sbi.rcScrollBar.bottom - sbi.rcScrollBar.top) -
                    sbi.xyThumbBottom - sbi.dxyLineButton;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;

                *pxLeft = sbi.rcScrollBar.left + sbi.xyThumbBottom;
                *pcxWidth = (sbi.rcScrollBar.right - sbi.rcScrollBar.left) -
                    sbi.xyThumbBottom - sbi.dxyLineButton;
            }
            break;

        case INDEX_SCROLLBAR_THUMB:
            if (m_fVertical)
            {
                *pxLeft = sbi.rcScrollBar.left;
                *pcxWidth = dxyButton;

                *pyTop = sbi.rcScrollBar.top + sbi.xyThumbTop;
                *pcyHeight = sbi.xyThumbBottom - sbi.xyThumbTop;
            }
            else
            {
                *pyTop = sbi.rcScrollBar.top;
                *pcyHeight = dxyButton;

                *pxLeft = sbi.rcScrollBar.left + sbi.xyThumbTop;
                *pcxWidth = sbi.xyThumbBottom - sbi.xyThumbTop;
            }
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of scroll bar") );
    }

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CScrollCtl::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd)
{
    long    lEndUp = 0;
    SCROLLBARINFO   sbi;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) || !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (!varStart.lVal)
    {
        if (dwNavDir < NAVDIR_FIRSTCHILD)
            return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

        if (!m_fGrip)
            return(S_FALSE);

        if (dwNavDir == NAVDIR_FIRSTCHILD)
            dwNavDir = NAVDIR_NEXT;
        else
        {
            dwNavDir = NAVDIR_PREVIOUS;
            varStart.lVal = m_cChildren + 1;
        }
    }

    Assert(!m_fGrip);

    if (!MyGetScrollBarInfo(m_hwnd, OBJID_CLIENT, &sbi))
        return(S_FALSE);

    FixUpScrollBarInfo(&sbi);

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
FindNext:
            lEndUp = varStart.lVal;

            while (++lEndUp <= INDEX_SCROLLBAR_MAC)
            {
                if (!(sbi.rgstate[lEndUp] & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEndUp > INDEX_SCROLLBAR_MAC)
                lEndUp = 0;
            break;

        case NAVDIR_PREVIOUS:
FindPrevious:
            lEndUp = varStart.lVal;

            while (--lEndUp >= INDEX_SCROLLBAR_MIC)
            {
                if (!(sbi.rgstate[lEndUp] & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEndUp < INDEX_SCROLLBAR_MIC)
                lEndUp = 0;
            break;

        case NAVDIR_UP:
            lEndUp = 0;
            if (m_fVertical)
                goto FindPrevious;
            break;

        case NAVDIR_LEFT:
            lEndUp = 0;
            if (!m_fVertical)
                goto FindPrevious;
            break;

        case NAVDIR_DOWN:
            lEndUp = 0;
            if (m_fVertical)
                goto FindNext;
            break;

        case NAVDIR_RIGHT:
            lEndUp = 0;
            if (!m_fVertical)
                goto FindNext;
            break;

        default:
            AssertStr( TEXT("Invalid NavDir") );
    }

    if (lEndUp != INDEX_SCROLLBAR_SELF)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEndUp;
        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::accHitTest(long xLeft, long yTop, VARIANT* pvarHit)
{
    HRESULT hr;
    SCROLLBARINFO sbi;
    int     xyPtAxis;
    int     xyScrollEnd;

    //
    // Is this in our client area at all?
    //
    hr = CClient::accHitTest(xLeft, yTop, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0) || m_fGrip)
        return(hr);

    //
    // We only get here if this is a scrollbar control (not a grip)
    //
    if (!MyGetScrollBarInfo(m_hwnd, OBJID_CLIENT, &sbi))
        return(S_OK);

    FixUpScrollBarInfo(&sbi);

    //
    // Convert to scrollbar coords.
    //
    if (m_fVertical)
    {
        xyPtAxis = yTop - sbi.rcScrollBar.top;
        xyScrollEnd = sbi.rcScrollBar.bottom - sbi.rcScrollBar.top;
    }
    else
    {
        xyPtAxis = xLeft - sbi.rcScrollBar.left;
        xyScrollEnd = sbi.rcScrollBar.right - sbi.rcScrollBar.left;
    }

    if (xyPtAxis < sbi.dxyLineButton)
    {
        Assert(!(sbi.rgstate[INDEX_SCROLLBAR_UP] & STATE_SYSTEM_INVISIBLE));
        pvarHit->lVal = INDEX_SCROLLBAR_UP;
    }
    else if (xyPtAxis >= xyScrollEnd - sbi.dxyLineButton)
    {
        Assert(!(sbi.rgstate[INDEX_SCROLLBAR_DOWN] & STATE_SYSTEM_INVISIBLE));
        pvarHit->lVal = INDEX_SCROLLBAR_DOWN;
    }
    else if (!(sbi.rgstate[INDEX_SCROLLBAR_SELF] & STATE_SYSTEM_UNAVAILABLE))
    {
        if (xyPtAxis < sbi.xyThumbTop)
        {
            Assert(!(sbi.rgstate[INDEX_SCROLLBAR_UPPAGE] & STATE_SYSTEM_INVISIBLE));
            pvarHit->lVal = INDEX_SCROLLBAR_UPPAGE;
        }
        else if (xyPtAxis >= sbi.xyThumbBottom)
        {
            Assert(!(sbi.rgstate[INDEX_SCROLLBAR_DOWNPAGE] & STATE_SYSTEM_INVISIBLE));
            pvarHit->lVal = INDEX_SCROLLBAR_DOWNPAGE;
        }
        else
        {
            Assert(!(sbi.rgstate[INDEX_SCROLLBAR_THUMB] & STATE_SYSTEM_INVISIBLE));
            pvarHit->lVal = INDEX_SCROLLBAR_THUMB;
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CScrollCtl::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::accDoDefaultAction(VARIANT varChild)
{
    WPARAM          wpAction = 0;
    SCROLLBARINFO   sbi;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal || (varChild.lVal == INDEX_SCROLLBAR_THUMB))
        return(E_NOT_APPLICABLE);

    Assert(!m_fGrip);

    if (!MyGetScrollBarInfo(m_hwnd, OBJID_CLIENT, &sbi) ||
        (sbi.rgstate[INDEX_SCROLLBAR_SELF] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_UNAVAILABLE)))
    {
        return(S_FALSE);
    }

    FixUpScrollBarInfo(&sbi);

    if (sbi.rgstate[varChild.lVal] & STATE_SYSTEM_UNAVAILABLE)
        return(S_FALSE);

    switch (varChild.lVal)
    {
        case INDEX_SCROLLBAR_UP:
            wpAction = SB_LINEUP;
            break;

        case INDEX_SCROLLBAR_UPPAGE:
            wpAction = SB_PAGEUP;
            break;

        case INDEX_SCROLLBAR_DOWNPAGE:
            wpAction = SB_PAGEDOWN;
            break;

        case INDEX_SCROLLBAR_DOWN:
            wpAction = SB_LINEDOWN;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of scroll bar") );
    }                     

    SendMessage(GetParent(m_hwnd), (m_fVertical ? WM_VSCROLL : WM_HSCROLL),
        wpAction, (LPARAM)m_hwnd);

    return(S_OK);

}



// --------------------------------------------------------------------------
//
//  CScrollCtl::put_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CScrollCtl::put_accValue(VARIANT varChild, BSTR szValue)
{
    long    lPos;
    HRESULT hr;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal || m_fGrip)
        return(E_NOT_APPLICABLE);

    hr = VarI4FromStr(szValue, 0, 0, &lPos);
    if (!SUCCEEDED(hr))
        return(hr);

    // Verify that we've got a valid percent value
    if( lPos < 0 || lPos > 100 )
        return E_INVALIDARG;

    int Min, Max;
    GetScrollRange( m_hwnd, SB_CTL, & Min, & Max );

    // work out value from percentage...
    lPos = Min + ( ( Max - Min ) * lPos ) / 100;

    SetScrollPos(m_hwnd, SB_CTL, lPos, TRUE);

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\statbar.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  STATBAR.CPP
//
//  This knows how to talk to COMCTL32's status bar control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "statbar.h"

#define NOTOOLBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOPROGRESS
#define NOHOTKEY
#define NOHEADER
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTABCONTROL
#define NOANIMATE
#include <commctrl.h>

#define LPRECT_IN_LPRECT(rc1,rc2)   ((rc1->left >= rc2->left) && \
                                     (rc1->right <= rc2->right) && \
                                     (rc1->top >= rc2->top) && \
                                     (rc1->bottom <= rc2->bottom))

#define RECT_IN_RECT(rc1,rc2)   ((rc1.left >= rc2.left) && \
                                 (rc1.right <= rc2.right) && \
                                 (rc1.top >= rc2.top) && \
                                 (rc1.bottom <= rc2.bottom))


// --------------------------------------------------------------------------
//
//  CreateStatusBarClient()
//
//  EXTERNAL for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateStatusBarClient(HWND hwnd, long idChildCur, REFIID riid, void** ppv)
{
    HRESULT hr;
    CStatusBar32 * pstatus;

    InitPv(ppv);

    pstatus = new CStatusBar32(hwnd, idChildCur);
    if (!pstatus)
        return(E_OUTOFMEMORY);

    hr = pstatus->QueryInterface(riid, ppv);
    if (!SUCCEEDED(hr))
        delete pstatus;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::CStatusBar32()
//
// --------------------------------------------------------------------------
CStatusBar32::CStatusBar32(HWND hwnd, long iChildCur)
    : CClient( CLASS_StatusBarClient )
{
    Initialize(hwnd, iChildCur);
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::SetupChildren()
//
// --------------------------------------------------------------------------
void CStatusBar32::SetupChildren(void)
{
    m_cChildren = SendMessageINT(m_hwnd, SB_GETPARTS, 0, 0);
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatusBar32::get_accName(VARIANT varChild, BSTR* pszValue)
{
    LPTSTR  lpszValue;
    UINT    cchValue;
    HANDLE  hProcess;
    LPTSTR  lpszValueLocal;

    InitPv(pszValue);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(S_FALSE);

    varChild.lVal--;
    cchValue = SendMessageINT(m_hwnd, SB_GETTEXTLENGTH, varChild.lVal, 0);

    // HIGHWORD is type info, LOWORD is length
    cchValue = LOWORD( cchValue );

    if (! cchValue)
        return(S_FALSE);

    cchValue++;
    lpszValue = (LPTSTR)SharedAlloc((cchValue*sizeof(TCHAR)),m_hwnd,&hProcess);
    if (! lpszValue)
        return(E_OUTOFMEMORY);

    if (SendMessage(m_hwnd, SB_GETTEXT, varChild.lVal, (LPARAM)lpszValue))
    {
        lpszValueLocal = (LPTSTR)LocalAlloc (LPTR,cchValue*sizeof(TCHAR));
        if (! lpszValueLocal)
        {
            SharedFree (lpszValue,hProcess);
            return(E_OUTOFMEMORY);
        }
        SharedRead (lpszValue,lpszValueLocal,cchValue*sizeof(TCHAR),hProcess);

        if (*lpszValueLocal)
            *pszValue = TCharSysAllocString(lpszValueLocal);

        SharedFree(lpszValue,hProcess);
        LocalFree (lpszValueLocal);

        if (! *pszValue)
            return(E_OUTOFMEMORY);

        return(S_OK);
    }
    else
    {
        SharedFree(lpszValue,hProcess);
        return(S_FALSE);
    }
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatusBar32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    if (! varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_STATUSBAR;
    else
        pvarRole->lVal = ROLE_SYSTEM_STATICTEXT;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatusBar32::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // Status bar
    //
    if (!varChild.lVal)
        return(CClient::get_accState(varChild, pvarState));

    //
    // Status items
    //
    pvarState->vt = VT_I4;
    pvarState->lVal = 0;
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatusBar32::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    LPRECT  lprc;
    RECT    rcLocal;
    HANDLE  hProcess;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    lprc = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
    if (! lprc)
        return(E_OUTOFMEMORY);

    if (SendMessage(m_hwnd, SB_GETRECT, varChild.lVal-1, (LPARAM)lprc))
    {
        SharedRead (lprc,&rcLocal,sizeof(RECT),hProcess);
        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcLocal, 2);

        *pxLeft = rcLocal.left;
        *pyTop = rcLocal.top;
        *pcxWidth = rcLocal.right - rcLocal.left;
        *pcyHeight = rcLocal.bottom - rcLocal.top;

        SharedFree(lprc,hProcess);

        return(S_OK);
    }
    else
    {
        SharedFree(lprc,hProcess);
        return(S_FALSE);
    }
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatusBar32::accNavigate(long dwNavDir, VARIANT varStart, 
    VARIANT* pvarEnd)
{
    LONG    lEnd;

    InitPvar(pvarEnd);

    //CWO, 1/31/97, #14023, check for HWND children
    if ((!ValidateChild(&varStart) && !ValidateHwnd(&varStart)) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    // If the action is any navigation other than first or last
    // and the child is 0
    if ((dwNavDir < NAVDIR_FIRSTCHILD) && !varStart.lVal)
        // Then call the CClient navigation method
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

    // If the starting point is not a child ID, but is an
    // HWNDID, then we have to convert from the HWND to the
    // child ID by seeing which child area has coordinates
    // that contain the HWND.
    if (IsHWNDID(varStart.lVal))
        varStart.lVal = FindIDFromChildWindow( varStart.lVal );

    switch (dwNavDir)
    {
        case NAVDIR_FIRSTCHILD:
            lEnd = 1;
            goto NextStatusItem;

        case NAVDIR_LASTCHILD:
            lEnd = m_cChildren;
            break;

        case NAVDIR_NEXT:
        case NAVDIR_RIGHT:
            lEnd = varStart.lVal+1;
NextStatusItem:
            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_LEFT:
            lEnd = varStart.lVal-1;
            break;

        default:
            lEnd = 0;
            break;
           
    }

    if (lEnd)
    {
        // When we get here, we know which section to look in. 
        // We need to check all our child windows to see if they
        // are contained within that section and return a dispatch
        // interface if so.
        lEnd = FindChildWindowFromID (lEnd);
        if (IsHWNDID(lEnd))
        {
            pvarEnd->vt = VT_DISPATCH;
            return (AccessibleObjectFromWindow(HwndFromHWNDID(m_hwnd, lEnd),OBJID_WINDOW,
                                    IID_IDispatch, (void**)&pvarEnd->pdispVal));
        }
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CStatusBar32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatusBar32::accHitTest(long x, long y, VARIANT* pvarEnd)
{
    HRESULT hr;
    int*    lpi;
    HANDLE  hProcess;

    SetupChildren();

    //
    // Are we in the client area at all?
    //
    hr = CClient::accHitTest(x, y, pvarEnd);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarEnd->vt != VT_I4) || (pvarEnd->lVal != 0) ||
        !m_cChildren)
        return(hr);

    //
    // Yes.  What item are we over?
    //
    lpi = (LPINT)SharedAlloc((m_cChildren*sizeof(DWORD)),m_hwnd,&hProcess);
    if (! lpi)
        return(E_OUTOFMEMORY);

    if (SendMessage(m_hwnd, SB_GETPARTS, m_cChildren, (LPARAM)lpi))
    {
        LPINT   lpiLocal;
        POINT   pt;
        int     iPart;
        int     xCur;

        lpiLocal = (LPINT)LocalAlloc (LPTR,m_cChildren*sizeof(DWORD));
        if (! lpiLocal)
        {
            SharedFree (lpi,hProcess);
            return(E_OUTOFMEMORY);
        }
        SharedRead (lpi,lpiLocal,m_cChildren*sizeof(DWORD),hProcess);
        // 
        // Charming fact:  The right side of the last item can be -1,
        // meaning extend all the way to the right.  Turn this into MAXINT
        // so the comparison loop below will work OK.
        //

        //
        // This gets us back the right sides of each item, in order.
        //
        pt.x = x;
        pt.y = y;
        ScreenToClient(m_hwnd, &pt);

        xCur = 0;
        for (iPart = 0; iPart < m_cChildren; iPart++)
        {
            if (lpiLocal[iPart] == -1)
                lpiLocal[iPart] = 0x7FFFFFFF;

            if ((pt.x >= xCur) && (pt.x < lpiLocal[iPart]))
            {
                pvarEnd->lVal = iPart+1;
                break;
            }

            xCur = lpiLocal[iPart];
        }
    }

    SharedFree(lpi,hProcess);

    return(S_OK);
}


// --------------------------------------------------------------------------
// FindIDFromChildWindow
//
// This tries to find which section of the status bar the window child is
// in.
//
// What this is really doing is converting an id that refers to a child
// window to an ID that refers to the section of the status bar where that
// HWND lives.
//
//  Parameters:
//      long    HwndID - this should be an HWNDID - an ID referring to a HWND.
//
//  Returns:
//      long indicating which section the window is in. We will return a
//      1-based number, unless we didn't find anything, when we return 0.
//
// --------------------------------------------------------------------------
long CStatusBar32::FindIDFromChildWindow( long id )
{
LPRECT  lprcPart;
int     nParts;
int     i;
RECT    rcPartLocal;
RECT    rcWindowLocal;
HANDLE  hProcess2;

    lprcPart = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess2);
    if (lprcPart == NULL)
        return(0);

    if (!GetWindowRect (HwndFromHWNDID(m_hwnd, id),&rcWindowLocal))
    {
        SharedFree(lprcPart,hProcess2);
        return (0);
    }

    nParts = SendMessageINT(m_hwnd,SB_GETPARTS,0,0);
    for (i=0;i<nParts;i++)
    {
        SendMessage (m_hwnd,SB_GETRECT,i,(LPARAM)lprcPart);
        SharedRead (lprcPart,&rcPartLocal,sizeof(RECT),hProcess2);
        MapWindowPoints (m_hwnd,NULL,(LPPOINT)&rcPartLocal,2);

        if (RECT_IN_RECT(rcWindowLocal,rcPartLocal))
        {
            SharedFree(lprcPart,hProcess2);
            return (i+1);
        }
    }// end for

    SharedFree(lprcPart,hProcess2);
    return (0);
}

// --------------------------------------------------------------------------
// FindChildWindowFromID 
//
// This tries to find a child window inside a given part of a status bar.
//
//  Parameters:
//      long    ID - this should be a 1-based child ID indicating which
//                  part of the status bar to check for a child window.
//  Returns:
//      long that actually contains an HWNDID, or just the value passed
//      in if there was no child window.
// --------------------------------------------------------------------------
long CStatusBar32::FindChildWindowFromID (long ID)
{
LPRECT  lprcPart;
HWND    hwndChild;
RECT    rcWindowLocal;
RECT    rcPartLocal;
HANDLE  hProcess2;

    lprcPart = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess2);
    if (lprcPart == NULL)
        return(0);

    SendMessage (m_hwnd,SB_GETRECT,ID-1,(LPARAM)lprcPart);
    SharedRead (lprcPart,&rcPartLocal,sizeof(RECT),hProcess2);
    MapWindowPoints (m_hwnd,NULL,(LPPOINT)&rcPartLocal,2);

    hwndChild = ::GetWindow(m_hwnd,GW_CHILD);
    while (hwndChild)
    {
        GetWindowRect (hwndChild,&rcWindowLocal);
        if (RECT_IN_RECT(rcWindowLocal,rcPartLocal))
        {
            SharedFree(lprcPart,hProcess2);
            return (HWNDIDFromHwnd(m_hwnd, hwndChild));
        }
        hwndChild = ::GetWindow(hwndChild,GW_HWNDNEXT);
    }
    SharedFree(lprcPart,hProcess2);
    return (ID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\statbar.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  STATBAR.H
//
//  This communicates with COMCTL32's status bar control.
//
// --------------------------------------------------------------------------


class CStatusBar32 : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP    get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP    get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP    get_accState(VARIANT, VARIANT*);

        virtual STDMETHODIMP    accLocation(long*, long*, long*, long*, VARIANT);
        virtual STDMETHODIMP    accNavigate(long, VARIANT, VARIANT*);
        virtual STDMETHODIMP    accHitTest(long, long, VARIANT*);

        CStatusBar32(HWND, long);
        void                SetupChildren(void);
        long                FindIDFromChildWindow (long id);
        long                FindChildWindowFromID (long ID);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\slider.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  SLIDER.CPP
//
//  Knows how to talk to COMCTL32's TRACKBAR control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "slider.h"

#include "PropMgr_Util.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOPROGRESS
#define NODRAGLIST
#define NOTOOLBAR
#define NOHOTKEY
#define NOHEADER
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTABCONTROL
#define NOANIMATE
#include <commctrl.h>


// BOGUS
// For the moment, assume TBS_REVERSE will be0x0200
#ifndef TBS_REVERSE
#define TBS_REVERSE 0x0200
#endif

// --------------------------------------------------------------------------
//
//  CreateSliderClient()
//
// --------------------------------------------------------------------------
HRESULT CreateSliderClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvSlider)
{
    CSlider32*  pslider;
    HRESULT     hr;

    InitPv(ppvSlider);

    pslider = new CSlider32(hwnd, idChildCur);
    if (!pslider)
        return(E_OUTOFMEMORY);

    hr = pslider->QueryInterface(riid, ppvSlider);
    if (!SUCCEEDED(hr))
        delete pslider;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CSlider32::CSlider32()
//
// --------------------------------------------------------------------------
CSlider32::CSlider32(HWND hwnd, long idChildCur)
    : CClient( CLASS_SliderClient )
{
    Initialize(hwnd, idChildCur);
    m_cChildren = CCHILDREN_SLIDER;
    m_fUseLabel = TRUE;

    if (GetWindowLong(hwnd, GWL_STYLE) & TBS_VERT)
        m_fVertical = TRUE;
}



// --------------------------------------------------------------------------
//
//  CSlider32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accName(varChild, pszName));

    // Use scrollbar strings
    return(HrCreateString(STR_SCROLLBAR_NAME +
        (m_fVertical ? INDEX_SCROLLBAR_UP :  INDEX_SCROLLBAR_LEFT) +
        varChild.lVal, pszName));
}



// --------------------------------------------------------------------------
//
//  CSlider32::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    InitPv(pszValue);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // The elements of the slider never have a value
    //
    if (varChild.lVal)
        return(E_NOT_APPLICABLE);

    //
    // Get the current position
    //
    int lPos = SendMessageINT(m_hwnd, TBM_GETPOS, 0, 0);

    BOOL fGotUseRaw;
    if( CheckStringMap( m_hwnd, OBJID_CLIENT, varChild.lVal, PROPINDEX_VALUEMAP, & lPos, 1, pszValue,
                        TRUE /* allow 'use_raw' */, & fGotUseRaw ) )
    {
        if( ! fGotUseRaw )
            return S_OK; // Got string from map, use it...
        else
            return VarBstrFromI4( lPos, 0, 0, pszValue ); // 'use_raw' annotation present - don't scale
    }

    // No annotation - scale value to 0...100...
    long Min = SendMessageINT(m_hwnd, TBM_GETRANGEMIN, 0, 0);
    long Max = SendMessageINT(m_hwnd, TBM_GETRANGEMAX, 0, 0);

    // work out a percent value...
    if( Min != Max )
        lPos = ( ( lPos - Min ) * 100 ) / ( Max - Min );
    else
        lPos = 0; // Prevent div-by-0

    // if invert flag set, lPos = 100-lPos
    LONG Style = GetWindowLong( m_hwnd, GWL_STYLE );
    if( Style & TBS_REVERSE )
        lPos = 100 - lPos;

    return VarBstrFromI4( lPos, 0, 0, pszValue );
}



// --------------------------------------------------------------------------
//
//  CSlider32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    switch (varChild.lVal)
    {
        case INDEX_SLIDER_SELF:
            pvarRole->lVal = ROLE_SYSTEM_SLIDER;
            break;

        case INDEX_SLIDER_PAGEUPLEFT:
        case INDEX_SLIDER_PAGEDOWNRIGHT:
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            break;

        case INDEX_SLIDER_THUMB:
            pvarRole->lVal = ROLE_SYSTEM_INDICATOR;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of slider") );
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CSlider32::get_accState()
//
//  If the thumb is all the way to one side, that page up/down button is
//  not available.
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    LPRECT  lprcChannel;
    LPRECT  lprcThumb;
    HANDLE  hProcess1;
    HANDLE  hProcess2;
    RECT    rcChannel;
    RECT    rcThumb;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accState(varChild, pvarState));

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (GetWindowLong(m_hwnd, GWL_STYLE) & TBS_NOTHUMB)
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_UNAVAILABLE;
        return(S_OK);
    }

    if (varChild.lVal != INDEX_SLIDER_THUMB)
    {
        lprcChannel = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess1);
        if (!lprcChannel)
            return(E_OUTOFMEMORY);

        SendMessage(m_hwnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprcChannel);
        SharedRead (lprcChannel,&rcChannel,sizeof(RECT),hProcess1);

        lprcThumb = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess2);
        if (lprcThumb)
        {
            int iCoord;

            SendMessage(m_hwnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprcThumb);
            SharedRead (lprcThumb,&rcThumb,sizeof(RECT),hProcess2);

            iCoord = (m_fVertical ? 1 : 0);
            iCoord += (varChild.lVal == INDEX_SLIDER_PAGEDOWNRIGHT ? 2 : 0);

            if (((LPINT)&rcChannel)[iCoord] == ((LPINT)&rcThumb)[iCoord])
                pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

            SharedFree(lprcThumb,hProcess2);
        }

        SharedFree(lprcChannel,hProcess1);
    }

    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CSlider32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    LPRECT  lprcChannel;
    LPRECT  lprcThumb;
    int     iCoord;
    HANDLE  hProcess1;
    HANDLE  hProcess2;
    RECT    rcChannel;
    RECT    rcThumb;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    if (GetWindowLong(m_hwnd, GWL_STYLE) & TBS_NOTHUMB)
        return(S_FALSE);

    //
    // Get the thumb rect.
    //
    lprcThumb = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess1);
    if (!lprcThumb)
        return(E_OUTOFMEMORY);

    SendMessage(m_hwnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprcThumb);
    SharedRead (lprcThumb,&rcThumb,sizeof(RECT),hProcess1);

    if (varChild.lVal == INDEX_SLIDER_THUMB)
    {
        //
        // We are done.
        //
        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcThumb, 2);

        *pxLeft = rcThumb.left;
        *pyTop = rcThumb.top;
        *pcxWidth = rcThumb.right - rcThumb.left;
        *pcyHeight = rcThumb.bottom - rcThumb.top;
    }
    else
    {
        //
        // Get the channel rect.
        //
        lprcChannel = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess2);
        if (!lprcChannel)
        {
            SharedFree(lprcThumb,hProcess1);
            return(E_OUTOFMEMORY);
        }

        SendMessage(m_hwnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprcChannel);
        SharedRead (lprcChannel,&rcChannel,sizeof(RECT),hProcess2);

        // Need to flip the channel rect if vertical, since the trackbar doesn't do that itself...
        if( m_fVertical )
        {
            int temp = rcChannel.left; rcChannel.left = rcChannel.top; rcChannel.top = temp;
            temp = rcChannel.right; rcChannel.right = rcChannel.bottom; rcChannel.bottom = temp;
        }

        //
        // Figure out the page up/page down area rect.
        //
        iCoord = (m_fVertical ? 1 : 0);
        iCoord += (varChild.lVal == INDEX_SLIDER_PAGEUPLEFT) ? 2 : 0;

        //
        // We want the left side of the page right area to start at the 
        //      right side of the thumb.
        // We want the right side of the page left area to end at the
        //      left side of the thumb.
        // We want the top side of the page down area to start at the
        //      bottom side of the thumb.
        // We want the bottom side of the page up area to end at the
        //      top side of the thumb.
        ((LPINT)&rcChannel)[iCoord] = ((LPINT)&rcThumb)[(iCoord+2) % 4];

        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcChannel, 2);

        *pxLeft = rcChannel.left;
        *pyTop = rcChannel.top;
        *pcxWidth = rcChannel.right - rcChannel.left;
        *pcyHeight = rcChannel.bottom - rcChannel.top;
        
        SharedFree (lprcChannel,hProcess2);
    }

    SharedFree(lprcThumb,hProcess1);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CSlider32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::accHitTest(long x, long y, VARIANT* pvarHit)
{
    POINT   pt;
    HRESULT hr;
    LPRECT  lprcThumb;
    LPRECT  lprcChannel;
    int     iCoord;
    HANDLE  hProcess1;
    HANDLE  hProcess2;
    RECT    rcThumb;
    RECT    rcChannel;

    //
    // Is the point in us?  Or do we have no children?
    //
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0) ||
        (GetWindowLong(m_hwnd, GWL_STYLE) & TBS_NOTHUMB))
        return(hr);

    pt.x = x;
    pt.y = y;
    ScreenToClient(m_hwnd, &pt);

    //
    // Get the thumb.
    //
    lprcThumb = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess1);
    if (!lprcThumb)
        return(E_OUTOFMEMORY);

    //
    // Is the point in it?
    //
    SendMessage(m_hwnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprcThumb);
    SharedRead (lprcThumb,&rcThumb,sizeof(RECT),hProcess1);
    if (PtInRect(&rcThumb, pt))
    {
        // Yes.
        pvarHit->lVal = INDEX_SLIDER_THUMB;
    }
    else
    {
        // No.  See what side of the thumb it is on.
        lprcChannel = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess2);
        if (!lprcChannel)
        {
            SharedFree(lprcThumb,hProcess1);
            return(E_OUTOFMEMORY);
        }

        SendMessage(m_hwnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprcChannel);
        SharedRead (lprcChannel,&rcChannel,sizeof(RECT),hProcess2);

        // Need to flip the channel rect if vertical, since the trackbar doesn't do that itself...
        if( m_fVertical )
        {
            int temp = rcChannel.left; rcChannel.left = rcChannel.top; rcChannel.top = temp;
            temp = rcChannel.right; rcChannel.right = rcChannel.bottom; rcChannel.bottom = temp;
        }

        iCoord = (m_fVertical ? 1 : 0);

        if ((((LPINT)&pt)[iCoord] >= ((LPINT)&rcChannel)[iCoord]) &&
            (((LPINT)&pt)[iCoord] < ((LPINT)&rcThumb)[iCoord])) 
        {
            pvarHit->lVal = INDEX_SLIDER_PAGEUPLEFT;
        }
        else if ((((LPINT)&pt)[iCoord] >= ((LPINT)&rcThumb)[iCoord+2]) &&
            (((LPINT)&pt)[iCoord] < ((LPINT)&rcChannel)[iCoord+2]))
        {
            pvarHit->lVal = INDEX_SLIDER_PAGEDOWNRIGHT;
        }

        SharedFree(lprcChannel,hProcess2);
    }

    SharedFree(lprcThumb,hProcess1);
    
    return(S_OK);
}




// --------------------------------------------------------------------------
//
//  CSlider32::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
    long    lEnd = 0;
    VARIANT varChild;
    VARIANT varState;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        dwNavDir = NAVDIR_PREVIOUS;
        varStart.lVal = m_cChildren + 1;
    }
    else if (!varStart.lVal)
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

    if (GetWindowLong(m_hwnd, GWL_STYLE) & TBS_NOTHUMB)
        return(S_FALSE);

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
NextChild:
            lEnd = varStart.lVal;
            while (++lEnd <= m_cChildren)
            {
                // Is this item visible?
                VariantInit(&varChild);
                varChild.vt = VT_I4;
                varChild.lVal = lEnd;

                VariantInit(&varState);

                get_accState(varChild, &varState);
                if (!(varState.lVal & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
PrevChild:
            lEnd = varStart.lVal;
            while (--lEnd > 0)
            {
                // Is this item visible?
                VariantInit(&varChild);
                varChild.vt = VT_I4;
                varChild.lVal = lEnd;

                VariantInit(&varState);

                get_accState(varChild, &varState);
                if (!(varState.lVal & STATE_SYSTEM_INVISIBLE))
                    break;
            }
            break;

        case NAVDIR_UP:
            lEnd = 0;
            if (m_fVertical)
                goto PrevChild;
            break;

        case NAVDIR_DOWN:
            lEnd = 0;
            if (m_fVertical)
                goto NextChild;
            break;

        case NAVDIR_LEFT:
            lEnd = 0;
            if (!m_fVertical)
                goto PrevChild;
            break;

        case NAVDIR_RIGHT:
            lEnd = 0;
            if (!m_fVertical)
                goto NextChild;
            break;

    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;

        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CSlider32::put_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CSlider32::put_accValue(VARIANT varChild, BSTR szValue)
{
    long    lPos;
    HRESULT hr;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return(E_NOT_APPLICABLE);

    // Convert string to position.
    hr = VarI4FromStr(szValue, 0, 0, &lPos);
    if (!SUCCEEDED(hr))
        return(hr);
    
    // Verify that we've got a valid percent value
    if( lPos < 0 || lPos > 100 )
        return E_INVALIDARG;

    long Min = SendMessageINT(m_hwnd, TBM_GETRANGEMIN, 0, 0);
    long Max = SendMessageINT(m_hwnd, TBM_GETRANGEMAX, 0, 0);

    // if invert flag set, lPos = 100-lPos
    LONG Style = GetWindowLong( m_hwnd, GWL_STYLE );
    if( Style & TBS_REVERSE )
        lPos = 100 - lPos;

    // work out value from percentage...
    lPos = Min + ( ( Max - Min ) * lPos ) / 100;
  
    SendMessage(m_hwnd, TBM_SETPOS, 0, lPos);

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\static.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  STATIC.CPP
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "window.h"
#include "client.h"
#include "static.h"




// --------------------------------------------------------------------------
//
//  CreateStaticClient()
//
// --------------------------------------------------------------------------
HRESULT CreateStaticClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvStatic)
{
    CStatic * pstatic;
    HRESULT hr;

    InitPv(ppvStatic);

    pstatic = new CStatic(hwnd, idChildCur);
    if (!pstatic)
        return(E_OUTOFMEMORY);

    hr = pstatic->QueryInterface(riid, ppvStatic);
    if (!SUCCEEDED(hr))
        delete pstatic;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CStatic::CStatic()
//
// --------------------------------------------------------------------------
CStatic::CStatic(HWND hwnd, long idChildCur)
    : CClient( CLASS_StaticClient )
{
    Initialize(hwnd, idChildCur);

    // Is this a graphic?
    long lStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    long lType = lStyle & SS_TYPEMASK;
    switch ( lType )
    {
        case SS_LEFT:
        case SS_CENTER:
        case SS_RIGHT:
        case SS_SIMPLE:
        case SS_LEFTNOWORDWRAP:
        case SS_EDITCONTROL:
            // For label-like statics, use their own text, and expose a text role.
            m_fUseLabel = FALSE;	
            m_fGraphic = FALSE;
            break;

        case SS_OWNERDRAW:
            // For owner-draw statics, use their own text, and expose a graphic role.
            m_fUseLabel = FALSE;	
            m_fGraphic = TRUE;
            break;

        default:
            // For everything else, ignore the control's own text (probably a meaningless
            // resource ID) and use a label instead; and expose a graphic role.
            m_fUseLabel = TRUE;	
            m_fGraphic = TRUE;
            break;
    }
}



// --------------------------------------------------------------------------
//
//  CStatic::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatic::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    if (m_fGraphic)
        pvarRole->lVal = ROLE_SYSTEM_GRAPHIC;
    else
        pvarRole->lVal = ROLE_SYSTEM_STATICTEXT;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CStatic::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CStatic::get_accState(VARIANT varChild, VARIANT *pvarState)
{
    WINDOWINFO wi;

    InitPvar(pvarState);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

	pvarState->lVal |= STATE_SYSTEM_READONLY;

    if (!MyGetWindowInfo(m_hwnd, &wi))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_OK);
    }
    
	if (!(wi.dwStyle & WS_VISIBLE))
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\tabctrl.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TABCTRL.CPP
//
//  This knows how to talk to COMCTL32's tab control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "tabctrl.h"


#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOPROGRESS
#define NOHOTKEY
#define NOTREEVIEW
#define NOTOOLBAR
#define NOANIMATE
#include <commctrl.h>
#include "Win64Helper.h"
#include <tchar.h>

#define MAX_NAME_SIZE   128  // maximum size of name of tab control

// Used for Tab control code
// cbExtra for the tray is 8, so pick something even bigger, 16
#define CBEXTRA_TRAYTAB     16


// --------------------------------------------------------------------------
//
//  CreateTabControlClient()
//
//  EXTERNAL for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateTabControlClient(HWND hwnd, long idChildCur,REFIID riid, void** ppvTab)
{
    CTabControl32 * ptab;
    HRESULT hr;

    InitPv(ppvTab);

    ptab = new CTabControl32(hwnd, idChildCur);
    if (! ptab)
        return(E_OUTOFMEMORY);

    hr = ptab->QueryInterface(riid, ppvTab);
    if (!SUCCEEDED(hr))
        delete ptab;

    return(hr);
}





// --------------------------------------------------------------------------
//
//  IsReallyVisible()
//
//  Internal, used for wizard compat.
//  Wizards have a tab control that is has 'visible' state; but is covered
//  up by sibling dialogs (the actual sheets) so that to a user it is not
//  visible.
//
//  They (the comctl people who own the property sheet code) can't make it
//  actually invisible for compat reasons...
//
//  So we have to take this into account when calculating our 'visible'
//  flag.
//  If we didn't do this, Narrator and friends would think the control was
//  visible, and would read it out when reading the window.
//
// --------------------------------------------------------------------------


BOOL IsReallyVisible( HWND hwnd )
{
    // TODO - check own visible state...
    RECT rc;
    GetWindowRect( hwnd, & rc );

    for( HWND hPrev = GetWindow( hwnd, GW_HWNDPREV ) ; hPrev ; hPrev = GetWindow( hPrev, GW_HWNDPREV ) )
    {
        // if window is visible, and covers own rectangle, then we're invisible...
        if( IsWindowVisible( hPrev ) )
        {
            RECT rcSibling;
            GetWindowRect( hPrev, & rcSibling );

            if( rcSibling.left <= rc.left
             && rcSibling.right >= rc.right
             && rcSibling.top <= rc.top
             && rcSibling.bottom >= rc.bottom )
            {
                return FALSE;
            }
        }
    }

    // No predecessors whoch obscure us - visible by default...
    return TRUE;
}




// --------------------------------------------------------------------------
//
//  CTabControl32::CTabControl32()
//
// --------------------------------------------------------------------------
CTabControl32::CTabControl32(HWND hwnd, long idChild)
    : CClient( CLASS_TabControlClient )
{
    Initialize(hwnd, idChild);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::SetupChildren()
//
// --------------------------------------------------------------------------
void CTabControl32::SetupChildren(void)
{
    m_cChildren = SendMessageINT(m_hwnd, TCM_GETITEMCOUNT, 0, 0L);
}

// --------------------------------------------------------------------------
//
//  CTabControl32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accName(VARIANT varChild, BSTR* pszName)
{
LPTSTR  lpszName;
HRESULT hr;

    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
    {
        if (InTheShell(m_hwnd, SHELL_TRAY))
            return(HrCreateString(STR_TRAY, pszName));
        else
            return(CClient::get_accName(varChild, pszName));
    }

    varChild.lVal--;

	// Get the unstripped name
	hr = GetTabControlString (varChild.lVal,&lpszName);
	if( ! lpszName )
		return hr; // could be S_FALSE or E_erro_code

    if (*lpszName)
    {
        StripMnemonic(lpszName);
        *pszName = TCharSysAllocString(lpszName);
    }

	LocalFree (lpszName);
    
    return(*pszName ? S_OK : S_FALSE);
}

    
// --------------------------------------------------------------------------
//
//  CTabControl32::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
TCHAR   chMnemonic = 0;
LPTSTR  lpszName;
HRESULT hr;

    InitPv(pszShortcut);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
    {
        if (InTheShell(m_hwnd, SHELL_TRAY))
            return(S_FALSE); // no shortcut keys for these
        else
            return(CClient::get_accKeyboardShortcut(varChild, pszShortcut));
    }

    varChild.lVal--;

	// Get the unstripped name
	hr = GetTabControlString (varChild.lVal,&lpszName);
	if( ! lpszName )
		return hr; // could be S_FALSE or E_error_code

    if (*lpszName)
        chMnemonic = StripMnemonic(lpszName);

	LocalFree (lpszName);

	//
	// Is there a mnemonic?
	//
	if (chMnemonic)
	{
		//
		// Make a string of the form "Alt+ch".
		//
		TCHAR   szKey[2];

		*szKey = chMnemonic;
		*(szKey+1) = 0;

		return(HrMakeShortcut(szKey, pszShortcut));
	}
	return (S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CTabControl32::GetTabControlString()
//
// Get the name of the tab. There are three ways to do this - 
// You can just ask using the standard messages, if the tab is an
// owner drawn tab owned by the shell we happen to know that the
// item data is the hwnd, so we can just the hwnd's text, or if both
// of those fail, we can try to get it from a tooltip. Since we need to
// do this for both name and keyboard shortcut, we'll write a private
// method to get the unstripped name.
//
// Parameters:
//		int	ChildIndex	    - the zero based index of the tab we want to get
//		LPTSTR*	ppszName	- pointer that will be LocalAlloc'ed and filled
//							  in with the name. Caller must LocalFree it.
//
// Returns:
//
//      On Success:
//        returns S_TRUE, *ppszName will be non-NULL, caller must LocalFree() it.
//
//      On Failure:
//		  returns S_FALSE - no name available. *ppszName set to NULL.
//		  ...or...
//		  returns COM Failure code (including E_OUTOFMEMORY) - com/memory error.
//		  *ppszName set to NULL.
//
// Note: caller should take care if using "FAILED( hr )" to examine the return
// value of this method, since it does treats both S_OK and S_FALSE as 'success'.
// It may be better to check that *ppszName is non-NULL.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::GetTabControlString(int ChildIndex, LPTSTR* ppszName)
{
HWND        hwndToolTip;
LPTSTR		pszName = NULL;

	// Set this to NULL now, in case we return an error code (or S_FALSE) later...
    // (We'll set it to a valid return value later if we succeed...)
    *ppszName = NULL;

    // Try to get name of tab the easy way, by asking first.
	// Allocate a TCITEM structure in the process that owns the window,
	// so they can just read it/write into it when we send the message.
	// Have to use SharedWrite to set up the structure.
	TCHAR tchText[MAX_NAME_SIZE + 1] = {0};
	TCITEM tci;
	memset(&tci, 0, sizeof(TCITEM));
	tci.mask = TCIF_TEXT;
	tci.pszText = tchText;
	tci.cchTextMax = MAX_NAME_SIZE;

	if (SUCCEEDED(XSend_TabCtrl_GetItem(m_hwnd, TCM_GETITEM, ChildIndex, &tci)))
	{
		if (tci.pszText && *tci.pszText)
		{
			pszName = (LPTSTR)LocalAlloc (LPTR,(lstrlen(tci.pszText)+1)*sizeof(TCHAR));
			if (!pszName)
				return E_OUTOFMEMORY;

			lstrcpy(pszName, tci.pszText);
			*ppszName = pszName;
			return S_OK;
		}
	}

    // OK, Step 2 - another hack.  If this is the tray, we know the item data
    // is an HWND, so get the window's text.  So the tricky code is
    // really:  Is this from the tray?

	struct TCITEM_SHELL
	{
		TCITEM	tci;
		BYTE	bExtra[ CBEXTRA_TRAYTAB ];
		// Sending TCM_GETITEM with mask of TCIF_PARAM will overwrite bytes
		// from tci.lParam onwards. The length is set to sizeof(LPARAM) by
		// default, so it's usually not an issue. But the taskbar uses
		// TCM_SETITEMEXTRA to reserve an extra DWORD - so TCM_GETIEEM+TCIF_PARAM
		// sent to the taskbar will overwrite the lParam field plus the following
		// DWORD. It's really really really important to have something that can
		// take this, otherwise it's bye bye stack...
	};

	TCITEM_SHELL tcis;

    pszName = NULL;
	tcis.tci.mask = TCIF_PARAM;
	tcis.tci.pszText = 0;
	tcis.tci.cchTextMax = 0;

	if (InTheShell(m_hwnd, SHELL_TRAY) 
	  && SUCCEEDED(XSend_TabCtrl_GetItem(m_hwnd, TCM_GETITEM, ChildIndex, &tcis.tci)))
	{
		hwndToolTip = (HWND)tcis.tci.lParam;
        pszName = GetTextString (hwndToolTip,TRUE);
		if (pszName && *pszName)
		{
			*ppszName = pszName;
			return S_OK;
		}
	}
    LocalFree (pszName);

	//
	// If we still don't have a name, try method 3 - get name of tab via 
	// tooltip method 
	//
	// TODO (micw) Need to test getting name from tool tip
    hwndToolTip = (HWND)SendMessage(m_hwnd, TCM_GETTOOLTIPS, 0, 0);
    if (!hwndToolTip)
        return(S_FALSE);

	// See if there's tool tip text

	tchText[0] = 0;
	TOOLINFO ti;
	memset(&ti, 0, SIZEOF_TOOLINFO );
	ti.cbSize = SIZEOF_TOOLINFO;
	ti.lpszText = tchText;
	ti.hwnd = m_hwnd;
	ti.uId = ChildIndex;

	if (SUCCEEDED(XSend_ToolTip_GetItem(hwndToolTip, TTM_GETTEXT, 0, &ti, MAX_NAME_SIZE)))
	{
		if (*ti.lpszText)
		{
			pszName = (LPTSTR)LocalAlloc (LPTR,(lstrlen(ti.lpszText)+1)*sizeof(TCHAR));
			if (!pszName)
				return E_OUTOFMEMORY;

			lstrcpy(pszName, ti.lpszText);
			*ppszName = pszName;
			return S_OK;
		}
	}

	return S_FALSE;
}


// --------------------------------------------------------------------------
//
//  CTabControl32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;
    if (!varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_PAGETABLIST;
    else
        pvarRole->lVal = ROLE_SYSTEM_PAGETAB;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    InitPvar(pvarState);
    
    if( ! ValidateChild( & varChild ) )
        return E_INVALIDARG;

    if( !varChild.lVal )
    {
        // Workarond for wizard property sheets...
        //
        // Want to make the 'visible' but covered-up (so not visible to user)
        // tab strip have a state of invisible, so Narrator and friends don't
        // read it out.
        //
        // Do this by calling through to CClient::get_accState as usual,
        // then add in the invisible bit after, if necessary.
        HRESULT hr = CClient::get_accState( varChild, pvarState );
        if( hr == S_OK
         && pvarState->vt == VT_I4
         && ! ( pvarState->lVal & STATE_SYSTEM_INVISIBLE ) )
        {
            if( ! IsReallyVisible( m_hwnd ) )
            {
                pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
            }
        }
        return hr;
    }

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    TCITEM tci;
    memset(&tci, 0, sizeof(TCITEM));
    tci.mask = TCIF_STATE;

    if (SUCCEEDED(XSend_TabCtrl_GetItem(m_hwnd, TCM_GETITEM, varChild.lVal-1, &tci)))
    {
        if (tci.dwState & TCIS_BUTTONPRESSED)
            pvarState->lVal |= STATE_SYSTEM_PRESSED;
    } else
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
    }

    if( IsClippedByWindow( this, varChild, m_hwnd ) )
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
    }

    // It is always selectable
    pvarState->lVal |= STATE_SYSTEM_SELECTABLE;
    
    // Is this the current one?
    if (SendMessage(m_hwnd, TCM_GETCURSEL, 0, 0) == (varChild.lVal-1))
        pvarState->lVal |= STATE_SYSTEM_SELECTED;
    
    if (MyGetFocus() == m_hwnd)
    {
        pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
        
        if (SendMessage(m_hwnd, TCM_GETCURFOCUS, 0, 0) == (varChild.lVal-1))
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;
    }
    
    
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accFocus(VARIANT* pvarChild)
{
    HRESULT hr;
    long    lCur;

    hr = CClient::get_accFocus(pvarChild);
    if (!SUCCEEDED(hr) || (pvarChild->vt != VT_I4) || (pvarChild->lVal != 0))
        return(hr);

    //
    // This window has the focus.
    //
    lCur = SendMessageINT(m_hwnd, TCM_GETCURFOCUS, 0, 0L);
    pvarChild->lVal = lCur+1;

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CTabControl32::get_accSelection()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accSelection(VARIANT* pvarChild)
{
    long    lCur;

    InitPvar(pvarChild);

    lCur = SendMessageINT(m_hwnd, TCM_GETCURSEL, 0, 0L);
    if (lCur != -1)
    {
        pvarChild->vt = VT_I4;
        pvarChild->lVal = lCur+1;
        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::get_accDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::get_accDefaultAction(VARIANT varChild, BSTR* pszDefAction)
{
    InitPv(pszDefAction);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accDefaultAction(varChild, pszDefAction));

    return(HrCreateString(STR_TAB_SWITCH, pszDefAction));
}



// --------------------------------------------------------------------------
//
//  CTabControl32::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::accSelect(long flags, VARIANT varChild)
{
    if (!ValidateChild(&varChild) || !ValidateSelFlags(flags))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accSelect(flags, varChild));

    if (flags & ~(SELFLAG_TAKEFOCUS | SELFLAG_TAKESELECTION))
        return(E_NOT_APPLICABLE);

    if (flags & SELFLAG_TAKEFOCUS)
    {
        MySetFocus(m_hwnd);

        SendMessage(m_hwnd, TCM_SETCURFOCUS, varChild.lVal-1, 0);
    }

    if (flags & SELFLAG_TAKESELECTION)
        SendMessage(m_hwnd, TCM_SETCURSEL, varChild.lVal-1, 0);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
LPRECT  lprcShared;
HANDLE  hProcess;
RECT    rcLocation;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    //
    // Get the tab item rect
    //
    lprcShared = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
    if (!lprcShared)
        return(E_OUTOFMEMORY);

    if (SendMessage(m_hwnd, TCM_GETITEMRECT, varChild.lVal-1, (LPARAM)lprcShared))
    {
        SharedRead (lprcShared,&rcLocation,sizeof(RECT),hProcess);

        MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcLocation, 2);

        *pxLeft = rcLocation.left;
        *pyTop = rcLocation.top;
        *pcxWidth = rcLocation.right - rcLocation.left;
        *pcyHeight = rcLocation.bottom - rcLocation.top;
    }

    SharedFree(lprcShared,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::accNavigate()
//
//  BOGUS!  Doesn't handle multiple row or vertical right now.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::accNavigate(long dwNavFlags, VARIANT varStart,
    VARIANT* pvarEnd)
{
    long    lEnd;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) || !ValidateNavDir(dwNavFlags, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavFlags == NAVDIR_FIRSTCHILD)
        dwNavFlags = NAVDIR_NEXT;
    else if (dwNavFlags == NAVDIR_LASTCHILD)
    {
        varStart.lVal = m_cChildren + 1;
        dwNavFlags = NAVDIR_PREVIOUS;
    }
    else if (!varStart.lVal)
        return(CClient::accNavigate(dwNavFlags, varStart, pvarEnd));

    switch (dwNavFlags)
    {
        case NAVDIR_NEXT:
        case NAVDIR_RIGHT:
            lEnd = varStart.lVal + 1;
            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
        case NAVDIR_LEFT:
            lEnd = varStart.lVal - 1;
            break;

        default:
            lEnd = 0;
            break;
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;

        return(S_OK);
    }
    else
        return(S_FALSE);
}




// --------------------------------------------------------------------------
//
//  CTabControl32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::accHitTest(long x, long y, VARIANT* pvarHit)
{
HRESULT         hr;
long            lItem;
LPTCHITTESTINFO lptchShared;
HANDLE          hProcess;
POINT           ptTest;

    InitPvar(pvarHit);

    // Is the point in us?
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4))
        return(hr);

    // What item is this over?
    lptchShared = (LPTCHITTESTINFO)SharedAlloc(sizeof(TCHITTESTINFO),m_hwnd,&hProcess);
    if (!lptchShared)
        return(E_OUTOFMEMORY);

    ptTest.x = x;
    ptTest.y = y;
    ScreenToClient(m_hwnd, &ptTest);

    SharedWrite(&ptTest,&lptchShared->pt,sizeof(POINT),hProcess);

    lItem = SendMessageINT(m_hwnd, TCM_HITTEST, 0, (LPARAM)lptchShared);

    SharedFree(lptchShared,hProcess);

    // Note that if the point isn't over an item, TCM_HITTEST returns -1, 
    // and -1+1 is zero, which is self.
    pvarHit->vt = VT_I4;
    pvarHit->lVal = lItem+1;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTabControl32::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTabControl32::accDoDefaultAction(VARIANT varChild)
{
RECT		rcLoc;

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accDoDefaultAction(varChild));

	accLocation(&rcLoc.left,&rcLoc.top,&rcLoc.right,&rcLoc.bottom,varChild);
	
    // this will check if WindowFromPoint at the click point is the same
	// as m_hwnd, and if not, it won't click. Cool!
	if (ClickOnTheRect(&rcLoc,m_hwnd,FALSE))
		return (S_OK);

    return(E_NOT_APPLICABLE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\tabctrl.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TABCTRL.H
//
//  Knows how to talk to COMCTL32's tab control
//
// --------------------------------------------------------------------------

class CTabControl32 : public CClient
{
    public:
        // IAccessible
        virtual STDMETHODIMP    get_accName(VARIANT, BSTR*);
        virtual STDMETHODIMP    get_accRole(VARIANT, VARIANT*);
        virtual STDMETHODIMP    get_accState(VARIANT, VARIANT*);
        virtual STDMETHODIMP    get_accKeyboardShortcut(VARIANT, BSTR*);
        virtual STDMETHODIMP    get_accFocus(VARIANT*);
        virtual STDMETHODIMP    get_accSelection(VARIANT*);
        virtual STDMETHODIMP    get_accDefaultAction(VARIANT, BSTR*);

        virtual STDMETHODIMP    accSelect(long, VARIANT);
        virtual STDMETHODIMP    accLocation(long*, long*, long*, long*, VARIANT);
        virtual STDMETHODIMP    accNavigate(long, VARIANT, VARIANT*);
        virtual STDMETHODIMP    accHitTest(long, long, VARIANT*);
        virtual STDMETHODIMP    accDoDefaultAction(VARIANT);

        // constructor
        CTabControl32(HWND, long);

        // other methods
        void                    SetupChildren(void);

    private:
        STDMETHODIMP            GetTabControlString(int ChildIndex,LPTSTR* ppszName);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\titlebar.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TITLEBAR.CPP
//
//  Title bar class.
//
//  NOTE:
//  Every time we make a drawing, hittesting change to USER for titlebars,
//  update this file also!  I.E. when you
//      (1) Add a titlebar element like a new button
//      (2) Change the spacing like margins
//      (3) Add a new type of titlebar beyond normal/small
//      (4) Shuffle the layout
//
//  ISSUES:
//      (1) Need "button down" info from USER and hence a shared <oleuser.h>
//      (2) Need "hovered" info from USER
//      (3) For FE, we need a SC_IME system command.  The TrackIMEButton()
//          code does the command in line, unlike all other titlebar buttons.
//          This makes it not programmable.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "window.h"
#include "client.h"
#include "titlebar.h"


// --------------------------------------------------------------------------
//
//  CreateTitleBarObject()
//
// --------------------------------------------------------------------------
HRESULT CreateTitleBarObject(HWND hwnd, long idObject, REFIID riid, void** ppvTitle)
{
    UNUSED(idObject);

    return(CreateTitleBarThing(hwnd, 0, riid, ppvTitle));
}


// --------------------------------------------------------------------------
//
//  CreateTitleBarThing()
//
// --------------------------------------------------------------------------
HRESULT CreateTitleBarThing(HWND hwnd, long iChildCur, REFIID riid, void** ppvTitle)
{
    CTitleBar * ptitlebar;
    HRESULT hr;

    InitPv(ppvTitle);

    ptitlebar = new CTitleBar();
    if (ptitlebar)
    {
        if (! ptitlebar->FInitialize(hwnd, iChildCur))
        {
            delete ptitlebar;
            return(E_FAIL);
        }
    }
    else
        return(E_OUTOFMEMORY);

    hr = ptitlebar->QueryInterface(riid, ppvTitle);
    if (!SUCCEEDED(hr))
        delete ptitlebar;

    return(hr);
}




// --------------------------------------------------------------------------
//
//  GetRealChild()
//
// --------------------------------------------------------------------------
long GetRealChild(DWORD dwStyle, LONG lChild)
{
    switch (lChild)
    {
        case INDEX_TITLEBAR_MINBUTTON:
            if (dwStyle & WS_MINIMIZE)
                lChild = INDEX_TITLEBAR_RESTOREBUTTON;
            break;

        case INDEX_TITLEBAR_MAXBUTTON:
            if (dwStyle & WS_MAXIMIZE)
                lChild = INDEX_TITLEBAR_RESTOREBUTTON;
            break;
    }

    return(lChild);
}



// --------------------------------------------------------------------------
//
//  CTitleBar::FInitialize
//
// --------------------------------------------------------------------------
BOOL CTitleBar::FInitialize(HWND hwndTitleBar, LONG iChildCur)
{
    if (! IsWindow(hwndTitleBar))
        return(FALSE);

    m_hwnd = hwndTitleBar;
    m_cChildren = CCHILDREN_TITLEBAR;
    m_idChildCur = iChildCur;

    return(TRUE);
}



// --------------------------------------------------------------------------
//
//  CTitleBar::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::Clone(IEnumVARIANT ** ppenum)
{
    return(CreateTitleBarThing(m_hwnd, m_idChildCur, IID_IEnumVARIANT, (void**)ppenum));
}



// --------------------------------------------------------------------------
//
//  CTitleBar::get_accName()
//
//  Returns the proper noun name of the object.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::get_accName(VARIANT varChild, BSTR * pszName)
{
    long    index;
    LONG    dwStyle;

    InitPv(pszName);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    // The titlebar doesn't have a name itself
    if (!varChild.lVal)
        return(S_FALSE);

    //
    // Figure out what string to _really_ load (depends on window state)
    //
    dwStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    index = GetRealChild(dwStyle, varChild.lVal);

    return(HrCreateString(STR_TITLEBAR_NAME+index, pszName));
}



// --------------------------------------------------------------------------
//
//  CTitleBar::get_accValue()
//
//  The value of the titlebar itself is the text inside.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    InitPv(pszValue);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // Only the titlebar has a value, the child buttons don't.
    //
    if (varChild.lVal)
        //CWO, 1/16/97, Changed to S_FALSE from E_NOT_APPLICABLE
        return(S_FALSE);

    return(HrGetWindowName(m_hwnd, FALSE, pszValue));
}




// --------------------------------------------------------------------------
//
//  CTitleBar::get_accDescription()
//
//  Returns a full sentence describing the object.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::get_accDescription(VARIANT varChild, BSTR * pszDesc)
{
    long    index;
    LONG    dwStyle;

    InitPv(pszDesc);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // Figure out what string to _really_ load, depends on state.
    //
    dwStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    index = GetRealChild(dwStyle, varChild.lVal);

    return(HrCreateString(STR_TITLEBAR_DESCRIPTION+index, pszDesc));
}



// --------------------------------------------------------------------------
//
//  CTitleBar::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::get_accRole(VARIANT varChild, VARIANT * pvarRole)
{
    InitPvar(pvarRole);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    if (varChild.lVal == INDEX_TITLEBAR_SELF)
        pvarRole->lVal = ROLE_SYSTEM_TITLEBAR;
    else
        pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTitleBar::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    TITLEBARINFO    ti;

    InitPvar(pvarState);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (! MyGetTitleBarInfo(m_hwnd, &ti) ||
        (ti.rgstate[INDEX_TITLEBAR_SELF] & STATE_SYSTEM_INVISIBLE))
    {
        pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        return(S_OK);
    }

    pvarState->lVal |= ti.rgstate[INDEX_TITLEBAR_SELF];
    pvarState->lVal |= ti.rgstate[varChild.lVal];

	// only the title bar itself is focusable.
	if (varChild.lVal != INDEX_TITLEBAR_SELF)
		pvarState->lVal &= ~STATE_SYSTEM_FOCUSABLE;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTitleBar::get_accDefaultAction()
//
//  NOTE:  only the buttons have default actions.  The default action of
//  the system menu is ambiguous, since it is unknown until the window
//  enters menu mode.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::get_accDefaultAction(VARIANT varChild, BSTR*
    pszDefAction)
{
    long index;
    LONG dwStyle;

    InitPv(pszDefAction);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(E_NOT_APPLICABLE);

    //
    // Get the string
    //
    dwStyle = GetWindowLong(m_hwnd, GWL_STYLE);
    index = GetRealChild(dwStyle, varChild.lVal);

    //
    // BOGUS!  The IME button doesn't have a def action either since
    // we can't change the keyboard layout indirectly via WM_SYSCOMMAND.
    // The IME code does the work in line.  We need to make an SC_.
    //
    if (index <= INDEX_TITLEBAR_IMEBUTTON)
        return(E_NOT_APPLICABLE);

    return(HrCreateString(STR_BUTTON_PUSH, pszDefAction));
}


// --------------------------------------------------------------------------
//
//  CTitleBar::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::accSelect(long flagsSel, VARIANT varChild)
{
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! ValidateSelFlags(flagsSel))
        return(E_INVALIDARG);

	if (flagsSel & SELFLAG_TAKEFOCUS)
	{
		if (varChild.lVal == CHILDID_SELF)
		{
            MySetFocus(m_hwnd);
			return (S_OK);
		}
	}

    return(E_NOT_APPLICABLE);
}

// --------------------------------------------------------------------------
//
//  CTitleBar::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT * pvarEnd)
{
    TITLEBARINFO    ti;
    long        lEndUp;

    InitPvar(pvarEnd);

    if (! ValidateChild(&varStart) ||
        ! ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (! MyGetTitleBarInfo(m_hwnd, &ti))
        return(S_FALSE);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        dwNavDir = NAVDIR_PREVIOUS;
        varStart.lVal = m_cChildren + 1;
    }
    else if (varStart.lVal == INDEX_TITLEBAR_SELF)
        return(GetParentToNavigate(OBJID_TITLEBAR, m_hwnd,
            OBJID_WINDOW, dwNavDir, pvarEnd));

    //
    // NOTE:  It is up to the caller to make sure the item navigation
    // is starting from is visible.
    //
    switch (dwNavDir)
    {
        case NAVDIR_LEFT:
        case NAVDIR_PREVIOUS:
            // 
            // Is there anything to the left of us?
            //
            lEndUp = varStart.lVal;
            while (--lEndUp >= INDEX_TITLEBAR_MIC)
            {
                if (!(ti.rgstate[lEndUp] & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEndUp < INDEX_TITLEBAR_MIC)
                lEndUp = 0;
            break;

        case NAVDIR_RIGHT:
        case NAVDIR_NEXT:
            //
            // Is there anything to the right of us?
            //
            lEndUp = varStart.lVal;
            while (++lEndUp <= INDEX_TITLEBAR_MAC)
            {
                if (!(ti.rgstate[lEndUp] & STATE_SYSTEM_INVISIBLE))
                    break;
            }

            if (lEndUp > INDEX_TITLEBAR_MAC)
                lEndUp = 0;
            break;

        default:
            lEndUp = 0;
            break;
    }

    if (lEndUp)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEndUp;
        return(S_OK);
    }
    else
        return(S_FALSE);
}




// --------------------------------------------------------------------------
//
//  CTitleBar::accLocation()
//
//  Gets the screen rect of a particular element.  If the item isn't
//  actually present, this will fail.
//
//  NOTE:  It is up to the caller to make sure that the container (titlebar)
//  is visible before calling accLocation on a child.
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    int     cyBorder;
    int     cxyButton;
    TITLEBARINFO ti;
    int     index;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! MyGetTitleBarInfo(m_hwnd, &ti))
        return(S_FALSE);

    //
    // If this object isn't around, fail.
    //
    if ((ti.rgstate[INDEX_TITLEBAR_SELF] & (STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN)) ||
        (ti.rgstate[varChild.lVal] & STATE_SYSTEM_INVISIBLE))
    {
        return(S_FALSE);
    }

    cyBorder = GetSystemMetrics(SM_CYBORDER);
    cxyButton = ti.rcTitleBar.bottom - ti.rcTitleBar.top - cyBorder;

    if (varChild.lVal == INDEX_TITLEBAR_SELF)
    {
        *pxLeft     = ti.rcTitleBar.left;
        *pyTop      = ti.rcTitleBar.top;
        *pcxWidth   = ti.rcTitleBar.right - ti.rcTitleBar.left;
        *pcyHeight  = ti.rcTitleBar.bottom - ti.rcTitleBar.top;
    }
    else
    {
        *pyTop      = ti.rcTitleBar.top;
        *pcxWidth   = cxyButton;
        *pcyHeight  = cxyButton;

        // Where is the left side of the button?  Our INDEX_s are
        // conveniently defined in left-to-right order.  Start at the
        // end and work backwards to the system menu.  Subtract cxyButton
        // when a child is present.
        *pxLeft     = ti.rcTitleBar.right - cxyButton;
        for (index = INDEX_TITLEBAR_MAC; index > INDEX_TITLEBAR_SELF; index--)
        {
            if (index == varChild.lVal)
                break;

            if (!(ti.rgstate[index] & STATE_SYSTEM_INVISIBLE))
                *pxLeft -= cxyButton;
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTitleBar::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::accHitTest(long xLeft, long yTop, VARIANT* pvarChild)
{
    POINT   pt;
    int     cxyButton;
    int     index;
    TITLEBARINFO    ti;

    InitPvar(pvarChild);

    if (! MyGetTitleBarInfo(m_hwnd, &ti) ||
        (ti.rgstate[INDEX_TITLEBAR_SELF] & (STATE_SYSTEM_INVISIBLE || STATE_SYSTEM_OFFSCREEN)))
        return(S_FALSE);

    pt.x = xLeft;
    pt.y = yTop;

    // 
    // We return VT_EMPTY when the point isn't in the titlebar at all.
    //
    if (! PtInRect(&ti.rcTitleBar, pt))
        return(S_FALSE);

    pvarChild->vt = VT_I4;
    pvarChild->lVal = INDEX_TITLEBAR_SELF;

    cxyButton = ti.rcTitleBar.bottom - ti.rcTitleBar.top - GetSystemMetrics(SM_CYBORDER);

    // If yTop is greater than this, the point is on the border drawn below
    // the caption
    if (yTop < ti.rcTitleBar.top + cxyButton)
    {
        //
        // Start at the right side and work backwards.
        //
        pt.x = ti.rcTitleBar.right - cxyButton;

        for (index = INDEX_TITLEBAR_MAC; index > INDEX_TITLEBAR_SELF; index--)
        {
            //
            // This child is here.
            //
            if (!(ti.rgstate[index] & STATE_SYSTEM_INVISIBLE))
            {
                //
                // Is this point where this child is?
                //
                if (xLeft >= pt.x)
                {
                    pvarChild->lVal = index;
                    break;
                }

                pt.x -= cxyButton;
            }
        }
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CTitleBar::accDoDefaultAction()
//
// --------------------------------------------------------------------------
STDMETHODIMP CTitleBar::accDoDefaultAction(VARIANT varChild)
{
    WPARAM  scCommand = 0;
    int     index;
    TITLEBARINFO    ti;

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // We return nothing for the titlebar & system menu objects.  Hence it
    // is a real error to attempt to do the default action  on them.
    //
    if (varChild.lVal <= INDEX_TITLEBAR_IMEBUTTON)
        return(E_NOT_APPLICABLE);

    if (! MyGetTitleBarInfo(m_hwnd, &ti) ||
        (ti.rgstate[INDEX_TITLEBAR_SELF] & STATE_SYSTEM_INVISIBLE))
        return(S_FALSE);


    //
    // We do NOT do the default action of an object that is invisible.
    //
    if (ti.rgstate[varChild.lVal] & STATE_SYSTEM_INVISIBLE)
        return(S_FALSE);

    index = GetRealChild(GetWindowLong(m_hwnd, GWL_STYLE), varChild.lVal);

    switch (index)
    {
        case INDEX_TITLEBAR_MINBUTTON:
            scCommand = SC_MINIMIZE;
            break;

        case INDEX_TITLEBAR_HELPBUTTON:
            scCommand = SC_CONTEXTHELP;
            break;

        case INDEX_TITLEBAR_MAXBUTTON:
            scCommand = SC_MAXIMIZE;
            break;

        case INDEX_TITLEBAR_RESTOREBUTTON:
            scCommand = SC_RESTORE;
            break;

        case INDEX_TITLEBAR_CLOSEBUTTON:
            scCommand = SC_CLOSE;
            break;

        default:
            AssertStr( TEXT("Invalid ChildID for child of titlebar") );
    }

    //
    // Context help puts into a modal loop, which will block the calling
    // thread until the loop ends.  Hence we post this instead of sending it.
    //
    // Note that we will no doubt do something similar in menus.
    //
    PostMessage(m_hwnd, WM_SYSCOMMAND, scCommand, 0L);
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\toolbar.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TOOLBAR.H
//
//  This communicates with COMCTL32's tool bar control.
//
// --------------------------------------------------------------------------


class CToolBar32 : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accName(VARIANT, BSTR*);
        STDMETHODIMP    get_accRole(VARIANT, VARIANT*);
        STDMETHODIMP    get_accState(VARIANT, VARIANT*);
        STDMETHODIMP    get_accKeyboardShortcut(VARIANT, BSTR*);
        STDMETHODIMP    get_accDefaultAction(VARIANT, BSTR*);

        STDMETHODIMP    accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP    accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP    accHitTest(long, long, VARIANT*);
        STDMETHODIMP    accDoDefaultAction(VARIANT);

        // IEnumVARIANT
        STDMETHODIMP    Next(ULONG celt, VARIANT *rgvar, ULONG* pceltFetched);

        // constructor
        CToolBar32(HWND, long);

        // misc. methods
        BOOL                GetItemData(int, LPTBBUTTON);
        void                SetupChildren();

    private:
        STDMETHODIMP    GetToolbarString(int ChildId, LPTSTR* ppszName);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\strtable.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

#define STR_CARETNAME                   100

#define STR_CURSORNAMEFIRST             110

#define STR_TITLEBAR_NAME               140
#define STR_TITLEBAR_IMEBUTTON_NAME     141
#define STR_TITLEBAR_MINBUTTON_NAME     142
#define STR_TITLEBAR_MAXBUTTON_NAME     143
#define STR_TITLEBAR_HELPBUTTON_NAME    144
#define STR_TITLEBAR_CLOSEBUTTON_NAME   145
#define STR_TITLEBAR_RESTOREBUTTON_NAME 146

#define STR_TITLEBAR_DESCRIPTION        150
#define STR_TITLEBAR_SHORTCUT           160

#define STR_SCROLLBAR_NAME              180
#define STR_SCROLLBAR_DESCRIPTION       200

#define STR_MENUBAR_NAME                250
#define STR_SYSMENU_NAME                251
#define STR_MENUBAR_DESCRIPTION         252
#define STR_SYSMENUBAR_DESCRIPTION      253
#define STR_MENU_SHORTCUT               254
#define STR_MENU_SHORTCUT_FORMAT        255
#define STR_SYSMENU_KEY                 256
#define STR_CHILDSYSMENU_KEY            257
#define STR_EXECUTE                     258

#define STR_SHIFT                       259
#define STR_CONTROL                     260
#define STR_ALT                         STR_MENU_SHORTCUT
#define STR_CHILDSYSMENU_NAME           261
#define STR_STARTBUTTON_SHORTCUT		262
#define STR_CONTEXT_MENU                263
#define STR_DOCMENU_NAME				264
#define STR_DOUBLE_CLICK                265
#define STR_CLICK                       266

#define STR_WINDOW_NAME                 270
#define STR_STARTBUTTON                 271
#define STR_SPIN_GREATER                272
#define STR_SPIN_LESSER                 273
#define STR_TRAY                        274
#define STR_HOTKEY_NONE                 275

#define STR_COMBOBOX_LIST_SHORTCUT      280
#define STR_DROPDOWN_SHOW               285
#define STR_DROPDOWN_HIDE               286


#define STR_ALTTAB_NAME                 290
#define STR_ALTTAB_DESCRIPTION          291
#define STR_TAB_SWITCH                  292
#define STR_MDICLI_NAME                 293
#define STR_DESKTOP_NAME                294
#define STR_PERCENTAGE_FORMAT           295

#define STR_TREE_EXPAND                 305
#define STR_TREE_COLLAPSE               306

#define STR_HTML_JUMP                   307
#define STR_BUTTON_PUSH                 308
#define STR_BUTTON_CHECK                309
#define STR_BUTTON_UNCHECK              310
#define STR_BUTTON_HALFCHECK            311

#define STR_DESC_IP_PART				320

#define STR_STATEFIRST                  1000
#define STR_ROLEFIRST                   1100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\static.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  STATIC.H
//
//  Static object
//
// --------------------------------------------------------------------------

class   CStatic :   public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT *pvarRole);
		STDMETHODIMP	get_accState(VARIANT varChild, VARIANT *pvarState);

        CStatic(HWND, long);

    protected:
        BOOL    m_fGraphic;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\titlebar.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TITLEBAR.H
//
//  Titlebar ole accessibility implementation
//
// --------------------------------------------------------------------------

//
// BOGUS!  Do we implement QueryInterface() and respond to ITextDocument etc.
// if OSM is around?
//

class   CTitleBar :   public  CAccessible
{
    public:

        CTitleBar()
            : CAccessible( CLASS_TitleBarObject )
        {
            // Done.
        }

        // IAccessible
        STDMETHODIMP        get_accName(VARIANT varChild, BSTR * pszName);
        STDMETHODIMP        get_accValue(VARIANT, BSTR*);
        STDMETHODIMP        get_accDescription(VARIANT varChild, BSTR * pszDesc);
        STDMETHODIMP        get_accRole(VARIANT varChild, VARIANT * lpRole);
        STDMETHODIMP        get_accState(VARIANT varChild, VARIANT * lpRole);
        STDMETHODIMP        get_accDefaultAction(VARIANT varChild, BSTR * pszDefAction);

        STDMETHODIMP        accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
            long* pcyHeight, VARIANT varChild);
        STDMETHODIMP        accNavigate(long narDir, VARIANT varStart,
            VARIANT * pvarEndUpAt);
        STDMETHODIMP        accHitTest(long xLeft, long yTop, VARIANT * pvarChild);
        STDMETHODIMP        accDoDefaultAction(VARIANT varChild);
		STDMETHODIMP		accSelect(long flagsSel, VARIANT varChild);

        // IEnumVARIANT
        STDMETHODIMP        Clone(IEnumVARIANT** ppenum);

        BOOL                FInitialize(HWND hwnd, LONG iChildCur);
};


//
// Helper functions
//
HRESULT     CreateTitleBarThing(HWND hwnd, long idObject, REFIID riid, void** ppvObject);
long        GetRealChild(DWORD dwStyle, LONG lChild);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\toolbar.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TOOLBAR.CPP
//
//  This knows how to talk to COMCTL32's tool bar control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"

#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOPROGRESS
#define NOHOTKEY
#define NOTREEVIEW
#define NOANIMATE
#include <commctrl.h>
#include "Win64Helper.h"
#include <tchar.h>

#include "toolbar.h"

#define MAX_NAME_SIZE   128 


#ifndef I_IMAGENONE
#define I_IMAGENONE             (-2)
#endif


// --------------------------------------------------------------------------
//
//  CreateToolBarClient()
//
//  EXTERNAL for CreateClientObject()
//
// --------------------------------------------------------------------------
HRESULT CreateToolBarClient(HWND hwnd, long idChildCur, REFIID riid, void** ppvTool)
{
    HRESULT hr;
    CToolBar32* ptool;

    InitPv(ppvTool);

    ptool = new CToolBar32(hwnd, idChildCur);
    if (! ptool)
        return(E_OUTOFMEMORY);

    hr = ptool->QueryInterface(riid, ppvTool);
    if (!SUCCEEDED(hr))
        delete ptool;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CToolBar32::CToolBar32()
//
// --------------------------------------------------------------------------
CToolBar32::CToolBar32(HWND hwnd, long idChildCur)
    : CClient( CLASS_ToolBarClient )
{
    Initialize(hwnd, idChildCur);
}



// --------------------------------------------------------------------------
//
//  CToolBar32::SetupChildren()
//
//  We need the # of buttons, plus 1 if there is a window child.
//
// --------------------------------------------------------------------------
void CToolBar32::SetupChildren()
{
    m_cChildren = SendMessageINT(m_hwnd, TB_BUTTONCOUNT, 0, 0);

    if (::GetWindow(m_hwnd,GW_CHILD))
        m_cChildren++;
}



// --------------------------------------------------------------------------
//
//  CToolBar32::GetItemData()
//
//  This gets the data from a button in the toolbar, the command ID, the 
//  state, the style, etc.  We need the command ID for example to pass to
//  most TB_ messages instead of the index.
//
// --------------------------------------------------------------------------
BOOL CToolBar32::GetItemData(int itemID, LPTBBUTTON lptbResult)
{
LPTBBUTTON  lptbShared;
BOOL        fReturn;
HANDLE      hProcess;

    fReturn = FALSE;

    // Allocate a TBBUTTON struct from shared memory.  The last member in
	// TBBUTTON is an INT_PTR (iString) which isn't used by OLEACC.  For
	// 32b, in case we're making a cross-proc call to a 64b server, we'll
	// add an extra DWORD onto the end of the memory we allocate so the struct
	// is correctly sized for a 64b server.  When reading back the lower
	// DWORD is lopped off.

	UINT ccbTButton = sizeof(TBBUTTON);
#ifdef _WIN32
	ccbTButton += sizeof(DWORD);
#endif

    lptbShared = (LPTBBUTTON)SharedAlloc(ccbTButton,m_hwnd,&hProcess);
    if (lptbShared)
    {
        if (SendMessage(m_hwnd, TB_GETBUTTON, itemID-1, (LPARAM)lptbShared))
        {
            SharedRead (lptbShared,lptbResult,sizeof(TBBUTTON),hProcess);
            fReturn = TRUE;
        }

        SharedFree(lptbShared,hProcess);
    }

    return(fReturn);
}



// --------------------------------------------------------------------------
//
//  CToolBar32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::get_accName(VARIANT varChild, BSTR* pszName)
{
LPTSTR  lpszName = NULL;
HRESULT hr;

    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::get_accName(varChild, pszName));

    // if child id is not zero (CHILDID_SELF)...
    hr = GetToolbarString (varChild.lVal,&lpszName);
    if( ! lpszName )
        return (hr); // will be S_FALSE or an E_error_code

    if (*lpszName)
    {
        StripMnemonic(lpszName);
        *pszName = TCharSysAllocString(lpszName);
    }

	LocalFree (lpszName);
    
    return(*pszName ? S_OK : S_FALSE);


}


// --------------------------------------------------------------------------
//
//  CToolBar32::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
TCHAR   chMnemonic = 0;
LPTSTR  lpszName = NULL;
HRESULT hr;

    InitPv(pszShortcut);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::get_accKeyboardShortcut(varChild, pszShortcut));

    // if child id is not zero (CHILDID_SELF)...
    hr = GetToolbarString (varChild.lVal,&lpszName);
    if ( ! lpszName )
        return (hr); // will be S_FALSE or E_error_code...

    if (*lpszName)
		chMnemonic = StripMnemonic(lpszName);

	LocalFree (lpszName);

	//
	// Is there a mnemonic?
	//
	if (chMnemonic)
	{
		//
		// Make a string of the form "Alt+ch".
		//
		TCHAR   szKey[2];

		*szKey = chMnemonic;
		*(szKey+1) = 0;

		return(HrMakeShortcut(szKey, pszShortcut));
	}

    return(S_FALSE);

}


// --------------------------------------------------------------------------
//
//  CToolBar32::GetToolbarString()
//
// Get the name of the item on the toolbar. There are two ways to do this - 
// You can just ask using the standard messages, or if that fails, you
// can try to get it from a tooltip. Since we need to do this for both name 
// and keyboard shortcut, we'll write a private method to get the 
// unstripped name.
//
// Parameters:
//		int	ChildId	        - the Child ID (1 based) of the item we want to get
//		LPTSTR*	ppszName	- pointer that will be LocalAlloc'ed and filled
//							  in with the name. Caller must LocalFree it.
//
//	Returns:
//
//      On Success:
//        returns S_TRUE, *ppszName will be non-NULL, caller must LocalFree() it.
//
//      On Failure:
//		  returns S_FALSE - no name available. *ppszName set to NULL.
//		  ...or...
//		  returns COM Failure code (including E_OUTOFMEMORY) - com/memory error.
//		  *ppszName set to NULL.
//
// Note: caller should take care if using "FAILED( hr )" to examine the return
// value of this method, since it does treats both S_OK and S_FALSE as 'success'.
// It may be better to check that *ppszName is non-NULL.
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::GetToolbarString(int ChildId, LPTSTR* ppszName)
{
LPTSTR      lpszTextShared;
int         cchText;
int         nSomeInt;
TBBUTTON    tb;
HANDLE      hProcess;
LPTSTR      pszName = NULL;

	// Set this to NULL now, in case we return an error code (or S_FALSE) later...
    // (We'll set it to a valid return value later if we succeed...)
    *ppszName = NULL;

    // Get the button ID
    if (!GetItemData(ChildId, &tb))
        return(S_FALSE);

    //
    // Get the button text length.  NOTE:  If this is a separator item
    // then just return empty now.
    //
    if (tb.fsStyle & TBSTYLE_SEP)
        return(S_FALSE);

    cchText = SendMessageINT(m_hwnd, TB_GETBUTTONTEXT, tb.idCommand, 0);
    if (cchText && (cchText != -1))
    {
        // Allocate a buffer to hold it
        lpszTextShared = (LPTSTR)SharedAlloc((cchText+1)*sizeof(TCHAR),
                                        m_hwnd,&hProcess);

        if (! lpszTextShared)
            return(E_OUTOFMEMORY);

        pszName =  (LPTSTR)LocalAlloc(LPTR,(cchText+1)*sizeof(TCHAR));
        if (! pszName)
        {
            SharedFree (lpszTextShared,hProcess);
            return(E_OUTOFMEMORY);
        }

        // Get the button text
        nSomeInt = 0;
        SharedWrite (&nSomeInt,lpszTextShared,sizeof(int),hProcess);

        SendMessage(m_hwnd, TB_GETBUTTONTEXT, tb.idCommand, (LPARAM)lpszTextShared);

        SharedRead (lpszTextShared,pszName,(cchText+1)*sizeof(TCHAR),hProcess);
        SharedFree(lpszTextShared,hProcess);
    }
    else // Button has no text, so use tooltip method.
    {
        if ( ! GetTooltipStringForControl( m_hwnd, TB_GETTOOLTIPS, tb.idCommand, & pszName ) )
        {
            return S_FALSE;
        }
	}

	// At this stage, local var pszName points to a (possibly) empty string.
	// We deal with that next...

    // Paranoia...
    if( ! pszName )
    {
        return S_FALSE;
    }

    // do we have a non-empty string?
    if( *pszName )
	{
		*ppszName = pszName;
        return S_OK;
	}
	else
	{
		// Free the 'empty' pszName...
		LocalFree( pszName );
		return S_FALSE;
	}
}


// --------------------------------------------------------------------------
//
//  CToolBar32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
    {
        pvarRole->vt = VT_I4;
        pvarRole->lVal = ROLE_SYSTEM_TOOLBAR;
    }
    else
    {
        TBBUTTON tb;

        // Get the button type (checkbox, radio, or push).
        if (!GetItemData(varChild.lVal, &tb))
            return(S_FALSE);

        pvarRole->vt = VT_I4;

        BOOL bHasImageList = SendMessage( m_hwnd, TB_GETIMAGELIST, 0, 0 ) != 0;
	    DWORD dwExStyle = SendMessageINT( m_hwnd, TB_GETEXTENDEDSTYLE, 0, 0 );

        // If a separator, say so
		if (tb.fsStyle & TBSTYLE_SEP)
            pvarRole->lVal = ROLE_SYSTEM_SEPARATOR;
        else if (tb.fsStyle & TBSTYLE_CHECK)
        {
            // Special case for task list - they use the checked style, but only for visuals...
            TCHAR szClassName[ 64 ];
            HWND hwndParent = GetParent( m_hwnd );
            if ( hwndParent != NULL
                && GetClassName( hwndParent, szClassName, ARRAYSIZE( szClassName ) )
                && ( lstrcmp( szClassName, TEXT("MSTaskSwWClass") ) == 0 ) )
            {
                pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
            }
            else
            {
			    // Check other possible styles
                if (tb.fsStyle & TBSTYLE_GROUP)
                    pvarRole->lVal = ROLE_SYSTEM_RADIOBUTTON;
                else
                    pvarRole->lVal = ROLE_SYSTEM_CHECKBUTTON;
            }
        }
        else if (!bHasImageList || tb.iBitmap == I_IMAGENONE )
        {
            // TODO - check that it's not a standard image (since they don't require an
            // imagelist?

            // Text-only, no bitmap, so it's effectively a menu item.
            // (eg. as used in MMC)
            pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
        }
        else if ( ( tb.fsStyle & TBSTYLE_DROPDOWN ) && ( dwExStyle & TBSTYLE_EX_DRAWDDARROWS ) )
		{
			// if its a drop down and it has an arrow its a split button
			pvarRole->lVal = ROLE_SYSTEM_SPLITBUTTON;
		}
		else
		{	
            pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
		}
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CToolBar32::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    InitPvar(pvarState);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
	{
        return CClient::get_accState( varChild, pvarState );
	}
    else
    {
        TBBUTTON tb;

        if (! GetItemData(varChild.lVal, &tb))
        {
            pvarState->vt = VT_I4;
            pvarState->lVal = STATE_SYSTEM_INVISIBLE;
            return(S_OK);
        }

        pvarState->vt = VT_I4;
        pvarState->lVal = 0;

        if (tb.fsState & TBSTATE_CHECKED)
            pvarState->lVal |= STATE_SYSTEM_CHECKED;
        if (tb.fsState & TBSTATE_PRESSED)
            pvarState->lVal |= STATE_SYSTEM_PRESSED;
        if (!(tb.fsState & TBSTATE_ENABLED))
            pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

        if (tb.fsState & TBSTATE_HIDDEN)
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
        else
        {
            if( IsClippedByWindow( this, varChild, m_hwnd ) )
            {
                pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
            }
        }

        if (tb.fsState & TBSTATE_INDETERMINATE)
            pvarState->lVal |= STATE_SYSTEM_MIXED;

        if (tb.fsStyle & TBSTYLE_ALTDRAG)
            pvarState->lVal |= STATE_SYSTEM_MOVEABLE;


        // Special case for task list - they use the checked style, but only for visuals...
        TCHAR szClassName[ 64 ];
        HWND hwndParent = GetParent( m_hwnd );
        if ( hwndParent != NULL
            && GetClassName( hwndParent, szClassName, ARRAYSIZE( szClassName ) )
            && ( lstrcmp( szClassName, TEXT("MSTaskSwWClass") ) == 0 ) )
        {
            // Change the checked state into pressed instead...
            if( pvarState->lVal & STATE_SYSTEM_CHECKED )
            {
                pvarState->lVal &= ~ STATE_SYSTEM_CHECKED;
                pvarState->lVal |= STATE_SYSTEM_PRESSED;
            }
        }


        // idChild-1 will never == -1 here, since we handle that case (id==CHILDID_SELF)
        // in the first branch of this if. (TB_GETHOTITEM returns -1 if there's no hot item.)
        if( SendMessage( m_hwnd, TB_GETHOTITEM, 0, 0 ) == varChild.lVal - 1 )
        {
            pvarState->lVal |= STATE_SYSTEM_HOTTRACKED;

            // This doesn't quite work...
            // Some apps - notably MMCs - don't actually focus their toolbar -
            // they leave their main MDI child focused. So we have no way of
            // telling whether the menu is hot because it's in 'focus' mode
            // or whether it's just because the mouse is over it (not really
            // focused).
            //
            // But at least this finally gets us the correct state for the quick
            // launch toolbar.
            if( MyGetFocus() == m_hwnd )
            {
                pvarState->lVal |= STATE_SYSTEM_FOCUSED;
            }
        }

        // What about separators?
		// CWO, 4/22/97, Separators have a state of TBSTATE_ENABLED

        return(S_OK);
    }
}



// --------------------------------------------------------------------------
//
//  CToolBar32::get_accDefaultAction()
//
//  Default action is same as the name of the button.
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::get_accDefaultAction(VARIANT varChild, BSTR* pszDef)
{
    InitPv(pszDef);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::get_accDefaultAction(varChild, pszDef));
    else
    {
        TBBUTTON tb;

        // TBSTYLE_DROP has a different default action than the name
        if (GetItemData(varChild.lVal, &tb) && (tb.fsStyle & TBSTYLE_DROPDOWN))
            return(HrCreateString(STR_DROPDOWN_SHOW, pszDef));
        else
            return(HrCreateString(STR_BUTTON_PUSH, pszDef));
    }
}



// --------------------------------------------------------------------------
//
//  CToolBar32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::accLocation(long* pxLeft, long* pyTop,
    long* pcxWidth, long* pcyHeight, VARIANT varChild)
{
    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));
    else
    {
        LPRECT  prcShared;
        HRESULT hr;
        RECT    rcLocal;
        HANDLE  hProcess;

        // Allocate a Shared RECT
        prcShared = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
        if (! prcShared)
            return(E_OUTOFMEMORY);

        // This returns FALSE if the button is hidden
        if (SendMessage(m_hwnd, TB_GETITEMRECT, varChild.lVal-1, (LPARAM)prcShared))
        {
            hr = S_OK;

            SharedRead (prcShared,&rcLocal,sizeof(RECT),hProcess);
            MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rcLocal, 2);

            *pxLeft = rcLocal.left;
            *pyTop = rcLocal.top;
            *pcxWidth = rcLocal.right - rcLocal.left;
            *pcyHeight = rcLocal.bottom - rcLocal.top;
        }
        else
            hr = S_FALSE;

        SharedFree(prcShared,hProcess);

        return(hr);
    }

}



// --------------------------------------------------------------------------
//
//  CToolBar32::accNavigate()
//
//  Toolbar clients can only set an indent on the left side.  Hence all
//  child window objects are on the left, buttons are on the right.
//
//  BOGUS!  Doesn't deal with wrapped toolbars yet.
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
    int lEnd = 0;
    TBBUTTON tb;

    InitPvar(pvarEnd);

    if ((!ValidateChild(&varStart) && !ValidateHwnd(&varStart)) ||
        !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    // Peer-to-peer navigation in nonclient
    if (!varStart.lVal && (dwNavDir < NAVDIR_FIRSTCHILD))
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

    //
    // Nav is strange, the first items on the left have the highest IDs.
    //
    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        dwNavDir = NAVDIR_PREVIOUS;
        varStart.lVal = m_cChildren + 1;
    }

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
        case NAVDIR_RIGHT:
            lEnd = varStart.lVal;

            // Toolbars can't really have windows as children - it is
            // a hack that explorer does. Because it is a hack, we know
            // that when we get starting point that is a window, it is 
            // the first child, so to naviagte next, we just move to the
            // first 'real' child. 
            // If we are trying to navigate next from 0 (the toolbar itself) 
            // we just check if the toolbar window has a child window, and 
            // return a dispatch interface to that child.
            if (lEnd == CHILDID_SELF)
            {
            HWND    hwndChild;

                if (hwndChild = ::GetWindow(m_hwnd,GW_CHILD))
                {
			        pvarEnd->vt=VT_DISPATCH;
                    return (AccessibleObjectFromWindow(hwndChild,OBJID_WINDOW,
                        IID_IDispatch, (void**)&pvarEnd->pdispVal));
                }
            }
            // just set lEnd to 0 so we get the first 'real' child
            // of the toolbar - the first button.
            if (IsHWNDID(lEnd))
                lEnd = 0;

            while (++lEnd <= m_cChildren)
            {
                //
                // Is this a visible child?
				// CWO, 4/22/97, removed separate clause
                //
                if (GetItemData(lEnd, &tb) && !(tb.fsState & TBSTATE_HIDDEN))
                    break; // out of while loop
            }

            if (lEnd > m_cChildren)
                lEnd = 0;
            break; // out of switch 

        case NAVDIR_PREVIOUS:
        case NAVDIR_LEFT:
            lEnd = varStart.lVal;

            // Navigating previous is similar to next when dealing with 
            // children that are windows. If the start point is a child
            // window, then the end point is 0, the toolbar itself. If
            // the end point (after doing normal children) is 0, then 
            // check if the toolbar has a child window and if so, return
            // a dispatch interface to that object.
            if (IsHWNDID(lEnd))
            {
                lEnd = 0;
                break; // out of switch
            }
            while (--lEnd > 0)
            {
                //
                // Is this a visible child?
                // CWO, 4/22/97, removed separate clause
				//
                if (GetItemData(lEnd, &tb) && !(tb.fsState & TBSTATE_HIDDEN))
                    break; // out of while
            }
            if (lEnd == CHILDID_SELF)
            {
            HWND    hwndChild;

                if (hwndChild = ::GetWindow(m_hwnd,GW_CHILD))
                {
			        pvarEnd->vt=VT_DISPATCH;
                    return (AccessibleObjectFromWindow(hwndChild,OBJID_WINDOW,
                        IID_IDispatch, (void**)&pvarEnd->pdispVal));
                }
            }
            break; // out of switch

        case NAVDIR_UP:
        case NAVDIR_DOWN:
            lEnd = 0;
            // Don't handle wrapping toolbars yet.
            break; // out of switch
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;
        return(S_OK);
    }

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CToolBar32::accHitTest()
//
//  First, ask the client window what is here.  If itself, then try the
//  buttons.  If nothing/child window, return that thing.
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::accHitTest(long x, long y, VARIANT* pvarHit)
{
    POINT   pt;
    LPRECT  lprcShared;
    int     iButton;
    HRESULT hr;
    RECT    rcLocal;
    HANDLE  hProcess;

    SetupChildren();

    //
    // Is this point in our client, not in any child window?
    //
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0))
        return(hr);

    pt.x = x;
    pt.y = y;
    ScreenToClient(m_hwnd, &pt);

    //
    // Figure out what button this point is over.  We have to do this the
    // hard way, by looping through the buttons asking for location.
    //
    lprcShared = (LPRECT)SharedAlloc(sizeof(RECT),m_hwnd,&hProcess);
    if (!lprcShared)
        return(E_OUTOFMEMORY);

    for (iButton = 0; iButton < m_cChildren; iButton++)
    {
        if (SendMessage(m_hwnd, TB_GETITEMRECT, iButton, (LPARAM)lprcShared))
        {
            SharedRead (lprcShared,&rcLocal,sizeof(RECT),hProcess);
            if (PtInRect(&rcLocal, pt))
            {
                pvarHit->vt = VT_I4;
                pvarHit->lVal = iButton+1;

                SharedFree(lprcShared,hProcess);
                return(S_OK);
            }
        }
    }

    //
    // If we got here, the point is not over any toolbar item.  It must be
    // over ourself.
    //

    SharedFree(lprcShared,hProcess);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CToolBar32::accDoDefaultAction()
//
//  This sends the command that the button represents.  We can't fake a click
//  because that won't work if the window isn't active.  
//
//  We have to send a WM_COMMAND, BN_CLICKED to the toolbar parent.  Problem
//  is, no easy way to get the parent.  So we set it (which returns the old
//  one, then set it back).
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::accDoDefaultAction(VARIANT varChild)
{
    HWND    hwndToolBarParent;
    TBBUTTON tb;

    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (! varChild.lVal)
        return(CClient::accDoDefaultAction(varChild));

    //
    // Get the toolbar parent in a hacky way, by setting it then setting
    // it back.  THIS CODE ASSUMES THAT THE HANDLING IS MINIMAL IN COMCTL32.
    //
    hwndToolBarParent = (HWND)SendMessage(m_hwnd, TB_SETPARENT, 0, 0);
    SendMessage(m_hwnd, TB_SETPARENT, (WPARAM)hwndToolBarParent, 0);

    if (! hwndToolBarParent)
        return(S_FALSE);

    //
    // Get the command ID of this button, and generate a BN_CLICK if it
    // isn't a separator.
    //
    if (GetItemData(varChild.lVal, &tb) &&
        !(tb.fsStyle & TBSTYLE_SEP) &&
        (tb.fsState & TBSTATE_ENABLED) &&
        !(tb.fsState & TBSTATE_HIDDEN))
    {
        PostMessage(hwndToolBarParent, WM_COMMAND, MAKEWPARAM(tb.idCommand, BN_CLICKED), (LPARAM)m_hwnd);
        return(S_OK);
    }
    else
        return(S_FALSE);
}


// --------------------------------------------------------------------------
//
//  CToolBar32::Next()
//
//  This knows that the first child might be an HWND.
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolBar32::Next(ULONG celt, VARIANT *rgvar, ULONG* pceltFetched)
{
HWND        hwndChild;
VARIANT*    pvar;
long        cFetched;
HRESULT     hr;
long        iCur;
long        cChildTemp;

    SetupChildren();

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    cFetched = 0;

    // check for window handle child first
    if (m_idChildCur == CHILDID_SELF)
    {
        if (hwndChild = ::GetWindow(m_hwnd,GW_CHILD))
        {
			rgvar->vt=VT_DISPATCH;
            hr = AccessibleObjectFromWindow(hwndChild,OBJID_WINDOW,
                IID_IDispatch, (void**)&rgvar->pdispVal);

            if (!SUCCEEDED(hr))
                return(hr);

            // decrement how many left to get
            celt--;
            cFetched = 1;
            // increment to next variant in array
            rgvar++;

            // increment count of fetched
            if (pceltFetched)
                (*pceltFetched)++;

            // remember current child
            m_idChildCur = HWNDIDFromHwnd(m_hwnd, hwndChild);
            
            // if no more to get, return
            if (!celt)
                return(S_OK);
        } // end if there is a child window
    } // end if (started at 0)


    // now get any non-window children
    pvar = rgvar;
    iCur = m_idChildCur;
    if (IsHWNDID(iCur))
        iCur = 0;

    //
    // Loop through our items. Need to do different if there is a 
    // window child, because m_cChildren will be +1.
    //
    cChildTemp = m_cChildren;
    if (::GetWindow(m_hwnd,GW_CHILD))
        cChildTemp--;
    while ((cFetched < (long)celt) && (iCur < cChildTemp))
    {
        cFetched++;
        iCur++;

        //
        // Note this gives us (index)+1 because we incremented iCur
        //
        pvar->vt = VT_I4;
        pvar->lVal = iCur;
        ++pvar;
    }

    //
    // Advance the current position
    //
    m_idChildCur = iCur;

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched += cFetched;
    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\updown.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  UPDOWN.H
//
//  This knows how to talk to COMCTL32's updown control
//
// --------------------------------------------------------------------------


class CUpDown32 : public CClient
{
    public:
        // IAccessible
        // BOGUS!  No way to do default action support!
        //         Or button state.  Need COMCTL32 help.
        STDMETHODIMP        get_accName(VARIANT, BSTR*);
        STDMETHODIMP        get_accValue(VARIANT, BSTR*);
        STDMETHODIMP        get_accRole(VARIANT, VARIANT*);

        STDMETHODIMP        accLocation(long*, long*, long*, long*, VARIANT);
        STDMETHODIMP        accNavigate(long, VARIANT, VARIANT*);
        STDMETHODIMP        accHitTest(long, long, VARIANT*);

        STDMETHODIMP        put_accValue(VARIANT, BSTR);

        CUpDown32(HWND, long);

    protected:
        BOOL    m_fVertical;
};


#define INDEX_UPDOWN_SELF       0
#define INDEX_UPDOWN_UPLEFT     1
#define INDEX_UPDOWN_DNRIGHT    2
#define CCHILDREN_UPDOWN        2
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\types6432.h ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  types6432
//
//  basetsd.h substitute;
//  allows compliation on 32-bit systems without the up-to-date basetsd.h
//  defines.
//
//  If using VC6 headers, define NEED_BASETSD_DEFINES.
//  VC6 does have basetsd.h, but it's inconsistent with the current one.
//  (eg. it typedefs INT_PTR as long - causing int/long conversion errors -
//  should be plain int.)
//
// --------------------------------------------------------------------------

//
// Win64 compatibility
//

#if ! defined( _BASETSD_H_ ) || defined( NEED_BASETSD_DEFINES )

typedef unsigned long UINT_PTR;
typedef ULONG ULONG_PTR;
typedef DWORD DWORD_PTR;
typedef LONG  LONG_PTR;
#define PtrToInt  (int)
#define IntToPtr  (void *)
#define HandleToLong  (long)
#define LongToHandle (HANDLE)

// These 'override' VC6's broken INT_PTR definitions.
// That defines them as long - which causes long/int conversion problems.
// Here, we correctly define them as int- types.
// #define used sin'ce we can't untypedef the existing ones.

typedef int MY_INT_PTR;
typedef unsigned int MY_UINT_PTR;
#define INT_PTR MY_INT_PTR
#define UINT_PTR MY_UINT_PTR

#define SetWindowLongPtr    SetWindowLong
#define SetWindowLongPtrA   SetWindowLongA
#define SetWindowLongPtrW   SetWindowLongW
#define GetWindowLongPtr    GetWindowLong
#define GetWindowLongPtrA   GetWindowLongA
#define GetWindowLongPtrW   GetWindowLongW

#define SetClassLongPtr     SetClassLong
#define SetClassLongPtrA    SetClassLongA
#define SetClassLongPtrW    SetClassLongW
#define GetClassLongPtr     GetClassLong
#define GetClassLongPtrA    GetClassLongA
#define GetClassLongPtrW    GetClassLongW


#define GWLP_USERDATA       GWL_USERDATA
#define GWLP_WNDPROC        GWL_WNDPROC

#define GCLP_HMODULE        GCL_HMODULE

#endif



//
// inlines for SendMessage - saves having casts all over the place.
//
// SendMessageUINT - used when expecting a 32-bit return value - eg. text
//     length, number of elements, size of small (<4G) structures, etc.
//     (ie. almost all windows API messages)
//
// SendMessagePTR - used when expecting a pointer (32 or 64) return value
//     (ie. WM_GETOBJECT)
//

inline INT SendMessageINT( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    // Signed int, in keeping with LRESULT, which is also signed...
    return (INT)SendMessage( hWnd, uMsg, wParam, lParam );
}

inline void * SendMessagePTR( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    return (void *) SendMessage( hWnd, uMsg, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\updown.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  UPDOWN.CPP
//
//  This knows how to talk to COMCTL32's updown control.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "updown.h"


#define NOSTATUSBAR
#define NOTOOLBAR
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOPROGRESS
#define NOHOTKEY
#define NOHEADER
#define NOLISTVIEW
#define NOTREEVIEW
#define NOTABCONTROL
#define NOANIMATE
#include <commctrl.h>




// --------------------------------------------------------------------------
//
//  CreateUpDownClient()
//
// --------------------------------------------------------------------------
HRESULT CreateUpDownClient(HWND hwnd, long idChildCur, REFIID riid,
    void** ppvClient)
{
    CUpDown32 * pupdown;
    HRESULT     hr;

    InitPv(ppvClient);

    pupdown = new CUpDown32(hwnd, idChildCur);
    if (!pupdown)
        return(E_OUTOFMEMORY);

    hr = pupdown->QueryInterface(riid, ppvClient);
    if (!SUCCEEDED(hr))
        delete pupdown;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CUpDown32::CUpDown32()
//
// --------------------------------------------------------------------------
CUpDown32::CUpDown32(HWND hwnd, long idChildCur)
    : CClient( CLASS_UpDownClient )
{
    Initialize(hwnd, idChildCur);

    m_cChildren = CCHILDREN_UPDOWN;

    if (!(GetWindowLong(m_hwnd, GWL_STYLE) & UDS_HORZ))
        m_fVertical = TRUE;
}



// --------------------------------------------------------------------------
//
//  CUpDown32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::get_accName(VARIANT varChild, BSTR* pszName)
{
    InitPv(pszName);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::get_accName(varChild, pszName));

    //
    // Remember:
    // Spin buttons work opposite to the way that scrollbars do.  When you 
    // push the up arrow button in a vertical scrollbar, you are _decreasing_
    // the position of the vertical scrollbar, its value.  When you push
    // the up arrow button in a vertical spin button, you are _increasing_
    // its value.
    //
    return(HrCreateString(STR_SPIN_GREATER + varChild.lVal - 1, pszName));
}



// --------------------------------------------------------------------------
//
//  CUpDown32::get_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    long    lPos;

    InitPv(pszValue);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    return E_NOT_APPLICABLE;
}



// --------------------------------------------------------------------------
//
//  CUpDown32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarRole->vt = VT_I4;

    if (varChild.lVal)
        pvarRole->lVal = ROLE_SYSTEM_PUSHBUTTON;
    else
        pvarRole->lVal = ROLE_SYSTEM_SPINBUTTON;
    
    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CUpDown32::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    RECT    rc;
    int     iCoord;
    int     nHalf;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (!varChild.lVal)
        return(CClient::accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild));

    // The buttons split the client area in half.
    MyGetRect(m_hwnd, &rc, FALSE);
    MapWindowPoints(m_hwnd, NULL, (LPPOINT)&rc, 2);

    iCoord = (m_fVertical ? 1 : 0);
    nHalf = (((LPINT)&rc)[iCoord] + ((LPINT)&rc)[iCoord+2]) / 2;

    //
    // We want the right side of the left button to be the halfway point.
    // We want the left side of the right button to be the halfway point.
    // We want the bottom side of the up button to be the halfway point.
    // We want the top side of the down button to be the halfway point.
    //
    ((LPINT)&rc)[iCoord + ((varChild.lVal == INDEX_UPDOWN_UPLEFT) ? 2 : 0)] =
        nHalf;

    *pxLeft = rc.left;
    *pyTop = rc.top;
    *pcxWidth = rc.right - rc.left;
    *pcyHeight = rc.bottom - rc.top;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CUpDown32::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::accHitTest(long x, long y, VARIANT* pvarHit)
{
    HRESULT hr;
    POINT   pt;
    RECT    rc;
    int     iCoord;
    int     nHalf;

    //
    // If the point isn't in us at all, don't bother hit-testing for the
    // button item.
    //
    hr = CClient::accHitTest(x, y, pvarHit);
    // #11150, CWO, 1/27/97, Replaced !SUCCEEDED with !S_OK
    if ((hr != S_OK) || (pvarHit->vt != VT_I4) || (pvarHit->lVal != 0))
        return(hr);

    pt.x = x;
    pt.y = y;
    ScreenToClient(m_hwnd, &pt);

    MyGetRect(m_hwnd, &rc, FALSE);

    iCoord = (m_fVertical ? 1 : 0);
    nHalf = (((LPINT)&rc)[iCoord] + ((LPINT)&rc)[iCoord+2]) / 2;

    if (((LPINT)&pt)[iCoord] < nHalf)
        pvarHit->lVal = INDEX_UPDOWN_UPLEFT;
    else
        pvarHit->lVal = INDEX_UPDOWN_DNRIGHT;

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CUpDown32::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::accNavigate(long dwNavDir, VARIANT varStart, VARIANT* pvarEnd)
{
    long    lEnd = 0;

    InitPvar(pvarEnd);

    if (!ValidateChild(&varStart) || !ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        dwNavDir = NAVDIR_NEXT;
    else if (dwNavDir == NAVDIR_LASTCHILD)
    {
        dwNavDir = NAVDIR_PREVIOUS;
        varStart.lVal = m_cChildren + 1;
    }
    else if (!varStart.lVal)
        return(CClient::accNavigate(dwNavDir, varStart, pvarEnd));

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
NextChild:
            lEnd = varStart.lVal+1;
            if (lEnd > m_cChildren)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
PreviousChild:
            lEnd = varStart.lVal-1;
            break;

        case NAVDIR_UP:
            if (m_fVertical)
                goto PreviousChild;
            else
                lEnd = 0;
            break;

        case NAVDIR_DOWN:
            if (m_fVertical)
                goto NextChild;
            else
                lEnd = 0;
            break;

        case NAVDIR_LEFT:
            if (!m_fVertical)
                goto PreviousChild;
            else
                lEnd = 0;
            break;

        case NAVDIR_RIGHT:
            if (!m_fVertical)
                goto NextChild;
            else
                lEnd = 0;
            break;
    }

    if (lEnd)
    {
        pvarEnd->vt = VT_I4;
        pvarEnd->lVal = lEnd;

        return(S_OK);
    }
    else
        return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CUpDown32::put_accValue()
//
// --------------------------------------------------------------------------
STDMETHODIMP CUpDown32::put_accValue(VARIANT varChild, BSTR szValue)
{
    long    lPos;
    HRESULT hr;

    // 
    // BOGUS!  Do we set the pos directly, or set this in the buddy?
    //
    if (!ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal)
        return(E_NOT_APPLICABLE);

    lPos = 0;
    hr = VarI4FromStr(szValue, 0, 0, &lPos);
    if (!SUCCEEDED(hr))
        return(hr);

    SendMessage(m_hwnd, UDM_SETPOS, 0, lPos);

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\tooltips.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TOOLTIPS.CPP
//
//  Knows how to talk to COMCTL32's tooltips.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "client.h"
#include "tooltips.h"

#include <commctrl.h>

#include "win64helper.h"


#ifndef TTS_BALLOON
#define TTS_BALLOON             0x40
#endif


// --------------------------------------------------------------------------
//
//  CreateToolTipsClient()
//
// --------------------------------------------------------------------------
HRESULT CreateToolTipsClient(HWND hwnd, long idChildCur, REFIID riid, void **ppvToolTips)
{
    CToolTips32 *   ptooltips;
    HRESULT         hr;

    InitPv(ppvToolTips);

    ptooltips = new CToolTips32(hwnd, idChildCur);
    if (!ptooltips)
        return(E_OUTOFMEMORY);

    hr = ptooltips->QueryInterface(riid, ppvToolTips);
    if (!SUCCEEDED(hr))
        delete ptooltips;

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CToolTips32::CToolTips32()
//
// --------------------------------------------------------------------------
CToolTips32::CToolTips32(HWND hwnd, long idChildCur)
    : CClient( CLASS_ToolTipsClient )
{
    Initialize(hwnd, idChildCur);
}


// --------------------------------------------------------------------------
//
//  CToolTips32::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolTips32::get_accName(VARIANT varChild, BSTR *pszName)
{
    InitPv(pszName);

    //
    // Validate--this does NOT accept a child ID.
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    HRESULT hr = HrGetWindowName(m_hwnd, m_fUseLabel, pszName);

    if( FAILED( hr ) )
    {
        return hr;
    }

    // Check for title...
    WCHAR szTitle[ 1024 ];
    TTGETTITLE ttgt;
    ttgt.dwSize = sizeof( ttgt );
    ttgt.pszTitle = szTitle;
    ttgt.cch = ARRAYSIZE( szTitle );

    if( S_OK == XSend_ToolTip_GetTitle( m_hwnd, TTM_GETTITLE, 0, & ttgt ) 
        && szTitle[ 0 ] != '\0' )
    {
        // Got a title - glue it in front of the name string. If we didn't
        // get a name string, use the title on its own.
        int cchTitle = lstrlenW( szTitle );

        int cchName = 0;
        int cchSep = 0;
        if( *pszName )
        {
            cchName = lstrlenW( *pszName );
            cchSep = 2; // space for ": "
        }
        
        // SysAllocStringLen adds an extra 1 for terminating NUL, so we don't have to.
        BSTR bstrCombined = SysAllocStringLen( NULL, cchTitle + cchSep + cchName );
        if( ! bstrCombined )
        {
            // Just go with whatever we got above...
            return hr;
        }

        memcpy( bstrCombined, szTitle, cchTitle * sizeof( WCHAR ) );
        if( *pszName )
        {
            memcpy( bstrCombined + cchTitle, L": ", cchSep * sizeof( WCHAR ) );
            memcpy( bstrCombined + cchTitle + cchSep, *pszName, cchName * sizeof( WCHAR ) );

            SysFreeString( *pszName );
        }

        // Add terminating NUL, copy string to out param...
        bstrCombined[ cchName + cchSep + cchTitle ] = '\0';
        
        *pszName = bstrCombined;
    }

    return hr;
}


// --------------------------------------------------------------------------
//
//  CToolTips32::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CToolTips32::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    if (!ValidateChild(&varChild))
        return E_INVALIDARG;

    DWORD dwStyle = GetWindowLong( m_hwnd, GWL_STYLE );

    pvarRole->vt = VT_I4;

    if( dwStyle & TTS_BALLOON )
        pvarRole->lVal = ROLE_SYSTEM_HELPBALLOON;
    else
        pvarRole->lVal = ROLE_SYSTEM_TOOLTIP;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\tooltips.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  TOOLTIPS.H
//
//  Knows how to talk to COMCTL32's tooltips.
//
// --------------------------------------------------------------------------


class CToolTips32 : public CClient
{
    public:
        // IAccessible
        STDMETHODIMP    get_accName(VARIANT varChild, BSTR *pszName);
        STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT* pvarRole);

        CToolTips32(HWND, long);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\util.h ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  util
//
//  Miscellaneous helper routines
//
// --------------------------------------------------------------------------


BOOL ClickOnTheRect( LPRECT lprcLoc, HWND hwndToCheck, BOOL fDblClick );



// defines used for SendKey function
#define KEYPRESS    0
#define KEYRELEASE  KEYEVENTF_KEYUP
#define VK_VIRTUAL  0
#define VK_CHAR     1


BOOL SendKey( int nEvent, int nKeyType, WORD wKeyCode, TCHAR cChar );

HWND MyGetFocus();

void MySetFocus( HWND hwnd );

void MyGetRect(HWND, LPRECT, BOOL);

BSTR TCharSysAllocString( LPTSTR lpszString );

HRESULT HrCreateString(int istr, BSTR* pszResult);

inline
BOOL Rect1IsOutsideRect2( RECT const & rc1, RECT const & rc2 )
{
    return ( rc1.right  <= rc2.left ) ||
           ( rc1.bottom <= rc2.top )  ||
           ( rc1.left  >= rc2.right ) ||
           ( rc1.top >= rc2.bottom );
}

HRESULT GetLocationRect( IAccessible * pAcc, VARIANT & varChild, RECT * prc );

BOOL IsClippedByWindow( IAccessible * pAcc, VARIANT & varChild, HWND hwnd );


// This avoids requiring that files that #include this file
// also #include the propmgr files...
typedef enum PROPINDEX;

BOOL CheckStringMap( HWND hwnd,
                     DWORD idObject,
                     DWORD idChild,
                     PROPINDEX idxProp,
                     int * paKeys,
                     int cKeys,
                     BSTR * pbstr,
                     BOOL fAllowUseRaw = FALSE,
                     BOOL * pfGotUseRaw = NULL );

BOOL CheckDWORDMap( HWND hwnd,
                    DWORD idObject,
                    DWORD idChild,
                    PROPINDEX idxProp,
                    int * paKeys,
                    int cKeys,
                    DWORD * pdw );



BOOL GetTooltipStringForControl( HWND hwndCtl, UINT uGetTooltipMsg, DWORD dwIDCtl, LPTSTR * ppszName );






//
// Marshals an interface pointer, returning pointer to marshalled buffer.
//
// Also returns a MarshalState struct, which caller must pass to MarshalInterfaceDone
// when done using buffer.
//

class  MarshalState
{
    IStream * pstm;
    HGLOBAL   hGlobal;

    friend 
    HRESULT MarshalInterface( REFIID riid,
                              IUnknown * punk,
                              DWORD dwDestContext,
                              DWORD mshlflags,
                              const BYTE ** ppData,
                              DWORD * pDataLen,
                              MarshalState * pMarshalState );

    friend 
    void MarshalInterfaceDone( MarshalState * pMarshalState );

};

HRESULT MarshalInterface( REFIID riid,
                          IUnknown * punk,
                          DWORD dwDestContext,
                          DWORD mshlflags,
                          
                          const BYTE ** ppData,
                          DWORD * pDataLen,

                          MarshalState * pMarshalState );

void MarshalInterfaceDone( MarshalState * pMarshalState );


// Releases references associated with marshalled buffer.
// (wrapper for CoReleaseMarshalData)
// (Does not free/delete the actual buffer.)
HRESULT ReleaseMarshallData( const BYTE * pMarshalData, DWORD dwMarshalDataLen );

HRESULT UnmarshalInterface( const BYTE * pData, DWORD cbData,
                            REFIID riid, LPVOID * ppv );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\verdefs.h ===
//
//
//  Version information
//
//  In VSS, this lives in the top-level inc32 directory, and is
//  updated automatically by the build process. This controls
//  the version number of oleacc and the applets.
//
//  On the NT Build (Source Depot), this file lives in the same
//  directory as oleacc.dll, is updated by hand during checkin,
//  and controls the FileVersion of oleacc.dll. (ProductVersion
//  is determined by the NT build).
//
//  The four-digit version 4.2.yydd.0 is calculated by:
//    yy  Number of months since January 1997.
//    dd  Day of month
//
//  For example, a checkin on March 17th 2000 would have a
//  version of 3917.
//  
//  #include'd by:
//     oleacc\api.cpp       - used by GetOleaccVersionInfo
//     oleacc\version.h     - used in VERSIONINFO resource
//
//  additionally, for VSS builds:
//     oleaccrc\rc_ver.h    - used in VERSIONINFO resource
//     inc32\common.rc      - used in VERSIONINFO resource
//

#define BUILD_VERSION_INT   4,2,5406,0
#define BUILD_VERSION_STR   "4.2.5406.0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\util.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  util
//
//  Miscellaneous helper routines
//
// --------------------------------------------------------------------------


#include "oleacc_p.h"
//#include "util.h" // already in oleacc_p.h

#include "propmgr_util.h"
#include "propmgr_client.h"

#include <commctrl.h>

#include "Win64Helper.h"

const LPCTSTR g_szHotKeyEvent = TEXT("MSAASetHotKeyEvent");
const LPCTSTR g_szHotKeyAtom = TEXT("MSAASetFocusHotKey");
const LPCTSTR g_szMessageWindowClass = TEXT("MSAAMessageWindow");
#define HWND_MESSAGE     ((HWND)-3)
#define HOT_KEY 0xB9
LRESULT CALLBACK MessageWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

// This class is used to give aother window focus.
// This used to be done using SetForgroundWindow but in Win2k and beyond you (as in your thread) 
// must have input focus in order for SetForgroundWindow to work.  This class create a message 
// window, then registers a HotKey, sends that HotKey to the window and waits for that key to get
// to its window proc.  When it does I now has input focus and can call SetForgroundWindow with 
// the desired affect.
class CSetForegroundWindowHelper
{

public:
	CSetForegroundWindowHelper() : 
        m_hwndMessageWindow( NULL ), 
        m_atomHotKeyId( 0 ), 
        m_vkHotKey( 0 ), 
        m_fReceivedHotKey( FALSE ), 
        m_hwndTarget( NULL ),
        m_cUseCount( 0 )
	{
	}
	
	~CSetForegroundWindowHelper() 
	{
        Reset();
    }

    BOOL SetForegroundWindow( HWND hwnd );
    LRESULT CALLBACK CSetForegroundWindowHelper::WinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    

private:

    BOOL RegHotKey();
    void UnRegHotKey();
    BOOL CreateHiddenWindow();
    void Reset();
   
private:

    HWND m_hwndMessageWindow;
    ATOM m_atomHotKeyId;
    WORD m_vkHotKey;      // this virtural key is undefined
    HWND m_hwndTarget;
    bool m_fReceivedHotKey;
    int  m_cUseCount;

};


BOOL CSetForegroundWindowHelper::SetForegroundWindow( HWND hwnd )
{
    // if a regular SetForegroundWindow works their is no reason to go through all this
    // work.  This will be the case in win9x and win2k administrators.
    if ( ::SetForegroundWindow( hwnd ) )
        return TRUE;

    if ( !m_hwndMessageWindow )
    {
        m_vkHotKey = HOT_KEY;

        if ( !CreateHiddenWindow() )
        {
            DBPRINTF( TEXT("CreateHiddenWindow failed") );
            return FALSE;
        }

        // Wake up in 5 minutes and see if anyone is using this window
        SetTimer( m_hwndMessageWindow, 1, 300000, NULL );
    }

    if ( !RegHotKey() )
    {
        DBPRINTF( TEXT("RegHotKey failed") );
        return FALSE;
    }

    m_hwndTarget = hwnd;
    m_cUseCount++;

    m_fReceivedHotKey = false;

    MyBlockInput (TRUE);
    // Get state of shift keys and if they are down, send an up
    // when we're done
    BOOL fCtrlPressed = GetKeyState(VK_CONTROL) & 0x8000;
    BOOL fAltPressed = GetKeyState(VK_MENU) & 0x8000;
    BOOL fShiftPressed = GetKeyState(VK_SHIFT) & 0x8000;
    if (fCtrlPressed)
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_CONTROL,0);
    if (fAltPressed)
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_MENU,0);
    if (fShiftPressed)
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_SHIFT,0);


    // send the hot key
    SendKey( KEYPRESS, VK_VIRTUAL, m_vkHotKey, 0 ); 
    SendKey( KEYRELEASE, VK_VIRTUAL, m_vkHotKey, 0 );

    // send shift key down events if they were down before
    if (fCtrlPressed)
        SendKey (KEYPRESS,VK_VIRTUAL,VK_CONTROL,0);
    if (fAltPressed)
        SendKey (KEYPRESS,VK_VIRTUAL,VK_MENU,0);
    if (fShiftPressed)
        SendKey (KEYPRESS,VK_VIRTUAL,VK_SHIFT,0);
    MyBlockInput (FALSE);

    MSG msg;
    // Spin in this message loop until we get the hot key
    while ( GetMessage( &msg, NULL, 0, 0 ) )
    {
        TranslateMessage( &msg );
        DispatchMessage( &msg );
        if ( m_fReceivedHotKey )
            break;
    }
    m_fReceivedHotKey = false;
    
    UnRegHotKey();
    
    return TRUE;
}

LRESULT CALLBACK CSetForegroundWindowHelper::WinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lReturn = 0;

    switch( Msg )
    {
        case WM_HOTKEY:
            m_fReceivedHotKey = TRUE;
            ::SetForegroundWindow( m_hwndTarget );
            break;

        case WM_TIMER:
            if ( m_cUseCount == 0 )
            {
                KillTimer( m_hwndMessageWindow, 1 );
                Reset();
            }
            m_cUseCount = 0;
            break;

        default:
            lReturn = DefWindowProc( hWnd, Msg, wParam, lParam );
    }


    return lReturn;
}

BOOL CSetForegroundWindowHelper::RegHotKey()
{
    // If the ATOM is set the we already have a registered HotKey so get out
    if ( m_atomHotKeyId )
        return TRUE;

    const UINT uiModifiers = 0;
    const int cMaxTries = 20;
    bool fFoundHotKey = false;
    m_atomHotKeyId = GlobalAddAtom( g_szHotKeyAtom );

    //  Try a buch if different hot keys incase its already registered
    for ( int i = 0; i < cMaxTries; i++, m_vkHotKey-- )
    {
        if ( RegisterHotKey(m_hwndMessageWindow, m_atomHotKeyId, uiModifiers, m_vkHotKey ) )
        {
            DBPRINTF( TEXT("HotKey found\r\n") );
            fFoundHotKey = true;
            break;
        }
    }

    // only report an error if it the last try
    if ( !fFoundHotKey )
    {
        DBPRINTF( TEXT("RegisterHotKey failed, error = %d\r\n"), GetLastError() );
        GlobalDeleteAtom( m_atomHotKeyId  );
        m_atomHotKeyId = 0;
        return FALSE;
    }

    return TRUE;
}

void CSetForegroundWindowHelper::UnRegHotKey()
{
    if ( m_atomHotKeyId )
    {
        UnregisterHotKey( m_hwndMessageWindow, m_atomHotKeyId );
        GlobalDeleteAtom( m_atomHotKeyId  );
        m_atomHotKeyId = 0;
        m_vkHotKey = HOT_KEY;
    }

}

// create a message only window this is just used to get a hotkey message
BOOL CSetForegroundWindowHelper::CreateHiddenWindow()
{
    WNDCLASSEX wc;

    ZeroMemory( &wc, sizeof(WNDCLASSEX) );

    wc.cbSize = sizeof(WNDCLASSEX);
    wc.lpfnWndProc = MessageWindowProc;
    wc.lpszClassName = g_szMessageWindowClass;

    if( 0 == RegisterClassEx( &wc ) )
    {   
        DWORD dwError = GetLastError();

        if ( ERROR_CLASS_ALREADY_EXISTS != dwError )
        {
            DBPRINTF( TEXT("Register window class failed, error = %d\r\n"), dwError);
            return FALSE;
        }
    }

    m_hwndMessageWindow = CreateWindowEx(0,
                                         g_szMessageWindowClass,
                                         g_szMessageWindowClass,
                                         0,
                                         CW_USEDEFAULT,
                                         CW_USEDEFAULT,
                                         CW_USEDEFAULT,
                                         CW_USEDEFAULT,
                                         HWND_MESSAGE,
                                         NULL,
                                         NULL,
                                         NULL);

    if( !m_hwndMessageWindow )
    {
        DBPRINTF( TEXT("CreateWindowEx failed, error = %d\r\n"), GetLastError() );
        return FALSE;
    }

    return TRUE;
}

void CSetForegroundWindowHelper::Reset()
{
    UnRegHotKey();
    
    if ( m_hwndMessageWindow )
    {
        DestroyWindow( m_hwndMessageWindow );
        m_hwndMessageWindow = NULL;
    }
}

CSetForegroundWindowHelper g_GetFocus;

LRESULT CALLBACK MessageWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    return g_GetFocus.WinProc( hWnd, Msg, wParam, lParam );
}


////////////////////////////////////////////////////////////////////////////////////////////////
// --------------------------------------------------------------------------
//
// ClickOnTheRect
//
// This function takes a pointer to a rectangle that contains coordinates
// in the form (top,left) (width,height). These are screen coordinates. It
// then finds the center of that rectangle and checks that the window handle
// given is in fact the window at that point. If so, it uses the SendInput
// function to move the mouse to the center of the rectangle, do a single
// click of the default button, and then move the cursor back where it
// started. In order to be super-robust, it checks the Async state of the 
// shift keys (Shift, Ctrl, and Alt) and turns them off while doing the 
// click, then back on if they were on. if fDblClick is TRUE, it will do
// a double click instead of a single click.
//
// We have to make sure we are not interrupted while doing this!
//
// Returns TRUE if it did it, FALSE if there was some bad error.
//
// --------------------------------------------------------------------------

// this is for ClickOnTheRect
typedef struct tagMOUSEINFO
{
    int MouseThresh1;
    int MouseThresh2;
    int MouseSpeed;
}
MOUSEINFO, FAR* LPMOUSEINFO;


BOOL ClickOnTheRect(LPRECT lprcLoc,HWND hwndToCheck,BOOL fDblClick)
{
    POINT		ptCursor;
    POINT		ptClick;
    HWND		hwndAtPoint;
    MOUSEINFO	miSave;
    MOUSEINFO   miNew;
    int			nButtons;
    INPUT		rgInput[6];
    int         i;
    DWORD		dwMouseDown;
    DWORD		dwMouseUp;

    // Find Center of rect
	ptClick.x = lprcLoc->left + (lprcLoc->right/2);
	ptClick.y = lprcLoc->top + (lprcLoc->bottom/2);

	// check if hwnd at point is same as hwnd to check
	hwndAtPoint = WindowFromPoint (ptClick);
	if (hwndAtPoint != hwndToCheck)
		return FALSE;

    MyBlockInput (TRUE);
    // Get current cursor pos.
    GetCursorPos(&ptCursor);
	if (GetSystemMetrics(SM_SWAPBUTTON))
	{
		dwMouseDown = MOUSEEVENTF_RIGHTDOWN;
		dwMouseUp = MOUSEEVENTF_RIGHTUP;
	}
	else
	{
		dwMouseDown = MOUSEEVENTF_LEFTDOWN;
		dwMouseUp = MOUSEEVENTF_LEFTUP;
	}

    // Get delta to move to center of rectangle from current
    // cursor location.
    ptCursor.x = ptClick.x - ptCursor.x;
    ptCursor.y = ptClick.y - ptCursor.y;

    // NOTE:  For relative moves, USER actually multiplies the
    // coords by any acceleration.  But accounting for it is too
    // hard and wrap around stuff is weird.  So, temporarily turn
    // acceleration off; then turn it back on after playback.

    // Save mouse acceleration info
    if (!SystemParametersInfo(SPI_GETMOUSE, 0, &miSave, 0))
    {
        MyBlockInput (FALSE);
        return (FALSE);
    }

    if (miSave.MouseSpeed)
    {
        miNew.MouseThresh1 = 0;
        miNew.MouseThresh2 = 0;
        miNew.MouseSpeed = 0;

        if (!SystemParametersInfo(SPI_SETMOUSE, 0, &miNew, 0))
        {
            MyBlockInput (FALSE);
            return (FALSE);
        }
    }

    // Get # of buttons
    nButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);

    // Get state of shift keys and if they are down, send an up
    // when we're done

    BOOL fCtrlPressed = GetKeyState(VK_CONTROL) & 0x8000;
    BOOL fAltPressed = GetKeyState(VK_MENU) & 0x8000;
    BOOL fShiftPressed = GetKeyState(VK_SHIFT) & 0x8000;
    if (fCtrlPressed)
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_CONTROL,0);
    if (fAltPressed)
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_MENU,0);
    if (fShiftPressed)
        SendKey (KEYRELEASE,VK_VIRTUAL,VK_SHIFT,0);

    DWORD time = GetTickCount();

    // mouse move to center of start button
    rgInput[0].type = INPUT_MOUSE;
    rgInput[0].mi.dwFlags = MOUSEEVENTF_MOVE;
    rgInput[0].mi.dwExtraInfo = 0;
    rgInput[0].mi.dx = ptCursor.x;
    rgInput[0].mi.dy = ptCursor.y;
    rgInput[0].mi.mouseData = nButtons;
    rgInput[0].mi.time = time;

    i = 1;

DBL_CLICK:
    // Mouse click down, left button
    rgInput[i].type = INPUT_MOUSE;
    rgInput[i].mi.dwFlags = dwMouseDown;
    rgInput[i].mi.dwExtraInfo = 0;
    rgInput[i].mi.dx = 0;
    rgInput[i].mi.dy = 0;
    rgInput[i].mi.mouseData = nButtons;
    rgInput[i].mi.time = time;

    i++;
    // Mouse click up, left button
    rgInput[i].type = INPUT_MOUSE;
    rgInput[i].mi.dwFlags = dwMouseUp;
    rgInput[i].mi.dwExtraInfo = 0;
    rgInput[i].mi.dx = 0;
    rgInput[i].mi.dy = 0;
    rgInput[i].mi.mouseData = nButtons;
    rgInput[i].mi.time = time;

    i++;
    if (fDblClick)
    {
        fDblClick = FALSE;
        goto DBL_CLICK;
    }
	// move mouse back to starting location
    rgInput[i].type = INPUT_MOUSE;
    rgInput[i].mi.dwFlags = MOUSEEVENTF_MOVE;
    rgInput[i].mi.dwExtraInfo = 0;
    rgInput[i].mi.dx = -ptCursor.x;
    rgInput[i].mi.dy = -ptCursor.y;
    rgInput[i].mi.mouseData = nButtons;
    rgInput[i].mi.time = time;

    i++;
    if (!MySendInput(i, rgInput,sizeof(INPUT)))
        MessageBeep(0);

    // send shift key down events if they were down before
    if (fCtrlPressed)
        SendKey (KEYPRESS,VK_VIRTUAL,VK_CONTROL,0);
    if (fAltPressed)
        SendKey (KEYPRESS,VK_VIRTUAL,VK_MENU,0);
    if (fShiftPressed)
        SendKey (KEYPRESS,VK_VIRTUAL,VK_SHIFT,0);

    //
    // Restore Mouse Acceleration
    //
    if (miSave.MouseSpeed)
        SystemParametersInfo(SPI_SETMOUSE, 0, &miSave, 0);

    MyBlockInput (FALSE);

	return TRUE;
}






//--------------------------------------------------------------------------
//
//  SendKey
//
// This is a private function. Sends the key event specified by 
// the parameters - down or up, plus a virtual key code or character. 
//
// Parameters:
//  nEvent          either KEYPRESS or KEYRELEASE
//  nKeyType        either VK_VIRTUAL or VK_CHAR
//  wKeyCode        a Virtual Key code if KeyType is VK_VIRTUAL,
//                  ignored otherwise
//  cChar           a Character if KeyType is VK_CHAR, ignored otherwise.
//
// Returns:
//  BOOL indicating success (TRUE) or failure (FALSE)
//--------------------------------------------------------------------------
BOOL SendKey (int nEvent,int nKeyType,WORD wKeyCode,TCHAR cChar)
{
    INPUT		Input;

    Input.type = INPUT_KEYBOARD;
    if (nKeyType == VK_VIRTUAL)
    {
        Input.ki.wVk = wKeyCode;
        Input.ki.wScan = LOWORD(MapVirtualKey(wKeyCode,0));
    }
    else // must be a character
    {
        Input.ki.wVk = VkKeyScan (cChar);
        Input.ki.wScan = LOWORD(OemKeyScan (cChar));
    }
    Input.ki.dwFlags = nEvent;
    Input.ki.time = GetTickCount();
    Input.ki.dwExtraInfo = 0;

    return MySendInput(1, &Input,sizeof(INPUT));
}


// --------------------------------------------------------------------------
//
//  MyGetFocus()
//
//  Gets the focus on this window's VWI.
//
// --------------------------------------------------------------------------
HWND MyGetFocus()
{
    GUITHREADINFO     gui;

    //
    // Use the foreground thread.  If nobody is the foreground, nobody has
    // the focus either.
    //
    if (!MyGetGUIThreadInfo(0, &gui))
        return(NULL);

    return(gui.hwndFocus);
}



// --------------------------------------------------------------------------
//
//  MySetFocus()
//
//  Attempts to set the focused window.
//  Since SetFocus only works on HWNDs owned by the calling thread,
//  we use SetActiveWindow instead.
//
// --------------------------------------------------------------------------
void MySetFocus( HWND hwnd )
{

    HWND hwndParent = hwnd;
    BOOL fWindowEnabled = TRUE;
	HWND hwndDesktop = GetDesktopWindow();
	while ( hwndParent != hwndDesktop )
	{
        fWindowEnabled = IsWindowEnabled( hwndParent );
        if ( !fWindowEnabled ) 
            break;
        hwndParent = MyGetAncestor(hwndParent, GA_PARENT );
    }

	if ( fWindowEnabled )
	{
        // This is freaky, but seems to work.

        // There are some cases where it doesn't quite work, though:
        // * Won't focus the Address: combo in an IE/Explorer window
        // * Needs to check that the window is enabled first! Possible
        //   to set focus to a hwnd that is disabled because it has a
        //   modal dialog showing.

        // First, use SetForegroundWindow on the target window...
        // This can do weird things if its a child window - it looks
        // like the top-level window doesn't get activated properly...
        g_GetFocus.SetForegroundWindow( hwnd );

        // Now call SetForegroundWindow on the top-level window. This fixes the
        // activation, but actually leaves the focus on the child window.
        HWND hTopLevel = MyGetAncestor( hwnd, GA_ROOT );
        if( hTopLevel )
        {
            SetForegroundWindow( hTopLevel );
        }
    }
    
}




// --------------------------------------------------------------------------
//
//  MyGetRect
//
//  This initializes the rectangle to empty, then makes a GetClientRect()
//  or GetWindowRect() call.  These APIs will leave the rect alone if they
//  fail, hence the zero'ing out ahead of time.  They don't return a useful
//  value in Win '95.
//
// --------------------------------------------------------------------------
void MyGetRect(HWND hwnd, LPRECT lprc, BOOL fWindowRect)
{
    SetRectEmpty(lprc);

    if (fWindowRect)
        GetWindowRect(hwnd, lprc);
    else
        GetClientRect(hwnd, lprc);
}



// --------------------------------------------------------------------------
//
//  TCharSysAllocString
//
//  Pillaged from SHELL source, does ANSI BSTR stuff.
//
// --------------------------------------------------------------------------
BSTR TCharSysAllocString(LPTSTR pszString)
{
#ifdef UNICODE
    return SysAllocString(pszString);
#else
    LPOLESTR    pwszOleString;
    BSTR        bstrReturn;
    int         cChars;

    // do the call first with 0 to get the size needed
    cChars = MultiByteToWideChar(CP_ACP, 0, pszString, -1, NULL, 0);
    pwszOleString = (LPOLESTR)LocalAlloc(LPTR,sizeof(OLECHAR)*cChars);
    if (pwszOleString == NULL)
    {
        return NULL;
    }

	cChars = MultiByteToWideChar(CP_ACP, 0, pszString, -1, pwszOleString, cChars);
    bstrReturn = SysAllocString(pwszOleString);
	LocalFree (pwszOleString);
    return bstrReturn;
#endif
}




// --------------------------------------------------------------------------
//
//  HrCreateString
//
//  Loads a string from the resource file and makes a BSTR from it.
//
// --------------------------------------------------------------------------

#define CCH_STRING_MAX  256

HRESULT HrCreateString(int istr, BSTR* pszResult)
{
    TCHAR   szString[CCH_STRING_MAX];

    Assert(pszResult);
    *pszResult = NULL;

    if (!LoadString(hinstResDll, istr, szString, CCH_STRING_MAX))
        return(E_OUTOFMEMORY);

    *pszResult = TCharSysAllocString(szString);
    if (!*pszResult)
        return(E_OUTOFMEMORY);

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  GetLocationRect
//
//  Get a RECT location from an IAccessible. Converts accLocation's width and
//  height to right and bottom coords.
//
// --------------------------------------------------------------------------


HRESULT GetLocationRect( IAccessible * pAcc, VARIANT & varChild, RECT * prc )
{
    HRESULT hr = pAcc->accLocation( & prc->left, & prc->top, & prc->right, & prc->bottom, varChild );
    if( hr == S_OK )
    {
        // convert width/height to right/bottom...
        prc->right += prc->left;
        prc->bottom += prc->top;
    }
    return hr;
}



// --------------------------------------------------------------------------
//
//  IsClippedByWindow
//
//  Returns TRUE if a given IAccesible/varChild is completely outside the
//  rectangle of a given HWND.
//
//  (When varChildID is not CHILDID_SELF, and when the HWND is the HWND of
//  the IAccessible, then it means that the item is clipped by its parent.)
//
// --------------------------------------------------------------------------

BOOL IsClippedByWindow( IAccessible * pAcc, VARIANT & varChild, HWND hwnd )
{
    RECT rcItem;
    if( GetLocationRect( pAcc, varChild, & rcItem ) != S_OK )
        return FALSE;

    RECT rcWindow;
    GetClientRect( hwnd, & rcWindow );

    MapWindowPoints( hwnd, NULL, (POINT *) & rcWindow, 2 );

    return Rect1IsOutsideRect2( rcItem, rcWindow );
}




//
// Why not use the stdlib? Well, we want to do this all in Unicode, and
// work on 9x... (even when built as ANSI)
//
static
void ParseInt( LPCWSTR pStart, LPCWSTR * ppEnd, int * pInt )
{
    // Allow single leading + or -...
    BOOL fIsNeg = FALSE;
    if( *pStart == '-' )
    {
        fIsNeg = TRUE;
        pStart++;
    }
    else if( *pStart == '+' )
    {
        pStart++;
    }

    // Skip possible leading 0...
    if( *pStart == '0' )
    {
        pStart++;
    }

    // Possible 'x' indicating hex number...
    int base = 10;
    if( *pStart == 'x' || *pStart == 'X' )
    {
        base = 16;
        pStart++;
    }


    // Numbers all the way from here...

    // Note - this doesn't handle overflow/wraparound, nor the
    // extremities of the range (eg. max and min possible #'s...)
    int x = 0;
    for( ; ; )
    {
        int digit;

        if( *pStart >= '0' && *pStart <= '9' )
        {
            digit =  *pStart - '0';
        }
        else if( *pStart >= 'a' && *pStart <= 'f' )
        {
            digit =  *pStart - 'a' + 10;
        }
        else if( *pStart >= 'A' && *pStart <= 'F' )
        {
            digit =  *pStart - 'A' + 10;
        }
        else
        {
            // invalid digit
            break;
        }

        if( digit >= base )
        {
            // digit not appropriate for this base
            break;
        }

        pStart++;

        x = ( x * base ) + digit;
    }

    if( fIsNeg )
    {
        x = -x;
    }

    *pInt = x;
    *ppEnd = pStart;
}

static
void ParseString( LPCWSTR pStart, LPCWSTR * ppEnd, WCHAR wcSep )
{
    while( *pStart != '\0' && *pStart != wcSep )
    {
        pStart++;
    }
    *ppEnd = pStart;
}


static
BOOL StrEquW( LPCWSTR pStrA, LPCWSTR pStrB )
{
    while( *pStrA && *pStrA == *pStrB )
    {
        pStrA++;
        pStrB++;
    }
    return *pStrA == *pStrB;
}


// Format of map:
//
// Type A - currently only supported string.
// Separator can be any character (except NUL - must be a legal
// string character. Doesn't make sense to use space... also can't 
// be a numeric digit...)
//
// "A:0:String0:1:String1:2:String2:3:String3:"
//
// or...
//
// "TypeA 0='String0' 1='String1' 2='String2' 3='String3'"
//
// How to deal with quotes?



// FALSE -> Value not found in map.
// TRUE -> Value found, ppStart, ppEnd point to end points of corresponding entry

static
BOOL ParseValueMap( LPCWSTR pWMapStr,
                    int * aKeys,
                    int cKeys,
                    LPCWSTR * ppStrStart,
                    LPCWSTR * ppStrEnd )
{
    // Check header for Type-A signature

    // Note - I've used plain ANSI literals below - eg. 'A' instead of
    // L'A' - this is ok, since the compiler will promote these to Unicode
    // before doing the comparison.

    
    // Check for leading 'A'...
    if( *pWMapStr != 'A' )
    {
        return FALSE;
    }
    pWMapStr++;


    // Check for separator.
    WCHAR wcSeparator = *pWMapStr;
    if( wcSeparator == '\0' )
    {
        return FALSE;
    }
    pWMapStr++;


    // The first item indicates which source key we are using...
    int iKey;
    LPCWSTR pWStartOfInt = pWMapStr;
    ParseInt( pWMapStr, & pWMapStr, & iKey );
    
    if( pWMapStr == pWStartOfInt )
    {
        // missing number
        return FALSE;
    }

    // Check for separator...
    if( *pWMapStr != wcSeparator )
    {
        return FALSE;
    }
    pWMapStr++;

    // Is index within range?
    if( iKey >= cKeys )
    {
        return FALSE;
    }

    // Now we know what the key is in the key-value map...
    int TargetValue = aKeys[ iKey ];
                                        
    // We don't explicitly check for the terminating NUL in the map string here -
    // however, both ParseInt and ParseString will stop at it, and we'll then
    // check that it's the separator - which will fail, so we'll exit with FALSE.
    for( ; ; )
    {
        int x;
        LPCWSTR pWStartOfInt = pWMapStr;
        ParseInt( pWMapStr, & pWMapStr, & x );
        
        if( pWMapStr == pWStartOfInt )
        {
            // missing number
            return FALSE;
        }

        // Check for separator...
        if( *pWMapStr != wcSeparator )
        {
            return FALSE;
        }
        pWMapStr++;

        LPCWSTR pStrStart = pWMapStr;
        ParseString( pWMapStr, & pWMapStr, wcSeparator );
        LPCWSTR pStrEnd = pWMapStr;

        // Check for separator...
        if( *pWMapStr != wcSeparator )
        {
            return FALSE;
        }
        pWMapStr++;

        // Found it...
        if( TargetValue == x )
        {
            *ppStrStart = pStrStart;
            *ppStrEnd = pStrEnd;
            return TRUE;
        }
    }
}





BOOL CheckStringMap( HWND hwnd,
                     DWORD idObject,
                     DWORD idChild,
                     PROPINDEX idxProp,
                     int * pKeys,
                     int cKeys,
                     BSTR * pbstr,
                     BOOL fAllowUseRaw,
                     BOOL * pfGotUseRaw )
{
    VARIANT varMap;

    BYTE HwndKey[ HWNDKEYSIZE ];
    MakeHwndKey( HwndKey, hwnd, idObject, idChild );

    if( ! PropMgrClient_LookupProp( HwndKey, HWNDKEYSIZE, idxProp, & varMap ) )
    {
        return FALSE;
    }

    if( varMap.vt != VT_BSTR )
    {
        VariantClear( & varMap );
        return FALSE;
    }

    if( fAllowUseRaw )
    {
        *pfGotUseRaw = StrEquW( varMap.bstrVal, L"use_raw" );
        if( *pfGotUseRaw )
            return TRUE;
    }

    LPCWSTR pStrStart;
    LPCWSTR pStrEnd;

    BOOL fGot = ParseValueMap( varMap.bstrVal, pKeys, cKeys, & pStrStart, & pStrEnd );
    SysFreeString( varMap.bstrVal );
    if( ! fGot )
    {
        return FALSE;
    }

    // Cast for Win64 compile. Subtracting ptrs give 64-bit value; we only
    // want the 32-bit part...
    *pbstr = SysAllocStringLen( pStrStart, (UINT)( pStrEnd - pStrStart ) );
    if( ! *pbstr )
    {
        return FALSE;
    }

    return TRUE;
}




BOOL CheckDWORDMap( HWND hwnd,
                    DWORD idObject,
                    DWORD idChild,
                    PROPINDEX idxProp,
                    int * pKeys,
                    int cKeys,
                    DWORD * pdw )
{
    VARIANT varMap;

    BYTE HwndKey[ HWNDKEYSIZE ];
    MakeHwndKey( HwndKey, hwnd, idObject, idChild );
    
    if( ! PropMgrClient_LookupProp( HwndKey, HWNDKEYSIZE, idxProp, & varMap ) )
    {
        return FALSE;
    }

    if( varMap.vt != VT_BSTR )
    {
        VariantClear( & varMap );
        return FALSE;
    }

    LPCWSTR pStrStart;
    LPCWSTR pStrEnd;

    BOOL fGot = ParseValueMap( varMap.bstrVal, pKeys, cKeys, & pStrStart, & pStrEnd );
    SysFreeString( varMap.bstrVal );
    if( ! fGot )
    {
        return FALSE;
    }

    int i;
    LPCWSTR pIntEnd;
    ParseInt( pStrStart, & pIntEnd, & i );
    if( pIntEnd == pStrStart || pIntEnd != pStrEnd )
    {
        // invalid number...
        return FALSE;
    }

    *pdw = (DWORD) i;

    return TRUE;
}














#define MAX_NAME_SIZE   128 



struct EnumThreadWindowInfo
{
    HWND    hwndCtl;
    DWORD   dwIDCtl;

    TCHAR * pszName;
};


static
HRESULT TryTooltip( HWND hwndToolTip, LPTSTR pszName, HWND hwndCtl, DWORD dwIDCtl )
{
    TOOLINFO ti;
    ti.cbSize = SIZEOF_TOOLINFO;
    ti.lpszText = pszName;
    ti.hwnd = hwndCtl;
    ti.uId = dwIDCtl;

    *pszName = '\0';
    HRESULT hr = XSend_ToolTip_GetItem( hwndToolTip, TTM_GETTEXT, 0, & ti, MAX_NAME_SIZE );

    if( hr != S_OK )
        return hr;

    return S_OK;
}


static
BOOL CALLBACK EnumThreadWindowsProc( HWND hWnd, LPARAM lParam )
{
    EnumThreadWindowInfo * pInfo = (EnumThreadWindowInfo *) lParam;

    // Is this a tooltip window?
    TCHAR szClass[ 64 ];
    if( ! GetClassName( hWnd, szClass, ARRAYSIZE( szClass ) ) )
        return TRUE;

    if( lstrcmpi( szClass, TEXT("tooltips_class32") ) != 0 )
        return TRUE;

    if( TryTooltip( hWnd, pInfo->pszName, pInfo->hwndCtl, pInfo->dwIDCtl ) != S_OK )
        return TRUE;

    // Didn't get anything - continue looking...
    if( pInfo->pszName[ 0 ] == '\0' )
        return TRUE;

    // Got it - can stop iterating now.
    return FALSE;
}




BOOL GetTooltipStringForControl( HWND hwndCtl, UINT uGetTooltipMsg, DWORD dwIDCtl, LPTSTR * ppszName )
{
    TCHAR szName[ MAX_NAME_SIZE ];

    BOOL fTryScanningForTooltip = TRUE;

    if( uGetTooltipMsg )
    {
        HWND hwndToolTip = (HWND) SendMessage( hwndCtl, uGetTooltipMsg, 0, 0 );
        if( hwndToolTip )
        {
            // We've found the tooltip window, so we won't need to scan for it.
            // Instead, when we exit this if, we'll fall through to the code that
            // post-processed the name we've got...
            fTryScanningForTooltip = FALSE;

            // Got a tooltip window - use it.
            // (Otherwise we fall through to scanning for a corresponding tooltip
            // window...)
            TOOLINFO ti;
            szName[ 0 ] = '\0';
            ti.cbSize = SIZEOF_TOOLINFO;
            ti.lpszText = szName;
            ti.hwnd = hwndCtl;
            ti.uId = dwIDCtl;

            HRESULT hr = XSend_ToolTip_GetItem( hwndToolTip, TTM_GETTEXT, 0, & ti, MAX_NAME_SIZE );

            if( hr != S_OK )
                return FALSE;

            // Fall through and post-process the string...
        }
    }


    if( fTryScanningForTooltip )
    {
        // Control doesn't know its tooltip window - instead scan for one...

        // Enum the top-level windows owned by this thread...
        DWORD pid;
        DWORD tid = GetWindowThreadProcessId( hwndCtl, & pid );

        EnumThreadWindowInfo info;
        info.hwndCtl = hwndCtl;
        info.dwIDCtl = dwIDCtl;
        info.pszName = szName;
        info.pszName[ 0 ] = '\0';

        EnumThreadWindows( tid, EnumThreadWindowsProc, (LPARAM) & info );
    }

    // At this stage we might have gotten a name from some tooltip window -
    // check if there's anything there...

    if( szName[ 0 ] == '\0' )
        return FALSE;

    int len = lstrlen( szName ) + 1; // +1 for terminating NUL
    *ppszName = (LPTSTR)LocalAlloc( LPTR, len * sizeof(TCHAR) );
    if( ! * ppszName )
        return FALSE;

    memcpy( *ppszName, szName, len * sizeof(TCHAR) );

    return TRUE;
}







// This function also resets the stream pointer to the beginning
static
HRESULT RewindStreamAndGetSize( LPSTREAM pstm, PDWORD pcbSize ) 
{
    *pcbSize = 0;  // If anything fails, 0 is returned

    LARGE_INTEGER li = { 0, 0 };
    HRESULT hr = pstm->Seek( li, STREAM_SEEK_SET, NULL );

    if( FAILED(hr) ) 
    {
        TraceErrorHR( hr, TEXT("RewindStreamAndGetSize: pstm->Seek() failed") );
        return hr;
    }

    // Get the number of bytes in the stream
    STATSTG statstg;
    hr = pstm->Stat( & statstg, STATFLAG_NONAME );

    if( FAILED(hr) ) 
    {
        TraceErrorHR( hr, TEXT("RewindStreamAndGetSize: pstm->Stat() failed") );
        return hr;
    }

    *pcbSize = statstg.cbSize.LowPart;

    return S_OK;
}


// Marshals an interface, returning pointer to marshalled buffer.
// When done, caller must call MarshalInterfaceDone().
HRESULT MarshalInterface( REFIID riid,
                          IUnknown * punk,
                          DWORD dwDestContext,
                          DWORD mshlflags,
                          
                          const BYTE ** ppData,
                          DWORD * pDataLen,

                          MarshalState * pMarshalState )
{
    IStream * pStm = NULL;
    HRESULT hr = CreateStreamOnHGlobal( NULL, TRUE, & pStm );
    if( FAILED( hr ) || ! pStm )
    {
        TraceErrorHR( hr, TEXT("MarshalInterface: CreateStreamOnHGlobal failed") );
        return FAILED( hr ) ? hr : E_FAIL;
    }

    // We use strong table marshalling to keep the object alive until we release it.
    hr = CoMarshalInterface( pStm, riid, punk,
                             dwDestContext, NULL, mshlflags );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("MarshalInterface: CoMarshalInterface failed") );
        pStm->Release();
        return hr;
    }

    HGLOBAL hGlobal = NULL;
    hr = GetHGlobalFromStream( pStm, & hGlobal );
    if( FAILED( hr ) || ! hGlobal )
    {
        TraceErrorHR( hr, TEXT("MarshalInterface: GetHGlobalFromStream failed") );
        LARGE_INTEGER li = { 0, 0 };
        pStm->Seek(li, STREAM_SEEK_SET, NULL);
        CoReleaseMarshalData( pStm );
        pStm->Release();
        return FAILED( hr ) ? hr : E_FAIL;
    }

    DWORD dwDataLen = 0;
    hr = RewindStreamAndGetSize( pStm, & dwDataLen );
    if( FAILED( hr ) || dwDataLen == 0 )
    {
        CoReleaseMarshalData( pStm );
        pStm->Release();
        return FAILED( hr ) ? hr : E_FAIL;
    }

    BYTE * pData = (BYTE *) GlobalLock( hGlobal );
    if( ! pData )
    {
        TraceErrorW32( TEXT("MarshalInterface: GlobalLock failed") );
        CoReleaseMarshalData( pStm );
        pStm->Release();
        return E_FAIL;
    }

    *ppData = pData;
    *pDataLen = dwDataLen;

    pMarshalState->pstm = pStm;
    pMarshalState->hGlobal = hGlobal;

    return S_OK;
}



void MarshalInterfaceDone( MarshalState * pMarshalState )
{
    // Unlock the HGLOBAL *before* we release the stream...
    GlobalUnlock( pMarshalState->hGlobal );

    pMarshalState->pstm->Release();
}




HRESULT ReleaseMarshallData( const BYTE * pMarshalData, DWORD dwMarshalDataLen )
{
    IStream * pStm = NULL;
    HRESULT hr = CreateStreamOnHGlobal( NULL, TRUE, & pStm );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("ReleaseMarshallData: CreateStreamOnHGlobal failed") );
        return hr;
    }
    
    if( pStm == NULL )
    {
        TraceErrorHR( hr, TEXT("ReleaseMarshallData: CreateStreamOnHGlobal returned NULL") );
        return E_FAIL;
    }

    hr = pStm->Write( pMarshalData, dwMarshalDataLen, NULL );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("ReleaseMarshallData: pStm->Write() failed") );
        pStm->Release();
        return hr;
    }

    LARGE_INTEGER li = { 0, 0 };
    hr = pStm->Seek( li, STREAM_SEEK_SET, NULL );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("ReleaseMarshallData: pStm->Seek() failed") );
        pStm->Release();
        return hr;
    }

    hr = CoReleaseMarshalData( pStm );
    pStm->Release();

    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("ReleaseMarshallData: CoReleaseMarshalData failed") );
        // Nothing we can do about this, so return S_OK anyway...
    }

    return S_OK;
}



HRESULT UnmarshalInterface( const BYTE * pData, DWORD cbData,
                            REFIID riid, LPVOID * ppv )
{
    // Allocate memory for data
    HGLOBAL hGlobal = GlobalAlloc( GMEM_MOVEABLE, cbData );
    if( hGlobal == NULL ) 
    {
        TraceErrorW32( TEXT("UnmarshalInterface: GlobalAlloc failed") );
        return E_OUTOFMEMORY;
    }

    VOID * pv = GlobalLock( hGlobal );
    if( ! pv )
    {
        TraceErrorW32( TEXT("UnmarshalInterface: GlobalLock failed") );
        GlobalFree( hGlobal );
        return E_FAIL;
    }

    memcpy( pv, pData, cbData );

    GlobalUnlock( hGlobal );

    // Create a stream out of the data buffer
    IStream * pstm;
    // TRUE => Delete HGLOBAL on release
    HRESULT hr = CreateStreamOnHGlobal( hGlobal, TRUE, & pstm );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("UnmarshalInterface: CreateStreamOnHGlobal failed") );
        GlobalFree( hGlobal );
        return hr;
    }

    hr = CoUnmarshalInterface( pstm, riid, ppv );
    if( FAILED( hr ) )
    {
        TraceErrorHR( hr, TEXT("UnmarshalInterface: CoUnmarshalInterface failed") );
    }

    pstm->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\w95trace.h ===
/*
    declarations for Win95 tracing facility
*/

#ifndef __TRACEW95__
#define __TRACEW95__



#if defined( _DEBUG ) ||defined( DEBUG ) || defined( DBG )

#define DBPRINTF OutputDebugStringW95




// redefine all the MFC macros to point to us

#undef  TRACE
#define TRACE   OutputDebugStringW95

#undef  TRACE0
#define TRACE0   OutputDebugStringW95

#undef  TRACE1
#define TRACE1   OutputDebugStringW95

#undef  TRACE2
#define TRACE2   OutputDebugStringW95

#undef  TRACE3
#define TRACE3   OutputDebugStringW95

// redefine OutputDebugString so that it works with 
// API calls
#undef OutputDebugString
#define OutputDebugString   OutputDebugStringW95


// function declarations
void OutputDebugStringW95( LPCTSTR lpOutputString, ... );



#else
  #define DBPRINTF        1 ? (void)0 : (void)
#endif  // _DEBUG || DEBUG || DBG


#endif  //__TRACEW95__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\w95trace.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation


/*
    Implementation of Win95 tracing facility to mimic that of NT. Works on both.
*/

#pragma warning(disable:4201)	// allows nameless structs and unions
#pragma warning(disable:4514)	// don't care when unreferenced inline functions are removed
#pragma warning(disable:4706)	// we are allowed to assign within a conditional


#include "windows.h"
#include <stdio.h>
#include <stdarg.h>
#include <process.h>
#include "w95trace.h"


#if defined( _DEBUG ) ||defined( DEBUG ) || defined( DBG )

void OutputDebugStringW95( LPCTSTR lpOutputString, ...)
{
    // Only produce output if this mutex is set...
    HANDLE hTestMutex = OpenMutex( SYNCHRONIZE, FALSE, TEXT("oleacc-msaa-use-dbwin") );
    if( ! hTestMutex )
        return;
    CloseHandle( hTestMutex );


    HANDLE heventDBWIN;  /* DBWIN32 synchronization object */
    HANDLE heventData;   /* data passing synch object */
    HANDLE hSharedFile;  /* memory mapped file shared data */
    LPTSTR lpszSharedMem;
    TCHAR achBuffer[500];

    /* create the output buffer */
    va_list args;
    va_start(args, lpOutputString);
    wvsprintf(achBuffer, lpOutputString, args);
    va_end(args);

    /* 
        Do a regular OutputDebugString so that the output is 
        still seen in the debugger window if it exists.

        This ifdef is necessary to avoid infinite recursion 
        from the inclusion of W95TRACE.H
    */
#ifdef UNICODE
    ::OutputDebugStringW(achBuffer);
#else
    ::OutputDebugStringA(achBuffer);
#endif

    /* bail if it's not Win95 */
    {
        OSVERSIONINFO VerInfo;
        VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&VerInfo);
        if ( VerInfo.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS )
            return;
    }

    /* make sure DBWIN is open and waiting */
    heventDBWIN = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_BUFFER_READY"));
    if ( !heventDBWIN )
    {
        //MessageBox(NULL, TEXT("DBWIN_BUFFER_READY nonexistent"), NULL, MB_OK);
        return;            
    }

    /* get a handle to the data synch object */
    heventData = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("DBWIN_DATA_READY"));
    if ( !heventData )
    {
        // MessageBox(NULL, TEXT("DBWIN_DATA_READY nonexistent"), NULL, MB_OK);
        CloseHandle(heventDBWIN);
        return;            
    }
    
    hSharedFile = CreateFileMapping((HANDLE)-1, NULL, PAGE_READWRITE, 0, 4096, TEXT("DBWIN_BUFFER"));
    if (!hSharedFile) 
    {
        //MessageBox(NULL, TEXT("DebugTrace: Unable to create file mapping object DBWIN_BUFFER"), TEXT("Error"), MB_OK);
        CloseHandle(heventDBWIN);
        CloseHandle(heventData);
        return;
    }

    lpszSharedMem = (LPTSTR)MapViewOfFile(hSharedFile, FILE_MAP_WRITE, 0, 0, 512);
    if (!lpszSharedMem) 
    {
        //MessageBox(NULL, "DebugTrace: Unable to map shared memory", "Error", MB_OK);
        CloseHandle(heventDBWIN);
        CloseHandle(heventData);
        return;
    }

    /* wait for buffer event */
    WaitForSingleObject(heventDBWIN, INFINITE);

    /* write it to the shared memory */
    *((LPDWORD)lpszSharedMem) = _getpid();
    wsprintf(lpszSharedMem + sizeof(DWORD), TEXT("%s"), achBuffer);

    /* signal data ready event */
    SetEvent(heventData);

    /* clean up handles */
    CloseHandle(hSharedFile);
    CloseHandle(heventData);
    CloseHandle(heventDBWIN);

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\version.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// OLEACC.DLL version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#include "verdefs.h"

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "Active Accessibility Core Component"
#define VER_INTERNALNAME_STR        "OLEACC"
#define VER_ORIGINALFILENAME_STR    "OLEACC.DLL"
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEVERSION             BUILD_VERSION_INT
#define VER_FILEVERSION_STR         BUILD_VERSION_STR

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\window.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  WINDOW.H
//
//  Default window OLE accessible object class
//
// --------------------------------------------------------------------------

class CWindow : public CAccessible
{
        // internal ctor. Private so taht derived classes don't inadvertantly use this -
        // they should use the one below (*where they specify a CLASS_ENUM) instead.
        // CreateWindowThing is a friend so it can create us (using new).

        CWindow()
            : CAccessible( CLASS_WindowObject )
        {
            // Done.
        }

        friend HRESULT CreateWindowThing(HWND hwnd, long idChildCur, REFIID riid, void** ppvObject);

    public:

        // Used by derived classes
        CWindow( CLASS_ENUM eclass )
            : CAccessible( eclass )
        {
            // Done.
        }

        // IAccessible
        virtual STDMETHODIMP    get_accParent(IDispatch ** ppdispParent);
        virtual STDMETHODIMP    get_accChild(VARIANT varChildIndex, IDispatch ** ppdispChild);

        virtual STDMETHODIMP    get_accName(VARIANT varChild, BSTR* pszName);
        virtual STDMETHODIMP    get_accDescription(VARIANT varChild, BSTR* pszDescription);
        virtual STDMETHODIMP    get_accRole(VARIANT varChild, VARIANT * pvarRole);
        virtual STDMETHODIMP    get_accState(VARIANT varChild, VARIANT *pvarState);
        virtual STDMETHODIMP    get_accHelp(VARIANT varChild, BSTR* pszHelp);
        virtual STDMETHODIMP    get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut);
        virtual STDMETHODIMP    get_accFocus(VARIANT * pvarFocusChild);

        virtual STDMETHODIMP    accSelect(long flags, VARIANT varChild);
        virtual STDMETHODIMP    accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        virtual STDMETHODIMP    accNavigate(long navDir, VARIANT varStart, VARIANT* pvarEndUpAt);
        virtual STDMETHODIMP    accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);

        // IEnumVARIANT
        virtual STDMETHODIMP    Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP    Clone(IEnumVARIANT * *);

        void    Initialize(HWND, long);

        //
        // NOTE:  We override the default implementation of ValidateChild()!
        //
        virtual BOOL ValidateChild(VARIANT*);
};


//
// Version defines
//
#define VER30   0x0300
#define VER31   0x030A
#define VER40   0x0400
#define VER41   0x040A

#define ObjidFromIndex(index)       (DWORD)(0 - (LONG)(index))
#define IndexFromObjid(objid)       (-(long)(objid))

extern HRESULT  CreateWindowThing(HWND hwnd, long iChild, REFIID riid, void** ppvObjct);
extern HRESULT  FrameNavigate(HWND, long, long, VARIANT *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\window.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  WINDOW.CPP
//
//  Window class.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"
#include "default.h"
#include "classmap.h"
#include "ctors.h"
#include "client.h"
#include "window.h"

#pragma warning( disable : 4005 ) // macro redefinition
#define COMPILE_MULTIMON_STUBS
#include "multimon.h"
#pragma warning( default : 4005 ) 


#define MaskBit(n)                  (1 << (n))

#define IndexFromNavDir(navdir)     (navdir - NAVDIR_UP)

// Remember, these are negative!
#define OBJID_WINDOW_FIRST      OBJID_SIZEGRIP
#define OBJID_WINDOW_LAST       OBJID_SYSMENU

typedef struct tagNAVIGATE
{
    long    NavPeer[4];
} NAVIGATE;

#ifndef CCHILDREN_FRAME
#define CCHILDREN_FRAME  7
#endif

// Order is Up, Down, Left, Right
NAVIGATE    rgFrameNavigate[CCHILDREN_FRAME] =
{
    // System menu
    {
        0, IndexFromObjid(OBJID_MENU), 0, IndexFromObjid(OBJID_TITLEBAR)
    },

    // Title bar
    {
        0, IndexFromObjid(OBJID_MENU), IndexFromObjid(OBJID_SYSMENU), 0
    },

    // Menu bar
    {
        IndexFromObjid(OBJID_TITLEBAR), IndexFromObjid(OBJID_CLIENT), 0, 0
    },

    // Client
    {
        IndexFromObjid(OBJID_MENU), IndexFromObjid(OBJID_HSCROLL), 0, IndexFromObjid(OBJID_VSCROLL)
    },

    // Vertical scrollbar
    {
        IndexFromObjid(OBJID_MENU), IndexFromObjid(OBJID_SIZEGRIP), IndexFromObjid(OBJID_CLIENT), 0
    },

    // Horizontal scrollbar
    {
        IndexFromObjid(OBJID_CLIENT), 0, 0, IndexFromObjid(OBJID_SIZEGRIP)
    },

    // Size grip
    {
        IndexFromObjid(OBJID_VSCROLL), 0, IndexFromObjid(OBJID_HSCROLL), 0
    }
};



// --------------------------------------------------------------------------
//
//  CreateWindowObject()
//
//  External function for CreateDefault...
//
// --------------------------------------------------------------------------
HRESULT CreateWindowObject(HWND hwnd, long idObject, REFIID riid, void** ppvWindow)
{
    UNUSED(idObject);

    InitPv(ppvWindow);

    if (!IsWindow(hwnd))
        return(E_FAIL);

    // Look for (and create) a suitable proxy/handler if one
    // exists. Use CreateWindowThing as default if none found.
    // (TRUE => use window, as opposed to client, classes)
    return FindAndCreateWindowClass( hwnd, TRUE, CLASS_WindowObject,
                                     OBJID_WINDOW, 0, riid, ppvWindow );
}


// --------------------------------------------------------------------------
//
//  CreateWindowThing()
//
//  Private function that uses atom type to decide what class of window
//  this is.  If there is a private create function, uses that one.  Else
//  uses generic window frame handler.
//
// --------------------------------------------------------------------------
HRESULT CreateWindowThing(HWND hwnd, long idChildCur, REFIID riid, void** ppvWindow)
{
    CWindow * pwindow;
    HRESULT     hr;

    InitPv(ppvWindow);

    pwindow = new CWindow();
    if (!pwindow)
        return(E_OUTOFMEMORY);

    // Can't be in the constructor--derived classes can't call the init
    // code if so.
    pwindow->Initialize(hwnd, idChildCur);

    hr = pwindow->QueryInterface(riid, ppvWindow);
    if (!SUCCEEDED(hr))
        delete pwindow;

    return(hr);
}


// --------------------------------------------------------------------------
//
//  CWindow::Initialize()
//
// --------------------------------------------------------------------------
void CWindow::Initialize(HWND hwnd, LONG iChild)
{
    m_hwnd = hwnd;
    m_cChildren = CCHILDREN_FRAME;
    m_idChildCur = iChild;
}



// --------------------------------------------------------------------------
//
//  CWindow::ValidateChild()
//
//  The window children are the OBJID_s of the elements that compose the
//  frame.  These are NEGATIVE values.  Hence we override the validation.
//
// --------------------------------------------------------------------------
BOOL CWindow::ValidateChild(VARIANT* pvar)
{
    //
    // This validates a VARIANT parameter and translates missing/empty
    // params.
    //

TryAgain:
    // Missing parameter, a la VBA
    switch (pvar->vt)
    {
        case VT_VARIANT | VT_BYREF:
            VariantCopy(pvar, pvar->pvarVal);
            goto TryAgain;

        case VT_ERROR:
            if (pvar->scode != DISP_E_PARAMNOTFOUND)
                return(FALSE);
            // FALL THRU

        case VT_EMPTY:
            pvar->vt = VT_I4;
            pvar->lVal = 0;
            break;

// remove this! VT_I2 is not valid!!
#ifdef  VT_I2_IS_VALID  // it isn't now...
        case VT_I2:
            pvar->vt = VT_I4;
            pvar->lVal = (long)pvar->iVal;
            // FALL THROUGH
#endif

        case VT_I4:
            if ((pvar->lVal > 0) || (pvar->lVal < (long)OBJID_WINDOW_FIRST))
                return(FALSE);
            break;

        default:
            return(FALSE);
    }

    return(TRUE);
}



// --------------------------------------------------------------------------
//
//  CWindow::get_accParent()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accParent(IDispatch ** ppdispParent)
{
    HWND    hwndParent;

    InitPv(ppdispParent);

    hwndParent = MyGetAncestor(m_hwnd, GA_PARENT);
    if (! hwndParent)
        return(S_FALSE);

    return(AccessibleObjectFromWindow(hwndParent, OBJID_CLIENT, IID_IDispatch,
        (void **)ppdispParent));
}



// --------------------------------------------------------------------------
//
//  CWindow::get_accChild()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accChild(VARIANT varChild, IDispatch ** ppdispChild)
{
    InitPv(ppdispChild);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    return(AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
        IID_IDispatch, (void**)ppdispChild));
}



// --------------------------------------------------------------------------
//
//  CWindow::get_accName()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accName(VARIANT varChild, BSTR* pszName)
{
    IAccessible * poleacc;
    HRESULT hr;

    InitPv(pszName);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // If the caller want's our name, forward to the client object
    //
    if (varChild.lVal == CHILDID_SELF)
        varChild.lVal = OBJID_CLIENT;


    //
    // Get the name of our child frame object.
    //
    poleacc = NULL;
    hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
        IID_IAccessible, (void **)&poleacc);
    if (!SUCCEEDED(hr))
        return(hr);

    varChild.lVal = CHILDID_SELF;
    hr = poleacc->get_accName(varChild, pszName);
    poleacc->Release();

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CWindow::get_accDescription()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accDescription(VARIANT varChild, BSTR* pszDesc)
{
    InitPv(pszDesc);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        return(S_FALSE);
    }
    else
    {
        IAccessible * poleacc;
        HRESULT hr;

        //
        // Get the description of our child frame object.
        //
        poleacc = NULL;
        hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal, IID_IAccessible,
            (void **)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);
        if (!poleacc)
            return(S_FALSE);

        varChild.lVal = CHILDID_SELF;
        hr = poleacc->get_accDescription(varChild, pszDesc);
        poleacc->Release();

        return(hr);
    }

}



// --------------------------------------------------------------------------
//
//  CWindow::get_accHelp()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{
    InitPv(pszHelp);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
        return(E_NOT_APPLICABLE);
    else
    {
        IAccessible * poleacc;
        HRESULT hr;

        //
        // Get the help for our child frame object.
        //
        poleacc = NULL;
        hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
            IID_IAccessible, (void **)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);
        if (!poleacc)
            return(S_FALSE);

        varChild.lVal = CHILDID_SELF;
        hr = poleacc->get_accHelp(varChild, pszHelp);
        poleacc->Release();

        return(hr);
    }

}



// --------------------------------------------------------------------------
//
//  CWindow::get_accRole()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accRole(VARIANT varChild, VARIANT* pvarRole)
{
    InitPvar(pvarRole);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == CHILDID_SELF)
    {
        //
        // Fill in our role.
        //
        pvarRole->vt = VT_I4;
        pvarRole->lVal = ROLE_SYSTEM_WINDOW;
    }
    else
    {
        IAccessible * poleacc;
        HRESULT hr;

        //
        // Get the role of our child frame object.
        //
        poleacc = NULL;
        hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
            IID_IAccessible, (void **)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);
        if (!poleacc)
            return(S_FALSE);

        varChild.lVal = CHILDID_SELF;
        hr = poleacc->get_accRole(varChild, pvarRole);
        poleacc->Release();

        return(hr);
    }

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CWindow::get_accState()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accState(VARIANT varChild, VARIANT* pvarState)
{
    HWND    hwndParent;

    InitPvar(pvarState);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    pvarState->vt = VT_I4;
    pvarState->lVal = 0;

    if (varChild.lVal == CHILDID_SELF)
    {
        //
        // Get our state.
        //
        WINDOWINFO  wi;
        RECT        rcParent;

        if (! MyGetWindowInfo(m_hwnd, &wi))
        {
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
            return(S_OK);
        }

        if (!(wi.dwStyle & WS_VISIBLE))
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;

        if (wi.dwStyle & WS_DISABLED)
            pvarState->lVal |= STATE_SYSTEM_UNAVAILABLE;

        if (wi.dwStyle & WS_THICKFRAME)
            pvarState->lVal |= STATE_SYSTEM_SIZEABLE;

        if ((wi.dwStyle & WS_CAPTION) == WS_CAPTION)
        {
            pvarState->lVal |= STATE_SYSTEM_MOVEABLE;
            pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;
        }

// Windows are not selectable, so they shouldn't be selected either.
#if 0
        if (wi.dwWindowStatus & WS_ACTIVECAPTION)
            pvarState->lVal |= STATE_SYSTEM_SELECTED;
#endif

        if (MyGetFocus() == m_hwnd)
            pvarState->lVal |= STATE_SYSTEM_FOCUSED;

        if (GetForegroundWindow() == MyGetAncestor(m_hwnd, GA_ROOT))
            pvarState->lVal |= STATE_SYSTEM_FOCUSABLE;

        // This is the _real_ parent window.
        if (hwndParent = MyGetAncestor(m_hwnd, GA_PARENT))
        {
            MyGetRect(hwndParent, &rcParent, FALSE);
            MapWindowPoints(hwndParent, NULL, (LPPOINT)&rcParent, 2);

			if ( hwndParent == GetDesktopWindow() )
			{
				if ( MonitorFromRect( &wi.rcWindow, MONITOR_DEFAULTTONULL ) == NULL )
					pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
			}
			else
			{
                if ( Rect1IsOutsideRect2( wi.rcWindow, rcParent ) )
                {
                    pvarState->lVal |= STATE_SYSTEM_INVISIBLE | STATE_SYSTEM_OFFSCREEN;
                }
            }
        }
    }
    else
    {
        IAccessible * poleacc;
        HRESULT hr;

        //
        // Ask the frame element what its state is.
        //
        poleacc = NULL;
        hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
            IID_IAccessible, (void **)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);
        if (!poleacc)
        {
            pvarState->lVal |= STATE_SYSTEM_INVISIBLE;
            return(S_OK);
        }

        varChild.lVal = CHILDID_SELF;
        hr = poleacc->get_accState(varChild, pvarState);
        poleacc->Release();

        return(hr);
    }

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CWindow::get_accKeyboardShortcut()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszShortcut)
{
    IAccessible * poleacc;
    HRESULT hr;

    InitPv(pszShortcut);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    //
    // If the caller is asking us for our shortcut, forward to the client.
    //
    if (varChild.lVal == CHILDID_SELF)
        varChild.lVal = OBJID_CLIENT;

    //
    // Ask the child.
    //
    poleacc = NULL;
    hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
        IID_IAccessible, (void **)&poleacc);
    if (!SUCCEEDED(hr))
        return(hr);

    varChild.lVal = CHILDID_SELF;
    hr = poleacc->get_accKeyboardShortcut(varChild, pszShortcut);
    poleacc->Release();

    return(hr);
}



// --------------------------------------------------------------------------
//
//  CWindow::get_accFocus()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::get_accFocus(VARIANT* pvarChild)
{
    HWND    hwndFocus;

    InitPvar(pvarChild);

    //
    // BOGUS!  If we are in menu mode, then menu object has focus.  If
    // we are in scrolling mode, scrollbar has the focus.  etc.
    //
    hwndFocus = MyGetFocus();

    if ((m_hwnd == hwndFocus) || IsChild(m_hwnd, hwndFocus))
        return(GetNoncObject(m_hwnd, OBJID_CLIENT, pvarChild));

    return(S_FALSE);
}



// --------------------------------------------------------------------------
//
//  CWindow::accNavigate()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::accNavigate(long dwNavDir, VARIANT varStart,
    VARIANT* pvarEnd)
{
    InitPvar(pvarEnd);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varStart)   ||
        ! ValidateNavDir(dwNavDir, varStart.lVal))
        return(E_INVALIDARG);

    if (dwNavDir == NAVDIR_FIRSTCHILD)
        return(FrameNavigate(m_hwnd, 0, NAVDIR_NEXT, pvarEnd));
    else if (dwNavDir == NAVDIR_LASTCHILD)
        return(FrameNavigate(m_hwnd, OBJID_SIZEGRIP-1, NAVDIR_PREVIOUS, pvarEnd));
    else if (varStart.lVal == CHILDID_SELF)
    {
        HWND    hwndParent;

        hwndParent = MyGetAncestor(m_hwnd, GA_PARENT);
        if (!hwndParent)
            return(S_FALSE);

        return (GetParentToNavigate(HWNDIDFromHwnd(hwndParent, m_hwnd), hwndParent,
            OBJID_CLIENT, dwNavDir, pvarEnd));
    }
    else
        return(FrameNavigate(m_hwnd, varStart.lVal, dwNavDir, pvarEnd));

}


// --------------------------------------------------------------------------
//
//  CWindow::accSelect()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::accSelect(long lSelFlags, VARIANT varChild)
{
    if (! ValidateChild(&varChild) ||
        ! ValidateSelFlags(lSelFlags))
        return E_INVALIDARG;

    if (lSelFlags != SELFLAG_TAKEFOCUS)
        return E_NOT_APPLICABLE;

    if (varChild.lVal)
        return S_FALSE ;

    MySetFocus( m_hwnd );

    return S_OK;
}



// --------------------------------------------------------------------------
//
//  CWindow::accLocation()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::accLocation(long* pxLeft, long* pyTop, long* pcxWidth,
    long* pcyHeight, VARIANT varChild)
{
    RECT    rc;

    InitAccLocation(pxLeft, pyTop, pcxWidth, pcyHeight);

    //
    // Validate parameters
    //
    if (! ValidateChild(&varChild))
        return(E_INVALIDARG);

    if (varChild.lVal == 0)
    {
        MyGetRect(m_hwnd, &rc, TRUE);

        *pxLeft = rc.left;
        *pyTop = rc.top;
        *pcxWidth = rc.right - rc.left;
        *pcyHeight = rc.bottom - rc.top;
    }
    else
    {
        //
        // Ask the child.
        //
        IAccessible * poleacc;
        HRESULT hr;

        //
        // Get the help for our child frame object.
        //
        poleacc = NULL;
        hr = AccessibleObjectFromWindow(m_hwnd, varChild.lVal,
            IID_IAccessible, (void **)&poleacc);
        if (!SUCCEEDED(hr))
            return(hr);
        if (!poleacc)
            return(S_FALSE);

        varChild.lVal = CHILDID_SELF;
        hr = poleacc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
        poleacc->Release();

        return(hr);
    }

    return(S_OK);
}


// --------------------------------------------------------------------------
//
//  CWindow::accHitTest()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::accHitTest(long xLeft, long yTop, VARIANT* pvarHit)
{
    WINDOWINFO wi;
    long    lEnd;
    long    lHit;
    POINT   pt;

    InitPvar(pvarHit);

    lEnd = 0;

    if (! MyGetWindowInfo(m_hwnd, &wi))
        return(S_FALSE);

    //
    // Find out where point is.  But special case the client area!
    //
    pt.x = xLeft;
    pt.y = yTop;
    if (PtInRect(&wi.rcClient, pt))
        goto ReallyTheClient;

    lHit = SendMessageINT(m_hwnd, WM_NCHITTEST, 0, MAKELONG(xLeft, yTop));

    switch (lHit)
    {
        case HTERROR:
        case HTNOWHERE:
            return(S_FALSE);

        case HTCAPTION:
        case HTMINBUTTON:
        case HTMAXBUTTON:
        case HTHELP:
        case HTCLOSE:
        // case HTIME!
            lEnd = OBJID_TITLEBAR;
            break;

        case HTMENU:
            lEnd = OBJID_MENU;
            break;

        case HTSYSMENU:
            lEnd = OBJID_SYSMENU;
            break;

        case HTHSCROLL:
            lEnd = OBJID_HSCROLL;
            break;

        case HTVSCROLL:
            lEnd = OBJID_VSCROLL;
            break;

        case HTCLIENT:
        case HTTRANSPARENT:
ReallyTheClient:
            lEnd = OBJID_CLIENT;
            break;

        case HTGROWBOX:
            lEnd = OBJID_SIZEGRIP;
            break;

        case HTBOTTOMRIGHT:
            // Note that for sizeable windows, being over the size grip may
            // return in fact HTBOTTOMRIGHT for sizing purposes.  If this
            // point is inside the window borders, that is the case.
            if ((xLeft < wi.rcWindow.right - (int)wi.cxWindowBorders) &&
                (yTop < wi.rcWindow.bottom - (int)wi.cyWindowBorders))
            {
                lEnd = OBJID_SIZEGRIP;
            }
            break;

        // Includes borders!
        default:
            break;
    }

    if (lEnd)
        return(GetNoncObject(m_hwnd, lEnd, pvarHit));
    else
    {
        pvarHit->vt = VT_I4;
        pvarHit->lVal = lEnd;
    }

    return(S_OK);
}



// --------------------------------------------------------------------------
//
//  CWindow::Next()
//
//  We do loop from 0 to cChildren, it's just that the IDs are NEGATIVE,
//  not positive.  We accept child ids that are OBJIDs.
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::Next(ULONG celt, VARIANT* rgvar, ULONG* pceltFetched)
{
    VARIANT* pvar;
    long    cFetched;
    long    iCur;

    // Can be NULL
    if (pceltFetched)
        *pceltFetched = 0;

    pvar = rgvar;
    cFetched = 0;
    iCur = m_idChildCur;

    //
    // Loop through our items
    //
    while ((cFetched < (long)celt) && (iCur < m_cChildren))
    {
        cFetched++;
        iCur++;

        //
        // Note this gives us -((index)+1), which means we start at -1 and
        // decrement.  Conveniently, this corresponds to OBJID values!
        //
        pvar->vt = VT_I4;
        pvar->lVal = 0 - iCur;
        ++pvar;
    }

    //
    // Advance the current position
    //
    m_idChildCur = iCur;

    //
    // Fill in the number fetched
    //
    if (pceltFetched)
        *pceltFetched = cFetched;

    //
    // Return S_FALSE if we grabbed fewer items than requested
    //
    return((cFetched < (long)celt) ? S_FALSE : S_OK);
}



// --------------------------------------------------------------------------
//
//  CWindow::Clone()
//
// --------------------------------------------------------------------------
STDMETHODIMP CWindow::Clone(IEnumVARIANT ** ppenum)
{
    InitPv(ppenum);

    // Look for (and create) a suitable proxy/handler if one
    // exists. Use CreateWindowThing as default if none found.
    // (TRUE => use window, as opposed to client, classes)
    return FindAndCreateWindowClass( m_hwnd, TRUE, CLASS_WindowObject,
                           OBJID_WINDOW, m_idChildCur, IID_IEnumVARIANT, (void**)ppenum );
}




// --------------------------------------------------------------------------
//
//  FrameNavigate()
//
//  Default handling of navigation among frame children.  The standard
//  frame widget handlers (titlebar, menubar, scrollbar, etc.) hand off
//  peer navigation to us, their parent.  There are two big reasons for this:
//
//  (1) It saves on code and ease of implementation, since the knowledge of
//      what is to the left of what, what is below what, etc. only has to
//      be coded in one place.
//
//  (2) It allows apps that want to manage their own frame and e.g. add a
//      new element that acts like a frame piece yet still have navigation
//      work properly.  Their frame handler can hand off to the default
//      implementation but trap navigation.
//
// --------------------------------------------------------------------------
HRESULT FrameNavigate(HWND hwndFrame, long lStart, long dwNavDir,
    VARIANT * pvarEnd)
{
    long        lEnd;
    long        lMask;
    WINDOWINFO  wi;
    TCHAR       szClassName[128];
    BOOL        bFound = FALSE;
    IAccessible *   poleacc;
    IDispatch * pdispEl;
    HRESULT     hr;

    //
    // Currently, we get an index (fix validation layer so IDs are OBJIDs)
    //
    lEnd = 0;

    lStart = IndexFromObjid(lStart);

    //
    // Figure out what is present, what isn't.
    //
    if (!MyGetWindowInfo(hwndFrame, &wi))
        return(E_FAIL);

    lMask = 0;
    lMask |= MaskBit(IndexFromObjid(OBJID_CLIENT));

    if ((wi.dwStyle & WS_CAPTION)== WS_CAPTION)
        lMask |= MaskBit(IndexFromObjid(OBJID_TITLEBAR));

    if (wi.dwStyle & WS_SYSMENU)
        lMask |= MaskBit(IndexFromObjid(OBJID_SYSMENU));

    if (wi.dwStyle & WS_VSCROLL)
        lMask |= MaskBit(IndexFromObjid(OBJID_VSCROLL));

    if (wi.dwStyle & WS_HSCROLL)
        lMask |= MaskBit(IndexFromObjid(OBJID_HSCROLL));

    if ((wi.dwStyle & (WS_HSCROLL | WS_VSCROLL)) == (WS_HSCROLL | WS_VSCROLL))
        lMask |= MaskBit(IndexFromObjid(OBJID_SIZEGRIP));

    if (!(wi.dwStyle & WS_CHILD) && GetMenu(hwndFrame))
        lMask |= MaskBit(IndexFromObjid(OBJID_MENU));

    // HACKISH BIT for new IE4/Shell Menubands
    // The menus aren't menus, so we have to see if this thing
    // has menubands.
    // First, check the classname - only the browser and shell
    // windows have these things...
    // The reason we have to do this is because the IE4 guys are
    // slackers and didn't do very much for accessibility.
    GetClassName (hwndFrame, szClassName,ARRAYSIZE(szClassName));
    if ((0 == lstrcmp (szClassName,TEXT("IEFrame"))) ||
        (0 == lstrcmp (szClassName,TEXT("CabinetWClass"))))
    {
        HWND            hwndWorker;
        HWND            hwndRebar;
        HWND            hwndSysPager;
        HWND            hwndToolbar;

        // We can just send a WM_GETOBJECT to the menuband window,
        // we just have to find it. Let's use FindWindowEx to do that.
        // This is not easy: There are 4 children of an IEFrame Window,
        // and I am not sure how many children of a shell window (CabinetWClass).
        // For IEFrame windows, the menuband is the:
        // ToolbarWindow32 child of a SysPager that is the child of a
        // RebarWindow32 that is the child of a Worker.
        // But there are 2 Worker windows at the 1st level down,
        // and 2 SysPagers that are children of the RebarWindow32.

        bFound = FALSE;
        hwndWorker = NULL;
        while (!bFound)
        {
            hwndWorker = FindWindowEx (hwndFrame,hwndWorker,TEXT("Worker"),NULL);
            if (!hwndWorker)
                break;

            hwndRebar = FindWindowEx (hwndWorker,NULL,TEXT("RebarWindow32"),NULL);
            if (!hwndRebar)
                continue;

            hwndSysPager = NULL;
            while (!bFound)
            {
                hwndSysPager = FindWindowEx (hwndRebar,hwndSysPager,TEXT("SysPager"),NULL);
                if (!hwndSysPager)
                    break;
                hwndToolbar = FindWindowEx (hwndSysPager,NULL,TEXT("ToolbarWindow32"),NULL);
                hr = AccessibleObjectFromWindow (hwndToolbar,OBJID_MENU,
                                                 IID_IAccessible, (void **)&poleacc);
                if (SUCCEEDED(hr))
                {
                    bFound = TRUE;
                    lMask |= MaskBit(IndexFromObjid(OBJID_MENU));
                }
            }
        }
    } // end if we are talking to something that might have a menuband

    switch (dwNavDir)
    {
        case NAVDIR_NEXT:
            lEnd = lStart;
            while (++lEnd <= CCHILDREN_FRAME)
            {
                // Is the next item present?
                if (lMask & MaskBit(lEnd))
                    break;
            }

            if (lEnd > CCHILDREN_FRAME)
                lEnd = 0;
            break;

        case NAVDIR_PREVIOUS:
            lEnd = lStart;
            while (--lEnd > 0)
            {
                // Is the previous item present?
                if (lMask & MaskBit(lEnd))
                    break;
            }

            Assert(lEnd >= 0);
            break;

        case NAVDIR_UP:
        case NAVDIR_DOWN:
        case NAVDIR_LEFT:
        case NAVDIR_RIGHT:
            lEnd = lStart;
            while (lEnd = rgFrameNavigate[lEnd-1].NavPeer[IndexFromNavDir(dwNavDir)])
            {
                // Is this item around?
                if (lMask & MaskBit(lEnd))
                    break;
            }
            break;
    }

    if (lEnd)
    {
        // now finish up our hackish work. For normal things, we just
        // return GetNoncObject, which is basically just a call to
        // AccessibleObjectFromWindow with the id of the frame element,
        // and then it just stuffs the return value (an IDispatch) into
        // the VARIANT.
        // For IE4 hackish stuff, we have an IAccessible, we'll QI for
        // IDispatch, Release the IAccessible, and stuff the IDispatch
        // into a VARIANT.
        if (bFound && lEnd == IndexFromObjid(OBJID_MENU))
        {
            hr = poleacc->QueryInterface(IID_IDispatch,(void**)&pdispEl);
			poleacc->Release();

            if (!SUCCEEDED(hr))
                return(hr);
            if (!pdispEl)
                return(E_FAIL);

            pvarEnd->vt = VT_DISPATCH;
            pvarEnd->pdispVal = pdispEl;
            return (S_OK);
        }
        else
            return(GetNoncObject(hwndFrame, ObjidFromIndex(lEnd), pvarEnd));
    }
    else
        return(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\win64helper.cpp ===
// Copyright (c) 1996-2000 Microsoft Corporation
// ----------------------------------------------------------------------------
// Win64Helper.cpp
//
// Helper functions used by all the control wrappers
//
// ----------------------------------------------------------------------------
#include "Win64Helper.h"
#include "w95trace.h"

#include "RemoteProxy6432.h"
#include <atlbase.h> // CComPtr


// Used for Tab control code
// cbExtra for the tray is 8, so pick something even bigger, 16
#define CBEXTRA_TRAYTAB     16



// Stuff in this file:
//
// * Bitness utility functions
//   - determine whether we are on a 32- or 64- bit system, determine
//     what bitness a process is.
//
// * Cross-proc SendMessage utility class
//   - manages allocting a struct in the remote process, copying to that
//     struct, sending a message, and copying back out the result.
//
// * Remote type template class
//   - template class used in the explicit 64/32 structure definitions
//
// * Explicit 64/32 structure definitions
//   - Definitions of comctl and related structs (eg. LVITEM) in separate
//     64- and 32-bit versions (eg. LVITEM_64, LVITEM_32) that have the
//     correct item sizes, layout and alignment for that bitness.
//
// * Cross-proc message handlers
//   - one for each supported message/datatype. (eg. ListView_Get_Handler
//     handles LVM_GETITEM which uses LVITEM.) These copy the 'in' fields
//     from a local struct (eg. LVITEM) to a local copy of the appropriate
//     'remote' struct (eg. LVITEM_32 or LVITEM_64, depending on the bitness
//     of the target proxy), use the cross-proc sendmessage helper to
//     copy that to the remote proc, send the message, and copy back; and
//     then copy the appropriate 'out' fields back to the original local
//     struct.
//
// * Stub macro
//   - this macro declares a function that does a plain sendmessage if we're
//     in the same process as the target HWND - otherwise it uses a cross-proc
//     handler (see above) to send the message cross-proc.
//
//
// * GetRemoteProxyFactory
//   - Lives here because there's no other suitable place for it.
//
//





// ----------------------------------------------------------------------------
//
//  Bitness utility functions
//
//  Class CProcessorType is used to determine whether we are running on a
//  64- or 32-bit system (regardless of whether this is a 32- or 64-bit
//  process - eg. we could be a 32-bit process on a 64-bit machine).
//
//  Function SameBitness determines if a window belongs to a process with the
//  same bitness as the current process.
//
// ----------------------------------------------------------------------------


// Taken from enum _PROCESSINFOCLASS in NT\PUBLIC\sdk\inc\ntpsapi.h ...

#define ProcessWow64Information 26

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

typedef enum ProcessorTypes {
    ProcessorUndef,
    ProcessorX86,
    ProcessorIA64
} ProcessorTypes;

class CProcessorType {
private:
    static ProcessorTypes m_ProcessorType;
    static void Init()
    {
        if (m_ProcessorType != ProcessorUndef)
            return;
#ifndef _WIN64
        ULONG_PTR Wow64Info = NULL;
        HANDLE hProcess;

        hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
        long lStatus = MyNtQueryInformationProcess(hProcess, ProcessWow64Information, &Wow64Info, sizeof(Wow64Info), NULL);
        CloseHandle(hProcess);
        if (NT_ERROR(lStatus))
        {
            // Query failed.  Must be on an NT4 or earlier NT machine.  Definitely a 32-bit machine.
            m_ProcessorType = ProcessorX86;
        } else if (Wow64Info) 
        {
            // We are running inside WOW64 on a 64-bit machine
            m_ProcessorType = ProcessorIA64;
        } else 
        {
            // We are running on x86 Win2000 or later OS
            m_ProcessorType = ProcessorX86;
        }
        DBPRINTF(TEXT("CProcessorType:  !_WIN64 defined m_ProcessorType=%d\r\n"), m_ProcessorType);
#else
        // _WIN64 is defined, so definitely running on a 64-bit processor
        m_ProcessorType = ProcessorIA64;
        DBPRINTF(TEXT("CProcessorType:  _WIN64 defined m_ProcessorType=%d\r\n"), m_ProcessorType);
#endif
    };
public:
    CProcessorType() {};
    ~CProcessorType() {};
    static BOOL ProcessorIsIA64() {
        Init();
        return m_ProcessorType == ProcessorIA64;
    }
    static BOOL ProcessorIsX86() {
        Init();
        return m_ProcessorType == ProcessorX86;
    }
};
ProcessorTypes CProcessorType::m_ProcessorType = ProcessorUndef;




HRESULT SameBitness(HWND hwnd, BOOL *pfIsSameBitness)
{
    *pfIsSameBitness = TRUE;

#ifndef ENABLE6432_INTEROP
    return S_OK;
#endif

    // If running on an X86 then we must be same bitness
    if (CProcessorType::ProcessorIsX86())
        return S_OK;

    DWORD dwProcessId;
    if ( !GetWindowThreadProcessId(hwnd, &dwProcessId) )
        return E_FAIL;
    
    BOOL fIs32Bit;
    
    HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, dwProcessId);
    if ( NULL == hProcess )
    {
        // The desktop window is in a process that OpenProcess fails on
        // with an ERROR_ACCESS_DENIED (5) so special case it an assume 
        // its the same as the platform
        // TODO figure out what other thisngs could fall in this catagory 
        // and deal with them as exceptions
        const HWND hwndDesktop = GetDesktopWindow();
        if ( hwnd == hwndDesktop )
        {
            // at this point we are on a 64 bit platfrom and therefore
            // can assume that the desktop is 64 bit as well
            fIs32Bit = FALSE;   
        }
        else
        {
            DWORD dwErr = GetLastError();
            DBPRINTF( TEXT("OpenProcess returned null GetLastError()=%d\r\n"), dwErr );
            return E_FAIL;
        }
    }
    else
    {
        ULONG_PTR Wow64Info = NULL;
        long rv = MyNtQueryInformationProcess(
                      hProcess
                    , ProcessWow64Information
                    , &Wow64Info
                    , sizeof(Wow64Info)
                    , NULL);
        CloseHandle(hProcess);

        if (NT_ERROR(rv))
        {
            Wow64Info = NULL;    // fake that process is 64bit (OK because this code only executed for _WIN64)
        }

        fIs32Bit = (NULL != Wow64Info);
    }
    
#ifdef _WIN64
    *pfIsSameBitness = !fIs32Bit;
#else
    *pfIsSameBitness = fIs32Bit;
#endif
    return S_OK;
}




// ----------------------------------------------------------------------------
//
//  Cross-proc SendMessage utility class
//
//  The cross-proc message handlers all follow a similar pattern.
//
//  First, the handler works out how much extra storage it will need - eg.
//  for returning a text string. It then calls Alloc() with the size of the
//  base struct (eg. LVITEM), and the size of the extra data - if any (may be
//  0).
//
//  Alloc() then allocaes space for both the base struct and the extra
//  data, and returns TRUE if the allocation succeeded.
//
//  GetExtraPtr() returns a pointer, relative to the remote process, to the
//  extra space. If no extra space was requested, it returns NULL.
//
//  ReadExtra() is used to read data in that extra space from the remote
//  process to the local process. If no extra space was requested, it
//  does nothing.
//  
//  WriteSendMsgRead() copies the struct to the remote process, sends the
//  message using SendMessage, and then copies the struct back to the local
//  process.
//
//  WriteSendMsg() is the same as WriteSendMsgRead(), except it does not
//  copy the result back. (This is used for 'put' messages that do not
//  return information.)
//
// ----------------------------------------------------------------------------

class CXSendHelper
{
private:
    void *  m_pvAddress;    // Ptr to remote shared mem
    HANDLE  m_hProcess;     // Handle of remote process
    UINT    m_cbSize;       // Size of base struct
    UINT    m_cbExtra;      // Size of extra stuff - usually text - stored after the struct

public:

    CXSendHelper() : m_pvAddress(0) {};

    virtual ~CXSendHelper() 
    {
        if (m_pvAddress)
        {
            ::SharedFree(m_pvAddress, m_hProcess);
            m_pvAddress = 0;
        }
    }

    BOOL Alloc( HWND hwnd, UINT cbSize, UINT cbExtra )
    {
        m_cbSize = cbSize;
        m_cbExtra = cbExtra;
        m_pvAddress = ::SharedAlloc( cbSize + cbExtra, hwnd, &m_hProcess );
        return m_pvAddress != NULL;
    }

    void * GetExtraPtr()
    {
        // If no extra space was requested, then return NULL...
        if( ! m_cbExtra )
        {
            return NULL;
        }

        // Return pointer to the 'extra' data that follows the struct
        return (BYTE *)m_pvAddress + m_cbSize;
    }

    BOOL ReadExtra( LPVOID lpvDest, LPVOID lpvRemoteSrc, BOOL fIsString )
    {
        // Does nothing if no extra space was requested.
        if( ! m_cbExtra )
            return TRUE;
        
        if( lpvRemoteSrc )
        {
            // This may point to the extra space we allocated, or the control may
            // have changed the pointer to point to its own data instead of copying
            // into the space we allocated.
            if( ! SharedRead( lpvRemoteSrc, lpvDest, m_cbExtra, m_hProcess ) )
                return FALSE;

            if( fIsString )
            {
                // Paranoia - forcibly NUL-terminate, in case we get garbage...
                LPTSTR pEnd = (LPTSTR)((BYTE *)lpvDest + m_cbExtra) - 1;
                *pEnd = '\0';
            }

            return TRUE;
        }
        else
        {
            // The control changed the pointer to NULL - assume that this means there's
            // nothing there.
            if( fIsString )
            {
                // Use empty string
                *(LPTSTR)lpvDest = '\0';
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
    }

    template < class T >
    BOOL WriteSendMsgRead ( T * pStruct, HWND hwnd, UINT uMsg, WPARAM wParam, BOOL fCheckSend )
    {
        // Copy the struct to the remote process...
        if( ! SharedWrite( pStruct, m_pvAddress, sizeof( T ), m_hProcess ) )
        {
            return FALSE;
        }

        // Send the message...
        // If SendMessage fails, we fail only if the fCheckSend flag is specified.
        if( ( ! SendMessage( hwnd, uMsg, wParam, (LPARAM) m_pvAddress) ) && fCheckSend )
        {
            return FALSE;
        }

        // Copy returned struct back to local process...
        if( ! SharedRead( m_pvAddress, pStruct, sizeof( T ), m_hProcess ) )
        {
            return FALSE;
        }

        return TRUE;
    }

    template < class T >
    BOOL WriteSendMsg ( T * pStruct, HWND hwnd, UINT uMsg, WPARAM wParam, BOOL fCheckSend )
    {
        // Copy the struct remotely...
        if( ! SharedWrite( pStruct, m_pvAddress, sizeof( T ), m_hProcess ) )
            return FALSE;

        // Send the message...
        // If SendMessage fails, we fail only if the fCheckSend flag is specified.
        if( ! SendMessage( hwnd, uMsg, wParam, (LPARAM) m_pvAddress) && fCheckSend )
            return FALSE;

        return TRUE;
    }
};






// ----------------------------------------------------------------------------
//
//  'Remote Type' template class
//
//  This is used to represent a type in a remote address space.
//  While the local type may be a poiter, a handle, or some other 'native'
//  type, when accessed remotely, an integer type is used to ensure correct
//  size.
//
//  Eg. a pointer in a 64-bit process is represented as a ULONG64; a ptr in a
//  32-bit process is represented as a ULONG32.
//
//  Signedness matters for some types - pointers are zero-extended when going
//  from 32-to-64, but handles are sign-extended.
//
//  This class, which has assignment and conversion operators defined, takes
//  care of the necessary casting to ensure correct conversion between the
//  local type and the remote representation
//
//  This is a template class, which takes the following parameters:
//  
//    REMOTE_INT       - remote representation type - eg. ULONG64, LONG32, etc.
//    LOCAL_INT_PTR    - local integer type, eg. ULONG_PTR, LONG_PTR
//    LOCAL_TYPE       - local type - eg handle, void*, LPARAM, etc.
//
//
//  A 64-bit pointer, for example, would have a REMOTE_INT of ULONG64 - 64bit
//  size, unsigned for zero-extension; a LOCAL_INT_PTR of ULONG_PTR - same
//  sign as REMOTE_INT - and a local type of void*.
//
// ----------------------------------------------------------------------------

template < typename REMOTE_INT, typename LOCAL_INT_PTR, typename LOCAL_TYPE >
class RemoteType
{
    REMOTE_INT    m_val;

public:

    void operator = ( LOCAL_TYPE h )
    {
        // Convert from local type to remote integer type, via local integer type
        m_val = (REMOTE_INT) (LOCAL_INT_PTR) h;
    }

    operator LOCAL_TYPE ( )
    {
        // Convert from remote integer to local type, via local integer type
        return (LOCAL_TYPE) (LOCAL_INT_PTR) m_val;
    }
};


typedef RemoteType< ULONG32, ULONG_PTR, void * > Ptr32;
typedef RemoteType< ULONG64, ULONG_PTR, void * > Ptr64;

typedef RemoteType< LONG32, LONG_PTR, LPARAM > LParam32;
typedef RemoteType< LONG64, LONG_PTR, LPARAM > LParam64;

typedef RemoteType< LONG32, LONG_PTR, HWND > HWnd32;
typedef RemoteType< LONG64, LONG_PTR, HWND > HWnd64;

typedef RemoteType< LONG32, LONG_PTR, HBITMAP > HBitmap32;
typedef RemoteType< LONG64, LONG_PTR, HBITMAP > HBitmap64;

typedef RemoteType< LONG32, LONG_PTR, HINSTANCE > HInstance32;
typedef RemoteType< LONG64, LONG_PTR, HINSTANCE > HInstance64;






// ----------------------------------------------------------------------------
//
// Explicit 32-bit and 64-bit versions of the control structs
//
// These use explicit 'remote type' fields instead of handler or pointer,
// to ensure the correct size and sign extension when compiled as either
// 32-bit or 64-code. "for_alignment" fields are also added to the 64-bit
// versions where necessary to obtain correct alignment.
//
// These structs do not contain recently added fields (those that are ifdef'd
// out with #if (_WIN32_IE >= 0x0300) or later) - we go for a 'least common
// denominator' approach. The earlier, smalleer structs are accepted by both
// old and new comctl versions; but only the recent comctl versions accept
// the larger structs.
//
// (This only really matters where the struct has a cbSize field - otherwise
// a field isn't used unless it is referenced by a bit in the mask.)
//
// ----------------------------------------------------------------------------

struct LVITEM_32 {
    UINT        mask; 
    int         iItem; 
    int         iSubItem; 
    UINT        state; 
    UINT        stateMask; 
    Ptr32       pszText; 
    int         cchTextMax; 
    int         iImage; 
    LParam32    lParam;
    int         iIndent;
};

struct LVITEM_64 {
    UINT        mask; 
    int         iItem; 
    int         iSubItem; 
    UINT        state; 
    UINT        stateMask; 
    UINT        for_alignment;
    Ptr64       pszText;
    int         cchTextMax; 
    int         iImage; 
    LParam64    lParam;
    int         iIndent;
};


// LVITEM_V6 structs are extensions of the old ones...
struct LVITEM_V6_32: public LVITEM_32
{
    int         iGroupId;
    UINT        cColumns;
    Ptr32       puColumns;
};

struct LVITEM_V6_64: public LVITEM_64
{
    int         iGroupId;
    UINT        cColumns;
    Ptr64       puColumns;
};

struct LVGROUP_V6_32
{
    UINT    cbSize;
    UINT    mask;
    Ptr32  pszHeader;
    int     cchHeader;

    Ptr32  pszFooter;
    int     cchFooter;

    int     iGroupId;

    UINT    stateMask;
    UINT    state;
    UINT    uAlign;
};

struct LVGROUP_V6_64
{
    UINT    cbSize;
    UINT    mask;
    Ptr64  pszHeader;
    int     cchHeader;

    Ptr64  pszFooter;
    int     cchFooter;

    int     iGroupId;

    UINT    stateMask;
    UINT    state;
    UINT    uAlign;
};



struct LVCOLUMN_32 {
    UINT        mask;
    int         fmt;
    int         cx;
    Ptr32       pszText;
    int         cchTextMax;
    int         iSubItem;
};

struct LVCOLUMN_64 {
    UINT        mask;
    int         fmt;
    int         cx;
    UINT        for_alignment;
    Ptr64       pszText;
    int         cchTextMax;
    int         iSubItem;
};



struct HDITEM_32 {
    UINT        mask; 
    int         cxy; 
    Ptr32       pszText; 
    HBitmap32   hbm; 
    int         cchTextMax; 
    int         fmt; 
    LParam32    lParam; 
    int         iImage;
    int         iOrder;
};

struct HDITEM_64 {
    UINT        mask; 
    int         cxy; 
    Ptr64       pszText;
    HBitmap64   hbm; 
    int         cchTextMax; 
    int         fmt; 
    LParam64    lParam; 
    int         iImage;
    int         iOrder;
};

struct TCITEM_32 {
    UINT        mask;
    DWORD       dwState;
    DWORD       dwStateMask;
    Ptr32       pszText;
    int         cchTextMax;
    int         iImage;
    LParam32    lParam;
}; 

struct TCITEM_64 {
    UINT        mask;
    DWORD       dwState;
    DWORD       dwStateMask;
    UINT        for_alignment;
    Ptr64       pszText;
    int         cchTextMax;
    int         iImage;
    LParam64    lParam;
}; 

struct TOOLINFO_32 {
    UINT        cbSize; 
    UINT        uFlags; 
    HWnd32      hwnd; 
    WPARAM      uId; 
    RECT        rect; 
    HInstance32 hinst; 
    Ptr32       lpszText; 
};

struct TOOLINFO_64 {
    UINT        cbSize; 
    UINT        uFlags; 
    HWnd64      hwnd; 
    WPARAM      uId; 
    RECT        rect; 
    HInstance64 hinst; 
    Ptr64       lpszText; 
};


struct TTGETTITLE_32
{
    DWORD       dwSize;
    UINT        uTitleBitmap;
    UINT        cch;
    Ptr32       pszTitle;
};

struct TTGETTITLE_64
{
    DWORD       dwSize;
    UINT        uTitleBitmap;
    UINT        cch;
    UINT        for_alignment;
    Ptr64       pszTitle;
};



// ----------------------------------------------------------------------------
//
//  Handlers for the common controls message handlers
//
//  The basic structure of these is:
//
//  1. Determine if extra storage is needed for text.
//  2. Allocate storage
//  3. Fill a local struct that has the same bitness as the target
//  4. Copy that struct to the remote process, do the SendMessage, and copy
//     the struct back
//  5. Copy fields from that struct back to the local one
//  6. Copy any extra data back (usually text) if necessary
//
// ----------------------------------------------------------------------------


template <class T>
HRESULT ListView_Get_Handler( T & lvDest, HWND hwnd, UINT uiMsg, WPARAM wParam, LVITEM * pItemSrc, BOOL fCheckSend, UINT )
{
    // work out required size of target struct, and allocate...
    DWORD dwTextSize = 0;
    if(pItemSrc->mask & LVIF_TEXT)
        dwTextSize = sizeof(TCHAR) * (pItemSrc->cchTextMax + 1);

    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), dwTextSize ) )
        return E_OUTOFMEMORY;

    // Copy to remote struct...
    lvDest.mask         = pItemSrc->mask;
    lvDest.iItem        = pItemSrc->iItem;
    lvDest.iSubItem     = pItemSrc->iSubItem;
    lvDest.pszText      = xsh.GetExtraPtr();
    lvDest.cchTextMax   = pItemSrc->cchTextMax;


    if( ! xsh.WriteSendMsgRead( & lvDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;

    // Copy back the struct out members...
    pItemSrc->state     = lvDest.state;
    pItemSrc->stateMask = lvDest.stateMask;
    pItemSrc->iImage    = lvDest.iImage;
    pItemSrc->lParam    = lvDest.lParam;
    pItemSrc->iIndent   = lvDest.iIndent;

    // Copy text back out separately...
    if( ! xsh.ReadExtra( pItemSrc->pszText, lvDest.pszText, TRUE ) )
        return E_FAIL;

    return S_OK;
}


template <class T>            // T is one of the LVITEM types
HRESULT ListView_Set_Handler( T & lvDest, HWND hwnd, UINT uiMsg, WPARAM wParam, LVITEM *pItemSrc, BOOL fCheckSend, UINT )
{
    // work out required size of target struct, and allocate...
    DWORD dwTextSize = 0;
    if(pItemSrc->mask & LVIF_TEXT)
        dwTextSize = sizeof(TCHAR) * (pItemSrc->cchTextMax + 1);

    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), dwTextSize ) )
        return E_OUTOFMEMORY;

    // Copy to remote struct...
    lvDest.mask         = pItemSrc->mask;
    lvDest.iItem        = pItemSrc->iItem;
    lvDest.iSubItem     = pItemSrc->iSubItem;
    lvDest.pszText      = xsh.GetExtraPtr();
    lvDest.cchTextMax   = pItemSrc->cchTextMax;
    lvDest.state        = pItemSrc->state;
    lvDest.stateMask    = pItemSrc->stateMask;
    lvDest.iImage       = pItemSrc->iImage;
    lvDest.lParam       = pItemSrc->lParam;
    lvDest.iIndent      = pItemSrc->iIndent;

    xsh.WriteSendMsg( & lvDest, hwnd, uiMsg, wParam, fCheckSend );

    return S_OK;
}


template <class T>
HRESULT ListView_GetCol_Handler( T & lvDest, HWND hwnd, UINT uiMsg, WPARAM wParam, LVCOLUMN * pItemSrc, BOOL fCheckSend, UINT )
{
    // work out required size of target struct, and allocate...
    DWORD dwTextSize = 0;
    if(pItemSrc->mask & LVCF_TEXT)
        dwTextSize = sizeof(TCHAR) * (pItemSrc->cchTextMax + 1);

    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), dwTextSize ) )
        return E_OUTOFMEMORY;

    // Copy to remote struct...
    lvDest.mask         = pItemSrc->mask;
    lvDest.iSubItem     = pItemSrc->iSubItem;
    lvDest.pszText      = xsh.GetExtraPtr();
    lvDest.cchTextMax   = pItemSrc->cchTextMax;

    if( ! xsh.WriteSendMsgRead( & lvDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;

    // Copy text back out separately...
    if( ! xsh.ReadExtra( pItemSrc->pszText, lvDest.pszText, TRUE ) )
        return E_FAIL;

    return S_OK;
}



template <class T>
HRESULT ListView_V6_Get_Handler( T & lvDest, HWND hwnd, UINT uiMsg, WPARAM wParam, LVITEM_V6 * pItemSrc, BOOL fCheckSend, UINT )
{
    // This version only gets column information, not text...

    DWORD dwExtraSize = 0;
    if(pItemSrc->mask & LVIF_COLUMNS)
        dwExtraSize = sizeof(UINT) * (pItemSrc->cColumns);

    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), dwExtraSize ) )
        return E_OUTOFMEMORY;

    // Copy to remote struct...
    lvDest.mask      = pItemSrc->mask;
    lvDest.iItem     = pItemSrc->iItem;
    lvDest.iSubItem  = pItemSrc->iSubItem;
    lvDest.cColumns  = pItemSrc->cColumns;
    lvDest.puColumns = xsh.GetExtraPtr();

    // LVM_GETITEM/LVIF_COLUMNS returns FALSE when puColumns is NULL, even though it
    // does set cColumns to the size required. So we should only check that SendMessage
    // returns TRUE when puColumns is non-NULL.
    if( ! xsh.WriteSendMsgRead( & lvDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;

    // Copy back the struct out members...
    pItemSrc->cColumns = lvDest.cColumns;
    pItemSrc->iGroupId = lvDest.iGroupId;

    // Copy columns back out separately...
    // UINTs are the same on 64 vs 32, so don't need extra processing here.
    if( ! xsh.ReadExtra( pItemSrc->puColumns, lvDest.puColumns, FALSE ) )
        return E_FAIL;

    return S_OK;
}



template <class T>
HRESULT ListView_V6_GetGroup_Handler( T & lvDest, HWND hwnd, UINT uiMsg, WPARAM wParam, LVGROUP_V6 * pItemSrc, BOOL fCheckSend, UINT )
{
    DWORD dwTextSize = 0;
    if( pItemSrc->mask & LVGF_HEADER )
        dwTextSize = sizeof(TCHAR) * (pItemSrc->cchHeader + 1);
    
    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), dwTextSize ) )
        return E_OUTOFMEMORY;
    
    // Copy to remote struct...
    lvDest.cbSize       = pItemSrc->cbSize;
    lvDest.mask       = pItemSrc->mask;
    lvDest.pszHeader   = xsh.GetExtraPtr();
    lvDest.cchHeader   = pItemSrc->cchHeader;
    lvDest.iGroupId    = pItemSrc->iGroupId;
    
    if( ! xsh.WriteSendMsgRead( &lvDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;
    
    // Copy text back out separately...
    if( ! xsh.ReadExtra( pItemSrc->pszHeader, lvDest.pszHeader, TRUE ) )
        return E_FAIL;
    
    return S_OK;
}



template <class T>
HRESULT HeaderCtrl_Get_Handler( T & hdDest, HWND hwnd, UINT uiMsg, WPARAM wParam, HDITEM *pItemSrc, BOOL fCheckSend, UINT )
{
    // work out required size of target struct, and allocate...
    DWORD dwTextSize = 0;
    if(pItemSrc->mask & HDI_TEXT)
        dwTextSize = sizeof(TCHAR) * (pItemSrc->cchTextMax + 1);

    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), dwTextSize ) )
        return E_OUTOFMEMORY;
    
    // Copy to remote struct...
    hdDest.mask         = pItemSrc->mask;
    hdDest.pszText      = xsh.GetExtraPtr();
    hdDest.cchTextMax   = pItemSrc->cchTextMax;

    if( ! xsh.WriteSendMsgRead( & hdDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;
        
    // Copy back the struct out members...
    pItemSrc->cxy       = hdDest.cxy;
    pItemSrc->hbm       = hdDest.hbm;
    pItemSrc->fmt       = hdDest.fmt;
    pItemSrc->lParam    = hdDest.lParam;
    pItemSrc->iImage    = hdDest.iImage;
    pItemSrc->iOrder    = hdDest.iOrder;

    // Copy text back out separately...
    if( ! xsh.ReadExtra( pItemSrc->pszText, hdDest.pszText, TRUE ) )
        return E_FAIL;

    return S_OK;
}


template <class T>
HRESULT TabCtrl_Get_Handler( T & tcDest, HWND hwnd, UINT uiMsg, WPARAM wParam, TCITEM *pItemSrc, BOOL fCheckSend, UINT )
{
    // work out required size of target struct, and allocate...
    DWORD dwTextSize = 0;
    if(pItemSrc->mask & TCIF_TEXT)
        dwTextSize = sizeof(TCHAR) * (pItemSrc->cchTextMax + 1);

    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T) + CBEXTRA_TRAYTAB, dwTextSize ) )
        return E_OUTOFMEMORY;
    
    // Copy to remote struct...
    tcDest.mask           = pItemSrc->mask;
    tcDest.dwState        = pItemSrc->dwState;
    tcDest.dwStateMask    = pItemSrc->dwStateMask;
    tcDest.pszText        = xsh.GetExtraPtr();
    tcDest.cchTextMax     = pItemSrc->cchTextMax;
    tcDest.iImage         = pItemSrc->iImage;
    tcDest.lParam         = pItemSrc->lParam;

    if( ! xsh.WriteSendMsgRead( & tcDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;

    // Copy back the struct out members...
    pItemSrc->dwState     = tcDest.dwState;
    pItemSrc->dwStateMask = tcDest.dwStateMask;
    pItemSrc->iImage      = tcDest.iImage;
    pItemSrc->lParam      = tcDest.lParam;

    // Copy text back out separately...
    if( ! xsh.ReadExtra( pItemSrc->pszText, tcDest.pszText, TRUE ) )
        return E_FAIL;

    return S_OK;
}


template <class T>
HRESULT ToolInfo_Get_Handler( T & tiDest, HWND hwnd, UINT uiMsg, WPARAM wParam, TOOLINFO *pItemSrc, BOOL fCheckSend, UINT cchTextMax )
{
    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), sizeof(TCHAR) * cchTextMax ) )
        return E_OUTOFMEMORY;
    
    // Copy to remote struct...
    tiDest.cbSize   = sizeof( tiDest );
    tiDest.uFlags   = pItemSrc->uFlags;
    tiDest.uId      = pItemSrc->uId;
    tiDest.hwnd     = pItemSrc->hwnd;
    tiDest.lpszText = xsh.GetExtraPtr();

    // Don't fail if the message is TTM_GETTEXT and 0 is returned - that's OK for that message.
    // (TTM_GETTEXT has no documented return value!)
    if( ! xsh.WriteSendMsgRead( & tiDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;
        
    // Copy back the struct out members...
    pItemSrc->uFlags = tiDest.uFlags;
    pItemSrc->uId    = tiDest.uId;
    pItemSrc->rect   = tiDest.rect;

    // Copy text back out...
    if( ! xsh.ReadExtra( pItemSrc->lpszText, tiDest.lpszText, TRUE ) )
        return E_FAIL;

    return S_OK;
}



template <class T>
HRESULT ToolInfo_GetTitle_Handler( T & tiDest, HWND hwnd, UINT uiMsg, WPARAM wParam, TTGETTITLE *pItemSrc, BOOL fCheckSend, UINT )
{
    CXSendHelper xsh;
    if( ! xsh.Alloc( hwnd, sizeof(T), sizeof(TCHAR) * pItemSrc->cch ) )
        return E_OUTOFMEMORY;
    
    // Copy to remote struct...
    tiDest.dwSize   = sizeof( tiDest );
    tiDest.cch      = pItemSrc->cch;
    tiDest.pszTitle = xsh.GetExtraPtr();

    if( ! xsh.WriteSendMsgRead( & tiDest, hwnd, uiMsg, wParam, fCheckSend ) )
        return E_FAIL;
        
    // Copy back the struct out members...
    pItemSrc->uTitleBitmap = tiDest.uTitleBitmap;

    // Copy text back out...
    if( ! xsh.ReadExtra( pItemSrc->pszTitle, tiDest.pszTitle, TRUE ) )
        return E_FAIL;

    return S_OK;
}






// ----------------------------------------------------------------------------
//
//  Cross-proc sendmessage stub macro
//
//  All cross-proc SendMessage code has the same basic structure - some tests
//  to determine if a cross proc send message is needed in the first place - 
//  if not, we can do a regular local SendMessage instead.
//  If we do need to do a remote SendMessage, we call either a 32-bit or 64-bit
//  "handler" routine based on the bitness of the target proxy.
//
//  Since this code is the same for all cases, a #define is used to avoid
//  duplication of code.
//
//
//  DEFINE_XSEND_STUB takes the following parameters:
//
//  Name            - the name of the function being defined
//  Handler         - the name of the cross-proc handler (see above)
//  Type            - base type used.
//  CheckSendExpr   - expression that indicates if the result of SendMessage
//                    should be checked. Most - but not all - messages return
//                    TRUE to indicate success. 
// 
//
// ----------------------------------------------------------------------------


// For a given type - eg. LVITEM - this macro sets LVITEM_THIS and
// LVITEM_REMOTE to be typedef'd to LVITEM_32 and LVITEM_64 as appropriate,
// depending on whether this is 32- or 64- bit code.
//
// This relies on the base struct (eg. LVITEM) having the same base name as the
// explicit 32- and 64- bit structs which are defined above.

#ifdef _WIN64
#define DEFINE_TYPE_6432( Type ) typedef Type ## _64 Type ## _THIS; typedef Type ## _32 Type ## _REMOTE;
#else
#define DEFINE_TYPE_6432( Type ) typedef Type ## _32 Type ## _THIS; typedef Type ## _64 Type ## _REMOTE;
#endif


#define DEFINE_XSEND_STUB( Name, Handler, Type, CheckSendExpr ) /**/ \
    HRESULT Name ( HWND hwnd, UINT uiMsg, WPARAM wParam, Type * pItem, UINT uiParam )\
    {\
        /* Optimize if in same process...*/\
        DWORD dwProcessId;\
        if( ! GetWindowThreadProcessId( hwnd, & dwProcessId ) )\
            return E_FAIL;\
    \
        BOOL fCheckSend = CheckSendExpr;\
    \
        if( dwProcessId == GetCurrentProcessId() )\
        {\
            DBPRINTF( TEXT("Inprocess") );\
            if( ! SendMessage( hwnd, uiMsg, wParam, (LPARAM) pItem ) && fCheckSend )\
            {\
                DBPRINTF( TEXT("SendMessag failed") );\
                return E_FAIL;\
            }\
    \
            return S_OK;\
        }\
    \
        /* Otherwise pass the correct type off to the template function...*/\
        BOOL fIsSameBitness;\
        if( FAILED( SameBitness( hwnd, & fIsSameBitness ) ) )\
            return E_FAIL;\
    \
        if( fIsSameBitness )\
        {\
            Type ## _THIS t;\
            memset( & t, 0, sizeof( t ) );\
            return Handler( t, hwnd, uiMsg, wParam, pItem, fCheckSend, uiParam );\
        }\
        else\
        {\
            Type ## _REMOTE t;\
            memset( & t, 0, sizeof( t ) );\
            return Handler( t, hwnd, uiMsg, wParam, pItem, fCheckSend, uiParam );\
        }\
    }


DEFINE_TYPE_6432( LVITEM    )
DEFINE_TYPE_6432( LVITEM_V6 )
DEFINE_TYPE_6432( LVGROUP_V6 )
DEFINE_TYPE_6432( LVCOLUMN  )
DEFINE_TYPE_6432( TCITEM    )
DEFINE_TYPE_6432( HDITEM    )
DEFINE_TYPE_6432( TOOLINFO  )
DEFINE_TYPE_6432( TTGETTITLE )

DEFINE_XSEND_STUB( XSend_ListView_GetItem,      ListView_Get_Handler,       LVITEM,     TRUE    )
DEFINE_XSEND_STUB( XSend_ListView_SetItem,      ListView_Set_Handler,       LVITEM,     FALSE   )
DEFINE_XSEND_STUB( XSend_ListView_GetColumn,    ListView_GetCol_Handler,    LVCOLUMN,   TRUE    )
DEFINE_XSEND_STUB( XSend_ListView_V6_GetItem,   ListView_V6_Get_Handler,    LVITEM_V6,  pItem->puColumns != NULL )
DEFINE_XSEND_STUB( XSend_ListView_V6_GetGroupInfo, ListView_V6_GetGroup_Handler,    LVGROUP_V6,  TRUE )
DEFINE_XSEND_STUB( XSend_TabCtrl_GetItem,       TabCtrl_Get_Handler,        TCITEM,     TRUE    )
DEFINE_XSEND_STUB( XSend_HeaderCtrl_GetItem,    HeaderCtrl_Get_Handler,     HDITEM,     TRUE    )
DEFINE_XSEND_STUB( XSend_ToolTip_GetItem,       ToolInfo_Get_Handler,       TOOLINFO,   uiMsg != TTM_GETTEXT     )
DEFINE_XSEND_STUB( XSend_ToolTip_GetTitle,      ToolInfo_GetTitle_Handler,  TTGETTITLE, TRUE    )


// ----------------------------------------------------------------------------
//
// GetRemoteProxyFactory()
//
// Returns an AddRef'd proxy factory for the other bitness
//

CComPtr<IRemoteProxyFactory> g_pRemoteProxyFactory;    // Only a single instance. CComPtr
                                                    // will release on dll unload.

HRESULT GetRemoteProxyFactory(IRemoteProxyFactory **pRPF)
{
    if (IsBadWritePtr(pRPF, sizeof(IRemoteProxyFactory *)))
        return E_POINTER;

    *pRPF = NULL;

    if (!g_pRemoteProxyFactory)
    {
        HRESULT hr = CoCreateInstance(
#ifdef _WIN64
                  CLSID_RemoteProxyFactory32
#else
                  CLSID_RemoteProxyFactory64
#endif
                , NULL
                , CLSCTX_LOCAL_SERVER
                , IID_IRemoteProxyFactory
                , reinterpret_cast<void **>(&g_pRemoteProxyFactory));

        if (FAILED(hr))
        {
            DBPRINTF(TEXT("GetRemoteProxyFactory: CoCreateInstance FAILED "));
#ifdef _WIN64
                DBPRINTF(TEXT("for clsid 0x%x\r\n"), CLSID_RemoteProxyFactory32.Data1);
#else
                DBPRINTF(TEXT("for clsid 0x%x\r\n"), CLSID_RemoteProxyFactory64.Data1);
#endif
            return hr;
        }

        if (!g_pRemoteProxyFactory)
            return E_OUTOFMEMORY;
    }

    DBPRINTF(TEXT("GetRemoteProxyFactory: CoCreateInstance SUCCEEDED\r\n"));
    *pRPF = g_pRemoteProxyFactory;
    (*pRPF)->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\win64helper.h ===
// Copyright (c) 1996-2000 Microsoft Corporation
// ----------------------------------------------------------------------------
// Win64Helper.h
//
// Helper function prototypes used by the comctl32 wrappers
//
// ----------------------------------------------------------------------------
#ifndef INC_OLE2
#include "oleacc_p.h"
#include "default.h"
#endif
#define NOSTATUSBAR
#define NOUPDOWN
#define NOMENUHELP
#define NOTRACKBAR
#define NODRAGLIST
#define NOTOOLBAR
#define NOHOTKEY
#define NOPROGRESS
#define NOTREEVIEW
#define NOANIMATE
#include <commctrl.h>

// if this W2K and not ALPHA enable 64b/32b interoperability
#if defined(UNICODE) && !defined(_M_AXP64)
#define ENABLE6432_INTEROP
#endif


// ComCtl V6 Listview structure - this has extra fields since the previous
// version. We define this structure explicitly here, so that we can compile
// in either NT build or in VS6 - we're not reliant on the lastest commctrl.h
// file.

#ifndef LVIF_COLUMNS
#define LVIF_COLUMNS            0x0200
#endif

struct LVITEM_V6
{
    UINT mask;
    int iItem;
    int iSubItem;
    UINT state;
    UINT stateMask;
    LPTSTR pszText;
    int cchTextMax;
    int iImage;
    LPARAM lParam;
    int iIndent;
    // The following fields are new in V6.
    int iGroupId;
    UINT cColumns; // tile view columns
    PUINT puColumns;
};


#ifndef LVGF_HEADER
#define LVGF_HEADER         0x00000001
#endif

#ifndef LVIF_GROUPID
#define LVIF_GROUPID            0x0100
#endif

#ifndef LVM_GETGROUPINFO
#define LVM_GETGROUPINFO         (LVM_FIRST + 149)
#endif


struct LVGROUP_V6
{
    UINT    cbSize;
    UINT    mask;
    LPTSTR  pszHeader;
    int     cchHeader;

    LPTSTR  pszFooter;
    int     cchFooter;

    int     iGroupId;

    UINT    stateMask;
    UINT    state;
    UINT    uAlign;
};



#ifndef TTM_GETTITLE
#define TTM_GETTITLE            (WM_USER + 35)

struct TTGETTITLE
{
    DWORD dwSize;
    UINT uTitleBitmap;
    UINT cch;
    WCHAR* pszTitle;
};
#endif

HRESULT SameBitness(HWND hwnd, BOOL *pfIsSameBitness);

// Why the unused 'dummy' variable? Only XSend_ToolTip_GetItem actually uses that param,
// but adding it to all these functions gives them the same number of params, and, with
// the exception of the struct field (LVITEM/HDITEM/etc), gives them the same signature.
// This allows for somewhat cleaner code in the implemetation (Win64Helper.cpp)
// Using a default value for that param means that calling code doesn't have to specify
// it, so the callers can ignore the fact that it is there.

HRESULT XSend_ListView_GetItem    ( HWND hwnd, UINT uiMsg, WPARAM wParam, LVITEM *    pItem, UINT dummy = 0 );
HRESULT XSend_ListView_SetItem    ( HWND hwnd, UINT uiMsg, WPARAM wParam, LVITEM *    pItem, UINT dummy = 0 );
HRESULT XSend_ListView_GetColumn  ( HWND hwnd, UINT uiMsg, WPARAM wParam, LVCOLUMN *  pItem, UINT dummy = 0 );
HRESULT XSend_ListView_V6_GetItem ( HWND hwnd, UINT uiMsg, WPARAM wParam, LVITEM_V6 * pItem, UINT dummy = 0 );
HRESULT XSend_ListView_V6_GetGroupInfo ( HWND hwnd, UINT uiMsg, WPARAM wParam, LVGROUP_V6 * pItem, UINT dummy = 0 );
HRESULT XSend_HeaderCtrl_GetItem  ( HWND hwnd, UINT uiMsg, WPARAM wParam, HDITEM *    pItem, UINT dummy = 0 );
HRESULT XSend_TabCtrl_GetItem     ( HWND hwnd, UINT uiMsg, WPARAM wParam, TCITEM *    pItem, UINT dummy = 0 );
HRESULT XSend_ToolTip_GetItem     ( HWND hwnd, UINT uiMsg, WPARAM wParam, TOOLINFO *  pItem, UINT cchTextMax );
HRESULT XSend_ToolTip_GetTitle    ( HWND hwnd, UINT uiMsg, WPARAM wParam, TTGETTITLE * pItem, UINT dummy = 0 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\wrap_annotation.cpp ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  wrap_annotation
//
//  Wrapper class to implement annotation for IAccessibles
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"

#include "PropMgr_Client.h"
#include "PropMgr_Util.h"

#include "wrap_base.h"



class AccWrap_AddIAccProp: public AccWrap_Base
{
    HWND                m_FakeIAccPropHwnd;
    BOOL                m_fCheckedForFakeIAccProp;


    BOOL CanFakeIAccIdentity( HWND * phwnd )
    {
        // Can we fale IAccIdentity for this object?
        // Yes, if:
        // * It supports IAccessible
        // * It has a parent
        // * The parent supports IAccIdentity
        // * Parent's identity is HWND-base,d and is OBJID_WINDOW.
        // We can 99.9% assume that the child is an OBJID_CLIENT object.
        //
        // (TODO - also check that its HWND matches that of its parent?)
        //
        // This is useful where native IAccessible is implementing IAccessible
        // for a client (ie. where it's not something complicated like Trident
        // with multiple levels). Since the native IAccessible won't implement
        // IAccIdentity (since that was spec'd only recently), annotation
        // won't work for it.
        // However, if we can determine that it is a simple IAccessible - and
        // we do so by checking that it's parent is a OBJID_WINDOW object -
        // we can supply the identity for it.
        // This works because noone has ever wanted to supply an IAccessible
        // for anything other than the OBJID_CLIENT child of an OBJID_WINDOW.


        // Note that we use the AccWrap_Base::get_accParent here instead of
        // using get_accParent - if we used the latter, we'd end up trying
        // to use annotation (to see if the parent was annotated), but we're
        // in the middle ot QI'ing for an annotation interface, so that would
        // be freaky. So we explicitly call the base class to short-circuit-out
        // the annotated version of get_accParent.
        IDispatch * pdispParent = NULL;
        HRESULT hr = AccWrap_Base::get_accParent( & pdispParent );
        if( hr != S_OK || pdispParent == NULL )
        {
            return FALSE;
        }

        // This is very important - we want to talk to the real parent IAccessible -
        // not its wrapper, so that when we QI it for IAccIdentity, we will know
        // for sure if the parent actually supports it or not. (If we didn't do this,
        // the parent's wrapper would try to implement IAccIdentity for it, by
        // calling back into this method on the parent, which would in turn do the same
        // for the parent's parent, and so on up the tree. Eventually, that would all
        // correctly return 'FALSE', but it's a particularly expensive way to calculate
        // FALSE, especially where deep trees are used, eg. in a trident doc.)
        // 
        // We get the real parent by QI'ing for IServiceProvider, and then QS'ing for
        // IIS_AccWrapBase_GetIUnknown. (These are implemented in wrap_base.cpp).

        IServiceProvider * psvc = NULL;
        hr = pdispParent->QueryInterface( IID_IServiceProvider, (void **) & psvc );
        pdispParent->Release();
        if( hr != S_OK || psvc == NULL )
        {
            return FALSE;
        }

        // QS allows us to both get the real parent, and QI it (for IAccIdentity) in one go...
        IAccIdentity * pParentID = NULL;
        hr = psvc->QueryService( IIS_AccWrapBase_GetIUnknown, IID_IAccIdentity, (void **) & pParentID );
        psvc->Release();
        if( hr != S_OK || pParentID == NULL )
        {
            return FALSE;
        }

        // Got the parent's identity interface - now get its identity string...
        BYTE * pIDString = NULL;
        DWORD dwStringLen = 0;
        hr = pParentID->GetIdentityString( CHILDID_SELF, & pIDString, & dwStringLen );
        pParentID->Release();
        if( hr != S_OK || pIDString == NULL )
        {
            return FALSE;
        }

        // Finally check if it is a OBJID_WINDOW thing...
        HWND hwnd;
        DWORD idObject;
        DWORD idChild;
        BOOL fGotIt = DecodeHwndKey( pIDString, dwStringLen, & hwnd, & idObject, & idChild );
        CoTaskMemFree( pIDString );

        if( ! fGotIt || hwnd == NULL || idObject != OBJID_WINDOW || idChild != CHILDID_SELF )
        {
            return FALSE;
        }

        * phwnd = hwnd;

        return TRUE;
    }

public:

    AccWrap_AddIAccProp( IUnknown * punk )
        : AccWrap_Base( punk ),
          m_FakeIAccPropHwnd( NULL ),
          m_fCheckedForFakeIAccProp( FALSE )
    {
    }


    ~AccWrap_AddIAccProp()
    {
    }


    HRESULT STDMETHODCALLTYPE QueryInterface( REFIID riid, void ** ppv )
    {
        HRESULT hr = AccWrap_Base::QueryInterface( riid, ppv );

        if( hr == E_NOINTERFACE && riid == IID_IAccIdentity )
        {
            if( ! m_fCheckedForFakeIAccProp )
            {
                // Check if we can fake an IAccIdentity, if we haven't
                // checked already...
                HWND hwnd;
                m_fCheckedForFakeIAccProp = TRUE;
                if( CanFakeIAccIdentity( & hwnd ) )
                {
                    m_FakeIAccPropHwnd = hwnd;
                }
            }

            if( m_FakeIAccPropHwnd )
            {
                // Yes, we can fake it...
                *ppv = (IAccIdentity *) this;
                AddRef();
                hr = S_OK;
            }
        }
        return hr;
    }


    HRESULT STDMETHODCALLTYPE GetIdentityString (
        DWORD	    dwIDChild,
        BYTE **     ppIDString,
        DWORD *     pdwIDStringLen
    )
    {
        *ppIDString = NULL;
        *pdwIDStringLen = 0;

        if( ! m_fCheckedForFakeIAccProp )
        {
            // Object supports this interface natively - call through...
            return AccWrap_Base::GetIdentityString( dwIDChild, ppIDString, pdwIDStringLen );
        }

        if( ! m_FakeIAccPropHwnd )
        {
            // This shouldn't happen - if we've checked for the interface, but didn't
            // get a valid HWND to use, then we'd have returned E_NOINTERFACE in QI, so
            // the caller shouldn't have got an interface to call us on.
            Assert( FALSE );
            return E_NOTIMPL;
        }

        // Ok, we need to fake a key for an object that doesn't itself support IAccIdentity,
        // but which is fakeable (see CanFakeIAccIdentity for more details
        // on what that means.) Basically assume it's OBJID_CLIENT, and construct
        // a win32/hwnd key.
        BYTE * pKeyData = (BYTE *) CoTaskMemAlloc( HWNDKEYSIZE );
        if( ! pKeyData )
        {
            return E_OUTOFMEMORY;
        }

        MakeHwndKey( pKeyData, m_FakeIAccPropHwnd, OBJID_CLIENT, dwIDChild );

        *ppIDString = pKeyData;
        *pdwIDStringLen = HWNDKEYSIZE;

        return S_OK;
    }
};





//
//  Note on member m_pAccPropID:
//
//  This is a pointer to an interface on *this* object - so we don't need
//  to AddRef it. It is actually important that we don't AddRef() it,
//  otherwise we'd be keeping a ref to ourself - so we'd never get
//  destroyed (circular ref problem).
//  We get this interface pointer from QI on this object - the base
//  class AccWrap_Base will only return a pointer if the object we're
//  wrapping supports it too.
//  As soon as we get the ptr from QI, we Release() to undo the effect
//  of the AddRef in QI. It is still valid to use this pointer, however,
//  since it is a pointer to ourself.
//  This weirdness applies only because this is a pointer back to
//  ourself. If the pointer pointed to any other object, we'd have to
//  do the usual Release-only-when-done-with-ptr-eg.-in-the-dtor stuff.
//
//  (Why not just cast instead of using QI? Well, the base class only
//  returns a pointer via QI if the object we're wrapping also supports
//  this inteface. If we did a cast, we'd always succeed, even if the
//  object we're wrapping doesn't support this interface.)
//

class AccWrap_Annotate: public AccWrap_AddIAccProp
{
    BOOL                m_fInited;
    IAccIdentity *      m_pAccPropID; // See note above

    // This function calls our ctor...
    friend HRESULT WrapObject( IUnknown * punk, REFIID riid, void ** ppv );


    AccWrap_Annotate( IUnknown * punk )
        : AccWrap_AddIAccProp( punk ),
          m_fInited( FALSE ),
          m_pAccPropID( NULL )
    {
    }


    ~AccWrap_Annotate()
    {
        // We *don't* release m_pAccPropID, since it points to this object.
        // See note at top of class for more details.
    }

    void Init()
    {
        if( ! m_fInited )
        {
            // Get the identity interface for this IAccessible - if it has one...
            IAccIdentity * pAccPropID = NULL;
            HRESULT hr = this->QueryInterface( IID_IAccIdentity, (void **) & pAccPropID );
            if( hr == S_OK && pAccPropID )
            {
                m_pAccPropID = pAccPropID;

                // We *must* release m_pAccPropID now, even though we're going to use it later.
                // This is only because it points to this object.
                // See note at top of class for more details.
                m_pAccPropID->Release();
            }
        }
        m_fInited = TRUE;
    }

public:

    // Factory method - the AccWrap_Base calls this when it needs to wrap outgoing
    // params to the IAccessible methods.
    IUnknown * WrapFactory( IUnknown * punk )
    {
        return static_cast<IAccessible *>( new AccWrap_Annotate( punk ) );
    }





    // Forwarding methods...


    BOOL GetGenericProp( VARIANT varChild, PROPINDEX idxProp, short vt, VARIANT * pvar )
    {
        // We do the 'check if annotation is active' check before calculating the key (in Init()).
        // This saves calc'ing the key - which can be slightly expensive for out-of-proc objects
        // (cross proc calls involved - at least QI.) - if nothing is using annotation anyhow.
        if( varChild.vt != VT_I4 || ! PropMgrClient_CheckAlive() )
        {
            return FALSE;
        }

        Init();

        if( ! m_pAccPropID )
        {
            return FALSE;
        }

        BYTE * pIDString = NULL;
        DWORD dwIDStringLen = 0;
        HRESULT hr = m_pAccPropID->GetIdentityString( varChild.lVal, & pIDString, & dwIDStringLen );
        if( hr != S_OK || pIDString == NULL )
        {
            return FALSE;
        }

        BOOL fLookup = PropMgrClient_LookupProp( pIDString, dwIDStringLen, idxProp, pvar );

        CoTaskMemFree( pIDString );

        if( ! fLookup )
        {
            return FALSE;
        }

        // If vt is not VT_EMPTY, then check the type is what we expect...
        if( vt != VT_EMPTY && pvar->vt != vt )
        {
            VariantClear( pvar );
            return FALSE;
        }

        return TRUE;
    }








#define FORWARD_BSTR( name, idProp ) /**/\
    HRESULT STDMETHODCALLTYPE get_acc ## name ( VARIANT varChild, BSTR * pbstr )\
    {\
        VARIANT var;\
        if( GetGenericProp( varChild, idProp, VT_BSTR, & var ) )\
        {\
            *pbstr = var.bstrVal;\
            return S_OK;\
        }\
        return AccWrap_Base::get_acc ## name( varChild, pbstr );\
    }

#define FORWARD_VTI4( name, idProp ) /**/\
    HRESULT STDMETHODCALLTYPE get_acc ## name ( VARIANT varChild, VARIANT * pvar )\
    {\
        if( GetGenericProp( varChild, idProp, VT_I4, pvar ) )\
        {\
            return S_OK;\
        }\
        return AccWrap_Base::get_acc ## name( varChild, pvar );\
    }


    FORWARD_BSTR( Name,              PROPINDEX_NAME                )
    FORWARD_BSTR( Value,             PROPINDEX_VALUE               )
    FORWARD_BSTR( Description,       PROPINDEX_DESCRIPTION         )
    FORWARD_BSTR( Help,              PROPINDEX_HELP                )
    FORWARD_BSTR( KeyboardShortcut,  PROPINDEX_KEYBOARDSHORTCUT    )
    FORWARD_BSTR( DefaultAction,     PROPINDEX_DEFAULTACTION       )

    FORWARD_VTI4( Role,              PROPINDEX_ROLE                )
    FORWARD_VTI4( State,             PROPINDEX_STATE               )



    HRESULT STDMETHODCALLTYPE get_accParent( IDispatch ** ppdispParent )
    {
        VARIANT varChild;
        varChild.vt = VT_I4;
        varChild.lVal = CHILDID_SELF;
        VARIANT var;
        if( GetGenericProp( varChild, PROPINDEX_PARENT, VT_DISPATCH, & var ) )
        {
            *ppdispParent = var.pdispVal;
            return S_OK;
        }

        return AccWrap_Base::get_accParent( ppdispParent );
    }

    HRESULT STDMETHODCALLTYPE get_accFocus( VARIANT * pvar )
    {
        VARIANT varChild;
        varChild.vt = VT_I4;
        varChild.lVal = CHILDID_SELF;
        if( GetGenericProp( varChild, PROPINDEX_FOCUS, VT_EMPTY, pvar ) )
        {
            return S_OK;
        }
        return AccWrap_Base::get_accFocus( pvar );
    }

    HRESULT STDMETHODCALLTYPE get_accSelection( VARIANT * pvar )
    {
        VARIANT varChild;
        varChild.vt = VT_I4;
        varChild.lVal = CHILDID_SELF;
        if( GetGenericProp( varChild, PROPINDEX_SELECTION, VT_EMPTY, pvar ) )
        {
            return S_OK;
        }
        return AccWrap_Base::get_accSelection( pvar );
    }


    HRESULT STDMETHODCALLTYPE accNavigate( long NavDir, VARIANT varStart, VARIANT * pvar )
    {
        PROPINDEX idxProp;

        switch( NavDir )
        {
            case NAVDIR_UP:         idxProp = PROPINDEX_NAV_UP;         break;
            case NAVDIR_DOWN:       idxProp = PROPINDEX_NAV_DOWN;       break;
            case NAVDIR_LEFT:       idxProp = PROPINDEX_NAV_LEFT;       break;
            case NAVDIR_RIGHT:      idxProp = PROPINDEX_NAV_RIGHT;      break;
            case NAVDIR_NEXT:       idxProp = PROPINDEX_NAV_NEXT;       break;
            case NAVDIR_PREVIOUS:   idxProp = PROPINDEX_NAV_RIGHT;      break;
            case NAVDIR_LASTCHILD:  idxProp = PROPINDEX_NAV_LASTCHILD;  break;
            case NAVDIR_FIRSTCHILD: idxProp = PROPINDEX_NAV_FIRSTCHILD; break;

            default:
                return AccWrap_Base::accNavigate( NavDir, varStart, pvar );
        }

        if( GetGenericProp( varStart, idxProp, VT_EMPTY, pvar ) )
        {
            return S_OK;
        }

        return AccWrap_Base::accNavigate( NavDir, varStart, pvar );
    }


    HRESULT STDMETHODCALLTYPE accDoDefaultAction( VARIANT varChild )
    {
        VARIANT varResult;
        if( GetGenericProp( varChild, PROPINDEX_DODEFAULTACTION, VT_I4, & varResult ) )
        {
            return varResult.lVal;
        }
        return AccWrap_Base::accDoDefaultAction( varChild );
    }

};




//
//  AccessibleObjectFromWindow calls this to wrap outgoing objects...
//


HRESULT WrapObject( IUnknown * punk, REFIID riid, void ** ppv )
{
    if( AccWrap_Base::AlreadyWrapped( punk ) )
    {
        return punk->QueryInterface( riid, ppv );
    }
    else
    {
        IUnknown * punkWrap = (IAccessible *) new AccWrap_Annotate( punk );
        // TODO - error check if NULL...
        if( ! punkWrap )
            return E_OUTOFMEMORY;

        HRESULT hr = punkWrap->QueryInterface( riid, ppv );
        punkWrap->Release();

        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleaccrc\oleaccrc.cpp ===
// Copyright (c) 1996-1999 Microsoft Corporation

/*
 *
 *  Minimal DllMain - to keep linker happy.
 *  DLL otherwise contains just resources.
 *
 *
 *  Note: set compiler/linker options to ignore
 *  default libraries, and set entry point symbol
 *  to DllMain.
 *
 */
#include <windows.h>

BOOL WINAPI DllMain( HANDLE hInst, 
                     ULONG ul_reason_for_call,
                     LPVOID lpReserved )
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\wrap_base.h ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  wrap_base
//
//  Base class for IAccessible wrapping.
//  Derived classes implement annotation, caching, and other cool features.
//
// --------------------------------------------------------------------------

#include "fwd_macros.h"


// Private QI'ing to return the base IUnknown. Does not work across apartments.
DEFINE_GUID( IIS_AccWrapBase_GetIUnknown, 0x33f139ee, 0xe509, 0x47f7, 0xbf, 0x39, 0x83, 0x76, 0x44, 0xf7, 0x45, 0x76);


class AccWrap_Base: public IAccessible,
                    public IOleWindow,
                    public IEnumVARIANT,
                    public IAccIdentity,
                    public IServiceProvider
{
    // We need to do our own refcounting for this wrapper object
    ULONG               m_ref;

    // Need ptr to the IAccessible - also keep around ptrs to EnumVar and
    // OleWindow as part of this object, so we can filter those interfaces
    // and trap their QI's...
    // ( We leave pEnumVar and OleWin as NULL until we need them )
    IUnknown *          m_pUnknown;

    IAccessible *       m_pAcc;
    IEnumVARIANT *      m_pEnumVar;
    IOleWindow *        m_pOleWin;
    IAccIdentity *      m_pAccID;
    IServiceProvider *  m_pSvcPdr;

    DWORD               m_QIMask; // Remembers what we've QI'd for, so we don't try again


    ITypeInfo *         m_pTypeInfo;


    HRESULT InitTypeInfo();


    // These process [out] params, and wrap them where necessary.

    HRESULT ProcessIUnknown( IUnknown ** ppUnk );
    HRESULT ProcessIDispatch( IDispatch ** ppdisp );
    HRESULT ProcessIEnumVARIANT( IEnumVARIANT ** ppEnum );
    HRESULT ProcessVariant( VARIANT * pvar, BOOL CanBeCollection = FALSE );
    HRESULT ProcessEnum( VARIANT * pvar, ULONG * pceltFetched );

    IUnknown * Wrap( IUnknown * pUnk );

    HRESULT CheckForInterface( IUnknown * punk, REFIID riid, int QIIndex, void ** pDst );

protected:

    // Only derived classes should have access to this - sould call through
    // in their ctors.
            AccWrap_Base( IUnknown * pUnk );

public:


    static  BOOL                        AlreadyWrapped( IUnknown * punk );


    virtual ~AccWrap_Base( );



    // Override in derived classes so that propogated values get wrapped appropriately.
    virtual IUnknown * WrapFactory( IUnknown * pUnk ) = 0;



    // IUnknown
    // ( We do our own ref counting )
    virtual HRESULT STDMETHODCALLTYPE   QueryInterface( REFIID riid, void ** ppv );
    virtual ULONG   STDMETHODCALLTYPE   AddRef( );
    virtual ULONG   STDMETHODCALLTYPE   Release( );

    // IServiceProvider
    virtual HRESULT STDMETHODCALLTYPE   QueryService( REFGUID guidService, REFIID riid, void **ppv );

    // IDispatch
    virtual HRESULT STDMETHODCALLTYPE   GetTypeInfoCount( UINT * pctinfo );
    virtual HRESULT STDMETHODCALLTYPE   GetTypeInfo( UINT itinfo, LCID lcid, ITypeInfo ** pptinfo );
    virtual HRESULT STDMETHODCALLTYPE   GetIDsOfNames( REFIID riid, OLECHAR ** rgszNames, UINT cNames,
                                                       LCID lcid, DISPID * rgdispid );
    virtual HRESULT STDMETHODCALLTYPE   Invoke( DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                                                DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,
                                                UINT * puArgErr );


        
//  Forwarding macro:
//
//    ptr           is the member pointer to forward this call though - a different
//                  one is used for each interface we support,
//
//    name          is the name of the method,
//
//    c, params     are the count of parameters, and the parameters; in (type1,var1,
//                  type2,var2...typeN,varN) format.
//
//    expr          is an expression to evaluate after making the forwarded call. It
//                  will typically contain a call to one of the methods to fixup and
//                  wrap any outgoing params. Will be 0 (no-op) if not needed.

#define FORWARD( ptr, name, c, params, expr ) /**/\
HRESULT STDMETHODCALLTYPE AccWrap_Base:: name AS_DECL( c, params )\
{\
    HRESULT hr = ptr -> name AS_CALL( c, params );\
    if( hr != S_OK )\
        return hr;\
    expr;\
    return hr;\
}

        
    // IAccessible

    FORWARD( m_pAcc, get_accParent,             1, ( IDispatch **, ppdispParent ),      ProcessIDispatch( ppdispParent ) )

    FORWARD( m_pAcc, get_accChildCount,         1, ( long *, pChildCount ),             0 )

    FORWARD( m_pAcc, get_accChild,              2, ( VARIANT, varChild,
                                                     IDispatch **, ppdispChild ),       ProcessIDispatch( ppdispChild ) )


    FORWARD( m_pAcc, get_accName,               2, ( VARIANT, varChild, BSTR *, pbstr ),        0 )
    FORWARD( m_pAcc, get_accValue,              2, ( VARIANT, varChild, BSTR *, pbstr ),        0 )
    FORWARD( m_pAcc, get_accDescription,        2, ( VARIANT, varChild, BSTR *, pbstr ),        0 )
    FORWARD( m_pAcc, get_accHelp,               2, ( VARIANT, varChild, BSTR *, pbstr ),        0 )
    FORWARD( m_pAcc, get_accKeyboardShortcut,   2, ( VARIANT, varChild, BSTR *, pbstr ),        0 )
    FORWARD( m_pAcc, get_accDefaultAction,      2, ( VARIANT, varChild, BSTR *, pbstr ),        0 )

    FORWARD( m_pAcc, get_accRole,               2, ( VARIANT, varChild, VARIANT *, pvarRole ),  0 )
    FORWARD( m_pAcc, get_accState,              2, ( VARIANT, varChild, VARIANT *, pvarState ), 0 )

    FORWARD( m_pAcc, get_accHelpTopic,          3, ( BSTR *, pszHelpFile,
                                                     VARIANT, varChild,
                                                     long *, pidTopic ),                0 )


    FORWARD( m_pAcc, get_accFocus,              1, ( VARIANT *, pvarChild ),            ProcessVariant( pvarChild ) )

    FORWARD( m_pAcc, get_accSelection,          1, ( VARIANT *, pvarChildren ),         ProcessVariant( pvarChildren, TRUE ) )

    FORWARD( m_pAcc, accSelect,                 2, ( long, flagsSel,
                                                     VARIANT, varChild ),               0 )

    FORWARD( m_pAcc, accLocation,               5, ( long *, pxLeft,
                                                     long *, pyTop,
                                                     long *, pcxWidth,
                                                     long *, pcyHeight,
                                                     VARIANT, varChild ),               0 )

    FORWARD( m_pAcc, accNavigate,               3, ( long, navDir,
                                                     VARIANT, varStart,
                                                     VARIANT *, pvarEndUpAt ),          ProcessVariant( pvarEndUpAt ) )

    FORWARD( m_pAcc, accHitTest,                3, ( long, xLeft,
                                                     long, yTop,
                                                     VARIANT *, pvarChildAtPoint ),     ProcessVariant( pvarChildAtPoint ) )

    FORWARD( m_pAcc, accDoDefaultAction,        1, ( VARIANT, varChild ),               0 )

    FORWARD( m_pAcc, put_accName,               2, ( VARIANT, varChild,
                                                     BSTR, bstr ),                      0 )

    FORWARD( m_pAcc, put_accValue,              2, ( VARIANT, varChild,
                                                     BSTR, bstr ),                      0 )


    // IEnumVARIANT

    FORWARD( m_pEnumVar, Next,                  3, ( ULONG, celt,
                                                     VARIANT *, rgvar,
                                                     ULONG *, pceltFetched ),           ProcessEnum( rgvar, pceltFetched ) )

    FORWARD( m_pEnumVar, Skip,                  1, ( ULONG, celt ),                     0 )


    FORWARD( m_pEnumVar, Reset,                 0, ( ),                                 0 )


    FORWARD( m_pEnumVar, Clone,                 1, ( IEnumVARIANT **, ppenum ),         ProcessIEnumVARIANT( ppenum ) )


    // IOleWindow

    FORWARD( m_pOleWin, GetWindow,              1, ( HWND *, phwnd ),                   0 )

    FORWARD( m_pOleWin, ContextSensitiveHelp,   1, ( BOOL, fEnterMode ),                0 )


    // IAccIdentity

    FORWARD( m_pAccID, GetIdentityString,       3, ( DWORD, dwIDChild,
                                                     BYTE **, ppIDString,
                                                     DWORD *, pdwIDStringLen ),         0 )
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleacc\wrap_base.cpp ===
// Copyright (c) 2000-2000 Microsoft Corporation

// --------------------------------------------------------------------------
//
//  wrap_base
//
//  Base class for IAccessible wrapping.
//  Derived classes implement annotation, caching, and other cool features.
//
// --------------------------------------------------------------------------

#include "oleacc_p.h"

#include <initguid.h> // used for IIS_AccWrapBase_GetIUnknown in wrap_base.h
#include "wrap_base.h"



enum
{
    QIINDEX_IAccessible,
    QIINDEX_IEnumVARIANT,
    QIINDEX_IOleWindow,
    QIINDEX_IAccIdentity,
    QIINDEX_IServiceProvider,
};


AccWrap_Base::AccWrap_Base( IUnknown * pUnknown )
    : m_ref( 1 ),
      m_QIMask( 0 ),
      m_pUnknown( pUnknown ),
      m_pAcc( NULL ),
      m_pEnumVar( NULL ),
      m_pOleWin( NULL ),
      m_pAccID( NULL ),
      m_pSvcPdr( NULL ),
      m_pTypeInfo( NULL )
{
    m_pUnknown->AddRef();
}

AccWrap_Base::~AccWrap_Base()
{
    m_pUnknown->Release();
    if( m_pAcc )
        m_pAcc->Release();
    if( m_pEnumVar )
        m_pEnumVar->Release();
    if( m_pOleWin )
        m_pOleWin->Release();
    if( m_pAccID )
        m_pAccID->Release();
    if( m_pSvcPdr )
        m_pSvcPdr->Release();
    if( m_pTypeInfo )
        m_pTypeInfo->Release();
}



// Helper used by QI...
HRESULT AccWrap_Base::CheckForInterface( IUnknown * punk, REFIID riid, int QIIndex, void ** pDst )
{
    // Do we already have a cached interface ptr? If so, don't need to QI again...
    if( *pDst )
        return S_OK;

    // Did we try QI'ing for this before? If so, don't try again, just return E_NOINTERFACE...
    if( IsBitSet( m_QIMask, QIIndex ) )
        return E_NOINTERFACE;

    SetBit( & m_QIMask, QIIndex );

    HRESULT hr = punk->QueryInterface( riid, pDst );
    if( FAILED( hr ) )
    {
        *pDst = NULL;
        return hr;
    }

    // Paranoia ( in case QI returns S_OK with NULL... )
    if( ! *pDst )
        return E_FAIL;

    return S_OK;
}



BOOL AccWrap_Base::AlreadyWrapped( IUnknown * punk )
{
    // Try QueryService'ing to IIS_AccWrapBase_GetIUnknown - if it succeeds, then
    // we are talking to something that's already wrapped.
    IServiceProvider * psvc = NULL;
    HRESULT hr = punk->QueryInterface( IID_IServiceProvider, (void **) & psvc );
    if( hr != S_OK || psvc == NULL )
    {
        return FALSE;
    }

    IUnknown * pout = NULL;
    hr = psvc->QueryService( IIS_AccWrapBase_GetIUnknown, IID_IUnknown, (void **) & pout );
    psvc->Release();
    if( hr != S_OK || pout == NULL )
    {
        return FALSE;
    }

    pout->Release();
    return TRUE;
}

IUnknown * AccWrap_Base::Wrap( IUnknown * pUnk )
{
    if( AlreadyWrapped( pUnk ) )
    {
        pUnk->AddRef();
        return pUnk;
    }
    else
    {
        return WrapFactory( pUnk );
    }
}



// IUnknown
// Implement refcounting ourselves
// Also implement QI ourselves, so that we return a ptr back to the wrapper.
HRESULT STDMETHODCALLTYPE  AccWrap_Base::QueryInterface( REFIID riid, void ** ppv )
{
    HRESULT hr;
    *ppv = NULL;

    if ( riid == IID_IUnknown )
    {
        *ppv = static_cast< IAccessible * >( this );
    }
    else if( riid == IID_IAccessible || riid == IID_IDispatch )
    {
        hr = CheckForInterface( m_pUnknown, IID_IAccessible, QIINDEX_IAccessible, (void **) & m_pAcc );
        if( hr != S_OK )
            return hr;
        *ppv = static_cast< IAccessible * >( this );
    }
    else if( riid == IID_IEnumVARIANT )
    {
        hr = CheckForInterface( m_pUnknown, IID_IEnumVARIANT, QIINDEX_IEnumVARIANT, (void **) & m_pEnumVar );
        if( hr != S_OK )
            return hr;
        *ppv = static_cast< IEnumVARIANT * >( this );
    }
    else if( riid == IID_IOleWindow )
    {
        hr = CheckForInterface( m_pUnknown, IID_IOleWindow, QIINDEX_IOleWindow, (void **) & m_pOleWin );
        if( hr != S_OK )
            return hr;
        *ppv = static_cast< IOleWindow * >( this );
    }
    else if( riid == IID_IAccIdentity )
    {
        hr = CheckForInterface( m_pUnknown, IID_IAccIdentity, QIINDEX_IAccIdentity, (void **) & m_pAccID );
        if( hr != S_OK )
            return hr;
        *ppv = static_cast< IAccIdentity * >( this );
    }
    else if( riid == IID_IServiceProvider )
    {
        *ppv = static_cast< IServiceProvider * >( this );
    }
    else
    {
        return E_NOINTERFACE ;
    }

    AddRef( );

    return S_OK;
}


ULONG STDMETHODCALLTYPE AccWrap_Base::AddRef( )
{
    return ++m_ref;
}


ULONG  STDMETHODCALLTYPE AccWrap_Base::Release( )
{
    if( --m_ref == 0 )
    {
        delete this;
        return 0;
    }
    return m_ref;
}




// IServiceProvider
HRESULT STDMETHODCALLTYPE   AccWrap_Base::QueryService( REFGUID guidService, REFIID riid, void **ppv )
{
    // For the moment, just handle  locally. Later, also forward others through to the base,
    // if it supports IServiceProvider.

    if( guidService == IIS_AccWrapBase_GetIUnknown )
    {
        return m_pUnknown->QueryInterface( riid, ppv );
    }
    else
    {
        // Pass through to base, if it handles IServiceProvider..
        CheckForInterface( m_pUnknown, IID_IServiceProvider, QIINDEX_IServiceProvider, (void **) & m_pSvcPdr );
        if( m_pSvcPdr )
        {
            return m_pSvcPdr->QueryService( guidService, riid, ppv );
        }
        else
        {
            // MSDN mentions SVC_E_UNKNOWNSERVICE as the return code, but that's not in any of the headers.
            // Returning E_INVALIDARG instead. (Don't want to use E_NOINTERFACE, since that clashes with
            // QI's return value, making it hard to distinguish between valid service+invalid interface vs
            // invalid service.
            return E_INVALIDARG;
        }
    }
}



// IDispatch
// implemented locally, to avoid IDispatch short-circuiting...

HRESULT AccWrap_Base::InitTypeInfo()
{
    if( m_pTypeInfo )
        return S_OK;

    // Try getting the typelib from the registry
    ITypeLib * piTypeLib = NULL;
    HRESULT hr = LoadRegTypeLib( LIBID_Accessibility, 1, 0, 0, &piTypeLib );

    if( FAILED( hr ) || piTypeLib == NULL )
    {
        OLECHAR wszPath[ MAX_PATH ];

        // Try loading directly.
#ifdef UNICODE
        MyGetModuleFileName( NULL, wszPath, ARRAYSIZE( wszPath ) );
#else
        TCHAR   szPath[ MAX_PATH ];

        MyGetModuleFileName( NULL, szPath, ARRAYSIZE( szPath ) );
        MultiByteToWideChar( CP_ACP, 0, szPath, -1, wszPath, ARRAYSIZE( wszPath ) );
#endif
        hr = LoadTypeLib(wszPath, &piTypeLib);
    }

    if( SUCCEEDED( hr ) )
    {
        hr = piTypeLib->GetTypeInfoOfGuid( IID_IAccessible, & m_pTypeInfo );
        piTypeLib->Release();

        if( ! SUCCEEDED( hr ) )
        {
            m_pTypeInfo = NULL;
        }
    }

    return hr;
}



HRESULT STDMETHODCALLTYPE  AccWrap_Base::GetTypeInfoCount( UINT * pctInfo )
{
    HRESULT hr = InitTypeInfo();
    if( SUCCEEDED( hr ) )
    {
        *pctInfo = 1;
    }
    else
    {
        *pctInfo = 0;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  AccWrap_Base::GetTypeInfo(
    UINT                    itInfo,
    LCID            unused( lcid ),
    ITypeInfo **            ppITypeInfo )
{
    if( ppITypeInfo == NULL )
    {
        return E_POINTER;
    }

    *ppITypeInfo = NULL;

    if( itInfo != 0 )
    {
        return TYPE_E_ELEMENTNOTFOUND;
    }

    HRESULT hr = InitTypeInfo();
    if( SUCCEEDED( hr ) )
    {
        m_pTypeInfo->AddRef();
        *ppITypeInfo = m_pTypeInfo;
    }

    return hr;
}

HRESULT STDMETHODCALLTYPE  AccWrap_Base::GetIDsOfNames(
    REFIID      unused( riid ),
    OLECHAR **          rgszNames,
    UINT                cNames,
    LCID        unused( lcid ),
    DISPID *            rgDispID )
{
    HRESULT hr = InitTypeInfo();
    if( ! SUCCEEDED( hr ) )
    {
        return hr;
    }

    return m_pTypeInfo->GetIDsOfNames( rgszNames, cNames, rgDispID );
}

HRESULT STDMETHODCALLTYPE  AccWrap_Base::Invoke(
    DISPID              dispID,
    REFIID      unused( riid ),
    LCID        unused( lcid ),
    WORD                wFlags,
    DISPPARAMS *        pDispParams,
    VARIANT *           pvarResult,
    EXCEPINFO *         pExcepInfo,
    UINT *              puArgErr )
{
    HRESULT hr = InitTypeInfo();
    if( ! SUCCEEDED( hr ) )
        return hr;

    return m_pTypeInfo->Invoke( (IAccessible *)this, dispID, wFlags,
                                pDispParams, pvarResult, pExcepInfo, puArgErr );
}





//
//  Post-method fixup methods
//
//  These wrap any outgoing params. All of these are passed a pointer
//  to the prospective outgoing value, which is wrapped and modified in-place.
//


HRESULT AccWrap_Base::ProcessIUnknown( IUnknown ** ppUnk )
{
    if( ! ppUnk || ! *ppUnk )
        return S_OK;

    IUnknown * punkWrap = Wrap( *ppUnk );

    (*ppUnk)->Release();
    *ppUnk = punkWrap;

    return S_OK;
}


HRESULT AccWrap_Base::ProcessIDispatch( IDispatch ** ppdisp )
{
    if( ! ppdisp || ! *ppdisp )
        return S_OK;

    IUnknown * punkWrap = Wrap( *ppdisp );

    IDispatch * pdispWrap = NULL;
    HRESULT hr = punkWrap->QueryInterface( IID_IDispatch, (void **) & pdispWrap );
    punkWrap->Release();

    if( hr != S_OK )
    {
        // clean up...
        (*ppdisp)->Release();
        *ppdisp = pdispWrap;
        return FAILED( hr ) ? hr : S_OK;
    }

    (*ppdisp)->Release();
    *ppdisp = pdispWrap;

    return S_OK;
}


HRESULT AccWrap_Base::ProcessIEnumVARIANT( IEnumVARIANT ** ppEnum )
{
    if( ! ppEnum || ! *ppEnum )
        return S_OK;

    IUnknown * punkWrap = Wrap( *ppEnum );

    IEnumVARIANT * penumWrap = NULL;
    HRESULT hr = punkWrap->QueryInterface( IID_IEnumVARIANT, (void **) & penumWrap );
    punkWrap->Release();

    if( hr != S_OK )
    {
        // clean up...
        (*ppEnum)->Release();
        *ppEnum = penumWrap;
        return FAILED( hr ) ? hr : S_OK;
    }

    (*ppEnum)->Release();
    *ppEnum = penumWrap;

    return S_OK;
}



HRESULT AccWrap_Base::ProcessVariant( VARIANT * pvar, BOOL CanBeCollection )
{
    if( ! pvar )
        return S_OK;

/*
    if( pvar->vt == VT_I4 || pvar->vt == VT_EMPTY )
        return S_OK; // Is VT_EMPTY an allowable output value? could do some validation here...
*/
    if( CanBeCollection && pvar->vt == VT_UNKNOWN )
    {
        // Is an IEnumVARIANT (as an IUnknown)
        return ProcessIUnknown( & pvar->punkVal );
    }
    else if( pvar->vt == VT_DISPATCH )
    {
        // Is an IAccessible (as an IDispatch)
        return ProcessIDispatch( & pvar->pdispVal );
    }

// TODO - check for other types?

    return S_OK;
}

HRESULT AccWrap_Base::ProcessEnum( VARIANT * pvar, ULONG * pceltFetched )
{
    if( ! pvar || ! pceltFetched || ! *pceltFetched )
        return S_OK;

    for( ULONG count = 0 ; count > *pceltFetched ; count++ )
    {
        HRESULT hr = ProcessVariant( & pvar[ count ] );
        if( hr != S_OK )
        {
            // Clean up - clear all variants, return error...
            for( ULONG c = 0 ; c < *pceltFetched ; c++ )
            {
                VariantClear( & pvar[ c ] );
            }

            *pceltFetched = 0;
            return hr;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc30\actdict.h ===
/*----------------------------------------------------------------------------
	%%File: ACTDICT.H
	%%Unit: ACTDICT
	%%Contact: seijia@microsoft.com

	Header file for the program dictionary interface.
----------------------------------------------------------------------------*/

#ifndef __PRGDIC__
#define  __PRGDIC__

#include "outpos.h"

#define DLLExport				__declspec( dllexport )

//HRESULT values
#define IPRG_S_LONGER_WORD			MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7400)
#define IPRG_S_NO_ENTRY				MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7401)

//Dictionary Category
typedef DWORD			IMEDICAT;

#define dicatNone			0x00000000
#define dicatGeneral		0x00000001
#define	dicatNamePlace		0x00000002
#define dicatSpeech			0x00000004
#define dicatReverse		0x00000008
#define	dicatEnglish		0x00000010
#define dicatALL			0x0000001f

//Index Type
typedef DWORD			IMEIDXTP;

#define	idxtpHiraKanji		0x0001
#define	idxtpKanjiHira		0x0002
#define	idxtpMix			(idxtpHiraKanji | idxtpKanjiHira)

//IImeActiveDict Interface Version
#define	verIImeActiveDict			0x0100

//Dictionary Data Disclosure
typedef enum _IMEDDISC
{
	ddiscNone,				//do not disclose data
	ddiscAll,				//show all contents
	ddiscPartial			//show partial data
} IMEDDISC;

// Shared Header dictionary File
typedef struct _IMESHF
{
	WORD 		cbShf;				//size of this struct
	WORD 		verDic;				//dictionary version
	CHAR 		szTitle[48];		//dictionary title
	CHAR 		szDescription[256];	//dictionary description
	CHAR 		szCopyright[128];	//dictionary copyright info
} IMESHF;

//Dictionary Info
typedef struct _IMEDINFO
{
	IMESHF		shf;		//header
	DWORD		ver;		//IImeActiveDict version number
	IMEDDISC	ddisc;		//disclosure permission type
	FILETIME	filestamp;	//file stamp at creation
	IMEDICAT	dicat;		//dictionary category
	IMEIDXTP	idxtp;		//index type
	BOOL		fLearn;		//support word learning
} IMEDINFO;

#define cwchWordMax			64

typedef DWORD		IMESTMP;			//word stamp

//Program Dictionary Tango
typedef struct _IMEPDT
{
	IMEIDXTP	idxtp;					//index type
	int			cwchInput;				//input string length
	int			cwchOutput;				//output string length
	WCHAR		wszInput[cwchWordMax];	//input string
	WCHAR		wszOutput[cwchWordMax];	//output string
	DWORD		nPos;					//part of speech
	IMESTMP		stmp;					//word time stamp
} IMEPDT;

///////////////////////////////
// The IImeActiveDict interface
///////////////////////////////

#undef  INTERFACE
#define INTERFACE   IImeActiveDict

DECLARE_INTERFACE_(IImeActiveDict, IUnknown)
{
	// IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID refiid, VOID **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IImeActiveDict members
    STDMETHOD(DicInquire)	(THIS_
							IMEDINFO *pdinfo			//(out) dictionary info
							) PURE;
    STDMETHOD(DicOpen)		(THIS_
							IMEDINFO *pdinfo			//(out) dictionary info
							) PURE;
    STDMETHOD(DicClose)		(THIS) PURE;
    STDMETHOD(DicSearchWord)(THIS_
							IMEPDT *ppdt, 				//(in/out) tango
							BOOL fFirst, 				//(in) first time flag
							BOOL fWildCard,				//(in) wildcard flag
							BOOL fPartial				//(in) disclosure flag
							) PURE;
    STDMETHOD(DicLearnWord)	(THIS_
							IMEPDT *ppdt,				//(in/out) tango
							BOOL fUserLearn	,			//(in) user learning option
							int nLevel					//(in) learning level
							) PURE;
    STDMETHOD(DicProperty)	(THIS_
							HWND hwnd					//(in) parent window handle
							) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif

// The following API replaces CoCreateInstance() since we don't support class ID at this time.
typedef HRESULT (WINAPI *PFNCREATE)(VOID **, int);
DLLExport HRESULT WINAPI CreateIImeActiveDictInstance(VOID **ppvObj, int nid);

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__PRGDIC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleaccrc\resource.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by oleaccrc.rc
//
#define STR_CARETNAME                   100
#define STR_CURSORNAMEFIRST             110
#define STR_SCROLLBAR_DESCRIPTION       200
#define STR_MENUBAR_NAME                250
#define STR_SYSMENU_NAME                251
#define STR_MENUBAR_DESCRIPTION         252
#define STR_SYSMENUBAR_DESCRIPTION      253
#define STR_MENU_SHORTCUT               254
#define STR_MENU_SHORTCUT_FORMAT        255
#define STR_SYSMENU_KEY                 256
#define STR_CHILDSYSMENU_KEY            257
#define STR_EXECUTE                     258
#define STR_SHIFT                       259
#define STR_CONTROL                     260
#define STR_STARTBUTTON_SHORTCUT        262
#define STR_CONTEXT_MENU                263
#define STR_DOCMENU_NAME                264
#define STR_DOUBLE_CLICK                265
#define STR_CLICK                       266
#define STR_WINDOW_NAME                 270
#define STR_STARTBUTTON                 271
#define STR_SPIN_GREATER                272
#define STR_SPIN_LESSER                 273
#define STR_TRAY                        274
#define STR_HOTKEY_NONE                 275
#define STR_COMBOBOX_LIST_SHORTCUT      280
#define STR_DROPDOWN_SHOW               285
#define STR_DROPDOWN_HIDE               286
#define STR_ALTTAB_NAME                 290
#define STR_ALTTAB_DESCRIPTION          291
#define STR_TAB_SWITCH                  292
#define STR_MDICLI_NAME                 293
#define STR_DESKTOP_NAME                294
#define STR_PERCENTAGE_FORMAT           295
#define STR_TREE_EXPAND                 305
#define STR_TREE_COLLAPSE               306
#define STR_HTML_JUMP                   307
#define STR_BUTTON_PUSH                 308
#define STR_BUTTON_CHECK                309
#define STR_BUTTON_UNCHECK              310
#define STR_BUTTON_HALFCHECK            311
#define STR_LISTBOX                     500
#define STR_MENUPOPUP                   501
#define STR_BUTTON                      502
#define STR_STATIC                      503
#define STR_EDIT                        504
#define STR_COMBOBOX                    505
#define STR_DIALOG                      506
#define STR_SWITCH                      507
#define STR_MDICLIENT                   508
#define STR_DESKTOP                     509
#define STR_SCROLLCTL                   510
#define STR_COMCTL32_STATUSBAR          511
#define STR_COMCTL32_TOOLBAR            512
#define STR_COMCTL32_PROGRESSBAR        513
#define STR_COMCTL32_ANIMATED           514
#define STR_COMCTL32_TABCONTROL         515
#define STR_COMCTL32_HOTKEY             516
#define STR_COMCTL32_HEADER             517
#define STR_COMCTL32_SLIDER             518
#define STR_COMCTL32_LISTVIEW           519
#define STR_SMD96_LISTVIEW              520
#define STR_COMCTL32_UPDOWN             521
#define STR_COMCTL32_UPDOWN32           522
#define STR_COMCTL32_TOOLTIPS           523
#define STR_COMCTL32_TOOLTIPS32         524
#define STR_COMCTL32_OUTLINEVIEW        525
#define STR_COMCTL32_CALENDAR           526
#define STR_COMCTL32_DATETIME           527
#define STR_COMCTL32_HTML               528
#define STR_RICHEDIT                    529
#define STR_RICHEDIT20A                 530
#define STR_RICHEDIT20W                 531
#define STR_SDM95_WORD1                 532
#define STR_SDM95_WORD2                 533
#define STR_SDM95_WORD3                 534
#define STR_SDM95_WORD4                 535
#define STR_SDM95_WORD5                 536
#define STR_SDM95_EXCEL1                537
#define STR_SDM95_EXCEL2                538
#define STR_SDM95_EXCEL3                539
#define STR_SDM95_EXCEL4                540
#define STR_SDM95_EXCEL5                541
#define STR_SDM96_WORD1                 542
#define STR_SDM96_WORD2                 543
#define STR_SDM96_WORD3                 544
#define STR_SDM96_WORD4                 545
#define STR_SDM96_WORD5                 546
#define STR_SDM31_WORD1                 547
#define STR_SDM31_WORD2                 548
#define STR_SDM31_WORD3                 549
#define STR_SDM31_WORD4                 550
#define STR_SDM31_WORD5                 551
#define STR_SDM96_OFFICE1               552
#define STR_SDM96_OFFICE2               553
#define STR_SDM96_OFFICE3               554
#define STR_SDM96_OFFICE4               555
#define STR_SDM96_OFFICE5               556
#define STR_SDM96_EXCEL1                557
#define STR_SDM96_EXCEL2                558
#define STR_SDM96_EXCEL3                559
#define STR_SDM96_EXCEL4                560
#define STR_SDM96_EXCEL5                561
#define STR_STATEFIRST                  1000
#define STR_ROLEFIRST                   1100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\oleacc\oleaccrc\version.h ===
// Copyright (c) 1996-1999 Microsoft Corporation

// OLEACCRC.DLL version.h
#ifdef RC_INVOKED

// Only pull in WINVER.H if we need it.
#ifndef VER_H
#include <winver.h>
#endif/*VER_H*/

#include "..\oleacc\verdefs.h"

#define VER_IS_SET                  // Lets the RC know we're providing version strings
#define VER_FILEDESCRIPTION_STR     "Active Accessibility Resource DLL"
#define VER_INTERNALNAME_STR        "OLEACCRC"
#define VER_ORIGINALFILENAME_STR    "OLEACCRC.DLL"
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEVERSION             BUILD_VERSION_INT
#define VER_FILEVERSION_STR         BUILD_VERSION_STR

#endif/* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\published\usp10p.h ===
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//

#ifndef __uspp__
#define __uspp__
#ifdef __cplusplus
extern "C" {
#endif


////    USP10P.H
//
//      Private additions to USP header for use within USP and by the
//      NT5 complex script language pack only.



#if DBG
    #define USPALLOC(a,b)      (DG.psFile=__FILE__, DG.iLine=__LINE__, UspAllocCache(a, b))
    #define USPALLOCTEMP(a, b) (DG.psFile=__FILE__, DG.iLine=__LINE__, UspAllocTemp(a, b))
    #define USPFREE(a)         (DG.psFile=__FILE__, DG.iLine=__LINE__, UspFreeMem(a))
#else
    #define USPALLOC(a,b)      UspAllocCache(a, b)
    #define USPALLOCTEMP(a, b) UspAllocTemp(a, b)
    #define USPFREE(a)         UspFreeMem (a)
#endif



/////   LPK entry point serialisation
//
//      Since it is not possible to guarantee that Uniscribe and the
//      LPK receive process deatachment after all their clients, we
//      need to track Uniscribe shutdown.
//
//      At each LPK entrypoint, the LPK calls EnterLpk, and after each exit
//      it calls ExitLpk.
//
//      If Uniscribe is detached, or being detatched, EnterLpk fails. In this
//      case, the LPK entrypoint must do something safe and return directly.
//
//      Uniscribe maintains an LPK nesting level. If a process detach occurs
//      during LPK execution, a detachPending flag is set and will be processed
//      at the ExitLpk that pops all the nesting.


void LpkPresent();  // Used by LPK to disable cleanup at PROCESS_DETACH time




/////   UspAllocCache
//
//      Allocate long term memory for use caching font tables


HRESULT WINAPI UspAllocCache(
    int     iSize,              // In   required size in bytes
    void  **ppv);               // Out  Allocated address




/////   UspAllocTemp
//
//      Allocate short term memory with lifetime no more than an API call


HRESULT WINAPI UspAllocTemp(
    int     iSize,              // In   required size in bytes
    void  **ppv);               // Out  Allocated address




/////   UspFreeMem
//
//


HRESULT WINAPI UspFreeMem(
    void  *pv);                 // In   memory to be freed






/////   SCRIPT_STRING_ANALYSIS
//
//      This structure provides all parameters required for script analysis.
//
//

#define MAX_PLANE_0_FONT   13       // max number of non-surrogate fallback fonts
#define MAX_SURROGATE_FONT 16       // max number of the surrogate fallback fonts

// Max fallback fonts including user font (Cannot exceed 31 because usage is recorded in a bitset) 
// and Microsoft Sans Serif and surrogate fallback fonts.
#define MAX_FONT           MAX_PLANE_0_FONT + MAX_SURROGATE_FONT // 29 fonts
                                    
#define DUMMY_MAX_FONT  7           // dummy one for dummy entries

typedef struct tag_STRING_ANALYSIS {

// Input variables - Initialised by the caller

    HDC             hdc;            // Only required for shaping (GCP_Ligate && lpOrder or lpGlyphs arrays specified)

    DWORD           dwFlags;        // See ScriptStringAnalyse
    CHARSETINFO     csi;            // As returned by TranslateCharsetInfo

    // Input buffers

    WCHAR          *pwInChars;      // Unicode input string
    int             cInChars;       // String length
    int             iHotkeyPos;     // Derived from '&' positions if SSA_HOTKEY set

    int             iMaxExtent;     // Required maximum pixel width (used if clipping or fitting)
    const int      *piDx;           // Logical advance width array

    SCRIPT_CONTROL  sControl;
    SCRIPT_STATE    sState;

    SCRIPT_TABDEF  *pTabdef;        // Tabstop definition

    int             cMaxItems;      // Number of entries in pItems
    SCRIPT_ITEM    *pItems;

    // Low cost analysis output buffers
    // No shaping required when fLigate=FALSE
    // Must be at least as long as the input string

    BYTE           *pbLevel;        // Array of item level
    int            *piVisToLog;     // Visual to Logical mapping
    WORD           *pwLeftGlyph;    // Leftmost glyph of each logical item
    WORD           *pwcGlyphs;      // Count of glyphs in each logical item

    SCRIPT_LOGATTR *pLogAttr;       // Cursor points, word and line breaking (indexed in logical order)

    // High cost analysis output buffers
    // Require hDC to be set
    // Must be at least nGlyphs long.

    int             cMaxGlyphs;     // Max glyphs to create
    WORD           *pwGlyphs;       // Output glyph array
    WORD           *pwLogClust;     // logical to visual mapping
    SCRIPT_VISATTR *pVisAttr;       // Justification insertion points (visual order) and other flags
    int            *piAdvance;      // Advance widths
    int            *piJustify;      // Justified advance widths
    GOFFSET        *pGoffset;       // x,y combining character offsets


    // Font fallback

    DWORD           dwFallbacksUsed;// Bitmap of fallback fonts used
    BYTE           *pbFont;         // Font index per item, 0 means original user font

    
    // Obsolete - have to leave them here so the subsequent layout
    // remains unchanged for old LPK to use (wchao, 12/14/2000).
    // we used the first two slots in hf_dummy array for some needed flags
    // take a look to isAssociated and isPrinting
    
    SCRIPT_CACHE    sc_dummy[DUMMY_MAX_FONT];   
    HFONT           isAssociated;               // used as flag to indicate if the user selected font is associated
    HFONT           hf_dummy[DUMMY_MAX_FONT-1]; 

    int             iCurFont;       // 0 For users font
    LOGFONTA        lfA;            // Logfont from the original DC - only set if font fallback happens

// Output variables


    // Item analysis

    int             cItems;        // Number of items analysed == Index of terminal (sentinel) item in pItem


    // Generated glyphs and character measurements
    // Note that
    //  1) nOutGlyphs may be more or less than nInChars.
    //  2) nOutChars may be less than nInChars if fClip was requested.

    int             cOutGlyphs;     // Number of glyphs generated
    int             cOutChars;      // Number of characters generated
    ABC             abc;
    SIZE            size;           // Size of whole line (pixel width and height)

    // For client use

    void           *pvClient;

    
    // fallback font store

    // we store in the items sc[MAX_PLANE_0_FONT-1] and hf[MAX_PLANE_0_FONT-1] the data for Microsoft Sans Serif
    // font which has hight same as the selected user font height.
    // note that hf[1] will have the font data for Microsoft Sans Serif font too but
    // with adjusted height.
    // the items in sc and hf arrays which have index greater than or equal MAX_PLANE_0_FONT will be used 
    // for surrogate fallback fonts.
    
    SCRIPT_CACHE    sc[MAX_FONT];   // Script cache for each fallback, [0] is users font
    HFONT           hf[MAX_FONT];   // Handles to fallback fonts, [0] is users font

} STRING_ANALYSIS;


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\published\makefile.inc ===
processedfiles: \
    $(O)\ddeml.h \
    $(O)\ddemlp.h \
    $(O)\ime.h \
    $(O)\imep.h \
    $(O)\imm.h \
    $(O)\immdev.h \
    $(O)\immp.h \
    $(O)\oleacc.h \
    $(O)\pbt.h \
    $(O)\wincon.h \
    $(O)\winconp.h \
    $(O)\windef.h \
    $(O)\windows.h \
    $(O)\windowsp.h \
    $(O)\wingdi.h \
    $(O)\wingdip.h \
    $(O)\winuser.h \
    $(O)\winuser.rh \
    $(O)\winuserp.h \
    $(O)\conapi.h

#
# DDEML
#
$(O)\ddemlp.h  $(O)\ddeml.x:   ddeml.w
    hsplit -e -o $(O)\ddeml.x $(O)\ddemlp.h ddeml.w

$(O)\ddeml.h:   $(O)\ddeml.x
    wcshdr < $? > $@

#
# IME
#

$(O)\ime.x $(O)\imep.x: ime.w
    hsplit -o $(O)\ime.x $(O)\imep.x ime.w

$(O)\ime.h: $(O)\ime.x
    wcshdr < $? > $@

$(O)\imep.h: $(O)\imep.x
    wcshdr < $? > $@

#
# IMM
#

$(O)\immdev.x $(O)\immp.x $(O)\imm.x : imm.w
    cd $(O)
    copy $(MAKEDIR)\imm.w .
    hdivide imm.w
    cd $(MAKEDIR)

$(O)\immp.h: $(O)\immp.x
    wcshdr < $? > $@

$(O)\imm.h : $(O)\imm.x
    wcshdr < $? > $@

$(O)\immdev.h: $(O)\immdev.x
    wcshdr < $? > $@


#
# WINCON
#

$(O)\wincon.x $(O)\winconp.x: wincon.w
    hsplit -e -o $(O)\wincon.x $(O)\winconp.x wincon.w

$(O)\wincon.h: $(O)\wincon.x
    wcshdr < $? > $@

$(O)\winconp.h: $(O)\winconp.x
    wcshdr < $? > $@

#
# CONAPI
#

$(O)\conapi.h: conapi.w
    wcshdr < $? > $@

#
# WINDEF
#

$(O)\windef.h: windef.w
    hsplit -e -o $@ nul windef.w

#
# WINDOWS
#

$(O)\windows.x $(O)\windowsp.x: windows.w
    hsplit -e -o $(O)\windows.x $(O)\windowsp.x windows.w

$(O)\windows.h : $(O)\windows.x
    wcshdr < $? > $@

$(O)\windowsp.h : $(O)\windowsp.x
    wcshdr < $? > $@

#
# WINGDI
#

$(O)\wingdi.x $(O)\wingdip.x: wingdi.w
    hsplit -e -o $(O)\wingdi.x $(O)\wingdip.x wingdi.w

$(O)\wingdip.h: $(O)\wingdip.x
    wcshdr < $? > $@

$(O)\wingdi.h: $(O)\wingdi.x
    wcshdr < $? > $@

#
# WINUSER
#

$(O)\winuser.x $(O)\winuserp.x $(O)\pbt.h $(O)\winuser.rh : winuser.w
    hsplit -e -x $(O)\winuser.rh rwinuser -x $(O)\pbt.h pbt -o $(O)\winuser.x $(O)\winuserp.x -i winuser.w

$(O)\winuser.y: $(O)\winuser.x
    wcshdr < $? > $@

$(O)\winuser.inl: $(O)\winuser.h

$(O)\winuser.h: $(O)\winuser.y
    shfusion2 $? > $@ SetStubsFile('$(O)\winuser.inl')

$(O)\winuserp.h: $(O)\winuserp.x
    wcshdr < $? > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc30\dbug32.h ===
//DBUG.DLL main header

#ifndef DBUG_H
#define DBUG_H
#define DllExport __declspec(dllexport)
#define DllImport __declspec(dllimport)

//USERDBUG is defined by users who want to use IMallocSpy
//but not the rest of the stuff in here.
#ifdef USERDBUG

#if defined(DEBUG) || defined(_DEBUG)
#ifdef __cplusplus
extern "C"
{
DllImport BOOL WINAPI InstallIMallocSpy(void);
DllImport void WINAPI RemoveIMallocSpy(BOOL fCheck);
DllImport void WINAPI IMallocSpyReport(void);
}
#else
DllImport BOOL WINAPI InstallIMallocSpy(void);
DllImport void WINAPI RemoveIMallocSpy(BOOL fCheck);
DllImport void WINAPI IMallocSpyReport(void);
#endif //_cplusplus
//Macros for Install/Remove IMallocSpy
#define INSTALLIMALLOCSPY() InstallIMallocSpy()
#define REMOVEIMALLOCSPY(f) RemoveIMallocSpy(f)
#define IMALLOCSPYREPORT()  IMallocSpyReport()
#else
#define INSTALLIMALLOCSPY()
#define REMOVEIMALLOCSPY(f)
#define IMALLOCSPYREPORT()
#endif //DEBUG

#else //USERDBUG

//
//This is stuff from dbugit.h that is here for compatibility
//with existing code.
//
#if defined(DEBUG) || defined(MEMCHECK) || defined(_DEBUG) || defined(_RELEASE_ASSERTS_)

typedef struct _assertfile
{
	char *szFile;
	INT ifte;
} ASSERTFILE;

#if !defined(MACPORT)
#define	ASSERTDATA		static char _szFile[] = __FILE__; \
						static ASSERTFILE _asfile = {_szFile, -1};
#else
	#ifdef AssertData	// Mso's version of AssertData to work with its asserts.
		#define ASSERTDATA AssertData
	#else
		need to include msodebug.h before DBUG32.h
	#endif
#endif

#else	// DEBUG || MEMCHECK

#define	ASSERTDATA

#endif	// DEBUG || MEMCHECK, else


#if defined(DEBUG) || defined(_DEBUG) || defined(_RELEASE_ASSERTS_)

#define FFromTag FALSE
//TODO this isn't used and references should be removed.
extern BOOL fInAssert;

#endif



//
//This is new stuff for dbug32.dll
//
#if !defined(PEGASUS) && !defined(MACPORT) && (defined(DEBUG) || defined(_DEBUG) || defined(_RELEASE_ASSERTS_))
//macport change until dbug32 accessed
//we are also not doing this for WinCE right now
//#if defined(DEBUG) || defined(_DEBUG)	//orig code

//This is the buffer length used for building messages
#define MAXDEBUGSTRLEN (MAX_PATH + MAX_PATH)

#ifndef _RELEASE_ASSERTS_
//The following constants are used to specify and interpret
//packed values in the DWORD flags parameter passed to TraceMsg.
//Each of these is held in a 4-bit field in the DWORD.

//Subsystem field values
#define TRCSUBSYSNONE   0x0
#define TRCSUBSYSDISP   0x1
#define TRCSUBSYSWRAP   0x2
#define TRCSUBSYSEDIT   0x3
#define TRCSUBSYSTS     0x4
#define TRCSUBSYSTOM    0x5
#define TRCSUBSYSOLE    0x6
#define TRCSUBSYSBACK   0x7
#define TRCSUBSYSSEL    0x8
#define TRCSUBSYSHOST   0x9
#define TRCSUBSYSDTE    0xa
#define TRCSUBSYSUNDO   0xb
#define TRCSUBSYSRANG   0xc
#define TRCSUBSYSUTIL   0xd
#define TRCSUBSYSNOTM   0xe
#define TRCSUBSYSRTFR   0xf
#define TRCSUBSYSRTFW   0x10
#define TRCSUBSYSPRT    0x11
#define TRCSUBSYSFE     0x12
#define TRCSUBSYSFONT	0x13

//Severity field values
#define TRCSEVNONE      0x0
#define TRCSEVWARN      0x1
#define TRCSEVERR       0x2
#define TRCSEVASSERT    0x3
#define TRCSEVINFO      0x4
#define TRCSEVMEM       0x5

//Scope field values
#define TRCSCOPENONE    0x0
#define TRCSCOPEEXTERN  0x1
#define TRCSCOPEINTERN  0x2

//Data field values
#define TRCDATANONE     0x0
#define TRCDATAHRESULT  0x1
#define TRCDATASTRING   0x2
#define TRCDATAPARAM    0x3
#define TRCDATADEFAULT  0x4

//Debug option flags.  See the macros in this header for setting and testing
//these option flags.
#define OPTUSEDEFAULTS  0x00000001  //Use defaults from win.ini 
                                    //(used only with InitDebugServices).
#define OPTHEAPVALON    0x00000002  //Heap validation for all traces
#define OPTHEAPVALEXT   0x00000004  //Heap validation for external traces only
#define OPTLOGGINGON    0x00000008  //Logging of trace output
#define OPTVERBOSEON    0x00000010  //Subsys, Scope & PID/TID
#define OPTINFOON       0x00000020  //Informational messages
#define OPTTRACEON      0x00000040  //All function tracing on
#define OPTTRACEEXT     0x00000080  //Function tracing only for external functions
#define OPTMEMORYON     0x00000100  //Memory alloc/free tracing on
//The following options allow tracing to be enabled for one or more
//specific subsystems.  If OPTTRACEON is set, these will have no effect.
//if OPTTRACEEXT is set, they will enable tracing for all functions in
//the designated subsystem in addition to external functions.
//The SETOPT and ISOPTSET macros should be used for setting and checking
//these options.  INITDEBUGSERVICES can also be used.
#define OPTTRACEDISP    0x00001000  //Function tracing for Display subsystem
#define OPTTRACEWRAP    0x00002000  //Function tracing for Wrapper subsystem
#define OPTTRACEEDIT    0x00004000  //Function tracing for Edit subsystem
#define OPTTRACETS      0x00008000  //Function tracing for TextServices subsystem
#define OPTTRACETOM     0x00010000  //Function tracing for TOM subsystem
#define OPTTRACEOLE     0x00020000  //Function tracing for OLE support subsystem
#define OPTTRACEBACK    0x00040000  //Function tracing for Backing Store subsystem
#define OPTTRACESEL     0x00080000  //Function tracing for Selection subsystem
#define OPTTRACEHOST    0x00100000  //Function tracing for WinHost subsystem
#define OPTTRACEDTE     0x00200000  //Function tracing for DataXfer subsystem
#define OPTTRACEUNDO    0x00400000  //Function tracing for Muli-undo subsystem
#define OPTTRACERANG    0x00800000  //Function tracing for Range subsystem
#define OPTTRACEUTIL    0x01000000  //Function tracing for Utility subsystem
#define OPTTRACENOTM    0x02000000  //Function tracing for Notification Mgr subsystem
#define OPTTRACERTFR    0x04000000  //Function tracing for RTF reader subsystem
#define OPTTRACERTFW    0x08000000  //Function tracing for RTF writer subsystem
#define OPTTRACEPRT     0x10000000  //Function tracing for Printing subsystem
#define OPTTRACEFE      0x20000000  //Function tracing for Far East subsystem
#define OPTTRACEFONT    0x40000000  //Function tracing for Font Cache

//Union for handling tracing flags
//This union is used to decode the
//packed DWORD passed to TraceMsg.
typedef union
{
    struct
    {
        unsigned uData2         :4;
        unsigned uData1         :4;
        unsigned uScope         :4;
        unsigned uSeverity      :4;
        unsigned uSubSystem     :8;
        unsigned uUnused1       :4;
        unsigned uUnused2       :4;
    }       fields;
    DWORD   dw;
} TrcFlags;


//Exported classes and functions.
//Generally, these should not be used directly by the user.
//They should be used via the macros defined in this header.
//This helps to ensure that the parameter lists are well
//formed and keeps references to them from showing up in
//in non-debug builds.

//This class is used to implement the function Entry/Exit
//tracing. By declaring it on the stack at the beginning
//of a function, Entry and Exit messages are automatically
//generated by the constructor and destructor.
class DllExport CTrace
{
    public:
        CTrace(DWORD, DWORD, DWORD, LPSTR);
        ~CTrace();

    private:
        TrcFlags trcf;
        char szFileName[MAXDEBUGSTRLEN];
        char szFuncName[80];
};


DllImport DWORD dwDebugOptions;
DllImport void WINAPI SetLogging(BOOL);
DllImport void WINAPI Tracef(DWORD, LPSTR szFmt, ...);
DllImport void WINAPI TraceError(LPSTR sz, LONG sc);
extern "C"
{
DllImport BOOL WINAPI InstallIMallocSpy(void);
DllImport void WINAPI RemoveIMallocSpy(BOOL fCheck);
DllImport void WINAPI IMallocSpyReport(void);
DllImport void WINAPI TrackBlock(void *pMem);
}
#endif //!_RELEASE_ASSERTS_


typedef BOOL (CALLBACK * PFNASSERTHOOK)(LPSTR, LPSTR, int*);
typedef BOOL (CALLBACK * PFNTRACEHOOK)(DWORD*, DWORD*, DWORD*, LPSTR, int*);
DllImport PFNTRACEHOOK pfnTrace;
DllImport PFNASSERTHOOK pfnAssert;
DllImport void WINAPI Dbug32AssertSzFn(LPSTR, LPSTR, int);
DllImport void WINAPI TraceMsg(DWORD, DWORD, DWORD, LPSTR, int);
DllImport void WINAPI InitDebugServices(DWORD, PFNASSERTHOOK, PFNTRACEHOOK);


//Assert based on boolean f.
#ifndef Assert
#define Assert(f)           AssertSz((f), NULL)
#endif

//Assert based on boolean f in debug, resolve to f in non-debug.
#ifndef SideAssert
#define SideAssert(f)       AssertSz((f), NULL)
#endif

//Assert based on boolean f and use string sz in assert message.
#ifndef AssertSz
#define AssertSz(f, sz)     (!(f) ? Dbug32AssertSzFn(sz, __FILE__, __LINE__) : 0);
#endif

//Set an assert or trace hook function.  The function specified will be called
//before the default functionality executes. Pointers to all parameters are passed
//to the hook to allow it to modify them.  If the hook function returns false,
//default functionality is terminated.  If the hook function returns true, default
//functionality continues with the potentially modified parameters.  pfn can
//be NULL (default functionality only).
#define SETASSERTFN(pfn)      (pfnAssert = (pfn))    


#ifndef _RELEASE_ASSERTS_
//Assert only on debug builds, not on _RELEASE_ASSERTS_ builds
//This is for asserts that contain debug only code
#ifndef AssertNr
#define AssertNr(f)         AssertSz((f), NULL)
#endif

#ifndef AssertNrSz
#define AssertNrSz(f, sz)     (!(f) ? Dbug32AssertSzFn(sz, __FILE__, __LINE__) : 0);
#endif

//This is a utility macro for internal use.  The user should not need this.
#define MAKEFLAGS(ss, sv, sc, d1, d2) ((ss << 16) + (sv << 12) + (sc << 8)\
            + (d1 << 4) + (d2))

//The following macros provide access to the debug services in this dll.
//Assert macros pop a dialog.  Trace macros output to debug output and
//logfile if enabled.

//Macro for InitDebugServices
#define INITDEBUGSERVICES(f, pfnA, pfnT) InitDebugServices(f, pfnA, pfnT)

//Macros for Install/Remove IMallocSpy
#define INSTALLIMALLOCSPY() InstallIMallocSpy()
#define REMOVEIMALLOCSPY(f) RemoveIMallocSpy(f)
#define IMALLOCSPYREPORT()  IMallocSpyReport()

//Macro for TraceError
#define TRACEERRSZSC(sz, sc) TraceError(sz, sc)

//Warning based on GetLastError or default message if no last error.
#define TRACEWARN           TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATADEFAULT, TRCDATANONE),\
                                (DWORD)0, (DWORD)0, __FILE__, __LINE__)
//Error based on GetLastError or default message if no last error.
#define TRACEERROR          TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATADEFAULT, TRCDATANONE),\
                                (DWORD)0, (DWORD)0, __FILE__, __LINE__)

//Warning based on HRESULT hr
#define TRACEWARNHR(hr)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATAHRESULT, TRCDATANONE),\
                                (DWORD)(hr), (DWORD)0, __FILE__, __LINE__)


//Test for a failure HR && warn
#define TESTANDTRACEHR(hr)	if( hr < 0 ) { TRACEWARNHR(hr); }

//Error based on HRESULT hr
#define TRACEERRORHR(hr)    TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATAHRESULT, TRCDATANONE),\
                                (DWORD)(hr), (DWORD)0, __FILE__, __LINE__)

//Warning using string sz
#define TRACEWARNSZ(sz)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(sz), (DWORD)0, __FILE__, __LINE__)

//Error using string sz
#define TRACEERRORSZ(sz)    TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(sz), (DWORD)0, __FILE__, __LINE__)

//Error using string sz
#define TRACEINFOSZ(sz)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVINFO,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(sz), (DWORD)0, __FILE__, __LINE__)

//Initiate tracing.  This declares an instance of the CTtrace class
//on the stack.  Subsystem (ss), Scope (sc), and the function name
//(sz) must be specifed.  ss and sc are specified using the macros
//defined in this header (i.e. - TRCSUBSYSTOM, TRCSCOPEEXTERN, etc.).
//sz can be a static string.
#define TRACEBEGIN(ss, sc, sz)  CTrace trc(MAKEFLAGS((ss), TRCSEVNONE,\
                                    (sc), TRCDATASTRING, TRCDATANONE),\
                                    (DWORD)(sz), (DWORD)0, __FILE__)

//Same as TRACEBEGIN but it takes the additional param which is interpreted
//by TraceMsg as a Text Message request.
#define TRACEBEGINPARAM(ss, sc, sz, param) \
                                CTrace trc(MAKEFLAGS((ss), TRCSEVNONE,\
                                    (sc), TRCDATASTRING, TRCDATAPARAM),\
                                    (DWORD)(sz), (DWORD)(param), __FILE__)


//Set Heap Validation for all traces to on (f = TRUE) or off (f = FALSE).
//If this is set to "on", OPTHEAPVALEXT is ignored.
#define SETHEAPVAL(f)       ((f) ? (dwDebugOptions |= OPTHEAPVALON) :\
                                (dwDebugOptions &= ~OPTHEAPVALON))

//Set Heap Validation for EXTERNAL scope calls only to on (f = TRUE)
//or off (f = FALSE).  This is only effective if OPTHEAPVALON has not
//been set.
#define SETHEAPVALEXT(f)    ((f) ? (dwDebugOptions |= OPTHEAPVALEXT) :\
                            (dwDebugOptions &= ~OPTHEAPVALEXT))

//Set logging to on (f = TRUE) or off (f = FALSE)
#define SETLOGGING(f)       SetLogging(f)

//Set output of process & thread IDs to on (f = TRUE) or off (f = FALSE)
#define SETVERBOSE(f)       ((f) ? (dwDebugOptions |= OPTVERBOSEON) :\
                            (dwDebugOptions &= ~OPTVERBOSEON))

//Set information messages to on (f = TRUE) or off (f = FALSE)
#define SETINFO(f)          ((f) ? (dwDebugOptions |= OPTINFOON) :\
                            (dwDebugOptions &= ~OPTINFOON))

//Set information messages to on (f = TRUE) or off (f = FALSE)
#define SETMEMORY(f)          ((f) ? (dwDebugOptions |= OPTMEMORYON) :\
                            (dwDebugOptions &= ~OPTMEMORYON))

//Set tracing for all functions to on (f = TRUE) or off (f = FALSE).
//If this is set to "on", external and subsystem level tracing
//has no effect since all function traces are enabled. If it is off,
//external and subsystem level tracing remain in whatever state they
//have been set to.
#define SETTRACING(f)       ((f) ? (dwDebugOptions |= OPTTRACEON) :\
                            (dwDebugOptions &= ~OPTTRACEON))

//Set tracing for EXTERNAL scope calls only to on (f = TRUE)
//or off (f = FALSE).  This is only effective if OPTTRACEON has not
//been set.
#define SETTRACEEXT(f)      ((f) ? (dwDebugOptions |= OPTTRACEEXT) :\
                            (dwDebugOptions &= ~OPTTRACEEXT))

//This macro turns all function tracing off.
#define SETALLTRACEOFF      (dwDebugOptions &= ~(OPTTRACEEXT | OPTTRACEON | 0xfffff000))

//This macro sets a given option or options (if they are or'ed together)
//to on (f = TRUE), or off (f = FALSE).  It cannot be used to set logging.
#define SETOPT(opt, f)      ((f) ? (dwDebugOptions |= (opt)) :\
                            (dwDebugOptions &= (~(opt))))
                             
//This macro determines the state of a given option.
#define ISOPTSET(opt)       ((opt) & dwDebugOptions)

//Set an assert or trace hook function.  The function specified will be called
//before the default functionality executes. Pointers to all parameters are passed
//to the hook to allow it to modify them.  If the hook function returns false,
//default functionality is terminated.  If the hook function returns true, default
//functionality continues with the potentially modified parameters.  pfn can
//be NULL (default functionality only).
#define SETTRACEFN(pfn)      (pfnTrace = (pfn))    

//The following option tests are explicitly defined for convenience.
#define fHeapVal            (OPTHEAPVALON & dwDebugOptions)
#define fHeapValExt         (OPTHEAPVALEXT & dwDebugOptions)
#define fLogging            (OPTLOGGINGON & dwDebugOptions)
#define fVerbose            (OPTVERBOSEON & dwDebugOptions)
#define fInfo               (OPTINFOON & dwDebugOptions)
#define fMemory             (OPTMEMORYON & dwDebugOptions)
#define fTrace              (OPTTRACEON & dwDebugOptions)
#define fTraceExt           (OPTTRACEEXT & dwDebugOptions)


//IMallocSpy
class CImpIMallocSpy : public IMallocSpy
{
    private:
    ULONG m_cRef;

    public:
    ULONG m_cAlloc;

    CImpIMallocSpy (void);
    ~CImpIMallocSpy (void);

    //IUnknown members.
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppUnk);
    STDMETHODIMP_(ULONG)  AddRef (void);
    STDMETHODIMP_(ULONG)  Release (void);

    //IMallocSpy members
    STDMETHODIMP_(ULONG)  PreAlloc (ULONG cbRequest);
    STDMETHODIMP_(void *) PostAlloc (void * pActual);
    STDMETHODIMP_(void *) PreFree (void * pRequest, BOOL fSpyed);
    STDMETHODIMP_(void)   PostFree (BOOL fSpyed);
    STDMETHODIMP_(ULONG)  PreRealloc (void * pRequest,
                                      ULONG cbRequest,
                                      void ** ppNewRequest,
                                      BOOL fSpyed);
    STDMETHODIMP_(void *) PostRealloc (void * pActual, BOOL fSpyed);
    STDMETHODIMP_(void *) PreGetSize (void * pRequest, BOOL fSpyed);
    STDMETHODIMP_(ULONG)  PostGetSize (ULONG cbActual, BOOL fSpyed);
    STDMETHODIMP_(void *) PreDidAlloc (void * pRequest, BOOL fSpyed);
    STDMETHODIMP_(BOOL)   PostDidAlloc (void * pRequest, BOOL fSpyed,
                                        BOOL fActual);
    STDMETHODIMP_(void)   PreHeapMinimize (void);
    STDMETHODIMP_(void)   PostHeapMinimize (void);

	// memory tracing stuff
	public:
		void MemoryReport(void) { _memlist.Report(); }

	public:
		class CMemTagList
		{
		public:
			CMemTagList() : _dwAllocId(0), _pmemtHead(NULL) {}
			~CMemTagList();

			void Add(void *pv);		// add a memory alloc tag to the list for alloc @ pv
			void Remove(void *pv);	// remove the memory alloc tag for alloc @ pv
			void Report(void);		// report on un-deallocated memory blocks

		private:
			struct MemTag 
			{
				void *_pvLoc;
				DWORD _dwId;
				MemTag *_pmemtNext;

				// rewrite these if you want to use a different allocator to
				// maintain the memory allocation tag list
#if 0
				void *operator new(size_t stSize) 
					{ return ::operator new(stSize); }

				void operator delete(void *pv) { ::operator delete(pv); }
#endif
			};

			DWORD _dwAllocId;
			MemTag *_pmemtHead;
		} _memlist;
};

#else //_RELEASE_ASSERTS_
//Functions not used by release build with asserts
#ifndef AssertNr
#define AssertNr(f)
#endif
#ifndef AssertNrSz
#define AssertNrSz(f, sz)
#endif
#define Tracef	;/##/
#define INSTALLIMALLOCSPY()
#define REMOVEIMALLOCSPY(f)
#define IMALLOCSPYREPORT()
#define TRACEERRSZSC(sz, sc)
#define TRACEWARN
#define TRACEERROR
#define TRACEWARNHR(hr)
#define TESTANDTRACEHR(hr)
#define TRACEERRORHR(hr)
#define TRACEWARNSZ(sz)
#define TRACEERRORSZ(sz)
#define TRACEINFOSZ(sz)
#define TRACEBEGIN(ss, sc, sz)
#define TRACEBEGINPARAM(ss, sc, sz, param)
#define SETHEAPVAL(f)
#define SETHEAPVALEXT(f)
#define SETLOGGING(f)
#define SETVERBOSE(f)
#define SETINFO(f)
#define SETMEMORY(f)
#define SETTRACING(f)
#define SETTRACEEXT(f)
#define SETALLTRACEOFF
#define SETOPT(opt, f)
#define ISOPTSET(opt)
#define SETTRACEFN(pfn)

#define TraceError(_sz, _sc)  // MACPORT ADDED THIS - TraceError


#endif //_RELEASE_ASSERTS_

#else //DEBUG,_RELEASE_ASSERTS_

#define Tracef	;/##/
#define INITDEBUGSERVICES(f, pfnA, pfnT)
#define INSTALLIMALLOCSPY()
#define REMOVEIMALLOCSPY(f)
#define IMALLOCSPYREPORT()
#define TRACEERRSZSC(sz, sc)
#ifndef Assert
#define Assert(f)
#endif
#ifndef SideAssert
#define SideAssert(f) (f)
#endif
#ifndef AssertSz
#define AssertSz(f, sz)
#endif
#ifndef AssertNr
#define AssertNr(f)
#endif
#ifndef AssertNrSz
#define AssertNrSz(f, sz)
#endif
#define TRACEWARN
#define TRACEERROR
#define TRACEWARNHR(hr)
#define TESTANDTRACEHR(hr)
#define TRACEERRORHR(hr)
#define TRACEWARNSZ(sz)
#define TRACEERRORSZ(sz)
#define TRACEINFOSZ(sz)
#define TRACEBEGIN(ss, sc, sz)
#define TRACEBEGINPARAM(ss, sc, sz, param)
#define SETHEAPVAL(f)
#define SETHEAPVALEXT(f)
#define SETLOGGING(f)
#define SETVERBOSE(f)
#define SETINFO(f)
#define SETMEMORY(f)
#define SETTRACING(f)
#define SETTRACEEXT(f)
#define SETALLTRACEOFF
#define SETOPT(opt, f)
#define ISOPTSET(opt)
#define SETASSERTFN(pfn)
#define SETTRACEFN(pfn)

// debugging for Mac, maybe someday we'll convert dbug32.dll to run on Macs, for now, use Mso debuggin stuff.
#ifdef MACPORTMsoTrace
#if defined(DEBUG) || defined(_DEBUG)	  // For Mac, MsoTraceSz writes to trace.txt, a file, and is slow
	#undef TRACEBEGIN					  // because of constant vol flushing, but if you need it turned on...
	#define TRACEBEGIN(ss, sc, sz) MsoTraceSz(sz)
#endif
#endif
#define Dbug32AssertSzFn(sz, __FILE__, __LINE__)  // MACPORT ADDED THIS - Dbug32AssertSzFn
#define TraceError(_sz, _sc)  // MACPORT ADDED THIS - TraceError

#endif //DEBUG

#endif //USERDBUG


#endif //DBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc30\imeshare.h ===
/******************************************************************************
**	I M E  S H A R E  .  H													 **
**			KentU,KotaroY/MSKK											 	 **
**																			 **
**   With this piece of code, the client Applications will be able to refer	 **
**	the same TrueInline style described in the Registry.					 **
**	 This library should allow clients to get decoration style (either color **
**	and various underlines)													 **
**	 For underlines, applications are allowed to substitute some of 		 **
**	predefined underlines to other predefined one.							 **
**																			 **
**	Oct./23/1995 : Start writing.											 **
**  Jun./19/1997 : Add new CPP interface.	[KotaroY]						 **
**  Sep./02/1997 : Rewrite. True object-based architecture.	[KotaroY]		 **
**																			 **
******************************************************************************/

#ifndef __IMESHARE_H__
#define __IMESHARE_H__

#include <windows.h>

#ifdef IMESHARE_CPL
#include "resource.h"
#endif

#define IMECDECL __cdecl
#define IMESHAREAPI  __declspec( dllimport )

typedef WORD	LID;


#define UINTIMEBOGUS 0xffffffff


#define IMESATTR_MIN					0
#define IMESATTR_INPUT 					ATTR_INPUT
#define IMESATTR_TARGET_CONVERTED		ATTR_TARGET_CONVERTED
#define	IMESATTR_CONVERTED				ATTR_CONVERTED
#define IMESATTR_TARGET_NOTCONVERTED	ATTR_TARGET_NOTCONVERTED
#define IMESATTR_INPUT_ERROR			ATTR_INPUT_ERROR
#define IMESATTR_FIXEDCONVERTED			5
#define IMESATTR_MAX					5
#define CATR (IMESATTR_MAX - IMESATTR_MIN + 1)


#define IMESTY_UL_MIN				2002
#define IMESTY_UL_NONE				2002
#define	IMESTY_UL_SINGLE			2003
//OLD #define IMESTY_UL_DOUBLE			2004
#define IMESTY_UL_DOTTED			2005
#define IMESTY_UL_THICK				2006
//OLD #define IMESTY_UL_DASHLINE			2007
//OLD #define IMESTY_UL_DOTDASH			2008
//OLD #define IMESTY_UL_DOTDOTDASH		2009
//OLD #define IMESTY_UL_WAVE				2010
#define IMESTY_UL_LOWER				2011
#define IMESTY_UL_THICKLOWER		2012
#define IMESTY_UL_THICKDITHLOWER	2013
#define IMESTY_UL_DITHLOWER			2014
#define IMESTY_UL_MAX				2014
#define CIMEUL (IMESTY_UL_MAX - IMESTY_UL_MIN + 1)
				//WARNING: Based on an assumption that all IDSsty definitions id are consecutive.


//Naming convention IdstyIMEShare[return type][property][subgrouping]
#define IdstyIMEShareSubText			0x0000
#define IdstyIMEShareSubBack			0x0001
#define IdstyIMEShareSubUl				0x0002
#define IdstyIMEShareFBold				0x0100
#define IdstyIMEShareFItalic			0x0200
#define IdstyIMEShareFUl				0x0300
#define IdstyIMEShareUKul				0x0400
#define IdstyIMEShareFWinCol			0x0500
#define IdstyIMEShareFFundCol			0x0600
#define IdstyIMEShareFRGBCol			0x0700
#define IdstyIMEShareFSpecCol			0x0800
#define IdstyIMEShareRGBCol				0x0900
#define IdstyIMEShareFSpecColText		0x0a00
#define IdstyIMEShareFSpecColWindow		0x0b00

#ifdef IMESHARE_CPL
#define IdstyIMEShareUSpecColId			0x0c00
#define IdstyIMEShareUWinColId			0x0d00
#define IdstyIMEShareUFundColId			0x0e00
#define IdstyIMEShareGrfSty				0x0f00
#endif	// IMESHARE_CPL

#define COLOR_RGB  0	  //RGB()
#define COLOR_WIN  1	  //Windows' color scheme.
#define COLOR_FUND 2	  //one of 16 fundamental color
#define COLOR_SPEC 3	  //special color.


#ifdef IMESHARE_CPL
#define STY_PLAIN					IDS_STYPLAIN
#define	STY_BOLD					IDS_STYBOLD
#define STY_ITALIC					IDS_STYITALIC

#define IMECOL_SPEC_MIN				IDS_COLAPPTEXT
#define IMECOL_APPTEXT					IDS_COLAPPTEXT
#define IMECOL_APPWINDOW				IDS_COLAPPWINDOW
#define IMECOL_SPEC_MAX				IDS_COLAPPWINDOW + 1
#define COL_FUND_MIN				IDS_COLBLACK
#define COL_BLACK					IDS_COLBLACK
#define COL_BLUE					IDS_COLBLUE
#define COL_CYAN					IDS_COLCYAN
#define COL_GREEN					IDS_COLGREEN
#define COL_MAGENTA					IDS_COLMAGENTA
#define COL_RED						IDS_COLRED
#define COL_YELLOW					IDS_COLYELLOW
#define COL_WHITE					IDS_COLWHITE
#define COL_DKBLUE					IDS_COLDKBLUE
#define COL_DKCYAN					IDS_COLDKCYAN
#define COL_DKGREEN					IDS_COLDKGREEN
#define COL_DKMAGENTA				IDS_COLDKMAGENTA
#define COL_DKRED					IDS_COLDKRED
#define COL_DKYELLOW				IDS_COLDKYELLOW
#define COL_DKGRAY					IDS_COLDKGRAY
#define COL_LTGRAY					IDS_COLLTGRAY
#define COL_FUND_MAX				IDS_COLLTGRAY + 1

#define COL_WIN_MIN					IDS_COLSCROLLBAR
#define COL_WIN_SCROLLBAR 			IDS_COLSCROLLBAR
#define COL_WIN_BACKGROUND			IDS_COLBACKGROUND
#define COL_WIN_ACTIVECAPTION		IDS_COLACTIVECAPTION
#define COL_WIN_INACTIVECAPTION		IDS_COLINACTIVECAPTION
#define COL_WIN_MENU				IDS_COLMENU
#define COL_WIN_WINDOW				IDS_COLWINDOW
#define COL_WIN_WINDOWFRAME			IDS_COLWINDOWFRAME
#define COL_WIN_MENUTEXT			IDS_COLMENUTEXT
#define COL_WIN_WINDOWTEXT			IDS_COLWINDOWTEXT
#define COL_WIN_CAPTIONTEXT			IDS_COLCAPTIONTEXT
#define COL_WIN_ACTIVEBORDER		IDS_COLACTIVEBORDER
#define COL_WIN_INACTIVEBORDER		IDS_COLINACTIVEBORDER
#define COL_WIN_APPWORKSPACE		IDS_COLAPPWORKSPACE
#define COL_WIN_HIGHLIGHT			IDS_COLHIGHLIGHT
#define COL_WIN_HIGHLIGHTTEXT		IDS_COLHIGHLIGHTTEXT
#define COL_WIN_BTNFACE				IDS_COLBTNFACE
#define COL_WIN_BTNSHADOW			IDS_COLBTNSHADOW
#define COL_WIN_GRAYTEXT			IDS_COLGRAYTEXT
#define COL_WIN_BTNTEXT				IDS_COLBTNTEXT
#define COL_WIN_INACTIVECAPTIONTEXT	IDS_COLINACTIVECAPTIONTEXT
#define COL_WIN_SHADOW				IDS_COLSHADOW
#define COL_WIN_BTNHIGHLIGHT		IDS_COLBTNHIGHLIGHT
#define COL_WIN_BTNDKSHADOW			IDS_COLBTNDKSHADOW
#define COL_WIN_BTNLIGHT			IDS_COLBTNLIGHT
#define COL_WIN_INFOTEXT			IDS_COLINFOTEXT
#define COL_WIN_INFOWINDOW			IDS_COLINFOWINDOW
#define COL_WIN_MAC					COL_WIN_INFOWINDOW + 1

#define RGB_BLACK	(RGB(  0,  0,  0))
#define RGB_BLUE	(RGB(  0,  0,255))
#define RGB_CYAN	(RGB(  0,255,255))
#define RGB_GREEN   (RGB(  0,255,  0))
#define RGB_MAGENTA (RGB(255,  0,255))
#define RGB_RED		(RGB(255,  0,  0))
#define RGB_YELLOW  (RGB(255,255,  0))
#define RGB_WHITE   (RGB(255,255,255))
#define RGB_DKBLUE  (RGB(  0,  0,127))
#define RGB_DKCYAN  (RGB(  0,127,127))
#define RGB_DKGREEN (RGB(  0,127,  0))
#define RGB_DKMAGENTA (RGB(127,  0,127))
#define RGB_DKRED   (RGB(127,  0,  0))
#define RGB_DKYELLOW (RGB(127,127,  0))
#define RGB_DKGRAY  (RGB(127,127,127))
#define RGB_LTGRAY  (RGB(192,192,192))

#endif	// IMESHARE_CPL


typedef struct {
	union {
		UINT grfsty;
		struct {
			UINT	fBold:1;
			UINT	fItalic:1;
			UINT	fUl:1;
			UINT	idUl:(sizeof(UINT) * 8 - 3);
		};
	};
} GRFSTY;




#ifdef __cplusplus

class CIMEShare{
public:
	virtual void	IMECDECL CustomizeIMEShare()=0;
	virtual BOOL	IMECDECL FSupportSty(UINT sty, UINT styAltered)=0;
	virtual LID		IMECDECL LidSetLid(LID lid)=0;
	virtual LID		IMECDECL LidGetLid(void)=0;
	virtual DWORD	IMECDECL DwGetIMEStyle(const UINT attr, const UINT idsty)=0;
	virtual BOOL	IMECDECL FDeleteIMEShare(void)=0;
	virtual DWORD	IMECDECL DwGetIMEStyleCpl(const UINT attr, const UINT idsty)=0;
	virtual BOOL	IMECDECL FSetIMEStyleCpl(const UINT attr, const UINT idsty, DWORD dwval)=0;
	virtual BOOL	IMECDECL FSaveIMEShareCpl(void)=0;
};

#else  //!__cplusplus

typedef struct _CIMEShare CIMEShare;

typedef struct _CIMEShareVtbl{
	void (IMECDECL *CustomizeIMEShare)(CIMEShare *This);
	BOOL (IMECDECL *FSupportSty)(CIMEShare *This, UINT sty, UINT styAlered);
	unsigned short (IMECDECL *LidSetLid)(CIMEShare *This, unsigned short lid);
    unsigned short (IMECDECL *LidGetLid)(CIMEShare *This);
	DWORD (IMECDECL *DwGetIMEStyle)(CIMEShare *This, UINT attr, UINT idsty);
	BOOL (IMECDECL *FDeleteIMEShare)(CIMEShare *This);

	DWORD (IMECDECL *DwGetIMEStyleCpl)(CIMEShare *This, UINT attr, UINT idsty);
	BOOL (IMECDECL *FSetIMEStyleCpl)(CIMEShare *This, UINT attr, UINT idsty, DWORD dwVal);
	BOOL (IMECDECL *FSaveIMEShareCpl)(CIMEShare *This);
} CIMEShareVtbl;

typedef struct _CIMEShare{
	const CIMEShareVtbl *lpVtbl;
} CIMEShare;

#endif //__cplusplus


#ifdef __cplusplus
extern "C"{
#endif
CIMEShare * IMECDECL PIMEShareCreate();
typedef CIMEShare * (IMECDECL FNPIMESHARECREATE)(void);
#ifdef __cplusplus
}
#endif




#ifdef OBSOLETE

typedef struct {
	UINT colorId;
	union {
		COLORREF	rgb;
		UINT		colorWin;
		UINT		colorSpec;
		UINT		colorFund;
	};
} IMECOLORSTY;

typedef struct {
	union {
		GRFSTY	grfsty;
		struct {
			UINT	fBold:1;
			UINT	fItalic:1;
			UINT	fUl:1;
			UINT	idUl:(sizeof(UINT) * 8 - 3);
		};
	};

	union {
		IMECOLORSTY colorstyText;
		struct {
			UINT	colorIdText;
			union {
				COLORREF	rgbText;
				UINT		colorWinText;
				UINT		colorSpecText;
				UINT		colorFundText;
			};
		};
	};

	union {
		IMECOLORSTY colorstyBack;
		struct {
			UINT	colorIdBack;
			union {
				COLORREF	rgbBack;
				UINT		colorWinBack;
				UINT		colorSpecBack;
				UINT		colorFundBack;
			};
		};
	};

	union {
		IMECOLORSTY colorstyUl;
		struct {
			UINT	colorIdUl;
			union {
				COLORREF	rgbUl;
				UINT		colorWinUl;
				UINT		colorSpecUl;
				UINT		colorFundUl;
			};
		};
	};
} IMESTYLE;

#ifdef __cplusplus
extern "C"{
#endif
//Functions

#if 0	// no need to redefine DllMain.
#ifndef PEGASUS
IMESHAREAPI BOOL	WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
#endif
#endif

IMESHAREAPI BOOL	IMECDECL FInitIMEShare();
IMESHAREAPI void	IMECDECL CustomizeIMEShare();
IMESHAREAPI void	IMECDECL EndIMEShare();

// Multilingual support
LID IMECDECL LidGetLid(void);
LID IMECDECL LidSetLid(LID NewValue);

//Refresh notify support
IMESHAREAPI BOOL	IMECDECL FRefreshStyle();

//substitution
IMESHAREAPI BOOL	IMECDECL FSupportSty(UINT sty, UINT styAltered);

//style handling                            
IMESHAREAPI const IMESTYLE * IMECDECL PIMEStyleFromAttr(const UINT attr);
IMESHAREAPI const IMECOLORSTY * IMECDECL PColorStyleTextFromIMEStyle(const IMESTYLE * pimestyle);
IMESHAREAPI const IMECOLORSTY * IMECDECL PColorStyleBackFromIMEStyle(const IMESTYLE * pimestyle);
#define PIMESTY(x) (PIMEStyleFromAttr(x))
#define PTEXTIMECOL(x) (PColorStyleTextFromIMEStyle(PIMESTY(x)))
#define PBACKIMECOL(x) (PColorStyleBackFromIMEStyle(PIMESTY(x)))
IMESHAREAPI BOOL	IMECDECL FBoldIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI BOOL	IMECDECL FItalicIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI BOOL	IMECDECL FUlIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI UINT	IMECDECL IdUlIMEStyle(const IMESTYLE *pimestyle);

//color handling
IMESHAREAPI BOOL	IMECDECL FWinIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FFundamentalIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FRGBIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FSpecialIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FSpecialTextIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FSpecialWindowIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI COLORREF	IMECDECL RGBFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);

#ifdef IMESHARE_CPL
IMESHAREAPI UINT	IMECDECL IdSpecialFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI UINT	IMECDECL IdWinFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI UINT	IMECDECL IdFundamentalFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI GRFSTY	IMECDECL GrfStyIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI BOOL	IMECDECL FGetIMEStyleAttr(IMESTYLE *pimestyle, const UINT attr);
IMESHAREAPI BOOL	IMECDECL FSetIMEStyleAttr(const IMESTYLE *pimestyle, const UINT attr);
IMESHAREAPI BOOL	IMECDECL FSetIMEColorStyle(UINT attr, BOOL fTextCol, UINT id, DWORD col);
IMESHAREAPI BOOL	IMECDECL FSetIMEStyle(const UINT attr, BOOL fBold, BOOL fItalic, BOOL fUl, UINT idUl);
IMESHAREAPI BOOL	IMECDECL FSaveIMEShareSetting(void);
#endif // IMESHARE_CPL
#ifdef __cplusplus
}
#endif
#endif // OBSOLETE


#endif	// __IMESHARE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc30\imeapp.h ===
//
//	%%Title: IMEAPP
//	%%Unit: COM
//	%%Contact: TakeshiF/SeijiA
//	%%Date: 97/06/20
//	%%File: imeapp.h
//
//	Private API / Message service
//

#ifndef __IMEUP_H__
#define __IMEUP_H__

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#include "actdict.h"

//// START

/***********************************************************************
	Msg:	WM_MSIME_SERVICE
	Desc: 	service functions
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_SERVICE		TEXT("MSIMEService")

#define	VERSION_ID_JAPAN	0x01000000
#define	VERSION_ID_KOREA	0x02000000
#define	VERSION_ID_TC		0x04000000
#define	VERSION_ID_PRC		0x08000000

#define	VERSION_ID_IMEJP98	(VERSION_ID_JAPAN | 0x980)
#define	VERSION_ID_IMEJP98A	(VERSION_ID_JAPAN | 0x98a)


/***********************************************************************
	Msg:	WM_MSIME_AUTOCOMPLETE
	Desc: 	use IImeActiveDict to support auto-complete
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_AUTOCOMPLETE 		TEXT("MSIMEAutoComplete")

// AutoComplete Version
#define VERSION_AUTOCOMPETE		1

// Dictionary Structure
typedef struct _IMEDICT
{
	int				cbSize;			//size of this structure
	HIMC			hIMC;			//IME context
	IImeActiveDict	*pdict;			//program dictionary
} IMEDICT;

//WParam definition
#define FID_AUTO_VERSION		1
#define FID_AUTO_ACTIVATE		2
#define FID_AUTO_DEACTIVATE		3


/***********************************************************************
	Msg:	WM_MSIME_WORDSTAT
	Desc: 	use IImeActiveDict to get word statistics
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_WORDSTAT 		TEXT("MSIMEWordStatistics")

// WordStat Version
#define VERSION_WORDSTAT		1

// WParam definition
#define FID_STAT_VERSION		1
#define FID_STAT_GIVESTAT		2


/***********************************************************************
	Msg:	WM_MSIME_DOCKDICT
	Desc: 	use IImeActiveDict to dock dictionary
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_DOCKDICT 		TEXT("MSIMEDockActiveDict")

// Dictionary Docking Version
#define VERSION_DOCKDICT		1

// WParam definition
#define FID_DOCK_VERSION		1
#define FID_DOCK_ACTIVATE		2
#define FID_DOCK_DEACTIVATE		3


/***********************************************************************
	Msg:	WM_MSIME_MOUSE
	Desc: 	mouse operation definition                
	Owner: 	kentu				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_MOUSE 		TEXT("MSIMEMouseOperation")

// Mouse Operation Version (return value of IMEMOUSE_VERSION)
#define VERSION_MOUSE_OPERATION		1

// Mouse operation result
#define IMEMOUSERET_NOTHANDLED		(-1)

//WParam definition for WM_IME_MOUSE.
#define IMEMOUSE_VERSION	0xff	// mouse supported?

#define IMEMOUSE_NONE		0x00	// no mouse button was pushed
#define IMEMOUSE_LDOWN		0x01
#define IMEMOUSE_RDOWN		0x02
#define IMEMOUSE_MDOWN		0x04
#define IMEMOUSE_WUP		0x10	// wheel up
#define IMEMOUSE_WDOWN		0x20	// wheel down


/***********************************************************************
	Msg:	WM_MSIME_RECONVERT/WM_MSIME_RECONVERTREQUEST
	Desc: 	reconversion
	Owner: 	takeshif				
 ***********************************************************************/

// wParam of WM_MSIME_RECONVERTREQUEST
#define FID_RECONVERT_VERSION	0x10000000

// Private reconversion Version
#define VERSION_RECONVERSION		1

// Label for RegisterWindowMessage
#define	RWM_RECONVERT			TEXT("MSIMEReconvert")
#define	RWM_RECONVERTREQUEST	TEXT("MSIMEReconvertRequest")

/***********************************************************************
	Msg:	WM_MSIME_DOCUMENTFEED
	Desc: 	reconversion
	Owner: 	takeshif				
	Usage: SendMessage( hwndApp, WM_MSIME_DOCUMENTFEED, VERSION_DOCUMENTFEED,
				(RECONVERTSTRING*)pReconv );
	wParam: VERSION_DOCUMENTFEED
	lParam: Pointer of RECONVERTSTRING structure
	return: size of RECONVERTSTRING structure
 ***********************************************************************/

// wParam of WM_MSIME_DOCUMENTFEED (set current docfeed version)
#define VERSION_DOCUMENTFEED		1

// lParam is pointer of RECONVERTSTRING structure

// Label for RegisterWindowMessage
#define	RWM_DOCUMENTFEED	TEXT("MSIMEDocumentFeed")

/***********************************************************************
	Msg:	WM_MSIME_QUERYHIDECARET
	Desc: 	composition UI
	Owner: 	takeshif				
	Usage: SendMessage( hwndDefUI, WM_MSIME_QUERYHIDECARET, 0, 0 );
	wParam: reserved
	lParam: reserved
	return: Non-zero = shows caret. Zero = hide caret.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYHIDECARET
#define VERSION_QUERYHIDECARET		1

// Label for RegisterWindowMessage
#define	RWM_QUERYHIDECARET	TEXT("MSIMEQueryHideCaret")

/***********************************************************************
	Msg:	WM_MSIME_QUERYPOSITION
	Desc: 	composition UI
	Owner: 	takeshif				
	Usage: SendMessage( hwndApp, WM_MSIME_QUERYPOSITION, 0, (IMEPOSITION*)pPs );
	wParam: reserved. must be 0.
	lParam: pointer of IMEPOSITION structure
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYPOSITION
#define VERSION_QUERYPOSITION		1

// Label for RegisterWindowMessage
#define	RWM_QUERYPOSITION	TEXT("MSIMEQueryPosition")


/***********************************************************************
	Msg:	WM_MSIME_MODEBIAS
	Desc: 	input mode bias
	Owner: 	takeshif
	Usage: SendMessage( hwndDefUI, WM_MSIME_MODEBIAS, MODEBIAS_xxxx, 0 );
	wParam: see below MODEBIAS_xxxx
	lParam: reserved
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_MODEBIAS			TEXT("MSIMEModeBias")

// wParam - bias setting
#define MODEBIAS_DEFAULT				0x00000000	// reset all of bias setting
#define MODEBIAS_FILENAME				0x00000001
#define MODEBIAS_URL					0x00000002
#define MODEBIAS_DISABLEAUTOCONV		0x00000010


/***********************************************************************
	Msg:	WM_MSIME_SHOWIMEPAD
	Desc: 	show ImePad
	Owner: 	toshiaK
	Usage: SendMessage( hwndDefUI, WM_MSIME_SHOWIMEPAD, 0, 0 );
	wParam: reserved
	lParam: reserved
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_SHOWIMEPAD			TEXT("MSIMEShowImePad")


/***********************************************************************
	Msg:	WM_MSIME_KEYMAP
	Desc: 	key map sharing with apps
	Owner: 	HiroakiK
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_KEYMAP				TEXT("MSIMEKeyMap")
#define	RWM_CHGKEYMAP			TEXT("MSIMEChangeKeyMap")
#define	RWM_NTFYKEYMAP			TEXT("MSIMENotifyKeyMap")


#define FID_MSIME_KMS_VERSION		1
#define FID_MSIME_KMS_INIT			2
#define FID_MSIME_KMS_TERM			3
#define FID_MSIME_KMS_DEL_KEYLIST	4
#define FID_MSIME_KMS_NOTIFY		5
#define FID_MSIME_KMS_GETMAP		6
#define FID_MSIME_KMS_INVOKE		7
#define FID_MSIME_KMS_SETMAP		8



#define IMEKMS_NOCOMPOSITION        0
#define IMEKMS_COMPOSITION          1
#define IMEKMS_SELECTION            2
#define IMEKMS_IMEOFF               3
#define IMEKMS_2NDLEVEL             4
#define IMEKMS_INPTGL               5



typedef struct tagIMEKMSINIT {
	INT			cbSize;
	HWND		hWnd;	// Window which receives notification from IME.
						// If hWnd is NULL, no notification is posted
						// to Input context.
} IMEKMSINIT;


typedef struct tagIMEKMSKEY {
	DWORD dwStatus;		//Shift-Control combination status.
						//Any combination of constants below
						//(defined in IMM.H)
						// 0x0000 (default)
						// MOD_CONTROL     0x0002
						// MOD_SHIFT       0x0004
						// Alt key and Win key is not processed by IME. 
	
	DWORD dwCompStatus;	//Composition string status
						//One of the constants below
						// IMEKMS_NOCOMPOSITION  No composition string      
						// IMEKMS_COMPOSITION    Some composition string
						// IMEKMS_SELECTION      Selection exists in apps
						// IMEKMS_IMEOFF         IME Off state
						// IMEKMS_2NDLEVEL       2nd stage on 2 stroke key operation
						
	
	DWORD dwVKEY;		// VKEY code defined in IMM.H
	union {
		DWORD dwControl;// IME Functionality ID
		DWORD dwNotUsed;
	};
	union {
		WCHAR pwszDscr[31];// The pointer to string of description of this functionalify
		WCHAR pwszNoUse[31];
	};
} IMEKMSKEY;

typedef struct tagIMEKMS {
	INT			cbSize;
	HIMC		hIMC;
	LANGID		idLang;
	DWORD		cKeyList;
	IMEKMSKEY	*pKeyList;
} IMEKMS;

typedef struct tagIMEKMSNTFY {
	INT			cbSize;
	HIMC		hIMC;
	BOOL		fSelect;
} IMEKMSNTFY;

typedef struct tagIMEKMSKMP {
	INT			cbSize;			//[in] size of this structure
	HIMC		hIMC;			//[in] Input context
	WORD		wVKStart;		//[in] VKEY start
	WORD		wVKEnd;			//[in] VKEY end
	INT			cKeyList;		//[out] number of IMEKMSKEY
	IMEKMSKEY	*pKeyList;		//[out] retrieve buffer of IMEKMSKEY
								//      Must be GlobalMemFree by clients
} IMEKMSKMP;

typedef struct tagIMEKMSINVK {
	INT			cbSize;
	HIMC		hIMC;
	DWORD		dwControl;
} IMEKMSINVK;


//// END

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif	// __cplusplus


#endif // __IMEUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\published\usp10.h ===
/*++

   Copyright (c) Microsoft Corporation. All rights reserved.

*/

#ifndef __usp10__
#define __usp10__
#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#ifdef __cplusplus
extern "C" {
#endif


///// Uniscribe build number

#define USPBUILD 0400



/////   USP - Unicode Complex Script processor
//
//      Copyright (c) Microsoft Corporation. All rights reserved.




/////   SCRIPT
//
//      The SCRIPT enum is an opaque type used internally to identify
//      which shaping engine functions are used to process a given run.
//
//
#define SCRIPT_UNDEFINED  0
//
//p     SCRIPT_UNDEFINED: This is the only public script ordinal. May be
//      forced into the eScript field of a SCRIPT_ANALYSIS to disable shaping.
//      SCRIPT_UNDEFINED is supported by all fonts - ScriptShape will display
//      whatever glyph is defined in the font CMAP table, or, if none, the
//      missing glyph.







/////   USP Status Codes
//
#define USP_E_SCRIPT_NOT_IN_FONT   \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_ITF,0x200)    // Script doesn't exist in font






/////   SCRIPT_CACHE
//
//      Many script APIs take a combination of HDC and SCRIPT_CACHE parameter.
//
//      A SCRIPT_CACHE is an opaque pointer to a Uniscribe font metric cache
//      structure.


typedef void *SCRIPT_CACHE;


//      The client must allocate and retain one SCRIPT_CACHE variable for each
//      character style used. It must be initialised by the client to NULL.
//
//      APIs are passed an HDC and the address of a SCRIPT_CACHE variable.
//      Uniscribe will first attempt to access font data via the SCRIPT_CACHE
//      and will only inspect the HDC if the required data is not already
//      cached.
//
//      The HDC may be passed as NULL. If data required by Uniscribe is
//      already cached, the HDC won't be accessed and operation continues
//      normally.
//
//      If the HDC is passed as NULL, and Uniscribe needs to access it for
//      any reason, Uniscribe will return E_PENDING.
//
//      E_PENDING is returned quickly, allowing the client to avoid time
//      consuming SelectObject calls. The following example applies to all
//      APIs that take a SCRIPT_CACHE and an optional HDC.
//
//c     hr = ScriptShape(NULL, &sc, ..);
//c     if (hr == E_PENDING) {
//c         ... select font into hdc ...
//c         hr = ScriptShape(hdc, &sc, ...);
//c     }






/////   ScriptFreeCache
//
//      The client may free a SCRIPT_CACHE at any time. Uniscribe maintains
//      reference counts in it's font and shaper caches, and frees font data
//      only when all sizes of the font are free, and shaper data only when
//      all fonts it supports are freed.
//
//      The client should free the SCRIPT_CACHE for a style when it discards
//      that style.
//
//      ScriptFreeCache always sets it's parameter to NULL to help avoid
//      mis-referencing.


HRESULT WINAPI ScriptFreeCache(
    SCRIPT_CACHE   *psc);       //InOut  Cache handle






/////   SCRIPT_CONTROL
//
//      The SCRIPT_CONTROL structure provides itemization control flags to the
//      ScriptItemize function.
//
//
typedef struct tag_SCRIPT_CONTROL {
    DWORD   uDefaultLanguage    :16; // For NADS, also default for context
    DWORD   fContextDigits      :1;  // Means use previous script instead of uDefaultLanguage

    // The following flags provide legacy support for GetCharacterPlacement features
    DWORD   fInvertPreBoundDir  :1;  // Reading order of virtual item immediately prior to string
    DWORD   fInvertPostBoundDir :1;  // Reading order of virtual item immediately following string
    DWORD   fLinkStringBefore   :1;  // Equivalent to presence of ZWJ before string
    DWORD   fLinkStringAfter    :1;  // Equivalent to presence of ZWJ after string
    DWORD   fNeutralOverride    :1;  // Causes all neutrals to be strong in the current embedding direction
    DWORD   fNumericOverride    :1;  // Causes all numerals to be strong in the current embedding direction
    DWORD   fLegacyBidiClass    :1;  // Causes plus and minus to be reated as neutrals, slash as a common separator
    DWORD   fReserved           :8;
} SCRIPT_CONTROL;
//
//
//p     uDefaultLanguage: Language to use when Unicode values are ambiguous.
//              Used by numeric processing to select digit shape when
//              fDigitSubstitute (see SCRIPT_STATE) is in force.
//
//p     fContextDigits: Specifies that national digits are chosen according to
//              the nearest previous strong text, rather than using
//              uDefaultLanguage.
//
//p     fInvertPreBoundDir: By default text at the start of the string is
//              laid out as if it follows strong text of the same direction
//              as the base embedding level. Set fInvertPreBoundDir to change
//              the initial context to the opposite of the base embedding
//              level. This flag is for GetCharacterPlacement legacy support.
//
//p     fInvertPostBoundDir: By default text at the end of the string is
//              laid out as if it preceeds strong text of the same direction
//              as the base embedding level. Set fInvertPostBoundDir to change
//              the final context to the opposite of the base embedding
//              level. This flag is for GetCharacterPlacement legacy support.
//
//p     fLinkStringBefore: Causes the first character of the string to be
//              shaped as if were joined to a previous character.
//
//p     fLinkStringAfter: Causes the last character of the string to be
//              shaped as if were joined to a following character.
//
//p     fNeutralOverride: Causes all neutral characters in the string to be
//              treated as if they were strong characters of their enclosing
//              embedding level. This effectively locks neutrals in place,
//              reordering occuring only between neutrals.
//
//p     fNumericOverride: Causes all numeric characters in the string to be
//              treated as if they were strong characters of their enclosing
//              embedding level. This effectively locks numerics in place,
//              reordering occuring only between numerics.
//
//p     fReserved: Reserved. Always initialise to 0.






/////   SCRIPT_STATE
//
//      The SCRIPT_STATE structure is used both to initialise the unicode
//      algorithm state as an input parameter to ScriptItemize, and is also
//      a component of each item analysis returned by ScriptItemize.
//
//
typedef struct tag_SCRIPT_STATE {
    WORD    uBidiLevel         :5;  // Unicode Bidi algorithm embedding level (0-16)
    WORD    fOverrideDirection :1;  // Set when in LRO/RLO embedding
    WORD    fInhibitSymSwap    :1;  // Set by U+206A (ISS), cleared by U+206B (ASS)
    WORD    fCharShape         :1;  // Set by U+206D (AAFS), cleared by U+206C (IAFS)
    WORD    fDigitSubstitute   :1;  // Set by U+206E (NADS), cleared by U+206F (NODS)
    WORD    fInhibitLigate     :1;  // Equiv !GCP_Ligate, no Unicode control chars yet
    WORD    fDisplayZWG        :1;  // Equiv GCP_DisplayZWG, no Unicode control characters yet
    WORD    fArabicNumContext  :1;  // For EN->AN Unicode rule
    WORD    fGcpClusters       :1;  // For Generating Backward Compatible GCP Clusters (legacy Apps)
    WORD    fReserved          :1;
    WORD    fEngineReserved    :2;  // For use by shaping engine
} SCRIPT_STATE;
//
//
//p     uBidiLevel: The embedding level associated with all characters in this
//              run according to the Unicode bidi algorithm. When passed to
//              ScriptItemize, should be initialised to 0 for an LTR base
//              embedding level, or 1 for RTL.
//
//p     fOverrideDirection: TRUE if this level is an override level (LRO/RLO).
//              In an override level, characters are layed out purely
//              left to right, or purely right to left. No reordering of digits
//              or strong characters of opposing direction takes place.
//              Note that this initial value is reset by LRE, RLE, LRO or
//              RLO codes in the string.
//
//p     fInhibitSymSwap: TRUE if the shaping engine is to bypass mirroring of
//              Unicode Mirrored glyphs such as brackets. Set by Unicode
//              character ISS, cleared by ASS.
//
//p     fCharShape: TRUE if character codes in the Arabic Presentation Forms
//              areas of Unicode should be shaped. (Not implemented).
//
//p     fDigitSubstitute: TRUE if character codes U+0030 through U+0039
//              (European digits) are to be substituted by national digits.
//              Set by Unicode NADS, Cleared by NODS.
//
//p     fInhibitLigate: TRUE if ligatures are not to be used in the shaping
//              of Arabic or Hebrew characters.
//
//p     fDisplayZWG: TRUE if control characters are to be shaped as
//              representational glyphs. (Normally, control characters are
//              shaped to the blank glyph and given a width of zero).
//
//p     fArabicNumContext: TRUE indicates prior strong characters were Arabic
//              for the purposes of rule P0 on page 3-19 of 'The Unicode
//              Standard, version 2.0'. Should normally be set TRUE before
//              itemizing an RTL paragraph in an Arabic language, FALSE
//              otherwise.
//
//p     fGcpClusters: For GetCharaterPlacement legacy support only.
//              Initialise to TRUE to request ScriptShape to generate
//              the LogClust array the same way as GetCharacterPlacement
//              does in Arabic and Hebrew Windows95. Affects only Arabic
//              and Hebrew items.
//
//p     fReserved: Reserved. Always initialise to 0.
//
//p     fEngineReserved: Reserved. Always initialise to 0.






/////   SCRIPT_ANALYSIS
//
//      Each analysed item is described by a SCRIPT_ANALYSIS structure.
//      It also includes a copy of the Unicode algorithm state (SCRIPT_STATE).
//
//
typedef struct tag_SCRIPT_ANALYSIS {
    WORD    eScript         :10;    // Shaping engine
    WORD    fRTL            :1;     // Rendering direction
    WORD    fLayoutRTL      :1;     // Set for GCP classes ARABIC/HEBREW and LOCALNUMBER
    WORD    fLinkBefore     :1;     // Implies there was a ZWJ before this item
    WORD    fLinkAfter      :1;     // Implies there is a ZWJ following this item.
    WORD    fLogicalOrder   :1;     // Set by client as input to ScriptShape/Place
    WORD    fNoGlyphIndex   :1;     // Generated by ScriptShape/Place - this item does not use glyph indices
    SCRIPT_STATE s;
} SCRIPT_ANALYSIS;
//
//
//p     eScript: Opaque value identifying which engine Uniscribe will use to
//              Shape, Place and TextOut this item. The value of eScript is
//              undefined, and will change in future releases, but attributes
//              of eScript may be obtained by calling ScriptGetProperties.
//
//p     fRTL: Rendering direction. Normally identical to the parity of the
//              Unicode embedding level, but may differ if overridden by
//              GetCharacterPlacement legacy support.
//
//p     fLayoutRTL: Logical direction - whether conceptually part of a
//              left-to-right sequenece or a right-to-left sequence. Although
//              this is usually the same as fRTL, for a number in a
//              right-to-left run, fRTL is False (because digits are always
//              displayed LTR), but fLayoutRTL is True (because the number is
//              read as part of the right-to-left sequence).
//
//p     fLinkBefore: If set, the shaping engine will shape the first character
//              of this item as if it were joining with a previous character.
//              Set by ScriptItemize, may be overriden before calling ScriptShape.
//
//p     fLinkAfter: If set, the shaping engine will shape the last character
//              of this item as if it were joining with a subsequient character.
//              Set by ScriptItemize, may be overriden before calling ScriptShape.
//
//p     fLogicalOrder: If set, the shaping engine will generate all glyph
//              related arrays in logical order. By default glyph related
//              arrays are in visual order, the first array entry corresponding
//              to the leftmost glyph.
//              Set to FALSE by ScriptItemize, may be overriden before calling
//              ScriptShape.
//
//p     fNoGlyphIndex: May be set TRUE on input to ScriptShape to disable use
//              of glyphs for this item. Additionally, ScriptShape will set it
//              TRUE for hdcs containing symbolic, unrecognised and device fonts.
//              Disabling glyphing disables complex script shaping. When set,
//              shaping and placing for this item is implemented directly by
//              calls to GetTextExtentExPoint and ExtTextOut.
/////   SCRIPT_ITEM
//
//      The SCRIPT_ITEM structure includes a SCRIPT_ANALYSIS with the string
//      ofset of the first character of the item.
//
//
typedef struct tag_SCRIPT_ITEM {
    int              iCharPos;      // Logical offset to first character in this item
    SCRIPT_ANALYSIS  a;
} SCRIPT_ITEM;
//
//
//p     iCharPos: Offset from beginning of itemised string to first character
//              of this item, counted in Unicode codepoints (i.e. words).
//
//p     a: Script analysis structure containing analysis specific to this
//              item, to be passed to ScriptShape, ScriptPlace etc.






/////   ScriptItemize - break text into items
//
//      Breaks a run of unicode into individually shapeable items.
//      Items are delimited by
//
//      o Change of shaping engine
//      o Change of direction
//
//      The client may create multiple runs from each item returned by
//      ScriptItemize, but should not combine multiple items into a single run.
//
//      Later the client will call ScriptShape for each run (when measuring or
//      rendering), and must pass the SCRIPT_ANALYSIS that ScriptItemize
//      returned.


HRESULT WINAPI ScriptItemize(
    const WCHAR           *pwcInChars,  // In   Unicode string to be itemized
    int                    cInChars,    // In   Codepoint count to itemize
    int                    cMaxItems,   // In   Max length of itemization array
    const SCRIPT_CONTROL  *psControl,   // In   Analysis control (optional)
    const SCRIPT_STATE    *psState,     // In   Initial bidi algorithm state (optional)
    SCRIPT_ITEM           *pItems,      // Out  Array to receive itemization
    int                   *pcItems);    // Out  Count of items processed (optional)






/////
//
//
//      Returns E_INVALIDARG if pwcInChars == NULL or cInChars == 0
//          or pItems == NULL or cMaxItems < 2.
//
//      Returns E_OUTOFMEMORY if the output buffer length (cMaxItems) is
//          insufficient. Note that in this case, as in all error cases, no
//          items have been fully processed so no part of the output array
//          contains defined values.
//
//      If psControl and psState are NULL on entry, ScriptItemize
//      breaks the unicode string purely by character code.  If they are all
//      non-null, it performs a full Unicode bidi analysis.
//
//      ScriptItemize always adds a terminal item to the item analysis array
//      (pItems) such that the length of an item at pItem is always available as:
//
//c     pItem[1].iCharPos - pItem[0].iCharPos
//
//      For this reason, it is invalid to call ScriptItemize with a buffer
//      of less than two SCRIPT_ANALYSIS items.
//
//      To perform a correct Unicode Bidi analysis, the SCRIPT_STATE should
//      be initialised according to the paragraph reading order at paragraph
//      start, and ScriptItemize should be passed the whole paragraph.
//
//      fRTL and fNumeric together provide the same classification as
//      the lpClass output from GetCharacterPlacement.
//
//      European digits U+0030 through U+0039 may be rendered as national
//      digits as follows:
//
//t     fDigitSubstitute | FContextDigits | Digit shapes displayed for Unicode U+0030 through U+0039
//t     ---------------- | -------------- | ------------------------------------
//t     False            | Any            | Western (European / American) digits
//t     True             | False          | As specified in SCRIPT_CONTROL.uDefaultLanguage
//t     True             | True           | As prior strong text, defaulting to SCRIPT_CONTROL.uDefaultLanguage
//
//
//      For fContextDigits, any Western digits (U+0030 - U+0039) encountered
//      before the first strongly directed character are substituted by the
//      traditional digits of the SCRIPT_CONTROL.uDefaultLanguage when that
//      language is written in the same direction as SCRIPT_STATE.uBidiLevel.
//
//      Thus, in a right-to-left string, if SCRIPT_CONTROL.uDefaultLanguage is
//      1 (LANG_ARABIC), then leading Western digits will be substituted by
//      traditional Arabic digits.
//
//      However, also in a right-to-left string, if SCRIPT_CONTROL.uDefaultLanguage
//      is 0x1e (LANG_THAI), then no substitution occurs on leading Western
//      digits because the Thai language is written left-to-right.
//
//      Following strongly directed characters, digits are substituted
//      by the traditional digits associated with the closest prior strongly
//      directed character.
//
//      The left-to-right mark (LRM) and right-to-left mark (RLM) are strong
//      characters whose language depends on the SCRIPT_CONTROL.uDefaultLangauge.
//
//      If SCRIPT_CONTROL.uDefaultLangauge is a left-to-right langauge, then
//      LRM causes subsequent Western digits to be substituted by the
//      traditional digits associated with that language, while Western
//      digits following RLM are not substituted.
//
//      Conversly, if SCRIPT_CONTROL.uDefaultLangauge is a right-to-left
//      langauge, then Western digits following LRM are not substituted, while
//      Western digits following RLM are substituted by the traditional digits
//      associated with that language.
//
//
//
//      Effect of Unicode control characters on SCRIPT_STATE:
//
//t     SCRIPT_STATE flag | Set by | Cleared by
//t     ----------------- | ------   ----------
//t     fDigitSubstitute  |  NADS  |   NODS
//t     fInhibitSymSwap   |  ISS   |   ASS
//t     fCharShape        |  AAFS  |   IAFS
//
//      SCRIPT_STATE.fArabicNumContext controls the Unicode EN->AN rule.
//      It should normally be initialised to TRUE
//      before itemizing an RTL paragraph in an Arabic language, FALSE
//      otherwise.
/////   ScriptLayout
//
//      The ScriptLayout function converts an array of run embedding levels to
//      a map of visual to logical position, and/or logical to visual position.
//
//      pbLevel must contain the embedding levels for all runs on the line,
//      ordered logically.
//
//      On output, piVisualToLogical[0] is the logical index of the run to
//      display at the far left. Subsequent entries should be displayed
//      progressing from left to right.
//
//      piLogicalToVisual[0] is the relative visual position where the first
//      logical run should be displayed - the leftmost display position being zero.
//
//      The caller may request either piLogicalToVisual or piVisualToLogical
//      or both.
//
//      Note: No other input is required since the embedding levels give all
//      necessary information for layout.


HRESULT WINAPI ScriptLayout(
    int           cRuns,              // In   Number of runs to process
    const BYTE   *pbLevel,            // In   Array of run embedding levels
    int          *piVisualToLogical,  // Out  List of run indices in visual order
    int          *piLogicalToVisual); // Out  List of visual run positions






/////   SCRIPT_JUSTIFY
//
//      The script justification enumeration provides the client with the
//      glyph characteristic information it needs to implement justification.


typedef enum tag_SCRIPT_JUSTIFY {
    SCRIPT_JUSTIFY_NONE           = 0,   // Justification can't be applied at this glyph
    SCRIPT_JUSTIFY_ARABIC_BLANK   = 1,   // This glyph represents a blank in an Arabic run
    SCRIPT_JUSTIFY_CHARACTER      = 2,   // Inter-character justification point follows this glyph
    SCRIPT_JUSTIFY_RESERVED1      = 3,   // Reserved #1
    SCRIPT_JUSTIFY_BLANK          = 4,   // This glyph represents a blank outside an Arabic run
    SCRIPT_JUSTIFY_RESERVED2      = 5,   // Reserved #2
    SCRIPT_JUSTIFY_RESERVED3      = 6,   // Reserved #3
    SCRIPT_JUSTIFY_ARABIC_NORMAL  = 7,   // Normal Middle-Of-Word glyph that connects to the right (begin)
    SCRIPT_JUSTIFY_ARABIC_KASHIDA = 8,   // Kashida(U+640) in middle of word
    SCRIPT_JUSTIFY_ARABIC_ALEF    = 9,   // Final form of Alef-like (U+627, U+625, U+623, U+632)
    SCRIPT_JUSTIFY_ARABIC_HA      = 10,  // Final form of Ha (U+647)
    SCRIPT_JUSTIFY_ARABIC_RA      = 11,  // Final form of Ra (U+631)
    SCRIPT_JUSTIFY_ARABIC_BA      = 12,  // Middle-Of-Word form of Ba (U+628)
    SCRIPT_JUSTIFY_ARABIC_BARA    = 13,  // Ligature of alike (U+628,U+631)
    SCRIPT_JUSTIFY_ARABIC_SEEN    = 14,  // Highest priority: Initial shape of Seen(U+633) (end)
    SCRIPT_JUSTIFY_RESERVED4      = 15,  // Reserved #4
} SCRIPT_JUSTIFY;



/////   SCRIPT_VISATTR
//
//      The visual (glyph) attribute buffer generated by ScriptShape
//      identifies clusters and justification points:


typedef struct tag_SCRIPT_VISATTR {
    WORD           uJustification   :4;  // Justification class
    WORD           fClusterStart    :1;  // First glyph of representation of cluster
    WORD           fDiacritic       :1;  // Diacritic
    WORD           fZeroWidth       :1;  // Blank, ZWJ, ZWNJ etc, with no width
    WORD           fReserved        :1;  // General reserved
    WORD           fShapeReserved   :8;  // Reserved for use by shaping engines
} SCRIPT_VISATTR;
//
//
//p     uJustification: Justification class for this glyph. See SCRIPT_JUSTIFY.
//
//p     fClusterStart: Set for the logically first glyph in every cluster,
//          even for clusters containing just one glyph.
//
//p     fDiacritic: Set for glyphs that combine with base characters.
//
//p     fZeroWidth: Set by the shaping engine for some, but not all, zero
//          width characters.


/////   ScriptShape
//
//      The ScriptShape function takes a Unicode run and generates glyphs and
//      visual attributes.
//
//      The number of glyphs generated varies according to the script and the
//      font. Only for simple scripts and fonts does each Unicode code point
//      generates a single glyph.
//
//      There is no limit on the number of glyphs generated by a codepoint.
//      For example, a sophisticated complex script font might choose to
//      constuct characters from components, and so generate many times as
//      many glyphs as characters.
//
//      There are also special cases like invalid character representations,
//      where extra glyphs are added to represent the invalid sequence.
//
//      A reasonable guess might be to provide a glyph buffer 1.5 times the
//      length of the character buffer, plus a 16 glyph fixed addition for
//      rare cases like invalid sequenece representation.
//
//      If ScriptShape returns E_OUTOFMEMORY it will be necessary to recall
//      it, possibly more than once, until a large enough buffer is found.


HRESULT WINAPI ScriptShape(
    HDC                 hdc,            // In    Optional (see under caching)
    SCRIPT_CACHE       *psc,            // InOut Cache handle
    const WCHAR        *pwcChars,       // In    Logical unicode run
    int                 cChars,         // In    Length of unicode run
    int                 cMaxGlyphs,     // In    Max glyphs to generate
    SCRIPT_ANALYSIS    *psa,            // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    WORD               *pwOutGlyphs,    // Out   Output glyph buffer
    WORD               *pwLogClust,     // Out   Logical clusters
    SCRIPT_VISATTR     *psva,           // Out   Visual glyph attributes
    int                *pcGlyphs);      // Out   Count of glyphs generated






/////
//
//      Returns E_OUTOFMEMORY if the output buffer length (cMaxGlyphs) is
//          insufficient. Note that in this case, as in all error cases, the
//          content of all output parameters are undefined.
//
//p     psa: Pass the SCRIPT_ANALYSIS field of the SCRIPT_ITEM entry for this
//          item. (The SCRIPT_ITEM array is returned by ScriptItemize.)
//
//      Clusters are sequenced uniformly within the run, as are glyphs within
//      the cluster - the fRTL item flag (from ScriptItemize) identifies
//      whether left to right, or right to left.
//
//p     pwLogClust: has cChars elements - each entry in pwLogClust corresponds
//          to a character in the input string (pwcChars). The value in each
//          pwLogCLust entry is the offset of the first glyph in the cluster
//          that contains this character.
//
//      Example: In the following example, there are four clusters:
//      1st cluster: one character represented by one glyph
//      2nd cluster: one character represented by 3 glyphs
//      3rd cluster: three characters represented by one glyph
//      4th cluster: 2 characters represented by three glyphs
//
//      Glyph array: (c<n>g<m> means cluster n glyph m)
//c        0      1    2    3      4      5    6    7
//c     -------------------------------------------------
//c     | c1g1 | c2g1 c2g2 c2g3 | c3g1 | c4g1 c4g2 c4g3 |
//c     -------------------------------------------------
//
//      Character array: (c<n>u<m> means cluster n Unicode codepoint m)
//c        0      1      2    3    4      5    6
//c     --------------------------------------------
//c     | c1u1 | c2u1 | c3u1 c3u2 c3u3 | c4u1 c4u2 |
//c     --------------------------------------------
//
//      LogClust: (one entry per character gives 1st glyph in cluster
//c     --------------------------------------------
//c     |   0  |   1  |   4    4    4  |   5    5  |
//c     --------------------------------------------
//
//      Note that for an RTL run (SCRIPT_ANALYSIS.a.fRTL == TRUE) and when
//      fLogicalOrder == FALSE (the default), glyphs are generated in visual
//      order - the reverse of the codepoint order, and the values in the
//      LogClust array will be descending.
//
//
//p     psva: has one visual attribute per glyph and so has maxGlyphs entries.
//
//
//      ScriptShape may set the fNoGlyphIndex flag in psa if the font or
//      OS cannot support glyph indices.
//
//      If fLogicalOrder is requested in psa, glyphs will be always be
//      generated in the same order as the original Unicode characters.
//
//      If fLogicalOrder is not set, right to left items are generated in
//      reverse order, so ScriptTextOut does not need to reverse them before
//      calling ExtTextOut.
/////   ScriptPlace
//
//      The ScriptPlace function takes the output of a ScriptShape call and
//      generates glyph advance width and 2D offset information.
//
//      The composite ABC width for the whole item identifies how much the
//      glyphs overhang to the left of the start position and to the right of
//      the length implied by the sum of the advance widths.
//
//      The total advance width of the line is exactly abcA + abcB + abcC.
//
//      abcA and abcC are maintained internally by Uniscribe as proportions
//      of the cell height represented in 8 bits and are thus roughly +/- 1%.
//      The total width returned (as the sum of piAdvance, and as the sum of
//      abcA+abcB+abcC) is accurate to the resolution of the TrueType shaping
//      engine.
//
//      All glyph related arrays are in visual order unless the fLogicalOrder
//      flag is set in psa.


#ifndef LSDEFS_DEFINED
typedef struct tagGOFFSET {
    LONG  du;
    LONG  dv;
} GOFFSET;
#endif


HRESULT WINAPI ScriptPlace(
    HDC                     hdc,        // In    Optional (see under caching)
    SCRIPT_CACHE           *psc,        // InOut Cache handle
    const WORD             *pwGlyphs,   // In    Glyph buffer from prior ScriptShape call
    int                     cGlyphs,    // In    Number of glyphs
    const SCRIPT_VISATTR   *psva,       // In    Visual glyph attributes
    SCRIPT_ANALYSIS        *psa,        // InOut Result of ScriptItemize (may have fNoGlyphIndex set)
    int                    *piAdvance,  // Out   Advance wdiths
    GOFFSET                *pGoffset,   // Out   x,y offset for combining glyph
    ABC                    *pABC);      // Out   Composite ABC for the whole run (Optional)






/////   ScriptTextOut
//
//      The ScriptTextOut function takes the output of both ScriptShape and
//      ScriptPlace calls and calls the operating system ExtTextOut function
//      appropriately. If the last parameter is not null, GDI's ExtTextOutW calls
//      are routed to this function.
//
//      All arrays are in visual order unless the fLogicalOrder flag is set in
//      psa.


HRESULT WINAPI ScriptTextOut(
    const HDC                           hdc,            // In     OS handle to device context (required)
    SCRIPT_CACHE                        *psc,           // InOut  Cache handle
    int                                 x,              // In     x,y position for first glyph
    int                                 y,              // In
    UINT                                fuOptions,      // In     ExtTextOut options
    const RECT                          *lprc,          // In     optional clipping/opaquing rectangle
    const SCRIPT_ANALYSIS               *psa,           // In     Result of ScriptItemize
    const WCHAR                         *pwcReserved,   // In     Reserved (requires NULL)
    int                                 iReserved,      // In     Reserved (requires 0)
    const WORD                          *pwGlyphs,      // In     Glyph buffer from prior ScriptShape call
    int                                 cGlyphs,        // In     Number of glyphs
    const int                           *piAdvance,     // In     Advance widths from ScriptPlace
    const int                           *piJustify,     // In     Justified advance widths (optional)
    const GOFFSET                       *pGoffset);     // In     x,y offset for combining glyph






/////
//
//      The caller should normally use SetTextAlign(hdc, TA_RIGHT) before
//      calling ScriptTextOut with an RTL item inlogical order.
//
//      The piJustify array provides requested cell widths for each glyph.
//      When the piJustify width of a glyph differs from the unjustified
//      width (in PiAdvance), space is added to or removed from the glyph
//      cell at it's trailing edge. The glyph is always aligned with the
//      leading edge of it's cell. (This rule applies even in visual order.)
//
//      When a glyph cell is extended the extra space is uaually made up by
//      the addition of white space, however for Arabic scripts, the extra
//      space is made up by one or more kashida glyphs, unless the extra space
//      is insufficient for the shortest kashida glyph in the font. (The
//      width of the shortest kashida is available by calling
//      ScriptGetFontProperties.)
//
//      piJustify should only be passed if re-justification of the string is
//      required. Normally pass NULL to this parameter.
//
//      fuOptions may contain ETO_CLIPPED or ETO_OPAQUE (or neither or both).
//
//      Do not use ScriptTextOut to write to a metafile unless you are sure
//      that the metafile will eventually be played back without any font
//      substitution. ScriptTextOut record glyph numbers in the metafile.
//      Since glyph numbers vary considerably from one font to another
//      such a metafile is unlikely to play back correctly when differant
//      fonts are substituted.
//
//      For example when a metafile is played back at a different scale
//      CreateFont requests recorded in the metafile may resolve to bitmap
//      instead of truetype fonts, or if the metafile is played back on
//      a different machine requested fonts may not be installed.//
//
//      To write complex scripts in a metafile in a font independant manner,
//      use ExtTextOut to write the logical characters directly, so that
//      glyph generation and placement does not occur until the text is
//      played back.
/////   ScriptJustify
//
//      ScriptJustify provides a simple minded implementation of multilingual
//      justification.
//
//      Sophisticated text formatters may prefer to generate their own delta
//      dx array by combining their own features with the information returned
//      by ScriptShape in the SCRIPT_VISATTR array.
//
//      ScriptJustify establishes how much adjustment to make at each glyph
//      position on the line. It interprets the SCRIPT_VISATTR array generated
//      by a call to ScriptShape, and gives top priority to kashida, then uses
//      inter word spacing if there's no kashida points, then uses
//      intercharacter spacing if there are no inter-word points.
//
//      The justified advance widths generated in ScriptJustify should be
//      passed to ScriptTextOut in the piJustify paramter.
//
//      ScriptJustify creates a justify array containing updated advance
//      widths for each glyph. Where a glyphs advance width is increased, it
//      is expected that the extra width will be rendered to the right of the
//      glyph, with as white space or, for Arabic text, as kashida.
/////
HRESULT WINAPI ScriptJustify(
    const SCRIPT_VISATTR  *psva,        // In   Collected visual attributes for entire line
    const int             *piAdvance,   // In   Advance widths from ScriptPlace
    int                    cGlyphs,     // In   Size of all arrays
    int                    iDx,         // In   Desired width change, either increase or descrease
    int                    iMinKashida, // In   Minimum length of continuous kashida glyph to generate
    int                   *piJustify);  // Out  Updated advance widths to pass to ScriptTextOut






/////   SCRIPT_LOGATTR
//
//      The SCRIPT_LOGATTR structure describes attributes of logical
//      characters useful when editing and formatting text.
//
//      Note that for wordbreaking and linebreaking, if the first character of
//      the run passed in is not whitespace, the client needs to check whether
//      the last character of the previous run is whitespace to determine if
//      the first character of this run is the start of a word.
//
//
typedef struct tag_SCRIPT_LOGATTR {
    BYTE    fSoftBreak      :1;     // Potential linebreak point
    BYTE    fWhiteSpace     :1;     // A unicode whitespace character, except NBSP, ZWNBSP
    BYTE    fCharStop       :1;     // Valid cursor position (for left/right arrow)
    BYTE    fWordStop       :1;     // Valid cursor position (for ctrl + left/right arrow)
    BYTE    fInvalid        :1;     // Invalid character sequence
    BYTE    fReserved       :3;
} SCRIPT_LOGATTR;
//
//
//p     fSoftBreak: It would be valid to break the line in front of this
//              character. This flag is set on the first character of
//              South-East Asian words. Note that when linebreaking the
//              client would usually also treat any nonblank following a blank
//              as a softbreak position, by inspecting the fWhiteSPace flag
//              below.
//
//p     fWhiteSpace: This character is one of the many Unicode character
//              that are classified as breakable whitespace.
//
//p     fCharStop: Valid cursor position. Set on most characters, but not
//              on codepoints inside Indian and South East Asian character
//              clusters. May be used to implement left and right arrow
//              operation in editors.
//
//p     fWordStop: Valid position following word advance/retire commonly
//              implemented at ctrl/left-arrow and ctrl/right-arrow.
//              May be used to implement ctrl+left and ctrl+right arrow
//              operation in editors. As with fSoftBreak clients should
//              normally also inspect the fWhiteSpace flag and treat the
//              first character after a run of whitespace as the start of a
//              word.
//
//p     fInvalid: Marks characters which form an invalid or undisplayable
//              combination. Scripts which can set this flag have the flag
//              fInvalidLogAttr set in their SCRIPT_PROPERTIES.






/////   ScriptBreak
//
//      The ScriptBreak function returns cursor movement and formatting break
//      positions for an item as an array of SCRIPT_LOGATTRs. To support
//      mixed formatting within a single word correctly, ScriptBreak should
//      be passed whole items as returned by ScriptItemize.
//
//      ScriptBreak does not require an hdc and does not execute glyph shaping.
//
//      The fCharStop flag marks cluster boundaries for those scripts where
//      it is conventional to restrict from moving inside clusters. The same
//      boundaries could also be inferred by inspecting the pLogCLust array
//      returned by ScriptShape, however ScriptBreak is considerably faster in
//      implementation and does not require an hdc to be prepared.
//
//      The fWordStop, fSoftBreak and fWhiteSpace flags are only available
//      through ScriptBreak.
//
//      Most shaping engines that identify invalid sequences do so by setting
//      the fInvalid flag in ScriptBreak. The fInvalidLogAttr flag in
//      ScriptProperties identifies which scripts do this.


HRESULT WINAPI ScriptBreak(
    const WCHAR            *pwcChars,  // In   Logical unicode item
    int                     cChars,    // In   Length of unicode item
    const SCRIPT_ANALYSIS  *psa,       // In   Result of earlier ScriptItemize call
    SCRIPT_LOGATTR         *psla);     // Out  Logical character attributes






/////   ScriptCPtoX
//
//      The ScriptCPtoX function returns the x offset from the left end
//      (!fLogical) or leading edge (fLogical) of a run to either the leading
//      or the trailing edge of a logical character cluster.
//
//      iCP is the offset of any logical character in the cluster.
//
//      For scripts where the caret may conventionally be placed into the
//      middle of clusters (e.g. Arabic, Hebrew), the returned X may be
//      an interpolated position for any codepoint in the line.
//
//      For scripts where the caret is conventionally snapped to the boundaries
//      of clusters, (e.g. Thai, Indian), the resulting X position will be
//      snapped to the requested edge of the cluster containing CP.


HRESULT WINAPI ScriptCPtoX(
    int                     iCP,        // In   Logical character position in run
    BOOL                    fTrailing,  // In   Which edge (default - leading)
    int                     cChars,     // In   Count of logical codepoints in run
    int                     cGlyphs,    // In   Count of glyphs in run
    const WORD             *pwLogClust, // In   Logical clusters
    const SCRIPT_VISATTR   *psva,       // In   Visual glyph attributes array
    const int              *piAdvance,  // In   Advance widths
    const SCRIPT_ANALYSIS  *psa,        // In   Script analysis from item attributes
    int                    *piX);       // Out  Resulting X position






/////   ScriptXtoCP
//
//      The ScriptXtoCP function converts an x offset from the left end
//      (!fLogical) or leading edge (fLogical) of a run to a logical
//      character position and a flag that indicates whether the X position
//      fell in the leading or the trailing half of the character.
//
//      For scripts where the cursor may conventionally be placed into the
//      middle of clusters (e.g. Arabic, Hebrew), the returned CP may be
//      for any codepoint in the line, and fTrailing will be either zero
//      or one.
//
//      For scripts where the cursor is conventionally snapped to the
//      boundaries of a cluster, the returned CP is always the position of
//      the logically first codepoint in a cluster, and fTrailing is either
//      zero, or the number of codepoints in the cluster.
//
//      Thus the appropriate cursor position for a mouse hit is always the
//      returned CP plus the value of fTrailing.
//
//      If the X positition passed is not in the item at all, the resulting
//      position will be the trailing edge of character -1 (for X positions
//      before the item), or the leading edge of character 'cChars' (for
//      X positions following the item).


HRESULT WINAPI ScriptXtoCP(
    int                     iX,             // In   X offset from left of run
    int                     cChars,         // In   Count of logical codepoints in run
    int                     cGlyphs,        // In   Count of glyphs in run
    const WORD             *pwLogClust,     // In   Logical clusters
    const SCRIPT_VISATTR   *psva,           // In   Visual glyph attributes
    const int              *piAdvance,      // In   Advance widths
    const SCRIPT_ANALYSIS  *psa,            // In   Script analysis from item attributes
    int                    *piCP,           // Out  Resulting character position
    int                    *piTrailing);    // Out  Leading or trailing half flag






/////   Relationship between caret positions, justifications points and clusters
//
//
//t     Job                              | Uniscribe support
//t     -------------------------------- | --------------------------------------------------------
//t     Caret move by character cluster  | LogClust or VISATTR.fClusterStart or LOGATTR.fCharStop
//t     Line breaking between characters | LogClust or VISATTR.fClusterStart or LOGATTR.fCharStop
//t     Caret move by word               | LOGATTR.fWordStop
//t     Line breaking between words      | LOGATTR.fWordStop
//t     Justification                    | VISATTR.uJustification
//
//
//
/////   Character clusters
//
//      Character clusters are glyph sequences that cannot be split between
//      lines.
//
//      Some languages (e.g. Thai, Indic) restrict caret placement to points
//      betwen clusters. This applies both to keyboard initiated caret
//      movement (e.g. cursor keys) and pointing and clicking with the mouse
//      (hit testing).
//
//      Uniscribe provides cluster information in both the visual and logical
//      attributes. If you've called ScriptShape you'll find the cluster
//      information represented both by sequences of the same value in the
//      pwLogClust array, and by the fClusterStart flag in the psva
//      SCRIPT_VISATTR array.
//
//      ScriptBreak also returns the fCharStop flag in the SCRIPT_LOGATTR
//      array to identify cluster positions.
//
//
//
/////   Word break points
//
//      Valid positions for moving the caret when moving in whole words are
//      marked by the fWordStop flag returned by ScriptBreak.
//
//      Valid positions for breaking lines between words are marked by the
//      fSoftBreak flag returned by ScriptBreak.
//
//
//
/////   Justification
//
//      Justification space or kashida should be inserted where identified by
//      the uJustificaion field of the SCRIPT_VISATTR.
//
//      When performing inter-character justification, insert extra space
//      only after glyphs marked with uJustify == SCRIPT_JUSTIFY_CHARACTER.
//
//
//
/////   Script specific processing
//
//      Uniscribe provides information about special processing for each
//      script in the SCRIPT_PROPERTIES array.
//
//      Use the following code during initialisation to get a pointer to
//      the SCRIPT_PROPERTIES array:
//
//c     const SCRIPT_PROPERTIES **g_ppScriptProperties; // Array of pointers to properties
//c     int iMaxScript;
//c     HRESULT hr;
//
//c     hr = ScriptGetProperties(&g_ppScriptProperties, &g_iMaxScript);
//
//      Then inspect the properties of the script of an item 'iItem' as follows:
//
//c     hr = ScriptItemize( ... , pItems, ... );
//c     ...
//c     if (g_ppScriptProperties[pItems[iItem].a.eScript]->fNeedsCaretInfo) {
//c         // Use ScriptBreak to restrict the caret from entering clusters (for example).
//c     }
//
//
//      SCRIPT_PROPERTIES.fNeedsCaretInfo
//
//      Caret placement should be restricted to cluster
//      edges for scripts such as Thai and Indian. The fNeedsCaretInfo flag
//      in SCRIPT_PROPERTIES identifies such languages.
//
//      Note that ScriptXtoCP and ScriptCPtoX automatically apply caret
//      placement restictions.
//
//
//      SCRIPT_PROPERTIES.fNeedsWordBreaking
//
//      For most scripts, word break placement  may be
//      identified by scanning for characters marked as fWhiteSpace in
//      SCRIPT_LOGATTR, or for glyphs marked as uJustify ==
//      SCRIPT_JUSTIFY_BLANK or SCRIPT_JUSTIFY_ARABIC_BLANK in SCRIPT_VISATTR.
//
//      For languages such as Thai, it is also necessary to call ScriptBreak,
//      and include character positions marked as fWordStop in SCRIPT_LOGATTR.
//      Such scripts are marked as fNeedsWordbreaking in SCRIPT_PROPERTIES.
//
//
//      SCRIPT_PROPERTIES.fNeedsCharacterJustify
//
//      Languages such as Thai also require inter-character spacing when
//      justifying (where uJustify == SCRIPT_JUSTIFY_CHARACTER in the
//      SCRIPT_VISATTR). Such languages are marked as fNeedsCharacterJustify
//      in SCRIPT_PROPERTIES.
//
//
//      SCRIPT_PROPERTIES.fAmbiguousCharSet
//
//      Many Uniscribe scripts do not correspond directly to 8 bit character
//      sets. For example Unicode characters in the range U+100 through U+024F
//      represent extended latin shapes used for many languages, including
//      those supported by EASTEUROPE_CHARSET, TURKISH_CHARSET and
//      VIETNAMESE_CHARSET. However many of these characters are supported by
//      more han one of thsese charsets.
//      fAmbiguousCharset is set for any script token which could contain
//      characters from a number of these charsets. In these cases the bCharSet
//      field may contain ANSI_CHARSET or DEFAULT_CHARSET. The Uniscribe client
//      will generally need to apply futher processing to determine which charset
//      to use when requesting a font suitable for this run. For example it
//      determine that the run consists of multiple languages and split it up
//      to use a different font for each language.






/////   Notes on ScriptXtoCP and ScriptCPtoX
//
//      Both functions work only within runs and require the results of a
//      previous ScriptShape call.
//
//      The client must establish which run a given cursor offset or x
//      position is within before passing it to ScriptCPtoX or ScriptXtoCP.
//
//      Cluster information in the logical cluster array is used to share
//      the width of a cluster of glyphs equally among the logical characters
//      they represent.
//
//      For example, the lam alif glyph is divided into four areas: the
//      leading half of the lam, the trailing half of the lam, the leading
//      half of the alif and the trailing half of the alif.
//
//      ScriptXtoCP Understands the caret position conventions of each script.
//      For Indian and Thai, caret positions are snapped to cluster boundaries,
//      for Arabic and Hebrew, caret positions are interpolated within clusters.
//
//
/////   Translating mouse hit 'x' offset to caret position
//
//      Conventionally, caret position 'cp' may be selected by clicking either
//      on the trailing half of character 'cp-1' or on the leading half of
//      character 'cp'. This may easily be implemented as follows:
//
//c     int iCharPos;
//c     int iCaretPos
//c     int fTrailing;
//
//c     ScriptXtoCP(iMouseX, ..., &iCharPos, &fTrailing);
//c     iCaretPos = iCharPos + fTrailing;
//
//      For scripts that snap the caret to cluster boundaries, ScriptXtoCP
//      returns ftrailing set to either 0, or the width of the cluster in
//      codepoints. Thus the above code correctly returns only valid
//      caret positions.
//
//
/////   Displaying the caret in bidi strings
//
//      In unidirectional text, the leading edge of a character is at the same
//      place as the trailing edge of the previous character, so there is no
//      ambiguity in placing the caret between characters.
//
//      In bidirectional text, the caret position between runs of opposing
//      direction may be ambiguous.
//
//      For example in the left to right paragraph 'helloMAALAS', the last
//      letter of 'hello' immediately preceeds the first letter of 'salaam'.
//      The best position to display the caret depends on whether it is
//      considered to follow the 'o' of 'hello', or to preceed the 's' of
//      'salaam'.
//
/////   Commonly used caret positioning conventions
//
//t     Situation       | Visual caret placement
//t     ---------       | -------------------------------------------
//t     Typing          | Trailing edge of last character typed
//t     Pasting         | Trailing edge of last character pasted
//t     Caret advancing | Trailing edge of last character passed over
//t     Caret retiring  | Leading edge of last character passed over
//t     Home            | Leading edge of line
//t     End             | Trailing edge of line
//
//      The caret may be positioned as follows:
//
//c     if (advancing) {
//c         ScriptCPtoX(iCharPos-1, TRUE, ..., &iCaretX);
//c     } else {
//c         ScriptCPtoX(iCharPos, FALSE, ..., &iCaretX);
//c     }
//
//      Or, more simply, given an fAdvancing BOOL restricted to TRUE or FALSE:
//
//c     ScriptCPtoX(iCharPos-fAdvancing, fAdvancing, ..., &iCaretX);
//
//      ScriptCPtoX handles out of range positions logically: it returns the
//      leading edge of the run for iCharPos <0, and the trailing edge of the
//      run for iCharPos >=length.
/////   ScriptGetLogicalWidths
//
//      Converts visual withs in piAdvance into logical widths,
//      one per original character, in logical order.
//
//      Ligature glyphs widths are divided evenly amongst the characters
//      they represent.


HRESULT WINAPI ScriptGetLogicalWidths(
    const SCRIPT_ANALYSIS  *psa,            // In   Script analysis from item attributes
    int                     cChars,         // In   Count of logical codepoints in run
    int                     cGlyphs,        // In   Count of glyphs in run
    const int              *piGlyphWidth,   // In   Advance widths
    const WORD             *pwLogClust,     // In   Logical clusters
    const SCRIPT_VISATTR   *psva,           // In   Visual glyph attributes
    int                    *piDx);          // Out  Logical widths






/////
//      ScriptGetLogicalWidths is useful for recording widths in a
//      font independant manner. By passing the recorded logical widths
//      to ScriptApplyLogicalWidths, a block of text can be replayed in the
//      same boundaries with acceptable loss of quality even when the original
//      font is not available.
/////   ScriptApplyLogicalWidth
//
//      Accepts an array of advance widths in logical order, corresponding
//      one to one with codepoints, and generates an array of glyph widths
//      suitable for passing to the piJustify parameter of ScriptTextOut.
//
//      ScriptApplyLogicalWidth may be used to reapply logical widths
//      obtained with ScriptGetLogicalWidths. It may be useful in situations
//      such as metafiling, where it is necessary to record and reapply
//      advance width information in a font independant manner.



HRESULT WINAPI ScriptApplyLogicalWidth(
    const int              *piDx,        // In     Logical dx array to apply
    int                     cChars,      // In     Count of logical codepoints in run
    int                     cGlyphs,     // In     Glyph count
    const WORD             *pwLogClust,  // In     Logical clusters
    const SCRIPT_VISATTR   *psva,        // In     Visual attributes from ScriptShape/Place
    const int              *piAdvance,   // In     Glyph advance widths from ScriptPlace
    const SCRIPT_ANALYSIS  *psa,         // In     Script analysis from item attributes
    ABC                    *pABC,        // InOut  Updated item ABC width (optional)
    int                    *piJustify);  // Out    Resulting glyph advance widths for ScriptTextOut






/////
//p     piDx: Pointer to an array of dx widths in logical order, one per codepoint.
//
//p     cChars: Count of the logical codepoints in the run.
//
//p     cGlyphs: Glyph count.
//
//p     pwLogClust: Pointer to an array of logical clusters from ScriptShape
//
//p     psva: Pointer to an array of visual attributes from ScriptShape and
//          updated by ScriptPlace.
//
//p     piAdvance: Pointer to an array of glyph advance widths from ScriptPlace.
//
//p     psa: Pointer to a SCRIPT_ANALYSIS structure from ScriptItemize and
//          updated by ScriptShape and SriptPlace..
//
//p     pABC: Pointer to the run overall ABC width (optional). If present,
//          when the function is called, it should contain the run ABC width
//          returned by ScriptPlace; when the function returns, the ABC width
//          has been updated to match the new widths.
//
//p     piJustify:Pointer to an array of the resulting glyph advance widths.
//          This is suitable for passing to the piJustify parameter of ScriptTextOut.
/////   ScriptGetCMap
//
//      ScriptGetCMap may be used to determine which characters in a run
//      are supported by the selected font.
//
//      It returns glyph indices of Unicode characters according to Truetype
//      Cmap table, or standard Cmap implemented for old style fonts. The
//      glyph indices are returned in the same order as the input string.
//
//      The caller may scan the returned glyph buffer looking for the default
//      glyph to determine which characters are not available. (The default
//      glyph index for the selected font should be determined by calling
//      ScriptGetFontProperties).
//
//      The return value indicates the presence of any missing glyphs.


#define SGCM_RTL  0x00000001      // Return mirrored glyph for mirrorable Unicode codepoints


HRESULT WINAPI ScriptGetCMap(
    HDC             hdc,            // In    Optional (see notes on caching)
    SCRIPT_CACHE   *psc,            // InOut Address of Cache handle
    const WCHAR    *pwcInChars,     // In    Unicode codepoint(s) to look up
    int             cChars,         // In    Number of characters
    DWORD           dwFlags,        // In    Flags such as SGCM_RTL
    WORD           *pwOutGlyphs);   // Out   Array of glyphs, one per input character






/////
//  returns S_OK     - All unicode codepoints were present in the font
//          S_FALSE  - Some of the Unicode codepoints were mapped to the default glyph
//          E_HANDLE - font or system does not support glyph indices
/////   ScriptGetGlyphABCWidth
//
//      Returns ABC width of a given glyph.
//      May be useful for drawing glyph charts. Should not be used for
//      run of the mill complex script text formatting.


HRESULT WINAPI ScriptGetGlyphABCWidth(
    HDC             hdc,            // In    Optional (see notes on caching)
    SCRIPT_CACHE   *psc,            // InOut Address of Cache handle
    WORD            wGlyph,         // In    Glyph
    ABC            *pABC);          // Out   ABC width






/////
//  returns S_OK     - Glyph width returned
//          E_HANDLE - font or system does not support glyph indices
/////   SCRIPT_PROPERTIES
//
typedef struct {
    DWORD   langid                 :16; // Primary and sublanguage associated with script
    DWORD   fNumeric               :1;
    DWORD   fComplex               :1;  // Script requires special shaping or layout
    DWORD   fNeedsWordBreaking     :1;  // Requires ScriptBreak for word breaking information
    DWORD   fNeedsCaretInfo        :1;  // Requires caret restriction to cluster boundaries
    DWORD   bCharSet               :8;  // Charset to use when creating font
    DWORD   fControl               :1;  // Contains only control characters
    DWORD   fPrivateUseArea        :1;  // This item is from the Unicode range U+E000 through U+F8FF
    DWORD   fNeedsCharacterJustify :1;  // Requires inter-character justification
    DWORD   fInvalidGlyph          :1;  // Invalid combinations generate glyph wgInvalid in the glyph buffer
    DWORD   fInvalidLogAttr        :1;  // Invalid combinations are marked by fInvalid in the logical attributes
    DWORD   fCDM                   :1;  // Contains Combining Diacritical Marks
    DWORD   fAmbiguousCharSet      :1;  // Script does not correspond 1:1 with a charset
    DWORD   fClusterSizeVaries     :1;  // Measured cluster width depends on adjacent clusters
    DWORD   fRejectInvalid         :1;  // Invalid combinations should be rejected
} SCRIPT_PROPERTIES;
//
//p     langid: Language associated with this script. When a script is used for many languages,
//          langid id represents a default language. For example, Western script is represented
//          by LANG_ENGLISH although it is also used for French, German, Spanish etc.
//
//p     fNumeric: Script contains numerics and characters used in conjunction with numerics
//          by the rules of the Unicode bidirectional algorithm. For example
//          dollar sign and period are classified as numeric when adjacent to or in between
//          digits.
//
//p     fComplex: Indicates a script that requires complex script handling. If fComplex is false
//          the script contains no combining characters and requires no contextual shaping or reordering.
//
//p     fNeedsWordBreaking: A script, such as Thai, which requires algorithmic wordbreaking.
//          Use ScriptBreak to obtain a wordbreak points using the standard system wordbreaker.
//
//p     fNeedsCaretInfo: A script, such as Thai and Indian, where the caret may not be placed
//          inside a cluster. To determine valid caret positions inspect the fCharStop flag in the
//          logical attributes returned by ScriptBreak, or compare adjacent values in the pwLogClust
//          array returned by ScriptShape.
//
//p     bCharSet: Nominal charset associated with script. May be used in a logfont when creating
//          a font suitable for displaying this script. Note that for new scripts where there
//          is no charset defined, bCharSet may be innapropriate and DEFAULT_CHARSET should
//          be used instead - see the description of fAmbiguousCharSet below.
//
//p     fControl: contains control characters.
//
//p     fPrivateUseArea: The Unicode range U+E000 through U+F8FF.
//
//p     fNeedsCharacterJustify: A script, such as Thai, where justification is conventionally
//          achieved by increasing the space between all letters, not just between words.
//
//p     fInvalidGlyph: A script for which ScriptShape generates an invalid glyph
//          to represent invalid sequences. The glyph index of the invalid glyph for
//          a particular font may be obtained by calling ScriptGetFontProperties.
//
//p     fInvalidLogAttr: A script for which ScriptBreak sets the fInvalid flag
//          in the logical attributes to mark invalid sequences.
//
//p     fCDM: Implies that an item analysed by ScriptItemize included combining
//          diacritical marks (U+0300 through U+36F).
//
//p     fAmbiguousCharSet: No single legacy charset supports this script.
//          For example the extended Latin Extended-A Unicode range includes
//          characters from the EASTUROPE_CHARSET, the TURKISH_CHARSET and the
//          BALTIC_CHARSET. It also contains characters that are not available
//          in any legacy charset. Use DEFAULT_CHARSET when creating fonts to
//          display parts of this run.
//
//p     fClusterSizeVaries: A script, such as Arabic, where contextual shaping
//          may cause a string to increase in size when removing characters.
//
//p     fRejectInvalid: A script, such as Thai, where invalid sequences conventionally
//          cause an editor such as notepad to beep, and ignore keypresses.


/////   ScriptGetProperties
//
//      ScriptGetProperties returns the address of a table that maps a
//      script in a SCRIPT_ANALYSIS uScript field to properties including
//      the primary language associated with that script, whether it's
//      numeric and whether it's complex.


HRESULT WINAPI ScriptGetProperties(
    const SCRIPT_PROPERTIES ***ppSp,             // Out  Receives pointer to table of pointers to properties indexed by script
    int                       *piNumScripts);    // Out  Receives number of scripts (valid values are 0 through NumScripts-1)






/////   SCRIPT_FONTPROPERTIES
//
typedef struct {
    int     cBytes;         // Structure length
    WORD    wgBlank;        // Blank glyph
    WORD    wgDefault;      // Glyph used for Unicode values not present in the font
    WORD    wgInvalid;      // Glyph used for invalid character combinations (especially in Thai)
    WORD    wgKashida;      // Shortest continuous kashida glyph in the font, -1 if doesn't exist
    int     iKashidaWidth;  // Widths of shortest continuous kashida glyph in the font
} SCRIPT_FONTPROPERTIES;


/////   ScriptGetFontProperties
//
//      Returns information from the font cache


HRESULT WINAPI ScriptGetFontProperties(
    HDC                     hdc,    // In    Optional (see notes on caching)
    SCRIPT_CACHE           *psc,    // InOut Address of Cache handle
    SCRIPT_FONTPROPERTIES  *sfp);   // Out   Receives properties for this font






/////   ScriptCacheGetHeight
//
//


HRESULT WINAPI ScriptCacheGetHeight(
    HDC            hdc,         // In    Optional (see notes on caching)
    SCRIPT_CACHE  *psc,         // InOut Address of Cache handle
    long          *tmHeight);   // Out   Receives font height in pixels






/////   ScriptStringAnalyse
//
//
#define SSA_PASSWORD         0x00000001  // Input string contains a single character to be duplicated iLength times
#define SSA_TAB              0x00000002  // Expand tabs
#define SSA_CLIP             0x00000004  // Clip string at iReqWidth
#define SSA_FIT              0x00000008  // Justify string to iReqWidth
#define SSA_DZWG             0x00000010  // Provide representation glyphs for control characters
#define SSA_FALLBACK         0x00000020  // Use fallback fonts
#define SSA_BREAK            0x00000040  // Return break flags (character and word stops)
#define SSA_GLYPHS           0x00000080  // Generate glyphs, positions and attributes
#define SSA_RTL              0x00000100  // Base embedding level 1
#define SSA_GCP              0x00000200  // Return missing glyphs and LogCLust with GetCharacterPlacement conventions
#define SSA_HOTKEY           0x00000400  // Replace '&' with underline on subsequent codepoint
#define SSA_METAFILE         0x00000800  // Write items with ExtTextOutW Unicode calls, not glyphs
#define SSA_LINK             0x00001000  // Apply FE font linking/association to non-complex text
#define SSA_HIDEHOTKEY       0x00002000  // Remove first '&' from displayed string
#define SSA_HOTKEYONLY       0x00002400  // Display underline only.

#define SSA_FULLMEASURE      0x04000000  // Internal - calculate full width and out the number of chars can fit in iReqWidth.
#define SSA_LPKANSIFALLBACK  0x08000000  // Internal - enable FallBack for all LPK Ansi calls Except BiDi hDC calls
#define SSA_PIDX             0x10000000  // Internal
#define SSA_LAYOUTRTL        0x20000000  // Internal - Used when DC is mirrored
#define SSA_DONTGLYPH        0x40000000  // Internal - Used only by GDI during metafiling - Use ExtTextOutA for positioning
#define SSA_NOKASHIDA        0x80000000  // Internal - Used by GCP to justify the non Arabic glyphs only.
//
//
//p     SSA_HOTKEY: Note that SSA_HOTKEY and SSA_HIDEHOTKEY remove the
//          hotkey '&' character from further processing, so functions
//          such as ScriptString_pLogAttr return arrays based on a string
//          which excludes the '&'.




/////   SCRIPT_TABDEF
//
//      Defines tabstop positions for ScriptStringAnalyse (ignored unless SSA_TAB passed)
//
typedef struct tag_SCRIPT_TABDEF {
    int   cTabStops;        // Number of entries in pTabStops array
    int   iScale;           // Scale factor for pTabStops (see below)
    int  *pTabStops;        // Pointer to array of one or more tab stops
    int   iTabOrigin;       // Initial offset for tab stops (logical units)
} SCRIPT_TABDEF;
//
//
//p     cTabStops: Number of entries in the pTabStops array. If zero, tabstops
//          are every 8 average character widths. If one, all tabstops are
//          the length of the first entry in pTabStops. If more than one,
//          the first cTabStops are as specified in the pTabStops array,
//          subsequent tabstops are every 8 average characters from the last
//          tabstop in the array.
//
//p     iScale: Scale factor for iTabOrigin and pTabStops entries. Values are
//          converted to device coordinates by multiplying by iScale then
//          dividing by 4. If values are already in device units, set iScale to
//          4. If values are in dialog units, set iScale to the average char
//          width of the dialog font. If values are multiples of the average
//          character width for the selected font, set iScale to 0.
//
//p     pTabStops: Array of cTabStops entries. Each entry specifies a
//          tabstop position. Positive values give nearedge alignment,
//          negative values give faredge alignment.
//
//p     iTabOrigin: Tabs are considered to start iTabOrigin before the
//          beginning of the string. Helps with multiple tabbed
//          outputs on the same line.






/////   ScriptStringAnalyse
//
//      cString - Input string must contain at least one character
//
//      hdc - required if SSA_GLYPH requested. Optional for SSA_BREAK.
//      If present the current font in the hdc is inspected and if a symbolic
//      font the character string is treated as a single neutral SCRIPT_UNDEFINED item.
//
//      Note that the uBidiLevel field in the initial SCRIPT_STATE value
//      is ignored - the uBidiLevel used is derived from the SSA_RTL
//      flag in combination with the layout of the hdc.


typedef void* SCRIPT_STRING_ANALYSIS;


HRESULT WINAPI ScriptStringAnalyse(
    HDC                      hdc,       //In  Device context (required)
    const void              *pString,   //In  String in 8 or 16 bit characters
    int                      cString,   //In  Length in characters (Must be at least 1)
    int                      cGlyphs,   //In  Required glyph buffer size (default cString*1.5 + 16)
    int                      iCharset,  //In  Charset if an ANSI string, -1 for a Unicode string
    DWORD                    dwFlags,   //In  Analysis required
    int                      iReqWidth, //In  Required width for fit and/or clip
    SCRIPT_CONTROL          *psControl, //In  Analysis control (optional)
    SCRIPT_STATE            *psState,   //In  Analysis initial state (optional)
    const int               *piDx,      //In  Requested logical dx array
    SCRIPT_TABDEF           *pTabdef,   //In  Tab positions (optional)
    const BYTE              *pbInClass, //In  Legacy GetCharacterPlacement character classifications (deprecated)

    SCRIPT_STRING_ANALYSIS  *pssa);     //Out Analysis of string






/////   ScriptStringFree - free a string analysis
//
//


HRESULT WINAPI ScriptStringFree(
    SCRIPT_STRING_ANALYSIS *pssa);  //InOut Address of pointer to analysis






/////   ScriptStringSize
//
//      returns a pointer to the size (width and height) of an analysed string
//
//      Note that the SIZE pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.


const SIZE* WINAPI ScriptString_pSize(
    SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptString_pcOutChars
//
//      returns pointer to length of string after clipping (requires SSA_CLIP set)
//
//      Note that the int pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.


const int* WINAPI ScriptString_pcOutChars(
    SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptString_pLogAttr
//
//      returns pointer to logical attributes buffer in a SCRIPT_STRING_ANALYSIS
//
//      Note that the buffer pointer remains valid only until the
//      SCRIPT_STRING_ANALYSIS is passed to ScriptStringFree.
//
//      The logical attribute array contains *ScriptString_pcOutChars(ssa)
//      entries.


const SCRIPT_LOGATTR* WINAPI ScriptString_pLogAttr(
    SCRIPT_STRING_ANALYSIS   ssa); 






/////   ScriptStringGetOrder
//
//      Creates an array mapping original character position to glyph position.
//
//      Treats clusters as they were in legacy systems - Unless a cluster
//      contains more glyphs than codepoints, each glyph is referenced at
//      least once from the puOrder array.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.
//
//      The puOrder parameter should address a buffer containing room for
//      at least *ScriptString_pcOutChars(ssa) ints.


HRESULT WINAPI ScriptStringGetOrder(
    SCRIPT_STRING_ANALYSIS  ssa,
    UINT                    *puOrder); 






/////   ScriptStringCPtoX
//
//      Return x coordinate for leading or trailing edge of character icp.


HRESULT WINAPI ScriptStringCPtoX(
    SCRIPT_STRING_ANALYSIS  ssa,        //In  String analysis
    int                     icp,        //In  Caret character position
    BOOL                    fTrailing,  //In  Which edge of icp
    int                    *pX);        //Out Corresponding x offset






/////   ScriptStringXtoCP
//
//


HRESULT WINAPI ScriptStringXtoCP(
    SCRIPT_STRING_ANALYSIS  ssa,            // In
    int                     iX,             // In
    int                    *piCh,           // Out
    int                    *piTrailing);    // Out






/////   ScriptStringGetLogicalWidths
//
//      Converts visual withs in psa->piAdvance into logical widths,
//      one per original character, in logical order.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.
//
//      The piDx parameter should address a buffer containing room for
//      at least *ScriptString_pcOutChars(ssa) ints.


HRESULT WINAPI ScriptStringGetLogicalWidths(
    SCRIPT_STRING_ANALYSIS  ssa,
    int                    *piDx); 






/////   ScriptStringValidate
//
//      Scans the string analysis for invalid glyphs.
//
//      Only glyphs generated by scripts that can generate invalid glyphs
//      are scanned.
//
//      returns S_OK    - no invalid glyphs are present
//              S_FALSE - one or more invalid glyphs are present


HRESULT WINAPI ScriptStringValidate(
    SCRIPT_STRING_ANALYSIS ssa); 






/////   ScriptStringOut
//
//      Displays the string generated by a prior ScriptStringAnalyze call,
//      then optionally adds highlighting corresponding to a logical selection.
//
//      Requires SSA_GLYPHS requested in original ScriptStringAnalyse call.


HRESULT WINAPI ScriptStringOut(
    SCRIPT_STRING_ANALYSIS ssa,         //In  Analysis with glyphs
    int              iX,                //In
    int              iY,                //In
    UINT             uOptions,          //In  ExtTextOut options
    const RECT      *prc,               //In  Clipping rectangle (iff ETO_CLIPPED)
    int              iMinSel,           //In  Logical selection. Set iMinSel>=iMaxSel for no selection
    int              iMaxSel,           //In
    BOOL             fDisabled);        //In  If disabled, only the background is highlighted.






/////
//      uOptions may nclude only ETO_CLIPPED or ETO_OPAQUE.
/////   ScriptIsComplex
//
//      Determines whether a Unicode string requires complex script processing
//
//      The dwFlags parameter may include the following requests
//
#define SIC_COMPLEX     1   // Treat complex script letters as complex
#define SIC_ASCIIDIGIT  2   // Treat digits U+0030 through U+0039 as complex
#define SIC_NEUTRAL     4   // Treat neutrals as complex
//
//      SIC_COMPLEX: Should normally set. Causes complex script letters to
//      be treated as complex.
//
//      SIC_ASCIIDIGIT: Set this flag if the string would be displayed with
//      digit substitution enabled. If you are following the users NLS
//      settings using the ScriptRecordDigitSubstitution API, you can pass
//      scriptDigitSubstitute.DigitSubstitute != SCRIPT_DIGITSUBSTITUTE_NONE.
//
//      SIC_NEUTRAL: Set this flag if you may be displaying the string with
//      right-to-left reading order. When this flag is set, neutral characters
//      are considered as complex.
//
//
//      Returns S_OK     if string requires complex script processing,
//              S_FALSE  if string contains only characters laid out side by
//                       side from left to right.


HRESULT WINAPI ScriptIsComplex(
    const WCHAR     *pwcInChars,        //In  String to be tested
    int              cInChars,          //In  Length in characters
    DWORD            dwFlags);          //In  Flags (see above)






/////   ScriptRecordDigitSubstitution
//
//      Reads NLS native digit and digit substitution settings and records
//      them in the SCRIPT_DIGITSUBSTITUTE structure.
//
//
typedef struct tag_SCRIPT_DIGITSUBSTITUTE {
    DWORD  NationalDigitLanguage    :16;   // Language for native substitution
    DWORD  TraditionalDigitLanguage :16;   // Language for traditional substitution
    DWORD  DigitSubstitute          :8;    // Substitution type
    DWORD  dwReserved;                     // Reserved
} SCRIPT_DIGITSUBSTITUTE;
//
//
//p     NationalDigitLanguage: Standard digits for the selected locale as
//          defined by the countries standard setting authority.
//
//p     TraditionalDigitLangauge: Digits originally used with the locales
//          script.
//
//p     DigitSubstitute: Selects between None, Context, National and
//          Traditional. See ScriptApplyDigitSubstitution below for
//          constant definitions.
//
//      Although most complex scripts have their own associated digits, many
//      countries using those scripts use western (so called
//      'Arabic') digits as their standard. NationalDigitLanguage reflects the
//      digits used as standard, and is set from
//      the NLS data for the locale.
//      On Windows 2000 the national digit langauge can be
//      adjusted to any digit script with the control panel/regional
//      options/numbers/Standard digits listbox.
//
//      The TraditionalDigitLanguage for a locale is derived directly from the
//      script used by that locale.


HRESULT WINAPI ScriptRecordDigitSubstitution(
    LCID                     Locale,    // In   LOCALE_USER_DEFAULT or desired locale
    SCRIPT_DIGITSUBSTITUTE  *psds);     // Out  Digit substitution settings






/////
//p     Locale: NLS locale to be queried. Should usually be set to
//          LOCALE_USER_DEFAULT. Alternatively may be passed as a locale
//          combined with LOCALE_NOUSEROVERRIDE to obtain default settings
//          for a given locale. Note that context digit substitution is
//          supported only in ARABIC and FARSI locales. In other locales,
//          context digit is mapped to no substitution.
//
//p     psds: Pointer to SCRIPT_DIGITSUBSTITUTE. This structure may be passed
//          later to ScriptApplyDigitSubstitution.
//
//p     returns: E_INVALIDARG if Locale is invalid or not installed. E_POINTER
//          if psds is NULL. Otherwise S_OK.
//
//      For performance reasons, you should not call
//      ScriptRecordDigitSubstitution frequently. In particular it would be a
//      considerable overhead to call it every time you call ScriptItemize
//      or ScriptStringAnalyse.
//
//      Instead, you may choose to save the SCRIPT_DIGITSUBSTITUTE
//      structure, and update it only when you receive a
//      WM_SETTINGCHANGE message or when a RegNotifyChangeKeyValue
//      call in a dedicated thread indicates a change in the registry
//      under HKCU\Control Panel\\International.
//
//      The normal way to call this function is simply
//
//c     SCRIPT_DIGITSUBSTITUTE sds;
//c     ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &sds);
//
//      Then every time you itemize, you'd use the results like this:
//
//c     SCRIPT_CONTROL  sc = {0};
//c     SCRIPT_STATE    ss = {0};
//
//c     ScriptApplyDigitSubstitution(&sds, &sc, &ss);
//
//
/////   ScriptApplyDigitSubstitution
//
//      Aplies the digit substitution settings recorded in a
//      SCRIPT_DIGIT_SUBSTITUTE structure to the SCRIPT_CONTROL and
//      SCRIPT_STATE structures.
//
//      The DigitSubstitute field of the SCRIPT_DIGITSUBSTITUTE structure
//      is normally set by ScriptRecordDigitSubstitution, however it may
//      be replaced by any one of the following values:
//
//
#define SCRIPT_DIGITSUBSTITUTE_CONTEXT      0  // Substitute to match preceeding letters
#define SCRIPT_DIGITSUBSTITUTE_NONE         1  // No substitution
#define SCRIPT_DIGITSUBSTITUTE_NATIONAL     2  // Substitute with official national digits
#define SCRIPT_DIGITSUBSTITUTE_TRADITIONAL  3  // Substitute with traditional digits of the locale
//
//
//p     SCRIPT_DIGITSUBSTITUTE_CONTEXT: Digits U+0030 - U+0039 will be
//          substituted according to the language of prior letters. Before
//          any letters, digits will be substituted according to the
//          TraditionalDigitLangauge field of the SCRIPT_DIGIT_SUBSTITUTE
//          structure. This field is normally set to the primary language of
//          the Locale passed to ScriptRecordDigitSubstitution.
//
//p     SCRIPT_DIGITSUBSTITUTE_NONE: Digits will not be substituted. Unicode
//          values U+0030 to U+0039 will be displayed with Arabic (i.e.
//          Western) numerals.
//
//p     SCRIPT_DIGITSUBSTITUTE_NATIONAL: Digits U+0030 - U+0039 will be
//          substituted according to the NationalDigitLangauge field of
//          the SCRIPT_DIGIT_SUBSTITUTE structure. This field is normally
//          set to the national digits returned for the NLS LCTYPE
//          LOCALE_SNATIVEDIGITS by ScriptRecordDigitSubstitution.
//
//p     SCRIPT_DIGITSUBSTITUTE_TRADITIONAL: Digits U+0030 - U+0039 will be
//          substituted according to the TraditionalDigitLangauge field of
//          the SCRIPT_DIGIT_SUBSTITUTE structure. This field is normally
//          set to the primary language of the Locale passed to
//          ScriptRecordDigitSubstitution.


HRESULT WINAPI ScriptApplyDigitSubstitution(
    const SCRIPT_DIGITSUBSTITUTE  *psds,   // In   Digit substitution settings
    SCRIPT_CONTROL                *psc,    // Out  Script control structure
    SCRIPT_STATE                  *pss);   // Out  Script state structure






/////
//p     psds: Pointer to SCRIPT_DIGITSUBSTITUTE structure recorded earlier.
//          If NULL, ScriptApplyDigitSubstitution calls
//          ScriptRecordDigitSubstitution with LOCALE_USER_DEFAULT.
//
//p     psc: SCRIPT_CONTROL structure. The fContextDigits and uDefaultLanguage
//          fields will be updated.
//
//p     pss: SCRIPT_CONTROL structure. The fDigitSubstitute field will be
//          updated.
//
//p     returns: E_INVALIDARG if the DigitSubstitute field of the
//          SCRIPT_DIGITSUBSTITUTE structure is unrecognised, else S_OK;
#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\actdict.h ===
/*----------------------------------------------------------------------------
	%%File: ACTDICT.H
	%%Unit: ACTDICT
	%%Contact: seijia@microsoft.com

	Header file for the program dictionary interface.
----------------------------------------------------------------------------*/

#ifndef __PRGDIC__
#define  __PRGDIC__

#include "outpos.h"

#define DLLExport				__declspec( dllexport )

//HRESULT values
#define IPRG_S_LONGER_WORD			MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7400)
#define IPRG_S_NO_ENTRY				MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x7401)

//Dictionary Category
typedef DWORD			IMEDICAT;

#define dicatNone			0x00000000
#define dicatGeneral		0x00000001
#define	dicatNamePlace		0x00000002
#define dicatSpeech			0x00000004
#define dicatReverse		0x00000008
#define	dicatEnglish		0x00000010
#define dicatALL			0x0000001f

//Index Type
typedef DWORD			IMEIDXTP;

#define	idxtpHiraKanji		0x0001
#define	idxtpKanjiHira		0x0002
#define	idxtpMix			(idxtpHiraKanji | idxtpKanjiHira)

//IImeActiveDict Interface Version
#define	verIImeActiveDict			0x0100

//Dictionary Data Disclosure
typedef enum _IMEDDISC
{
	ddiscNone,				//do not disclose data
	ddiscAll,				//show all contents
	ddiscPartial			//show partial data
} IMEDDISC;

// Shared Header dictionary File
typedef struct _IMESHF
{
	WORD 		cbShf;				//size of this struct
	WORD 		verDic;				//dictionary version
	CHAR 		szTitle[48];		//dictionary title
	CHAR 		szDescription[256];	//dictionary description
	CHAR 		szCopyright[128];	//dictionary copyright info
} IMESHF;

//Dictionary Info
typedef struct _IMEDINFO
{
	IMESHF		shf;		//header
	DWORD		ver;		//IImeActiveDict version number
	IMEDDISC	ddisc;		//disclosure permission type
	FILETIME	filestamp;	//file stamp at creation
	IMEDICAT	dicat;		//dictionary category
	IMEIDXTP	idxtp;		//index type
	BOOL		fLearn;		//support word learning
} IMEDINFO;

#define cwchWordMax			64

typedef DWORD		IMESTMP;			//word stamp

//Program Dictionary Tango
typedef struct _IMEPDT
{
	IMEIDXTP	idxtp;					//index type
	int			cwchInput;				//input string length
	int			cwchOutput;				//output string length
	WCHAR		wszInput[cwchWordMax];	//input string
	WCHAR		wszOutput[cwchWordMax];	//output string
	DWORD		nPos;					//part of speech
	IMESTMP		stmp;					//word time stamp
} IMEPDT;

///////////////////////////////
// The IImeActiveDict interface
///////////////////////////////

#undef  INTERFACE
#define INTERFACE   IImeActiveDict

DECLARE_INTERFACE_(IImeActiveDict, IUnknown)
{
	// IUnknown members
    STDMETHOD(QueryInterface)(THIS_ REFIID refiid, VOID **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

	// IImeActiveDict members
    STDMETHOD(DicInquire)	(THIS_
							IMEDINFO *pdinfo			//(out) dictionary info
							) PURE;
    STDMETHOD(DicOpen)		(THIS_
							IMEDINFO *pdinfo			//(out) dictionary info
							) PURE;
    STDMETHOD(DicClose)		(THIS) PURE;
    STDMETHOD(DicSearchWord)(THIS_
							IMEPDT *ppdt, 				//(in/out) tango
							BOOL fFirst, 				//(in) first time flag
							BOOL fWildCard,				//(in) wildcard flag
							BOOL fPartial				//(in) disclosure flag
							) PURE;
    STDMETHOD(DicLearnWord)	(THIS_
							IMEPDT *ppdt,				//(in/out) tango
							BOOL fUserLearn	,			//(in) user learning option
							int nLevel					//(in) learning level
							) PURE;
    STDMETHOD(DicProperty)	(THIS_
							HWND hwnd					//(in) parent window handle
							) PURE;
};


#ifdef __cplusplus
extern "C" {
#endif

// The following API replaces CoCreateInstance() since we don't support class ID at this time.
typedef HRESULT (WINAPI *PFNCREATE)(VOID **, int);
DLLExport HRESULT WINAPI CreateIImeActiveDictInstance(VOID **ppvObj, int nid);

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__PRGDIC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc30\outpos.h ===
/*----------------------------------------------------------------------------
	%%File: OUTPOS.H
	%%Unit: OUTPOS
	%%Contact: seijia

	mapping from public and private pos
----------------------------------------------------------------------------*/

#ifndef __OUTPOS_H__
#define __OUTPOS_H__

#define JPOS_UNDEFINED		0

#define JPOS_MEISHI_FUTSU		100		//
#define JPOS_MEISHI_SAHEN		101		//ϖ
#define JPOS_MEISHI_ZAHEN		102		//ϖ
#define JPOS_MEISHI_KEIYOUDOUSHI		103		//`
#define JPOS_HUKUSIMEISHI		104		//I
#define JPOS_MEISA_KEIDOU		105		//ό`
#define JPOS_JINMEI		106		//l
#define JPOS_JINMEI_SEI		107		//
#define JPOS_JINMEI_MEI		108		//
#define JPOS_CHIMEI		109		//n
#define JPOS_CHIMEI_KUNI		110		//
#define JPOS_CHIMEI_KEN		111		//
#define JPOS_CHIMEI_GUN		112		//S
#define JPOS_CHIMEI_KU		113		//
#define JPOS_CHIMEI_SHI		114		//s
#define JPOS_CHIMEI_MACHI		115		//
#define JPOS_CHIMEI_MURA		116		//
#define JPOS_CHIMEI_EKI		117		//w
#define JPOS_SONOTA		118		//ŗL
#define JPOS_SHAMEI		119		//Ж
#define JPOS_SOSHIKI		120		//gD
#define JPOS_KENCHIKU		121		//z
#define JPOS_BUPPIN		122		//i
#define JPOS_DAIMEISHI		123		//㖼
#define JPOS_DAIMEISHI_NINSHOU		124		//l̑㖼
#define JPOS_DAIMEISHI_SHIJI		125		//w㖼
#define JPOS_KAZU		126		//
#define JPOS_KAZU_SURYOU		127		//
#define JPOS_KAZU_SUSHI		128		//
#define JPOS_5DAN_AWA		200		//s
#define JPOS_5DAN_KA		201		//s
#define JPOS_5DAN_GA		202		//s
#define JPOS_5DAN_SA		203		//s
#define JPOS_5DAN_TA		204		//s
#define JPOS_5DAN_NA		205		//ȍs
#define JPOS_5DAN_BA		206		//΍s
#define JPOS_5DAN_MA		207		//܍s
#define JPOS_5DAN_RA		208		//s
#define JPOS_5DAN_AWAUON		209		//s
#define JPOS_5DAN_KASOKUON		210		//s
#define JPOS_5DAN_RAHEN		211		//sϊi
#define JPOS_4DAN_HA		212		//͍sli
#define JPOS_1DAN		213		//i
#define JPOS_TOKUSHU_KAHEN		214		//ϓ
#define JPOS_TOKUSHU_SAHENSURU		215		//ϓ
#define JPOS_TOKUSHU_SAHEN		216		//sϊi
#define JPOS_TOKUSHU_ZAHEN		217		//sϊi
#define JPOS_TOKUSHU_NAHEN		218		//ȍsϊi
#define JPOS_KURU_KI		219		//
#define JPOS_KURU_KITA		220		//
#define JPOS_KURU_KITARA		221		//
#define JPOS_KURU_KITARI		222		//
#define JPOS_KURU_KITAROU		223		//낤
#define JPOS_KURU_KITE		224		//
#define JPOS_KURU_KUREBA		225		//
#define JPOS_KURU_KO		226		//iȂj
#define JPOS_KURU_KOI		227		//
#define JPOS_KURU_KOYOU		228		//悤
#define JPOS_SURU_SA		229		//
#define JPOS_SURU_SI		230		//
#define JPOS_SURU_SITA		231		//
#define JPOS_SURU_SITARA		232		//
#define JPOS_SURU_SIATRI		233		//
#define JPOS_SURU_SITAROU		234		//낤
#define JPOS_SURU_SITE		235		//
#define JPOS_SURU_SIYOU		236		//悤
#define JPOS_SURU_SUREBA		237		//
#define JPOS_SURU_SE		238		//
#define JPOS_SURU_SEYO		239		//^
#define JPOS_KEIYOU		300		//`e
#define JPOS_KEIYOU_GARU		301		//`e
#define JPOS_KEIYOU_GE		302		//`e
#define JPOS_KEIYOU_ME		303		//`e
#define JPOS_KEIYOU_YUU		304		//`e
#define JPOS_KEIYOU_U		305		//`e
#define JPOS_KEIDOU		400		//`e
#define JPOS_KEIDOU_NO		401		//`e
#define JPOS_KEIDOU_TARU		402		//`e
#define JPOS_KEIDOU_GARU		403		//`e
#define JPOS_FUKUSHI		500		//
#define JPOS_FUKUSHI_SAHEN		501		//ϕ
#define JPOS_FUKUSHI_NI		502		//
#define JPOS_FUKUSHI_NANO		503		//
#define JPOS_FUKUSHI_DA		504		//
#define JPOS_FUKUSHI_TO		505		//
#define JPOS_FUKUSHI_TOSURU		506		//Ă
#define JPOS_RENTAISHI		600		//A̎
#define JPOS_RENTAISHI_SHIJI		601		//wA̎
#define JPOS_SETSUZOKUSHI		650		//ڑ
#define JPOS_KANDOUSHI		670		//
#define JPOS_SETTOU		700		//ړ
#define JPOS_SETTOU_KAKU		701		//Pړ
#define JPOS_SETTOU_SAI		702		//Qړ
#define JPOS_SETTOU_FUKU		703		//Rړ
#define JPOS_SETTOU_MI		704		//Sړ
#define JPOS_SETTOU_DAISHOU		705		//Tړ
#define JPOS_SETTOU_KOUTEI		706		//Uړ
#define JPOS_SETTOU_CHOUTAN		707		//Vړ
#define JPOS_SETTOU_SHINKYU		708		//Wړ
#define JPOS_SETTOU_JINMEI		709		//lړ
#define JPOS_SETTOU_CHIMEI		710		//nړ
#define JPOS_SETTOU_SONOTA		711		//ŗLړ
#define JPOS_SETTOU_JOSUSHI		712		//Ou
#define JPOS_SETTOU_TEINEI_O		713		//JPړ
#define JPOS_SETTOU_TEINEI_GO		714		//JQړ
#define JPOS_SETTOU_TEINEI_ON		715		//JRړ
#define JPOS_SETSUBI		800		//ڔ
#define JPOS_SETSUBI_TEKI		801		//Pڔ
#define JPOS_SETSUBI_SEI		802		//Qڔ
#define JPOS_SETSUBI_KA		803		//Rڔ
#define JPOS_SETSUBI_CHU		804		//Sڔ
#define JPOS_SETSUBI_FU		805		//Tڔ
#define JPOS_SETSUBI_RYU		806		//Uڔ
#define JPOS_SETSUBI_YOU		807		//Vڔ
#define JPOS_SETSUBI_KATA		808		//Wڔ
#define JPOS_SETSUBI_MEISHIRENDAKU		809		//A
#define JPOS_SETSUBI_JINMEI		810		//lڔ
#define JPOS_SETSUBI_CHIMEI		811		//nڔ
#define JPOS_SETSUBI_KUNI		812		//ڔ
#define JPOS_SETSUBI_KEN		813		//ڔ
#define JPOS_SETSUBI_GUN		814		//Sڔ
#define JPOS_SETSUBI_KU		815		//ڔ
#define JPOS_SETSUBI_SHI		816		//sڔ
#define JPOS_SETSUBI_MACHI		817		//Pڔ
#define JPOS_SETSUBI_CHOU		818		//Qڔ
#define JPOS_SETSUBI_MURA		819		//Pڔ
#define JPOS_SETSUBI_SON		820		//Qڔ
#define JPOS_SETSUBI_EKI		821		//wڔ
#define JPOS_SETSUBI_SONOTA		822		//ŗLڔ
#define JPOS_SETSUBI_SHAMEI		823		//Жڔ
#define JPOS_SETSUBI_SOSHIKI		824		//gDڔ
#define JPOS_SETSUBI_KENCHIKU		825		//zڔ
#define JPOS_RENYOU_SETSUBI		826		//Apڔ
#define JPOS_SETSUBI_JOSUSHI		827		//u
#define JPOS_SETSUBI_JOSUSHIPLUS		828		//u{
#define JPOS_SETSUBI_JIKAN		829		//ԏ
#define JPOS_SETSUBI_JIKANPLUS		830		//ԏ{
#define JPOS_SETSUBI_TEINEI		831		//Jڔ
#define JPOS_SETSUBI_SAN		832		//JPڔ
#define JPOS_SETSUBI_KUN		833		//JQڔ
#define JPOS_SETSUBI_SAMA		834		//JRڔ
#define JPOS_SETSUBI_DONO		835		//JSڔ
#define JPOS_SETSUBI_FUKUSU		836		//ڔ
#define JPOS_SETSUBI_TACHI		837		//Pڔ
#define JPOS_SETSUBI_RA		838		//Qڔ
#define JPOS_TANKANJI		900		//P
#define JPOS_TANKANJI_KAO		901		//
#define JPOS_KANYOUKU		902		//p
#define JPOS_DOKURITSUGO		903		//Ɨ
#define JPOS_FUTEIGO		904		//s
#define JPOS_KIGOU		905		//L
#define JPOS_EIJI		906		//p
#define JPOS_KUTEN		907		//_
#define JPOS_TOUTEN		908		//Ǔ_
#define JPOS_KANJI		909		//͕s\
#define JPOS_OPENBRACE		910		//J
#define JPOS_CLOSEBRACE		911		//


#pragma pack (push, 1)
//POS table data structure
typedef struct _POSTBL
{
	WORD		nPos;					//pos number
	BYTE		*szName;				//name of pos
} POSTBL;
#pragma pack (pop)

#ifdef __cplusplus
extern "C" {
#endif

//function prototypes
extern POSTBL *ObtainPosTable(int *pcPos);
extern WORD WPosExtFromIn(WORD wPos);
extern WORD WPosInFromExt(WORD wPos);
#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__OUTPOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc30\ourtypes.h ===
/*
 *	@doc INTERNAL
 *
 *	@module	OURTYPES.H	-- Miscellaneous type declarations |
 *	
 *	Original Author: <nl>
 *		DGreen
 *
 *	History: <nl>
 *		02/19/98  KeithCu  Cleaned up
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _OURTYPES_H_
#define _OURTYPES_H_

// WM_SYSKEYDOWN masks for lKeyData
#define SYS_ALTERNATE		0x20000000
#define SYS_PREVKEYSTATE	0x40000000


#ifndef WINDOWS
#define WINDOWS
#endif


// Windows does not provide defines for WM_NCMOUSEFIRST and WM_NCMOUSELAST
// as is done for MOUSE and KEY events.

#define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
#define WM_NCMOUSELAST WM_NCMBUTTONDBLCLK


#if defined(WIN32) && !defined(MACPORT)

#define CchSzAToSzW(_szA, _szW, _cbSzW)	\
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (_szA), -1, (_szW),	\
						(_cbSzW) / sizeof(WCHAR))

#define CchSzWToSzA(_szW, _szA, _cbSzA)	\
	WideCharToMultiByte(CP_ACP, 0, (_szW), -1, (_szA), (_cbSzA), NULL, NULL)

#define UsesMakeOLESTRX(_cchMax)	WCHAR szWT[_cchMax]
#define UsesMakeOLESTR				UsesMakeOLESTRX(MAX_PATH)
#define MakeOLESTR(_szA)	\
	(CchSzAToSzW((_szA), szWT, sizeof(szWT)) ? szWT : NULL)

#define UsesMakeANSIX(_cchMax)		CHAR szAT[_cchMax * 2]
#define UsesMakeANSI				UsesMakeANSIX(MAX_PATH)
#define MakeANSI(_szW)		\
	(CchSzWToSzA((_szW), szAT, sizeof(szAT)) ? szAT : NULL)

HRESULT HrSzAFromSzW(LPWSTR szW, LPSTR * psz);

#else	// !WIN32

#define UsesMakeOLESTRX(_cchMax)	/##/
#define UsesMakeOLESTR				/##/
#define MakeOLESTR(_szA)		(_szA)

#define UsesMakeANSIX(_cchMax)		/##/
#define UsesMakeANSI				/##/
#define MakeANSI(_szW)			(_szW)

#endif	// !WIN32

#endif //_OURTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc30\imm.h ===
/**********************************************************************/
/*      IMM.H - Input Method Manager definitions                      */
/*                                                                    */
/*      Copyright (c) 1993-1995  Microsoft Corporation                */
/**********************************************************************/

#ifndef _IMM_
#define _IMM_        // defined if IMM.H has been included

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _WINUSER_
#define VK_PROCESSKEY 0x0E5
#endif

#ifndef IMM_WINVER
#define IMM_WINVER 0x040A
#endif

//#if(IMM_WINVER >= 0x040A)
//DECLARE_HANDLE(HIMC);
//#else
typedef DWORD     HIMC;
//#endif

//#if(IMM_WINVER >= 0x040A)
//DECLARE_HANDLE(HIMCC);
//#else
typedef DWORD     HIMCC;
//#endif

typedef HKL FAR  *LPHKL;
typedef UINT FAR *LPUINT;

#define NULLIMC  ((HIMC)0)

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, NEAR *NPCOMPOSITIONFORM, FAR *LPCOMPOSITIONFORM;

typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, NEAR *NPCANDIDATEFORM, FAR *LPCANDIDATEFORM;

typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, NEAR *NPCANDIDATELIST, FAR *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA, NEAR *NPREGISTERWORDA, FAR *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW, NEAR *NPREGISTERWORDW, FAR *LPREGISTERWORDW;
#ifdef UNICODE
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#else
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#endif // UNICODE

#if(IMM_WINVER >= 0x040A)
typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, NEAR *NPRECONVERTSTRING, FAR *LPRECONVERTSTRING;
#endif

#define STYLE_DESCRIPTION_SIZE  32

typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFA, *PSTYLEBUFA, NEAR *NPSTYLEBUFA, FAR *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFW, *PSTYLEBUFW, NEAR *NPSTYLEBUFW, FAR *LPSTYLEBUFW;
#ifdef UNICODE
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#else
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#endif // UNICODE

#if(IMM_WINVER >= 0x040A)
#define IMEMENUITEM_STRING_SIZE 80 

typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, NEAR *NPIMEMENUITEMINFOA, FAR *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, NEAR *NPIMEMENUITEMINFOW, FAR *LPIMEMENUITEMINFOW;
#ifdef UNICODE
typedef IMEMENUITEMINFOW IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOW PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOW NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOW LPIMEMENUITEMINFO;
#else
typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#endif // UNICODE

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, NEAR *NPIMECHARPOSITION, FAR *LPIMECHARPOSITION;

#endif /* IMM_WINVER >= 0x040A */

// prototype of IMM API

HKL  WINAPI ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
HKL  WINAPI ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);
#ifdef UNICODE
#define ImmInstallIME  ImmInstallIMEW
#else
#define ImmInstallIME  ImmInstallIMEA
#endif // !UNICODE

HWND WINAPI ImmGetDefaultIMEWnd(HWND);

UINT WINAPI ImmGetDescriptionA(HKL, LPSTR, UINT uBufLen);
UINT WINAPI ImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetDescription  ImmGetDescriptionW
#else
#define ImmGetDescription  ImmGetDescriptionA
#endif // !UNICODE

UINT WINAPI ImmGetIMEFileNameA(HKL, LPSTR, UINT uBufLen);
UINT WINAPI ImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetIMEFileName  ImmGetIMEFileNameW
#else
#define ImmGetIMEFileName  ImmGetIMEFileNameA
#endif // !UNICODE

DWORD WINAPI ImmGetProperty(HKL, DWORD);

BOOL WINAPI ImmIsIME(HKL);

BOOL WINAPI ImmSimulateHotKey(HWND, DWORD);

HIMC WINAPI ImmCreateContext(void);
BOOL WINAPI ImmDestroyContext(HIMC);
HIMC WINAPI ImmGetContext(HWND);
BOOL WINAPI ImmReleaseContext(HWND, HIMC);
HIMC WINAPI ImmAssociateContext(HWND, HIMC);
#if(IMM_WINVER >= 0x040A)
BOOL WINAPI ImmAssociateContextEx(HWND, HIMC, DWORD);
#endif /* IMM_WINVER >= 0x040A */

LONG  WINAPI ImmGetCompositionStringA(HIMC, DWORD, LPVOID, DWORD);
LONG  WINAPI ImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD);
#ifdef UNICODE
#define ImmGetCompositionString  ImmGetCompositionStringW
#else
#define ImmGetCompositionString  ImmGetCompositionStringA
#endif // !UNICODE

BOOL  WINAPI ImmSetCompositionStringA(HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);
BOOL  WINAPI ImmSetCompositionStringW(HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);
#ifdef UNICODE
#define ImmSetCompositionString  ImmSetCompositionStringW
#else
#define ImmSetCompositionString  ImmSetCompositionStringA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListCountA(HIMC, LPDWORD);
DWORD WINAPI ImmGetCandidateListCountW(HIMC, LPDWORD);
#ifdef UNICODE
#define ImmGetCandidateListCount  ImmGetCandidateListCountW
#else
#define ImmGetCandidateListCount  ImmGetCandidateListCountA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListA(HIMC, DWORD, LPCANDIDATELIST, DWORD);
DWORD WINAPI ImmGetCandidateListW(HIMC, DWORD, LPCANDIDATELIST, DWORD);
#ifdef UNICODE
#define ImmGetCandidateList  ImmGetCandidateListW
#else
#define ImmGetCandidateList  ImmGetCandidateListA
#endif // !UNICODE

DWORD WINAPI ImmGetGuideLineA(HIMC, DWORD, LPSTR, DWORD);
DWORD WINAPI ImmGetGuideLineW(HIMC, DWORD, LPWSTR, DWORD);
#ifdef UNICODE
#define ImmGetGuideLine  ImmGetGuideLineW
#else
#define ImmGetGuideLine  ImmGetGuideLineA
#endif // !UNICODE

BOOL WINAPI ImmGetConversionStatus(HIMC, LPDWORD, LPDWORD);
BOOL WINAPI ImmSetConversionStatus(HIMC, DWORD, DWORD);
BOOL WINAPI ImmGetOpenStatus(HIMC);
BOOL WINAPI ImmSetOpenStatus(HIMC, BOOL);

BOOL WINAPI ImmGetCompositionFontA(HIMC, LPLOGFONTA);
BOOL WINAPI ImmGetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmGetCompositionFont  ImmGetCompositionFontW
#else
#define ImmGetCompositionFont  ImmGetCompositionFontA
#endif // !UNICODE

BOOL WINAPI ImmSetCompositionFontA(HIMC, LPLOGFONTA);
BOOL WINAPI ImmSetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmSetCompositionFont  ImmSetCompositionFontW
#else
#define ImmSetCompositionFont  ImmSetCompositionFontA
#endif // !UNICODE

BOOL    WINAPI ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID);
BOOL    WINAPI ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID);
#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE

LRESULT WINAPI ImmEscapeA(HKL, HIMC, UINT, LPVOID);
LRESULT WINAPI ImmEscapeW(HKL, HIMC, UINT, LPVOID);
#if 0
#ifdef UNICODE
#define ImmEscape  ImmEscapeW
#else
#define ImmEscape  ImmEscapeA
#endif // !UNICODE
#endif
DWORD   WINAPI ImmGetConversionListA(HKL, HIMC, LPCSTR, LPCANDIDATELIST, DWORD, UINT);
DWORD   WINAPI ImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD, UINT);
#ifdef UNICODE
#define ImmGetConversionList  ImmGetConversionListW
#else
#define ImmGetConversionList  ImmGetConversionListA
#endif // !UNICODE

BOOL    WINAPI ImmNotifyIME(HIMC, DWORD, DWORD, DWORD);

BOOL WINAPI ImmGetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmSetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM);
BOOL WINAPI ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM);

BOOL WINAPI ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM);
BOOL WINAPI ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM);
#ifdef UNICODE
#define ImmIsUIMessage  ImmIsUIMessageW
#else
#define ImmIsUIMessage  ImmIsUIMessageA
#endif // !UNICODE

UINT WINAPI ImmGetVirtualKey(HWND);

typedef int (CALLBACK *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (CALLBACK *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCW
#else
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCA
#endif // !UNICODE

BOOL WINAPI ImmRegisterWordA(HKL, LPCSTR, DWORD, LPCSTR);
BOOL WINAPI ImmRegisterWordW(HKL, LPCWSTR, DWORD, LPCWSTR);
#ifdef UNICODE
#define ImmRegisterWord  ImmRegisterWordW
#else
#define ImmRegisterWord  ImmRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmUnregisterWordA(HKL, LPCSTR, DWORD, LPCSTR);
BOOL WINAPI ImmUnregisterWordW(HKL, LPCWSTR, DWORD, LPCWSTR);
#ifdef UNICODE
#define ImmUnregisterWord  ImmUnregisterWordW
#else
#define ImmUnregisterWord  ImmUnregisterWordA
#endif // !UNICODE

UINT WINAPI ImmGetRegisterWordStyleA(HKL, UINT, LPSTYLEBUFA);
UINT WINAPI ImmGetRegisterWordStyleW(HKL, UINT, LPSTYLEBUFW);
#ifdef UNICODE
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleW
#else
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleA
#endif // !UNICODE

UINT WINAPI ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR, DWORD, LPCSTR, LPVOID);
UINT WINAPI ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define ImmEnumRegisterWord  ImmEnumRegisterWordW
#else
#define ImmEnumRegisterWord  ImmEnumRegisterWordA
#endif // !UNICODE

#if(IMM_WINVER >= 0x040A)
BOOL WINAPI ImmDisableIME(DWORD);
DWORD WINAPI ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA, LPIMEMENUITEMINFOA, DWORD);
DWORD WINAPI ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW, LPIMEMENUITEMINFOW, DWORD);
#ifdef UNICODE
#define ImmGetImeMenuItems  ImmGetImeMenuItemsW
#else
#define ImmGetImeMenuItems  ImmGetImeMenuItemsA
#endif // !UNICODE
#ifdef UNICODE
#define ImmRequestMessage  ImmRequestMessageW
#else
#define ImmRequestMessage  ImmRequestMessageA
#endif // !UNICODE
#endif /* IMM_WINVER >= 0x040A */

// the IME related messages
#define WM_CONVERTREQUESTEX             0x0108
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F

#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286
#define WM_IME_REQUEST                  0x0288

#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291

// wParam for WM_IME_CONTROL                 
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022

// wParam for WM_IME_CONTROL to the soft keyboard
// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE                0x0010
#define NI_CLOSECANDIDATE               0x0011
#define NI_SELECTCANDIDATESTR           0x0012
#define NI_CHANGECANDIDATELIST          0x0013
#define NI_FINALIZECONVERSIONRESULT     0x0014
#define NI_COMPOSITIONSTR               0x0015
#define NI_SETCANDIDATE_PAGESTART       0x0016
#define NI_SETCANDIDATE_PAGESIZE        0x0017
#define NI_IMEMENUSELECTED              0x0018

// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW       0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW     0x80000000
#define ISC_SHOWUIGUIDELINE             0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW    0x0000000F
#define ISC_SHOWUIALL                   0xC000000F

// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE                    0x0001
#define CPS_CONVERT                     0x0002
#define CPS_REVERT                      0x0003
#define CPS_CANCEL                      0x0004

// the modifiers of hot key
#define MOD_ALT                         0x0001
#define MOD_CONTROL                     0x0002
#define MOD_SHIFT                       0x0004

#define MOD_LEFT                        0x8000
#define MOD_RIGHT                       0x4000

#define MOD_ON_KEYUP                    0x0800
#define MOD_IGNORE_ALL_MODIFIER         0x0400

// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_IME_NONIME_TOGGLE           0x10
#define IME_CHOTKEY_SHAPE_TOGGLE                0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE               0x12

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_CLOSE_OPEN                  0x30

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_SHAPE_TOGGLE                0x50
#define IME_KHOTKEY_HANJACONVERT                0x51
#define IME_KHOTKEY_ENGLISH                     0x52

// Windows for Tranditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_IME_NONIME_TOGGLE           0x70
#define IME_THOTKEY_SHAPE_TOGGLE                0x71
#define IME_THOTKEY_SYMBOL_TOGGLE               0x72

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST                0x100
#define IME_HOTKEY_DSWITCH_LAST                 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_HOTKEY_PRIVATE_FIRST                0x200
#define IME_ITHOTKEY_RESEND_RESULTSTR           0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION       0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE             0x202
#define IME_ITHOTKEY_RECONVERTSTRING            0x203
#define IME_HOTKEY_PRIVATE_LAST                 0x21F

// dwSystemInfoFlags bits

// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR                 0x0001
#define GCS_COMPREADATTR                0x0002
#define GCS_COMPREADCLAUSE              0x0004
#define GCS_COMPSTR                     0x0008
#define GCS_COMPATTR                    0x0010
#define GCS_COMPCLAUSE                  0x0020
#define GCS_CURSORPOS                   0x0080
#define GCS_DELTASTART                  0x0100
#define GCS_RESULTREADSTR               0x0200
#define GCS_RESULTREADCLAUSE            0x0400
#define GCS_RESULTSTR                   0x0800
#define GCS_RESULTCLAUSE                0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR                   0x2000
#define CS_NOMOVECARET                  0x4000

// bits of fdwInit of INPUTCONTEXT
// IME version constants
#define IMEVER_0310                     0x0003000A
#define IMEVER_0400                     0x00040000

// IME property bits
#define IME_PROP_AT_CARET               0x00010000
#define IME_PROP_SPECIAL_UI             0x00020000
#define IME_PROP_CANDLIST_START_FROM_1  0x00040000
#define IME_PROP_UNICODE                0x00080000
#define IME_PROP_COMPLETE_ON_UNSELECT   0x00100000

// IME UICapability bits
#define UI_CAP_2700                     0x00000001
#define UI_CAP_ROT90                    0x00000002
#define UI_CAP_ROTANY                   0x00000004

// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR                 0x00000001
#define SCS_CAP_MAKEREAD                0x00000002
#define SCS_CAP_SETRECONVERTSTRING      0x00000004

// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION           0x00000001
#define SELECT_CAP_SENTENCE             0x00000002

// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL                       0x00000001
#define GGL_INDEX                       0x00000002
#define GGL_STRING                      0x00000003
#define GGL_PRIVATE                     0x00000004

// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE            0x00000000
#define GL_LEVEL_FATAL                  0x00000001
#define GL_LEVEL_ERROR                  0x00000002
#define GL_LEVEL_WARNING                0x00000003
#define GL_LEVEL_INFORMATION            0x00000004

// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN                   0x00000000
#define GL_ID_NOMODULE                  0x00000001
#define GL_ID_NODICTIONARY              0x00000010
#define GL_ID_CANNOTSAVE                0x00000011
#define GL_ID_NOCONVERT                 0x00000020
#define GL_ID_TYPINGERROR               0x00000021
#define GL_ID_TOOMANYSTROKE             0x00000022
#define GL_ID_READINGCONFLICT           0x00000023
#define GL_ID_INPUTREADING              0x00000024
#define GL_ID_INPUTRADICAL              0x00000025
#define GL_ID_INPUTCODE                 0x00000026
#define GL_ID_INPUTSYMBOL               0x00000027
#define GL_ID_CHOOSECANDIDATE           0x00000028
#define GL_ID_REVERSECONVERSION         0x00000029
#define GL_ID_PRIVATE_FIRST             0x00008000
#define GL_ID_PRIVATE_LAST              0x0000FFFF

// ID for dwIndex of ImmGetProperty
#define IGP_GETIMEVERSION               (DWORD)(-4)
#define IGP_PROPERTY                    0x00000004
#define IGP_CONVERSION                  0x00000008
#define IGP_SENTENCE                    0x0000000c
#define IGP_UI                          0x00000010
#define IGP_SETCOMPSTR                  0x00000014
#define IGP_SELECT                      0x00000018

// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR                      (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR                  (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE                (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)
#define SCS_SETRECONVERTSTRING          0x00010000
#define SCS_QUERYRECONVERTSTRING        0x00020000

// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT                      0x00
#define ATTR_TARGET_CONVERTED           0x01
#define ATTR_CONVERTED                  0x02
#define ATTR_TARGET_NOTCONVERTED        0x03
#define ATTR_INPUT_ERROR                0x04
#define ATTR_FIXEDCONVERTED             0x05

// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT                     0x0000
#define CFS_RECT                        0x0001
#define CFS_POINT                       0x0002
#define CFS_FORCE_POSITION              0x0020
#define CFS_CANDIDATEPOS                0x0040
#define CFS_EXCLUDE                     0x0080

// conversion direction for ImmGetConversionList
#define GCL_CONVERSION                  0x0001
#define GCL_REVERSECONVERSION           0x0002
#define GCL_REVERSE_LENGTH              0x0003

// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC          0x0000
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_CHINESE               IME_CMODE_NATIVE
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE              IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA              0x0002  // only effect under IME_CMODE_NATIVE
#define IME_CMODE_LANGUAGE              0x0003
#define IME_CMODE_FULLSHAPE             0x0008
#define IME_CMODE_ROMAN                 0x0010
#define IME_CMODE_CHARCODE              0x0020
#define IME_CMODE_HANJACONVERT          0x0040
#define IME_CMODE_SOFTKBD               0x0080
#define IME_CMODE_NOCONVERSION          0x0100
#define IME_CMODE_EUDC                  0x0200
#define IME_CMODE_SYMBOL                0x0400
#define IME_CMODE_FIXED                 0x0800

#define IME_SMODE_NONE                  0x0000
#define IME_SMODE_PLAURALCLAUSE         0x0001
#define IME_SMODE_SINGLECONVERT         0x0002
#define IME_SMODE_AUTOMATIC             0x0004
#define IME_SMODE_PHRASEPREDICT         0x0008
#define IME_SMODE_CONVERSATION          0x0010

// style of candidate
#define IME_CAND_UNKNOWN                0x0000
#define IME_CAND_READ                   0x0001
#define IME_CAND_CODE                   0x0002
#define IME_CAND_MEANING                0x0003
#define IME_CAND_RADICAL                0x0004
#define IME_CAND_STROKE                 0x0005

// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW            0x0001
#define IMN_OPENSTATUSWINDOW             0x0002
#define IMN_CHANGECANDIDATE              0x0003
#define IMN_CLOSECANDIDATE               0x0004
#define IMN_OPENCANDIDATE                0x0005
#define IMN_SETCONVERSIONMODE            0x0006
#define IMN_SETSENTENCEMODE              0x0007
#define IMN_SETOPENSTATUS                0x0008
#define IMN_SETCANDIDATEPOS              0x0009
#define IMN_SETCOMPOSITIONFONT           0x000A
#define IMN_SETCOMPOSITIONWINDOW         0x000B
#define IMN_SETSTATUSWINDOWPOS           0x000C
#define IMN_GUIDELINE                    0x000D
#define IMN_PRIVATE                      0x000E

#if(IMM_WINVER >= 0x040A)
// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW      0x0001
#define IMR_CANDIDATEWINDOW        0x0002
#define IMR_COMPOSITIONFONT        0x0003
#define IMR_RECONVERTSTRING        0x0004
#define IMR_CONFIRMRECONVERTSTRING 0x0005
#define IMR_QUERYCHARPOSITION      0x0006
#define IMR_DOCUMENTFEED           0x0007
#endif

// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA                (-1)
#define IMM_ERROR_GENERAL               (-2)

// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL              1
#define IME_CONFIG_REGISTERWORD         2
#define IME_CONFIG_SELECTDICTIONARY     3

// dialog mode of ImmEscape
#define IME_ESC_QUERY_SUPPORT           0x0003
#define IME_ESC_RESERVED_FIRST          0x0004
#define IME_ESC_RESERVED_LAST           0x07FF
#define IME_ESC_PRIVATE_FIRST           0x0800
#define IME_ESC_PRIVATE_LAST            0x0FFF
#define IME_ESC_SEQUENCE_TO_INTERNAL    0x1001
#define IME_ESC_GET_EUDC_DICTIONARY     0x1003
#define IME_ESC_SET_EUDC_DICTIONARY     0x1004
#define IME_ESC_MAX_KEY                 0x1005
#define IME_ESC_IME_NAME                0x1006
#define IME_ESC_SYNC_HOTKEY             0x1007
#define IME_ESC_HANJA_MODE              0x1008
#define IME_ESC_AUTOMATA                0x1009
#define IME_ESC_PRIVATE_HOTKEY          0x100a
#define IME_ESC_GETHELPFILENAME         0x100b

// style of word registration
#define IME_REGWORD_STYLE_EUDC          0x00000001
#define IME_REGWORD_STYLE_USER_FIRST    0x80000000
#define IME_REGWORD_STYLE_USER_LAST     0xFFFFFFFF

#if(IMM_WINVER >= 0x040A)
// dwFlags for ImmAssociateContextEx
#define IACE_CHILDREN                   0x0001
#define IACE_DEFAULT                    0x0010
#define IACE_IGNORENOCONTEXT            0x0020

// dwFlags for ImmGetImeMenuItems
#define IGIMIF_RIGHTMENU                0x00000001

// dwType for ImmGetImeMenuItems
#define IGIMII_CMODE                    0x00000001
#define IGIMII_SMODE                    0x00000002
#define IGIMII_CONFIGURE                0x00000004
#define IGIMII_TOOLS                    0x00000008
#define IGIMII_HELP                     0x00000010
#define IGIMII_OTHER                    0x00000020
#define IGIMII_INPUTTOOLS               0x00000040

// fType of IMEMENUITEMINFO structure
#define IMFT_RADIOCHECK 0x00001
#define IMFT_SEPARATOR  0x00002
#define IMFT_SUBMENU    0x00004

// fState of IMEMENUITEMINFO structure
#define IMFS_GRAYED          MFS_GRAYED
#define IMFS_DISABLED        MFS_DISABLED
#define IMFS_CHECKED         MFS_CHECKED
#define IMFS_HILITE          MFS_HILITE
#define IMFS_ENABLED         MFS_ENABLED
#define IMFS_UNCHECKED       MFS_UNCHECKED
#define IMFS_UNHILITE        MFS_UNHILITE
#define IMFS_DEFAULT         MFS_DEFAULT
#endif /* IMM_WINVER >= 0x040A */

// type of soft keyboard
// for Windows Tranditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1            0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1            0x0002

#ifdef __cplusplus
}
#endif

#endif  // _IMM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc30\win2mac.h ===
//*******************************************************************
//
//
//		win2mac.h
//
//		Compatability transforms
//
//
//
//*******************************************************************
#ifndef _WIN2MAC_H_
#define _WIN2MAC_H_


#ifdef MACPORT
#define USE_UNICODE_WRAPPER


#if defined(UNICODE)

#include "ourmac.h"
#include "msostd.h"
#include "msostr.h"
#include "msointl.h"
#include <winnls.h>
#include <WINUSER.H>
#include <tchar.h>



//----------------------------------------------------------------------------
// We have to re-define some of the clipboard formats
#ifdef CF_TEXT
#undef CF_TEXT
#endif
#define CF_TEXT cfText

#ifdef CF_UNICODETEXT
#undef CF_UNICODETEXT
#endif
#define CF_UNICODETEXT 'UNIC'

//----------------------------------------------------------------------------
// These are from WINERROR.H which is no longer being included
// now that we compile for native MACOLE
#define ERROR_INVALID_FLAGS              1004L
#define CO_E_RELEASED                    0x800401FFL
#define FACILITY_WIN32 0x0007
#define HRESULT_FROM_WIN32(x) \
     (x ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : 0 )

//----------------------------------------------------------------------------
// maximum unsigned 16 bit value -  from MSDEV\limits.h 
#define _UI16_MAX	  0xffffui16	

//----------------------------------------------------------------------------
// 
// Misc functions/macros
// 
//----------------------------------------------------------------------------
EXTERN_C int __pascal GetLocaleInfoA(LCID, LCTYPE, char FAR*, int);
LRESULT CALLBACK MacRichEditWndProc(HWND, UINT, WPARAM, LPARAM);
UINT MacSimulateKey (UINT& msg, WPARAM& wParam);
UINT MacSimulateMouseButtons (UINT& msg, WPARAM& wParam);

#define ActivateKeyboardLayout(a,b)
#define CreateFileW	CreateFileA	
#define GetHGlobalFromStream(a, b)	GetHGlobalFromStream(a, (Handle *)b)
#define GetProfileIntA(a,b,c)	c
#define OleDuplicateData(a,b,c) OleDuplicateData((Handle)a, b, c)
#define ReleaseStgMedium(a) ReleaseStgMedium((DUAL_STGMEDIUM*)a)

//----------------------------------------------------------------------------
#ifdef  ExtTextOutW
#undef  ExtTextOutW
#endif 
#define ExtTextOutW			MsoExtTextOutW
MSOAPI_(BOOL) MsoTextOutW(HDC, int, int, LPCWSTR, int);

//----------------------------------------------------------------------------
#ifdef  TextOutW
#undef  TextOutW
#endif 
#define TextOutW			MsoTextOutW
MSOAPI_(BOOL) MsoExtTextOutW(HDC, int, int, UINT, CONST RECT *,LPCWSTR, UINT, CONST INT *);

//----------------------------------------------------------------------------
#ifdef  GetTextExtentPointW
#undef  GetTextExtentPointW
#endif 
#define GetTextExtentPointW MsoGetTextExtentPointW
MSOAPI_(BOOL) MsoGetTextExtentPointW(HDC, LPCWSTR, int, LPSIZE);

//----------------------------------------------------------------------------
#ifdef  MultiByteToWideChar
#undef  MultiByteToWideChar
#endif 
#define MultiByteToWideChar	MsoMultiByteToWideChar
		
//----------------------------------------------------------------------------
#ifdef  WideCharToMultiByte
#undef  WideCharToMultiByte
#endif 
#define WideCharToMultiByte	MsoWideCharToMultiByte


//----------------------------------------------------------------------------
//
//	Mac wrappers  
//
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
#ifdef  CoTaskMemAlloc
#undef  CoTaskMemAlloc
#endif
#define CoTaskMemAlloc		MacCoTaskMemAlloc
STDAPI_(LPVOID) MacCoTaskMemAlloc(
			ULONG cb
			);

//----------------------------------------------------------------------------
#ifdef  CoTaskMemRealloc
#undef  CoTaskMemRealloc
#endif
#define CoTaskMemRealloc	MacCoTaskMemRealloc
STDAPI_(LPVOID) MacCoTaskMemRealloc(
			LPVOID pv, 
			ULONG cb
			);

//----------------------------------------------------------------------------
#ifdef  CoTaskMemFree
#undef  CoTaskMemFree
#endif
#define CoTaskMemFree		MacCoTaskMemFree
STDAPI_(void)   MacCoTaskMemFree(
			LPVOID pv
			);

//----------------------------------------------------------------------------
#ifdef  CLSIDFromProgID
#undef  CLSIDFromProgID
#endif 
#define CLSIDFromProgID		MacCLSIDFromProgID
STDAPI  MacCLSIDFromProgID(
			LPCWSTR lpszProgID, 
			LPCLSID lpclsid
			);

//----------------------------------------------------------------------------
#ifdef  DoDragDrop
#undef  DoDragDrop
#endif 
#define DoDragDrop			MacDoDragDrop 
STDAPI  MacDoDragDrop(
			LPDATAOBJECT	pDataObj,
            LPDROPSOURCE	pDropSource,
            DWORD			dwOKEffects,
            LPDWORD         pdwEffect
			);

//----------------------------------------------------------------------------
#ifdef  GetCurrentObject
#undef  GetCurrentObject
#endif 
#define GetCurrentObject			MacGetCurrentObject 
HGDIOBJ WINAPI MacGetCurrentObject(HDC	hdc,  
                                   UINT uObjectType); 
 
//----------------------------------------------------------------------------
#ifdef  GetDoubleClickTime
#undef  GetDoubleClickTime
#endif
#define GetDoubleClickTime	MacGetDoubleClickTime;
UINT MacGetDoubleClickTime();
    
//----------------------------------------------------------------------------
#ifdef  GetMetaFileBitsEx
#undef  GetMetaFileBitsEx
#endif
#define GetMetaFileBitsEx	MacGetMetaFileBitsEx
UINT WINAPI MacGetMetaFileBitsEx(
			HMETAFILE  hmf,    
			UINT  nSize,    
			LPVOID  lpvData   
			);

//----------------------------------------------------------------------------
#ifdef  IsValidCodePage
#undef  IsValidCodePage
#endif 
#define IsValidCodePage		MacIsValidCodePage
WINBASEAPI BOOL WINAPI MacIsValidCodePage(
			UINT  CodePage
			);

//----------------------------------------------------------------------------
#ifdef  OleDraw 
#undef  OleDraw 
#endif 
#define OleDraw				MacOleDraw
STDAPI  MacOleDraw(
			IUnknown *	pUnk,
			DWORD		dwAspect, 
			HDC			hdcDraw, 
			LPCRECT		lprcBounds
			);

//----------------------------------------------------------------------------
#ifdef  ProgIDFromCLSID
#undef  ProgIDFromCLSID
#endif 
#define ProgIDFromCLSID		MacProgIDFromCLSID
STDAPI  MacProgIDFromCLSID(
			REFCLSID clsid, 
			LPWSTR FAR* lplpszProgID
			);

//----------------------------------------------------------------------------
#ifdef  RegisterDragDrop
#undef  RegisterDragDrop
#endif 
#define RegisterDragDrop	MacRegisterDragDrop
STDAPI  MacRegisterDragDrop(
			HWND			hwnd, 
            LPDROPTARGET	pDropTarget
			);

//----------------------------------------------------------------------------
#ifdef  RevokeDragDrop
#undef  RevokeDragDrop
#endif 
#define RevokeDragDrop		MacRevokeDragDrop
STDAPI  MacRevokeDragDrop(
			HWND hwnd
			);

//----------------------------------------------------------------------------
#ifdef  SelectPalette 
#undef  SelectPalette 
#endif 
#define SelectPalette		MacSelectPalette
HPALETTE WINAPI MacSelectPalette(
			HDC,
			HPALETTE,
			BOOL
			);

//----------------------------------------------------------------------------
#ifdef  SetCursor 
#undef  SetCursor
#endif
// note we have not named this MacSetCursor 
// since this function already exists in WLM
#define SetCursor			MacportSetCursor
HCURSOR MacportSetCursor(
			HCURSOR  hCursor 	
			);

//----------------------------------------------------------------------------
#ifdef  SetMetaFileBitsEx
#undef  SetMetaFileBitsEx
#endif
#define SetMetaFileBitsEx	MacSetMetaFileBitsEx
HMETAFILE WINAPI MacSetMetaFileBitsEx(
			UINT  nSize,
			CONST BYTE *  lpData 
			);

//----------------------------------------------------------------------------
#ifdef  SysAllocStringLen
#undef  SysAllocStringLen 
#endif 
#define SysAllocStringLen	MacSysAllocStringLen
STDAPI_(BSTR) MacSysAllocStringLen(
			LPCWSTR, 
			UINT
			);

//----------------------------------------------------------------------------
#ifdef  WORDSWAPLONG
#undef  WORDSWAPLONG      
#endif 
#define WORDSWAPLONG		MacWordSwapLong
ULONG	MacWordSwapLong( 
			ULONG ul
			);

#endif //UNICODE

#endif //MACPORT

#endif // _WIN2MAC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc30\richole.h ===
#ifndef _RICHOLE_
#define _RICHOLE_

/*
 *	RICHOLE.H
 *
 *	Purpose:
 *		OLE Extensions to the Rich Text Editor
 *
 *	Copyright (c) 1985-1996, Microsoft Corporation
 */

// Structure passed to GetObject and InsertObject
typedef struct _reobject
{
	DWORD			cbStruct;			// Size of structure
	LONG			cp;					// Character position of object
	CLSID			clsid;				// Class ID of object
	LPOLEOBJECT		poleobj;			// OLE object interface
	LPSTORAGE		pstg;				// Associated storage interface
	LPOLECLIENTSITE	polesite;			// Associated client site interface
	SIZEL			sizel;				// Size of object (may be 0,0)
	DWORD			dvaspect;			// Display aspect to use
	DWORD			dwFlags;			// Object status flags
	DWORD			dwUser;				// Dword for user's use
} REOBJECT;

// Flags to specify which interfaces should be returned in the structure above
#define REO_GETOBJ_NO_INTERFACES	(0x00000000L)
#define REO_GETOBJ_POLEOBJ			(0x00000001L)
#define REO_GETOBJ_PSTG				(0x00000002L)
#define REO_GETOBJ_POLESITE			(0x00000004L)
#define REO_GETOBJ_ALL_INTERFACES	(0x00000007L)

// Place object at selection
#define REO_CP_SELECTION ((ULONG) -1L)

// Use character position to specify object instead of index
#define REO_IOB_SELECTION ((ULONG) -1L)
#define REO_IOB_USE_CP ((ULONG) -2L)

// Object flags
#define REO_NULL			(0x00000000L)	// No flags
#define REO_READWRITEMASK	(0x0000007FL)	// Mask out RO bits
#define REO_OWNERDRAWSELECT	(0x00000040L)	// Owner draws selected object
#define REO_DONTNEEDPALETTE	(0x00000020L)	// Object doesn't need palette
#define REO_BLANK			(0x00000010L)	// Object is blank
#define REO_DYNAMICSIZE		(0x00000008L)	// Object defines size always
#define REO_INVERTEDSELECT	(0x00000004L)	// Object drawn all inverted if sel
#define REO_BELOWBASELINE	(0x00000002L)	// Object sits below the baseline
#define REO_RESIZABLE		(0x00000001L)	// Object may be resized
#define REO_LINK			(0x80000000L)	// Object is a link (RO)
#define REO_STATIC			(0x40000000L)	// Object is static (RO)
#define REO_SELECTED		(0x08000000L)	// Object selected (RO)
#define REO_OPEN			(0x04000000L)	// Object open in its server (RO)
#define REO_INPLACEACTIVE	(0x02000000L)	// Object in place active (RO)
#define REO_HILITED			(0x01000000L)	// Object is to be hilited (RO)
#define REO_LINKAVAILABLE	(0x00800000L)	// Link believed available (RO)
#define REO_GETMETAFILE		(0x00400000L)	// Object requires metafile (RO)

// flags for IRichEditOle::GetClipboardData(),
// IRichEditOleCallback::GetClipboardData() and
// IRichEditOleCallback::QueryAcceptData()
#define RECO_PASTE			(0x00000000L)	// paste from clipboard
#define RECO_DROP			(0x00000001L)	// drop
#define RECO_COPY			(0x00000002L)	// copy to the clipboard
#define RECO_CUT			(0x00000003L)	// cut to the clipboard
#define RECO_DRAG			(0x00000004L)	// drag

/*
 *	IRichEditOle
 *
 *	Purpose:
 *		Interface used by the client of RichEdit to perform OLE-related
 *		operations.
 *
 *	//$ REVIEW:
 *		The methods herein may just want to be regular Windows messages.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOle

DECLARE_INTERFACE_(IRichEditOle, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOle methods ***
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR * lplpolesite) PURE;
	STDMETHOD_(LONG,GetObjectCount) (THIS) PURE;
	STDMETHOD_(LONG,GetLinkCount) (THIS) PURE;
	STDMETHOD(GetObject) (THIS_ LONG iob, REOBJECT FAR * lpreobject,
						  DWORD dwFlags) PURE;
    STDMETHOD(InsertObject) (THIS_ REOBJECT FAR * lpreobject) PURE;
	STDMETHOD(ConvertObject) (THIS_ LONG iob, REFCLSID rclsidNew,
							  LPCSTR lpstrUserTypeNew) PURE;
	STDMETHOD(ActivateAs) (THIS_ REFCLSID rclsid, REFCLSID rclsidAs) PURE;
	STDMETHOD(SetHostNames) (THIS_ LPCSTR lpstrContainerApp,
							 LPCSTR lpstrContainerObj) PURE;
	STDMETHOD(SetLinkAvailable) (THIS_ LONG iob, BOOL fAvailable) PURE;
	STDMETHOD(SetDvaspect) (THIS_ LONG iob, DWORD dvaspect) PURE;
	STDMETHOD(HandsOffStorage) (THIS_ LONG iob) PURE;
	STDMETHOD(SaveCompleted) (THIS_ LONG iob, LPSTORAGE lpstg) PURE;
	STDMETHOD(InPlaceDeactivate) (THIS) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(ImportDataObject) (THIS_ LPDATAOBJECT lpdataobj,
									CLIPFORMAT cf, HGLOBAL hMetaPict) PURE;
};
typedef         IRichEditOle FAR * LPRICHEDITOLE;

/*
 *	IRichEditOleCallback
 *
 *	Purpose:
 *		Interface used by the RichEdit to get OLE-related stuff from the
 *		application using RichEdit.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOleCallback

DECLARE_INTERFACE_(IRichEditOleCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOleCallback methods ***
	STDMETHOD(GetNewStorage) (THIS_ LPSTORAGE FAR * lplpstg) PURE;
    STDMETHOD(GetInPlaceContext) (THIS_ LPOLEINPLACEFRAME FAR * lplpFrame,
								  LPOLEINPLACEUIWINDOW FAR * lplpDoc,
								  LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
	STDMETHOD(ShowContainerUI) (THIS_ BOOL fShow) PURE;
	STDMETHOD(QueryInsertObject) (THIS_ LPCLSID lpclsid, LPSTORAGE lpstg,
									LONG cp) PURE;
	STDMETHOD(DeleteObject) (THIS_ LPOLEOBJECT lpoleobj) PURE;
	STDMETHOD(QueryAcceptData) (THIS_ LPDATAOBJECT lpdataobj,
								CLIPFORMAT FAR * lpcfFormat, DWORD reco,
								BOOL fReally, HGLOBAL hMetaPict) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(GetDragDropEffect) (THIS_ BOOL fDrag, DWORD grfKeyState,
									LPDWORD pdwEffect) PURE;
	STDMETHOD(GetContextMenu) (THIS_ WORD seltype, LPOLEOBJECT lpoleobj,
									CHARRANGE FAR * lpchrg,
									HMENU FAR * lphmenu) PURE;
};
typedef         IRichEditOleCallback FAR * LPRICHEDITOLECALLBACK;

#ifndef MAC
// RichEdit interface GUIDs
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif // !MAC

#endif // _RICHOLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplus.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus.hpp
*
* Abstract:
*
*   GDI+ Native C++ public header file
*
* Revision History:
*
*   03/03/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUS_H
#define _GDIPLUS_H

struct IDirectDrawSurface7;

namespace Gdiplus
{
    namespace DllExports
    {
        #include "GdiplusMem.h"
    };

    #include "GdiplusBase.h"

    // The following headers are used internally as well
    #include "GdiplusEnums.h"
    #include "GdiplusTypes.h"
    #include "GdiplusPixelFormats.h"
    #include "GdiplusColor.h"
    #include "GdiplusMetaHeader.h"
    #include "GdiplusImaging.h"
    #include "imaging.h"
    #include "GdiplusColorMatrix.h"

    // The rest of these are used only by the application

    #include "GdiplusGpStubs.h"
    #include "GdiplusHeaders.h"

    namespace DllExports
    {
        #include "GdiplusFlat.h"
    };


    #include "GdiplusImageAttributes.h"
    #include "GdiplusMatrix.h"
    #include "GdiplusBrush.h"
    #include "GdiplusPen.h"
    #include "GdiplusStringFormat.h"
    #include "GdiplusPath.h"
    #include "GdiplusLineCaps.h"
    #include "GdiplusMetafile.h"
    #include "GdiplusGraphics.h"
    #include "GdiplusCachedBitmap.h"
    #include "GdiplusRegion.h"
    #include "GdiplusFontCollection.h"
    #include "GdiplusFontFamily.h"
    #include "GdiplusFont.h"
    #include "GdiplusBitmap.h"
    #include "GdiplusImageCodec.h"

}; // namespace Gdiplus

#endif // !_GDIPLUS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\ct_ras_win.h ===
/*

Copyright (c) 1999  Microsoft Corporation

******************************
*** Microsoft Confidential ***
******************************

Module Name:

    CT_Ras_Win.h

Author: 

  Paul Linnerud (paulli@microsoft.com)

Abstract:

    This module defines the API mapping layer for the standalone implementation of the ClearType
	rasterizer. Applications written to use the Win32 API should make use of these functions to
	output using ClearType.

Revision History:

*/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _CT_Ras_Win_
#define _CT_Ras_Win_

#if !defined(_CTWAPI_LIB_)
#define CTWAPI __declspec(dllimport)
#else
#define CTWAPI
#endif

/* defines */

typedef void *(__cdecl *CTWAPI_ALLOCPROC)(ULONG ulSize);
typedef void *(__cdecl *CTWAPI_REALLOCPROC)(void * pMem, ULONG ulSize);
typedef void  (__cdecl *CTWAPI_FREEPROC)(void * pMem);

typedef struct
{
	CTWAPI_ALLOCPROC fnAlloc; 
	CTWAPI_REALLOCPROC fnReAlloc; 
	CTWAPI_FREEPROC fnFree;
} CTWAPIMEMORYFUNCTIONS, *PCTWAPIMEMORYFUNCTIONS;

typedef HANDLE WAPIFONTINSTANCEHANDLE;

typedef struct
{
	ULONG ulStructSize;

	/* System Parameters */
	BOOL bBGR;
	BOOL bHorizontal;

	// gamma clamp
	ULONG ulGammaBottom, ulGammaTop;

	/* User Parameters */
	// color filter
	ULONG ulColorThreshold;
	ULONG ulCLFRedFactor;
	ULONG ulCLFGreenFactor;

	// blue color filter
	ULONG ulBlueColorThreshold;
	ULONG ulBCLFGreenFactor;
	ULONG ulBCLFBlueFactor;
	ULONG ulBCLFRedFactor;
}CTWAPIPARAMS, *PCTWAPIPARAMS;

/* Fetch last error. */
CTWAPI LONG WINAPI WAPI_CTGetLastError();

/* Override the default memory handler. Optional function only should be called once per process and
before any other functions in this module are called. */
CTWAPI BOOL WAPI_CTOverrideDefaultMemoryFunctions(PCTWAPIMEMORYFUNCTIONS pMemFunctionStruct);

/* Functions to manage an instance of a font. */

/* From a handle to a DC, create a FONTINSTANCE handle. */
CTWAPI WAPIFONTINSTANCEHANDLE WINAPI WAPI_CTCreateFontInstance(HDC hDC, DWORD dwFlags);

/* Delete a FONTINSTANCE handle. */
CTWAPI BOOL WINAPI WAPI_CTDeleteFontInstance(WAPIFONTINSTANCEHANDLE hFontInstance);

/* Information functions. */

/* Return the family name for the font. */
CTWAPI LONG WINAPI WAPI_CTGetTextFaceW(WAPIFONTINSTANCEHANDLE hFontInstance, LONG lCount, PWSTR pTextFace);

/* Get the TEXTMETRICW structure. */
CTWAPI BOOL WINAPI WAPI_CTGetTextMetricsW(WAPIFONTINSTANCEHANDLE hFontInstance, PTEXTMETRICW ptm);

/* Get the OUTLINETEXTMETRICW structure. */
CTWAPI ULONG WINAPI WAPI_CTGetOutlineTextMetricsW(WAPIFONTINSTANCEHANDLE hFontInstance, ULONG ulcData, POUTLINETEXTMETRICW potm);

/* Get the ABC widths. */
CTWAPI BOOL WINAPI WAPI_CTGetCharABCWidthsW(WAPIFONTINSTANCEHANDLE hFontInstance, WCHAR wFirstChar, WCHAR wLastChar, PABC pabc);
CTWAPI BOOL WINAPI WAPI_CTGetCharABCWidthsI(WAPIFONTINSTANCEHANDLE hFontInstance, WCHAR wFirstChar, WCHAR wLastChar, PABC pabc);

/* Get the char widths. */
CTWAPI BOOL WINAPI WAPI_CTGetCharWidthW(WAPIFONTINSTANCEHANDLE hFontInstance, WCHAR wFirstChar, WCHAR wLastChar, PLONG plWidths);
CTWAPI BOOL WINAPI WAPI_CTGetCharWidthI(WAPIFONTINSTANCEHANDLE hFontInstance, WCHAR wFirstChar, WCHAR wLastChar, PLONG plWidths);

/* GetTextExtentPoint */
CTWAPI BOOL WINAPI WAPI_CTGetTextExtentPointW(WAPIFONTINSTANCEHANDLE hFontInstance, PWSTR pString, LONG lCount, PSIZE pSize);

/* GetTextExtentExPoint */
CTWAPI BOOL WINAPI WAPI_CTGetTextExtentExPointW(WAPIFONTINSTANCEHANDLE hFontInstance, PWSTR pString, LONG lCount, LONG lMaxExtent,
										PLONG pnFit, PLONG apDx, PSIZE pSize);

/* Modes */
CTWAPI COLORREF WINAPI WAPI_CTSetTextColor(WAPIFONTINSTANCEHANDLE hFontInstance, COLORREF crColor);

CTWAPI COLORREF WINAPI WAPI_CTGetTextColor(WAPIFONTINSTANCEHANDLE hFontInstance);

CTWAPI COLORREF WINAPI WAPI_CTSetBkColor(WAPIFONTINSTANCEHANDLE hFontInstance, COLORREF crColor);

CTWAPI COLORREF WINAPI WAPI_CTGetBkColor(WAPIFONTINSTANCEHANDLE hFontInstance);

CTWAPI LONG WINAPI WAPI_CTSetBkMode(WAPIFONTINSTANCEHANDLE hFontInstance, LONG lBkMode);

/* Supports opaque and transparent with solid color. Note that we need to know the background color for the
ClearType algorithm so even in transparent mode, the correct color must be set prior to rendering text. */
CTWAPI LONG WINAPI WAPI_CTGetBkMode(WAPIFONTINSTANCEHANDLE hFontInstance);

/* Set text alignment supporting TA_BASELINE, TA_TOP, TA_CENTER, TA_LEFT, TA_RIGHT. */
CTWAPI ULONG WINAPI WAPI_CTSetTextAlign(WAPIFONTINSTANCEHANDLE hFontInstance, ULONG fMode);

/* Get text alignment supporting TA_BASELINE, TA_TOP, TA_CENTER, TA_LEFT, TA_RIGHT.*/
CTWAPI ULONG WINAPI WAPI_CTGetTextAlign(WAPIFONTINSTANCEHANDLE hFontInstance);

CTWAPI BOOL WINAPI WAPI_CTSetSystemParameters(PCTWAPIPARAMS pParams);
CTWAPI BOOL WINAPI WAPI_CTSetUserParameters(PCTWAPIPARAMS pParams);
CTWAPI BOOL WINAPI WAPI_CTGetParameters(PCTWAPIPARAMS pParams);
CTWAPI BOOL WINAPI WAPI_CTRestoreDefaultParameters();

/* Output functions. */

/* Output the text the basic way. */
CTWAPI BOOL WINAPI WAPI_CTTextOutW(WAPIFONTINSTANCEHANDLE hFontInstance, HDC hdc, LONG lXStart, LONG lYStart, PWSTR pString, LONG lCount);

/* Output text via glyph index. */
CTWAPI BOOL WINAPI WAPI_CTTextOutI(WAPIFONTINSTANCEHANDLE hFontInstance, HDC hdc, LONG lXStart, LONG lYStart, PWSTR pString, LONG lCount);

/* Output the text with limited  extended functionality. 
	supports: lpDx and flags ETO_GLYPH_INDEX and ETO_PDY and ETO_OPAQUE. */
CTWAPI BOOL WINAPI WAPI_CTExtTextOutW(WAPIFONTINSTANCEHANDLE hFontInstance, HDC hdc, LONG lXStart, LONG lYStart, DWORD dwOptions,
							  CONST RECT* lprc, PWSTR pString, ULONG ulCount, CONST LONG *lpDx);

/* Alternative EZ functions that trade off speed for being easier to use and integrate. Functions are DC based so we store
	the WAPIFONTINSTANCEHANDLE internally and must find it for each function. Additional time is also taken since we fetch
	the various modes from DC for each call. Any support limitations mentioned above with faster functions also apply to the
	EZ functions. */

CTWAPI BOOL WINAPI WAPI_EZCTCreateFontInstance(HDC hDC, DWORD dwFlags);

CTWAPI BOOL WINAPI WAPI_EZCTDeleteFontInstance(HFONT hFont);

// can be used to get WAPIFONTINSTANCEHANDLE from DC so additional function above such as WAPI_CTGetTextMetrics may be used.
CTWAPI WAPIFONTINSTANCEHANDLE WINAPI WAPI_EZCTDcToFontInst(HDC hDC);

CTWAPI BOOL WINAPI WAPI_EZCTTextOutW(HDC hDC, LONG lXStart, LONG lYStart, PWSTR pString, LONG lCount);

CTWAPI BOOL WINAPI WAPI_EZCTTextOutI(HDC hDC, LONG lXStart, LONG lYStart, PWSTR pString, LONG lCount);

CTWAPI BOOL WINAPI WAPI_EZCTExtTextOutW(HDC hDC, LONG lXStart, LONG lYStart, DWORD dwOptions,
							  CONST RECT* lprc, PWSTR pString, ULONG ulCount, CONST LONG *lpDx);

CTWAPI BOOL WINAPI WAPI_EZCTGetCharABCWidthsW(HDC hDC, WCHAR wFirstChar, WCHAR wLastChar, PABC pabc);

CTWAPI BOOL WINAPI WAPI_EZCTGetCharABCWidthsI(HDC hDC, WCHAR wFirstChar, WCHAR wLastChar, PABC pabc);

CTWAPI BOOL WINAPI WAPI_EZCTGetCharWidthW(HDC hDC, WCHAR wFirstChar, WCHAR wLastChar, PLONG plWidths);

CTWAPI BOOL WINAPI WAPI_EZCTGetCharWidthI(HDC hDC, WCHAR wFirstChar, WCHAR wLastChar, PLONG plWidths);


#endif /* _CT_Ras_Win_ */

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc30\zmouse.h ===
/******************************************************************************\
*       ZMOUSE.H - Include file for MSDELTA Zoom mouse DLL. 
*
*       AUTHOR - Paul Henderson, July 1995
*                Lora McCambridge January 1996
*       REVISIONS - 
*        Lora McCambridge April 1996 - removing WM_MOUSEWHEEL, this
*             message will only be available via the OS.  Applications
*             must now register the message MSH_MOUSEWHEEL, and
*             use that message for messages from MSWHEEL.  
*       LKM May 1996 - Added add'l #defines for class and title of the wheel
*                      module window to reflect the MSH_ style.
*                    - Added #defines for WHEEL SUPPORT and Scroll Lines
*                    - Added inline function HwndMsWheel, apps can use
*                      this function to retrieve the handle to mswheel,
*                      get the message ID's for the registered messages,
*                      the flag for 3d support, and the value for scroll
*                      lines. Please in function at end of file.
*
*       Copyright (C) 1995, 1996 Microsoft Corporation.
*       All rights reserved. 
\******************************************************************************/


/**************************************************************************
	 Client Appplication (API) Defines for Wheel rolling
***************************************************************************/


// Apps need to call RegisterWindowMessage using the #define below to
// get the message number that is sent to the foreground window
// when a wheel roll occurs

#define MSH_MOUSEWHEEL "MSWHEEL_ROLLMSG"
   // wParam = zDelta expressed in multiples of WHEEL_DELTA
   // lParam is the mouse coordinates

#define WHEEL_DELTA      120      // Default value for rolling one detent


#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL (WM_MOUSELAST+1)  // message that will be supported
                                        // by the OS 
#endif


/**************************************************************************
    Client Appplication (API) Defines for
	 determining 3D support active
	 determining # of Scroll Lines
***************************************************************************/

// Class name for Magellan/Z MSWHEEL window
// use FindWindow to get hwnd to MSWHEEL
#define MOUSEZ_CLASSNAME  "MouseZ"           // wheel window class  
#define MOUSEZ_TITLE      "Magellan MSWHEEL" // wheel window title

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

// Apps need to call RegisterWindowMessage using the #defines below to
// get the message number that can be sent to the MSWHEEL window to
// query if wheel support is active (MSH_WHEELSUPPORT), and the message
// number to query the number of scroll lines (MSH_SCROLLLINES).  
// To send a message to MSWheel window, use FindWindow with the #defines
// for CLASS and TITLE above.  If FindWindow fails to find the MSWHEEL
// window or the return from SendMessage is false, then Wheel support
// is currently not available.

#define MSH_WHEELSUPPORT "MSH_WHEELSUPPORT_MSG" // name of msg to send
                                                // to query for wheel support
// MSH_WHEELSUPPORT
//    wParam - not used 
//    lParam - not used
//    returns BOOL - TRUE if wheel support is active, FALSE otherwise

                                
#define MSH_SCROLL_LINES "MSH_SCROLL_LINES_MSG"

// MSH_SCROLL_LINES
//    wParam - not used 
//    lParam - not used
//    returns int  - number of lines to scroll on a wheel roll

#ifndef  WHEEL_PAGESCROLL  
#define WHEEL_PAGESCROLL  (UINT_MAX)    // signifies to scroll a page, to
					// be defined in updated winuser.h
					// in SDK release for NT4.0
#endif 


// NB!! The remainder of the original header file has been deleted since it
// doesn't compile.  RichEdit doesn't need the remainder in any event.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusbase.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Base
*
* Abstract:
*
*   Represents the base class for GDIPlus memory allocation. 
*
* Revision History:
*
*   04/27/2000 gillesk
*       
*
\**************************************************************************/

#ifndef _GDIPLUSBASE_H
#define _GDIPLUSBASE_H

class GdiplusBase
{
public:
    void (operator delete)(void* in_pVoid)
    {
       DllExports::GdipFree(in_pVoid);
    }
    void* (operator new)(size_t in_size)
    {
       return DllExports::GdipAlloc(in_size);
    }
    void (operator delete[])(void* in_pVoid)
    {
       DllExports::GdipFree(in_pVoid);
    }
    void* (operator new[])(size_t in_size)
    {
       return DllExports::GdipAlloc(in_size);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusbitmap.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Bitmap.hpp
*
* Abstract:
*
*   Bitmap related declarations
*
* Revision History:
*
*   4/26/2000 ericvan
*       Update header files.
*
*   12/09/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSBITMAP_H
#define _GDIPLUSBITMAP_H

// NOTE:
//  Our current choice for the public API is to use constructors
//  instead of static load functions to create image objects.
//
//  I've kept the static load functions here for now so that
//  existing test programs are not broken. But they should
//  eventually be taken out.

#ifndef DCR_USE_NEW_140782

inline 
Image::Image(
    IN const WCHAR* filename
    )
{
    nativeImage = NULL;
    lastResult = DllExports::GdipLoadImageFromFile(filename, &nativeImage);
}

inline 
Image::Image(
    IN IStream* stream
    )
{
    nativeImage = NULL;
    lastResult = DllExports::GdipLoadImageFromStream(stream, &nativeImage);
}

inline Image* 
Image::FromFile(
    IN const WCHAR* filename
    )
{
    return new Image(filename);
}

inline Image*
Image::FromStream(
    IN IStream* stream
    )
{
    return new Image(stream);
}

#else

inline 
Image::Image(
    IN const WCHAR* filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    nativeImage = NULL;
    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipLoadImageFromFileICM(
            filename, 
            &nativeImage
        );
    }
    else
    {      
        lastResult = DllExports::GdipLoadImageFromFile(
            filename, 
            &nativeImage
        );
    }
}

inline 
Image::Image(
    IN IStream* stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    nativeImage = NULL;
    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipLoadImageFromStreamICM(
            stream, 
            &nativeImage
        );
    }
    else
    {
        lastResult = DllExports::GdipLoadImageFromStream(
            stream, 
            &nativeImage
        );
    }
}

inline Image* 
Image::FromFile(
    IN const WCHAR* filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Image(
        filename, 
        useEmbeddedColorManagement
    );
}

inline Image*
Image::FromStream(
    IN IStream* stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Image(
        stream,
        useEmbeddedColorManagement
    );
}

#endif

inline 
Image::~Image()
{
    DllExports::GdipDisposeImage(nativeImage);
}

inline Image* 
Image::Clone() 
{
    GpImage *cloneimage = NULL;

    SetStatus(DllExports::GdipCloneImage(nativeImage, &cloneimage));

    return new Image(cloneimage, lastResult);
}

// Encorder Parameter

inline UINT
Image::GetEncoderParameterListSize(
    IN const CLSID* clsidEncoder
    ) 
{
    UINT size = 0;

    SetStatus(DllExports::GdipGetEncoderParameterListSize(nativeImage,
                                                          clsidEncoder,
                                                          &size));
    return size;
}

inline Status
Image::GetEncoderParameterList(
    IN const CLSID* clsidEncoder,
    IN UINT size,
    OUT EncoderParameters* buffer
    )
{
    return SetStatus(DllExports::GdipGetEncoderParameterList(nativeImage,
                                                             clsidEncoder,
                                                             size,
                                                             buffer));
}

// Save images

inline Status
Image::Save(
    IN const WCHAR* filename,
    IN const CLSID* clsidEncoder,
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveImageToFile(nativeImage,
                                                     filename,
                                                     clsidEncoder,
                                                     encoderParams));
}

inline Status
Image::Save(
    IN IStream* stream,
    IN const CLSID* clsidEncoder,
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveImageToStream(nativeImage,
                                                       stream,
                                                       clsidEncoder,
                                                       encoderParams));
}

inline Status
Image::SaveAdd(
    IN const EncoderParameters *encoderParams
    )
{
    return SetStatus(DllExports::GdipSaveAdd(nativeImage,
                                             encoderParams));
}

inline Status
Image::SaveAdd(
    IN Image* newImage,
    IN const EncoderParameters *encoderParams
    )
{
    if ( newImage == NULL )
    {
        return SetStatus(InvalidParameter);
    }

    return SetStatus(DllExports::GdipSaveAddImage(nativeImage,
                                                  newImage->nativeImage,
                                                  encoderParams));
}

// Get size and type information
inline ImageType 
Image::GetType() const
{
    ImageType type = ImageTypeUnknown;

    SetStatus(DllExports::GdipGetImageType(nativeImage, &type));

    return type;
}

inline Status 
Image::GetPhysicalDimension(
    OUT SizeF* size
    ) 
{
    if (size == NULL) 
    {
        return SetStatus(InvalidParameter);
    }
    
    REAL width, height;
    Status status;

    status = SetStatus(DllExports::GdipGetImageDimension(nativeImage,
                                                         &width, &height));

    size->Width  = width;
    size->Height = height;

    return status;
}

inline Status 
Image::GetBounds(
    OUT RectF *srcRect, 
    OUT Unit *srcUnit
    )
{
    return SetStatus(DllExports::GdipGetImageBounds(nativeImage,
                                                    srcRect, srcUnit));
}

inline UINT 
Image::GetWidth()
{
    UINT width = 0;

    SetStatus(DllExports::GdipGetImageWidth(nativeImage, &width));

    return width;
}

inline UINT 
Image::GetHeight()
{
    UINT height = 0;

    SetStatus(DllExports::GdipGetImageHeight(nativeImage, &height));

    return height;
}

inline REAL 
Image::GetHorizontalResolution()
{
    REAL resolution = 0.0f;

    SetStatus(DllExports::GdipGetImageHorizontalResolution(nativeImage, &resolution));

    return resolution;
}

inline REAL 
Image::GetVerticalResolution()
{
    REAL resolution = 0.0f;

    SetStatus(DllExports::GdipGetImageVerticalResolution(nativeImage, &resolution));

    return resolution;
}

inline UINT 
Image::GetFlags()
{
    UINT flags = 0;

    SetStatus(DllExports::GdipGetImageFlags(nativeImage, &flags));

    return flags;
}

inline Status 
Image::GetRawFormat(OUT GUID *format)
{
    return SetStatus(DllExports::GdipGetImageRawFormat(nativeImage, format));
}

inline PixelFormat 
Image::GetPixelFormat()
{
    PixelFormat format;

    SetStatus(DllExports::GdipGetImagePixelFormat(nativeImage, &format));

    return format;
}

inline INT 
Image::GetPaletteSize()
{
    INT size = 0;
    
    SetStatus(DllExports::GdipGetImagePaletteSize(nativeImage, &size));
    
    return size;
}

inline Status 
Image::GetPalette(
    OUT ColorPalette *palette,
    IN INT size
)
{
    return SetStatus(DllExports::GdipGetImagePalette(nativeImage, palette, size));
}

inline Status 
Image::SetPalette(
    IN const ColorPalette *palette
    )
{
    return SetStatus(DllExports::GdipSetImagePalette(nativeImage, palette));
}

// Thumbnail support

inline Image* 
Image::GetThumbnailImage(
    IN UINT thumbWidth,
    IN UINT thumbHeight,
    IN GetThumbnailImageAbort callback,
    IN VOID* callbackData
    )
{
    GpImage *thumbimage = NULL;

    SetStatus(DllExports::GdipGetImageThumbnail(nativeImage,
                                                thumbWidth, thumbHeight,
                                                &thumbimage,
                                                callback, callbackData));

    Image *newImage = new Image(thumbimage, lastResult);

    if (newImage == NULL) 
    {
        DllExports::GdipDisposeImage(thumbimage);
    }

    return newImage;
}

// Multi-frame support
inline UINT 
Image::GetFrameDimensionsCount()
{
    UINT count = 0;

    SetStatus(DllExports::GdipImageGetFrameDimensionsCount(nativeImage,
                                                                  &count));

    return count;
}

inline Status 
Image::GetFrameDimensionsList(
    OUT GUID* dimensionIDs, 
    IN UINT count
    )
{
    return SetStatus(DllExports::GdipImageGetFrameDimensionsList(nativeImage,
                                                                 dimensionIDs,
                                                                 count));
}

inline UINT 
Image::GetFrameCount(
    IN const GUID* dimensionID
    )
{
    UINT count = 0;

    SetStatus(DllExports::GdipImageGetFrameCount(nativeImage,
                                                        dimensionID,
                                                        &count));
    return count;
}

inline Status 
Image::SelectActiveFrame(
    IN const GUID *dimensionID, 
    IN UINT frameIndex
    )
{
    return SetStatus(DllExports::GdipImageSelectActiveFrame(nativeImage,
                                                            dimensionID,
                                                            frameIndex));
}

// Image property related functions

inline UINT 
Image::GetPropertyCount()
{
    UINT numProperty = 0;

    SetStatus(DllExports::GdipGetPropertyCount(nativeImage,
                                               &numProperty));

    return numProperty;
}

inline Status 
Image::GetPropertyIdList(
    IN UINT numOfProperty, 
    OUT PROPID* list
    )
{
    return SetStatus(DllExports::GdipGetPropertyIdList(nativeImage,
                                                       numOfProperty, list));
}
    
inline UINT 
Image::GetPropertyItemSize(
    IN PROPID propId
    )
{
    UINT size = 0;

    SetStatus(DllExports::GdipGetPropertyItemSize(nativeImage,
                                                  propId,
                                                  &size));

    return size;
}

inline Status 
Image::GetPropertyItem(
    IN PROPID propId, 
    IN UINT propSize,
    OUT PropertyItem* buffer
    )
{
    return SetStatus(DllExports::GdipGetPropertyItem(nativeImage,
                                                     propId, propSize, buffer));
}

inline Status 
Image::GetPropertySize(
    OUT UINT* totalBufferSize, 
    OUT UINT* numProperties
    )
{
    return SetStatus(DllExports::GdipGetPropertySize(nativeImage,
                                                     totalBufferSize,
                                                     numProperties));
}

inline Status 
Image::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    OUT PropertyItem* allItems
    )
{
    if (allItems == NULL) 
    {
        return SetStatus(InvalidParameter);
    }
    return SetStatus(DllExports::GdipGetAllPropertyItems(nativeImage,
                                                         totalBufferSize,
                                                         numProperties,
                                                         allItems));
}

inline Status 
Image::RemovePropertyItem(
    IN PROPID propId
    )
{
    return SetStatus(DllExports::GdipRemovePropertyItem(nativeImage, propId));
}

inline Status 
Image::SetPropertyItem(
    IN const PropertyItem* item
    )
{
    return SetStatus(DllExports::GdipSetPropertyItem(nativeImage, item));
}

// Get/SetLayout
// Support for Middle East localization (right-to-left mirroring)

inline ImageLayout
Image::GetLayout() const
{
    ImageLayout layout;

    SetStatus(DllExports::GdipGetImageLayout(nativeImage, &layout));

    return layout;
}

inline Status
Image::SetLayout(IN const ImageLayout layout)
{
    SetStatus(DllExports::GdipSetImageLayout(nativeImage, layout));
}

inline Status
Image::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

inline 
Image::Image(GpImage *nativeImage, Status status)
{
    SetNativeImage(nativeImage);
    lastResult = status;
}

inline VOID 
Image::SetNativeImage(GpImage *nativeImage)
{
    this->nativeImage = nativeImage;
}

inline 
Bitmap::Bitmap(
    IN const WCHAR *filename, 
    IN BOOL useEmbeddedColorManagement
    )
{
    GpBitmap *bitmap = NULL;

    if(useEmbeddedColorManagement) 
    {
        lastResult = DllExports::GdipCreateBitmapFromFileICM(filename, &bitmap);
    }
    else
    {
        lastResult = DllExports::GdipCreateBitmapFromFile(filename, &bitmap);
    }

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN IStream *stream, 
    IN BOOL useEmbeddedColorManagement
    )
{
    GpBitmap *bitmap = NULL;

    if(useEmbeddedColorManagement)
    {
        lastResult = DllExports::GdipCreateBitmapFromStreamICM(stream, &bitmap);
    }
    else
    {
        lastResult = DllExports::GdipCreateBitmapFromStream(stream, &bitmap);
    }

    SetNativeImage(bitmap);
}

inline
Bitmap::Bitmap(
    IN INT width,
    IN INT height,
    IN INT stride,
    IN PixelFormat format,
    IN BYTE *scan0
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromScan0(width,
                                                       height,
                                                       stride,
                                                       format,
                                                       scan0,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN INT width,
    IN INT height,
    IN PixelFormat format
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromScan0(width,
                                                       height,
                                                       0,
                                                       format,
                                                       NULL,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline
Bitmap::Bitmap(
    IN INT width, 
    IN INT height, 
    IN Graphics* target)
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromGraphics(width,
                                                          height,
                                                          target->nativeGraphics,
                                                          &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN IDirectDrawSurface7 * surface
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromDirectDrawSurface(surface,
                                                       &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN const BITMAPINFO* gdiBitmapInfo, 
    IN VOID* gdiBitmapData
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromGdiDib(gdiBitmapInfo,
                                                        gdiBitmapData,
                                                        &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HBITMAP hbm, 
    IN HPALETTE hpal
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromHBITMAP(hbm, hpal, &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HICON hicon
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromHICON(hicon, &bitmap);

    SetNativeImage(bitmap);
}

inline 
Bitmap::Bitmap(
    IN HINSTANCE hInstance, 
    IN const WCHAR *bitmapName
    )
{
    GpBitmap *bitmap = NULL;

    lastResult = DllExports::GdipCreateBitmapFromResource(hInstance,
                                                          bitmapName,
                                                          &bitmap);

    SetNativeImage(bitmap);
}


inline Bitmap* 
Bitmap::FromFile(
    IN const WCHAR *filename,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Bitmap(
        filename, 
        useEmbeddedColorManagement
    );
}

inline Bitmap* 
Bitmap::FromStream(
    IN IStream *stream,
    IN BOOL useEmbeddedColorManagement
    )
{
    return new Bitmap(
        stream, 
        useEmbeddedColorManagement
    );
}

inline Bitmap* 
Bitmap::FromDirectDrawSurface7(
    IN IDirectDrawSurface7* surface
    )
{
    return new Bitmap(surface);
}

inline Bitmap* 
Bitmap::FromBITMAPINFO(
    IN const BITMAPINFO* gdiBitmapInfo, 
    IN VOID* gdiBitmapData)
{
    return new Bitmap(gdiBitmapInfo, gdiBitmapData);
}

inline Bitmap* 
Bitmap::FromHBITMAP(
    IN HBITMAP hbm, 
    IN HPALETTE hpal
    )
{
    return new Bitmap(hbm, hpal);
}

inline Bitmap* 
Bitmap::FromHICON(
    IN HICON hicon
    )
{
    return new Bitmap(hicon);
}

inline Bitmap* 
Bitmap::FromResource(
    IN HINSTANCE hInstance, 
    IN const WCHAR *bitmapName)
{
    return new Bitmap(hInstance, bitmapName);
}

inline Status 
Bitmap::GetHBITMAP(
    IN const Color& colorBackground,
    OUT HBITMAP* hbmReturn
    )
{
    return SetStatus(DllExports::GdipCreateHBITMAPFromBitmap(
                                        static_cast<GpBitmap*>(nativeImage),
                                        hbmReturn,
                                        colorBackground.GetValue()));
}

inline Status 
Bitmap::GetHICON(
    OUT HICON* hiconReturn
    )
{
    return SetStatus(DllExports::GdipCreateHICONFromBitmap(
                                        static_cast<GpBitmap*>(nativeImage),
                                        hiconReturn));
}

inline Bitmap* 
Bitmap::Clone(
    IN const Rect& rect,
    IN PixelFormat format
    )
{
    return Clone(rect.X, rect.Y, rect.Width, rect.Height, format);
}

inline Bitmap* 
Bitmap::Clone(
    IN INT x,
    IN INT y,
    IN INT width,
    IN INT height,
    IN PixelFormat format
    )
{
   GpBitmap* gpdstBitmap = NULL;
   Bitmap* bitmap;

   lastResult = DllExports::GdipCloneBitmapAreaI(
                               x,
                               y,
                               width,
                               height,
                               format,
                               (GpBitmap *)nativeImage,
                               &gpdstBitmap);

   if (lastResult == Ok)
   {
       bitmap = new Bitmap(gpdstBitmap);

       if (bitmap == NULL) 
       {
           DllExports::GdipDisposeImage(gpdstBitmap);
       }

       return bitmap;
   }
   else
       return NULL;
}

inline Bitmap* 
Bitmap::Clone(
    IN const RectF& rect,
    IN PixelFormat format
    )
{
    return Clone(rect.X, rect.Y, rect.Width, rect.Height, format);
}

inline Bitmap*
Bitmap::Clone(
    IN REAL x,
    IN REAL y,
    IN REAL width,
    IN REAL height,
    IN PixelFormat format
    )
{
   GpBitmap* gpdstBitmap = NULL;
   Bitmap* bitmap;

   SetStatus(DllExports::GdipCloneBitmapArea(
                               x,
                               y,
                               width,
                               height,
                               format,
                               (GpBitmap *)nativeImage,
                               &gpdstBitmap));

   if (lastResult == Ok)
   {
       bitmap = new Bitmap(gpdstBitmap);

       if (bitmap == NULL) 
       {
           DllExports::GdipDisposeImage(gpdstBitmap);
       }

       return bitmap;
   }
   else
       return NULL;
}

inline Bitmap::Bitmap(GpBitmap *nativeBitmap)
{
    SetNativeImage(nativeBitmap);
}

inline Status
Bitmap::LockBits(
    IN const Rect& rect,
    IN UINT flags,
    IN PixelFormat format,
    OUT BitmapData* lockedBitmapData
)
{
    return SetStatus(DllExports::GdipBitmapLockBits(
                                    static_cast<GpBitmap*>(nativeImage),
                                    &rect,
                                    flags,
                                    format,
                                    lockedBitmapData));
}

inline Status 
Bitmap::UnlockBits(
    IN BitmapData* lockedBitmapData
    )
{
    return SetStatus(DllExports::GdipBitmapUnlockBits(
                                    static_cast<GpBitmap*>(nativeImage),
                                    lockedBitmapData));
}

inline Status 
Bitmap::GetPixel(
    IN INT x, 
    IN INT y, 
    OUT Color *color) 
{
    ARGB argb;

    Status status = SetStatus(DllExports::GdipBitmapGetPixel(
        static_cast<GpBitmap *>(nativeImage),
        x, y,        
        &argb));

    if (status == Ok) 
    {
        color->SetValue(argb);
    }

    return  status;
}

inline Status 
Bitmap::SetPixel(
    IN INT x, 
    IN INT y, 
    IN const Color& color) 
{
    return SetStatus(DllExports::GdipBitmapSetPixel(
        static_cast<GpBitmap *>(nativeImage),
        x, y,
        color.GetValue()));
}

inline Status 
Bitmap::SetResolution(
    IN REAL xdpi, 
    IN REAL ydpi)
{
    return SetStatus(DllExports::GdipBitmapSetResolution(
        static_cast<GpBitmap *>(nativeImage),
        xdpi, ydpi));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdipluscachedbitmap.h ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   CachedBitmap class definition
*
* Abstract:
*
*   CachedBitmap is a representation of an accelerated drawing
*   that has restrictions on what operations are allowed in order
*   to accelerate the drawing to the destination.
*
*
 Created:
*
*   04/23/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _GDIPLUSCACHEDBITMAP_H
#define _GDIPLUSCACHEDBITMAP_H

/**************************************************************************
*
* Class Name:
*
*   CachedBitmap
*
* Abstract:
*
*   An object to store a bitmap prepared for rendering on a particular
*   Graphics object. The memory storage for the CachedBitmap is opaque
*   to the other Engine code, so the only operations supported are
*   initializing the data (with a bitmap) and using the graphics to
*   draw it on the screen with an integer offset.
*
*   Look for the class definition in GdiplusHeaders.h
*
* Created:
*
*   04/23/2000 asecchia
*      Created it.
*
**************************************************************************/
inline 
CachedBitmap::CachedBitmap(
    IN Bitmap *bitmap, 
    IN Graphics *graphics)
{
    nativeCachedBitmap = NULL;    

    lastResult = DllExports::GdipCreateCachedBitmap(
        (GpBitmap *)bitmap->nativeImage,
        graphics->nativeGraphics,
        &nativeCachedBitmap
    );
}

inline 
CachedBitmap::~CachedBitmap()
{
    DllExports::GdipDeleteCachedBitmap(nativeCachedBitmap);
}

inline Status 
CachedBitmap::GetLastStatus() const 
{
    Status lastStatus = lastResult;
    lastResult = Ok;    
    return (lastStatus);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdipluscolormatrix.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Color Matrix
*
* Abstract:
*
*   Class for color adjustment object passed to Graphics.DrawImage
*
* Revision History:
*
*   09/17/1999 gilmanw
*       Created it.
*   10/14/1999 agodfrey
*       Moved it out of GdiplusTypes.h
*
\**************************************************************************/

#ifndef _GDIPLUSCOLORMATRIX_H
#define _GDIPLUSCOLORMATRIX_H

//----------------------------------------------------------------------------
// Color matrix
//----------------------------------------------------------------------------

struct ColorMatrix
{
    REAL m[5][5];
};

//----------------------------------------------------------------------------
// Color Matrix flags
//----------------------------------------------------------------------------

enum ColorMatrixFlags
{
    ColorMatrixFlagsDefault   = 0,
    ColorMatrixFlagsSkipGrays = 1,
    ColorMatrixFlagsAltGray   = 2
};

//----------------------------------------------------------------------------
// Color Adjust Type
//----------------------------------------------------------------------------

enum ColorAdjustType
{
    ColorAdjustTypeDefault,
    ColorAdjustTypeBitmap,
    ColorAdjustTypeBrush,
    ColorAdjustTypePen,
    ColorAdjustTypeText,
    ColorAdjustTypeCount,   // must be immediately after all the individual ones
    ColorAdjustTypeAny      // internal use: for querying if any type has recoloring
};

//----------------------------------------------------------------------------
// Color Map
//----------------------------------------------------------------------------

struct ColorMap
{
    Color oldColor;
    Color newColor;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusbrush.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   Brush API related declarations
*
* Revision History:
*
*   4/26/2000 ericvan
*       Update header files.
*
*   12/09/1998 davidx
*       Flesh out Brush interfaces.
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSBRUSH_H
#define _GDIPLUSBRUSH_H

//--------------------------------------------------------------------------
// Abstract base class for various brush types
//--------------------------------------------------------------------------

class GraphicsPath;

class Brush : public GdiplusBase
{
public:
    friend class Pen;
    friend class Graphics;

    virtual ~Brush()
    {
        DllExports::GdipDeleteBrush(nativeBrush);
    }

    virtual Brush* Clone() const
    {
        GpBrush *brush = NULL;

        SetStatus(DllExports::GdipCloneBrush(nativeBrush, &brush));

        Brush *newBrush = new Brush(brush, lastResult);
        
        if (newBrush == NULL) 
        {
            DllExports::GdipDeleteBrush(brush);
        }

        return newBrush;
    }

    BrushType GetType() const
    {
        BrushType type = static_cast<BrushType>(-1);

        SetStatus(DllExports::GdipGetBrushType(nativeBrush, &type));

        return type;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:

    Brush()
    {
        SetStatus(NotImplemented);
    }

    Brush(const Brush& brush)
    {
        brush;
        SetStatus(NotImplemented);
    }

    Brush& operator=(const Brush& brush)
    {
        brush;
        SetStatus(NotImplemented);
        return *this;
    }

    Brush(GpBrush* nativeBrush, Status status)
    {
        lastResult = status;
        SetNativeBrush(nativeBrush);
    }

    VOID SetNativeBrush(GpBrush* nativeBrush)
    {
        this->nativeBrush = nativeBrush;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpBrush* nativeBrush;
    mutable Status lastResult;
};

//--------------------------------------------------------------------------
// Represent solid fill brush object
//--------------------------------------------------------------------------

class SolidBrush : public Brush
{
public:
    friend class Pen;

    SolidBrush(IN const Color& color)
    {
        GpSolidFill *brush = NULL;

        lastResult = DllExports::GdipCreateSolidFill(color.GetValue(), &brush);

        SetNativeBrush(brush);
    }

    Status GetColor(OUT Color* color) const
    {
        ARGB argb;

        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        SetStatus(DllExports::GdipGetSolidFillColor((GpSolidFill*)nativeBrush,
                                                    &argb));

        *color = Color(argb);

        return lastResult;
    }

    Status SetColor(IN const Color& color)
    {
        return SetStatus(DllExports::GdipSetSolidFillColor((GpSolidFill*)nativeBrush, 
                                                           color.GetValue()));
    }

protected:

    SolidBrush()
    {
    }
};

class TextureBrush : public Brush
{
public:
    friend class Pen;

    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode = WrapModeTile)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture(
                                                  image->nativeImage,
                                                  wrapMode, &texture);

        SetNativeBrush(texture);
    }

    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode,
                 IN const RectF &dstRect)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2(
                                                   image->nativeImage,
                                                   wrapMode, 
                                                   dstRect.X, 
                                                   dstRect.Y, 
                                                   dstRect.Width, 
                                                   dstRect.Height,
                                                   &texture);

        SetNativeBrush(texture);
    }
    
    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.

    TextureBrush(IN Image *image, 
                 IN RectF &dstRect,
                 IN ImageAttributes *imageAttributes = NULL)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTextureIA(
            image->nativeImage,
            (imageAttributes)?imageAttributes->nativeImageAttr:NULL,
            dstRect.X, 
            dstRect.Y, 
            dstRect.Width, 
            dstRect.Height,
            &texture
        );

        SetNativeBrush(texture);
    }
    
    #ifdef DCR_USE_NEW_145138
    TextureBrush(IN Image *image, 
                 IN Rect &dstRect,
                 IN ImageAttributes *imageAttributes = NULL)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTextureIA(
            image->nativeImage,
            (imageAttributes)?imageAttributes->nativeImageAttr:NULL,
            (REAL)dstRect.X, 
            (REAL)dstRect.Y, 
            (REAL)dstRect.Width, 
            (REAL)dstRect.Height,
            &texture
        );

        SetNativeBrush(texture);
    }
    #endif

    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.

    TextureBrush(
        IN Image* image,
        IN WrapMode wrapMode,
        
        #ifdef DCR_USE_NEW_145138       
        const IN Rect &dstRect
        #else
        IN Rect &dstRect
        #endif
    )
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2I(
                                                    image->nativeImage,
                                                    wrapMode, 
                                                    dstRect.X, 
                                                    dstRect.Y, 
                                                    dstRect.Width, 
                                                    dstRect.Height,
                                                    &texture);

        SetNativeBrush(texture);
    }

    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode, 
                 IN REAL dstX, 
                 IN REAL dstY, 
                 IN REAL dstWidth, 
                 IN REAL dstHeight)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2(
                                                   image->nativeImage,
                                                   wrapMode, 
                                                   dstX, 
                                                   dstY, 
                                                   dstWidth, 
                                                   dstHeight,
                                                   &texture);

        SetNativeBrush(texture);
    }

    // When creating a texture brush from a metafile image, the dstRect
    // is used to specify the size that the metafile image should be
    // rendered at in the device units of the destination graphics.
    // It is NOT used to crop the metafile image, so only the width 
    // and height values matter for metafiles.
    TextureBrush(IN Image* image, 
                 IN WrapMode wrapMode, 
                 IN INT dstX, 
                 IN INT dstY, 
                 IN INT dstWidth, 
                 IN INT dstHeight)
    {
        GpTexture *texture = NULL;

        lastResult = DllExports::GdipCreateTexture2I(
                                                    image->nativeImage,
                                                    wrapMode, 
                                                    dstX, 
                                                    dstY, 
                                                    dstWidth, 
                                                    dstHeight,
                                                    &texture);

        SetNativeBrush(texture);
    }

    /**
     * Set/get brush transform
     */
    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetTextureTransform((GpTexture*)nativeBrush, 
                                                             matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetTextureTransform((GpTexture*)nativeBrush, 
                                                             matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetTextureTransform((GpTexture*)nativeBrush));
    }

    Status MultiplyTransform(IN Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyTextureTransform((GpTexture*)nativeBrush,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx,
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateTextureTransform((GpTexture*)nativeBrush,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleTextureTransform((GpTexture*)nativeBrush,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateTextureTransform((GpTexture*)nativeBrush,
                                                              angle, order));
    }

    /**
     * Set/get brush wrapping mode
     */
    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetTextureWrapMode((GpTexture*)nativeBrush, 
                                                            wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetTextureWrapMode((GpTexture*)nativeBrush, 
                                                     &wrapMode));
        return wrapMode;
    }

    // Get texture brush attributes

    Image *GetImage() const
    {
        GpImage *image;

        SetStatus(DllExports::GdipGetTextureImage((GpTexture *)nativeBrush,
                                                  &image));

        Image *retimage = new Image(image, lastResult);

        if (retimage == NULL) 
        {
            DllExports::GdipDisposeImage(image);
        }

        return retimage;
    }

protected:

    TextureBrush()
    {
    }
};

//--------------------------------------------------------------------------
// Represent line gradient brush object
//--------------------------------------------------------------------------

class LinearGradientBrush : public Brush
{
public:
    friend class Pen;

    LinearGradientBrush(IN const PointF& point1,
                        IN const PointF& point2,
                        IN const Color& color1,
                        IN const Color& color2)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrush(&point1,
                                                     &point2,
                                                     color1.GetValue(),
                                                     color2.GetValue(),
                                                     WrapModeTile,
                                                     &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Point& point1,
                        IN const Point& point2,
                        IN const Color& color1,
                        IN const Color& color2)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushI(&point1,
                                                      &point2,
                                                      color1.GetValue(),
                                                      color2.GetValue(),
                                                      WrapModeTile,
                                                      &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const RectF& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN LinearGradientMode mode)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRect(&rect,
                                                             color1.GetValue(),
                                                             color2.GetValue(),
                                                             mode,
                                                             WrapModeTile,
                                                             &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Rect& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN LinearGradientMode mode)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectI(&rect,
                                                              color1.GetValue(),
                                                              color2.GetValue(),
                                                              mode,
                                                              WrapModeTile,
                                                              &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const RectF& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN REAL angle,
                        IN BOOL isAngleScalable = FALSE)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectWithAngle(&rect,
                                                                      color1.GetValue(),
                                                                      color2.GetValue(),
                                                                      angle,
                                                                      isAngleScalable,
                                                                      WrapModeTile,
                                                                      &brush);

        SetNativeBrush(brush);
    }

    LinearGradientBrush(IN const Rect& rect,
                        IN const Color& color1,
                        IN const Color& color2,
                        IN REAL angle,
                        IN BOOL isAngleScalable = FALSE)
    {
        GpLineGradient *brush = NULL;

        lastResult = DllExports::GdipCreateLineBrushFromRectWithAngleI(&rect,
                                                                       color1.GetValue(),
                                                                       color2.GetValue(),
                                                                       angle,
                                                                       isAngleScalable,
                                                                       WrapModeTile,
                                                                       &brush);

        SetNativeBrush(brush);
    }

    // Get/set point attributes

    Status SetLinearPoints(IN const PointF& point1, 
                           IN const PointF& point2)
    {
        return SetStatus(DllExports::GdipSetLinePoints((GpLineGradient*)nativeBrush,
                                                       &point1, &point2));
    }

    Status GetLinearPoints(OUT PointF* points) const 
    {
        return SetStatus(DllExports::GdipGetLinePoints((GpLineGradient*) nativeBrush,
                                                       points));
    }

    Status SetLinearPoints(IN const Point& point1, 
                           IN const Point& point2)
    {
        return SetStatus(DllExports::GdipSetLinePointsI((GpLineGradient*)nativeBrush,
                                                        &point1, &point2));
    }

    Status GetLinearPoints(OUT Point* points) const
    {
        return SetStatus(DllExports::GdipGetLinePointsI((GpLineGradient*) nativeBrush,
                                                        points));
    }
    // Get/set color attributes

    Status SetLinearColors(IN const Color& color1, 
                           IN const Color& color2)
    {
        return SetStatus(DllExports::GdipSetLineColors((GpLineGradient*)nativeBrush,
                                                       color1.GetValue(),
                                                       color2.GetValue()));
    }

    Status GetLinearColors(OUT Color* colors) const
    {
        ARGB argb[2];

        if (colors == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        SetStatus(DllExports::GdipGetLineColors((GpLineGradient*) nativeBrush, argb));

        if (lastResult == Ok)
        {
            // use bitwise copy operator for Color copy
            colors[0] = Color(argb[0]);
            colors[1] = Color(argb[1]);
        }

        return lastResult;
    }

    Status GetRectangle(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetLineRect((GpLineGradient*)nativeBrush, rect));
    }

    // integer version
    Status GetRectangle(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetLineRectI((GpLineGradient*)nativeBrush, rect));
    }

    // Gamma correction in interporlation.

    Status SetGammaCorrection(IN BOOL useGammaCorrection)
    {
        return SetStatus(DllExports::GdipSetLineGammaCorrection((GpLineGradient*)nativeBrush,
                    useGammaCorrection));
    }
    
    BOOL GetGammaCorrection() const
    {
        BOOL useGammaCorrection;

        SetStatus(DllExports::GdipGetLineGammaCorrection((GpLineGradient*)nativeBrush,
                    &useGammaCorrection));

        return useGammaCorrection;
    }

    INT GetBlendCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetLineBlendCount((GpLineGradient*)
                                                    nativeBrush,
                                                    &count));

        return count;
    }

    Status SetBlend(IN const REAL* blendFactors, 
                    IN const REAL* blendPositions,
                    IN INT count)
    {
        return SetStatus(DllExports::GdipSetLineBlend((GpLineGradient*)
                                                      nativeBrush,
                                                      blendFactors,
                                                      blendPositions,
                                                      count));
    }

    Status GetBlend(OUT REAL* blendFactors, 
                    OUT REAL* blendPositions, 
                    IN INT count) const 
    {
        return SetStatus(DllExports::GdipGetLineBlend((GpLineGradient*)nativeBrush,
                                                      blendFactors,
                                                      blendPositions,
                                                      count));
    }

    INT GetInterpolationColorCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetLinePresetBlendCount((GpLineGradient*)
                                                          nativeBrush,
                                                          &count));

        return count;
    }

    Status SetInterpolationColors(IN const Color* presetColors,
                                  IN const REAL* blendPositions, 
                                  IN INT count)
    {
        if ((count <= 0) || !presetColors)
            return SetStatus(InvalidParameter);
         
        ARGB *argbs = (ARGB*) new BYTE[count*sizeof(ARGB)];
        
        if (argbs)
        {
            for (INT i = 0; i < count; i++)
            {
                argbs[i] = presetColors[i].GetValue();
            }

            Status status = SetStatus(DllExports::GdipSetLinePresetBlend(
                                                                        (GpLineGradient*) nativeBrush,
                                                                        argbs,
                                                                        blendPositions,
                                                                        count));
            delete [] argbs;
            return status;
        }
        else
        {
            return SetStatus(OutOfMemory);
        }
    }

    Status GetInterpolationColors(OUT Color* presetColors, 
                                  OUT REAL* blendPositions, 
                                  IN INT count) const 
    {
        if ((count <= 0) || !presetColors)
            return SetStatus(InvalidParameter);

        ARGB* argbs = (ARGB*) new BYTE[count*sizeof(ARGB)];
        
        if (!argbs)
        {
            return SetStatus(OutOfMemory);
        }

        Status status = SetStatus(DllExports::GdipGetLinePresetBlend((GpLineGradient*)nativeBrush,
                                                                     argbs,
                                                                     blendPositions,
                                                                     count));
        if (status == Ok) 
        {
            for (INT i = 0; i < count; i++)
            { 
                presetColors[i] = Color(argbs[i]);
            }
        }
        
        delete [] argbs;
        
        return status;
    }

    Status SetBlendBellShape(IN REAL focus, 
                             IN REAL scale = 1.0)
    {
        return SetStatus(DllExports::GdipSetLineSigmaBlend((GpLineGradient*)nativeBrush, focus, scale));
    }

    #ifdef DCR_USE_NEW_145135
    Status SetBlendTriangularShape(
        IN REAL focus,
        IN REAL scale = 1.0
    )
    #else
    Status SetBlendTrianglarShape(IN REAL focus,
                                  IN REAL scale = 1.0)
    #endif                              
    {
        return SetStatus(DllExports::GdipSetLineLinearBlend((GpLineGradient*)nativeBrush, focus, scale));
    }

    /**
     * Set/get brush transform
     */
    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetLineTransform((GpLineGradient*)nativeBrush, 
                                                          matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetLineTransform((GpLineGradient*)nativeBrush, 
                                                          matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetLineTransform((GpLineGradient*)nativeBrush));
    }

    Status MultiplyTransform(IN Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyLineTransform((GpLineGradient*)nativeBrush,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateLineTransform((GpLineGradient*)nativeBrush,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleLineTransform((GpLineGradient*)nativeBrush,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateLineTransform((GpLineGradient*)nativeBrush,
                                                              angle, order));
    }

    /**
     * Set/get brush wrapping mode
     */
    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetLineWrapMode((GpLineGradient*)nativeBrush, 
                                                         wrapMode));
    }

    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetLineWrapMode((GpLineGradient*)
                                                  nativeBrush, 
                                                  &wrapMode));

        return wrapMode;
    }

protected:

    LinearGradientBrush()
    {
    }
};

//--------------------------------------------------------------------------
// PathGradientBrush object is defined
// in gdipluspath.h.
//--------------------------------------------------------------------------

//--------------------------------------------------------------------------
// Represent hatch brush object
//--------------------------------------------------------------------------

class HatchBrush : public Brush
{
public:
    friend class Pen;

    // Constructors

    HatchBrush(IN HatchStyle hatchStyle, 
               IN const Color& foreColor,
               IN const Color& backColor = Color())
    {
        GpHatch *brush = NULL;

        lastResult = DllExports::GdipCreateHatchBrush(hatchStyle, 
                                                      foreColor.GetValue(), 
                                                      backColor.GetValue(),
                                                      &brush);
        SetNativeBrush(brush);
    }

    HatchStyle GetHatchStyle() const
    {
        HatchStyle hatchStyle;

        SetStatus(DllExports::GdipGetHatchStyle((GpHatch*)nativeBrush, 
                                                &hatchStyle));

        return hatchStyle;
    }
    
    Status GetForegroundColor(OUT Color* color) const
    {
        ARGB argb;

        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        Status status = SetStatus(DllExports::GdipGetHatchForegroundColor(
                                                        (GpHatch*)nativeBrush, 
                                                        &argb));

        color->SetValue(argb);

        return status;
    }

    Status GetBackgroundColor(OUT Color *color) const
    {
        ARGB argb;
        
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        Status status = SetStatus(DllExports::GdipGetHatchBackgroundColor(
                                                        (GpHatch*)nativeBrush,
                                                        &argb));

        color->SetValue(argb);
        
        return status;
    }

protected:

    HatchBrush()
    {
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdipluscolor.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Color
*
* Abstract:
*
*   Represents a GDI+ color.
*
* Revision History:
*
*   10/13/1999 agodfrey
*       Moved it out of GdiplusTypes.h
*
\**************************************************************************/

#ifndef _GDIPLUSCOLOR_H
#define _GDIPLUSCOLOR_H

//----------------------------------------------------------------------------
// Color mode
//----------------------------------------------------------------------------

enum ColorMode
{
    ColorModeARGB32 = 0,
    ColorModeARGB64 = 1
};

//----------------------------------------------------------------------------
// Color Channel flags
//----------------------------------------------------------------------------

enum ColorChannelFlags
{
    ColorChannelFlagsC = 0,
    ColorChannelFlagsM,
    ColorChannelFlagsY,
    ColorChannelFlagsK,
    ColorChannelFlagsLast
};

//----------------------------------------------------------------------------
// Color
//----------------------------------------------------------------------------

class Color
{
public:

    Color()
    {
        Argb = (ARGB)Color::Black;
    }

    // Construct an opaque Color object with
    // the specified R, G, B values.

    Color(IN BYTE r,
          IN BYTE g,
          IN BYTE b)
    {
        Argb = MakeARGB(255, r, g, b);
    }

    // Construct a Color object with
    // the specified A, R, G, B values.
    //
    // NOTE: R, G, B color values are not premultiplied.

    Color(IN BYTE a,
          IN BYTE r,
          IN BYTE g,
          IN BYTE b)
    {
        Argb = MakeARGB(a, r, g, b);
    }

    // Construct a Color object with
    // the specified ARGB values.
    //
    // NOTE: R, G, B color components are not premultiplied.

    Color(IN ARGB argb)
    {
        Argb = argb;
    }

    // Extract A, R, G, B components

    BYTE GetAlpha() const
    {
        return (BYTE) (Argb >> AlphaShift);
    }

    BYTE GetA() const
    {
        return GetAlpha();
    }

    BYTE GetRed() const
    {
        return (BYTE) (Argb >> RedShift);
    }

    BYTE GetR() const
    {
        return GetRed();
    }

    BYTE GetGreen() const
    {
        return (BYTE) (Argb >> GreenShift);
    }

    BYTE GetG() const
    {
        return GetGreen();
    }

    BYTE GetBlue() const
    {
        return (BYTE) (Argb >> BlueShift);
    }

    BYTE GetB() const
    {
        return GetBlue();
    }

    // Retrieve ARGB values

    ARGB GetValue() const
    {
        return Argb;
    }

    VOID SetValue(IN ARGB argb)
    {
        Argb = argb;
    }

    VOID SetFromCOLORREF(IN COLORREF rgb)
    {
        Argb = MakeARGB(255, GetRValue(rgb), GetGValue(rgb), GetBValue(rgb));
    }

    COLORREF ToCOLORREF() const
    {
        return RGB(GetRed(), GetGreen(), GetBlue());
    }

public:

    // Standard color constants
    enum
    {
       Black = 0xff000000,
       Silver = 0xffc0c0c0,
       Gray = 0xff808080,
       White = 0xffffffff,
       Maroon = 0xff800000,
       Red = 0xffff0000,
       Purple = 0xff800080,
       Fuchsia = 0xffff00ff,
       Green = 0xff008000,
       Lime = 0xff00ff00,
       Olive = 0xff808000,
       Yellow = 0xffffff00,
       Navy = 0xff000080,
       Blue = 0xff0000ff,
       Teal = 0xff008080,
       Aqua = 0xff00ffff
    };

    // Shift count and bit mask for A, R, G, B components
    enum
    {
        AlphaShift  = 24,
        RedShift    = 16,
        GreenShift  = 8,
        BlueShift   = 0
    };

    enum
    {
        AlphaMask   = 0xff000000,
        RedMask     = 0x00ff0000,
        GreenMask   = 0x0000ff00,
        BlueMask    = 0x000000ff
    };

    // Assemble A, R, G, B values into a 32-bit integer
    static ARGB MakeARGB(IN BYTE a,
                         IN BYTE r,
                         IN BYTE g,
                         IN BYTE b)
    {
        return (((ARGB) (b) <<  BlueShift) |
                ((ARGB) (g) << GreenShift) |
                ((ARGB) (r) <<   RedShift) |
                ((ARGB) (a) << AlphaShift));
    }

protected:

    ARGB Argb;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusenums.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusEnums.hpp
*
* Abstract:
*
*   Various enumeration types
*
* Revision History:
*
*   12/11/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSENUMS_H
#define _GDIPLUSENUMS_H

//--------------------------------------------------------------------------
// Graphics and Container State cookies
//--------------------------------------------------------------------------

typedef UINT     GraphicsState;
typedef UINT     GraphicsContainer;

//--------------------------------------------------------------------------
// Fill mode constants
//--------------------------------------------------------------------------

enum FillMode
{
    FillModeAlternate,        // 0
    FillModeWinding           // 1
};

//--------------------------------------------------------------------------
// Quality mode constants
//--------------------------------------------------------------------------

enum QualityMode
{
    QualityModeInvalid   = -1,
    QualityModeDefault   = 0,
    QualityModeLow       = 1, // for apps that need the best performance
    QualityModeHigh      = 2  // for apps that need the best rendering quality
};

//--------------------------------------------------------------------------
// Alpha compositing mode constants
//--------------------------------------------------------------------------

enum CompositingMode
{
    CompositingModeSourceOver,    // 0
    CompositingModeSourceCopy     // 1
};

//--------------------------------------------------------------------------
// Alpha compositing quality constants
//--------------------------------------------------------------------------

enum CompositingQuality
{
    CompositingQualityInvalid          = QualityModeInvalid,
    CompositingQualityDefault          = QualityModeDefault,
    CompositingQualityHighSpeed        = QualityModeLow,
    CompositingQualityHighQuality      = QualityModeHigh,
    CompositingQualityGammaCorrected,
    CompositingQualityAssumeLinear
};

//--------------------------------------------------------------------------
// Unit constants
//--------------------------------------------------------------------------

enum Unit
{
    UnitWorld,      // 0 -- World coordinate (non-physical unit)
    UnitDisplay,    // 1 -- Variable -- for PageTransform only
    UnitPixel,      // 2 -- Each unit is one device pixel.
    UnitPoint,      // 3 -- Each unit is a printer's point, or 1/72 inch.
    UnitInch,       // 4 -- Each unit is 1 inch.
    UnitDocument,   // 5 -- Each unit is 1/300 inch.
    UnitMillimeter  // 6 -- Each unit is 1 millimeter.
};

//--------------------------------------------------------------------------
// MetafileFrameUnit
//
// The frameRect for creating a metafile can be specified in any of these
// units.  There is an extra frame unit value (MetafileFrameUnitGdi) so
// that units can be supplied in the same units that GDI expects for
// frame rects -- these units are in .01 (1/100ths) millimeter units
// as defined by GDI.
//--------------------------------------------------------------------------
enum MetafileFrameUnit
{
    MetafileFrameUnitPixel      = UnitPixel,
    MetafileFrameUnitPoint      = UnitPoint,
    MetafileFrameUnitInch       = UnitInch,
    MetafileFrameUnitDocument   = UnitDocument,
    MetafileFrameUnitMillimeter = UnitMillimeter,
    MetafileFrameUnitGdi                        // GDI compatible .01 MM units
};

//--------------------------------------------------------------------------
// Coordinate space identifiers
//--------------------------------------------------------------------------

enum CoordinateSpace
{
    CoordinateSpaceWorld,     // 0
    CoordinateSpacePage,      // 1
    CoordinateSpaceDevice     // 2
};

//--------------------------------------------------------------------------
// Various wrap modes for brushes
//--------------------------------------------------------------------------

enum WrapMode
{
    WrapModeTile,        // 0
    WrapModeTileFlipX,   // 1
    WrapModeTileFlipY,   // 2
    WrapModeTileFlipXY,  // 3
    WrapModeClamp        // 4
};

//--------------------------------------------------------------------------
// Various hatch styles
//--------------------------------------------------------------------------

enum HatchStyle
{
    HatchStyleHorizontal,         // 0
    HatchStyleVertical,           // 1
    HatchStyleForwardDiagonal,    // 2
    HatchStyleBackwardDiagonal,   // 3
    HatchStyleCross,              // 4
    HatchStyleDiagonalCross       // 5
};

//--------------------------------------------------------------------------
// Dash style constants
//--------------------------------------------------------------------------

enum DashStyle
{
    DashStyleSolid,          // 0
    DashStyleDash,           // 1
    DashStyleDot,            // 2
    DashStyleDashDot,        // 3
    DashStyleDashDotDot,     // 4
    DashStyleCustom          // 5
};

//--------------------------------------------------------------------------
// Line cap constants (only the lowest 8 bits are used).
//--------------------------------------------------------------------------

enum LineCap
{
    LineCapFlat             = 0,
    LineCapSquare           = 1,
    LineCapRound            = 2,
    LineCapTriangle         = 3,

    LineCapNoAnchor         = 0x10, // corresponds to flat cap
    LineCapSquareAnchor     = 0x11, // corresponds to square cap
    LineCapRoundAnchor      = 0x12, // corresponds to round cap
    LineCapDiamondAnchor    = 0x13, // corresponds to triangle cap
    LineCapArrowAnchor      = 0x14, // no correspondence

    LineCapCustom           = 0xff, // custom cap

    LineCapAnchorMask       = 0xf0  // mask to check for anchor or not.
};

//--------------------------------------------------------------------------
// Custom Line cap type constants
//--------------------------------------------------------------------------

enum CustomLineCapType
{
    CustomLineCapTypeDefault         = 0,
    CustomLineCapTypeAdjustableArrow = 1
};

//--------------------------------------------------------------------------
// Line join constants
//--------------------------------------------------------------------------

enum LineJoin
{
    LineJoinMiter   = 0,
    LineJoinBevel   = 1,
    LineJoinRound   = 2
};

//--------------------------------------------------------------------------
// Path point types (only the lowest 8 bits are used.)
//  The lowest 3 bits are interpreted as point type
//  The higher 5 bits are reserved for flags.
//--------------------------------------------------------------------------

enum PathPointType
{
    PathPointTypeStart           = 0,    // move
    PathPointTypeLine            = 1,    // line
    PathPointTypeBezier          = 3,    // default Beizer (= cubic Bezier)
    PathPointTypePathTypeMask    = 0x07, // type mask (lowest 3 bits).
    PathPointTypeDashMode        = 0x10, // currently in dash mode.
    PathPointTypePathMarker      = 0x20, // a marker for the path.
    PathPointTypeCloseSubpath    = 0x80, // closed flag

    // Path types used for advanced path.

    PathPointTypeBezier2    = 2,    // quadratic Beizer
    PathPointTypeBezier3    = 3,    // cubic Bezier
    PathPointTypeBezier4    = 4,    // quartic (4th order) Beizer
    PathPointTypeBezier5    = 5,    // quintic (5th order) Bezier
    PathPointTypeBezier6    = 6     // hexaic (6th order) Bezier
};

//--------------------------------------------------------------------------
// WarpMode constants
//--------------------------------------------------------------------------

enum WarpMode
{
    WarpModePerspective,    // 0
    WarpModeBilinear        // 1
};

//--------------------------------------------------------------------------
// LineGradient Mode
//--------------------------------------------------------------------------

enum LinearGradientMode
{
    LinearGradientModeHorizontal,         // 0
    LinearGradientModeVertical,           // 1
    LinearGradientModeForwardDiagonal,    // 2
    LinearGradientModeBackwardDiagonal    // 3
};

//--------------------------------------------------------------------------
// Region Comine Modes
//--------------------------------------------------------------------------

enum CombineMode
{
    CombineModeReplace,     // 0
    CombineModeIntersect,   // 1
    CombineModeUnion,       // 2
    CombineModeXor,         // 3
    CombineModeExclude,     // 4
    CombineModeComplement   // 5 (does exclude from)
};

//--------------------------------------------------------------------------
 // Image types
//--------------------------------------------------------------------------

enum ImageType
{
    ImageTypeUnknown,   // 0
    ImageTypeBitmap,    // 1
    ImageTypeMetafile   // 2
};

//--------------------------------------------------------------------------
// Interpolation modes
//--------------------------------------------------------------------------

enum InterpolationMode
{
    InterpolationModeInvalid          = QualityModeInvalid,
    InterpolationModeDefault          = QualityModeDefault,
    InterpolationModeLowQuality       = QualityModeLow,
    InterpolationModeHighQuality      = QualityModeHigh,
    InterpolationModeBilinear,
    InterpolationModeBicubic,
    InterpolationModeNearestNeighbor,
    InterpolationModeHighQualityBilinear,
    InterpolationModeHighQualityBicubic
};

//--------------------------------------------------------------------------
// Pen types
//--------------------------------------------------------------------------
enum PenAlignment
{
    PenAlignmentCenter       = 0,
    PenAlignmentInset        = 1,
    PenAlignmentOutset       = 2,
    PenAlignmentLeft         = 3,
    PenAlignmentRight        = 4
};

//--------------------------------------------------------------------------
// Brush types
//--------------------------------------------------------------------------

enum BrushType
{
   BrushTypeSolidColor       = 0,
   BrushTypeHatchFill        = 1,
   BrushTypeTextureFill      = 2,
   BrushTypePathGradient     = 3,
   BrushTypeLinearGradient   = 4
};

//--------------------------------------------------------------------------
// Pen's Fill types
//--------------------------------------------------------------------------

enum PenType
{
   PenTypeSolidColor       = BrushTypeSolidColor,
   PenTypeHatchFill        = BrushTypeHatchFill,
   PenTypeTextureFill      = BrushTypeTextureFill,
   PenTypePathGradient     = BrushTypePathGradient,
   PenTypeLinearGradient   = BrushTypeLinearGradient,
   PenTypeUnknown          = -1
};

//--------------------------------------------------------------------------
// Matrix Order
//--------------------------------------------------------------------------

enum MatrixOrder
{
    MatrixOrderPrepend    = 0,
    MatrixOrderAppend     = 1
};

//--------------------------------------------------------------------------
// Generic font families
//--------------------------------------------------------------------------

enum GenericFontFamily
{
    GenericFontFamilySerif,
    GenericFontFamilySansSerif,
    GenericFontFamilyMonospace

};

//--------------------------------------------------------------------------
// FontStyle: face types and common styles
//--------------------------------------------------------------------------

//  These should probably be flags

//  Must have:
//      Regular = 0
//      Bold = 1
//      Italic = 2
//      BoldItalic = 3

enum FontStyle
{
    FontStyleRegular    = 0,
    FontStyleBold       = 1,
    FontStyleItalic     = 2,
    FontStyleBoldItalic = 3,
    FontStyleUnderline  = 4,
    FontStyleStrikeout  = 8
};

//---------------------------------------------------------------------------
// Smoothing Mode
//---------------------------------------------------------------------------

enum SmoothingMode
{
    SmoothingModeInvalid     = QualityModeInvalid,
    SmoothingModeDefault     = QualityModeDefault,
    SmoothingModeHighSpeed   = QualityModeLow,
    SmoothingModeHighQuality = QualityModeHigh,
    SmoothingModeNone,
    SmoothingModeAntiAlias
};

//---------------------------------------------------------------------------
// Pixel Format Mode
//---------------------------------------------------------------------------

enum PixelOffsetMode
{
    PixelOffsetModeInvalid     = QualityModeInvalid,
    PixelOffsetModeDefault     = QualityModeDefault,
    PixelOffsetModeHighSpeed   = QualityModeLow,
    PixelOffsetModeHighQuality = QualityModeHigh,
    PixelOffsetModeNone,    // no pixel offset
    PixelOffsetModeHalf     // offset by -0.5, -0.5 for fast anti-alias perf
};

//---------------------------------------------------------------------------
// Text Rendering Hint
//---------------------------------------------------------------------------

enum TextRenderingHint
{
    TextRenderingHintSingleBitPerPixelGridFit = 0, // Glyph bitmap with hinting
    TextRenderingHintSingleBitPerPixel,            // Glyph bitmap without hinting
    TextRenderingHintAntiAliasGridFit,             // Glyph anti-alias bitmap without hinting
    TextRenderingHintAntiAlias,                    // Glyph anti-alias bitmap with hinting
    TextRenderingHintClearTypeGridFit              // Glyph CT bitmap with hinting
};

//---------------------------------------------------------------------------
// Metafile Types
//---------------------------------------------------------------------------
enum MetafileType
{
    MetafileTypeInvalid,            // Invalid metafile
    MetafileTypeWmf,                // Standard WMF
    MetafileTypeWmfAldus,           // Aldus Placeable Metafile format
    MetafileTypeEmf,                // EMF (not EMF+)
    MetafileTypeEmfPlusOnly,        // EMF+ without dual, down-level records
    MetafileTypeEmfPlusDual         // EMF+ with dual, down-level records
};

// Specifies the type of EMF to record
enum EmfType
{
    EmfTypeEmfOnly     = MetafileTypeEmf,          // no EMF+, only EMF
    EmfTypeEmfPlusOnly = MetafileTypeEmfPlusOnly,  // no EMF, only EMF+
    EmfTypeEmfPlusDual = MetafileTypeEmfPlusDual   // both EMF+ and EMF
};

// All persistent objects must have a type listed here
enum ObjectType
{
    ObjectTypeInvalid,
    ObjectTypeBrush,
    ObjectTypePen,
    ObjectTypePath,
    ObjectTypeRegion,
    ObjectTypeImage,
    ObjectTypeFont,
    ObjectTypeStringFormat,
    ObjectTypeImageAttributes,
    ObjectTypeMax = ObjectTypeImageAttributes,
    ObjectTypeMin = ObjectTypeBrush
};

inline BOOL
ObjectTypeIsValid(
    ObjectType      type
    )
{
    return ((type >= ObjectTypeMin) && (type <= ObjectTypeMax));
}

//---------------------------------------------------------------------------
// EMF+ Records
//---------------------------------------------------------------------------

// We have to change the WMF record numbers so that they don't conflict with
// the EMF and EMF+ record numbers.
enum EmfPlusRecordType;
#define GDIP_EMFPLUS_RECORD_BASE        0x00004000
#define GDIP_WMF_RECORD_BASE            0x00010000
#define GDIP_WMF_RECORD_TO_EMFPLUS(n)   ((EmfPlusRecordType)((n) | GDIP_WMF_RECORD_BASE))
#define GDIP_EMFPLUS_RECORD_TO_WMF(n)   ((n) & (~GDIP_WMF_RECORD_BASE))
#define GDIP_IS_WMF_RECORDTYPE(n)       (((n) & GDIP_WMF_RECORD_BASE) != 0)

enum EmfPlusRecordType
{
   // Since we have to enumerate GDI records right along with GDI+ records,
   // we list all the GDI records here so that they can be part of the
   // same enumeration type which is used in the enumeration callback.

    WmfRecordTypeSetBkColor              = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETBKCOLOR),
    WmfRecordTypeSetBkMode               = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETBKMODE),
    WmfRecordTypeSetMapMode              = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETMAPMODE),
    WmfRecordTypeSetROP2                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETROP2),
    WmfRecordTypeSetRelAbs               = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETRELABS),
    WmfRecordTypeSetPolyFillMode         = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPOLYFILLMODE),
    WmfRecordTypeSetStretchBltMode       = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETSTRETCHBLTMODE),
    WmfRecordTypeSetTextCharExtra        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTCHAREXTRA),
    WmfRecordTypeSetTextColor            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTCOLOR),
    WmfRecordTypeSetTextJustification    = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTJUSTIFICATION),
    WmfRecordTypeSetWindowOrg            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETWINDOWORG),
    WmfRecordTypeSetWindowExt            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETWINDOWEXT),
    WmfRecordTypeSetViewportOrg          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETVIEWPORTORG),
    WmfRecordTypeSetViewportExt          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETVIEWPORTEXT),
    WmfRecordTypeOffsetWindowOrg         = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETWINDOWORG),
    WmfRecordTypeScaleWindowExt          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SCALEWINDOWEXT),
    WmfRecordTypeOffsetViewportOrg       = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETVIEWPORTORG),
    WmfRecordTypeScaleViewportExt        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SCALEVIEWPORTEXT),
    WmfRecordTypeLineTo                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_LINETO),
    WmfRecordTypeMoveTo                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_MOVETO),
    WmfRecordTypeExcludeClipRect         = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXCLUDECLIPRECT),
    WmfRecordTypeIntersectClipRect       = GDIP_WMF_RECORD_TO_EMFPLUS(META_INTERSECTCLIPRECT),
    WmfRecordTypeArc                     = GDIP_WMF_RECORD_TO_EMFPLUS(META_ARC),
    WmfRecordTypeEllipse                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_ELLIPSE),
    WmfRecordTypeFloodFill               = GDIP_WMF_RECORD_TO_EMFPLUS(META_FLOODFILL),
    WmfRecordTypePie                     = GDIP_WMF_RECORD_TO_EMFPLUS(META_PIE),
    WmfRecordTypeRectangle               = GDIP_WMF_RECORD_TO_EMFPLUS(META_RECTANGLE),
    WmfRecordTypeRoundRect               = GDIP_WMF_RECORD_TO_EMFPLUS(META_ROUNDRECT),
    WmfRecordTypePatBlt                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_PATBLT),
    WmfRecordTypeSaveDC                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_SAVEDC),
    WmfRecordTypeSetPixel                = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPIXEL),
    WmfRecordTypeOffsetCilpRgn           = GDIP_WMF_RECORD_TO_EMFPLUS(META_OFFSETCLIPRGN),
    WmfRecordTypeTextOut                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_TEXTOUT),
    WmfRecordTypeBitBlt                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_BITBLT),
    WmfRecordTypeStretchBlt              = GDIP_WMF_RECORD_TO_EMFPLUS(META_STRETCHBLT),
    WmfRecordTypePolygon                 = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYGON),
    WmfRecordTypePolyline                = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYLINE),
    WmfRecordTypeEscape                  = GDIP_WMF_RECORD_TO_EMFPLUS(META_ESCAPE),
    WmfRecordTypeRestoreDC               = GDIP_WMF_RECORD_TO_EMFPLUS(META_RESTOREDC),
    WmfRecordTypeFillRegion              = GDIP_WMF_RECORD_TO_EMFPLUS(META_FILLREGION),
    WmfRecordTypeFrameRegion             = GDIP_WMF_RECORD_TO_EMFPLUS(META_FRAMEREGION),
    WmfRecordTypeInvertRegion            = GDIP_WMF_RECORD_TO_EMFPLUS(META_INVERTREGION),
    WmfRecordTypePaintRegion             = GDIP_WMF_RECORD_TO_EMFPLUS(META_PAINTREGION),
    WmfRecordTypeSelectClipRegion        = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTCLIPREGION),
    WmfRecordTypeSelectObject            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTOBJECT),
    WmfRecordTypeSetTextAlign            = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETTEXTALIGN),
    WmfRecordTypeChord                   = GDIP_WMF_RECORD_TO_EMFPLUS(META_CHORD),
    WmfRecordTypeSetMapperFlags          = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETMAPPERFLAGS),
    WmfRecordTypeExtTextOut              = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXTTEXTOUT),
    WmfRecordTypeSetDIBToDev             = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETDIBTODEV),
    WmfRecordTypeSelectPalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_SELECTPALETTE),
    WmfRecordTypeRealizePalette          = GDIP_WMF_RECORD_TO_EMFPLUS(META_REALIZEPALETTE),
    WmfRecordTypeAnimatePalette          = GDIP_WMF_RECORD_TO_EMFPLUS(META_ANIMATEPALETTE),
    WmfRecordTypeSetPalEntries           = GDIP_WMF_RECORD_TO_EMFPLUS(META_SETPALENTRIES),
    WmfRecordTypePolyPolygon             = GDIP_WMF_RECORD_TO_EMFPLUS(META_POLYPOLYGON),
    WmfRecordTypeResizePalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_RESIZEPALETTE),
    WmfRecordTypeDIBBitBlt               = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBBITBLT),
    WmfRecordTypeDIBStretchBlt           = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBSTRETCHBLT),
    WmfRecordTypeDIBCreatePatternBrush   = GDIP_WMF_RECORD_TO_EMFPLUS(META_DIBCREATEPATTERNBRUSH),
    WmfRecordTypeStretchDIB              = GDIP_WMF_RECORD_TO_EMFPLUS(META_STRETCHDIB),
    WmfRecordTypeExtFloodFill            = GDIP_WMF_RECORD_TO_EMFPLUS(META_EXTFLOODFILL),
    WmfRecordTypeSetLayout               = GDIP_WMF_RECORD_TO_EMFPLUS(0x0149), // META_SETLAYOUT
    WmfRecordTypeDeleteObject            = GDIP_WMF_RECORD_TO_EMFPLUS(META_DELETEOBJECT),
    WmfRecordTypeCreatePalette           = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPALETTE),
    WmfRecordTypeCreatePatternBrush      = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPATTERNBRUSH),
    WmfRecordTypeCreatePenIndirect       = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEPENINDIRECT),
    WmfRecordTypeCreateFontIndirect      = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEFONTINDIRECT),
    WmfRecordTypeCreateBrushIndirect     = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEBRUSHINDIRECT),
    WmfRecordTypeCreateRegion            = GDIP_WMF_RECORD_TO_EMFPLUS(META_CREATEREGION),

    EmfRecordTypeHeader                  = EMR_HEADER,
    EmfRecordTypePolyBezier              = EMR_POLYBEZIER,
    EmfRecordTypePolygon                 = EMR_POLYGON,
    EmfRecordTypePolyline                = EMR_POLYLINE,
    EmfRecordTypePolyBezierTo            = EMR_POLYBEZIERTO,
    EmfRecordTypePolyLineTo              = EMR_POLYLINETO,
    EmfRecordTypePolyPolyline            = EMR_POLYPOLYLINE,
    EmfRecordTypePolyPolygon             = EMR_POLYPOLYGON,
    EmfRecordTypeSetWindowExtEx          = EMR_SETWINDOWEXTEX,
    EmfRecordTypeSetWindowOrgEx          = EMR_SETWINDOWORGEX,
    EmfRecordTypeSetViewportExtEx        = EMR_SETVIEWPORTEXTEX,
    EmfRecordTypeSetViewportOrgEx        = EMR_SETVIEWPORTORGEX,
    EmfRecordTypeSetBrushOrgEx           = EMR_SETBRUSHORGEX,
    EmfRecordTypeEOF                     = EMR_EOF,
    EmfRecordTypeSetPixelV               = EMR_SETPIXELV,
    EmfRecordTypeSetMapperFlags          = EMR_SETMAPPERFLAGS,
    EmfRecordTypeSetMapMode              = EMR_SETMAPMODE,
    EmfRecordTypeSetBkMode               = EMR_SETBKMODE,
    EmfRecordTypeSetPolyFillMode         = EMR_SETPOLYFILLMODE,
    EmfRecordTypeSetROP2                 = EMR_SETROP2,
    EmfRecordTypeSetStretchBltMode       = EMR_SETSTRETCHBLTMODE,
    EmfRecordTypeSetTextAlign            = EMR_SETTEXTALIGN,
    EmfRecordTypeSetColorAdjustment      = EMR_SETCOLORADJUSTMENT,
    EmfRecordTypeSetTextColor            = EMR_SETTEXTCOLOR,
    EmfRecordTypeSetBkColor              = EMR_SETBKCOLOR,
    EmfRecordTypeOffsetClipRgn           = EMR_OFFSETCLIPRGN,
    EmfRecordTypeMoveToEx                = EMR_MOVETOEX,
    EmfRecordTypeSetMetaRgn              = EMR_SETMETARGN,
    EmfRecordTypeExcludeClipRect         = EMR_EXCLUDECLIPRECT,
    EmfRecordTypeIntersectClipRect       = EMR_INTERSECTCLIPRECT,
    EmfRecordTypeScaleViewportExtEx      = EMR_SCALEVIEWPORTEXTEX,
    EmfRecordTypeScaleWindowExtEx        = EMR_SCALEWINDOWEXTEX,
    EmfRecordTypeSaveDC                  = EMR_SAVEDC,
    EmfRecordTypeRestoreDC               = EMR_RESTOREDC,
    EmfRecordTypeSetWorldTransform       = EMR_SETWORLDTRANSFORM,
    EmfRecordTypeModifyWorldTransform    = EMR_MODIFYWORLDTRANSFORM,
    EmfRecordTypeSelectObject            = EMR_SELECTOBJECT,
    EmfRecordTypeCreatePen               = EMR_CREATEPEN,
    EmfRecordTypeCreateBrushIndirect     = EMR_CREATEBRUSHINDIRECT,
    EmfRecordTypeDeleteObject            = EMR_DELETEOBJECT,
    EmfRecordTypeAngleArc                = EMR_ANGLEARC,
    EmfRecordTypeEllipse                 = EMR_ELLIPSE,
    EmfRecordTypeRectangle               = EMR_RECTANGLE,
    EmfRecordTypeRoundRect               = EMR_ROUNDRECT,
    EmfRecordTypeArc                     = EMR_ARC,
    EmfRecordTypeChord                   = EMR_CHORD,
    EmfRecordTypePie                     = EMR_PIE,
    EmfRecordTypeSelectPalette           = EMR_SELECTPALETTE,
    EmfRecordTypeCreatePalette           = EMR_CREATEPALETTE,
    EmfRecordTypeSetPaletteEntries       = EMR_SETPALETTEENTRIES,
    EmfRecordTypeResizePalette           = EMR_RESIZEPALETTE,
    EmfRecordTypeRealizePalette          = EMR_REALIZEPALETTE,
    EmfRecordTypeExtFloodFill            = EMR_EXTFLOODFILL,
    EmfRecordTypeLineTo                  = EMR_LINETO,
    EmfRecordTypeArcTo                   = EMR_ARCTO,
    EmfRecordTypePolyDraw                = EMR_POLYDRAW,
    EmfRecordTypeSetArcDirection         = EMR_SETARCDIRECTION,
    EmfRecordTypeSetMiterLimit           = EMR_SETMITERLIMIT,
    EmfRecordTypeBeginPath               = EMR_BEGINPATH,
    EmfRecordTypeEndPath                 = EMR_ENDPATH,
    EmfRecordTypeCloseFigure             = EMR_CLOSEFIGURE,
    EmfRecordTypeFillPath                = EMR_FILLPATH,
    EmfRecordTypeStrokeAndFillPath       = EMR_STROKEANDFILLPATH,
    EmfRecordTypeStrokePath              = EMR_STROKEPATH,
    EmfRecordTypeFlattenPath             = EMR_FLATTENPATH,
    EmfRecordTypeWidenPath               = EMR_WIDENPATH,
    EmfRecordTypeSelectClipPath          = EMR_SELECTCLIPPATH,
    EmfRecordTypeAbortPath               = EMR_ABORTPATH,
    EmfRecordTypeReserved_069            = 69,  // Not Used
    EmfRecordTypeGdiComment              = EMR_GDICOMMENT,
    EmfRecordTypeFillRgn                 = EMR_FILLRGN,
    EmfRecordTypeFrameRgn                = EMR_FRAMERGN,
    EmfRecordTypeInvertRgn               = EMR_INVERTRGN,
    EmfRecordTypePaintRgn                = EMR_PAINTRGN,
    EmfRecordTypeExtSelectClipRgn        = EMR_EXTSELECTCLIPRGN,
    EmfRecordTypeBitBlt                  = EMR_BITBLT,
    EmfRecordTypeStretchBlt              = EMR_STRETCHBLT,
    EmfRecordTypeMaskBlt                 = EMR_MASKBLT,
    EmfRecordTypePlgBlt                  = EMR_PLGBLT,
    EmfRecordTypeSetDIBitsToDevice       = EMR_SETDIBITSTODEVICE,
    EmfRecordTypeStretchDIBits           = EMR_STRETCHDIBITS,
    EmfRecordTypeExtCreateFontIndirect   = EMR_EXTCREATEFONTINDIRECTW,
    EmfRecordTypeExtTextOutA             = EMR_EXTTEXTOUTA,
    EmfRecordTypeExtTextOutW             = EMR_EXTTEXTOUTW,
    EmfRecordTypePolyBezier16            = EMR_POLYBEZIER16,
    EmfRecordTypePolygon16               = EMR_POLYGON16,
    EmfRecordTypePolyline16              = EMR_POLYLINE16,
    EmfRecordTypePolyBezierTo16          = EMR_POLYBEZIERTO16,
    EmfRecordTypePolylineTo16            = EMR_POLYLINETO16,
    EmfRecordTypePolyPolyline16          = EMR_POLYPOLYLINE16,
    EmfRecordTypePolyPolygon16           = EMR_POLYPOLYGON16,
    EmfRecordTypePolyDraw16              = EMR_POLYDRAW16,
    EmfRecordTypeCreateMonoBrush         = EMR_CREATEMONOBRUSH,
    EmfRecordTypeCreateDIBPatternBrushPt = EMR_CREATEDIBPATTERNBRUSHPT,
    EmfRecordTypeExtCreatePen            = EMR_EXTCREATEPEN,
    EmfRecordTypePolyTextOutA            = EMR_POLYTEXTOUTA,
    EmfRecordTypePolyTextOutW            = EMR_POLYTEXTOUTW,
    EmfRecordTypeSetICMMode              = 98,  // EMR_SETICMMODE,
    EmfRecordTypeCreateColorSpace        = 99,  // EMR_CREATECOLORSPACE,
    EmfRecordTypeSetColorSpace           = 100, // EMR_SETCOLORSPACE,
    EmfRecordTypeDeleteColorSpace        = 101, // EMR_DELETECOLORSPACE,
    EmfRecordTypeGLSRecord               = 102, // EMR_GLSRECORD,
    EmfRecordTypeGLSBoundedRecord        = 103, // EMR_GLSBOUNDEDRECORD,
    EmfRecordTypePixelFormat             = 104, // EMR_PIXELFORMAT,
    EmfRecordTypeDrawEscape              = 105, // EMR_RESERVED_105,
    EmfRecordTypeExtEscape               = 106, // EMR_RESERVED_106,
    EmfRecordTypeStartDoc                = 107, // EMR_RESERVED_107,
    EmfRecordTypeSmallTextOut            = 108, // EMR_RESERVED_108,
    EmfRecordTypeForceUFIMapping         = 109, // EMR_RESERVED_109,
    EmfRecordTypeNamedEscape             = 110, // EMR_RESERVED_110,
    EmfRecordTypeColorCorrectPalette     = 111, // EMR_COLORCORRECTPALETTE,
    EmfRecordTypeSetICMProfileA          = 112, // EMR_SETICMPROFILEA,
    EmfRecordTypeSetICMProfileW          = 113, // EMR_SETICMPROFILEW,
    EmfRecordTypeAlphaBlend              = 114, // EMR_ALPHABLEND,
    EmfRecordTypeSetLayout               = 115, // EMR_SETLAYOUT,
    EmfRecordTypeTransparentBlt          = 116, // EMR_TRANSPARENTBLT,
    EmfRecordTypeReserved_117            = 117, // Not Used
    EmfRecordTypeGradientFill            = 118, // EMR_GRADIENTFILL,
    EmfRecordTypeSetLinkedUFIs           = 119, // EMR_RESERVED_119,
    EmfRecordTypeSetTextJustification    = 120, // EMR_RESERVED_120,
    EmfRecordTypeColorMatchToTargetW     = 121, // EMR_COLORMATCHTOTARGETW,
    EmfRecordTypeCreateColorSpaceW       = 122, // EMR_CREATECOLORSPACEW,
    EmfRecordTypeMax                     = 122,
    EmfRecordTypeMin                     = 1,

    // That is the END of the GDI EMF records.

    // Now we start the list of EMF+ records.  We leave quite
    // a bit of room here for the addition of any new GDI
    // records that may be added later.

    EmfPlusRecordTypeInvalid = GDIP_EMFPLUS_RECORD_BASE,
    EmfPlusRecordTypeHeader,
    EmfPlusRecordTypeEndOfFile,

    EmfPlusRecordTypeComment,

    EmfPlusRecordTypeGetDC,    // the application grabbed the metafile dc

    EmfPlusRecordTypeMultiFormatStart,
    EmfPlusRecordTypeMultiFormatSection,
    EmfPlusRecordTypeMultiFormatEnd,

    // For all persistent objects
    EmfPlusRecordTypeObject, // brush,pen,path,region,image,font,string-format

    // Drawing Records
    EmfPlusRecordTypeClear,
    EmfPlusRecordTypeFillRects,
    EmfPlusRecordTypeDrawRects,
    EmfPlusRecordTypeFillPolygon,
    EmfPlusRecordTypeDrawLines,
    EmfPlusRecordTypeFillEllipse,
    EmfPlusRecordTypeDrawEllipse,
    EmfPlusRecordTypeFillPie,
    EmfPlusRecordTypeDrawPie,
    EmfPlusRecordTypeDrawArc,
    EmfPlusRecordTypeFillRegion,
    EmfPlusRecordTypeFillPath,
    EmfPlusRecordTypeDrawPath,
    EmfPlusRecordTypeFillClosedCurve,
    EmfPlusRecordTypeDrawClosedCurve,
    EmfPlusRecordTypeDrawCurve,
    EmfPlusRecordTypeDrawBeziers,
    EmfPlusRecordTypeDrawImage,
    EmfPlusRecordTypeDrawImagePoints,
    EmfPlusRecordTypeDrawString,

    // Graphics State Records
    EmfPlusRecordTypeSetRenderingOrigin,
    EmfPlusRecordTypeSetAntiAliasMode,
    EmfPlusRecordTypeSetTextRenderingHint,
    EmfPlusRecordTypeSetTextGammaValue,
    EmfPlusRecordTypeSetInterpolationMode,
    EmfPlusRecordTypeSetPixelOffsetMode,
    EmfPlusRecordTypeSetCompositingMode,
    EmfPlusRecordTypeSetCompositingQuality,
    EmfPlusRecordTypeSave,
    EmfPlusRecordTypeRestore,
    EmfPlusRecordTypeBeginContainer,
    EmfPlusRecordTypeBeginContainerNoParams,
    EmfPlusRecordTypeEndContainer,
    EmfPlusRecordTypeSetWorldTransform,
    EmfPlusRecordTypeResetWorldTransform,
    EmfPlusRecordTypeMultiplyWorldTransform,
    EmfPlusRecordTypeTranslateWorldTransform,
    EmfPlusRecordTypeScaleWorldTransform,
    EmfPlusRecordTypeRotateWorldTransform,
    EmfPlusRecordTypeSetPageTransform,
    EmfPlusRecordTypeResetClip,
    EmfPlusRecordTypeSetClipRect,
    EmfPlusRecordTypeSetClipPath,
    EmfPlusRecordTypeSetClipRegion,
    EmfPlusRecordTypeOffsetClip,

    // New record types must be added here (at the end) -- do not add above, 
    // since that will invalidate previous metafiles!
    EmfPlusRecordTypeDrawDriverString,

    // Have this here so you don't need to keep changing the value of
    // EmfPlusRecordTypeMax every time you add a new record.

    EmfPlusRecordTotal,

    EmfPlusRecordTypeMax = EmfPlusRecordTotal-1,
    EmfPlusRecordTypeMin = EmfPlusRecordTypeHeader,
};

//---------------------------------------------------------------------------
// StringFormatFlags
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// String format flags
//
//  DirectionRightToLeft          - For horizontal text, the reading order is
//                                  right to left. This value is called
//                                  the base embedding level by the Unicode
//                                  bidirectional engine.
//                                  For vertical text, columns are read from
//                                  right to left.
//                                  By default, horizontal or vertical text is
//                                  read from left to right.
//
//  DirectionVertical             - Individual lines of text are vertical. In
//                                  each line, characters progress from top to
//                                  bottom.
//                                  By default, lines of text are horizontal,
//                                  each new line below the previous line.
//
//  NoFitBlackBox                 - Allows parts of glyphs to overhang the
//                                  bounding rectangle.
//                                  By default glyphs are first aligned
//                                  inside the margines, then any glyphs which
//                                  still overhang the bounding box are
//                                  repositioned to avoid any overhang.
//                                  For example when an italic
//                                  lower case letter f in a font such as
//                                  Garamond is aligned at the far left of a
//                                  rectangle, the lower part of the f will
//                                  reach slightly further left than the left
//                                  edge of the rectangle. Setting this flag
//                                  will ensure the character aligns visually
//                                  with the lines above and below, but may
//                                  cause some pixels outside the formatting
//                                  rectangle to be clipped or painted.
//
//  NumberContextArabic           - Causes any initial numeric in the string to
//                                  be analysed for bidirection layout as if
//                                  it was preceeded by Arabic text.
//
//  DisableKashidaJustification   - Arabic text will not be justified by the
//                                  insertion of kashidas (i.e. extending the
//                                  joining line between characters). Instead
//                                  Arabic script will be justified by the
//                                  widening of the whitespace between words.
//
//  DisplayFormatControl          - Causes control characters such as the
//                                  left-to-right mark to be shown in the
//                                  output with a representative glyph.
//
//  DisableKerning                - Disables Truetype and OpenType kerning.
//
//  DisableLigatures              - Disables Truetype and OpenType ligatures.
//
//  LayoutLegacyBidi              - Causes the bidirection algorithm to use
//                                  slightly different classifications for
//                                  '+', '-' and '/' that make their layout
//                                  much closer to that expected by files
//                                  generated in Windows or by Windows
//                                  applications.
//
//  NoChanges                     - A text imager created with this flag set
//                                  does not support those APIs that change
//                                  it's contents or formatting, but for most
//                                  simple text will be significantly faster in
//                                  performing measurement and drawing
//                                  functions.
//
//  NoFontFallback                - Disables fallback to alternate fonts for
//                                  characters not supported in the requested
//                                  font. Any missing characters will be
//                                  be displayed with the fonts missing glyph,
//                                  usually an open square.
//
//  NoWrap                        - Disables wrapping of text between lines
//                                  when formatting within a rectangle.
//                                  NoWrap is implied when a point is passed
//                                  instead of a rectangle, or when the
//                                  specified rectangle has a zero line length.
//
//  NoClip                        - By default text is clipped to the
//                                  formatting rectangle. Setting NoClip
//                                  allows overhanging pixels to affect the
//                                  device outside the formatting rectangle.
//                                  Pixels at the end of the line may be
//                                  affected if the glyphs overhang their
//                                  cells, and either the NoFitBlackBox flag
//                                  has been set, or the glyph extends to far
//                                  to be fitted.
//                                  Pixels above/before the first line or
//                                  below/after the last line may be affected
//                                  if the glyphs extend beyond their cell
//                                  ascent / descent. This can occur rarely
//                                  with unusual diacritic mark combinations.

//---------------------------------------------------------------------------

enum StringFormatFlags
{
    StringFormatFlagsDirectionRightToLeft        = 0x00000001,
    StringFormatFlagsDirectionVertical           = 0x00000002,
    StringFormatFlagsNoFitBlackBox               = 0x00000004,
    StringFormatFlagsNumberContextArabic         = 0x00000008,
    StringFormatFlagsDisableKashidaJustification = 0x00000010,
    StringFormatFlagsDisplayFormatControl        = 0x00000020,
    StringFormatFlagsDisableKerning              = 0x00000040,
    StringFormatFlagsDisableLigatures            = 0x00000080,
    StringFormatFlagsLayoutLegacyBidi            = 0x00000100,
    StringFormatFlagsNoChanges                   = 0x00000200,
    StringFormatFlagsNoFontFallback              = 0x00000400,
    StringFormatFlagsMeasureTrailingSpaces       = 0x00000800,
    StringFormatFlagsNoWrap                      = 0x00001000,
    StringFormatFlagsLineLimit                   = 0x00002000,

    StringFormatFlagsNoClip                      = 0x00004000
};

//---------------------------------------------------------------------------
// StringTrimming
//---------------------------------------------------------------------------

enum StringTrimming {
    StringTrimmingNone              = 0,
    StringTrimmingCharacter         = 1,
    StringTrimmingWord              = 2,
    StringTrimmingEllipsisCharacter = 3,
    StringTrimmingEllipsisWord      = 4,
    StringTrimmingEllipsisPath      = 5
};

//---------------------------------------------------------------------------
// String units
//
// String units are like length units in CSS, they may be absolute, or
// they may be relative to a font size.
//
//---------------------------------------------------------------------------

enum StringUnit {
    StringUnitWorld        = UnitWorld,
    StringUnitDisplay      = UnitDisplay,
    StringUnitPixel        = UnitPixel,
    StringUnitPoint        = UnitPoint,
    StringUnitInch         = UnitInch,
    StringUnitDocument     = UnitDocument,
    StringUnitMillimeter   = UnitMillimeter,
    StringUnitEm           = 32
};

//---------------------------------------------------------------------------
// Line spacing flags
//---------------------------------------------------------------------------

enum LineSpacing {
    LineSpacingWorld                = UnitWorld,
    LineSpacingDisplay              = UnitDisplay,
    LineSpacingPixel                = UnitPixel,
    LineSpacingPoint                = UnitPoint,
    LineSpacingInch                 = UnitInch,
    LineSpacingDocument             = UnitDocument,
    LineSpacingMillimeter           = UnitMillimeter,

    LineSpacingRecommended          = 32,
    LineSpacingAtLeast              = 33,
    LineSpacingAtLeastMultiple      = 34,
    LineSpacingCell                 = 35,
    LineSpacingCellAtLeast          = 36,
    LineSpacingCellAtLeastMultiple  = 37
};

/// The following methods of linespacing are relative to the font size
//
// =========== Method ===========  =============== Relative to ===============
//
// LineSpacingRecommended          recommended line spacing specified by font
// LineSpacingAtLeast              max(recommended, tallest glyph cell)
// LineSpacingAtLeastMultiple      smallest multiple of recommended big enough
//                                 for all glyph cells on the line
// LineSpacingCell                 cell height
// LineSpacingCellAtLeast          max(font cell height, tallest glyph cell)
// LineSpacingCellAtLeastMultiple  smallest multiple of cell height big enough
//                                 for all glyph cells on the line

//---------------------------------------------------------------------------
// National language digit substitution
//---------------------------------------------------------------------------

enum StringDigitSubstitute
{
    StringDigitSubstituteUser        = 0,  // As NLS setting
    StringDigitSubstituteNone        = 1,
    StringDigitSubstituteNational    = 2,
    StringDigitSubstituteTraditional = 3
};

//---------------------------------------------------------------------------
// Hotkey prefix interpretation
//---------------------------------------------------------------------------

enum HotkeyPrefix
{
    HotkeyPrefixNone        = 0,
    HotkeyPrefixShow        = 1,
    HotkeyPrefixHide        = 2
};

//---------------------------------------------------------------------------
// Text alignment flags
//---------------------------------------------------------------------------

enum StringAlignment
{
    // Left edge for left-to-right text,
    // right for right-to-left text,
    // and top for vertical
    StringAlignmentNear   = 0,
    StringAlignmentCenter = 1,
    StringAlignmentFar    = 2
};

//---------------------------------------------------------------------------
// DriverStringOptions
//---------------------------------------------------------------------------

enum DriverStringOptions
{
    DriverStringOptionsCmapLookup             = 1,
    DriverStringOptionsVertical               = 2,
    DriverStringOptionsRealizedAdvance        = 4,
    DriverStringOptionsCompensateResolution   = 8
};

//---------------------------------------------------------------------------
// Flush Intention flags
//---------------------------------------------------------------------------

enum FlushIntention
{
    FlushIntentionFlush = 0,        // Flush all batched rendering operations
    FlushIntentionSync = 1          // Flush all batched rendering operations
                                    // and wait for them to complete
};

//---------------------------------------------------------------------------
// Window Change Notification types
//---------------------------------------------------------------------------

enum WindowNotifyEnum
{
   WindowNotifyEnumEnable = 0,
   WindowNotifyEnumDisable,
   WindowNotifyEnumPalette,
   WindowNotifyEnumDisplay,
   WindowNotifyEnumSysColor
};

//---------------------------------------------------------------------------
// Image encoder parameter related types
//---------------------------------------------------------------------------

#ifdef DCR_USE_NEW_145804
enum EncoderParameterValueType
#else
enum ValueType
#endif
{
    ValueTypeByte           = 1,    // 8-bit unsigned int
    ValueTypeASCII          = 2,    // 8-bit byte containing one 7-bit ASCII
                                    // code. NULL terminated.
    ValueTypeShort          = 3,    // 16-bit unsigned int
    ValueTypeLong           = 4,    // 32-bit unsigned int
    ValueTypeRational       = 5,    // Two Longs. The first Long is the
                                    // numerator, the second Long expresses the
                                    // denomintor.
    ValueTypeLongRange      = 6,    // Two longs which specify a range of
                                    // integer values. The first Long specifies
                                    // the lower end and the second one
                                    // specifies the higher end. All values
                                    // are inclusive at both ends
    ValueTypeUndefined      = 7,    // 8-bit byte that can take any value
                                    // depending on field definition
    ValueTypeRationalRange  = 8     // Two Rationals. The first Rational
                                    // specifies the lower end and the second
                                    // specifies the higher end. All values
                                    // are inclusive at both ends
};

//---------------------------------------------------------------------------
// Image encoder value types
//---------------------------------------------------------------------------

enum EncoderValue
{
    EncoderValueColorTypeCMYK,
    EncoderValueColorTypeYCCK,
    EncoderValueCompressionLZW,
    EncoderValueCompressionCCITT3,
    EncoderValueCompressionCCITT4,
    EncoderValueCompressionRle,
    EncoderValueCompressionNone,
    EncoderValueScanMethodInterlaced,
    EncoderValueScanMethodNonInterlaced,
    EncoderValueVersionGif87,
    EncoderValueVersionGif89,
    EncoderValueRenderProgressive,
    EncoderValueRenderNonProgressive,
    EncoderValueTransformRotate90,
    EncoderValueTransformRotate180,
    EncoderValueTransformRotate270,
    EncoderValueTransformFlipHorizontal,
    EncoderValueTransformFlipVertical,
    #ifdef DCR_USE_NEW_140861
    EncoderValueMultiFrame,
    #else
    EncodeValueMultiFrame,
    #endif
    EncoderValueLastFrame,
    EncoderValueFlush,
    #ifdef DCR_USE_NEW_140861
    EncoderValueFrameDimensionTime,
    EncoderValueFrameDimensionResolution,
    EncoderValueFrameDimensionPage
    #else
    EncodeValueFrameDimensionTime,
    EncodeValueFrameDimensionResolution,
    EncodeValueFrameDimensionPage
    #endif
};

//---------------------------------------------------------------------------
// Graphics layout values (support for Middle East localization)
//---------------------------------------------------------------------------

enum GraphicsLayout
{
    GraphicsLayoutNormal,
    GraphicsLayoutMirrored,
    GraphicsLayoutMirroredIgnoreImages,
    GraphicsLayoutMirroredForceImages
};

//---------------------------------------------------------------------------
// Image layout values (support for Middle East localization)
//---------------------------------------------------------------------------

enum ImageLayout
{
    ImageLayoutNormal,
    ImageLayoutIgnoreMirrored
};

#endif // !_GDIPLUSENUMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusfontcollection.h ===
/**************************************************************************\
*
* Copyright (c) 2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   Font collections (Installed and Private)
*
* Revision History:
*
*   03/07/2000 DChinn
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSFONTCOLL_H
#define _GDIPLUSFONTCOLL_H

inline
FontCollection::FontCollection()
{
    nativeFontCollection = NULL;
}

inline
FontCollection::~FontCollection()
{
}

inline INT
FontCollection::GetFamilyCount() const
{
    INT numFound = 0;

    lastResult = DllExports::GdipGetFontCollectionFamilyCount(
                             nativeFontCollection, &numFound);



    return numFound;
}

inline Status
FontCollection::GetFamilies(
    IN INT           numSought,
    OUT FontFamily * gpfamilies,
    OUT INT *        numFound
) const
{
    if (numSought <= 0 || gpfamilies == NULL || numFound == NULL)
    {
        return SetStatus(InvalidParameter);
    }

    GpFontFamily **nativeFamilyList = new GpFontFamily*[numSought];

    if (nativeFamilyList == NULL)
    {
        return SetStatus(OutOfMemory);
    }

    Status status = SetStatus(DllExports::GdipGetFontCollectionFamilyList(
        nativeFontCollection,
        numSought,
        nativeFamilyList,
        numFound
    ));

    for (INT i = 0; i < *numFound; i++)
    {
        DllExports::GdipCloneFontFamily(nativeFamilyList[i],
                                        &gpfamilies[i].nativeFamily);
    }

    delete [] nativeFamilyList;

    return status;
}

inline Status FontCollection::GetLastStatus () const
{
    return lastResult;
}

// protected method
inline Status
FontCollection::SetStatus(IN Status status) const
{
    lastResult = status;
    return lastResult;
}

inline
InstalledFontCollection::InstalledFontCollection()
{
    nativeFontCollection = NULL;
    lastResult = DllExports::GdipNewInstalledFontCollection(&nativeFontCollection);
}

inline
InstalledFontCollection::~InstalledFontCollection()
{
}

inline Status
InstalledFontCollection::InstallFontFile(IN const WCHAR* filename)
{
    return SetStatus(DllExports::GdipInstallFontFile(nativeFontCollection, filename));
}

inline Status
InstalledFontCollection::UninstallFontFile(IN const WCHAR* filename)
{
    return SetStatus(DllExports::GdipUninstallFontFile(nativeFontCollection, filename));
}

inline
PrivateFontCollection::PrivateFontCollection()
{
    nativeFontCollection = NULL;
    lastResult = DllExports::GdipNewPrivateFontCollection(&nativeFontCollection);
}

inline
PrivateFontCollection::~PrivateFontCollection()
{
    DllExports::GdipDeletePrivateFontCollection(&nativeFontCollection);
}

inline Status
PrivateFontCollection::AddFontFile(IN const WCHAR* filename)
{
    return SetStatus(DllExports::GdipPrivateAddFontFile(nativeFontCollection, filename));
}

inline Status
PrivateFontCollection::AddMemoryFont(IN const void* memory,
                                     IN INT length)
{
    return SetStatus(DllExports::GdipPrivateAddMemoryFont(
        nativeFontCollection,
        memory,
        length));
}

#endif // _GDIPLUSFONTCOLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusfont.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   Font related declarations
*
* Revision History:
*
*   05/06/1999 ikkof
*       Created it.
*   22/July/1999  Xudong Wu [tessiew]
*       Modified it.
*
\**************************************************************************/

#ifndef _GDIPLUSFONT_H
#define _GDIPLUSFONT_H

inline
Font::Font(IN HDC hdc)
{
    GpFont *font = NULL;
    lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);

#ifndef DCR_USE_NEW_135429
    if ((INT) lastResult >= 10)
        lastResult = NotFound;
#endif

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const LOGFONTW* logfont)
{
    GpFont *font = NULL;
    if (logfont)
    {
        lastResult = DllExports::GdipCreateFontFromLogfontW(hdc, logfont, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

#ifndef DCR_USE_NEW_135429
    if ((INT) lastResult >= 10)
        lastResult = NotFound;
#endif

    SetNativeFont(font);
}

inline
Font::Font(IN HDC hdc,
           IN const LOGFONTA* logfont)
{
    GpFont *font = NULL;
    lastResult = DllExports::GdipCreateFontFromLogfontA(hdc, logfont, &font);
    if (logfont)
    {
        lastResult = DllExports::GdipCreateFontFromLogfontA(hdc, logfont, &font);
    }
    else
    {
        lastResult = DllExports::GdipCreateFontFromDC(hdc, &font);
    }

#ifndef DCR_USE_NEW_135429
    if ((INT) lastResult >= 10)
        lastResult = NotFound;
#endif

    SetNativeFont(font);
}

inline
Font::Font(
     IN const FontFamily * family,
     IN REAL         emSize,
     IN INT          style,
     IN Unit         unit
)
{
    GpFont *font = NULL;

    lastResult = DllExports::GdipCreateFont(family->nativeFamily,
                    emSize,
                    style,
                    unit,
                    &font);

#ifndef DCR_USE_NEW_135429
    if ((INT) lastResult >= 10)
        lastResult = NotFound;
#endif

    SetNativeFont(font);
}

inline
Font::Font(
     IN const WCHAR *          familyName,
     IN REAL                   emSize,
     IN INT                    style,
     IN Unit                   unit,
     IN const FontCollection * fontCollection
)
{
    FontFamily family(familyName, fontCollection);

    GpFont * font = NULL;

    lastResult = family.GetLastStatus();

    if (lastResult == Ok)
    {

        lastResult = DllExports::GdipCreateFont(family.nativeFamily,
                                emSize,
                                style,
                                unit,
                                &font);
    }

#ifndef DCR_USE_NEW_135429
    if ((INT) lastResult >= 10)
        lastResult = NotFound;
#endif

    SetNativeFont(font);
}

inline Status
Font::GetLogFontA(IN const Graphics *g,
                  OUT LOGFONTA *logfontA) const
{
    return SetStatus(DllExports::GdipGetLogFontA(nativeFont, g->nativeGraphics, logfontA));

}

inline Status
Font::GetLogFontW(IN const Graphics *g,
                  OUT LOGFONTW *logfontW) const
{
    return SetStatus(DllExports::GdipGetLogFontW(nativeFont, g->nativeGraphics, logfontW));
}


inline Font*
Font::Clone() const
{
    GpFont *cloneFont = NULL;

    SetStatus(DllExports::GdipCloneFont(nativeFont, &cloneFont));

    return new Font(cloneFont, lastResult);
}

inline
Font::~Font()
{
    DllExports::GdipDeleteFont(nativeFont);
}

// Operations

inline BOOL
Font::IsAvailable() const
{
    return (nativeFont ? TRUE : FALSE);
}

inline Status
Font::GetFamily(OUT FontFamily *family) const
{
    if (family == NULL) 
    {
        return SetStatus(InvalidParameter);
    }
    
    Status status = DllExports::GdipGetFamily(nativeFont, &(family->nativeFamily));
    family->SetStatus(status);

    return SetStatus(status);
}

inline INT
Font::GetStyle() const
{
    INT style;

    SetStatus(DllExports::GdipGetFontStyle(nativeFont, &style));

    return style;
}

inline REAL
Font::GetSize() const
{
    REAL size;
    SetStatus(DllExports::GdipGetFontSize(nativeFont, &size));
    return size;
}

inline Unit
Font::GetUnit() const
{
    Unit unit;
    SetStatus(DllExports::GdipGetFontUnit(nativeFont, &unit));
    return unit;
}

inline REAL
Font::GetHeight(IN const Graphics *graphics) const
{
    REAL height;
    SetStatus(DllExports::GdipGetFontHeight(
        nativeFont,
        graphics ? graphics->nativeGraphics : NULL,
        &height
    ));
    return height;
}

// protected method
inline
Font::Font(IN GpFont* font,
           IN Status status)
{
    lastResult = status;
    SetNativeFont(font);
}

// protected method
inline VOID
Font::SetNativeFont(GpFont *Font)
{
    nativeFont = Font;
}

inline Status
Font::GetLastStatus(void) const
{
    return lastResult;
}

// protected method
inline Status
Font::SetStatus(IN Status status) const
{
    if (status != Ok)
        return (lastResult = status);
    else
        return status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusfontfamily.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   Font family API related declarations
*
* Revision History:
*
*
*   06/30/1999 cameronb
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUS_FONT_FAMILY_H
#define _GDIPLUS_FONT_FAMILY_H

inline 
FontFamily::FontFamily() :
    nativeFamily (NULL),
    lastResult    (Ok)
{
}

inline 
FontFamily::FontFamily(
    IN const WCHAR*          name,
    IN const FontCollection* fontCollection
)
{
    nativeFamily = NULL;
    lastResult = DllExports::GdipCreateFontFamilyFromName(
        name,
        fontCollection ? fontCollection->nativeFontCollection : NULL,
        &nativeFamily
    );
    
#ifndef DCR_USE_NEW_135429
    if ((INT) lastResult >= 10)
        lastResult = NotFound;
#endif
}

// private method
inline
FontFamily::FontFamily(
    IN GpFontFamily *nativeOrig,
    IN Status status
)
{
    lastResult    = status;
    nativeFamily = nativeOrig;
}

// Generic font family access

inline const FontFamily *
FontFamily::GenericSansSerif() 
{
    if (GenericSansSerifFontFamily != NULL)
    {
        return GenericSansSerifFontFamily;
    }

    GenericSansSerifFontFamily =
        (FontFamily*) GenericSansSerifFontFamilyBuffer;

    GenericSansSerifFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilySansSerif(
            &(GenericSansSerifFontFamily->nativeFamily)
        );

#ifndef DCR_USE_NEW_135429
    if ((INT) GenericSansSerifFontFamily->lastResult >= 10)
        GenericSansSerifFontFamily->lastResult = NotFound;
#endif

    return GenericSansSerifFontFamily;
}

inline const FontFamily *
FontFamily::GenericSerif() 
{
    if (GenericSerifFontFamily != NULL)
    {
        return GenericSerifFontFamily;
    }

    GenericSerifFontFamily =
        (FontFamily*) GenericSerifFontFamilyBuffer;

    GenericSerifFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilySerif(
            &(GenericSerifFontFamily->nativeFamily)
        );

#ifndef DCR_USE_NEW_135429
    if ((INT) GenericSerifFontFamily->lastResult >= 10)
        GenericSerifFontFamily->lastResult = NotFound;
#endif

    return GenericSerifFontFamily;
}

inline const FontFamily *
FontFamily::GenericMonospace()
{
    if (GenericMonospaceFontFamily != NULL)
    {
        return GenericMonospaceFontFamily;
    }

    GenericMonospaceFontFamily =
        (FontFamily*) GenericMonospaceFontFamilyBuffer;

    GenericMonospaceFontFamily->lastResult =
        DllExports::GdipGetGenericFontFamilyMonospace(
            &(GenericMonospaceFontFamily->nativeFamily)
        );

#ifndef DCR_USE_NEW_135429
    if ((INT) GenericMonospaceFontFamily->lastResult >= 10)
        GenericMonospaceFontFamily->lastResult = NotFound;
#endif

    return GenericMonospaceFontFamily;
}

inline FontFamily::~FontFamily()
{
    DllExports::GdipDeleteFontFamily (nativeFamily);
}

inline FontFamily *
FontFamily::Clone() const
{
    GpFontFamily * clonedFamily = NULL;

    SetStatus(DllExports::GdipCloneFontFamily (nativeFamily, &clonedFamily));

    return new FontFamily(clonedFamily, lastResult);
}

inline Status 
FontFamily::GetFamilyName(
    IN WCHAR name[LF_FACESIZE],
    IN LANGID language
) const
{
    return SetStatus(DllExports::GdipGetFamilyName(nativeFamily, 
                                                   name, 
                                                   language));
}

inline BOOL 
FontFamily::IsStyleAvailable(IN INT style) const
{
    BOOL    StyleAvailable;
    Status  status;

    status = SetStatus(DllExports::GdipIsStyleAvailable(nativeFamily, style, &StyleAvailable));

    if (status != Ok)
        StyleAvailable = FALSE;

    return StyleAvailable;
}


inline UINT16 
FontFamily::GetEmHeight(IN INT style) const
{
    UINT16  EmHeight;

    SetStatus(DllExports::GdipGetEmHeight(nativeFamily, style, &EmHeight));

    return EmHeight;
}

inline UINT16 
FontFamily::GetCellAscent(IN INT style) const
{
    UINT16  CellAscent;

    SetStatus(DllExports::GdipGetCellAscent(nativeFamily, style, &CellAscent));

    return CellAscent;
}

inline UINT16 
FontFamily::GetCellDescent(IN INT style) const
{
    UINT16  CellDescent;

    SetStatus(DllExports::GdipGetCellDescent(nativeFamily, style, &CellDescent));

    return CellDescent;
}


inline UINT16 
FontFamily::GetLineSpacing(IN INT style) const
{
    UINT16  LineSpacing;

    SetStatus(DllExports::GdipGetLineSpacing(nativeFamily, style, &LineSpacing));

    return LineSpacing;

}

#ifdef TEXTV2

// The following APIs return data from the font OS/2 table

inline INT16 
FontFamily::GetTypographicAscent(IN INT style) const
{
    INT16  TypographicAscent;

    SetStatus(DllExports::GdipGetTypographicAscent(nativeFamily, style, &TypographicAscent));

    return TypographicAscent;
}

inline INT16 
FontFamily::GetTypographicDescent(IN INT style) const
{
    INT16   TypographicDescent;

    SetStatus(DllExports::GdipGetTypographicDescent(nativeFamily, style, &TypographicDescent));

    return TypographicDescent;
}

inline INT16 
FontFamily::GetTypographicLineGap(IN INT style) const
{
    INT16   TypographicLineGap;

    SetStatus(DllExports::GdipGetTypographicLineGap(nativeFamily, style, &TypographicLineGap));

    return TypographicLineGap;
}

#endif

///////////////////////////////////////////////////////////

// GetLastStatus - return last error code and clear error code

inline Status 
FontFamily::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

// protected method
inline Status
FontFamily::SetStatus(Status status) const 
{
    if (status != Ok)
        return (lastResult = status);
    else
        return status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusflat.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   flatapi.h
*
* Abstract:
*
*   Flat GDI+ API wrappers - header file
*
* Revision History:
*
*   12/13/1998 davidx
*       Created it.
*
\**************************************************************************/

// TODO: this file style needs to be made internally consistent with the way
//       it handles breaking the long argument lists across multiple lines

#ifndef _FLATAPI_H
#define _FLATAPI_H

#define WINGDIPAPI __stdcall

// currently, only C++ wrapper API's force const.

#define GDIPCONST const

#ifdef __cplusplus
extern "C" {
#endif

VOID
WINGDIPAPI
GdipDisplayPaletteWindowNotify(WindowNotifyEnum notify);

//----------------------------------------------------------------------------
// GraphicsPath methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePath(GpFillMode brushMode, GpPath **path);

GpStatus WINGDIPAPI
GdipCreatePath2(GDIPCONST GpPointF*, GDIPCONST BYTE*, INT, GpFillMode,
                                    GpPath **path);

GpStatus WINGDIPAPI
GdipCreatePath2I(GDIPCONST GpPoint*, GDIPCONST BYTE*, INT, GpFillMode,
                                     GpPath **path);

GpStatus WINGDIPAPI
GdipClonePath(GpPath* path, GpPath **clonePath);

GpStatus WINGDIPAPI
GdipDeletePath(GpPath* path);

GpStatus WINGDIPAPI
GdipResetPath(GpPath* path);

GpStatus WINGDIPAPI
GdipGetPointCount(GpPath* path, INT* count);

GpStatus WINGDIPAPI
GdipGetPathTypes(GpPath* path, BYTE* types, INT count);

GpStatus WINGDIPAPI
GdipGetPathPoints(GpPath*, GpPointF* points, INT count);

GpStatus WINGDIPAPI
GdipGetPathPointsI(GpPath*, GpPoint* points, INT count);

GpStatus WINGDIPAPI
GdipGetPathFillMode(GpPath *path, GpFillMode *fillmode);

GpStatus WINGDIPAPI
GdipSetPathFillMode(GpPath *path, GpFillMode fillmode);

GpStatus WINGDIPAPI
GdipGetPathData(GpPath *path, GpPathData* pathData);

GpStatus WINGDIPAPI
GdipStartPathFigure(GpPath *path);

GpStatus WINGDIPAPI
GdipClosePathFigure(GpPath *path);

GpStatus WINGDIPAPI
GdipClosePathFigures(GpPath *path);

GpStatus WINGDIPAPI
GdipSetPathMarker(GpPath* path);

GpStatus WINGDIPAPI
GdipClearPathMarkers(GpPath* path);

GpStatus WINGDIPAPI
GdipReversePath(GpPath* path);

GpStatus WINGDIPAPI
GdipGetPathLastPoint(GpPath* path, GpPointF* lastPoint);

GpStatus WINGDIPAPI
GdipAddPathLine(GpPath *path, REAL x1, REAL y1, REAL x2, REAL y2);

GpStatus WINGDIPAPI
GdipAddPathLine2(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathArc(GpPath *path, REAL x, REAL y, REAL width, REAL height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathBezier(GpPath *path, REAL x1, REAL y1, REAL x2, REAL y2,
                           REAL x3, REAL y3, REAL x4, REAL y4);

GpStatus WINGDIPAPI
GdipAddPathBeziers(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve2(GpPath *path, GDIPCONST GpPointF *points, INT count,
                           REAL tension);

GpStatus WINGDIPAPI
GdipAddPathCurve3(GpPath *path, GDIPCONST GpPointF *points, INT count,
                           INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve2(GpPath *path, GDIPCONST GpPointF *points, INT count,
                                 REAL tension);

GpStatus WINGDIPAPI
GdipAddPathRectangle(GpPath *path, REAL x, REAL y, REAL width, REAL height);

GpStatus WINGDIPAPI
GdipAddPathRectangles(GpPath *path, GDIPCONST GpRectF *rects, INT count);

GpStatus WINGDIPAPI
GdipAddPathEllipse(GpPath *path, REAL x, REAL y, REAL width,
                            REAL height);

GpStatus WINGDIPAPI
GdipAddPathPie(GpPath *path, REAL x, REAL y, REAL width, REAL height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathPolygon(GpPath *path, GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathPath(GpPath *path, GDIPCONST GpPath* addingPath, BOOL connect);

GpStatus WINGDIPAPI
GdipAddPathString(GpPath *path, GDIPCONST WCHAR *string,
                        INT length, GDIPCONST GpFontFamily *family, INT style,
                        REAL emSize, GDIPCONST RectF *layoutRect,
                        GDIPCONST GpStringFormat *format);

GpStatus WINGDIPAPI
GdipAddPathStringI(GpPath *path, GDIPCONST WCHAR *string,
                        INT length, GDIPCONST GpFontFamily *family, INT style,
                        REAL emSize, GDIPCONST Rect *layoutRect,
                        GDIPCONST GpStringFormat *format);

GpStatus WINGDIPAPI
GdipAddPathLineI(GpPath *path, INT x1, INT y1, INT x2, INT y2);

GpStatus WINGDIPAPI
GdipAddPathLine2I(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathArcI(GpPath *path, INT x, INT y, INT width, INT height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathBezierI(GpPath *path, INT x1, INT y1, INT x2, INT y2,
                           INT x3, INT y3, INT x4, INT y4);

GpStatus WINGDIPAPI
GdipAddPathBeziersI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurveI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathCurve2I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                           REAL tension);

GpStatus WINGDIPAPI
GdipAddPathCurve3I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                           INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipAddPathClosedCurveI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipAddPathClosedCurve2I(GpPath *path, GDIPCONST GpPoint *points, INT count,
                                 REAL tension);

GpStatus WINGDIPAPI
GdipAddPathRectangleI(GpPath *path, INT x, INT y, INT width, INT height);

GpStatus WINGDIPAPI
GdipAddPathRectanglesI(GpPath *path, GDIPCONST GpRect *rects, INT count);

GpStatus WINGDIPAPI
GdipAddPathEllipseI(GpPath *path, INT x, INT y, INT width, INT height);

GpStatus WINGDIPAPI
GdipAddPathPieI(GpPath *path, INT x, INT y, INT width, INT height,
                        REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipAddPathPolygonI(GpPath *path, GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFlattenPath(GpPath *path, GpMatrix* matrix, REAL flatness);

GpStatus WINGDIPAPI
GdipWidenPathWithMinimumResolutions(GpPath *path, GpPen *pen, REAL minXres,
            REAL minYres, GpMatrix *matrix, BOOL removeSelftIntersects);

GpStatus WINGDIPAPI
GdipWarpPath(GpPath *path, GpMatrix* matrix,
            GDIPCONST GpPointF *points, INT count,
            REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight,
            WarpMode warpMode, REAL flatness);

GpStatus WINGDIPAPI
GdipTransformPath(GpPath* path, GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetPathWorldBounds(GpPath* path, GpRectF* bounds, GDIPCONST GpMatrix *matrix,
                  GDIPCONST GpPen *pen);

GpStatus WINGDIPAPI
GdipGetPathWorldBoundsI(GpPath* path, GpRect* bounds, GDIPCONST GpMatrix *matrix,
                   GDIPCONST GpPen *pen);

GpStatus WINGDIPAPI
GdipIsVisiblePathPoint(GpPath* path, REAL x, REAL y,
                       GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePathPointI(GpPath* path, INT x, INT y,
                        GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsOutlineVisiblePathPoint(GpPath* path, REAL x, REAL y, GpPen *pen,
                              GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsOutlineVisiblePathPointI(GpPath* path, INT x, INT y, GpPen *pen,
                               GpGraphics *graphics, BOOL *result);

//----------------------------------------------------------------------------
// Path Enumeration methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePathIter(GpPathIterator **iterator, GpPath* path);

GpStatus WINGDIPAPI
GdipDeletePathIter(GpPathIterator *iterator);

GpStatus WINGDIPAPI
GdipPathIterNextSubpath(GpPathIterator* iterator, INT *resultCount,
        INT* startIndex, INT* endIndex, BOOL* isClosed);

GpStatus WINGDIPAPI
GdipPathIterNextSubpathPath(GpPathIterator* iterator, INT* resultCount,
        GpPath* path, BOOL* isClosed);

GpStatus WINGDIPAPI
GdipPathIterNextPathType(GpPathIterator* iterator, INT* resultCount,
        BYTE* pathType, INT* startIndex, INT* endIndex);

GpStatus WINGDIPAPI
GdipPathIterNextMarker(GpPathIterator* iterator, INT *resultCount,
        INT* startIndex, INT* endIndex);

GpStatus WINGDIPAPI
GdipPathIterNextMarkerPath(GpPathIterator* iterator, INT* resultCount,
        GpPath* path);

GpStatus WINGDIPAPI
GdipPathIterGetCount(GpPathIterator* iterator, INT* count);

GpStatus WINGDIPAPI
GdipPathIterGetSubpathCount(GpPathIterator* iterator, INT* count);

GpStatus WINGDIPAPI
GdipPathIterIsValid(GpPathIterator* iterator, BOOL* valid);

GpStatus WINGDIPAPI
GdipPathIterHasCurve(GpPathIterator* iterator, BOOL* hasCurve);

GpStatus WINGDIPAPI
GdipPathIterRewind(GpPathIterator* iterator);

GpStatus WINGDIPAPI
GdipPathIterEnumerate(GpPathIterator* iterator, INT* resultCount,
    GpPointF *points, BYTE *types, INT count);

GpStatus WINGDIPAPI
GdipPathIterCopyData(GpPathIterator* iterator, INT* resultCount,
    GpPointF* points, BYTE* types, INT startIndex, INT endIndex);

//----------------------------------------------------------------------------
// Matrix methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateMatrix(GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix2(REAL m11, REAL m12, REAL m21, REAL m22, REAL dx,
                                      REAL dy, GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix3(GDIPCONST GpRectF *rect, GDIPCONST GpPointF *dstplg,
                                      GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCreateMatrix3I(GDIPCONST GpRect *rect, GDIPCONST GpPoint *dstplg,
                                       GpMatrix **matrix);

GpStatus WINGDIPAPI
GdipCloneMatrix(GpMatrix *matrix, GpMatrix **cloneMatrix);

GpStatus WINGDIPAPI
GdipDeleteMatrix(GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetMatrixElements(GpMatrix *matrix, REAL m11, REAL m12, REAL m21, REAL m22,
                      REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipMultiplyMatrix(GpMatrix *matrix, GpMatrix* matrix2,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateMatrix(GpMatrix *matrix, REAL offsetX, REAL offsetY,
                    GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleMatrix(GpMatrix *matrix, REAL scaleX, REAL scaleY,
                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateMatrix(GpMatrix *matrix, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipShearMatrix(GpMatrix *matrix, REAL shearX, REAL shearY,
                GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipInvertMatrix(GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipTransformMatrixPoints(GpMatrix *matrix, GpPointF *pts, INT count);

GpStatus WINGDIPAPI
GdipTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts, INT count);

GpStatus WINGDIPAPI
GdipVectorTransformMatrixPoints(GpMatrix *matrix, GpPointF *pts,
                                         INT count);

GpStatus WINGDIPAPI
GdipVectorTransformMatrixPointsI(GpMatrix *matrix, GpPoint *pts,
                                         INT count);

GpStatus WINGDIPAPI
GdipGetMatrixElements(GpMatrix *matrix, REAL *matrixOut);

GpStatus WINGDIPAPI
GdipIsMatrixInvertible(GpMatrix *matrix, BOOL *result);

GpStatus WINGDIPAPI
GdipIsMatrixIdentity(GpMatrix *matrix, BOOL *result);

GpStatus WINGDIPAPI
GdipIsMatrixEqual(GpMatrix *matrix, GpMatrix *matrix2, BOOL *result);

//----------------------------------------------------------------------------
// Region methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateRegion(GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRect(GDIPCONST GpRectF *rect, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRectI(GDIPCONST GpRect *rect, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionPath(GpPath *path, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionRgnData(GDIPCONST BYTE *regionData, INT size, GpRegion **region);

GpStatus WINGDIPAPI
GdipCreateRegionHrgn(HRGN hRgn, GpRegion **region);

GpStatus WINGDIPAPI
GdipCloneRegion(GpRegion *region, GpRegion **cloneRegion);

GpStatus WINGDIPAPI
GdipDeleteRegion(GpRegion *region);

GpStatus WINGDIPAPI
GdipSetInfinite(GpRegion *region);

GpStatus WINGDIPAPI
GdipSetEmpty(GpRegion *region);

GpStatus WINGDIPAPI
GdipCombineRegionRect(GpRegion *region, GDIPCONST GpRectF *rect,
                      CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionRectI(GpRegion *region, GDIPCONST GpRect *rect,
                       CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionPath(GpRegion *region, GpPath *path, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipCombineRegionRegion(GpRegion *region,  GpRegion *region2,
                        CombineMode combineMode);

GpStatus WINGDIPAPI
GdipTranslateRegion(GpRegion *region, REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipTranslateRegionI(GpRegion *region, INT dx, INT dy);

GpStatus WINGDIPAPI
GdipTransformRegion(GpRegion *region, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipGetRegionBounds(GpRegion *region, GpGraphics *graphics,
                             GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetRegionBoundsI(GpRegion *region, GpGraphics *graphics,
                             GpRect *rect);

GpStatus WINGDIPAPI
GdipGetRegionHRgn(GpRegion *region, GpGraphics *graphics, HRGN *hRgn);

GpStatus WINGDIPAPI
GdipIsEmptyRegion(GpRegion *region, GpGraphics *graphics,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsInfiniteRegion(GpRegion *region, GpGraphics *graphics,
                              BOOL *result);

GpStatus WINGDIPAPI
GdipIsEqualRegion(GpRegion *region, GpRegion *region2,
                           GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetRegionDataSize(GpRegion *region, UINT * bufferSize);

GpStatus WINGDIPAPI
GdipGetRegionData(GpRegion *region, BYTE * buffer, UINT bufferSize, UINT * sizeFilled);

GpStatus WINGDIPAPI
GdipIsVisibleRegionPoint(GpRegion *region, REAL x, REAL y,
                                  GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionPointI(GpRegion *region, INT x, INT y,
                                  GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionRect(GpRegion *region, REAL x, REAL y, REAL width,
                        REAL height, GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRegionRectI(GpRegion *region, INT x, INT y, INT width,
                         INT height, GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetRegionScansCount(GpRegion *region, UINT* count, GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetRegionScans(GpRegion *region, GpRectF* rects, INT* count, GpMatrix* matrix);

GpStatus WINGDIPAPI
GdipGetRegionScansI(GpRegion *region, GpRect* rects, INT* count, GpMatrix* matrix);

//----------------------------------------------------------------------------
// Brush methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCloneBrush(GpBrush *brush, GpBrush **cloneBrush);

GpStatus WINGDIPAPI
GdipDeleteBrush(GpBrush *brush);

GpStatus WINGDIPAPI
GdipGetBrushType(GpBrush *brush, GpBrushType *type);

//----------------------------------------------------------------------------
// Hatch Brush methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateHatchBrush(GpHatchStyle hatchstyle, ARGB forecol,
                              ARGB backcol, GpHatch **brush);

GpStatus WINGDIPAPI
GdipGetHatchStyle(GpHatch *brush, GpHatchStyle *hatchstyle);

GpStatus WINGDIPAPI
GdipGetHatchForegroundColor(GpHatch *brush, ARGB* forecol);

GpStatus WINGDIPAPI
GdipGetHatchBackgroundColor(GpHatch *brush, ARGB* backcol);

//----------------------------------------------------------------------------
// Texture Brush methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateTexture(GpImage *image, GpWrapMode wrapmode,
                           GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTexture2(GpImage *image, GpWrapMode wrapmode, REAL x,
                   REAL y, REAL width, REAL height, GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTextureIA(GpImage *image, GpImageAttributes *imageAttributes,
                    REAL x, REAL y, REAL width, REAL height,
                    GpTexture **texture);

GpStatus WINGDIPAPI
GdipCreateTexture2I(GpImage *image, GpWrapMode wrapmode, INT x,
                    INT y, INT width, INT height, GpTexture **texture);

GpStatus WINGDIPAPI
GdipGetTextureTransform(GpTexture *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetTextureTransform(GpTexture *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetTextureTransform(GpTexture* brush);

GpStatus WINGDIPAPI
GdipMultiplyTextureTransform(GpTexture* brush, GpMatrix *matrix,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateTextureTransform(GpTexture* brush, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleTextureTransform(GpTexture* brush, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateTextureTransform(GpTexture* brush, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipSetTextureWrapMode(GpTexture *brush, GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetTextureWrapMode(GpTexture *brush, GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipGetTextureImage(GpTexture *brush, GpImage **image);

//----------------------------------------------------------------------------
// Solid Brush methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateSolidFill(ARGB color, GpSolidFill **brush);

GpStatus WINGDIPAPI
GdipSetSolidFillColor(GpSolidFill *brush, ARGB color);

GpStatus WINGDIPAPI
GdipGetSolidFillColor(GpSolidFill *brush, ARGB *color);

//----------------------------------------------------------------------------
// LineBrush methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateLineBrush(GDIPCONST GpPointF* point1,
                    GDIPCONST GpPointF* point2,
                    ARGB color1, ARGB color2,
                    GpWrapMode wrapMode,
                    GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushI(GDIPCONST GpPoint* point1,
                     GDIPCONST GpPoint* point2,
                     ARGB color1, ARGB color2,
                     GpWrapMode wrapMode,
                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRect(GDIPCONST GpRectF* rect,
                            ARGB color1, ARGB color2,
                            LinearGradientMode mode,
                            GpWrapMode wrapMode,
                            GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectI(GDIPCONST GpRect* rect,
                             ARGB color1, ARGB color2,
                             LinearGradientMode mode,
                             GpWrapMode wrapMode,
                             GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectWithAngle(GDIPCONST GpRectF* rect,
                                     ARGB color1, ARGB color2,
                                     REAL angle,
                                     BOOL isAngleScalable,
                                     GpWrapMode wrapMode,
                                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipCreateLineBrushFromRectWithAngleI(GDIPCONST GpRect* rect,
                                     ARGB color1, ARGB color2,
                                     REAL angle,
                                     BOOL isAngleScalable,
                                     GpWrapMode wrapMode,
                                     GpLineGradient **lineGradient);

GpStatus WINGDIPAPI
GdipSetLinePoints(GpLineGradient *brush,
                  GDIPCONST GpPointF* point1,
                  GDIPCONST GpPointF* point2);

GpStatus WINGDIPAPI
GdipSetLinePointsI(GpLineGradient *brush,
                   GDIPCONST GpPoint* point1,
                   GDIPCONST GpPoint* point2);

GpStatus WINGDIPAPI
GdipGetLinePoints(GpLineGradient *brush, GpPointF* points);

GpStatus WINGDIPAPI
GdipGetLinePointsI(GpLineGradient *brush, GpPoint* points);

GpStatus WINGDIPAPI
GdipSetLineColors(GpLineGradient *brush, ARGB color1, ARGB color2);

GpStatus WINGDIPAPI
GdipGetLineColors(GpLineGradient *brush, ARGB* colors);

GpStatus WINGDIPAPI
GdipGetLineRect(GpLineGradient *brush, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetLineRectI(GpLineGradient *brush, GpRect *rect);

GpStatus WINGDIPAPI
GdipSetLineGammaCorrection(GpLineGradient *brush, BOOL useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetLineGammaCorrection(GpLineGradient *brush, BOOL *useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetLineBlendCount(GpLineGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetLineBlend(GpLineGradient *brush, REAL *blend, REAL* positions,
                 INT count);

GpStatus WINGDIPAPI
GdipSetLineBlend(GpLineGradient *brush, GDIPCONST REAL *blend,
                 GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipGetLinePresetBlendCount(GpLineGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetLinePresetBlend(GpLineGradient *brush, ARGB *blend,
                                           REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetLinePresetBlend(GpLineGradient *brush, GDIPCONST ARGB *blend,
                       GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetLineSigmaBlend(GpLineGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetLineLinearBlend(GpLineGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetLineWrapMode(GpLineGradient *brush, GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetLineWrapMode(GpLineGradient *brush, GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipGetLineTransform(GpLineGradient *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetLineTransform(GpLineGradient *brush, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetLineTransform(GpLineGradient* brush);

GpStatus WINGDIPAPI
GdipMultiplyLineTransform(GpLineGradient* brush, GpMatrix *matrix,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateLineTransform(GpLineGradient* brush, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleLineTransform(GpLineGradient* brush, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateLineTransform(GpLineGradient* brush, REAL angle, GpMatrixOrder order);

//----------------------------------------------------------------------------
// PathGradient Brush
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePathGradient(GDIPCONST GpPointF* points,
                                    INT count,
                                    GpWrapMode wrapMode,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipCreatePathGradientI(GDIPCONST GpPoint* points,
                                    INT count,
                                    GpWrapMode wrapMode,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipCreatePathGradientFromPath(GDIPCONST GpPath* path,
                                    GpPathGradient **polyGradient);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterColor(
                        GpPathGradient *brush, ARGB* colors);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterColor(
                        GpPathGradient *brush, ARGB colors);

GpStatus WINGDIPAPI
GdipGetPathGradientSurroundColorsWithCount(
                        GpPathGradient *brush, ARGB* color, INT* count);

GpStatus WINGDIPAPI
GdipSetPathGradientSurroundColorsWithCount(
                        GpPathGradient *brush,
                        GDIPCONST ARGB* color, INT* count);

GpStatus WINGDIPAPI
GdipGetPathGradientPath(GpPathGradient *brush, GpPath *path);

GpStatus WINGDIPAPI
GdipSetPathGradientPath(GpPathGradient *brush, GDIPCONST GpPath *path);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterPoint(
                        GpPathGradient *brush, GpPointF* points);

GpStatus WINGDIPAPI
GdipGetPathGradientCenterPointI(
                        GpPathGradient *brush, GpPoint* points);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterPoint(
                        GpPathGradient *brush, GDIPCONST GpPointF* points);

GpStatus WINGDIPAPI
GdipSetPathGradientCenterPointI(
                        GpPathGradient *brush, GDIPCONST GpPoint* points);

GpStatus WINGDIPAPI
GdipGetPathGradientRect(GpPathGradient *brush, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetPathGradientRectI(GpPathGradient *brush, GpRect *rect);

GpStatus WINGDIPAPI
GdipGetPathGradientPointCount(GpPathGradient *brush, INT* count);

GpStatus WINGDIPAPI
GdipGetPathGradientSurroundColorCount(GpPathGradient *brush, INT* count);

GpStatus WINGDIPAPI
GdipSetPathGradientGammaCorrection(GpPathGradient *brush, BOOL useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetPathGradientGammaCorrection(GpPathGradient *brush, BOOL *useGammaCorrection);

GpStatus WINGDIPAPI
GdipGetPathGradientBlendCount(GpPathGradient *brush,
                                             INT *count);

GpStatus WINGDIPAPI
GdipGetPathGradientBlend(GpPathGradient *brush,
                                    REAL *blend, REAL *positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientBlend(GpPathGradient *brush,
                GDIPCONST REAL *blend, GDIPCONST REAL *positions, INT count);

GpStatus WINGDIPAPI
GdipGetPathGradientPresetBlendCount(GpPathGradient *brush, INT *count);

GpStatus WINGDIPAPI
GdipGetPathGradientPresetBlend(GpPathGradient *brush, ARGB *blend,
                                                REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientPresetBlend(GpPathGradient *brush, GDIPCONST ARGB *blend,
                                        GDIPCONST REAL* positions, INT count);

GpStatus WINGDIPAPI
GdipSetPathGradientSigmaBlend(GpPathGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipSetPathGradientLinearBlend(GpPathGradient *brush, REAL focus, REAL scale);

GpStatus WINGDIPAPI
GdipGetPathGradientWrapMode(GpPathGradient *brush,
                                         GpWrapMode *wrapmode);

GpStatus WINGDIPAPI
GdipSetPathGradientWrapMode(GpPathGradient *brush,
                                         GpWrapMode wrapmode);

GpStatus WINGDIPAPI
GdipGetPathGradientTransform(GpPathGradient *brush,
                                          GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipSetPathGradientTransform(GpPathGradient *brush,
                                          GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPathGradientTransform(GpPathGradient* brush);

GpStatus WINGDIPAPI
GdipMultiplyPathGradientTransform(GpPathGradient* brush, GpMatrix *matrix,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslatePathGradientTransform(GpPathGradient* brush, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScalePathGradientTransform(GpPathGradient* brush, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotatePathGradientTransform(GpPathGradient* brush, REAL angle,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipGetPathGradientFocusScales(GpPathGradient *brush, REAL* xScale, REAL* yScale);

GpStatus WINGDIPAPI
GdipSetPathGradientFocusScales(GpPathGradient *brush, REAL xScale, REAL yScale);

//----------------------------------------------------------------------------
// Pen methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreatePen1(ARGB color, REAL width, GpUnit unit, GpPen **pen);

GpStatus WINGDIPAPI
GdipCreatePen2(GpBrush *brush, REAL width, GpUnit unit,
                        GpPen **pen);

GpStatus WINGDIPAPI
GdipClonePen(GpPen *pen, GpPen **clonepen);

GpStatus WINGDIPAPI
GdipDeletePen(GpPen *pen);

GpStatus WINGDIPAPI
GdipSetPenWidth(GpPen *pen, REAL width);

GpStatus WINGDIPAPI
GdipGetPenWidth(GpPen *pen, REAL *width);

GpStatus WINGDIPAPI
GdipSetPenUnit(GpPen *pen, GpUnit unit);

GpStatus WINGDIPAPI
GdipGetPenUnit(GpPen *pen, GpUnit *unit);

GpStatus WINGDIPAPI
GdipSetPenLineCap(GpPen *pen, GpLineCap startCap, GpLineCap endCap,
                  GpLineCap dashCap);

GpStatus WINGDIPAPI
GdipSetPenStartCap(GpPen *pen, GpLineCap startCap);

GpStatus WINGDIPAPI
GdipSetPenEndCap(GpPen *pen, GpLineCap endCap);

GpStatus WINGDIPAPI
GdipSetPenDashCap(GpPen *pen, GpLineCap dashCap);

GpStatus WINGDIPAPI
GdipGetPenStartCap(GpPen *pen, GpLineCap *startCap);

GpStatus WINGDIPAPI
GdipGetPenEndCap(GpPen *pen, GpLineCap *endCap);

GpStatus WINGDIPAPI
GdipGetPenDashCap(GpPen *pen, GpLineCap *dashCap);

GpStatus WINGDIPAPI
GdipSetPenLineJoin(GpPen *pen, GpLineJoin lineJoin);

GpStatus WINGDIPAPI
GdipGetPenLineJoin(GpPen *pen, GpLineJoin *lineJoin);

GpStatus WINGDIPAPI
GdipSetPenCustomStartCap(GpPen *pen, GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipGetPenCustomStartCap(GpPen *pen, GpCustomLineCap** customCap);

GpStatus WINGDIPAPI
GdipSetPenCustomEndCap(GpPen *pen, GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipGetPenCustomEndCap(GpPen *pen, GpCustomLineCap** customCap);

GpStatus WINGDIPAPI
GdipSetPenMiterLimit(GpPen *pen, REAL miterLimit);

GpStatus WINGDIPAPI
GdipGetPenMiterLimit(GpPen *pen, REAL *miterLimit);

GpStatus WINGDIPAPI
GdipSetPenMode(GpPen *pen, GpPenAlignment penMode);

GpStatus WINGDIPAPI
GdipGetPenMode(GpPen *pen, GpPenAlignment *penMode);

GpStatus WINGDIPAPI
GdipSetPenTransform(GpPen *pen, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipGetPenTransform(GpPen *pen, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPenTransform(GpPen *pen);

GpStatus WINGDIPAPI
GdipMultiplyPenTransform(GpPen *pen, GpMatrix *matrix,
                           GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslatePenTransform(GpPen *pen, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScalePenTransform(GpPen *pen, REAL sx, REAL sy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotatePenTransform(GpPen *pen, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipSetPenColor(GpPen *pen, ARGB argb);

GpStatus WINGDIPAPI
GdipGetPenColor(GpPen *pen, ARGB *argb);

GpStatus WINGDIPAPI
GdipSetPenBrushFill(GpPen *pen, GpBrush *brush);

GpStatus WINGDIPAPI
GdipGetPenBrushFill(GpPen *pen, GpBrush **brush);

GpStatus WINGDIPAPI
GdipGetPenFillType(GpPen *pen, GpPenType* type);

GpStatus WINGDIPAPI
GdipGetPenDashStyle(GpPen *pen, GpDashStyle *dashstyle);

GpStatus WINGDIPAPI
GdipSetPenDashStyle(GpPen *pen, GpDashStyle dashstyle);

GpStatus WINGDIPAPI
GdipGetPenDashOffset(GpPen *pen, REAL *offset);

GpStatus WINGDIPAPI
GdipSetPenDashOffset(GpPen *pen, REAL offset);

GpStatus WINGDIPAPI
GdipGetPenDashCount(GpPen *pen, INT *count);

GpStatus WINGDIPAPI
GdipSetPenDashArray(GpPen *pen, GDIPCONST REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenDashArray(GpPen *pen, REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenCompoundCount(GpPen *pen, INT *count);

GpStatus WINGDIPAPI
GdipSetPenCompoundArray(GpPen *pen, GDIPCONST REAL *dash, INT count);

GpStatus WINGDIPAPI
GdipGetPenCompoundArray(GpPen *pen, REAL *dash, INT count);

//----------------------------------------------------------------------------
// CustomLineCap methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateCustomLineCap(GpPath* fillPath, GpPath* strokePath,
   GpLineCap baseCap, REAL baseInset, GpCustomLineCap **customCap);

GpStatus WINGDIPAPI
GdipDeleteCustomLineCap(GpCustomLineCap* customCap);

GpStatus WINGDIPAPI
GdipCloneCustomLineCap(GpCustomLineCap* customCap,
                       GpCustomLineCap** clonedCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapType(GpCustomLineCap* customCap,
                       CustomLineCapType* capType);

GpStatus WINGDIPAPI
GdipSetCustomLineCapStrokeCaps(GpCustomLineCap* customCap,
                               GpLineCap startCap, GpLineCap endCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapStrokeCaps(GpCustomLineCap* customCap,
                               GpLineCap* startCap, GpLineCap* endCap);

GpStatus WINGDIPAPI
GdipSetCustomLineCapStrokeJoin(GpCustomLineCap* customCap, GpLineJoin lineJoin);

GpStatus WINGDIPAPI
GdipGetCustomLineCapStrokeJoin(GpCustomLineCap* customCap, GpLineJoin* lineJoin);

GpStatus WINGDIPAPI
GdipSetCustomLineCapBaseCap(GpCustomLineCap* customCap, GpLineCap baseCap);

GpStatus WINGDIPAPI
GdipGetCustomLineCapBaseCap(GpCustomLineCap* customCap, GpLineCap* baseCap);

GpStatus WINGDIPAPI
GdipSetCustomLineCapBaseInset(GpCustomLineCap* customCap, REAL inset);

GpStatus WINGDIPAPI
GdipGetCustomLineCapBaseInset(GpCustomLineCap* customCap, REAL* inset);

GpStatus WINGDIPAPI
GdipSetCustomLineCapWidthScale(GpCustomLineCap* customCap, REAL widthScale);

GpStatus WINGDIPAPI
GdipGetCustomLineCapWidthScale(GpCustomLineCap* customCap, REAL* widthScale);

//----------------------------------------------------------------------------
// AdjustableArrowCap methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateAdjustableArrowCap(REAL height, REAL width, BOOL isFilled,
                             GpAdjustableArrowCap **cap);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapHeight(GpAdjustableArrowCap* cap, REAL height);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapHeight(GpAdjustableArrowCap* cap, REAL* height);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapWidth(GpAdjustableArrowCap* cap, REAL width);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapWidth(GpAdjustableArrowCap* cap, REAL* width);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapMiddleInset(GpAdjustableArrowCap* cap, REAL middleInset);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapMiddleInset(GpAdjustableArrowCap* cap, REAL* middleInset);

GpStatus WINGDIPAPI
GdipSetAdjustableArrowCapFillState(GpAdjustableArrowCap* cap, BOOL fillState);

GpStatus WINGDIPAPI
GdipGetAdjustableArrowCapFillState(GpAdjustableArrowCap* cap, BOOL* fillState);

//----------------------------------------------------------------------------
// Image methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipLoadImageFromStream(IStream* stream, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromFile(GDIPCONST WCHAR* filename, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromStreamICM(IStream* stream, GpImage **image);

GpStatus WINGDIPAPI
GdipLoadImageFromFileICM(GDIPCONST WCHAR* filename, GpImage **image);

GpStatus WINGDIPAPI
GdipCloneImage(GpImage *image, GpImage **cloneImage);

GpStatus WINGDIPAPI
GdipDisposeImage(GpImage *image);

GpStatus WINGDIPAPI
GdipSaveImageToFile(GpImage *image, GDIPCONST WCHAR* filename,
                    GDIPCONST CLSID* clsidEncoder, GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveImageToStream(GpImage *image, IStream* stream,
                      GDIPCONST CLSID* clsidEncoder, GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveAdd(GpImage *image, GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipSaveAddImage(GpImage *image, GpImage* newImage,
                 GDIPCONST EncoderParameters* encoderParams);

GpStatus WINGDIPAPI
GdipGetImageGraphicsContext(GpImage *image, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipGetImageBounds(GpImage *image, GpRectF *srcRect, GpUnit *srcUnit);

GpStatus WINGDIPAPI
GdipGetImageDimension(GpImage *image, REAL *width, REAL *height);

GpStatus WINGDIPAPI
GdipGetImageType(GpImage *image, ImageType *type);

GpStatus WINGDIPAPI
GdipGetImageWidth(GpImage *image, UINT *width);

GpStatus WINGDIPAPI
GdipGetImageHeight(GpImage *image, UINT *height);

GpStatus WINGDIPAPI
GdipGetImageHorizontalResolution(GpImage *image, REAL *resolution);

GpStatus WINGDIPAPI
GdipGetImageVerticalResolution(GpImage *image, REAL *resolution);

GpStatus WINGDIPAPI
GdipGetImageFlags(GpImage *image, UINT *flags);

GpStatus WINGDIPAPI
GdipGetImageRawFormat(GpImage *image, GUID *format);

GpStatus WINGDIPAPI
GdipGetImagePixelFormat(GpImage *image, PixelFormat *format);

GpStatus WINGDIPAPI
GdipGetImageThumbnail(GpImage *image, UINT thumbWidth, UINT thumbHeight,
                      GpImage **thumbImage,
                      GetThumbnailImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipGetEncoderParameterListSize(GpImage *image, GDIPCONST CLSID* clsidEncoder,
                                UINT* size);

GpStatus WINGDIPAPI
GdipGetEncoderParameterList(GpImage *image, GDIPCONST CLSID* clsidEncoder,
                            UINT size, EncoderParameters* buffer);

GpStatus WINGDIPAPI
GdipImageGetFrameDimensionsCount(GpImage* image, UINT* count);

GpStatus WINGDIPAPI
GdipImageGetFrameDimensionsList(GpImage* image, GUID* dimensionIDs, UINT count);

GpStatus WINGDIPAPI
GdipImageGetFrameCount(GpImage *image, GDIPCONST GUID* dimensionID, UINT* count);

GpStatus WINGDIPAPI
GdipImageSelectActiveFrame(GpImage *image, GDIPCONST GUID* dimensionID,
                           UINT frameIndex);
GpStatus WINGDIPAPI
GdipGetImagePalette(GpImage *image, ColorPalette *palette, INT size);

GpStatus WINGDIPAPI
GdipSetImagePalette(GpImage *image, GDIPCONST ColorPalette *palette);

GpStatus WINGDIPAPI
GdipGetImagePaletteSize(GpImage *image, INT *size);

GpStatus WINGDIPAPI
GdipGetPropertyCount(GpImage *image, UINT* numOfProperty);

GpStatus WINGDIPAPI
GdipGetPropertyIdList(GpImage *image, UINT numOfProperty, PROPID* list);

GpStatus WINGDIPAPI
GdipGetPropertyItemSize(GpImage *image, PROPID propId, UINT* size);

GpStatus WINGDIPAPI
GdipGetPropertyItem(GpImage *image, PROPID propId,UINT propSize,
                    PropertyItem* buffer);

GpStatus WINGDIPAPI
GdipGetPropertySize(GpImage *image, UINT* totalBufferSize, UINT* numProperties);

GpStatus WINGDIPAPI
GdipGetAllPropertyItems(GpImage *image, UINT totalBufferSize,
                        UINT numProperties, PropertyItem* allItems);

GpStatus WINGDIPAPI
GdipRemovePropertyItem(GpImage *image, PROPID propId);

GpStatus WINGDIPAPI
GdipSetPropertyItem(GpImage *image, GDIPCONST PropertyItem* item);

GpStatus WINGDIPAPI
GdipImageForceValidation(GpImage *image);

GpStatus WINGDIPAPI
GdipGetImageLayout(GpImage *image, ImageLayout* layout);

GpStatus WINGDIPAPI
GdipSetImageLayout(GpImage *image, GDIPCONST ImageLayout layout);

//----------------------------------------------------------------------------
// Bitmap methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateBitmapFromStream(IStream* stream, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromFile(GDIPCONST WCHAR* filename, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromStreamICM(IStream* stream, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromFileICM(GDIPCONST WCHAR* filename, GpBitmap **bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromScan0(INT width,
                          INT height,
                          INT stride,
                          PixelFormat format,
                          BYTE* scan0,
                          GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromGraphics(INT width,
                             INT height,
                             GpGraphics* target,
                             GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromDirectDrawSurface(IDirectDrawSurface7* surface,
                                      GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromGdiDib(GDIPCONST BITMAPINFO* gdiBitmapInfo,
                           VOID* gdiBitmapData,
                           GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateBitmapFromHBITMAP(HBITMAP hbm,
                            HPALETTE hpal,
                            GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateHBITMAPFromBitmap(GpBitmap* bitmap,
                            HBITMAP* hbmReturn,
                            ARGB background);

GpStatus WINGDIPAPI
GdipCreateBitmapFromHICON(HICON hicon,
                          GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCreateHICONFromBitmap(GpBitmap* bitmap,
                          HICON* hbmReturn);

GpStatus WINGDIPAPI
GdipCreateBitmapFromResource(HINSTANCE hInstance,
                             GDIPCONST WCHAR* lpBitmapName,
                             GpBitmap** bitmap);

GpStatus WINGDIPAPI
GdipCloneBitmapArea(REAL x, REAL y, REAL width, REAL height,
                            PixelFormat format,
                            GpBitmap *srcBitmap,
                            GpBitmap **dstBitmap);

GpStatus WINGDIPAPI
GdipCloneBitmapAreaI(INT x,
                     INT y,
                     INT width,
                     INT height,
                     PixelFormat format,
                     GpBitmap *srcBitmap,
                     GpBitmap **dstBitmap);

GpStatus WINGDIPAPI
GdipBitmapLockBits(GpBitmap* bitmap,
                   GDIPCONST GpRect* rect,
                   UINT flags,
                   PixelFormat format,
                   BitmapData* lockedBitmapData);

GpStatus WINGDIPAPI
GdipBitmapUnlockBits(GpBitmap* bitmap,
                     BitmapData* lockedBitmapData);

GpStatus WINGDIPAPI
GdipBitmapGetPixel(GpBitmap* bitmap, INT x, INT y, ARGB *color);

GpStatus WINGDIPAPI
GdipBitmapSetPixel(GpBitmap* bitmap, INT x, INT y, ARGB color);

GpStatus WINGDIPAPI
GdipBitmapSetResolution(GpBitmap* bitmap, REAL xdpi, REAL ydpi);

//----------------------------------------------------------------------------
// ImageAttributes methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateImageAttributes(GpImageAttributes **imageattr);

GpStatus WINGDIPAPI
GdipCloneImageAttributes(GpImageAttributes *imageattr,
                         GpImageAttributes **cloneImageattr);

GpStatus WINGDIPAPI
GdipDisposeImageAttributes(GpImageAttributes *imageattr);

GpStatus WINGDIPAPI
GdipSetImageAttributesToIdentity(GpImageAttributes *imageattr,
                                 ColorAdjustType type);
GpStatus WINGDIPAPI
GdipResetImageAttributes(GpImageAttributes *imageattr,
                         ColorAdjustType type);

GpStatus WINGDIPAPI
GdipSetImageAttributesColorMatrix(GpImageAttributes *imageattr,
                               ColorAdjustType type,
                               BOOL enableFlag,
                               GDIPCONST ColorMatrix* colorMatrix,
                               GDIPCONST ColorMatrix* grayMatrix,
                               ColorMatrixFlags flags);

GpStatus WINGDIPAPI
GdipSetImageAttributesThreshold(GpImageAttributes *imageattr,
                                ColorAdjustType type,
                                BOOL enableFlag,
                                REAL threshold);

GpStatus WINGDIPAPI
GdipSetImageAttributesGamma(GpImageAttributes *imageattr,
                            ColorAdjustType type,
                            BOOL enableFlag,
                            REAL gamma);

GpStatus WINGDIPAPI
GdipSetImageAttributesNoOp(GpImageAttributes *imageattr,
                           ColorAdjustType type,
                           BOOL enableFlag);

GpStatus WINGDIPAPI
GdipSetImageAttributesColorKeys(GpImageAttributes *imageattr,
                                ColorAdjustType type,
                                BOOL enableFlag,
                                ARGB colorLow,
                                ARGB colorHigh);

GpStatus WINGDIPAPI
GdipSetImageAttributesOutputChannel(GpImageAttributes *imageattr,
                                    ColorAdjustType type,
                                    BOOL enableFlag,
                                    ColorChannelFlags channelFlags);

GpStatus WINGDIPAPI
GdipSetImageAttributesOutputChannelColorProfile(GpImageAttributes *imageattr,
                                                ColorAdjustType type,
                                                BOOL enableFlag,
                                                GDIPCONST WCHAR *colorProfileFilename);

GpStatus WINGDIPAPI
GdipSetImageAttributesRemapTable(GpImageAttributes *imageattr,
                                 ColorAdjustType type,
                                 BOOL enableFlag,
                                 UINT mapSize,
                                 GDIPCONST ColorMap *map);
GpStatus WINGDIPAPI
GdipSetImageAttributesWrapMode(
    GpImageAttributes *imageAttr,
    WrapMode wrap,
    ARGB argb,
    BOOL clamp
);

GpStatus WINGDIPAPI
GdipSetImageAttributesICMMode(
    GpImageAttributes *imageAttr,
    BOOL on
);

GpStatus WINGDIPAPI
GdipGetImageAttributesAdjustedPalette(
    GpImageAttributes *imageAttr,
    ColorPalette * colorPalette,
    ColorAdjustType colorAdjustType
);

//----------------------------------------------------------------------------
// Graphics methods
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipFlush(GpGraphics *graphics, GpFlushIntention intention);

GpStatus WINGDIPAPI
GdipCreateFromHDC(HDC hdc, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHDC2(HDC hdc, HANDLE hDevice, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHWND(HWND hwnd, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipCreateFromHWNDICM(HWND hwnd, GpGraphics **graphics);

GpStatus WINGDIPAPI
GdipDeleteGraphics(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipGetDC(GpGraphics* graphics, HDC * hdc);

GpStatus WINGDIPAPI
GdipReleaseDC(GpGraphics* graphics, HDC hdc);

GpStatus WINGDIPAPI
GdipSetCompositingMode(GpGraphics *graphics, CompositingMode compositingMode);

GpStatus WINGDIPAPI
GdipGetCompositingMode(GpGraphics *graphics, CompositingMode *compositingMode);

GpStatus WINGDIPAPI
GdipSetRenderingOrigin(GpGraphics *graphics, INT x, INT y);

GpStatus WINGDIPAPI
GdipGetRenderingOrigin(GpGraphics *graphics, INT *x, INT *y);

GpStatus WINGDIPAPI
GdipSetCompositingQuality(GpGraphics *graphics, CompositingQuality compositingQuality);

GpStatus WINGDIPAPI
GdipGetCompositingQuality(GpGraphics *graphics, CompositingQuality *compositingQuality);

GpStatus WINGDIPAPI
GdipSetSmoothingMode(GpGraphics *graphics, SmoothingMode smoothingMode);

GpStatus WINGDIPAPI
GdipGetSmoothingMode(GpGraphics *graphics, SmoothingMode *smoothingMode);

GpStatus WINGDIPAPI
GdipSetPixelOffsetMode(GpGraphics* graphics, PixelOffsetMode pixelOffsetMode);

GpStatus WINGDIPAPI
GdipGetPixelOffsetMode(GpGraphics *graphics, PixelOffsetMode *pixelOffsetMode);

GpStatus WINGDIPAPI
GdipSetTextRenderingHint(GpGraphics *graphics, TextRenderingHint mode);

GpStatus WINGDIPAPI
GdipGetTextRenderingHint(GpGraphics *graphics, TextRenderingHint *mode);

GpStatus  WINGDIPAPI
GdipSetTextGammaValue(GpGraphics *graphics, UINT gammaValue);

GpStatus  WINGDIPAPI
GdipGetTextGammaValue(GpGraphics *graphics, UINT * gammaValue);

GpStatus WINGDIPAPI
GdipSetInterpolationMode(GpGraphics *graphics, InterpolationMode interpolationMode);

GpStatus WINGDIPAPI
GdipGetInterpolationMode(GpGraphics *graphics, InterpolationMode *interpolationMode);

GpStatus WINGDIPAPI
GdipSetWorldTransform(GpGraphics *graphics, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetWorldTransform(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipMultiplyWorldTransform(GpGraphics *graphics, GpMatrix *matrix,
                           GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipTranslateWorldTransform(GpGraphics *graphics, REAL dx, REAL dy,
                            GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipScaleWorldTransform(GpGraphics *graphics, REAL sx, REAL sy,
                        GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipRotateWorldTransform(GpGraphics *graphics, REAL angle, GpMatrixOrder order);

GpStatus WINGDIPAPI
GdipGetWorldTransform(GpGraphics *graphics, GpMatrix *matrix);

GpStatus WINGDIPAPI
GdipResetPageTransform(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipGetPageUnit(GpGraphics *graphics, GpUnit *unit);

GpStatus WINGDIPAPI
GdipGetPageScale(GpGraphics *graphics, REAL *scale);

GpStatus WINGDIPAPI
GdipSetPageUnit(GpGraphics *graphics, GpUnit unit);

GpStatus WINGDIPAPI
GdipSetPageScale(GpGraphics *graphics, REAL scale);

GpStatus WINGDIPAPI
GdipGetDpiX(GpGraphics *graphics, REAL* dpi);

GpStatus WINGDIPAPI
GdipGetDpiY(GpGraphics *graphics, REAL* dpi);

GpStatus WINGDIPAPI
GdipTransformPoints(GpGraphics *graphics, GpCoordinateSpace destSpace,
                             GpCoordinateSpace srcSpace, GpPointF *points,
                             INT count);

GpStatus WINGDIPAPI
GdipTransformPointsI(GpGraphics *graphics, GpCoordinateSpace destSpace,
                             GpCoordinateSpace srcSpace, GpPoint *points,
                             INT count);

GpStatus WINGDIPAPI
GdipGetNearestColor(GpGraphics *graphics, ARGB* argb);

// Create the Win9x Halftone Palette (even on NT) with correct Desktop colors
HPALETTE WINGDIPAPI
GdipCreateHalftonePalette();

GpStatus WINGDIPAPI
GdipDrawLine(GpGraphics *graphics, GpPen *pen, REAL x1, REAL y1,
                      REAL x2, REAL y2);

GpStatus WINGDIPAPI
GdipDrawLineI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1,
                      INT x2, INT y2);

GpStatus WINGDIPAPI
GdipDrawLines(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawLinesI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawArc(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
            REAL width, REAL height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawArcI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                     INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawBezier(GpGraphics *graphics, GpPen *pen, REAL x1, REAL y1,
                        REAL x2, REAL y2, REAL x3, REAL y3, REAL x4, REAL y4);

GpStatus WINGDIPAPI
GdipDrawBezierI(GpGraphics *graphics, GpPen *pen, INT x1, INT y1,
                        INT x2, INT y2, INT x3, INT y3, INT x4, INT y4);

GpStatus WINGDIPAPI
GdipDrawBeziers(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawBeziersI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawRectangle(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                      REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawRectangleI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                      INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawRectangles(GpGraphics *graphics, GpPen *pen, GDIPCONST GpRectF *rects,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawRectanglesI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpRect *rects,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawEllipse(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                         REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawEllipseI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                         INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawPie(GpGraphics *graphics, GpPen *pen, REAL x, REAL y,
                     REAL width, REAL height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawPieI(GpGraphics *graphics, GpPen *pen, INT x, INT y,
                     INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipDrawPolygon(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawPolygonI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                         INT count);

GpStatus WINGDIPAPI
GdipDrawPath(GpGraphics *graphics, GpPen *pen, GpPath *path);

GpStatus WINGDIPAPI
GdipDrawCurve(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawCurveI(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count);

GpStatus WINGDIPAPI
GdipDrawCurve2(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
                       INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve2I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                       INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve3(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPointF *points,
               INT count, INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipDrawCurve3I(GpGraphics *graphics, GpPen *pen, GDIPCONST GpPoint *points,
                INT count, INT offset, INT numberOfSegments, REAL tension);

GpStatus WINGDIPAPI
GdipDrawClosedCurve(GpGraphics *graphics, GpPen *pen,
                    GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipDrawClosedCurveI(GpGraphics *graphics, GpPen *pen,
                     GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipDrawClosedCurve2(GpGraphics *graphics, GpPen *pen,
                     GDIPCONST GpPointF *points, INT count, REAL tension);

GpStatus WINGDIPAPI
GdipDrawClosedCurve2I(GpGraphics *graphics, GpPen *pen,
                      GDIPCONST GpPoint *points, INT count, REAL tension);

GpStatus WINGDIPAPI
GdipGraphicsClear(GpGraphics *graphics, ARGB color);

GpStatus WINGDIPAPI
GdipFillRectangle(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
                  REAL width, REAL height);

GpStatus WINGDIPAPI
GdipFillRectangleI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
                   INT width, INT height);

GpStatus WINGDIPAPI
GdipFillRectangles(GpGraphics *graphics, GpBrush *brush,
                   GDIPCONST GpRectF *rects, INT count);

GpStatus WINGDIPAPI
GdipFillRectanglesI(GpGraphics *graphics, GpBrush *brush,
                    GDIPCONST GpRect *rects, INT count);

GpStatus WINGDIPAPI
GdipFillPolygon(GpGraphics *graphics, GpBrush *brush,
                GDIPCONST GpPointF *points, INT count, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillPolygonI(GpGraphics *graphics, GpBrush *brush,
                 GDIPCONST GpPoint *points, INT count, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillPolygon2(GpGraphics *graphics, GpBrush *brush,
                 GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipFillPolygon2I(GpGraphics *graphics, GpBrush *brush,
                  GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFillEllipse(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
                REAL width, REAL height);

GpStatus WINGDIPAPI
GdipFillEllipseI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
                 INT width, INT height);

GpStatus WINGDIPAPI
GdipFillPie(GpGraphics *graphics, GpBrush *brush, REAL x, REAL y,
            REAL width, REAL height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipFillPieI(GpGraphics *graphics, GpBrush *brush, INT x, INT y,
             INT width, INT height, REAL startAngle, REAL sweepAngle);

GpStatus WINGDIPAPI
GdipFillPath(GpGraphics *graphics, GpBrush *brush, GpPath *path);

GpStatus WINGDIPAPI
GdipFillClosedCurve(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPointF *points, INT count);

GpStatus WINGDIPAPI
GdipFillClosedCurveI(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPoint *points, INT count);

GpStatus WINGDIPAPI
GdipFillClosedCurve2(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPointF *points, INT count,
                              REAL tension, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillClosedCurve2I(GpGraphics *graphics, GpBrush *brush,
                              GDIPCONST GpPoint *points, INT count,
                              REAL tension, GpFillMode fillMode);

GpStatus WINGDIPAPI
GdipFillRegion(GpGraphics *graphics, GpBrush *brush,
                        GpRegion *region);

GpStatus WINGDIPAPI
GdipDrawImage(GpGraphics *graphics, GpImage *image, REAL x, REAL y);

GpStatus WINGDIPAPI
GdipDrawImageI(GpGraphics *graphics, GpImage *image, INT x, INT y);

GpStatus WINGDIPAPI
GdipDrawImageRect(GpGraphics *graphics, GpImage *image, REAL x, REAL y,
                           REAL width, REAL height);

GpStatus WINGDIPAPI
GdipDrawImageRectI(GpGraphics *graphics, GpImage *image, INT x, INT y,
                           INT width, INT height);

GpStatus WINGDIPAPI
GdipDrawImagePoints(GpGraphics *graphics, GpImage *image,
                             GDIPCONST GpPointF *dstpoints, INT count);

GpStatus WINGDIPAPI
GdipDrawImagePointsI(GpGraphics *graphics, GpImage *image,
                             GDIPCONST GpPoint *dstpoints, INT count);

GpStatus WINGDIPAPI
GdipDrawImagePointRect(GpGraphics *graphics, GpImage *image, REAL x,
                                REAL y, REAL srcx, REAL srcy, REAL srcwidth,
                                REAL srcheight, GpUnit srcUnit);

GpStatus WINGDIPAPI
GdipDrawImagePointRectI(GpGraphics *graphics, GpImage *image, INT x,
                                INT y, INT srcx, INT srcy, INT srcwidth,
                                INT srcheight, GpUnit srcUnit);

GpStatus WINGDIPAPI
GdipDrawImageRectRect(GpGraphics *graphics, GpImage *image, REAL dstx,
                      REAL dsty, REAL dstwidth, REAL dstheight,
                      REAL srcx, REAL srcy, REAL srcwidth, REAL srcheight,
                      GpUnit srcUnit,
                      GpImageAttributes* imageAttributes,
                      DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImageRectRectI(GpGraphics *graphics, GpImage *image, INT dstx,
                       INT dsty, INT dstwidth, INT dstheight,
                       INT srcx, INT srcy, INT srcwidth, INT srcheight,
                       GpUnit srcUnit,
                       GpImageAttributes* imageAttributes,
                       DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImagePointsRect(GpGraphics *graphics, GpImage *image,
                        GDIPCONST GpPointF *points, INT count, REAL srcx,
                        REAL srcy, REAL srcwidth, REAL srcheight,
                        GpUnit srcUnit,
                        GpImageAttributes* imageAttributes,
                        DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipDrawImagePointsRectI(GpGraphics *graphics, GpImage *image,
                         GDIPCONST GpPoint *points, INT count, INT srcx,
                         INT srcy, INT srcwidth, INT srcheight,
                         GpUnit srcUnit,
                         GpImageAttributes* imageAttributes,
                         DrawImageAbort callback, VOID * callbackData);

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point *       destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoint(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF &      destPoint,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point &       destPoint,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRect(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST RectF &       destRect,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestRectI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Rect &        destRect,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPoints(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST PointF *      destPoints,
    INT                     count,
    GDIPCONST RectF &       srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipEnumerateMetafileSrcRectDestPointsI(
    GpGraphics *            graphics,
    GDIPCONST GpMetafile *  metafile,
    GDIPCONST Point *       destPoints,
    INT                     count,
    GDIPCONST Rect &        srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    GpImageAttributes *     imageAttributes
    );

GpStatus WINGDIPAPI
GdipPlayMetafileRecord(
    GDIPCONST GpMetafile *  metafile,
    EmfPlusRecordType       recordType,
    UINT                    flags,
    UINT                    dataSize,
    GDIPCONST BYTE *        data
    );

GpStatus WINGDIPAPI
GdipSetClipGraphics(GpGraphics *graphics, GpGraphics *srcgraphics,
                    CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRect(GpGraphics *graphics, REAL x, REAL y,
                         REAL width, REAL height, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRectI(GpGraphics *graphics, INT x, INT y,
                         INT width, INT height, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipPath(GpGraphics *graphics, GpPath *path, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipRegion(GpGraphics *graphics, GpRegion *region,
                  CombineMode combineMode);

GpStatus WINGDIPAPI
GdipSetClipHrgn(GpGraphics *graphics, HRGN hRgn, CombineMode combineMode);

GpStatus WINGDIPAPI
GdipResetClip(GpGraphics *graphics);

GpStatus WINGDIPAPI
GdipTranslateClip(GpGraphics *graphics, REAL dx, REAL dy);

GpStatus WINGDIPAPI
GdipTranslateClipI(GpGraphics *graphics, INT dx, INT dy);

GpStatus WINGDIPAPI
GdipGetClip(GpGraphics *graphics, GpRegion *region);

GpStatus WINGDIPAPI
GdipGetClipBounds(GpGraphics *graphics, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetClipBoundsI(GpGraphics *graphics, GpRect *rect);

GpStatus WINGDIPAPI
GdipIsClipEmpty(GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipGetVisibleClipBounds(GpGraphics *graphics, GpRectF *rect);

GpStatus WINGDIPAPI
GdipGetVisibleClipBoundsI(GpGraphics *graphics, GpRect *rect);

GpStatus WINGDIPAPI
GdipIsVisibleClipEmpty(GpGraphics *graphics, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePoint(GpGraphics *graphics, REAL x, REAL y,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisiblePointI(GpGraphics *graphics, INT x, INT y,
                           BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRect(GpGraphics *graphics, REAL x, REAL y,
                           REAL width, REAL height, BOOL *result);

GpStatus WINGDIPAPI
GdipIsVisibleRectI(GpGraphics *graphics, INT x, INT y,
                           INT width, INT height, BOOL *result);

GpStatus WINGDIPAPI
GdipSaveGraphics(GpGraphics *graphics, GraphicsState *state);

GpStatus WINGDIPAPI
GdipRestoreGraphics(GpGraphics *graphics, GraphicsState state);

GpStatus WINGDIPAPI
GdipBeginContainer(GpGraphics *graphics, GDIPCONST GpRectF* dstrect,
                   GDIPCONST GpRectF *srcrect, GpUnit unit, GraphicsContainer *state);

GpStatus WINGDIPAPI
GdipBeginContainerI(GpGraphics *graphics, GDIPCONST GpRect* dstrect,
                    GDIPCONST GpRect *srcrect, GpUnit unit, GraphicsContainer *state);

GpStatus WINGDIPAPI
GdipBeginContainer2(GpGraphics *graphics, GraphicsContainer* state);

GpStatus WINGDIPAPI
GdipEndContainer(GpGraphics *graphics, GraphicsContainer state);

GpStatus
GdipGetMetafileHeaderFromWmf(
    HMETAFILE           hWmf,
    APMFileHeader *     apmFileHeader,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromEmf(
    HENHMETAFILE        hEmf,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromFile(
    GDIPCONST WCHAR*        filename,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromStream(
    IStream *           stream,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetMetafileHeaderFromMetafile(
    GpMetafile *        metafile,
    MetafileHeader *    header
    );

GpStatus
WINGDIPAPI
GdipGetHemfFromMetafile(
    GpMetafile *        metafile,
    HENHMETAFILE *      hEmf
    );

GpStatus WINGDIPAPI
GdipCreateStreamOnFile(GDIPCONST WCHAR * filename, UINT access, IStream **stream);

GpStatus WINGDIPAPI
GdipCreateMetafileFromWmf(HMETAFILE hWmf, BOOL deleteWmf,
                          APMFileHeader * apmFileHeader, GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromEmf(HENHMETAFILE hEmf, BOOL deleteEmf,
                          GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromFile(GDIPCONST WCHAR* file, GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipCreateMetafileFromStream(IStream * stream, GpMetafile **metafile);

GpStatus WINGDIPAPI
GdipRecordMetafile(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileI(
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileFileName(
    GDIPCONST WCHAR*    fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileFileNameI(
    GDIPCONST WCHAR*    fileName,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileStream(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRectF * frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipRecordMetafileStreamI(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    GDIPCONST GpRect *  frameRect,
    MetafileFrameUnit   frameUnit,
    GDIPCONST WCHAR *   description,
    GpMetafile **       metafile
    );

GpStatus WINGDIPAPI
GdipGetImageDecodersSize(UINT *numDecoders, UINT *size);

GpStatus WINGDIPAPI
GdipGetImageDecoders(UINT numDecoders,
                     UINT size,
                     ImageCodecInfo *decoders);

GpStatus WINGDIPAPI
GdipGetImageEncodersSize(UINT *numEncoders, UINT *size);

GpStatus WINGDIPAPI
GdipGetImageEncoders(UINT numEncoders,
                     UINT size,
                     ImageCodecInfo *encoders);

GpStatus WINGDIPAPI
GdipAddImageCodec(GDIPCONST ImageCodecInfo *codec);

GpStatus WINGDIPAPI
GdipRemoveImageCodec(GDIPCONST ImageCodecInfo *codec);

GpStatus WINGDIPAPI
GdipGetGraphicsPixel(GpGraphics* graphics, REAL x, REAL y, ARGB* argb);

GpStatus WINGDIPAPI
GdipComment(GpGraphics* graphics, UINT sizeData, GDIPCONST BYTE * data);

GpStatus WINGDIPAPI
GdipGetGraphicsLayout(GpGraphics* graphics, GraphicsLayout* layout);

GpStatus WINGDIPAPI
GdipSetGraphicsLayout(GpGraphics* graphics, GDIPCONST GraphicsLayout layout);

//----------------------------------------------------------------------------
// FontFamily
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateFontFamilyFromName(GDIPCONST WCHAR *name,
                             GpFontCollection *fontCollection,
                             GpFontFamily **FontFamily);

GpStatus WINGDIPAPI
GdipDeleteFontFamily(GpFontFamily *FontFamily);

GpStatus WINGDIPAPI
GdipCloneFontFamily(GpFontFamily *FontFamily, GpFontFamily **clonedFontFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilySansSerif(GpFontFamily **nativeFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilySerif(GpFontFamily **nativeFamily);

GpStatus WINGDIPAPI
GdipGetGenericFontFamilyMonospace(GpFontFamily **nativeFamily);


GpStatus WINGDIPAPI
GdipGetFamilyName(
    GDIPCONST GpFontFamily  *family,
    WCHAR                name[LF_FACESIZE],
    LANGID               language
);

GpStatus   WINGDIPAPI
GdipIsStyleAvailable(GDIPCONST GpFontFamily *family, INT style, BOOL * IsStyleAvailable);

GpStatus WINGDIPAPI
GdipFontCollectionEnumerable(
    GpFontCollection* fontCollection,
    GpGraphics* graphics,
    INT *       numFound
);

GpStatus WINGDIPAPI GdipFontCollectionEnumerate(
    GpFontCollection* fontCollection,
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound,
    GpGraphics*     graphics
);

//-----------------------------------
// New API
//-----------------------------------

GpStatus WINGDIPAPI
GdipGetEmHeight(GDIPCONST GpFontFamily *family, INT style, UINT16 * EmHeight);

GpStatus WINGDIPAPI
GdipGetCellAscent(GDIPCONST GpFontFamily *family, INT style, UINT16 * CellAscent);

GpStatus WINGDIPAPI
GdipGetCellDescent(GDIPCONST GpFontFamily *family, INT style, UINT16 * CellDescent);

GpStatus WINGDIPAPI
GdipGetLineSpacing(GDIPCONST GpFontFamily *family, INT style, UINT16 * LineSpacing);


//----------------------------------------------------------------------------
// Font
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateFontFromDC(
    HDC        hdc,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFontFromLogfontA(
    HDC        hdc,
    GDIPCONST LOGFONTA  *logfont,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFontFromLogfontW(
    HDC        hdc,
    GDIPCONST LOGFONTW  *logfont,
    GpFont   **font
);

GpStatus WINGDIPAPI
GdipCreateFont(
    GDIPCONST GpFontFamily  *fontFamily,
    REAL                 emSize,
    INT                  style,
    Unit                 unit,
    GpFont             **font
);

GpStatus WINGDIPAPI
GdipCloneFont(GpFont* font, GpFont** cloneFont);

GpStatus WINGDIPAPI
GdipDeleteFont(GpFont* font);

GpStatus WINGDIPAPI
GdipGetFamily(GpFont *font, GpFontFamily **family);

GpStatus WINGDIPAPI
GdipGetFontStyle(GpFont *font, INT *style);

GpStatus WINGDIPAPI
GdipGetFontSize(GpFont *font, REAL *size);

GpStatus WINGDIPAPI
GdipGetFontUnit(GpFont *font, Unit *unit);

GpStatus WINGDIPAPI
GdipGetFontHeight(GDIPCONST GpFont *font, GDIPCONST GpGraphics *graphics, REAL *height);

GpStatus WINGDIPAPI
GdipGetLogFontA(GpFont * font, GpGraphics *graphics, LOGFONTA * logfontA);

GpStatus WINGDIPAPI
GdipGetLogFontW(GpFont * font, GpGraphics *graphics, LOGFONTW * logfontW);

// FontCollection

GpStatus WINGDIPAPI
GdipNewInstalledFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipNewPrivateFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipDeletePrivateFontCollection(GpFontCollection** fontCollection);

GpStatus WINGDIPAPI
GdipGetFontCollectionFamilyCount(
    GpFontCollection* fontCollection,
    INT *       numFound
);

GpStatus WINGDIPAPI
GdipGetFontCollectionFamilyList(
    GpFontCollection* fontCollection,
    INT             numSought,
    GpFontFamily*   gpfamilies[],
    INT*            numFound
);

GpStatus WINGDIPAPI
GdipInstallFontFile(
    GpFontCollection* fontCollection,
    GDIPCONST WCHAR* filename
);

GpStatus WINGDIPAPI
GdipUninstallFontFile(
    GpFontCollection* fontCollection,
    GDIPCONST WCHAR* filename
);

GpStatus WINGDIPAPI
GdipPrivateAddFontFile(
    GpFontCollection* fontCollection,
    GDIPCONST WCHAR* filename
);

GpStatus WINGDIPAPI
GdipPrivateAddMemoryFont(
    GpFontCollection* fontCollection,
    GDIPCONST void* memory,
    INT length
);

//----------------------------------------------------------------------------
// Text
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipDrawString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    GDIPCONST GpBrush        *brush
);

GpStatus WINGDIPAPI
GdipMeasureString(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          *layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    RectF                    *boundingBox,
    INT                      *codepointsFitted,
    INT                      *linesFilled
);

GpStatus WINGDIPAPI
GdipMeasureStringRegion(
    GpGraphics               *graphics,
    GDIPCONST WCHAR          *string,
    INT                       length,
    GDIPCONST GpFont         *font,
    GDIPCONST RectF          &layoutRect,
    GDIPCONST GpStringFormat *stringFormat,
    INT                       firstCharacterIndex,
    INT                       characterCount,
    GpRegion                 *region
);

GpStatus WINGDIPAPI
GdipDrawDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST GpBrush *brush,
    GDIPCONST PointF *positions,
    INT flags,
    GpMatrix *matrix
);

GpStatus WINGDIPAPI
GdipMeasureDriverString(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST PointF *positions,
    INT flags,
    GpMatrix *matrix,
    RectF *boundingBox
);

GpStatus WINGDIPAPI
GdipDriverStringPointToCodepoint(
    GpGraphics *graphics,
    GDIPCONST UINT16 *text,
    INT length,
    GDIPCONST GpFont *font,
    GDIPCONST PointF *positions,
    INT flags,
    GpMatrix *matrix,
    GDIPCONST PointF *hit,
    INT *index,
    BOOL *rightEdge,
    REAL *distance
);

//----------------------------------------------------------------------------
// String format APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateStringFormat(
    INT               formatAttributes,
    LANGID            language,
    GpStringFormat  **format
);

GpStatus WINGDIPAPI
GdipStringFormatGetGenericDefault(GpStringFormat **format);

GpStatus WINGDIPAPI
GdipStringFormatGetGenericTypographic(GpStringFormat **format);

GpStatus WINGDIPAPI
GdipDeleteStringFormat(GpStringFormat *format);

GpStatus WINGDIPAPI
GdipCloneStringFormat(GDIPCONST GpStringFormat *format, GpStringFormat **newFormat);

GpStatus WINGDIPAPI
GdipSetStringFormatFlags(GpStringFormat *format, INT flags);

GpStatus WINGDIPAPI GdipGetStringFormatFlags(GDIPCONST GpStringFormat *format, INT *flags);

GpStatus WINGDIPAPI
GdipSetStringFormatLineSpacing(GpStringFormat *format, REAL amount,
                               LineSpacing method);

GpStatus WINGDIPAPI
GdipGetStringFormatLineSpacingAmount(GDIPCONST GpStringFormat *format, REAL *amount);
GpStatus WINGDIPAPI
GdipGetStringFormatLineSpacingMethod(GDIPCONST GpStringFormat *format, LineSpacing *method);

GpStatus WINGDIPAPI
GdipSetStringFormatAlign(GpStringFormat *format, StringAlignment align);

GpStatus WINGDIPAPI
GdipGetStringFormatAlign(GDIPCONST GpStringFormat *format, StringAlignment *align);

GpStatus WINGDIPAPI
GdipSetStringFormatLineAlign(GpStringFormat *format,
                             StringAlignment align);

GpStatus WINGDIPAPI
GdipGetStringFormatLineAlign(GDIPCONST GpStringFormat *format,
                             StringAlignment *align);

GpStatus WINGDIPAPI
GdipSetStringFormatTrimming(
    GpStringFormat  *format,
    StringTrimming   trimming
);

GpStatus WINGDIPAPI
GdipGetStringFormatTrimming(
    GDIPCONST GpStringFormat *format,
    StringTrimming       *trimming
);

GpStatus WINGDIPAPI
GdipSetStringFormatHotkeyPrefix(GpStringFormat *format, INT hotkeyPrefix);

GpStatus WINGDIPAPI
GdipGetStringFormatHotkeyPrefix(GDIPCONST GpStringFormat *format, INT *hotkeyPrefix);

GpStatus WINGDIPAPI
GdipSetStringFormatTabStops(GpStringFormat *format, REAL firstTabOffset, INT count, REAL *tabStops);

GpStatus WINGDIPAPI
GdipGetStringFormatTabStops(GDIPCONST GpStringFormat *format, INT count, REAL *firstTabOffset, REAL *tabStops);

GpStatus WINGDIPAPI
GdipGetStringFormatTabStopCount(GDIPCONST GpStringFormat *format, INT * count);

#ifdef DCR_USE_NEW_146933
GpStatus WINGDIPAPI
GdipSetStringFormatDigitSubstitution(GpStringFormat *format, LANGID language, 
                                     StringDigitSubstitute substitute);

GpStatus WINGDIPAPI
GdipGetStringFormatDigitSubstitution(GDIPCONST GpStringFormat *format, LANGID *language, 
                                     StringDigitSubstitute *substitute);
#endif // DCR_USE_NEW_146933

//----------------------------------------------------------------------------
// Cached Bitmap APIs
//----------------------------------------------------------------------------

GpStatus WINGDIPAPI
GdipCreateCachedBitmap(
    GpBitmap *bitmap,
    GpGraphics *graphics,
    GpCachedBitmap **cachedBitmap
);

GpStatus WINGDIPAPI
GdipDeleteCachedBitmap(GpCachedBitmap *cachedBitmap);

GpStatus WINGDIPAPI
GdipDrawCachedBitmap(
    GpGraphics *graphics,
    GpCachedBitmap *cachedBitmap,
    INT x,
    INT y
);

#ifdef __cplusplus
}
#endif

#endif // !_FLATAPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusgpstubs.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusGpStubs.hpp
*
* Abstract:
*
*   GDI+ Native C++ public header file
*
* Revision History:
*
*   03/03/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSGPSTUBS_H
#define _GDIPLUSGPSTUBS_H

//---------------------------------------------------------------------------
// GDI+ classes for forward reference
//---------------------------------------------------------------------------

class Graphics;
class Pen;
class Brush;
class Matrix;
class Bitmap;
class Metafile;
class GraphicsPath;
class PathIterator;
class Region;
class Image;
class TextureBrush;
class HatchBrush;
class SolidBrush;
class LinearGradientBrush;
class PathGradientBrush;
class Font;
class FontFamily;
class FontCollection;
class InstalledFontCollection;
class PrivateFontCollection;
class ImageAttributes;
class CachedBitmap;

//---------------------------------------------------------------------------
// Internal GDI+ classes for internal type checking
//---------------------------------------------------------------------------
class GpGraphics {};

class GpBrush {};
class GpTexture : public GpBrush {};
class GpSolidFill : public GpBrush {};
class GpLineGradient : public GpBrush {};
class GpPathGradient : public GpBrush {};
class GpHatch : public GpBrush {};

class GpPen {};
class GpCustomLineCap {};
class GpAdjustableArrowCap : public GpCustomLineCap {};

class GpImage {};
class GpBitmap : public GpImage {};
class GpMetafile : public GpImage {};
class GpImageAttributes {};

class GpPath {};
class GpRegion {};
class GpPathIterator {};

class GpFontFamily {};
class GpFont {};
class GpStringFormat {};
class GpFontCollection {};
class GpInstalledFontCollection : public GpFontCollection {};
class GpPrivateFontCollection : public GpFontCollection {};

class GpCachedBitmap;

typedef Status GpStatus;
typedef FillMode GpFillMode;
typedef WrapMode GpWrapMode;
typedef Unit GpUnit;
typedef CoordinateSpace GpCoordinateSpace;
typedef PointF GpPointF;
typedef Point GpPoint;
typedef RectF GpRectF;
typedef Rect GpRect;
typedef SizeF GpSizeF;
typedef HatchStyle GpHatchStyle;
typedef DashStyle GpDashStyle;
typedef LineCap GpLineCap;

typedef PenAlignment GpPenAlignment;

typedef LineJoin GpLineJoin;
typedef PenType GpPenType;

typedef Matrix GpMatrix;
typedef BrushType GpBrushType;
typedef MatrixOrder GpMatrixOrder;
typedef FlushIntention GpFlushIntention;
typedef PathData GpPathData;

#endif  // !_GDIPLUSGPSTUBS.HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusimagecodec.h ===
/**************************************************************************\
*
* Copyright (c) 2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusImageCodec.h
*
* Abstract:
*
*   APIs for imaging codecs.
*
* Revision History:
*
*   12/21/1999 dchinn
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSIMAGECODEC_H
#define _GDIPLUSIMAGECODEC_H

//--------------------------------------------------------------------------
// Codec Management APIs
//--------------------------------------------------------------------------

inline Status 
GetImageDecodersSize(
    OUT UINT *numDecoders,
    OUT UINT *size)
{
    return DllExports::GdipGetImageDecodersSize(numDecoders, size);
}


inline Status 
GetImageDecoders(
    IN UINT numDecoders,
    IN UINT size,
    OUT ImageCodecInfo *decoders)
{
    return DllExports::GdipGetImageDecoders(numDecoders, size, decoders);
}


inline Status 
GetImageEncodersSize(
    OUT UINT *numEncoders, 
    OUT UINT *size)
{
    return DllExports::GdipGetImageEncodersSize(numEncoders, size);
}


inline Status 
GetImageEncoders(
    IN UINT numEncoders,
    IN UINT size,
    OUT ImageCodecInfo *encoders)
{
    return DllExports::GdipGetImageEncoders(numEncoders, size, encoders);
}

inline Status 
AddImageCodec(
    IN const ImageCodecInfo* codec)
{
    return DllExports::GdipAddImageCodec(codec);
}

inline Status 
RemoveImageCodec(
    IN const ImageCodecInfo* codec)
{
    return DllExports::GdipRemoveImageCodec(codec);
}

#endif  // _GDIPLUSIMAGECODEC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusimageattributes.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Image Attributes
*
* Abstract:
*
*   Class for color adjustment object passed to Graphics.DrawImage
*
* Revision History:
*
*   15-Nov-1999 gilmanw
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSIMAGEATTRIBUTES_H
#define _GDIPLUSIMAGEATTRIBUTES_H

class GpImageAttributes;

// There are 5 possible sets of color adjustments:
//          ColorAdjustDefault,
//          ColorAdjustBitmap,
//          ColorAdjustBrush,
//          ColorAdjustPen,
//          ColorAdjustText,

// Bitmaps, Brushes, Pens, and Text will all use any color adjustments
// that have been set into the default ImageAttributes until their own
// color adjustments have been set.  So as soon as any "Set" method is
// called for Bitmaps, Brushes, Pens, or Text, then they start from
// scratch with only the color adjustments that have been set for them.
// Calling Reset removes any individual color adjustments for a type
// and makes it revert back to using all the default color adjustments
// (if any).  The SetToIdentity method is a way to force a type to
// have no color adjustments at all, regardless of what previous adjustments
// have been set for the defaults or for that type.

class ImageAttributes : public GdiplusBase
{
    friend class Graphics;
    friend class TextureBrush;

public:

    ImageAttributes()
    {
        nativeImageAttr = NULL;
        lastResult = DllExports::GdipCreateImageAttributes(&nativeImageAttr);
    }

    ~ImageAttributes()
    {
        DllExports::GdipDisposeImageAttributes(nativeImageAttr);
    }

    ImageAttributes* Clone() const
    {
        GpImageAttributes* clone;

        SetStatus(DllExports::GdipCloneImageAttributes(
                                            nativeImageAttr,
                                            &clone));

        return new ImageAttributes(clone, lastResult);
    }

    // Set to identity, regardless of what the default color adjustment is.
    Status
    SetToIdentity(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesToIdentity(
                                            nativeImageAttr,
                                            type));
    }

    // Remove any individual color adjustments, and go back to using the default
    Status
    Reset(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipResetImageAttributes(
                                            nativeImageAttr,
                                            type));
    }

    Status
    SetColorMatrix(
        IN const ColorMatrix *colorMatrix,
        IN ColorMatrixFlags mode = ColorMatrixFlagsDefault,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorMatrix,
                                            NULL,
                                            mode));
    }

    Status ClearColorMatrix(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL,
                                            ColorMatrixFlagsDefault));
    }

    Status
    SetColorMatrices(
        IN const ColorMatrix *colorMatrix,
        IN const ColorMatrix *grayMatrix,
        IN ColorMatrixFlags mode = ColorMatrixFlagsDefault,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorMatrix,
                                            grayMatrix,
                                            mode));
    }

    Status ClearColorMatrices(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorMatrix(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL,
                                            ColorMatrixFlagsDefault));
    }

    Status SetThreshold(
        IN REAL threshold,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesThreshold(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            threshold));
    }

    Status ClearThreshold(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesThreshold(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0.0));
    }

    Status SetGamma(
        IN REAL gamma,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesGamma(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            gamma));
    }

    Status ClearGamma(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesGamma(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0.0));
    }

    Status SetNoOp(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesNoOp(
                                            nativeImageAttr,
                                            type,
                                            TRUE));
    }

    Status ClearNoOp(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesNoOp(
                                            nativeImageAttr,
                                            type,
                                            FALSE));
    }

    Status SetColorKey(
        IN const Color& colorLow, 
        IN const Color& colorHigh,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorKeys(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorLow.GetValue(),
                                            colorHigh.GetValue()));
    }

    Status ClearColorKey(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesColorKeys(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL,
                                            NULL));
    }

    Status SetOutputChannel(
        IN ColorChannelFlags channelFlags,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannel(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            channelFlags));
    }
    
    Status ClearOutputChannel(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannel(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            ColorChannelFlagsLast));
    }

    Status SetOutputChannelColorProfile(
        IN const WCHAR *colorProfileFilename,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannelColorProfile(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            colorProfileFilename));
    }
    
    Status ClearOutputChannelColorProfile(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesOutputChannelColorProfile(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            NULL));
    }
    
    Status SetRemapTable(
        IN UINT mapSize, 
        IN const ColorMap *map,
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesRemapTable(
                                            nativeImageAttr,
                                            type,
                                            TRUE,
                                            mapSize,
                                            map));
    }

    Status ClearRemapTable(
        IN ColorAdjustType type = ColorAdjustTypeDefault
        )
    {
        return SetStatus(DllExports::GdipSetImageAttributesRemapTable(
                                            nativeImageAttr,
                                            type,
                                            FALSE,
                                            0,
                                            NULL));
    }

    Status SetBrushRemapTable(IN UINT mapSize, 
                              IN ColorMap *map)
    {
        return this->SetRemapTable(mapSize, map, ColorAdjustTypeBrush);
    }

    Status ClearBrushRemapTable()
    {
        return this->ClearRemapTable(ColorAdjustTypeBrush);
    }

    Status SetWrapMode(IN WrapMode wrap, 
                       IN const Color& color = Color(), 
                       IN BOOL clamp = FALSE) 
    {
        ARGB argb = color.GetValue();

        return SetStatus(DllExports::GdipSetImageAttributesWrapMode(
                           nativeImageAttr, wrap, argb, clamp));
    }

    #ifndef DCR_USE_NEW_145139
    Status SetICMMode(IN BOOL on)
    {
        on;
        // This is not implemented.
        // The supported method for doing ICM conversion from the embedded 
        // ICC profile is to use the Bitmap constructor from a file or stream
        // and specify TRUE for the useIcm parameter. This will cause the 
        // image to be ICM converted when it's loaded from the file/stream
        // if the profile exists.
        return SetStatus(NotImplemented);
//          DllExports::GdipSetImageAttributesICMMode(nativeImageAttr, on)
    }
    #endif

    // The flags of the palette are ignored.
    Status GetAdjustedPalette(IN OUT ColorPalette* colorPalette,
                              IN ColorAdjustType colorAdjustType) const 
    {
        return SetStatus(DllExports::GdipGetImageAttributesAdjustedPalette(
                           nativeImageAttr, colorPalette, colorAdjustType));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;
    
        return lastStatus;
    }
    

protected:
    ImageAttributes(GpImageAttributes* imageAttr, Status status)
    {
        SetNativeImageAttr(imageAttr);
        lastResult = status;
    }

    VOID SetNativeImageAttr(GpImageAttributes* nativeImageAttr)
    {
        this->nativeImageAttr = nativeImageAttr;
    }
    
    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else 
            return status;
    }

protected:
    GpImageAttributes* nativeImageAttr;
    mutable Status lastResult;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusgraphics.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Graphics.hpp
*
* Abstract:
*
*   Declarations for Graphics class
*
* Revision History:
*
*   12/04/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSGRAPHICS_H
#define _GDIPLUSGRAPHICS_H

/**
 * Represent a graphics context
 */
class Graphics : public GdiplusBase
{
public:
    friend class Region;
    friend class GraphicsPath;
    friend class Image;
    friend class Bitmap;
    friend class Metafile;
    friend class Font;
    friend class FontFamily;
    friend class FontCollection;
    friend class CachedBitmap;

    // Get a graphics context from an existing Win32 HDC or HWND
    static Graphics* FromHDC(IN HDC hdc)
    {
        return new Graphics(hdc);
    }

    static Graphics* FromHDC(IN HDC hdc, 
                             IN HANDLE hdevice)
    {
        return new Graphics(hdc, hdevice);
    }

    static Graphics* FromHWND(IN HWND hwnd,
                              IN BOOL icm = FALSE)
    {
        return new Graphics(hwnd, icm);
    }

    static Graphics* FromImage(IN Image *image)
    {
        return new Graphics(image);
    }

    Graphics(IN HDC hdc)
    {
        GpGraphics *graphics = NULL;

        lastResult = DllExports::GdipCreateFromHDC(hdc, &graphics);

        SetNativeGraphics(graphics);
    }

    Graphics(IN HDC hdc, 
             IN HANDLE hdevice)
    {
        GpGraphics *graphics = NULL;

        lastResult = DllExports::GdipCreateFromHDC2(hdc, hdevice, &graphics);

        SetNativeGraphics(graphics);
    }

    Graphics(IN HWND hwnd, 
             IN BOOL icm = FALSE)
    {
        GpGraphics *graphics = NULL;

        if (icm) 
        {
            lastResult = DllExports::GdipCreateFromHWNDICM(hwnd, &graphics);
        }
        else
        {
            lastResult = DllExports::GdipCreateFromHWND(hwnd, &graphics);
        }

        SetNativeGraphics(graphics);
    }

    Graphics(IN Image* image)
    {
        GpGraphics *graphics = NULL;

        if (image != NULL)
        {
            lastResult = DllExports::GdipGetImageGraphicsContext(
                                                                image->nativeImage, &graphics);
        }
        SetNativeGraphics(graphics);
    }

    ~Graphics()
    {
        DllExports::GdipDeleteGraphics(nativeGraphics);
    }

    VOID Flush(IN FlushIntention intention = FlushIntentionFlush)
    {
        DllExports::GdipFlush(nativeGraphics, intention);
    }

    //------------------------------------------------------------------------
    // Interop methods
    //------------------------------------------------------------------------

    // Locks the graphics until ReleaseDC is called
    HDC GetHDC()
    {
        HDC     hdc = NULL;

        SetStatus(DllExports::GdipGetDC(nativeGraphics, &hdc));

        return hdc;
    }

    VOID ReleaseHDC(IN HDC hdc)
    {
        SetStatus(DllExports::GdipReleaseDC(nativeGraphics, hdc));
    }

    //------------------------------------------------------------------------
    // Rendering modes
    //------------------------------------------------------------------------

    Status SetRenderingOrigin(IN INT x, IN INT y)
    {
        return SetStatus(
            DllExports::GdipSetRenderingOrigin(
                nativeGraphics, x, y
            )
        );
    }

    Status GetRenderingOrigin(OUT INT *x, OUT INT *y)
    {
        return SetStatus(
            DllExports::GdipGetRenderingOrigin(
                nativeGraphics, x, y
            )
        );
    }

    Status SetCompositingMode(IN CompositingMode compositingMode)
    {
        return SetStatus(DllExports::GdipSetCompositingMode(nativeGraphics,
                                                            compositingMode));
    }

    CompositingMode GetCompositingMode() const
    {
        CompositingMode mode;

        SetStatus(DllExports::GdipGetCompositingMode(nativeGraphics,
                                                     &mode));

        return mode;
    }

    Status SetCompositingQuality(IN CompositingQuality compositingQuality)
    {
        return SetStatus(DllExports::GdipSetCompositingQuality(
            nativeGraphics,
            compositingQuality));
    }

    CompositingQuality GetCompositingQuality() const
    {
        CompositingQuality quality;

        SetStatus(DllExports::GdipGetCompositingQuality(
            nativeGraphics,
            &quality));

        return quality;
    }
    
    Status SetTextRenderingHint(IN TextRenderingHint newMode)
    {
        return SetStatus(DllExports::GdipSetTextRenderingHint(nativeGraphics,
                                                          newMode));
    }
    
    TextRenderingHint GetTextRenderingHint() const
    {
        TextRenderingHint hint;

        SetStatus(DllExports::GdipGetTextRenderingHint(nativeGraphics,
                                                   &hint));

        return hint;
    }

    Status SetTextGammaValue(IN UINT gammaValue)
    {
        return SetStatus(DllExports::GdipSetTextGammaValue(nativeGraphics,
                                                          gammaValue));
    }

    UINT GetTextGammaValue() const
    {
        UINT gammaValue;

        SetStatus(DllExports::GdipGetTextGammaValue(nativeGraphics,
                                                    &gammaValue));

        return gammaValue;
    }

    InterpolationMode GetInterpolationMode() const
    {
        InterpolationMode mode = InterpolationModeInvalid;

        SetStatus(DllExports::GdipGetInterpolationMode(nativeGraphics,
                                                           &mode));

        return mode;
    }

    Status SetInterpolationMode(IN InterpolationMode interpolationMode)
    {
        return SetStatus(DllExports::GdipSetInterpolationMode(nativeGraphics,
                                                           interpolationMode));
    }

    SmoothingMode GetSmoothingMode() const
    {
        SmoothingMode smoothingMode = SmoothingModeInvalid;

        SetStatus(DllExports::GdipGetSmoothingMode(nativeGraphics,
                                                   &smoothingMode));

        return smoothingMode;
    }

    Status SetSmoothingMode(IN SmoothingMode smoothingMode)
    {
        return SetStatus(DllExports::GdipSetSmoothingMode(nativeGraphics,
                                                          smoothingMode));
    }

    PixelOffsetMode GetPixelOffsetMode() const
    {
        PixelOffsetMode pixelOffsetMode = PixelOffsetModeInvalid;

        SetStatus(DllExports::GdipGetPixelOffsetMode(nativeGraphics,
                                                     &pixelOffsetMode));

        return pixelOffsetMode;
    }

    Status SetPixelOffsetMode(IN PixelOffsetMode pixelOffsetMode)
    {
        return SetStatus(DllExports::GdipSetPixelOffsetMode(nativeGraphics,
                                                            pixelOffsetMode));
    }

    //------------------------------------------------------------------------
    // Manipulate the current world transform
    //------------------------------------------------------------------------

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetWorldTransform(nativeGraphics,
                                                        matrix->nativeMatrix));
    }
    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetWorldTransform(nativeGraphics));
    }

    Status MultiplyTransform(IN Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyWorldTransform(nativeGraphics,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateWorldTransform(nativeGraphics,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleWorldTransform(nativeGraphics,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateWorldTransform(nativeGraphics,
                                                              angle, order));
    }

    /**
     * Return the current world transform
     */

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetWorldTransform(nativeGraphics,
                                                           matrix->nativeMatrix));
    }

    /**
     * Manipulate the current page transform
     */

    Status SetPageUnit(IN Unit unit)
    {
        return SetStatus(DllExports::GdipSetPageUnit(nativeGraphics,
                                                     unit));
    }

    Status SetPageScale(IN REAL scale)
    {
        return SetStatus(DllExports::GdipSetPageScale(nativeGraphics,
                                                      scale));
    }

    /**
     * Retrieve the current page transform information
     * notes @ these are atomic
     */
    Unit GetPageUnit() const
    {
        Unit unit;

        SetStatus(DllExports::GdipGetPageUnit(nativeGraphics, &unit));

        return unit;
    }

    REAL GetPageScale() const
    {
        REAL scale;

        SetStatus(DllExports::GdipGetPageScale(nativeGraphics, &scale));

        return scale;
    }

    REAL GetDpiX() const
    {
        REAL dpi;

        SetStatus(DllExports::GdipGetDpiX(nativeGraphics, &dpi));

        return dpi;
    }

    REAL GetDpiY() const
    {
        REAL dpi;

        SetStatus(DllExports::GdipGetDpiY(nativeGraphics, &dpi));

        return dpi;
    }

    /**
     * Transform points in the current graphics context
     */
    // float version
    Status TransformPoints(IN CoordinateSpace destSpace,
                           IN CoordinateSpace srcSpace,
                           IN OUT PointF* pts,
                           IN INT count) const
    {
        return SetStatus(DllExports::GdipTransformPoints(nativeGraphics,
                                                         destSpace,
                                                         srcSpace,
                                                         pts,
                                                         count));
    }

    // integer version
    Status TransformPoints(IN CoordinateSpace destSpace,
                           IN CoordinateSpace srcSpace,
                           IN OUT Point* pts,
                           IN INT count) const
    {

        return SetStatus(DllExports::GdipTransformPointsI(nativeGraphics,
                                                          destSpace,
                                                          srcSpace,
                                                          pts,
                                                          count));
    }

    //------------------------------------------------------------------------
    // GetNearestColor (for <= 8bpp surfaces)
    // Note: alpha is ignored
    //------------------------------------------------------------------------
    Status GetNearestColor(IN OUT Color* color) const 
    {
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        ARGB argb = color->GetValue();

        Status status = SetStatus(DllExports::GdipGetNearestColor(nativeGraphics, &argb));
        
        color->SetValue(argb);

        return status;
    }

    /**
     * Vector drawing methods
     *
     * @notes Do we need a set of methods that take
     *  integer coordinate parameters?
     */

    // float version
    Status DrawLine(IN const Pen* pen, 
                    IN REAL x1, 
                    IN REAL y1, 
                    IN REAL x2, 
                    IN REAL y2)
    {
        return SetStatus(DllExports::GdipDrawLine(nativeGraphics,
                                                  pen->nativePen, x1, y1, x2,
                                                  y2));
    }

    Status DrawLine(IN const Pen* pen, 
                    IN const PointF& pt1, 
                    IN const PointF& pt2)
    {
        return DrawLine(pen, pt1.X, pt1.Y, pt2.X, pt2.Y);
    }

    Status DrawLines(IN const Pen* pen, 
                     IN const PointF* points, 
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawLines(nativeGraphics,
                                                   pen->nativePen,
                                                   points, count));
    }

    // int version
    Status DrawLine(IN const Pen* pen, 
                    IN INT x1, 
                    IN INT y1, 
                    IN INT x2, 
                    IN INT y2)
    {
        return SetStatus(DllExports::GdipDrawLineI(nativeGraphics,
                                                   pen->nativePen,
                                                   x1,
                                                   y1,
                                                   x2,
                                                   y2));
    }

    Status DrawLine(IN const Pen* pen, 
                    IN const Point& pt1, 
                    IN const Point& pt2)
    {
        return DrawLine(pen,
                        pt1.X,
                        pt1.Y,
                        pt2.X,
                        pt2.Y);
    }

    Status DrawLines(IN const Pen* pen, 
                     IN const Point* points, 
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawLinesI(nativeGraphics,
                                                    pen->nativePen,
                                                    points,
                                                    count));
    }

    // float version
    Status DrawArc(IN const Pen* pen, 
                   IN REAL x, 
                   IN REAL y, 
                   IN REAL width,
                   IN REAL height, 
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawArc(nativeGraphics,
                                                 pen->nativePen,
                                                 x,
                                                 y,
                                                 width,
                                                 height,
                                                 startAngle,
                                                 sweepAngle));
    }

    Status DrawArc(IN const Pen* pen, 
                   IN const RectF& rect,
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return DrawArc(pen, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    // int version
    Status DrawArc(IN const Pen* pen, 
                   IN INT x, 
                   IN INT y, 
                   IN INT width,
                   IN INT height, 
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawArcI(nativeGraphics,
                                                  pen->nativePen,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }


    Status DrawArc(IN const Pen* pen, 
                   IN const Rect& rect,
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return DrawArc(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    // float version
    Status DrawBezier(IN const Pen* pen, 
                      IN REAL x1, 
                      IN REAL y1, 
                      IN REAL x2, 
                      IN REAL y2,
                      IN REAL x3, 
                      IN REAL y3, 
                      IN REAL x4, 
                      IN REAL y4)
    {
        return SetStatus(DllExports::GdipDrawBezier(nativeGraphics,
                                                    pen->nativePen, x1, y1,
                                                    x2, y2, x3, y3, x4, y4));
    }

    Status DrawBezier(IN const Pen* pen, 
                      IN const PointF& pt1, 
                      IN const PointF& pt2,
                      IN const PointF& pt3, 
                      IN const PointF& pt4)
    {
        return DrawBezier(pen,
                          pt1.X,
                          pt1.Y,
                          pt2.X,
                          pt2.Y,
                          pt3.X,
                          pt3.Y,
                          pt4.X,
                          pt4.Y);
    }

    Status DrawBeziers(IN const Pen* pen,
                       IN const PointF* points, 
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawBeziers(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count));
    }

    // int version
    Status DrawBezier(IN const Pen* pen,
                      IN INT x1, 
                      IN INT y1, 
                      IN INT x2, 
                      IN INT y2,
                      IN INT x3, 
                      IN INT y3,
                      IN INT x4, 
                      IN INT y4)
    {
        return SetStatus(DllExports::GdipDrawBezierI(nativeGraphics,
                                                     pen->nativePen,
                                                     x1,
                                                     y1,
                                                     x2,
                                                     y2,
                                                     x3,
                                                     y3,
                                                     x4,
                                                     y4));
    }

    Status DrawBezier(IN const Pen* pen,
                      IN const Point& pt1,
                      IN const Point& pt2,
                      IN const Point& pt3,
                      IN const Point& pt4)
    {
        return DrawBezier(pen,
                          pt1.X,
                          pt1.Y,
                          pt2.X,
                          pt2.Y,
                          pt3.X,
                          pt3.Y,
                          pt4.X,
                          pt4.Y);
    }

    Status DrawBeziers(IN const Pen* pen, 
                       IN const Point* points, 
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawBeziersI(nativeGraphics,
                                                      pen->nativePen,
                                                      points,
                                                      count));
    }

    // float version
    Status DrawRectangle(IN const Pen* pen, 
                         IN const RectF& rect)
    {
        return DrawRectangle(pen, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawRectangle(IN const Pen* pen, 
                         IN REAL x, 
                         IN REAL y, 
                         IN REAL width,
                         IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawRectangle(nativeGraphics,
                                                       pen->nativePen, x, y,
                                                       width, height));
    }

    Status DrawRectangles(IN const Pen* pen, 
                          IN const RectF* rects, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipDrawRectangles(nativeGraphics,
                                                        pen->nativePen,
                                                        rects, count));
    }

    // integer version
    Status DrawRectangle(IN const Pen* pen, 
                         IN const Rect& rect)
    {
        return DrawRectangle(pen,
                             rect.X,
                             rect.Y,
                             rect.Width,
                             rect.Height);
    }

    Status DrawRectangle(IN const Pen* pen, 
                         IN INT x, 
                         IN INT y, 
                         IN INT width, 
                         IN INT height)
    {
        return SetStatus(DllExports::GdipDrawRectangleI(nativeGraphics,
                                                        pen->nativePen,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status DrawRectangles(IN const Pen* pen, 
                          IN const Rect* rects, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipDrawRectanglesI(nativeGraphics,
                                                         pen->nativePen,
                                                         rects,
                                                         count));
    }

    // float version
    Status DrawEllipse(IN const Pen* pen, 
                       IN const RectF& rect)
    {
        return DrawEllipse(pen, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawEllipse(IN const Pen* pen, 
                       IN REAL x, 
                       IN REAL y, 
                       IN REAL width, 
                       IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawEllipse(nativeGraphics,
                                                     pen->nativePen,
                                                     x,
                                                     y,
                                                     width,
                                                     height));
    }

    // integer version
    Status DrawEllipse(IN const Pen* pen, 
                       IN const Rect& rect)
    {
        return DrawEllipse(pen,
                           rect.X,
                           rect.Y,
                           rect.Width,
                           rect.Height);
    }

    Status DrawEllipse(IN const Pen* pen, 
                       IN INT x, 
                       IN INT y, 
                       IN INT width, 
                       IN INT height)
    {
        return SetStatus(DllExports::GdipDrawEllipseI(nativeGraphics,
                                                      pen->nativePen,
                                                      x,
                                                      y,
                                                      width,
                                                      height));
    }

    // floating point version
    Status DrawPie(IN const Pen* pen, 
                   IN const RectF& rect, 
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return DrawPie(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawPie(IN const Pen* pen, 
                   IN REAL x, 
                   IN REAL y, 
                   IN REAL width,
                   IN REAL height, 
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawPie(nativeGraphics,
                                                 pen->nativePen,
                                                 x,
                                                 y,
                                                 width,
                                                 height,
                                                 startAngle,
                                                 sweepAngle));
    }

    // integer point version
    Status DrawPie(IN const Pen* pen, 
                   IN const Rect& rect,
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return DrawPie(pen,
                       rect.X,
                       rect.Y,
                       rect.Width,
                       rect.Height,
                       startAngle,
                       sweepAngle);
    }

    Status DrawPie(IN const Pen* pen, 
                   IN INT x, 
                   IN INT y, 
                   IN INT width, 
                   IN INT height,
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipDrawPieI(nativeGraphics,
                                                  pen->nativePen,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }

    // float version
    Status DrawPolygon(IN const Pen* pen, 
                       IN const PointF* points, 
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawPolygon(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count));
    }

    // integer version
    Status DrawPolygon(IN const Pen* pen, 
                       IN const Point* points, 
                       IN INT count)
    {
        return SetStatus(DllExports::GdipDrawPolygonI(nativeGraphics,
                                                      pen->nativePen,
                                                      points,
                                                      count));
    }

    // float version
    Status DrawPath(IN const Pen* pen, 
                    IN const GraphicsPath* path)
    {
        return SetStatus(DllExports::GdipDrawPath(nativeGraphics,
                                                  pen->nativePen,
                                                  path->nativePath));
    }

    // float version
    Status DrawCurve(IN const Pen* pen, 
                     IN const PointF* points, 
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawCurve(nativeGraphics,
                                                   pen->nativePen, points,
                                                   count));
    }

    Status DrawCurve(IN const Pen* pen, 
                     IN const PointF* points, 
                     IN INT count,
                     IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawCurve2(nativeGraphics,
                                                    pen->nativePen, points,
                                                    count, tension));
    }

    Status DrawCurve(IN const Pen* pen,
                     IN const PointF* points, 
                     IN INT count,
                     IN INT offset, 
                     IN INT numberOfSegments, 
                     IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipDrawCurve3(nativeGraphics,
                                                    pen->nativePen, points,
                                                    count, offset,
                                                    numberOfSegments, tension));
    }

    // integer version
    Status DrawCurve(IN const Pen* pen, 
                     IN const Point* points, 
                     IN INT count)
    {
        return SetStatus(DllExports::GdipDrawCurveI(nativeGraphics,
                                                    pen->nativePen,
                                                    points,
                                                    count));
    }

    Status DrawCurve(IN const Pen* pen, 
                     IN const Point* points, 
                     IN INT count,
                     IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawCurve2I(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count,
                                                     tension));
    }

    Status DrawCurve(IN const Pen* pen, 
                     IN const Point* points, 
                     IN INT count,
                     IN INT offset, 
                     IN INT numberOfSegments, 
                     IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipDrawCurve3I(nativeGraphics,
                                                     pen->nativePen,
                                                     points,
                                                     count,
                                                     offset,
                                                     numberOfSegments,
                                                     tension));
    }

    // float version
    Status DrawClosedCurve(IN const Pen* pen, 
                           IN const PointF* points, 
                           IN INT count)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve(nativeGraphics,
                                                         pen->nativePen,
                                                         points, count));
    }

    Status DrawClosedCurve(IN const Pen *pen, 
                           IN const PointF* points, 
                           IN INT count,
                           IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve2(nativeGraphics,
                                                          pen->nativePen,
                                                          points, count,
                                                          tension));
    }

    // integer version
    Status DrawClosedCurve(IN const Pen* pen, 
                           IN const Point* points, 
                           IN INT count)
    {
        return SetStatus(DllExports::GdipDrawClosedCurveI(nativeGraphics,
                                                          pen->nativePen,
                                                          points,
                                                          count));
    }

    Status DrawClosedCurve(IN const Pen *pen, 
                           IN const Point* points, 
                           IN INT count,
                           IN REAL tension)
    {
        return SetStatus(DllExports::GdipDrawClosedCurve2I(nativeGraphics,
                                                           pen->nativePen,
                                                           points,
                                                           count,
                                                           tension));
    }

    Status Clear(IN const Color &color)
    {
        return SetStatus(DllExports::GdipGraphicsClear(
            nativeGraphics,
            color.GetValue()));
    }

    // float version
    Status FillRectangle(IN const Brush* brush, 
                         IN const RectF& rect)
    {
        return FillRectangle(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillRectangle(IN const Brush* brush, 
                         IN REAL x, 
                         IN REAL y, 
                         IN REAL width,
                         IN REAL height)
    {
        return SetStatus(DllExports::GdipFillRectangle(nativeGraphics,
                                                       brush->nativeBrush, x, y,
                                                       width, height));
    }

    Status FillRectangles(IN const Brush* brush, 
                          IN const RectF* rects, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipFillRectangles(nativeGraphics,
                                                        brush->nativeBrush,
                                                        rects, count));
    }

    // integer version
    Status FillRectangle(IN const Brush* brush, 
                         IN const Rect& rect)
    {
        return FillRectangle(brush,
                             rect.X,
                             rect.Y,
                             rect.Width,
                             rect.Height);
    }

    Status FillRectangle(IN const Brush* brush, 
                         IN INT x, 
                         IN INT y, 
                         IN INT width,
                         IN INT height)
    {
        return SetStatus(DllExports::GdipFillRectangleI(nativeGraphics,
                                                        brush->nativeBrush,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    Status FillRectangles(IN const Brush* brush, 
                          IN const Rect* rects, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipFillRectanglesI(nativeGraphics,
                                                         brush->nativeBrush,
                                                         rects,
                                                         count));
    }

    // float version
    Status FillPolygon(IN const Brush* brush, 
                       IN const PointF* points,
                       IN INT count)
    {
        return FillPolygon(brush, points, count, FillModeAlternate);
    }

    Status FillPolygon(IN const Brush* brush, 
                       IN const PointF* points, 
                       IN INT count,
                       IN FillMode fillMode)
    {
        return SetStatus(DllExports::GdipFillPolygon(nativeGraphics,
                                                     brush->nativeBrush,
                                                     points, count, fillMode));
    }

    // integer version
    Status FillPolygon(IN const Brush* brush, 
                       IN const Point* points, 
                       IN INT count)
    {
        return FillPolygon(brush, points, count, FillModeAlternate);
    }

    Status FillPolygon(IN const Brush* brush, 
                       IN const Point* points, 
                       IN INT count,
                       IN FillMode fillMode)
    {
        return SetStatus(DllExports::GdipFillPolygonI(nativeGraphics,
                                                      brush->nativeBrush,
                                                      points, count,
                                                      fillMode));
    }

    // float version
    Status FillEllipse(IN const Brush* brush, 
                       IN const RectF& rect)
    {
        return FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillEllipse(IN const Brush* brush, 
                       IN REAL x, 
                       IN REAL y, 
                       IN REAL width,
                       IN REAL height)
    {
        return SetStatus(DllExports::GdipFillEllipse(nativeGraphics,
                                                     brush->nativeBrush, x, y,
                                                     width, height));
    }

    // integer version
    Status FillEllipse(IN const Brush* brush, 
                       IN const Rect& rect)
    {
        return FillEllipse(brush, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status FillEllipse(IN const Brush* brush, 
                       IN INT x, 
                       IN INT y, 
                       IN INT width, 
                       IN INT height)
    {
        return SetStatus(DllExports::GdipFillEllipseI(nativeGraphics,
                                                      brush->nativeBrush,
                                                      x,
                                                      y,
                                                      width,
                                                      height));
    }

    // float version
    Status FillPie(IN const Brush* brush, 
                   IN const RectF& rect, 
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status FillPie(IN const Brush* brush, 
                   IN REAL x, 
                   IN REAL y, 
                   IN REAL width,
                   IN REAL height, 
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipFillPie(nativeGraphics,
                                                 brush->nativeBrush, x, y,
                                                 width, height, startAngle,
                                                 sweepAngle));
    }

    // integer version
    Status FillPie(IN const Brush* brush, 
                   IN const Rect& rect, 
                   IN REAL startAngle,
                   IN REAL sweepAngle)
    {
        return FillPie(brush, rect.X, rect.Y, rect.Width, rect.Height,
                       startAngle, sweepAngle);
    }

    Status FillPie(IN const Brush* brush, 
                   IN INT x, 
                   IN INT y, 
                   IN INT width,
                   IN INT height, 
                   IN REAL startAngle, 
                   IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipFillPieI(nativeGraphics,
                                                  brush->nativeBrush,
                                                  x,
                                                  y,
                                                  width,
                                                  height,
                                                  startAngle,
                                                  sweepAngle));
    }

    Status FillPath(IN const Brush* brush, 
                    IN const GraphicsPath* path)
    {
        return SetStatus(DllExports::GdipFillPath(nativeGraphics,
                                                  brush->nativeBrush,
                                                  path->nativePath));
    }

    // float version
    Status FillClosedCurve(IN const Brush* brush, 
                           IN const PointF* points, 
                           IN INT count)
    {
        return SetStatus(DllExports::GdipFillClosedCurve(nativeGraphics,
                                                         brush->nativeBrush,
                                                         points, count));

    }

    Status FillClosedCurve(IN const Brush* brush, 
                           IN const PointF* points, 
                           IN INT count,
                           IN FillMode fillMode, 
                           IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipFillClosedCurve2(nativeGraphics,
                                                          brush->nativeBrush,
                                                          points, count,
                                                          tension, fillMode));
    }

    // integer version
    Status FillClosedCurve(IN const Brush* brush, 
                           IN const Point* points,
                           IN INT count)
    {
        return SetStatus(DllExports::GdipFillClosedCurveI(nativeGraphics,
                                                          brush->nativeBrush,
                                                          points,
                                                          count));
    }

    Status FillClosedCurve(IN const Brush* brush, 
                           IN const Point* points, 
                           IN INT count,
                           IN FillMode fillMode, 
                           IN REAL tension = 0.5f)
    {
        return SetStatus(DllExports::GdipFillClosedCurve2I(nativeGraphics,
                                                           brush->nativeBrush,
                                                           points, count,
                                                           tension, fillMode));
    }

    // float version
    Status FillRegion(IN const Brush* brush, 
                      IN const Region* region)
    {
        return SetStatus(DllExports::GdipFillRegion(nativeGraphics,
                                                    brush->nativeBrush,
                                                    region->nativeRegion));
    }

    // DrawString and MeasureString
    Status
    DrawString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        IN const Brush        *brush
    )
    {
        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            brush->nativeBrush
        ));
    }

    Status
    DrawString(
        const WCHAR        *string,
        INT                 length,
        const Font         *font,
        const PointF       &origin,
        const Brush        *brush
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &rect,
            NULL,
            brush->nativeBrush
        ));
    }

    Status
    DrawString(
        const WCHAR        *string,
        INT                 length,
        const Font         *font,
        const PointF       &origin,
        const StringFormat *stringFormat,
        const Brush        *brush
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipDrawString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &rect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            brush->nativeBrush
        ));
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        OUT RectF             *boundingBox,
        OUT INT               *codepointsFitted = 0,
        OUT INT               *linesFilled      = 0
    ) const
    {
        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            boundingBox,
            codepointsFitted,
            linesFilled
        ));
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const SizeF        &layoutRectSize,
        IN const StringFormat *stringFormat,
        OUT SizeF             *size,
        OUT INT               *codepointsFitted = 0,
        OUT INT               *linesFilled      = 0
    ) const
    {
        RectF   layoutRect(0, 0, layoutRectSize.Width, layoutRectSize.Height);
        RectF   boundingBox;
        Status  status;
            
        if (size == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        status = SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            size ? &boundingBox : NULL,
            codepointsFitted,
            linesFilled
        ));

        if (size && status == Ok)
        {
            size->Width  = boundingBox.Width;
            size->Height = boundingBox.Height;
        }

        return status;
    }

    Status
    MeasureString(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const PointF       &origin,
        IN const StringFormat *stringFormat,
        OUT RectF             *boundingBox
    ) const
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &rect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }


    Status
    MeasureString(
        IN const WCHAR  *string,
        IN INT           length,
        IN const Font   *font,
        IN const RectF  &layoutRect,
        OUT RectF       *boundingBox
    ) const 
    {
        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &layoutRect,
            NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }

    Status
    MeasureString(
        IN const WCHAR  *string,
        IN INT           length,
        IN const Font   *font,
        IN const PointF &origin,
        OUT RectF       *boundingBox
    ) const
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipMeasureString(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            &rect,
            NULL,
            boundingBox,
            NULL,
            NULL
        ));
    }

    Status
    MeasureStringRegion(
        IN const WCHAR        *string,
        IN INT                 length,
        IN const Font         *font,
        IN const RectF        &layoutRect,
        IN const StringFormat *stringFormat,
        IN INT                 firstCharacterIndex,
        IN INT                 characterCount,
        OUT Region            *region
    ) const
    {
        if (region == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        return (SetStatus(DllExports::GdipMeasureStringRegion(
            nativeGraphics,
            string,
            length,
            font->nativeFont,
            layoutRect,
            stringFormat ? stringFormat->nativeFormat : NULL,
            firstCharacterIndex,
            characterCount,
            region->nativeRegion)));
    }

    Status DrawDriverString(
        IN const UINT16  *text,
        IN INT            length,
        IN const Font    *font,
        IN const Brush   *brush,
        IN const PointF  *positions,
        IN INT            flags,
        IN Matrix        *matrix
    )
    {
        return SetStatus(DllExports::GdipDrawDriverString(
            nativeGraphics,
            text,
            length,
            font ? font->nativeFont : NULL,
            brush ? brush->nativeBrush : NULL,
            positions,
            flags,
            matrix ? matrix->nativeMatrix : NULL
        ));
    }

    Status MeasureDriverString(
        IN const UINT16  *text,
        IN INT            length,
        IN const Font    *font,
        IN const PointF  *positions,
        IN INT            flags,
        IN Matrix        *matrix,
        OUT RectF        *boundingBox
    ) const
    {
        return SetStatus(DllExports::GdipMeasureDriverString(
            nativeGraphics,
            text,
            length,
            font ? font->nativeFont : NULL,
            positions,
            flags,
            matrix ? matrix->nativeMatrix : NULL,
            boundingBox
        ));
    }

    Status DriverStringPointToCodepoint(
        IN const UINT16  *text,
        IN INT            length,
        IN const Font    *font,
        IN const PointF  *positions,
        IN INT            flags,
        IN Matrix        *matrix,
        IN const PointF  &hit,
        OUT INT          *index,
        OUT BOOL         *rightEdge,
        OUT REAL         *distance
    )
    {
        return SetStatus(DllExports::GdipDriverStringPointToCodepoint(
            nativeGraphics,
            text,
            length,
            font ? font->nativeFont : NULL,
            positions,
            flags,
            matrix ? matrix->nativeMatrix : NULL,
            &hit,
            index,
            rightEdge,
            distance
        ));
    }


    // Draw a cached bitmap on this graphics destination offset by
    // x, y. Note this will fail with WrongState if the CachedBitmap
    // native format differs from this Graphics.

    Status DrawCachedBitmap(IN CachedBitmap *cb,
                            IN INT x, 
                            IN INT y)
    {
        return SetStatus(DllExports::GdipDrawCachedBitmap(
            nativeGraphics, 
            cb->nativeCachedBitmap,
            x, y
        ));
    }

    /**
     * Draw images (both bitmap and vector)
     */
    // float version
    Status DrawImage(IN Image* image,
                     IN const PointF& point)
    {
        return DrawImage(image, point.X, point.Y);
    }

    Status DrawImage(IN Image* image, 
                     IN REAL x, 
                     IN REAL y)
    {
        return SetStatus(DllExports::GdipDrawImage(nativeGraphics,
                                                   image ? image->nativeImage
                                                         : NULL,
                                                   x,
                                                   y));
    }

    Status DrawImage(IN Image* image, 
                     IN RectF& rect)
    {
        return DrawImage(image, rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status DrawImage(IN Image* image,
                     IN REAL x, 
                     IN REAL y, 
                     IN REAL width, 
                     IN REAL height)
    {
        return SetStatus(DllExports::GdipDrawImageRect(nativeGraphics,
                                                       image ? image->nativeImage
                                                             : NULL,
                                                       x,
                                                       y,
                                                       width,
                                                       height));
    }

    // integer version
    Status DrawImage(IN Image* image, 
                     IN const Point& point)
    {
        return DrawImage(image, point.X, point.Y);
    }

    Status DrawImage(IN Image* image, 
                     IN INT x, 
                     IN INT y)
    {
        return SetStatus(DllExports::GdipDrawImageI(nativeGraphics,
                                                    image ? image->nativeImage
                                                          : NULL,
                                                    x,
                                                    y));
    }

    Status DrawImage(IN Image* image, 
                     IN const Rect& rect)
    {
        return DrawImage(image,
                         rect.X,
                         rect.Y,
                         rect.Width,
                         rect.Height);
    }

    Status DrawImage(IN Image* image,
                     IN INT x, 
                     IN INT y,
                     IN INT width,
                     IN INT height) {
        return SetStatus(DllExports::GdipDrawImageRectI(nativeGraphics,
                                                        image ? image->nativeImage
                                                              : NULL,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    /**
     * Affine or perspective blt
     *  destPoints.length = 3: rect => parallelogram
     *      destPoints[0] <=> top-left corner of the source rectangle
     *      destPoints[1] <=> top-right corner
     *      destPoints[2] <=> bottom-left corner
     *  destPoints.length = 4: rect => quad
     *      destPoints[3] <=> bottom-right corner
     *
     *  @notes Perspective blt only works for bitmap images.
     */
    Status DrawImage(IN Image* image,
                     IN const PointF* destPoints, 
                     IN INT count)
    {
        if (count != 3 && count != 4)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipDrawImagePoints(nativeGraphics,
                                                         image ? image->nativeImage
                                                               : NULL,
                                                         destPoints, count));
    }

    Status DrawImage(IN Image* image, 
                     IN const Point* destPoints, 
                     IN INT count)
    {
        if (count != 3 && count != 4)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipDrawImagePointsI(nativeGraphics,
                                                          image ? image->nativeImage
                                                                : NULL,
                                                          destPoints,
                                                          count));
    }

    /**
     * We need another set of methods similar to the ones above
     * that take an additional Rect parameter to specify the
     * portion of the source image to be drawn.
     */
    // float version
    Status DrawImage(IN Image* image,
                     IN REAL x, 
                     IN REAL y, 
                     IN REAL srcx, 
                     IN REAL srcy,
                     IN REAL srcwidth, 
                     IN REAL srcheight, 
                     IN Unit srcUnit)
    {
        return SetStatus(DllExports::GdipDrawImagePointRect(nativeGraphics,
                                                            image ? image->nativeImage
                                                                  : NULL,
                                                            x, y,
                                                            srcx, srcy,
                                                            srcwidth, srcheight, srcUnit));
    }

    Status DrawImage(IN Image* image,
                     IN const RectF& destRect,
                     IN REAL srcx, 
                     IN REAL srcy, 
                     IN REAL srcwidth,
                     IN REAL srcheight,
                     IN Unit srcUnit,
                     IN ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImageRectRect(nativeGraphics,
                                                           image ? image->nativeImage
                                                                 : NULL,
                                                           destRect.X,
                                                           destRect.Y,
                                                           destRect.Width,
                                                           destRect.Height,
                                                           srcx, srcy,
                                                           srcwidth, srcheight,
                                                           srcUnit,
                                                           imageAttributes
                                                            ? imageAttributes->nativeImageAttr
                                                            : NULL,
                                                           callback,
                                                           callbackData));
    }

    Status DrawImage(IN Image* image, 
                     IN const PointF* destPoints,
                     IN INT count, 
                     IN REAL srcx, 
                     IN REAL srcy, 
                     IN REAL srcwidth,
                     IN REAL srcheight, 
                     IN Unit srcUnit,
                     IN ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImagePointsRect(nativeGraphics,
                                                             image ? image->nativeImage
                                                                   : NULL,
                                                             destPoints, count,
                                                             srcx, srcy,
                                                             srcwidth,
                                                             srcheight,
                                                             srcUnit,
                                                             imageAttributes
                                                              ? imageAttributes->nativeImageAttr
                                                              : NULL,
                                                             callback,
                                                             callbackData));
    }

    // integer version
    Status DrawImage(IN Image* image, 
                     IN INT x, 
                     IN INT y, 
                     IN INT srcx, 
                     IN INT srcy,
                     IN INT srcwidth, 
                     IN INT srcheight, 
                     IN Unit srcUnit)
    {
        return SetStatus(DllExports::GdipDrawImagePointRectI(nativeGraphics,
                                                             image ? image->nativeImage
                                                                   : NULL,
                                                             x,
                                                             y,
                                                             srcx,
                                                             srcy,
                                                             srcwidth,
                                                             srcheight,
                                                             srcUnit));
    }

    Status DrawImage(IN Image* image, 
                     IN const Rect& destRect,
                     IN INT srcx, 
                     IN INT srcy, 
                     IN INT srcwidth, 
                     IN INT srcheight,
                     IN Unit srcUnit,
                     IN ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImageRectRectI(nativeGraphics,
                                                            image ? image->nativeImage
                                                                  : NULL,
                                                            destRect.X,
                                                            destRect.Y,
                                                            destRect.Width,
                                                            destRect.Height,
                                                            srcx,
                                                            srcy,
                                                            srcwidth,
                                                            srcheight,
                                                            srcUnit,
                                                            imageAttributes
                                                            ? imageAttributes->nativeImageAttr
                                                            : NULL,
                                                            callback,
                                                            callbackData));
    }

    Status DrawImage(IN Image* image, 
                     IN const Point* destPoints,
                     IN INT count, 
                     IN INT srcx, 
                     IN INT srcy, 
                     IN INT srcwidth, 
                     IN INT srcheight,
                     IN Unit srcUnit,
                     IN ImageAttributes* imageAttributes = NULL,
                     IN DrawImageAbort callback = NULL,
                     IN VOID* callbackData = NULL)
    {
        return SetStatus(DllExports::GdipDrawImagePointsRectI(nativeGraphics,
                                                              image ? image->nativeImage
                                                                    : NULL,
                                                              destPoints,
                                                              count,
                                                              srcx,
                                                              srcy,
                                                              srcwidth,
                                                              srcheight,
                                                              srcUnit,
                                                              imageAttributes
                                                               ? imageAttributes->nativeImageAttr
                                                               : NULL,
                                                              callback,
                                                              callbackData));
    }

    // The following methods are for playing an EMF+ to a graphics
    // via the enumeration interface.  Each record of the EMF+ is
    // sent to the callback (along with the callbackData).  Then
    // the callback can invoke the Metafile::PlayRecord method
    // to play the particular record.

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF &          destPoint,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPoint(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point &           destPoint,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPointI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const RectF &           destRect,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestRect(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Rect &            destRect,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestRectI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF *          destPoints,
        IN INT                     count,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPoints(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point *           destPoints,
        IN INT                     count,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileDestPointsI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF &          destPoint,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPoint(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point &           destPoint,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPointI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoint,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const RectF &           destRect,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestRect(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Rect &            destRect,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestRectI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destRect,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const PointF *          destPoints,
        IN INT                     count,
        IN const RectF &           srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPoints(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    Status
    EnumerateMetafile(
        IN const Metafile *        metafile,
        IN const Point *           destPoints,
        IN INT                     count,
        IN const Rect &            srcRect,
        IN Unit                    srcUnit,
        IN EnumerateMetafileProc   callback,
        IN VOID *                  callbackData    = NULL,
        IN ImageAttributes *       imageAttributes = NULL
        )
    {
        return SetStatus(DllExports::GdipEnumerateMetafileSrcRectDestPointsI(
                    nativeGraphics,
                    (const GpMetafile *)(metafile ? metafile->nativeImage:NULL),
                    destPoints,
                    count,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes ? imageAttributes->nativeImageAttr : NULL));
    }

    /**
      * Clipping region operations
      *
      * @notes Simply incredible redundancy here.
      */
    Status SetClip(IN const Graphics* g, 
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipGraphics(nativeGraphics,
                                                         g->nativeGraphics,
                                                         combineMode));
    }

    Status SetClip(IN const RectF& rect, 
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     combineMode));
    }

    Status SetClip(IN const Rect& rect, 
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      combineMode));
    }

    Status SetClip(IN const GraphicsPath* path,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipPath(nativeGraphics,
                                                     path->nativePath,
                                                     combineMode));
    }

    Status SetClip(IN const Region* region,
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       combineMode));
    }

    // This is different than the other SetClip methods because it assumes
    // that the HRGN is already in device units, so it doesn't transform
    // the coordinates in the HRGN.
    Status SetClip(IN HRGN hRgn, 
                   IN CombineMode combineMode = CombineModeReplace)
    {
        return SetStatus(DllExports::GdipSetClipHrgn(nativeGraphics, hRgn,
                                                     combineMode));
    }

    Status IntersectClip(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     CombineModeIntersect));
    }

    Status IntersectClip(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      CombineModeIntersect));
    }

    Status IntersectClip(IN const Region* region)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       CombineModeIntersect));
    }

    Status ExcludeClip(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipSetClipRect(nativeGraphics,
                                                     rect.X, rect.Y,
                                                     rect.Width, rect.Height,
                                                     CombineModeExclude));
    }

    Status ExcludeClip(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipSetClipRectI(nativeGraphics,
                                                      rect.X, rect.Y,
                                                      rect.Width, rect.Height,
                                                      CombineModeExclude));
    }

    Status ExcludeClip(IN const Region* region)
    {
        return SetStatus(DllExports::GdipSetClipRegion(nativeGraphics,
                                                       region->nativeRegion,
                                                       CombineModeExclude));
    }

    Status ResetClip()
    {
        return SetStatus(DllExports::GdipResetClip(nativeGraphics));
    }

    Status TranslateClip(IN REAL dx, 
                         IN REAL dy)
    {
        return SetStatus(DllExports::GdipTranslateClip(nativeGraphics, dx, dy));
    }

    Status TranslateClip(IN INT dx, 
                         IN INT dy)
    {
        return SetStatus(DllExports::GdipTranslateClipI(nativeGraphics,
                                                        dx, dy));
    }

    /**
     *  GetClip region from graphics context
     */
    Status GetClip(OUT Region* region) const
    {
        return SetStatus(DllExports::GdipGetClip(nativeGraphics, 
                                                 region->nativeRegion));
    }

    /**
     * Hit testing operations
     */
    Status GetClipBounds(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetClipBounds(nativeGraphics, rect));
    }

    Status GetClipBounds(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetClipBoundsI(nativeGraphics, rect));
    }

    BOOL IsClipEmpty() const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsClipEmpty(nativeGraphics, &booln));

        return booln;
    }

    Status GetVisibleClipBounds(OUT RectF *rect) const
    {

        return SetStatus(DllExports::GdipGetVisibleClipBounds(nativeGraphics,
                                                              rect));
    }

    Status GetVisibleClipBounds(OUT Rect *rect) const
    {
       return SetStatus(DllExports::GdipGetVisibleClipBoundsI(nativeGraphics,
                                                              rect));
    }

    BOOL IsVisibleClipEmpty() const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisibleClipEmpty(nativeGraphics, &booln));

        return booln;
    }

    BOOL IsVisible(IN INT x,
                   IN INT y) const
    {
        return IsVisible(Point(x,y));
    }

    BOOL IsVisible(IN const Point& point) const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisiblePointI(nativeGraphics,
                                                  point.X,
                                                  point.Y,
                                                  &booln));

        return booln;
    }

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height) const
    {
        return IsVisible(Rect(x, y, width, height));
    }

    BOOL IsVisible(IN const Rect& rect) const
    {
        
        BOOL booln = TRUE;

        SetStatus(DllExports::GdipIsVisibleRectI(nativeGraphics,
                                                 rect.X,
                                                 rect.Y,
                                                 rect.Width,
                                                 rect.Height,
                                                 &booln));
        return booln;
    }

    BOOL IsVisible(IN REAL x,
                   IN REAL y) const
    {
        return IsVisible(PointF(x, y));
    }

    BOOL IsVisible(IN const PointF& point) const
    {
        BOOL booln = FALSE;

        SetStatus(DllExports::GdipIsVisiblePoint(nativeGraphics,
                                                 point.X,
                                                 point.Y,
                                                 &booln));

        return booln;
    }

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height) const
    {
        return IsVisible(RectF(x, y, width, height));
    }

    BOOL IsVisible(IN const RectF& rect) const
    {
        BOOL booln = TRUE;

        SetStatus(DllExports::GdipIsVisibleRect(nativeGraphics,
                                                rect.X,
                                                rect.Y,
                                                rect.Width,
                                                rect.Height,
                                                &booln));
        return booln;
    }

    /**
     * Save/restore graphics state
     */
    GraphicsState Save() const
    {
        GraphicsState gstate;

        SetStatus(DllExports::GdipSaveGraphics(nativeGraphics, &gstate));

        return gstate;
    }

    Status Restore(IN GraphicsState gstate)
    {
        return SetStatus(DllExports::GdipRestoreGraphics(nativeGraphics,
                                                         gstate));
    }

    /**
     * Begin and end container drawing
     */
    GraphicsContainer BeginContainer(IN const RectF &dstrect,
                                     IN const RectF &srcrect,
                                     IN Unit         unit)
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainer(nativeGraphics, &dstrect,
                                                 &srcrect, unit, &state));

        return state;
    }

    /**
     * Begin and end container drawing
     */
    GraphicsContainer BeginContainer(IN const Rect    &dstrect,
                                     IN const Rect    &srcrect,
                                     IN Unit           unit)
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainerI(nativeGraphics, &dstrect,
                                                  &srcrect, unit, &state));

        return state;
    }

    GraphicsContainer BeginContainer()
    {
        GraphicsContainer state;

        SetStatus(DllExports::GdipBeginContainer2(nativeGraphics, &state));

        return state;
    }

    Status EndContainer(IN GraphicsContainer state)
    {
        return SetStatus(DllExports::GdipEndContainer(nativeGraphics, state));
    }

    // only valid when recording metafiles
    Status AddMetafileComment(IN const BYTE * data,
                              IN UINT sizeData)
    {
        return SetStatus(DllExports::GdipComment(nativeGraphics, sizeData, data));
    }

    /**
     * Get/SetLayout
     * Support for Middle East localization (right-to-left mirroring)
     */
    GraphicsLayout GetLayout() const
    {
        GraphicsLayout layout;

        SetStatus(DllExports::GdipGetGraphicsLayout(nativeGraphics, &layout));

        return layout;
    }

    Status SetLayout(IN const GraphicsLayout layout)
    {
        SetStatus(DllExports::GdipSetGraphicsLayout(nativeGraphics, layout));
    }

    static HPALETTE GetHalftonePalette()
    {
        return DllExports::GdipCreateHalftonePalette();
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:
    Graphics(const Graphics& graphics)
    {
        graphics;
        SetStatus(NotImplemented);
    }

    Graphics& operator=(const Graphics& graphics)
    {
        graphics;
        SetStatus(NotImplemented);
        return *this;
    }

    Graphics(GpGraphics* graphics)
    {
        lastResult = Ok;
        SetNativeGraphics(graphics);
    }

    VOID SetNativeGraphics(GpGraphics *graphics)
    {
        this->nativeGraphics = graphics;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    // Methods necessary to subclass Graphics for extension test.

    GpGraphics* GetNativeGraphics()
    {
        return this->nativeGraphics;
    }

    GpPen* GetNativePen(const Pen* pen)
    {
        return pen->nativePen;
    }

protected:
    GpGraphics* nativeGraphics;
    mutable Status lastResult;

};

//----------------------------------------------------------------------------
// Extra implementation of GraphicsPath methods that use Graphics
//----------------------------------------------------------------------------

/**
 * Get the bounds of the path object with the given transform.
 * This is not always the tightest bounds.
 */

inline Status
GraphicsPath::GetBounds(
    OUT RectF* bounds, 
    IN const Matrix* matrix,
    IN const Pen* pen) const 
{
    GpMatrix* nativeMatrix = NULL;
    GpPen* nativePen = NULL;

    if (matrix)
        nativeMatrix = matrix->nativeMatrix;

    if (pen)
        nativePen = pen->nativePen;

    return SetStatus(DllExports::GdipGetPathWorldBounds(nativePath, bounds,
                                                   nativeMatrix, nativePen));
}

// integer version
inline Status
GraphicsPath::GetBounds(
    OUT Rect* bounds,
    IN const Matrix* matrix,
    IN const Pen* pen
) const
{
    GpMatrix* nativeMatrix = NULL;
    GpPen* nativePen = NULL;

    if (matrix)
        nativeMatrix = matrix->nativeMatrix;

    if (pen)
        nativePen = pen->nativePen;

    return SetStatus(DllExports::GdipGetPathWorldBoundsI(nativePath, bounds,
                                                    nativeMatrix, nativePen));
}

//----------------------------------------------------------------------------
// Hit testing operations
//----------------------------------------------------------------------------

inline BOOL
GraphicsPath::IsVisible(
    IN REAL x, 
    IN REAL y, 
    IN const Graphics* g) const
{
   BOOL booln = FALSE;

   GpGraphics* nativeGraphics = NULL;

   if (g)
       nativeGraphics = g->nativeGraphics;

   SetStatus(DllExports::GdipIsVisiblePathPoint(nativePath,
                                                x, y, nativeGraphics,
                                                &booln));
   return booln;
}

inline BOOL
GraphicsPath::IsVisible(
    IN INT x, 
    IN INT y, 
    IN const Graphics* g) const
{
   BOOL booln = FALSE;

   GpGraphics* nativeGraphics = NULL;

   if (g)
       nativeGraphics = g->nativeGraphics;

   SetStatus(DllExports::GdipIsVisiblePathPointI(nativePath,
                                                 x, y, nativeGraphics,
                                                 &booln));
   return booln;
}

inline BOOL
GraphicsPath::IsOutlineVisible(
    IN REAL x, 
    IN REAL y, 
    IN const Pen* pen,
    IN const Graphics* g) const
{
    BOOL booln = FALSE;

    GpGraphics* nativeGraphics = NULL;
    GpPen* nativePen = NULL;

    if(g)
        nativeGraphics = g->nativeGraphics;
    if(pen)
        nativePen = pen->nativePen;

    SetStatus(DllExports::GdipIsOutlineVisiblePathPoint(nativePath,
                                                        x, y, nativePen, nativeGraphics,
                                                        &booln));
    return booln;
}

inline BOOL
GraphicsPath::IsOutlineVisible(
    IN INT x, 
    IN INT y, 
    IN const Pen* pen,
    IN const Graphics* g) const
{
    BOOL booln = FALSE;

    GpGraphics* nativeGraphics = NULL;
    GpPen* nativePen = NULL;

    if(g)
        nativeGraphics = g->nativeGraphics;
    if(pen)
        nativePen = pen->nativePen;

    SetStatus(DllExports::GdipIsOutlineVisiblePathPointI(nativePath,
                                                         x, y, nativePen, nativeGraphics,
                                                         &booln));
    return booln;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusheaders.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusHeaders.hpp
*
* Abstract:
*
*   GDI+ Native C++ public header file
*
* Revision History:
*
*   03/03/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSHEADERS_H
#define _GDIPLUSHEADERS_H

//--------------------------------------------------------------------------
// Abstract base class for regions
//--------------------------------------------------------------------------

//  Include the class declarations here and have inline class implementation
//  in separate file to avoid circular references.

class Region : public GdiplusBase
{
public:
    friend class Graphics;

    Region();
    Region(IN const RectF& rect);
    Region(IN const Rect& rect);
    Region(IN const GraphicsPath* path);
    Region(IN const BYTE* regionData, IN INT size);
    Region(IN HRGN hRgn);
    static Region* FromHRGN(IN HRGN hRgn);

    ~Region();
    Region* Clone() const;

    Status MakeInfinite();
    Status MakeEmpty();

    // Get the size of the buffer needed for the GetData method
    UINT GetDataSize() const;

    // buffer     - where to put the data
    // bufferSize - how big the buffer is (should be at least as big as GetDataSize())
    // sizeFilled - if not NULL, this is an OUT param that says how many bytes
    //              of data were written to the buffer.
    Status GetData(OUT BYTE* buffer,
                   IN UINT bufferSize,
                   OUT UINT* sizeFilled = NULL) const;

    Status Intersect(IN const Rect& rect);
    Status Intersect(IN const RectF& rect);
    Status Intersect(IN const GraphicsPath* path);
    Status Intersect(IN const Region* region);
    Status Union(IN const Rect& rect);
    Status Union(IN const RectF& rect);
    Status Union(IN const GraphicsPath* path);
    Status Union(IN const Region* region);
    Status Xor(IN const Rect& rect);
    Status Xor(IN const RectF& rect);
    Status Xor(IN const GraphicsPath* path);
    Status Xor(IN const Region* region);
    Status Exclude(IN const Rect& rect);
    Status Exclude(IN const RectF& rect);
    Status Exclude(IN const GraphicsPath* path);
    Status Exclude(IN const Region* region);
    Status Complement(IN const Rect& rect);
    Status Complement(IN const RectF& rect);
    Status Complement(IN const GraphicsPath* path);
    Status Complement(IN const Region* region);
    Status Translate(IN REAL dx,
                     IN REAL dy);
    Status Translate(IN INT dx,
                     IN INT dy);
    Status Transform(IN const Matrix* matrix);

    Status GetBounds(OUT Rect* rect,
                     IN const Graphics* g) const;

    Status GetBounds(OUT RectF* rect,
                     IN const Graphics* g) const;

    HRGN   GetHRGN  (IN const Graphics * g) const;

    BOOL IsEmpty(IN const Graphics *g) const;
    BOOL IsInfinite(IN const Graphics *g) const;

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(Point(x, y), g);
    }

    BOOL IsVisible(IN const Point& point,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(PointF(x, y), g);
    }

    BOOL IsVisible(IN const PointF& point,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN INT x,
                   IN INT y,
                   IN INT width,
                   IN INT height,
                   IN const Graphics* g) const
    {
        return IsVisible(Rect(x, y, width, height), g);
    }

    BOOL IsVisible(IN const Rect& rect,
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN REAL x,
                   IN REAL y,
                   IN REAL width,
                   IN REAL height,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(RectF(x, y, width, height), g);
    }

    BOOL IsVisible(IN const RectF& rect,
                   IN const Graphics* g = NULL) const;

    BOOL Equals(IN const Region* region,
                IN const Graphics* g) const;

    UINT GetRegionScansCount(IN const Matrix* matrix) const;
    Status GetRegionScans(IN const Matrix* matrix,
                          OUT RectF* rects,
                          OUT INT* count) const;
    Status GetRegionScans(IN const Matrix* matrix,
                          OUT Rect*  rects,
                          OUT INT* count) const;
    Status GetLastStatus() const;

protected:
    Region(const Region &region)
    {
        region; // reference parameter
        SetStatus(NotImplemented);
    }

    Region& operator=(const Region &region)
    {
       region;  // reference parameter
       SetStatus(NotImplemented);
       return *this;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    Region(GpRegion* nativeRegion);

    VOID SetNativeRegion(GpRegion* nativeRegion);

protected:
    GpRegion* nativeRegion;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// Abstract base class for FontFamily
//--------------------------------------------------------------------------

class FontFamily : public GdiplusBase
{
public:
    friend class Font;
    friend class Graphics;
    friend class GraphicsPath;
    friend class FontCollection;

    FontFamily();

    FontFamily(
        IN const WCHAR          *name,
        IN const FontCollection *fontCollection = NULL
    );

    ~FontFamily();

    static const FontFamily *GenericSansSerif();
    static const FontFamily *GenericSerif();
    static const FontFamily *GenericMonospace();

    Status GetFamilyName(
        OUT WCHAR        name[LF_FACESIZE],
        IN LANGID        language = 0
    ) const;

//  Copy operator
    FontFamily * Clone() const;

    BOOL    IsAvailable() const
    {
        return (nativeFamily != NULL);
    };

    BOOL    IsStyleAvailable(IN INT style) const;

    UINT16  GetEmHeight     (IN INT style) const;
    UINT16  GetCellAscent   (IN INT style) const;
    UINT16  GetCellDescent  (IN INT style) const;
    UINT16  GetLineSpacing  (IN INT style) const;

    ///////////////////////////////////////////////////////////

    Status GetLastStatus() const;

protected:
    Status SetStatus(Status status) const;

    // private constructor for copy
    FontFamily(GpFontFamily * nativeFamily, Status status);

///////////////////////////////////////
//  Data members
protected:

    GpFontFamily    *nativeFamily;
    mutable Status   lastResult;
};

static FontFamily *GenericSansSerifFontFamily = NULL;
static FontFamily *GenericSerifFontFamily     = NULL;
static FontFamily *GenericMonospaceFontFamily = NULL;

static BYTE GenericSansSerifFontFamilyBuffer[sizeof(FontFamily)] = {0};
static BYTE GenericSerifFontFamilyBuffer    [sizeof(FontFamily)] = {0};
static BYTE GenericMonospaceFontFamilyBuffer[sizeof(FontFamily)] = {0};


//--------------------------------------------------------------------------
// Abstract base class for fonts
//--------------------------------------------------------------------------

class Font : public GdiplusBase
{
public:
    friend class Graphics;

    Font(IN HDC hdc);
    Font(IN HDC hdc,
         IN const LOGFONTA* logfont);
    Font(IN HDC hdc,
         IN const LOGFONTW* logfont);

    Font(
        IN const FontFamily * family,
        IN REAL         emSize,
        IN INT          style   = FontStyleRegular,
        IN Unit         unit    = UnitPoint
    );

    Font(
        IN const WCHAR *           familyName,
        IN REAL                    emSize,
        IN INT                     style   = FontStyleRegular,
        IN Unit                    unit    = UnitPoint,
        IN const FontCollection *  fontCollection = NULL
    );

    Status GetLogFontA(IN const Graphics* g,
                       OUT  LOGFONTA * logfontA) const;
    Status GetLogFontW(IN const Graphics* g,
                       OUT LOGFONTW * logfontW) const;

    Font* Clone() const;
    ~Font();
    BOOL        IsAvailable()   const;
    INT         GetStyle()      const;
    REAL        GetSize()       const;
    Unit        GetUnit()       const;
    Status      GetLastStatus() const;
    REAL        GetHeight(IN const Graphics *graphics = NULL) const;

    Status GetFamily(OUT FontFamily *family) const;

protected:
    Font(GpFont* font, Status status);
    VOID SetNativeFont(GpFont *Font);
    Status SetStatus(Status status) const;

protected:
    /*
     * handle to native line texture object
     */

    GpFont* nativeFont;
    mutable Status lastResult;
};

//--------------------------------------------------------------------------
// Abstract base classes for font collections
//--------------------------------------------------------------------------

class FontCollection : public GdiplusBase
{
public:
    friend class FontFamily;

    FontCollection();
    virtual ~FontCollection();

    INT GetFamilyCount() const;     // number of enumerable families in the collection

    Status GetFamilies(             // enumerate the fonts in a collection
        IN INT           numSought,
        OUT FontFamily * gpfamilies,
        OUT INT        * numFound
    ) const;

    Status GetLastStatus() const;

protected:
    Status SetStatus(Status status) const ;

    GpFontCollection *nativeFontCollection;
    mutable Status    lastResult;
};


class InstalledFontCollection : public FontCollection
{
public:
    InstalledFontCollection();
    ~InstalledFontCollection();

protected:
    // we will make these functions public in version 2
    Status InstallFontFile(IN const WCHAR* filename);
    Status UninstallFontFile(IN const WCHAR* filename);
    Status SetStatus(Status status) const ;
};


class PrivateFontCollection : public FontCollection
{
public:
    PrivateFontCollection();
    ~PrivateFontCollection();

    Status AddFontFile(IN const WCHAR* filename);
    Status AddMemoryFont(IN const VOID* memory,
                         IN INT length);
};


//--------------------------------------------------------------------------
// Abstract base class for bitmap image and metafile
//--------------------------------------------------------------------------

// !!! Note:
//  Include the class declarations here and have the inline class
//  implementation in a separate file.  This is done to resolve a
//  circular dependency since one of the Bitmap methods needs to
//  access the private member nativeGraphics of the Graphics object.

class Image : public GdiplusBase
{
public:
    friend class Brush;
    friend class TextureBrush;
    friend class Graphics;

#ifndef DCR_USE_NEW_140782
    Image(
        IN const WCHAR* filename
    );
    
    Image(
        IN IStream* stream
    );
    
    static Image* FromFile(
        IN const WCHAR* filename
    );
    
    static Image* FromStream(
        IN IStream* stream
    );
#else
    Image(
        IN const WCHAR* filename, 
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    Image(
        IN IStream* stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    static Image* FromFile(
        IN const WCHAR* filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    static Image* FromStream(
        IN IStream* stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
#endif    
        
    virtual ~Image();
    virtual Image* Clone();

    Status Save(IN const WCHAR* filename,
                IN const CLSID* clsidEncoder,
                IN const EncoderParameters *encoderParams = NULL);
    Status Save(IN IStream* stream,
                IN const CLSID* clsidEncoder,
                IN const EncoderParameters *encoderParams = NULL);
    Status SaveAdd(IN const EncoderParameters* encoderParams);
    Status SaveAdd(IN Image* newImage,
                   IN const EncoderParameters* encoderParams);

    ImageType GetType() const;
    Status GetPhysicalDimension(OUT SizeF* size);
    Status GetBounds(OUT RectF* srcRect,
                     OUT Unit* srcUnit);

    UINT GetWidth();
    UINT GetHeight();
    REAL GetHorizontalResolution();
    REAL GetVerticalResolution();
    UINT GetFlags();
    Status GetRawFormat(OUT GUID *format);
    PixelFormat GetPixelFormat();

    INT GetPaletteSize();
    Status GetPalette(OUT ColorPalette* palette,
                      IN INT size);
    Status SetPalette(IN const ColorPalette* palette);

    Image* GetThumbnailImage(IN UINT thumbWidth,
                             IN UINT thumbHeight,
                             IN GetThumbnailImageAbort callback = NULL,
                             IN VOID* callbackData = NULL);
    UINT GetFrameDimensionsCount();
    Status GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                  IN UINT count);
    UINT GetFrameCount(IN const GUID* dimensionID);
    Status SelectActiveFrame(IN const GUID* dimensionID,
                             IN UINT frameIndex);
    UINT GetPropertyCount();
    Status GetPropertyIdList(IN UINT numOfProperty,
                             OUT PROPID* list);
    UINT GetPropertyItemSize(IN PROPID propId);
    Status GetPropertyItem(IN PROPID propId,
                           IN UINT propSize,
                           OUT PropertyItem* buffer);
    Status GetPropertySize(OUT UINT* totalBufferSize,
                           OUT UINT* numProperties);
    Status GetAllPropertyItems(IN UINT totalBufferSize,
                               IN UINT numProperties,
                               OUT PropertyItem* allItems);
    Status RemovePropertyItem(IN PROPID propId);
    Status SetPropertyItem(IN const PropertyItem* item);

    UINT  GetEncoderParameterListSize(IN const CLSID* clsidEncoder);
    Status GetEncoderParameterList(IN const CLSID* clsidEncoder,
                                   IN UINT size,
                                   OUT EncoderParameters* buffer);

    // Support for Middle East localization (right-to-left mirroring)
    ImageLayout GetLayout() const;
    Status SetLayout(IN const ImageLayout layout);

    Status GetLastStatus() const;

protected:

    Image() {}

    Image(GpImage *nativeImage, Status status);

    VOID SetNativeImage(GpImage* nativeImage);

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

    GpImage* nativeImage;
    mutable Status lastResult;
    mutable Status loadStatus;

protected:

    // Disable copy constructor and assignment operator

    Image(IN const Image& C);
    Image& operator=(IN const Image& C);
};

class Bitmap : public Image
{
public:
    friend class Image;
    friend class CachedBitmap;

    Bitmap(
        IN const WCHAR *filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    Bitmap(
        IN IStream *stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    static Bitmap* FromFile(
        IN const WCHAR *filename,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    static Bitmap* FromStream(
        IN IStream *stream,
        IN BOOL useEmbeddedColorManagement = FALSE
    );
    
    Bitmap(IN INT width,
           IN INT height,
           IN INT stride, PixelFormat format,
           IN BYTE* scan0);
    Bitmap(IN INT width,
           IN INT height,
           IN PixelFormat format = PixelFormat32bppARGB);
    Bitmap(IN INT width,
           IN INT height,
           IN  Graphics* target);

    Bitmap* Clone(IN const Rect& rect,
                  IN PixelFormat format);
    Bitmap* Clone(IN INT x,
                  IN INT y,
                  IN INT width,
                  IN INT height,
                  IN PixelFormat format);
    Bitmap* Clone(IN const RectF& rect,
                  IN PixelFormat format);
    Bitmap* Clone(IN REAL x,
                  IN REAL y,
                  IN REAL width,
                  IN REAL height,
                  IN PixelFormat format);

    Status LockBits(IN const Rect& rect,
                    IN UINT flags,
                    IN PixelFormat format,
                    OUT BitmapData* lockedBitmapData);
    Status UnlockBits(IN BitmapData* lockedBitmapData);
    Status GetPixel(IN INT x,
                    IN INT y,
                    OUT Color *color);
    Status SetPixel(IN INT x,
                    IN INT y,
                    IN const Color &color);
    Status SetResolution(IN REAL xdpi,
                         IN REAL ydpi);

    // GDI interop:

    Bitmap(IN IDirectDrawSurface7* surface);
    Bitmap(IN const BITMAPINFO* gdiBitmapInfo,
           IN VOID* gdiBitmapData);
    Bitmap(IN HBITMAP hbm,
           IN HPALETTE hpal);
    Bitmap(IN HICON hicon);
    Bitmap(IN HINSTANCE hInstance,
           IN const WCHAR * bitmapName);
    static Bitmap* FromDirectDrawSurface7(IN IDirectDrawSurface7* surface);
    static Bitmap* FromBITMAPINFO(IN const BITMAPINFO* gdiBitmapInfo,
                                  IN VOID* gdiBitmapData);
    static Bitmap* FromHBITMAP(IN HBITMAP hbm,
                               IN HPALETTE hpal);
    static Bitmap* FromHICON(IN HICON hicon);
    static Bitmap* FromResource(IN HINSTANCE hInstance,
                                IN const WCHAR * bitmapName);

    Status GetHBITMAP(IN const Color& colorBackground,
                      OUT HBITMAP *hbmReturn);
    Status GetHICON(HICON *hicon);

protected:
    Bitmap(GpBitmap *nativeBitmap);
};

class CustomLineCap : public GdiplusBase
{
public:
    friend class Pen;

    CustomLineCap(
        IN const GraphicsPath* fillPath,
        IN const GraphicsPath* strokePath,
        IN LineCap baseCap = LineCapFlat,
        IN REAL baseInset = 0
        );
    virtual ~CustomLineCap();

    CustomLineCap* Clone() const;

    Status SetStrokeCap(IN LineCap strokeCap)
    {
        // This changes both start and and caps.

        return SetStrokeCaps(strokeCap, strokeCap);
    }

    Status SetStrokeCaps(IN LineCap startCap,
                         IN LineCap endCap);
    Status GetStrokeCaps(OUT LineCap* startCap,
                         OUT LineCap* endCap) const;
    Status SetStrokeJoin(IN LineJoin lineJoin);
    LineJoin GetStrokeJoin() const;
    Status SetBaseCap(IN LineCap baseCap);
    LineCap GetBaseCap() const;
    Status SetBaseInset(IN REAL inset);
    REAL GetBaseInset() const;
    Status SetWidthScale(IN REAL widthScale);
    REAL GetWidthScale() const;

protected:
    CustomLineCap();

    CustomLineCap(const CustomLineCap& customLineCap)
    {
        customLineCap;
        SetStatus(NotImplemented);
    }

    CustomLineCap& operator=(const CustomLineCap& customLineCap)
    {
        customLineCap;
        SetStatus(NotImplemented);
        return *this;
    }

    CustomLineCap(GpCustomLineCap* nativeCap, Status status)
    {
        lastResult = status;
        SetNativeCap(nativeCap);
    }

    VOID SetNativeCap(GpCustomLineCap* nativeCap)
    {
        this->nativeCap = nativeCap;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpCustomLineCap* nativeCap;
    mutable Status lastResult;
};

class CachedBitmap : public GdiplusBase
{
    friend Graphics;

public:
    CachedBitmap(IN Bitmap *bitmap,
                 IN Graphics *graphics);
    virtual ~CachedBitmap();

    Status GetLastStatus() const;

protected:
    GpCachedBitmap *nativeCachedBitmap;
    mutable Status lastResult;
};

#endif  // !_GDIPLUSHEADERS.HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusimaging.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   GdiplusImaging.h
*
* Abstract:
*
*   GUIDs defined and used by the imaging library
*
* Revision History:
*
*   03/28/2000 ericvan
*       Created it.
*
\**************************************************************************/
#ifndef _GDIPLUSIMAGING_H
#define _GDIPLUSIMAGING_H

//---------------------------------------------------------------------------
// Image file format identifiers
//---------------------------------------------------------------------------

DEFINE_GUID(ImageFormatUndefined, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatMemoryBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatBMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatEMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatWMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatJPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatPNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatGIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatTIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatEXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
#ifndef DCR_USE_NEW_140855
DEFINE_GUID(ImageFormatPhotoCD, 0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(ImageFormatFlashPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
#endif
DEFINE_GUID(ImageFormatIcon, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//---------------------------------------------------------------------------
// Predefined multi-frame dimension IDs
//---------------------------------------------------------------------------

DEFINE_GUID(FrameDimensionTime, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FrameDimensionResolution, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FrameDimensionPage, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//---------------------------------------------------------------------------
// Property sets
//---------------------------------------------------------------------------

DEFINE_GUID(FormatIDImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FormatIDJpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

#ifndef DCR_USE_NEW_140855
//---------------------------------------------------------------------------
// Decoder parameter sets
//---------------------------------------------------------------------------
DEFINE_GUID(DecoderTransColor, 0xb7a98c8f,0xdce7,0x457d,0xbf,0xa5,0xce,0xa7,0x1b,0xd1,0x4d,0xd6);
DEFINE_GUID(DecoderTransRange, 0xabeed189,0xd988,0x4d03,0xb4,0x25,0x57,0x10,0x55,0xc7,0x6a,0xd1);
DEFINE_GUID(DecoderOutputChannel, 0x2ff8f51e,0x724d,0x45fe,0x86,0xce,0x17,0x77,0xa0,0x56,0xda,0x60);
DEFINE_GUID(DecoderIconRes, 0x5c656eec,0xe94f,0x45ba,0xa6,0xf6,0x10,0x62,0xe8,0x5f,0x4a,0x7f);
#endif

//---------------------------------------------------------------------------
// Encoder parameter sets
//---------------------------------------------------------------------------

DEFINE_GUID(EncoderCompression, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(EncoderColorDepth, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(EncoderScanMethod, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(EncoderVersion, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(EncoderRenderMethod, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(EncoderQuality, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(EncoderTransformation,0x8d0eb2d1,0xa58e,0x4ea8,0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9);
DEFINE_GUID(EncoderLuminanceTable,0xedb33bce,0x0266,0x4a77,0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17);
DEFINE_GUID(EncoderChrominanceTable,0xf2e455dc,0x09b3,0x4316,0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c);
DEFINE_GUID(EncoderSaveFlag,0x292266fc,0xac40,0x47bf,0x8c, 0xfc, 0xa8, 0x5b, 0x89, 0xa6, 0x55, 0xde);

//--------------------------------------------------------------------------
// ImageCodecInfo structure
//--------------------------------------------------------------------------

class ImageCodecInfo
{
public:          
    CLSID Clsid;
    GUID  FormatID;
    const WCHAR* CodecName;
    const WCHAR* DllName;
    const WCHAR* FormatDescription;
    const WCHAR* FilenameExtension;
    const WCHAR* MimeType;
    DWORD Flags;
    DWORD Version;
    DWORD SigCount;
    DWORD SigSize;
    const BYTE* SigPattern;
    const BYTE* SigMask;
};

//--------------------------------------------------------------------------
// Information flags about image codecs
//--------------------------------------------------------------------------

enum ImageCodecFlags
{
    ImageCodecFlagsEncoder            = 0x00000001,
    ImageCodecFlagsDecoder            = 0x00000002,
    ImageCodecFlagsSupportBitmap      = 0x00000004,
    ImageCodecFlagsSupportVector      = 0x00000008,
    ImageCodecFlagsSeekableEncode     = 0x00000010,
    ImageCodecFlagsBlockingDecode     = 0x00000020,

    ImageCodecFlagsBuiltin            = 0x00010000,
    ImageCodecFlagsSystem             = 0x00020000,
    ImageCodecFlagsUser               = 0x00040000
};

//---------------------------------------------------------------------------
// Access modes used when calling Image::LockBits
//---------------------------------------------------------------------------

enum ImageLockMode
{
    ImageLockModeRead        = 0x0001,
    ImageLockModeWrite       = 0x0002,
    ImageLockModeUserInputBuf= 0x0004
};

//---------------------------------------------------------------------------
// Information about image pixel data
//---------------------------------------------------------------------------

class BitmapData
{
public:
    UINT Width;
    UINT Height;
    INT Stride;
    PixelFormat PixelFormat;
    VOID* Scan0;
    UINT_PTR Reserved;
};

//---------------------------------------------------------------------------
// Image flags
//---------------------------------------------------------------------------

enum ImageFlags
{
    ImageFlagsNone                = 0,

    // Low-word: shared with SINKFLAG_x

    ImageFlagsScalable            = 0x0001,
    ImageFlagsHasAlpha            = 0x0002,
    ImageFlagsHasTranslucent      = 0x0004,
    ImageFlagsPartiallyScalable   = 0x0008,

    // Low-word: color space definition

    ImageFlagsColorSpaceRGB       = 0x0010,
    ImageFlagsColorSpaceCMYK      = 0x0020,
    ImageFlagsColorSpaceGRAY      = 0x0040,
    ImageFlagsColorSpaceYCBCR     = 0x0080,
    ImageFlagsColorSpaceYCCK      = 0x0100,
 
    // Low-word: image size info

    ImageFlagsHasRealDPI          = 0x1000,
    ImageFlagsHasRealPixelSize    = 0x2000,

    // High-word

    ImageFlagsReadOnly            = 0x00010000,
    ImageFlagsCaching             = 0x00020000
};

//---------------------------------------------------------------------------
// Encoder Parameter structure
//---------------------------------------------------------------------------
class EncoderParameter
{
public:
    GUID    Guid;               // GUID of the parameter
    ULONG   NumberOfValues;     // Number of the parameter values
    ULONG   Type;               // Value type, like ValueTypeLONG  etc.
    VOID*   Value;              // A pointer to the parameter values
};

//---------------------------------------------------------------------------
// Encoder Parameters structure
//---------------------------------------------------------------------------
class EncoderParameters
{
public:
    UINT Count;                      // Number of parameters in this structure
    EncoderParameter Parameter[1];   // Parameter values
};

//---------------------------------------------------------------------------
// Property Item
//---------------------------------------------------------------------------
class PropertyItem
{
public:
    PROPID  id;                 // ID of this property
    ULONG   length;             // Length of the property value, in bytes
    WORD    type;               // Type of the value, as one of TAG_TYPE_XXX
                                // defined above
    VOID*   value;              // property value
};

#ifdef DCR_USE_NEW_140857
//---------------------------------------------------------------------------
// Image property types 
//---------------------------------------------------------------------------
#define PropertyTagTypeByte        1
#define PropertyTagTypeASCII       2
#define PropertyTagTypeShort       3
#define PropertyTagTypeLong        4
#define PropertyTagTypeRational    5
#define PropertyTagTypeUndefined   7
#define PropertyTagTypeSLONG       9
#define PropertyTagTypeSRational  10
#endif

//---------------------------------------------------------------------------
// Image property ID tags
//---------------------------------------------------------------------------

#define PropertyTagExifIFD             0x8769
#define PropertyTagGpsIFD              0x8825

#define PropertyTagNewSubfileType      0x00FE
#define PropertyTagSubfileType         0x00FF
#define PropertyTagImageWidth          0x0100
#define PropertyTagImageHeight         0x0101
#define PropertyTagBitsPerSample       0x0102
#define PropertyTagCompression         0x0103
#define PropertyTagPhotometricInterp   0x0106
#define PropertyTagThreshHolding       0x0107
#define PropertyTagCellWidth           0x0108
#define PropertyTagCellHeight          0x0109
#define PropertyTagFillOrder           0x010A
#define PropertyTagDocumentName        0x010D
#define PropertyTagImageDescription    0x010E
#define PropertyTagEquipMake           0x010F
#define PropertyTagEquipModel          0x0110
#define PropertyTagStripOffsets        0x0111
#define PropertyTagOrientation         0x0112
#define PropertyTagSamplesPerPixel     0x0115
#define PropertyTagRowsPerStrip        0x0116
#define PropertyTagStripBytesCount     0x0117
#define PropertyTagMinSampleValue      0x0118
#define PropertyTagMaxSampleValue      0x0119
#define PropertyTagXResolution         0x011A   // Image resolution in width direction
#define PropertyTagYResolution         0x011B   // Image resolution in height direction
#define PropertyTagPlanarConfig        0x011C   // Image data arrangement
#define PropertyTagPageName            0x011D
#define PropertyTagXPosition           0x011E
#define PropertyTagYPosition           0x011F
#define PropertyTagFreeOffset          0x0120
#define PropertyTagFreeByteCounts      0x0121
#define PropertyTagGrayResponseUnit    0x0122
#define PropertyTagGrayResponseCurve   0x0123
#define PropertyTagT4Option            0x0124
#define PropertyTagT6Option            0x0125
#define PropertyTagResolutionUnit      0x0128   // Unit of X and Y resolution
#define PropertyTagPageNumber          0x0129
#define PropertyTagTransferFuncition   0x012D
#define PropertyTagSoftwareUsed        0x0131
#define PropertyTagDateTime            0x0132
#define PropertyTagArtist              0x013B
#define PropertyTagHostComputer        0x013C
#define PropertyTagPredictor           0x013D
#define PropertyTagWhitePoint          0x013E
#define PropertyTagPrimaryChromaticities 0x013F
#define PropertyTagColorMap            0x0140
#define PropertyTagHalftoneHints       0x0141
#define PropertyTagTileWidth           0x0142
#define PropertyTagTileLength          0x0143
#define PropertyTagTileOffset          0x0144
#define PropertyTagTileByteCounts      0x0145
#define PropertyTagInkSet              0x014C
#define PropertyTagInkNames            0x014D
#define PropertyTagNumberOfInks        0x014E
#define PropertyTagDotRange            0x0150
#define PropertyTagTargetPrinter       0x0151
#define PropertyTagExtraSamples        0x0152
#define PropertyTagSampleFormat        0x0153
#define PropertyTagSMinSampleValue     0x0154
#define PropertyTagSMaxSampleValue     0x0155
#define PropertyTagTransferRange       0x0156

#define PropertyTagJPEGProc            0x0200
#define PropertyTagJPEGInterFormat     0x0201
#define PropertyTagJPEGInterLength     0x0202
#define PropertyTagJPEGRestartInterval 0x0203
#define PropertyTagJPEGLosslessPredictors  0x0205
#define PropertyTagJPEGPointTransforms     0x0206
#define PropertyTagJPEGQTables         0x0207
#define PropertyTagJPEGDCTables        0x0208
#define PropertyTagJPEGACTables        0x0209

#define PropertyTagYCbCrCoefficients   0x0211
#define PropertyTagYCbCrSubsampling    0x0212
#define PropertyTagYCbCrPositioning    0x0213
#define PropertyTagREFBlackWhite       0x0214

#define PropertyTagICCProfile          0x0300
#define PropertyTagGamma               0x0301
#define PropertyTagICCProfileDescriptor 0x0302
#define PropertyTagSRGBRenderingIntent 0x0303

#define PropertyTagImageTitle          0x0320
#define PropertyTagCopyright           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define PropertyTagResolutionXUnit           0x5001
#define PropertyTagResolutionYUnit           0x5002
#define PropertyTagResolutionXLengthUnit     0x5003
#define PropertyTagResolutionYLengthUnit     0x5004
#define PropertyTagPrintFlags                0x5005
#define PropertyTagPrintFlagsVersion         0x5006
#define PropertyTagPrintFlagsCrop            0x5007
#define PropertyTagPrintFlagsBleedWidth      0x5008
#define PropertyTagPrintFlagsBleedWidthScale 0x5009
#define PropertyTagHalftoneLPI               0x500A
#define PropertyTagHalftoneLPIUnit           0x500B
#define PropertyTagHalftoneDegree            0x500C
#define PropertyTagHalftoneShape             0x500D
#define PropertyTagHalftoneMisc              0x500E
#define PropertyTagHalftoneScreen            0x500F
#define PropertyTagJPEGQuality               0x5010
#define PropertyTagGridSize                  0x5011
#define PropertyTagThumbnailFormat           0x5012  // 1 = JPEG, 0 = RAW RGB
#define PropertyTagThumbnailWidth            0x5013
#define PropertyTagThumbnailHeight           0x5014
#define PropertyTagThumbnailColorDepth       0x5015
#define PropertyTagThumbnailPlanes           0x5016
#define PropertyTagThumbnailRawBytes         0x5017
#define PropertyTagThumbnailSize             0x5018
#define PropertyTagThumbnailCompressedSize   0x5019
#define PropertyTagColorTransferFunction     0x501A
#define PropertyTagThumbnailData             0x501B// RAW thumbnail bits in
                                                   // JPEG format or RGB format
                                                   // depends on
                                                   // PropertyTagThumbnailFormat

// Thumbnail related TAGs
                                                
#define PropertyTagThumbnailImageWidth       0x5020  // Thumbnail width
#define PropertyTagThumbnailImageHeight      0x5021  // Thumbnail height
#define PropertyTagThumbnailBitsPerSample    0x5022  // Number of bits per
                                                     // component
#define PropertyTagThumbnailCompression      0x5023  // Compression Scheme
#define PropertyTagThumbnailPhotometricInterp 0x5024 // Pixel composition
#define PropertyTagThumbnailImageDescription 0x5025  // Image Tile
#define PropertyTagThumbnailEquipMake        0x5026  // Manufacturer of Image
                                                     // Input equipment
#define PropertyTagThumbnailEquipModel       0x5027  // Model of Image input
                                                     // equipment
#define PropertyTagThumbnailStripOffsets     0x5028  // Image data location
#define PropertyTagThumbnailOrientation      0x5029  // Orientation of image
#define PropertyTagThumbnailSamplesPerPixel  0x502A  // Number of components
#define PropertyTagThumbnailRowsPerStrip     0x502B  // Number of rows per strip
#define PropertyTagThumbnailStripBytesCount  0x502C  // Bytes per compressed
                                                     // strip
#define PropertyTagThumbnailResolutionX      0x502D  // Resolution in width
                                                     // direction
#define PropertyTagThumbnailResolutionY      0x502E  // Resolution in height
                                                     // direction
#define PropertyTagThumbnailPlanarConfig     0x502F  // Image data arrangement
#define PropertyTagThumbnailResolutionUnit   0x5030  // Unit of X and Y
                                                     // Resolution
#define PropertyTagThumbnailTransferFunction 0x5031  // Transfer function
#define PropertyTagThumbnailSoftwareUsed     0x5032  // Software used
#define PropertyTagThumbnailDateTime         0x5033  // File change date and
                                                     // time
#define PropertyTagThumbnailArtist           0x5034  // Person who created the
                                                     // image
#define PropertyTagThumbnailWhitePoint       0x5035  // White point chromaticity
#define PropertyTagThumbnailPrimaryChromaticities 0x5036 
                                                     // Chromaticities of
                                                     // primaries
#define PropertyTagThumbnailYCbCrCoefficients 0x5037 // Color space transforma-
                                                     // tion coefficients
#define PropertyTagThumbnailYCbCrSubsampling 0x5038  // Subsampling ratio of Y
                                                     // to C
#define PropertyTagThumbnailYCbCrPositioning 0x5039  // Y and C position
#define PropertyTagThumbnailRefBlackWhite    0x503A  // Pair of black and white
                                                     // reference values
#define PropertyTagThumbnailCopyRight        0x503B  // CopyRight holder

#define PropertyTagLuminanceTable            0x5090
#define PropertyTagChrominanceTable          0x5091

#define PropertyTagFrameDelay                0x5100
#define PropertyTagLoopCount                 0x5101

#define PropertyTagPixelUnit         0x5110  // Unit specifier for pixel/unit
#define PropertyTagPixelPerUnitX     0x5111  // Pixels per unit in X
#define PropertyTagPixelPerUnitY     0x5112  // Pixels per unit in Y
#define PropertyTagPaletteHistogram  0x5113  // Palette histogram

// EXIF specific tag

#define PropertyTagExifExposureTime  0x829A
#define PropertyTagExifFNumber       0x829D

#define PropertyTagExifExposureProg  0x8822
#define PropertyTagExifSpectralSense 0x8824
#define PropertyTagExifISOSpeed      0x8827
#define PropertyTagExifOECF          0x8828

#define PropertyTagExifVer            0x9000
#define PropertyTagExifDTOrig         0x9003 // Date & time of original
#define PropertyTagExifDTDigitized    0x9004 // Date & time of digital data generation

#define PropertyTagExifCompConfig     0x9101
#define PropertyTagExifCompBPP        0x9102

#define PropertyTagExifShutterSpeed   0x9201
#define PropertyTagExifAperture       0x9202
#define PropertyTagExifBrightness     0x9203
#define PropertyTagExifExposureBias   0x9204
#define PropertyTagExifMaxAperture    0x9205
#define PropertyTagExifSubjectDist    0x9206
#define PropertyTagExifMeteringMode   0x9207
#define PropertyTagExifLightSource    0x9208
#define PropertyTagExifFlash          0x9209
#define PropertyTagExifFocalLength    0x920A
#define PropertyTagExifMakerNote      0x927C
#define PropertyTagExifUserComment    0x9286
#define PropertyTagExifDTSubsec       0x9290  // Date & Time subseconds
#define PropertyTagExifDTOrigSS       0x9291  // Date & Time original subseconds
#define PropertyTagExifDTDigSS        0x9292  // Date & TIme digitized subseconds

#define PropertyTagExifFPXVer         0xA000
#define PropertyTagExifColorSpace     0xA001
#define PropertyTagExifPixXDim        0xA002
#define PropertyTagExifPixYDim        0xA003
#define PropertyTagExifRelatedWav     0xA004  // related sound file
#define PropertyTagExifInterop        0xA005
#define PropertyTagExifFlashEnergy    0xA20B
#define PropertyTagExifSpatialFR      0xA20C  // Spatial Frequency Response
#define PropertyTagExifFocalXRes      0xA20E  // Focal Plane X Resolution
#define PropertyTagExifFocalYRes      0xA20F  // Focal Plane Y Resolution
#define PropertyTagExifFocalResUnit   0xA210  // Focal Plane Resolution Unit
#define PropertyTagExifSubjectLoc     0xA214
#define PropertyTagExifExposureIndex  0xA215
#define PropertyTagExifSensingMethod  0xA217
#define PropertyTagExifFileSource     0xA300
#define PropertyTagExifSceneType      0xA301
#define PropertyTagExifCfaPattern     0xA302

#define PropertyTagGpsVer             0x0000
#define PropertyTagGpsLatitudeRef     0x0001
#define PropertyTagGpsLatitude        0x0002
#define PropertyTagGpsLongitudeRef    0x0003
#define PropertyTagGpsLongitude       0x0004
#define PropertyTagGpsAltitudeRef     0x0005
#define PropertyTagGpsAltitude        0x0006
#define PropertyTagGpsGpsTime         0x0007
#define PropertyTagGpsGpsSatellites   0x0008
#define PropertyTagGpsGpsStatus       0x0009
#define PropertyTagGpsGpsMeasureMode  0x00A
#define PropertyTagGpsGpsDop          0x000B  // Measurement precision
#define PropertyTagGpsSpeedRef        0x000C
#define PropertyTagGpsSpeed           0x000D
#define PropertyTagGpsTrackRef        0x000E
#define PropertyTagGpsTrack           0x000F
#define PropertyTagGpsImgDirRef       0x0010
#define PropertyTagGpsImgDir          0x0011
#define PropertyTagGpsMapDatum        0x0012
#define PropertyTagGpsDestLatRef      0x0013
#define PropertyTagGpsDestLat         0x0014
#define PropertyTagGpsDestLongRef     0x0015
#define PropertyTagGpsDestLong        0x0016
#define PropertyTagGpsDestBearRef     0x0017
#define PropertyTagGpsDestBear        0x0018
#define PropertyTagGpsDestDistRef     0x0019
#define PropertyTagGpsDestDist        0x001A

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdipluslinecaps.h ===
/**************************************************************************\
* 
* Copyright (c) 2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   APIs for Custom Line Caps
*
* Revision History:
*
*   02/23/2000 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSLINECAPS_H
#define _GDIPLUSLINECAPS_H

inline 
CustomLineCap::CustomLineCap(
    IN const GraphicsPath* fillPath,
    IN const GraphicsPath* strokePath,
    IN LineCap baseCap,
    IN REAL baseInset
    )
{
    nativeCap = NULL;
    GpPath* nativeFillPath = NULL;
    GpPath* nativeStrokePath = NULL;

    if(fillPath)
        nativeFillPath = fillPath->nativePath;
    if(strokePath)
        nativeStrokePath = strokePath->nativePath;

    lastResult = DllExports::GdipCreateCustomLineCap(
                    nativeFillPath, nativeStrokePath,
                    baseCap, baseInset, &nativeCap);
}

inline 
CustomLineCap::CustomLineCap()
{
    // This is used for default constructor for subclasses.
    // So don't create a nativeCap.

    nativeCap = NULL;
    lastResult = Ok;
}

inline 
CustomLineCap::~CustomLineCap()
{
    DllExports::GdipDeleteCustomLineCap(nativeCap);
}

inline Status 
CustomLineCap::SetStrokeCaps(
    IN LineCap startCap, 
    IN LineCap endCap)
{
    return SetStatus(DllExports::GdipSetCustomLineCapStrokeCaps(nativeCap,
                startCap, endCap));
}

inline Status 
CustomLineCap::GetStrokeCaps(
    OUT LineCap* startCap, 
    OUT LineCap* endCap) const
{
    return SetStatus(DllExports::GdipGetCustomLineCapStrokeCaps(nativeCap,
                 startCap, endCap));
}

inline Status 
CustomLineCap::SetStrokeJoin(
    IN LineJoin lineJoin)
{
    return SetStatus(DllExports::GdipSetCustomLineCapStrokeJoin(nativeCap, lineJoin));
}

inline LineJoin 
CustomLineCap::GetStrokeJoin() const
{
    LineJoin lineJoin;

    SetStatus(DllExports::GdipGetCustomLineCapStrokeJoin(nativeCap, &lineJoin));

    return lineJoin;
}

inline Status 
CustomLineCap::SetBaseCap(IN LineCap baseCap)
{
    return SetStatus(DllExports::GdipSetCustomLineCapBaseCap(nativeCap, baseCap));
}

inline LineCap 
CustomLineCap::GetBaseCap() const
{
    LineCap baseCap;
    SetStatus(DllExports::GdipGetCustomLineCapBaseCap(nativeCap, &baseCap));

    return baseCap;
}

inline Status 
CustomLineCap::SetBaseInset(IN REAL inset)
{
    return SetStatus(DllExports::GdipSetCustomLineCapBaseInset(nativeCap, inset));
}

inline REAL 
CustomLineCap::GetBaseInset() const
{
    REAL inset;
    SetStatus(DllExports::GdipGetCustomLineCapBaseInset(nativeCap, &inset));

    return inset;
}


inline Status 
CustomLineCap::SetWidthScale(IN REAL widthScale)
{
    return SetStatus(DllExports::GdipSetCustomLineCapWidthScale(nativeCap, widthScale));
}

inline REAL 
CustomLineCap::GetWidthScale() const
{
    REAL widthScale;
    SetStatus(DllExports::GdipGetCustomLineCapWidthScale(nativeCap, &widthScale));

    return widthScale;
}

inline CustomLineCap* 
CustomLineCap::Clone() const
{
    GpCustomLineCap *newNativeLineCap = NULL;
    
    SetStatus(DllExports::GdipCloneCustomLineCap(nativeCap, &newNativeLineCap));

    if (lastResult == Ok) 
    {
        CustomLineCap *newLineCap = new CustomLineCap(newNativeLineCap, lastResult);
        if (newLineCap == NULL) 
        {
            SetStatus(DllExports::GdipDeleteCustomLineCap(newNativeLineCap));
        }

        return newLineCap;
    }

    return NULL;
}

class AdjustableArrowCap : public CustomLineCap
{
public:

    AdjustableArrowCap(
        IN REAL height,
        IN REAL width,
        IN BOOL isFilled = TRUE
        )
    {
        GpAdjustableArrowCap* cap = NULL;

        lastResult = DllExports::GdipCreateAdjustableArrowCap(
                        height, width, isFilled, &cap);
        SetNativeCap(cap);
    }

    Status SetHeight(IN REAL height)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapHeight(
                            cap, height));
    }

    REAL GetHeight() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL height;
        SetStatus(DllExports::GdipGetAdjustableArrowCapHeight(
                            cap, &height));

        return height;
    }

    Status SetWidth(IN REAL width)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapWidth(
                            cap, width));
    }

    REAL GetWidth() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL width;
        SetStatus(DllExports::GdipGetAdjustableArrowCapWidth(
                            cap, &width));

        return width;
    }

    Status SetMiddleInset(IN REAL middleInset)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapMiddleInset(
                            cap, middleInset));
    }

    REAL GetMiddleInset() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        REAL middleInset;
        SetStatus(DllExports::GdipGetAdjustableArrowCapMiddleInset(
                            cap, &middleInset));

        return middleInset;
    }

    Status SetFillState(IN BOOL isFilled)
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        return SetStatus(DllExports::GdipSetAdjustableArrowCapFillState(
                            cap, isFilled));
    }

    BOOL IsFilled() const
    {
        GpAdjustableArrowCap* cap = (GpAdjustableArrowCap*) nativeCap;
        BOOL isFilled;
        SetStatus(DllExports::GdipGetAdjustableArrowCapFillState(
                            cap, &isFilled));

        return isFilled;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusmem.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusMem.h
*
* Abstract:
*
*   Flat GDI+ Memory Allocators - header file
*
* Revision History:
*
*   04/27/2000 gillesk
*       Added Memory APIs
*
\**************************************************************************/

// TODO: this file style needs to be made internally consistent with the way
//       it handles breaking the long argument lists across multiple lines

#ifndef _GDIPLUSMEM_H
#define _GDIPLUSMEM_H

#define WINGDIPAPI __stdcall

// currently, only C++ wrapper API's force const.

#ifdef _GDIPLUS_H
#define GDIPCONST const
#else
#define GDIPCONST
#endif

#ifdef __cplusplus
extern "C" {
#endif

//----------------------------------------------------------------------------
// Memory Allocation APIs
//----------------------------------------------------------------------------

void* WINGDIPAPI
GdipAlloc(size_t size);

void WINGDIPAPI
GdipFree(void* ptr);

#ifdef __cplusplus
}
#endif

#endif // !_GDIPLUSMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusmetafile.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Metafile.h
*
* Abstract:
*
*   Metafile related declarations
*
* Revision History:
*
*   4/26/1999 DCurtis
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSMETAFILE_H
#define _GDIPLUSMETAFILE_H

class Metafile : public Image
{
public:
    friend class Image;

    // Read a metafile
    Metafile()
    {
        SetNativeImage(NULL);
        lastResult = Ok;
    }

    // Playback a metafile from a HMETAFILE
    // If deleteWmf is TRUE, then when the metafile is deleted,
    // the hWmf will also be deleted.  Otherwise, it won't be.
    Metafile(IN HMETAFILE hWmf,
             IN APMFileHeader * apmFileHeader, 
             IN BOOL deleteWmf = FALSE)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromWmf(hWmf, deleteWmf, apmFileHeader, &metafile);

        SetNativeImage(metafile);
    }

    // Playback a metafile from a HENHMETAFILE
    // If deleteEmf is TRUE, then when the metafile is deleted,
    // the hEmf will also be deleted.  Otherwise, it won't be.
    Metafile(IN HENHMETAFILE hEmf, 
             IN BOOL deleteEmf = FALSE)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromEmf(hEmf, deleteEmf, &metafile);

        SetNativeImage(metafile);
    }

    // Playback a metafile from a file
    Metafile(IN const WCHAR* filename)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromFile(filename, &metafile);

        SetNativeImage(metafile);
    }

    // Playback a metafile from a stream
    Metafile(IN IStream* stream)
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipCreateMetafileFromStream(stream, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to memory
    Metafile(
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafile(
                        referenceHdc, type, NULL, MetafileFrameUnitGdi,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to memory
    Metafile(
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafile(
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to memory
    Metafile(
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileI(
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to a file
    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileFileName(fileName,
                        referenceHdc, type, NULL, MetafileFrameUnitGdi,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to a file
    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileFileName(fileName,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to a file
    Metafile(
        IN const WCHAR*        fileName,
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileFileNameI(fileName,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to a stream
    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileStream(stream,
                        referenceHdc, type, NULL, MetafileFrameUnitGdi,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Record a metafile to a stream
    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN const RectF &       frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileStream(stream,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    // Write a metafile to a stream with down-level GDI records
    Metafile(
        IN IStream *           stream,
        IN HDC                 referenceHdc,
        IN const Rect &        frameRect,
        IN MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        IN EmfType             type        = EmfTypeEmfPlusDual,
        IN const WCHAR *       description = NULL
        )
    {
        GpMetafile *    metafile = NULL;

        lastResult = DllExports::GdipRecordMetafileStreamI(stream,
                        referenceHdc, type, &frameRect, frameUnit,
                        description, &metafile);

        SetNativeImage(metafile);
    }

    static Status GetMetafileHeader(
        IN HMETAFILE           hWmf,
        IN APMFileHeader *     apmFileHeader,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromWmf(hWmf, apmFileHeader, header);
    }

    static Status GetMetafileHeader(
        IN HENHMETAFILE        hEmf,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromEmf(hEmf, header);
    }

    static Status GetMetafileHeader(
        IN const WCHAR*        filename,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromFile(filename, header);
    }

    static Status GetMetafileHeader(
        IN IStream *           stream,
        OUT MetafileHeader *   header
        )
    {
        return DllExports::GdipGetMetafileHeaderFromStream(stream, header);
    }

    Status GetMetafileHeader(
        OUT MetafileHeader *    header
        ) const
    {
        return SetStatus(DllExports::GdipGetMetafileHeaderFromMetafile(
                                              (GpMetafile *)nativeImage, 
                                              header));
    }

    // Once this method is called, the Metafile object is in an invalid state
    // and can no longer be used.  It is the responsiblity of the caller to
    // invoke DeleteEnhMetaFile to delete this hEmf.

    HENHMETAFILE GetHENHMETAFILE()
    {
        HENHMETAFILE hEmf;

        SetStatus(DllExports::GdipGetHemfFromMetafile((GpMetafile *)nativeImage, &hEmf));

        return hEmf;
    }

    // Used in conjuction with Graphics::EnumerateMetafile to play an EMF+
    // The data must be DWORD aligned if it's an EMF or EMF+.  It must be
    // WORD aligned if it's a WMF.
    Status 
    PlayRecord(
        IN EmfPlusRecordType   recordType,
        IN UINT                flags,
        IN UINT                dataSize,
        IN const BYTE *        data
        ) const
    {
        return SetStatus(DllExports::GdipPlayMetafileRecord(
                                (GpMetafile *)nativeImage,
                                recordType,
                                flags,
                                dataSize,
                                data));
    }
};

#endif // !_METAFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdipluspixelformats.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus pixel formats
*
* Abstract:
*
*   Definitions for color types, palettes, pixel format IDs.
*
* Notes:
*
*   imaging.h
*
* Revision History:
*
*   10/13/1999 agodfrey
*       Separated it from imaging.h
*
\**************************************************************************/

#ifndef _GDIPLUSPIXELFORMATS_H
#define _GDIPLUSPIXELFORMATS_H

/*
 * 32-bit and 64-bit ARGB pixel value
 */

typedef DWORD ARGB;
typedef DWORDLONG ARGB64;

#define ALPHA_SHIFT 24
#define RED_SHIFT   16
#define GREEN_SHIFT 8
#define BLUE_SHIFT  0
#define ALPHA_MASK  ((ARGB) 0xff << ALPHA_SHIFT)

/*
 * In-memory pixel data formats:
 *  bits 0-7 = format index
 *  bits 8-15 = pixel size (in bits)
 *  bits 16-23 = flags
 *  bits 24-31 = reserved
 */

enum PixelFormat
{
    PixelFormatIndexed      = 0x00010000, // Indexes into a palette
    PixelFormatGDI          = 0x00020000, // Is a GDI-supported format
    PixelFormatAlpha        = 0x00040000, // Has an alpha component
    PixelFormatPAlpha       = 0x00080000, // Uses pre-multiplied alpha
    PixelFormatExtended     = 0x00100000, // Uses extended color (16 bits per channel)
    PixelFormatCanonical    = 0x00200000, // ?

    PixelFormatUndefined       =  0,
    PixelFormatDontCare        =  0,

    PixelFormat1bppIndexed     =  1 | ( 1 << 8) | PixelFormatIndexed
                                                | PixelFormatGDI,
    PixelFormat4bppIndexed     =  2 | ( 4 << 8) | PixelFormatIndexed
                                                | PixelFormatGDI,
    PixelFormat8bppIndexed     =  3 | ( 8 << 8) | PixelFormatIndexed
                                                | PixelFormatGDI,
    PixelFormat16bppGrayScale  =  4 | (16 << 8) | PixelFormatExtended,
    PixelFormat16bppRGB555     =  5 | (16 << 8) | PixelFormatGDI,
    PixelFormat16bppRGB565     =  6 | (16 << 8) | PixelFormatGDI,
    PixelFormat16bppARGB1555   =  7 | (16 << 8) | PixelFormatAlpha
                                                | PixelFormatGDI,
    PixelFormat24bppRGB        =  8 | (24 << 8) | PixelFormatGDI,
    PixelFormat32bppRGB        =  9 | (32 << 8) | PixelFormatGDI,
    PixelFormat32bppARGB       = 10 | (32 << 8) | PixelFormatAlpha
                                                | PixelFormatGDI
                                                | PixelFormatCanonical,
    PixelFormat32bppPARGB      = 11 | (32 << 8) | PixelFormatAlpha
                                                | PixelFormatPAlpha
                                                | PixelFormatGDI,
    PixelFormat48bppRGB        = 12 | (48 << 8) | PixelFormatExtended,
    PixelFormat64bppARGB       = 13 | (64 << 8) | PixelFormatAlpha
                                                | PixelFormatCanonical
                                                | PixelFormatExtended,
    PixelFormat64bppPARGB      = 14 | (64 << 8) | PixelFormatAlpha
                                                | PixelFormatPAlpha
                                                | PixelFormatExtended,
    PixelFormat24bppBGR        = 15 | (24 << 8) | PixelFormatGDI,
    PixelFormatMax             = 16
};

/*
 * Return the pixel size for the specified format (in bits)
 */

inline UINT
GetPixelFormatSize(
                   PixelFormat pixfmt
    )
{
    return (pixfmt >> 8) & 0xff;
}

/*
 * Determine if the specified pixel format is an indexed color format
 */

inline BOOL
IsIndexedPixelFormat(
                     PixelFormat pixfmt
    )
{
    return (pixfmt & PixelFormatIndexed) != 0;
}

/*
 * Determine if the pixel format can have alpha channel
 */

inline BOOL
IsAlphaPixelFormat(
                     PixelFormat pixfmt
)
{
   return (pixfmt & PixelFormatAlpha) != 0;
}

/*
 * Determine if the pixel format is an extended format,
 * i.e. supports 16-bit per channel
 */

inline BOOL
IsExtendedPixelFormat(
                     PixelFormat pixfmt
    )
{
   return (pixfmt & PixelFormatExtended) != 0;
}

/*
 * Determine if the pixel format is canonical format:
 *   PixelFormat32bppARGB
 *   PixelFormat32bppPARGB
 *   PixelFormat64bppARGB
 *   PixelFormat64bppPARGB
 */

inline BOOL
IsCanonicalPixelFormat(
                     PixelFormat pixfmt
    )
{
   return (pixfmt & PixelFormatCanonical) != 0;
}

/*
 * Color palette
 * palette entries are limited to 32bpp ARGB pixel format
 */ 

enum PaletteFlags
{
    PaletteFlagsHasAlpha    = 0x0001,
    PaletteFlagsGrayScale   = 0x0002,
    PaletteFlagsHalftone    = 0x0004
};

struct ColorPalette
{
public:
    UINT Flags;             // palette flags
    UINT Count;             // number of color entries
    ARGB Entries[1];        // palette color entries
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusmetaheader.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Metafile headers
*
* Abstract:
*
*   Declarations for various metafile header structures.
*
* Revision History:
*
*   10/15/1999 DCurtis
*       Created it.
*   10/15/1999 AGodfrey
*       Moved it to a separate file.
*
\**************************************************************************/

#ifndef _GDIPLUSMETAHEADER_H
#define _GDIPLUSMETAHEADER_H

typedef struct
{
    DWORD   iType;              // Record type EMR_HEADER
    DWORD   nSize;              // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    RECTL   rclFrame;           // Inclusive-inclusive Picture Frame of metafile in .01 mm units
    DWORD   dSignature;         // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Version number
    DWORD   nBytes;             // Size of the metafile in bytes
    DWORD   nRecords;           // Number of records in the metafile
    WORD    nHandles;           // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD    sReserved;          // Reserved.  Must be zero.
    DWORD   nDescription;       // Number of chars in the unicode description string
                                // This is 0 if there is no description string
    DWORD   offDescription;     // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD   nPalEntries;        // Number of entries in the metafile palette.
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters
} ENHMETAHEADER3;

// Aldus Placeable Metafiles

// Placeable Metafiles were created by Aldus Corporation as a non-standard
// way of specifying how a metafile is mapped and scaled on an output device.
// Placeable metafiles are quite wide-spread, but not directly supported by
// the Windows API. To playback a placeable metafile using the Windows API,
// you will first need to strip the placeable metafile header from the file.
// This is typically performed by copying the metafile to a temporary file
// starting at file offset 22 (0x16). The contents of the temporary file may
// then be used as input to the Windows GetMetaFile(), PlayMetaFile(),
// CopyMetaFile(), etc. GDI functions.

// Each placeable metafile begins with a 22-byte header,
//  followed by a standard metafile:

#include <pshpack2.h>   // set structure packing to 2

typedef struct
{
    INT16           Left;
    INT16           Top;
    INT16           Right;
    INT16           Bottom;
} APMRect16;

typedef struct
{
    UINT32          Key;            // GDIP_WMF_ALDUSKEY
    INT16           Hmf;            // Metafile HANDLE number (always 0)
    APMRect16       BoundingBox;    // Coordinates in metafile units
    INT16           Inch;           // Number of metafile units per inch
    UINT32          Reserved;       // Reserved (always 0)
    INT16           Checksum;       // Checksum value for previous 10 WORDs
} APMFileHeader;

#include <poppack.h>

// Key contains a special identification value that indicates the presence
// of a placeable metafile header and is always 0x9AC6CDD7.

// Handle is used to stored the handle of the metafile in memory. When written
// to disk, this field is not used and will always contains the value 0.

// Left, Top, Right, and Bottom contain the coordinates of the upper-left
// and lower-right corners of the image on the output device. These are
// measured in twips.

// A twip (meaning "twentieth of a point") is the logical unit of measurement
// used in Windows Metafiles. A twip is equal to 1/1440 of an inch. Thus 720
// twips equal 1/2 inch, while 32,768 twips is 22.75 inches.

// Inch contains the number of twips per inch used to represent the image.
// Normally, there are 1440 twips per inch; however, this number may be
// changed to scale the image. A value of 720 indicates that the image is
// double its normal size, or scaled to a factor of 2:1. A value of 360
// indicates a scale of 4:1, while a value of 2880 indicates that the image
// is scaled down in size by a factor of two. A value of 1440 indicates
// a 1:1 scale ratio.

// Reserved is not used and is always set to 0.

// Checksum contains a checksum value for the previous 10 WORDs in the header.
// This value can be used in an attempt to detect if the metafile has become
// corrupted. The checksum is calculated by XORing each WORD value to an
// initial value of 0.

// If the metafile was recorded with a reference Hdc that was a display.
#define GDIP_EMFPLUSFLAGS_DISPLAY       0x00000001

class MetafileHeader
{
public:
    MetafileType        Type;
    UINT                Size;               // Size of the metafile (in bytes)
    UINT                Version;            // EMF+, EMF, or WMF version
    UINT                EmfPlusFlags;
    REAL                DpiX;
    REAL                DpiY;
    INT                 X;                  // Bounds in device units
    INT                 Y;
    INT                 Width;
    INT                 Height;
    union
    {
        METAHEADER      WmfHeader;
        ENHMETAHEADER3  EmfHeader;
    };
    INT                 EmfPlusHeaderSize;  // size of the EMF+ header in file
    INT                 LogicalDpiX;        // Logical Dpi of reference Hdc
    INT                 LogicalDpiY;        // usually valid only for EMF+ files

public:
    // Get the metafile type
    MetafileType GetType() const { return Type; }

    // Get the size of the metafile in BYTEs
    UINT GetMetafileSize() const { return Size; }

    // If IsEmfPlus, this is the EMF+ version; else it is the WMF or EMF version
    UINT GetVersion() const { return Version; }

    // Get the EMF+ flags associated with the metafile
    UINT GetEmfPlusFlags() const { return EmfPlusFlags; }

    // Get the X Dpi of the metafile
    REAL GetDpiX() const { return DpiX; }

    // Get the Y Dpi of the metafile
    REAL GetDpiY() const { return DpiY; }

    // Get the bounds of the metafile in device units
    VOID GetBounds (OUT Rect *rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }
    
    // Is it any type of WMF (standard or Aldus Placeable Metafile)?
    BOOL IsWmf() const
    {
       return ((Type == MetafileTypeWmf) || (Type == MetafileTypeWmfAldus));
    }

    // Is this an Aldus Placeable Metafile?
    BOOL IsWmfAldus() const { return (Type == MetafileTypeWmf); }

    // Is this an EMF (not an EMF+)?
    BOOL IsEmf() const { return (Type == MetafileTypeEmf); }

    // Is this an EMF or EMF+ file?
    BOOL IsEmfOrEmfPlus() const { return (Type >= MetafileTypeEmf); }

    // Is this an EMF+ file?
    BOOL IsEmfPlus() const { return (Type >= MetafileTypeEmfPlusOnly); }

    // Is this an EMF+ dual (has dual, down-level records) file?
    BOOL IsEmfPlusDual() const { return (Type == MetafileTypeEmfPlusDual); }

    // Is this an EMF+ only (no dual records) file?
    BOOL IsEmfPlusOnly() const { return (Type == MetafileTypeEmfPlusOnly); }

    // If it's an EMF+ file, was it recorded against a display Hdc?
    BOOL IsDisplay() const
    {
        return (IsEmfPlus() &&
                ((EmfPlusFlags & GDIP_EMFPLUSFLAGS_DISPLAY) != 0));
    }

    // Get the WMF header of the metafile (if it is a WMF)
    const METAHEADER * GetWmfHeader() const
    {
        if (IsWmf())
        {
            return &WmfHeader;
        }
        return NULL;
    }

    // Get the EMF header of the metafile (if it is an EMF)
    const ENHMETAHEADER3 * GetEmfHeader() const
    {
        if (IsEmfOrEmfPlus())
        {
            return &EmfHeader;
        }
        return NULL;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusmatrix.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Gdiplus.hpp
*
* Abstract:
*
*   GDI+ Native C++ public header file
*
* Revision History:
*
*   03/03/1999 davidx
*       Created it.
*
\**************************************************************************/

class Matrix : public GdiplusBase
{
public:
    friend class Graphics;
    friend class GraphicsPath;
    friend class TextureBrush;
    friend class LinearGradientBrush;
    friend class PathGradientBrush;
    friend class Pen;
    friend class Region;
    
    // Default constructor - set to identity matrix

    Matrix()
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix(&matrix);
    
        SetNativeMatrix(matrix);
    }

    Matrix(IN REAL m11, 
           IN REAL m12,
           IN REAL m21, 
           IN REAL m22,
           IN REAL dx, 
           IN REAL dy)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix2(m11, m12, m21, m22, 
                                                      dx, dy, &matrix);
    
        SetNativeMatrix(matrix);
    }
    
    Matrix(IN const RectF& rect, 
           IN const PointF* dstplg)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix3(&rect, 
                                                   dstplg,
                                                   &matrix);

        SetNativeMatrix(matrix);
    }

    Matrix(IN const Rect& rect, 
           IN const Point* dstplg)
    {
        GpMatrix *matrix = NULL;

        lastResult = DllExports::GdipCreateMatrix3I(&rect, 
                                                    dstplg,
                                                    &matrix);

        SetNativeMatrix(matrix);
    }

    ~Matrix()
    {
        DllExports::GdipDeleteMatrix(nativeMatrix);
    }

    Matrix *Clone() const
    {
        GpMatrix *cloneMatrix = NULL;

        SetStatus(DllExports::GdipCloneMatrix(nativeMatrix,
                                                  &cloneMatrix));

        if (lastResult != Ok)
            return NULL;

        return new Matrix(cloneMatrix);
    }

    Status GetElements(OUT REAL *m) const 
    {
        return SetStatus(DllExports::GdipGetMatrixElements(nativeMatrix, m));
    }
    
    Status SetElements(IN REAL m11, 
                       IN REAL m12, 
                       IN REAL m21, 
                       IN REAL m22, 
                       IN REAL dx, 
                       IN REAL dy)
    {
        return SetStatus(DllExports::GdipSetMatrixElements(nativeMatrix,
                            m11, m12, m21, m22, dx, dy));
    }

    REAL OffsetX() const
    {
        REAL elements[6];

        if (GetElements(&elements[0]) == Ok)
            return elements[4];
        else 
            return 0.0f;
    }

    REAL OffsetY() const
    {
       REAL elements[6];

       if (GetElements(&elements[0]) == Ok)
           return elements[5];
       else 
           return 0.0f;
    }

    Status Reset()
    {
        // set identity matrix elements 
        return SetStatus(DllExports::GdipSetMatrixElements(nativeMatrix,
                                             1.0, 0.0, 0.0, 1.0, 0.0, 0.0));
    }

    Status Multiply(IN const Matrix *matrix, 
                    IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyMatrix(nativeMatrix, 
                                          matrix->nativeMatrix,
                                          order));
    }

    Status Translate(IN REAL offsetX, 
                     IN REAL offsetY, 
                     IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, offsetX, offsetY, order));
    }

    Status Scale(IN REAL scaleX, 
                 IN REAL scaleY, 
                 IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScaleMatrix(nativeMatrix, scaleX, scaleY, order));
    }

    Status Rotate(IN REAL angle, 
                  IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, order));
    }
    
    Status RotateAt(IN REAL angle, 
                    IN const PointF& center, 
                    IN MatrixOrder order = MatrixOrderPrepend)
    {
        if(order == MatrixOrderPrepend)
        {
            SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, center.X, center.Y, order));
            SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, order));
            return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, - center.X, - center.Y, order));
        }
        else
        {
            SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, - center.X, - center.Y, order));
            SetStatus(DllExports::GdipRotateMatrix(nativeMatrix, angle, order));
            return SetStatus(DllExports::GdipTranslateMatrix(nativeMatrix, center.X, center.Y, order));
        }
    }

    Status Shear(IN REAL shearX, 
                 IN REAL shearY,
                 IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipShearMatrix(nativeMatrix, shearX, shearY, order));
    }

    Status Invert()
    {
        return SetStatus(DllExports::GdipInvertMatrix(nativeMatrix));
    }

    // float version
    Status TransformPoints(IN OUT PointF* pts, 
                           IN INT count = 1) const
    {
        return SetStatus(DllExports::GdipTransformMatrixPoints(nativeMatrix, pts, count));
    }
    
    Status TransformPoints(IN OUT Point* pts, 
                           IN INT count = 1) const
    {
        return SetStatus(DllExports::GdipTransformMatrixPointsI(nativeMatrix, 
                                                                pts, 
                                                                count));
    }

    Status TransformVectors(IN OUT PointF* pts, 
                            IN INT count = 1) const
    { 
        return SetStatus(DllExports::GdipVectorTransformMatrixPoints(nativeMatrix, pts, count));
    }

    Status TransformVectors(IN OUT Point* pts, 
                            IN INT count = 1) const
    { 
       return SetStatus(DllExports::GdipVectorTransformMatrixPointsI(nativeMatrix, 
                                                                    pts, 
                                                                    count));
    }
    
    BOOL IsInvertible() const
    {
        BOOL result = FALSE;

        SetStatus(DllExports::GdipIsMatrixInvertible(nativeMatrix, &result));
    
        return result;
    }

    BOOL IsIdentity() const
    {
       BOOL result = FALSE;

       SetStatus(DllExports::GdipIsMatrixIdentity(nativeMatrix, &result));
    
       return result;
    }

    BOOL Equals(IN const Matrix *matrix) const
    {
       BOOL result = FALSE;

       SetStatus(DllExports::GdipIsMatrixEqual(nativeMatrix,
                                                 matrix->nativeMatrix, &result));
   
       return result;
    }
    
    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;
 
        return lastStatus;
    }

protected:
    Matrix(const Matrix& matrix)
    {
        matrix;
        SetStatus(NotImplemented);
        SetNativeMatrix(NULL);
    }

    Matrix& operator=(const Matrix& matrix)
    {
        matrix;
        SetStatus(NotImplemented);
        return *this;
    }

    Matrix(GpMatrix *nativeMatrix)
    {
        lastResult = Ok;
        SetNativeMatrix(nativeMatrix);
    }
    
    VOID SetNativeMatrix(GpMatrix *nativeMatrix)
    {
        this->nativeMatrix = nativeMatrix;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpMatrix *nativeMatrix;
    mutable Status lastResult;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusregion.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Region.hpp
*
* Abstract:
*
*   Region API related declarations
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/

#ifndef _GDIPLUSREGION_H
#define _GDIPLUSREGION_H

/**
 * Construct a new region object
 */

inline 
Region::Region()
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegion(&region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const RectF& rect)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRect(&rect, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const Rect& rect)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRectI(&rect, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const GraphicsPath* path)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionPath(path->nativePath, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN const BYTE* regionData, IN INT size)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionRgnData(regionData, size, &region);

    SetNativeRegion(region);
}

inline 
Region::Region(IN HRGN hRgn)
{
    GpRegion *region = NULL;

    lastResult = DllExports::GdipCreateRegionHrgn(hRgn, &region);

    SetNativeRegion(region);
}

inline 
Region* Region::FromHRGN(IN HRGN hRgn)
{
    GpRegion *region = NULL;

    if (DllExports::GdipCreateRegionHrgn(hRgn, &region) == Ok)
    {
        Region* newRegion = new Region(region);

        if (newRegion == NULL) 
        {
            DllExports::GdipDeleteRegion(region);
        }

        return newRegion;
    }
    else
        return NULL;
}

inline 
Region::~Region()
{
    DllExports::GdipDeleteRegion(nativeRegion);
}

/**
 * Make a copy of the region object
 */
inline Region* 
Region::Clone() const
{
    GpRegion *region = NULL;

    SetStatus(DllExports::GdipCloneRegion(nativeRegion, &region));

    return new Region(region);
}

inline Status 
Region::MakeInfinite()
{
    return SetStatus(DllExports::GdipSetInfinite(nativeRegion));
}

inline Status 
Region::MakeEmpty()
{
    return SetStatus(DllExports::GdipSetEmpty(nativeRegion));
}

/**
 * Region operations
 */
inline Status 
Region::Intersect(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, path->nativePath, CombineModeIntersect));
}

inline Status 
Region::Intersect(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, region->nativeRegion, CombineModeIntersect));
}

inline Status 
Region::Union(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, CombineModeUnion));
}

inline Status 
Region::Union(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, CombineModeUnion));
}

inline Status 
Region::Union(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, path->nativePath, CombineModeUnion));
}

inline Status 
Region::Union(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, region->nativeRegion, CombineModeUnion));
}

inline Status 
Region::Xor(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, CombineModeXor));
}

inline Status 
Region::Xor(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, CombineModeXor));
}

inline Status 
Region::Xor(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, path->nativePath, CombineModeXor));
}

inline Status 
Region::Xor(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion, region->nativeRegion, CombineModeXor));
}

inline Status 
Region::Exclude(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, CombineModeExclude));
}

inline Status 
Region::Exclude(IN const Rect& rect)
{
     return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, CombineModeExclude));
}

inline Status 
Region::Exclude(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion, path->nativePath, CombineModeExclude));
}

inline Status
Region::Exclude(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion,
                                               region->nativeRegion, CombineModeExclude));
}

inline Status 
Region::Complement(IN const RectF& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRect(nativeRegion, &rect, CombineModeComplement));
}

inline Status 
Region::Complement(IN const Rect& rect)
{
    return SetStatus(DllExports::GdipCombineRegionRectI(nativeRegion, &rect, CombineModeComplement));
}

inline Status 
Region::Complement(IN const GraphicsPath* path)
{
    return SetStatus(DllExports::GdipCombineRegionPath(nativeRegion,
                                                path->nativePath, CombineModeComplement));
}

inline Status 
Region::Complement(IN const Region* region)
{
    return SetStatus(DllExports::GdipCombineRegionRegion(nativeRegion,
                                                  region->nativeRegion, CombineModeComplement));
}

/**
 * Transform operations
 */
inline Status 
Region::Translate(IN REAL dx, 
                  IN REAL dy)
{
    return SetStatus(DllExports::GdipTranslateRegion(nativeRegion, dx, dy));
}

inline Status 
Region::Translate(IN INT dx, 
                  IN INT dy)
{
    return SetStatus(DllExports::GdipTranslateRegionI(nativeRegion, dx, dy));
}

inline Status 
Region::Transform(IN const Matrix* matrix)
{
    return SetStatus(DllExports::GdipTransformRegion(nativeRegion, matrix->nativeMatrix));
}

/**
 * Get region attributes
 */
inline Status 
Region::GetBounds(OUT RectF* rect,
                  IN const Graphics* g) const
{
    return SetStatus(DllExports::GdipGetRegionBounds(nativeRegion,
                                                g->nativeGraphics,
                                                rect));
}

inline Status 
Region::GetBounds(OUT Rect* rect,
                  IN const Graphics* g) const
{
    return SetStatus(DllExports::GdipGetRegionBoundsI(nativeRegion,
                                                g->nativeGraphics,
                                                rect));
}

inline HRGN
Region::GetHRGN(IN const Graphics* g) const
{
    HRGN hrgn;

    SetStatus(DllExports::GdipGetRegionHRgn(nativeRegion,
                                            g->nativeGraphics,
                                            &hrgn));

    return hrgn;
}

inline BOOL 
Region::IsEmpty(IN const Graphics *g) const
{
    BOOL booln = FALSE;
   
    SetStatus(DllExports::GdipIsEmptyRegion(nativeRegion,
                                            g->nativeGraphics,
                                            &booln));

    return booln;
}

inline BOOL 
Region::IsInfinite(IN const Graphics *g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsInfiniteRegion(nativeRegion,
                                                 g->nativeGraphics,
                                                 &booln));

    return booln;
}

inline BOOL 
Region::Equals(IN const Region* region, 
               IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsEqualRegion(nativeRegion,
                                              region->nativeRegion,
                                              g->nativeGraphics,
                                              &booln));
    return booln;
}

// Get the size of the buffer needed for the GetData method
inline UINT 
Region::GetDataSize() const
{
    UINT     bufferSize = 0;
    
    SetStatus(DllExports::GdipGetRegionDataSize(nativeRegion, &bufferSize));
    
    return bufferSize;
}

// buffer     - where to put the data
// bufferSize - how big the buffer is (should be at least as big as GetDataSize())
// sizeFilled - if not NULL, this is an OUT param that says how many bytes
//              of data were written to the buffer.
inline Status 
Region::GetData(OUT BYTE* buffer, 
                IN UINT bufferSize, 
                OUT UINT* sizeFilled) const
{
    return SetStatus(DllExports::GdipGetRegionData(nativeRegion, buffer, bufferSize, sizeFilled));
}

/**
 * Hit testing operations
 */
inline BOOL 
Region::IsVisible(IN const PointF& point, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionPoint(nativeRegion,
                                     point.X, point.Y, 
                                     (g == NULL) ? NULL : g->nativeGraphics,
                                     &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const RectF& rect, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionRect(nativeRegion, rect.X,
                                                    rect.Y, rect.Width,
                                                    rect.Height,
                                                    (g == NULL) ? NULL : g->nativeGraphics,
                                                    &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const Point& point, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;


    SetStatus(DllExports::GdipIsVisibleRegionPointI(nativeRegion,
                                                   point.X,
                                                   point.Y,
                                                   (g == NULL) ? NULL : g->nativeGraphics,
                                                   &booln));
    return booln;
}

inline BOOL 
Region::IsVisible(IN const Rect& rect, 
                  IN const Graphics* g) const
{
    BOOL booln = FALSE;

    SetStatus(DllExports::GdipIsVisibleRegionRectI(nativeRegion,
                                                  rect.X,
                                                  rect.Y,
                                                  rect.Width,
                                                  rect.Height,
                                                  (g == NULL) ? NULL : g->nativeGraphics,
                                                  &booln));
    return booln;
}

inline UINT 
Region::GetRegionScansCount(IN const Matrix* matrix) const
{
    UINT count = 0;

    SetStatus(DllExports::GdipGetRegionScansCount(nativeRegion,
                                                  &count,
                                                  matrix->nativeMatrix));
    return count;
}

inline Status 
Region::GetRegionScans(
    IN const Matrix* matrix,
    OUT RectF* rects,
    IN OUT INT* count) const
{
    return SetStatus(DllExports::GdipGetRegionScans(nativeRegion,
                                          rects,
                                          count,
                                          matrix->nativeMatrix));
}

// If rects is NULL, return the count of rects in the region.
// Otherwise, assume rects is big enough to hold all the region rects
// and fill them in and return the number of rects filled in.
// The rects are returned in the units specified by the matrix
// (which is typically a world-to-device transform).
// Note that the number of rects returned can vary, depending on the
// matrix that is used.
inline Status 
Region::GetRegionScans(
    IN const Matrix* matrix,
    OUT Rect* rects,       // NULL to just get the count
    IN OUT INT* count) const
{
    return SetStatus(DllExports::GdipGetRegionScansI(nativeRegion,
                                          rects,
                                          count,
                                          matrix->nativeMatrix));
}

// protected method
inline Region::Region(GpRegion* nativeRegion)
{
    SetNativeRegion(nativeRegion);
}

// protected method
inline VOID Region::SetNativeRegion(GpRegion* nativeRegion)
{
    this->nativeRegion = nativeRegion;
}

inline Status Region::GetLastStatus() const
{
    Status lastStatus = lastResult;
    lastResult = Ok;

    return lastStatus;
}

#endif // !_GDIPLUSREGION_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdipluspen.h ===
/**************************************************************************\
* 
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   Pen API related declarations
*
* Revision History:
*
*   12/09/1998 andrewgo
*       Flesh out pen interfaces.
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/
#ifndef _GDIPLUSPEN_H
#define _GDIPLUSPEN_H

//--------------------------------------------------------------------------
// class for various pen types
//--------------------------------------------------------------------------

class Pen : public GdiplusBase
{
public:
    friend class GraphicsPath;
    friend class Graphics;

    // abstract Clone() can't be implemented here because it can't
    // new an object with pure virtual functions

    // Constructors

    Pen(IN const Color& color, 
        IN REAL width = 1.0f)
    {
        Unit unit = UnitWorld;
        nativePen = NULL;
        lastResult = DllExports::GdipCreatePen1(color.GetValue(),
                                    width, unit, &nativePen);
    }

    Pen(IN const Brush* brush, 
        IN REAL width = 1.0f)
    {
        Unit unit = UnitWorld;
        nativePen = NULL;
        lastResult = DllExports::GdipCreatePen2(brush->nativeBrush,
                                    width, unit, &nativePen);
    }

    ~Pen()
    {
        DllExports::GdipDeletePen(nativePen);
    }

    Pen* Clone() const
    {
        GpPen *clonePen = NULL;

        lastResult = DllExports::GdipClonePen(nativePen, &clonePen);
   
        return new Pen(clonePen, lastResult);
    }

    Status SetWidth(IN REAL width)
    {
        return SetStatus(DllExports::GdipSetPenWidth(nativePen, width));
    }

    REAL GetWidth() const
    {
        REAL width;

        SetStatus(DllExports::GdipGetPenWidth(nativePen, &width));
        
        return width;
    }
    
    // Set/get line caps: start, end, and dash

    // Line cap and join APIs by using LineCap and LineJoin enums.

    Status SetLineCap(IN LineCap startCap, 
                      IN LineCap endCap, 
                      IN LineCap dashCap)
    {
        return SetStatus(DllExports::GdipSetPenLineCap(nativePen, 
                                   startCap, endCap, dashCap));
    }

    Status SetStartCap(IN LineCap startCap)
    {
        return SetStatus(DllExports::GdipSetPenStartCap(nativePen, startCap));
    }

    Status SetEndCap(IN LineCap endCap)
    {
        return SetStatus(DllExports::GdipSetPenEndCap(nativePen, endCap));
    }

    Status SetDashCap(IN LineCap dashCap)
    {
        return SetStatus(DllExports::GdipSetPenDashCap(nativePen, dashCap));
    }

    LineCap GetStartCap() const
    {
        LineCap startCap;

        SetStatus(DllExports::GdipGetPenStartCap(nativePen, &startCap));
        
        return startCap;
    }

    LineCap GetEndCap() const
    {
        LineCap endCap;

        SetStatus(DllExports::GdipGetPenEndCap(nativePen, &endCap));

        return endCap;
    }

    LineCap GetDashCap() const
    {
        LineCap dashCap;

        SetStatus(DllExports::GdipGetPenDashCap(nativePen, &dashCap));

        return dashCap;
    }

    // Set/get line join

    Status SetLineJoin(IN LineJoin lineJoin)
    {
        return SetStatus(DllExports::GdipSetPenLineJoin(nativePen, lineJoin));
    }

    LineJoin GetLineJoin() const
    {
        LineJoin lineJoin;
        
        SetStatus(DllExports::GdipGetPenLineJoin(nativePen, &lineJoin));
        
        return lineJoin;
    }

    Status SetCustomStartCap(IN const CustomLineCap* customCap)
    {
        GpCustomLineCap* nativeCap = NULL;
        if(customCap)
            nativeCap = customCap->nativeCap;

        return SetStatus(DllExports::GdipSetPenCustomStartCap(nativePen, nativeCap));
    }

    Status GetCustomStartCap(OUT CustomLineCap* customCap) const
    {
        if(!customCap)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPenCustomStartCap(nativePen, &(customCap->nativeCap)));
    }

    Status SetCustomEndCap(IN const CustomLineCap* customCap)
    {
        GpCustomLineCap* nativeCap = NULL;
        if(customCap)
            nativeCap = customCap->nativeCap;

        return SetStatus(DllExports::GdipSetPenCustomEndCap(nativePen, nativeCap));
    }

    Status GetCustomEndCap(OUT CustomLineCap* customCap) const
    {
        if(!customCap)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPenCustomEndCap(nativePen, &(customCap->nativeCap)));
    }

    Status SetMiterLimit(IN REAL miterLimit)
    {
        return SetStatus(DllExports::GdipSetPenMiterLimit(nativePen, miterLimit));
    }

    REAL GetMiterLimit() const
    {
        REAL miterLimit;

        SetStatus(DllExports::GdipGetPenMiterLimit(nativePen, &miterLimit));

        return miterLimit;
    }

    // Set/get pen mode
    Status SetAlignment(IN PenAlignment penAlignment)
    {
        return SetStatus(DllExports::GdipSetPenMode(nativePen, penAlignment));
    }

    PenAlignment GetAlignment() const
    {
        PenAlignment penAlignment;
        
        SetStatus(DllExports::GdipGetPenMode(nativePen, &penAlignment));
        
        return penAlignment;
    }
    
    // Set/get pen transform
    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetPenTransform(nativePen, 
                                                         matrix->nativeMatrix));
    }

    Status GetTransform(OUT Matrix* matrix) const
    {
        return SetStatus(DllExports::GdipGetPenTransform(nativePen, matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetPenTransform(nativePen));
    }

    Status MultiplyTransform(IN Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyPenTransform(nativePen,
                                                              matrix->nativeMatrix,
                                                              order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslatePenTransform(nativePen,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScalePenTransform(nativePen,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotatePenTransform(nativePen,
                                                              angle, order));
    }

    PenType GetPenType() const
    {
       PenType type;
       SetStatus(DllExports::GdipGetPenFillType(nativePen, &type));

       return type;
    }

    Status SetColor(IN const Color& color)
    {
        return SetStatus(DllExports::GdipSetPenColor(nativePen,
                                                     color.GetValue()));
    }

    Status SetBrush(IN const Brush* brush)
    {
        return SetStatus(DllExports::GdipSetPenBrushFill(nativePen, 
                                       brush->nativeBrush));
    }

    Status GetColor(OUT Color* color)
    {
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        PenType type = GetPenType();

        if (type != PenTypeSolidColor) 
        {
            return WrongState;
        }
        
        ARGB argb;
        
        SetStatus(DllExports::GdipGetPenColor(nativePen,
                                              &argb));
        if (lastResult == Ok)
        {
            color->SetValue(argb);
        }
        
        return lastResult;
    }

    Brush* GetBrush() const
    {
       PenType type = GetPenType();

       Brush* brush = NULL;

       switch(type)
       {
       case PenTypeSolidColor:
           brush = new SolidBrush();
           break;

       case PenTypeHatchFill:
           brush = new HatchBrush();
           break;

       case PenTypeTextureFill:
           brush = new TextureBrush();
           break;

       case PenTypePathGradient:
           brush = new Brush();
           break;

       case PenTypeLinearGradient:
           brush = new LinearGradientBrush();
           break;

       default:
           break;
       }

       if(brush)
       {
           GpBrush* nativeBrush;

           SetStatus(DllExports::GdipGetPenBrushFill(nativePen, &nativeBrush));
           brush->SetNativeBrush(nativeBrush);
       }

       return brush;
    }

    DashStyle GetDashStyle() const
    {
        DashStyle dashStyle;

        SetStatus(DllExports::GdipGetPenDashStyle(nativePen, &dashStyle));

        return dashStyle;
    }

    Status SetDashStyle(IN DashStyle dashStyle)
    {
        return SetStatus(DllExports::GdipSetPenDashStyle(nativePen, dashStyle));
    }

    REAL GetDashOffset() const
    {
        REAL dashOffset;

        SetStatus(DllExports::GdipGetPenDashOffset(nativePen, &dashOffset));

        return dashOffset;
    }

    Status SetDashOffset(IN REAL dashOffset)
    {
        return SetStatus(DllExports::GdipSetPenDashOffset(nativePen, dashOffset));
    }
    
    Status SetDashPattern(IN const REAL* dashArray, IN INT count)
    {
        return SetStatus(DllExports::GdipSetPenDashArray(nativePen, dashArray, 
                                                    count));
    }
    
    INT GetDashPatternCount() const
    {
        INT count = 0;
        
        SetStatus(DllExports::GdipGetPenDashCount(nativePen, &count));
        
        return count;
    }

    Status GetDashPattern(OUT REAL* dashArray, 
                          IN INT count) const
    {
        if (dashArray == NULL || count <= 0)
            return SetStatus(InvalidParameter); 
        
        return SetStatus(DllExports::GdipGetPenDashArray(nativePen, 
                                                         dashArray, 
                                                         count));
    }

    Status SetCompoundArray(IN const REAL* compoundArray,
                            IN INT count)
    {
        return SetStatus(DllExports::GdipSetPenCompoundArray(nativePen, compoundArray, 
                                                    count));
    }

    INT GetCompoundArrayCount() const
    {
        INT count = 0;
        
        SetStatus(DllExports::GdipGetPenCompoundCount(nativePen, &count));
        
        return count;
    }

    Status GetCompoundArray(OUT REAL* compoundArray, 
                            IN INT count) const
    {
        if (compoundArray == NULL || count <= 0)
            return SetStatus(InvalidParameter); 
        
        return SetStatus(DllExports::GdipGetPenCompoundArray(nativePen, 
                                                             compoundArray, 
                                                             count));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:
    Pen(const Pen& pen)
    {
        pen;
        SetStatus(NotImplemented);
        SetNativePen(NULL);
    }

    Pen& operator=(const Pen& pen)
    {
        pen;
        SetStatus(NotImplemented);
        return *this;
    }

    Pen(GpPen* nativePen, Status status)
    {
        lastResult = status;
        SetNativePen(nativePen);
    }

    VOID SetNativePen(GpPen* nativePen)
    {
        this->nativePen = nativePen;
    }
    
    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else 
            return status;
    }

protected:
    GpPen* nativePen;
    mutable Status lastResult;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdipluspath.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   path.hpp
*
* Abstract:
*
*   Path related declarations
*
* Revision History:
*
*   12/06/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSPATH_H
#define _GDIPLUSPATH_H

class GraphicsPath : public GdiplusBase
{
public:
    friend class Graphics;
    friend class Region;
    friend class PathGradientBrush;
    friend class GraphicsPathIterator;
    friend class CustomLineCap;

    // Path constructors

    GraphicsPath(IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath(fillMode, &nativePath);
    }

    GraphicsPath(IN const PointF* points,
                 IN const BYTE* types,
                 IN INT count,
                 IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath2(points,
                                                 types,
                                                 count,
                                                 fillMode,
                                                 &nativePath);
    }

    GraphicsPath(IN const Point* points,
                 IN const BYTE* types,
                 IN INT count,
                 IN FillMode fillMode = FillModeAlternate)
    {
        nativePath = NULL;
        lastResult = DllExports::GdipCreatePath2I(points,
                                                  types,
                                                  count,
                                                  fillMode,
                                                  &nativePath);
    }

    ~GraphicsPath()
    {
        DllExports::GdipDeletePath(nativePath);
    }

    /**
     * Make a copy of the current path object
     */
    GraphicsPath* Clone() const
    {
        GpPath *clonepath = NULL;

        SetStatus(DllExports::GdipClonePath(nativePath, &clonepath));

        return new GraphicsPath(clonepath);
    }

    /**
     * Reset the path object to empty (and fill mode to FillModeAlternate)
     */
    Status Reset()
    {
        return SetStatus(DllExports::GdipResetPath(nativePath));
    }

    /**
     * Get path fill mode information
     */
    FillMode GetFillMode() const
    {
        FillMode fillmode = FillModeAlternate;

        SetStatus(DllExports::GdipGetPathFillMode(nativePath, &fillmode));

        return fillmode;
    }

    /**
     * Set path fill mode information
     */
    Status SetFillMode(IN FillMode fillmode)
    {
        return SetStatus(DllExports::GdipSetPathFillMode(nativePath, fillmode));
    }

    /**
     * Set/get path data
     */
    Status GetPathData(OUT PathData* pathData) const
    {
        if (pathData == NULL) 
        {
            return SetStatus(InvalidParameter);
        }
        
        INT count = GetPointCount();
        
        if ((count <= 0) || (pathData->Count>0 && pathData->Count<count))
        {
            pathData->Count = 0;
            if (pathData->Points)
            {
                delete pathData->Points;
                pathData->Points = NULL;
            }

            if (pathData->Types) 
            {
                delete pathData->Types;
                pathData->Types = NULL;
            }

            if (count <= 0)
            {
                return lastResult;
            }
        }

        if (pathData->Count == 0) 
        {
            pathData->Points = new PointF[count];
            if (pathData->Points == NULL) 
            {
                return SetStatus(OutOfMemory);
            
            }
            pathData->Types = new byte[count];
            if (pathData->Types == NULL) 
            {
                delete pathData->Points;
                pathData->Points = NULL;

                return SetStatus(OutOfMemory);
            }
            pathData->Count = count;
        }

        return SetStatus(DllExports::GdipGetPathData(nativePath, pathData));
    }

    /**
     * Start/end a subpath
     */
    Status StartFigure()
    {
        return SetStatus(DllExports::GdipStartPathFigure(nativePath));
    }

    Status CloseFigure()
    {
        return SetStatus(DllExports::GdipClosePathFigure(nativePath));
    }

    Status CloseAllFigures()
    {
        return SetStatus(DllExports::GdipClosePathFigures(nativePath));
    }

    Status SetMarker()
    {
        return SetStatus(DllExports::GdipSetPathMarker(nativePath));
    }

    Status ClearMarkers()
    {
        return SetStatus(DllExports::GdipClearPathMarkers(nativePath));
    }

    Status Reverse()
    {
        return SetStatus(DllExports::GdipReversePath(nativePath));
    }

    Status GetLastPoint(OUT PointF* lastPoint) const
    {
        return SetStatus(DllExports::GdipGetPathLastPoint(nativePath, lastPoint));
    }

    /**
     * Add lines to the path object
     */
    // float version
    Status AddLine(IN const PointF& pt1, 
                   IN const PointF& pt2)
    {
        return AddLine(pt1.X, pt1.Y, pt2.X, pt2.Y);
    }

    Status AddLine(IN REAL x1,
                   IN REAL y1, 
                   IN REAL x2, 
                   IN REAL y2)
    {
        return SetStatus(DllExports::GdipAddPathLine(nativePath, x1, y1, x2, y2));
    }

    Status AddLines(IN const PointF* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathLine2(nativePath, points, count));
    }

    // integer version
    Status AddLine(IN const Point& pt1, 
                   IN const Point& pt2)
    {
        return AddLine(pt1.X,
                       pt1.Y,
                       pt2.X,
                       pt2.Y);
    }

    Status AddLine(IN INT x1, 
                   IN INT y1, 
                   IN INT x2, 
                   IN INT y2)
    {
        return SetStatus(DllExports::GdipAddPathLineI(nativePath,
                                                     x1,
                                                     y1,
                                                     x2,
                                                     y2));
    }

    Status AddLines(IN const Point* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathLine2I(nativePath,
                                                       points,
                                                       count));
    }

    /**
     * Add an arc to the path object
     */
    // float version
    Status AddArc(IN const RectF& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddArc(rect.X, rect.Y, rect.Width, rect.Height,
                      startAngle, sweepAngle);
    }

    Status AddArc(IN REAL x, 
                  IN REAL y, 
                  IN REAL width, 
                  IN REAL height,
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathArc(nativePath, x, y, width, height,
                                      startAngle, sweepAngle));
    }

    // integer version
    Status AddArc(IN const Rect& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddArc(rect.X, rect.Y, rect.Width, rect.Height,
                      startAngle, sweepAngle);
    }

    Status AddArc(IN INT x, 
                  IN INT y, 
                  IN INT width, 
                  IN INT height,
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathArcI(nativePath,
                                                    x,
                                                    y,
                                                    width,
                                                    height,
                                                    startAngle,
                                                    sweepAngle));
    }

    /**
     * Add Bezier curves to the path object
     */
    // float version
    Status AddBezier(IN const PointF& pt1, 
                     IN const PointF& pt2,
                     IN const PointF& pt3, 
                     IN const PointF& pt4)
    {
        return AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X,
                         pt4.Y);
    }

    Status AddBezier(IN REAL x1, 
                     IN REAL y1, 
                     IN REAL x2, 
                     IN REAL y2,
                     IN REAL x3, 
                     IN REAL y3, 
                     IN REAL x4, 
                     IN REAL y4)
    {
        return SetStatus(DllExports::GdipAddPathBezier(nativePath, x1, y1, x2, y2,
                                     x3, y3, x4, y4));
    }

    Status AddBeziers(IN const PointF* points, 
                      IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathBeziers(nativePath, points, count));
    }

    // integer version
    Status AddBezier(IN const Point& pt1, 
                     IN const Point& pt2,
                     IN const Point& pt3, 
                     IN const Point& pt4)
    {
       return AddBezier(pt1.X, pt1.Y, pt2.X, pt2.Y, pt3.X, pt3.Y, pt4.X,
                        pt4.Y);
    }

    Status AddBezier(IN INT x1, 
                     IN INT y1, 
                     IN INT x2, 
                     IN INT y2,
                     IN INT x3,
                     IN INT y3, 
                     IN INT x4, 
                     IN INT y4)
    {
       return SetStatus(DllExports::GdipAddPathBezierI(nativePath,
                                                      x1,
                                                      y1,
                                                      x2,
                                                      y2,
                                                      x3,
                                                      y3,
                                                      x4,
                                                      y4));
    }

    Status AddBeziers(IN const Point* points,
                      IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathBeziersI(nativePath,
                                                        points,
                                                        count));
    }

    // float version
    Status AddCurve(IN const PointF* points, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathCurve(nativePath,
                                                      points,
                                                      count));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count,
                    IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathCurve2(nativePath,
                                                       points,
                                                       count,
                                                       tension));
    }

    Status AddCurve(IN const PointF* points, 
                    IN INT count, 
                    IN INT offset,
                    IN INT numberOfSegments, 
                    IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathCurve3(nativePath,
                                                       points,
                                                       count,
                                                       offset,
                                                       numberOfSegments,
                                                       tension));
    }

    // integer version
    Status AddCurve(IN const Point* points, 
                    IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathCurveI(nativePath,
                                                     points,
                                                     count));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count, 
                    IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathCurve2I(nativePath,
                                                      points,
                                                      count,
                                                      tension));
    }

    Status AddCurve(IN const Point* points, 
                    IN INT count, 
                    IN INT offset,
                    IN INT numberOfSegments, 
                    IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathCurve3I(nativePath,
                                                      points,
                                                      count,
                                                      offset,
                                                      numberOfSegments,
                                                      tension));
    }

    // float version
    Status AddClosedCurve(IN const PointF* points, 
                          IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathClosedCurve(nativePath,
                                                            points,
                                                            count));
    }

    Status AddClosedCurve(IN const PointF* points, 
                          IN INT count, 
                          IN REAL tension)
    {
        return SetStatus(DllExports::GdipAddPathClosedCurve2(nativePath,
                                                             points,
                                                             count,
                                                             tension));
    }

    // integer version
    Status AddClosedCurve(IN const Point* points, 
                          IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathClosedCurveI(nativePath,
                                                            points,
                                                            count));
    }


    Status AddClosedCurve(IN const Point* points, 
                          IN INT count,
                          IN REAL tension)
    {
       return SetStatus(DllExports::GdipAddPathClosedCurve2I(nativePath,
                                                             points,
                                                             count,
                                                             tension));
    }


    /**
     * Add closed shapes to the path object
     */

    // float version
    Status AddRectangle(IN const RectF& rect)
    {
        return SetStatus(DllExports::GdipAddPathRectangle(nativePath,
                                                          rect.X,
                                                          rect.Y,
                                                          rect.Width,
                                                          rect.Height));
    }

    Status AddRectangles(IN const RectF* rects, 
                         IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathRectangles(nativePath,
                                                           rects,
                                                           count));
    }

    // integer version
    Status AddRectangle(IN const Rect& rect)
    {
        return SetStatus(DllExports::GdipAddPathRectangleI(nativePath,
                                                          rect.X,
                                                          rect.Y,
                                                          rect.Width,
                                                          rect.Height));
    }

    Status AddRectangles(IN const Rect* rects, INT count)
    {
        return SetStatus(DllExports::GdipAddPathRectanglesI(nativePath,
                                                           rects,
                                                           count));
    }

    // float version
    Status AddEllipse(IN const RectF& rect)
    {
        return AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status AddEllipse(IN REAL x, 
                      IN REAL y, 
                      IN REAL width, 
                      IN REAL height)
    {
        return SetStatus(DllExports::GdipAddPathEllipse(nativePath,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    // integer version
    Status AddEllipse(IN const Rect& rect)
    {
        return AddEllipse(rect.X, rect.Y, rect.Width, rect.Height);
    }

    Status AddEllipse(IN INT x, 
                      IN INT y, 
                      IN INT width, 
                      IN INT height)
    {
        return SetStatus(DllExports::GdipAddPathEllipseI(nativePath,
                                                        x,
                                                        y,
                                                        width,
                                                        height));
    }

    // float version
    Status AddPie(IN const RectF& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddPie(rect.X, rect.Y, rect.Width, rect.Height, startAngle,
                      sweepAngle);
    }

    Status AddPie(IN REAL x, 
                  IN REAL y, 
                  IN REAL width, 
                  IN REAL height, 
                  IN REAL startAngle,
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathPie(nativePath, x, y, width, height,
                                      startAngle, sweepAngle));
    }

    // integer version
    Status AddPie(IN const Rect& rect, 
                  IN REAL startAngle, 
                  IN REAL sweepAngle)
    {
        return AddPie(rect.X,
                      rect.Y,
                      rect.Width,
                      rect.Height,
                      startAngle,
                      sweepAngle);
    }

    Status AddPie(IN INT x, 
                  IN INT y, 
                  IN INT width, 
                  IN INT height, 
                  IN REAL startAngle,
                  IN REAL sweepAngle)
    {
        return SetStatus(DllExports::GdipAddPathPieI(nativePath,
                                                    x,
                                                    y,
                                                    width,
                                                    height,
                                                    startAngle,
                                                    sweepAngle));
    }

    // float version
    Status AddPolygon(IN const PointF* points, 
                      IN INT count)
    {
        return SetStatus(DllExports::GdipAddPathPolygon(nativePath, points, count));
    }

    // integer version
    Status AddPolygon(IN const Point* points, 
                      IN INT count)
    {
       return SetStatus(DllExports::GdipAddPathPolygonI(nativePath, points, count));
    }

    Status AddPath(IN const GraphicsPath* addingPath, 
                   IN BOOL connect)
    {
        GpPath* nativePath2 = NULL;
        if(addingPath)
            nativePath2 = addingPath->nativePath;

        return SetStatus(DllExports::GdipAddPathPath(nativePath, nativePath2, connect));
    }

    // AddString point version

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // In world units
        IN const PointF        &origin,
        IN const StringFormat  *format
    )
    {
        RectF rect(origin.X, origin.Y, 0.0f, 0.0f);

        return SetStatus(DllExports::GdipAddPathString(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &rect,
            format ? format->nativeFormat : NULL
        ));
    }

    // AddString rectangle version

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // In world units
        IN const RectF         &layoutRect,
        IN const StringFormat  *format
    )
    {
        return SetStatus(DllExports::GdipAddPathString(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &layoutRect,
            format ? format->nativeFormat : NULL
        ));
    }

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // In world units
        IN const Point         &origin,
        IN const StringFormat  *format
    )
    {
        Rect rect(origin.X, origin.Y, 0, 0);

        return SetStatus(DllExports::GdipAddPathStringI(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &rect,
            format ? format->nativeFormat : NULL
        ));
    }

    // AddString rectangle version

    Status AddString(
        IN const WCHAR         *string,
        IN INT                  length,
        IN const FontFamily    *family,
        IN INT                  style,
        IN REAL                 emSize,  // In world units
        IN const Rect          &layoutRect,
        IN const StringFormat  *format
    )
    {
        return SetStatus(DllExports::GdipAddPathStringI(
            nativePath,
            string,
            length,
            family ? family->nativeFamily : NULL,
            style,
            emSize,
            &layoutRect,
            format ? format->nativeFormat : NULL
        ));
    }
    
    /**
     * Transforms the path object
     */
    Status Transform(IN const Matrix* matrix)
    {
        if(matrix)
            return SetStatus(DllExports::GdipTransformPath(nativePath, matrix->nativeMatrix));
        else
            return Ok;  // No need to transform.
    }

    /**
     * Get the bounds of the path object with the given transform.
     * This is not always the tightest bounds.
     *
     * Defined in GdiplusGraphics.h.
     */
    Status GetBounds(OUT RectF* bounds, 
                     IN const Matrix* matrix = NULL, 
                     IN const Pen* pen = NULL) const;

    // integer version (defined in GdiplusGraphics.h)
    Status GetBounds(OUT Rect* bounds,
                     IN const Matrix* matrix = NULL, 
                     IN const Pen* pen = NULL) const;

    /**
     * Flatten the path object
     * Once this is called, the resultant path is made of line segments and
     * the original path information is lost.
     * When matrix = NULL, the identity matrix is assumed.
     */
    Status Flatten(IN const Matrix* matrix = NULL, 
                   IN REAL flatness = 0.25f)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipFlattenPath(nativePath, nativeMatrix, flatness));
    }

    /**
     * Widen the path object
     * When removeSelfIntersects is TRUE, this returns the widened path
     * without self intersections.
     * When it is FALSE, it returns the widened path with selfintersections.
     * The latter is faster and is usually safficient for filling.
     */
    Status Widen(IN const Pen* pen, 
                 IN const Matrix* matrix = NULL,
                 IN BOOL removeSelfIntersects = TRUE)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipWidenPathWithMinimumResolutions(nativePath, pen->nativePen,
            0, 0, nativeMatrix, removeSelfIntersects));
    }

    /**
     * Widen the path object
     * This is equivalent to Widen() method except that
     * The widths of the widened path are larger than the given
     * minimum resolutions in x and y coordinates after the transform.
     * This is usefull when widening a path with the limited device resolutions.
     */

    Status Widen(IN const Pen* pen, 
                 IN REAL minXres, 
                 IN REAL minYres, 
                 IN const Matrix* matrix = NULL,
                 IN BOOL removeSelfIntersects = TRUE)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipWidenPathWithMinimumResolutions(nativePath, pen->nativePen,
            minXres, minYres, nativeMatrix, removeSelfIntersects));
    }

    /**
     * Warp the path object
     * Once this is called, the resultant path is made of line segments and
     * the original path information is lost.
     * When matrix = NULL, the identity matrix is assumed.
     */
    Status Warp(IN const PointF* destPoints, 
                IN INT count,
                IN const RectF& srcRect, 
                IN const Matrix* matrix = NULL,
                IN WarpMode warpMode = WarpModePerspective,
                IN REAL flatness = 0.25f)
    {
        GpMatrix* nativeMatrix = NULL;
        if(matrix)
            nativeMatrix = matrix->nativeMatrix;

        return SetStatus(DllExports::GdipWarpPath(
                                        nativePath,
                                        nativeMatrix,
                                        destPoints,
                                        count,
                                        srcRect.X,
                                        srcRect.Y,
                                        srcRect.Width,
                                        srcRect.Height,
                                        warpMode,
                                        flatness));
    }

    /**
     * Return the number of points in the current path
     */
    INT GetPointCount() const
    {
        INT count = 0;

        SetStatus(DllExports::GdipGetPointCount(nativePath, &count));

        return count;
    }

    /**
     * Return the path point type information
     */
    Status GetPathTypes(OUT BYTE* types, 
                        IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathTypes(nativePath, types, count));
    }

    /**
     * Return the path point coordinate information
     * @notes Should there be PathData that contains types[] and points[]
     *        for get & set purposes.
     */
    Status GetPathPoints(OUT PointF* points, 
                         IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathPoints(nativePath, points, count));
    }

    // integer version
    Status GetPathPoints(OUT Point* points, 
                         IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathPointsI(nativePath, points, count));
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

    /**
     * Hit testing operations
     *
     * inline implementation is in gdiplusgraphics.h.
     */

    BOOL IsVisible(IN const PointF& point, 
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(point.X, point.Y, g);
    }
    
    BOOL IsVisible(IN REAL x, 
                   IN REAL y, 
                   IN const Graphics* g = NULL) const;

    BOOL IsVisible(IN const Point& point,
                   IN const Graphics* g = NULL) const
    {
        return IsVisible(point.X, point.Y, g);
    }

    BOOL IsVisible(IN INT x, 
                   IN INT y, 
                   IN const Graphics* g = NULL) const;
    
    BOOL IsOutlineVisible(IN const PointF& point,
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const
    {
        return IsOutlineVisible(point.X, point.Y, pen, g);
    }

    BOOL IsOutlineVisible(IN REAL x, 
                          IN REAL y, 
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const;

    BOOL IsOutlineVisible(IN const Point& point,
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const
    {
        return IsOutlineVisible(point.X, point.Y, pen, g);
    }
    
    BOOL IsOutlineVisible(IN INT x, 
                          IN INT y, 
                          IN const Pen* pen, 
                          IN const Graphics* g = NULL) const;

protected:
    GraphicsPath(const GraphicsPath& path)
    {
        path;
        SetStatus(NotImplemented);
        SetNativePath(NULL);
    }

    GraphicsPath& operator=(const GraphicsPath& path)
    {
        path;
        SetStatus(NotImplemented);
        return *this;
    }

    GraphicsPath(GpPath* nativePath)
    {
        lastResult = Ok;
        SetNativePath(nativePath);
    }

    VOID SetNativePath(GpPath *nativePath)
    {
        this->nativePath = nativePath;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpPath* nativePath;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// GraphisPathIterator class
//--------------------------------------------------------------------------

class GraphicsPathIterator : public GdiplusBase
{
public:

    GraphicsPathIterator(IN const GraphicsPath* path)
    {
        GpPath* nativePath = NULL;
        if(path)
            nativePath = path->nativePath;

        GpPathIterator *iter = NULL;
        lastResult = DllExports::GdipCreatePathIter(&iter, nativePath);
        SetNativeIterator(iter);
    }

    ~GraphicsPathIterator()
    {
        DllExports::GdipDeletePathIter(nativeIterator);
    }


    INT NextSubpath(OUT INT* startIndex,
                    OUT INT* endIndex,
                    OUT BOOL* isClosed)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextSubpath(nativeIterator,
            &resultCount, startIndex, endIndex, isClosed));

        return resultCount;
    }


    INT NextSubpath(IN const GraphicsPath* path, 
                    OUT BOOL* isClosed)
    {
        GpPath* nativePath = NULL;

        INT resultCount;

        if(path)
            nativePath= path->nativePath;

        SetStatus(DllExports::GdipPathIterNextSubpathPath(nativeIterator,
            &resultCount, nativePath, isClosed));

        return resultCount;
    }

    INT NextPathType(OUT BYTE* pathType, 
                     OUT INT* startIndex, 
                     OUT INT* endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextPathType(nativeIterator,
            &resultCount, pathType, startIndex, endIndex));

        return resultCount;
    }

    INT NextMarker(OUT INT* startIndex, 
                   OUT INT* endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterNextMarker(nativeIterator,
            &resultCount, startIndex, endIndex));

        return resultCount;
    }


    INT NextMarker(IN const GraphicsPath* path)
    {
        GpPath* nativePath = NULL;

        INT resultCount;

        if(path)
            nativePath= path->nativePath;

        SetStatus(DllExports::GdipPathIterNextMarkerPath(nativeIterator,
            &resultCount, nativePath));

        return resultCount;
    }

    INT GetCount() const
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterGetCount(nativeIterator, &resultCount));

        return resultCount;
    }

    INT GetSubpathCount() const
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterGetSubpathCount(nativeIterator, &resultCount));

        return resultCount;
    }

    BOOL HasCurve() const
    {
        BOOL hasCurve;

        SetStatus(DllExports::GdipPathIterHasCurve(nativeIterator, &hasCurve));

        return hasCurve;
    }

    VOID Rewind()
    {
        SetStatus(DllExports::GdipPathIterRewind(nativeIterator));
    }

    INT Enumerate(OUT PointF *points,
                  OUT BYTE *types, 
                  IN INT count)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterEnumerate(nativeIterator,
            &resultCount, points, types, count));

        return resultCount;
    }

    INT CopyData(OUT PointF* points, 
                 OUT BYTE* types,
                 IN INT startIndex, 
                 IN INT endIndex)
    {
        INT resultCount;

        SetStatus(DllExports::GdipPathIterCopyData(nativeIterator,
            &resultCount, points, types, startIndex, endIndex));

        return resultCount;
    }

    Status GetLastStatus() const
    {
        Status lastStatus = lastResult;
        lastResult = Ok;

        return lastStatus;
    }

protected:
    VOID SetNativeIterator(GpPathIterator *nativeIterator)
    {
        this->nativeIterator = nativeIterator;
    }

    Status SetStatus(Status status) const
    {
        if (status != Ok)
            return (lastResult = status);
        else
            return status;
    }

protected:
    GpPathIterator* nativeIterator;
    mutable Status lastResult;
};


//--------------------------------------------------------------------------
// Represent polygon gradient brush object
//--------------------------------------------------------------------------

class PathGradientBrush : public Brush
{
public:
    friend class Pen;

    PathGradientBrush(
        IN const PointF* points,
        IN INT count,
        IN WrapMode wrapMode = WrapModeClamp)
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradient(
                                        points, count,
                                        wrapMode, &brush);
        SetNativeBrush(brush);
    }

    PathGradientBrush(
        IN const Point* points,
        IN INT count,
        IN WrapMode wrapMode = WrapModeClamp)
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradientI(
                                        points, count,
                                        wrapMode, &brush);

        SetNativeBrush(brush);
    }

    PathGradientBrush(
        IN const GraphicsPath* path
        )
    {
        GpPathGradient *brush = NULL;

        lastResult = DllExports::GdipCreatePathGradientFromPath(
                                        path->nativePath, &brush);
        SetNativeBrush(brush);
    }

    // Get/set colors

    Status GetCenterColor(OUT Color* color) const
    {
        ARGB argb;
        
        if (color == NULL) 
        {
            return SetStatus(InvalidParameter);
        }

        SetStatus(DllExports::GdipGetPathGradientCenterColor(
                       (GpPathGradient*) nativeBrush, &argb));

        color->SetValue(argb);

        return lastResult;
    }

    Status SetCenterColor(IN const Color& color)
    {
        SetStatus(DllExports::GdipSetPathGradientCenterColor(
                       (GpPathGradient*) nativeBrush,
                       color.GetValue()));

        return lastResult;
    }

    INT GetPointCount() const
    {
        INT count;

        SetStatus(DllExports::GdipGetPathGradientPointCount(
                       (GpPathGradient*) nativeBrush, &count));

        return count;
    }

    INT GetSurroundColorCount() const
    {
        INT count;

        SetStatus(DllExports::GdipGetPathGradientSurroundColorCount(
                       (GpPathGradient*) nativeBrush, &count));

        return count;
    }

    Status GetSurroundColors(OUT Color* colors, 
                             IN OUT INT* count) const
    {
        if(colors == NULL || count == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        INT count1;
        
        SetStatus(DllExports::GdipGetPathGradientSurroundColorCount(
                        (GpPathGradient*) nativeBrush, &count1));

        if(lastResult != Ok)
            return lastResult;

        if((*count < count1) || (count1 <= 0))
            return SetStatus(InsufficientBuffer);

        ARGB* argbs = (ARGB*) new ARGB[count1];
        if(argbs == NULL)
            return SetStatus(OutOfMemory);

        SetStatus(DllExports::GdipGetPathGradientSurroundColorsWithCount(
                    (GpPathGradient*)nativeBrush, argbs, &count1));

        if(lastResult == Ok)
        {
            for(INT i = 0; i < count1; i++)
            {
                colors[i].SetValue(argbs[i]);
            }        
            *count = count1;
        }

        delete [] argbs;
        return lastResult;
    }

    Status SetSurroundColors(IN const Color* colors, 
                             IN OUT INT* count)
    {
        if(colors == NULL || count == NULL)
        {
            return SetStatus(InvalidParameter);
        }

        INT count1 = GetPointCount();

        if((*count > count1) || (count1 <= 0))
            return SetStatus(InvalidParameter);

        count1 = *count;

        ARGB* argbs = (ARGB*) new ARGB[count1];
        if(argbs == NULL)
            return SetStatus(OutOfMemory);

        for(INT i = 0; i < count1; i++)
        {
            argbs[i] = colors[i].GetValue();
        }

        SetStatus(DllExports::GdipSetPathGradientSurroundColorsWithCount(
                    (GpPathGradient*)nativeBrush, argbs, &count1));

        if(lastResult == Ok)
            *count = count1;

        delete [] argbs;

        return lastResult;
    }

    Status GetGraphicsPath(OUT GraphicsPath* path) const
    {
        if(path == NULL)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipGetPathGradientPath(
                    (GpPathGradient*)nativeBrush, path->nativePath));
    }

    Status SetGraphicsPath(IN const GraphicsPath* path)
    {
        if(path == NULL)
            return SetStatus(InvalidParameter);

        return SetStatus(DllExports::GdipSetPathGradientPath(
                    (GpPathGradient*)nativeBrush, path->nativePath));
    }

    Status GetCenterPoint(OUT PointF* point) const
    {
        return SetStatus(DllExports::GdipGetPathGradientCenterPoint(
                                (GpPathGradient*)nativeBrush,
                                point));
    }


    Status GetCenterPoint(OUT Point* point) const
    {
        return SetStatus(DllExports::GdipGetPathGradientCenterPointI(
                                (GpPathGradient*)nativeBrush,
                                point));
    }

    Status SetCenterPoint(IN const PointF& point)
    {
        return SetStatus(DllExports::GdipSetPathGradientCenterPoint(
                                (GpPathGradient*)nativeBrush,
                                &point));
    }

    Status SetCenterPoint(IN const Point& point)
    {
        return SetStatus(DllExports::GdipSetPathGradientCenterPointI(
                                (GpPathGradient*)nativeBrush,
                                &point));
    }

    Status GetRectangle(OUT RectF* rect) const
    {
        return SetStatus(DllExports::GdipGetPathGradientRect(
                            (GpPathGradient*)nativeBrush, rect));
    }

    Status GetRectangle(OUT Rect* rect) const
    {
        return SetStatus(DllExports::GdipGetPathGradientRectI(
                            (GpPathGradient*)nativeBrush, rect));
    }

    // Gamma correction.

    Status SetGammaCorrection(IN BOOL useGammaCorrection)
    {
        return SetStatus(DllExports::GdipSetPathGradientGammaCorrection(
            (GpPathGradient*)nativeBrush, useGammaCorrection));
    }

    BOOL GetGammaCorrection() const
    {
        BOOL useGammaCorrection;

        SetStatus(DllExports::GdipGetPathGradientGammaCorrection(
            (GpPathGradient*)nativeBrush, &useGammaCorrection));

        return useGammaCorrection;
    }

    INT GetBlendCount() const
    {
       INT count = 0;

       SetStatus(DllExports::GdipGetPathGradientBlendCount(
                           (GpPathGradient*) nativeBrush, &count));

       return count;
    }

    Status GetBlend(OUT REAL* blendFactors,
                    OUT REAL* blendPositions,
                    IN INT count) const
    {
        return SetStatus(DllExports::GdipGetPathGradientBlend(
                            (GpPathGradient*)nativeBrush,
                            blendFactors, blendPositions, count));
    }

    Status SetBlend(IN REAL* blendFactors, 
                    IN REAL* blendPositions, 
                    IN INT count)
    {
        return SetStatus(DllExports::GdipSetPathGradientBlend(
                            (GpPathGradient*)nativeBrush,
                            blendFactors, blendPositions, count));
    }

    INT GetInterpolationColorCount() const
    {
       INT count = 0;

       SetStatus(DllExports::GdipGetPathGradientPresetBlendCount(
                        (GpPathGradient*) nativeBrush, &count));

       return count;
    }

    Status SetInterpolationColors(IN const Color* presetColors,
                                  IN REAL* blendPositions, 
                                  IN INT count)
    {
        if ((count <= 0) || !presetColors) 
        {
            return SetStatus(InvalidParameter);
        }

        ARGB* argbs = (ARGB*) new ARGB[count];
        if(argbs)
        {
            for(INT i = 0; i < count; i++)
            {
                argbs[i] = presetColors[i].GetValue();
            }

            Status status = SetStatus(DllExports::GdipSetPathGradientPresetBlend(
                                    (GpPathGradient*) nativeBrush,
                                    argbs,
                                    blendPositions,
                                    count));
            delete[] argbs;
            return status;
        }
        else
        {
            return SetStatus(OutOfMemory);
        }
    }

    Status GetInterpolationColors(OUT Color* presetColors,
                                  OUT REAL* blendPositions, 
                                  IN INT count) const
    {
        if ((count <= 0) || !presetColors) 
        {
            return SetStatus(InvalidParameter);
        }

        ARGB* argbs = (ARGB*) new ARGB[count];
        
        if (!argbs)
        {
            return SetStatus(OutOfMemory);
        }

        GpStatus status = SetStatus(DllExports::GdipGetPathGradientPresetBlend(
                                (GpPathGradient*)nativeBrush,
                                argbs,
                                blendPositions,
                                count));
        
        for(INT i = 0; i < count; i++)
        {
            presetColors[i] = Color(argbs[i]);
        }
        delete [] argbs;
        
        return status;
    }

    Status SetBlendBellShape(IN REAL focus, 
                             IN REAL scale = 1.0)
    {
        return SetStatus(DllExports::GdipSetPathGradientSigmaBlend(
                            (GpPathGradient*)nativeBrush, focus, scale));
    }

    #ifdef DCR_USE_NEW_145135
    Status SetBlendTriangularShape(
        IN REAL focus,
        IN REAL scale = 1.0
    )
    #else
    Status SetBlendTrianglarShape(IN REAL focus,
                                  IN REAL scale = 1.0)
    #endif                              
    {
        return SetStatus(DllExports::GdipSetPathGradientLinearBlend(
                            (GpPathGradient*)nativeBrush, focus, scale));
    }

    /**
     * Get/set brush transform
     */
    Status GetTransform(OUT Matrix *matrix) const
    {
        return SetStatus(DllExports::GdipGetPathGradientTransform(
                            (GpPathGradient*) nativeBrush, matrix->nativeMatrix));
    }

    Status SetTransform(IN const Matrix* matrix)
    {
        return SetStatus(DllExports::GdipSetPathGradientTransform(
                            (GpPathGradient*) nativeBrush, matrix->nativeMatrix));
    }

    Status ResetTransform()
    {
        return SetStatus(DllExports::GdipResetPathGradientTransform((GpPathGradient*)nativeBrush));
    }

    Status MultiplyTransform(IN Matrix* matrix,
                             IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipMultiplyPathGradientTransform((GpPathGradient*)nativeBrush,
                                                                matrix->nativeMatrix,
                                                                order));
    }

    Status TranslateTransform(IN REAL dx, 
                              IN REAL dy,
                              IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipTranslatePathGradientTransform((GpPathGradient*)nativeBrush,
                                                               dx, dy, order));
    }

    Status ScaleTransform(IN REAL sx, 
                          IN REAL sy,
                          IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipScalePathGradientTransform((GpPathGradient*)nativeBrush,
                                                             sx, sy, order));
    }

    Status RotateTransform(IN REAL angle, 
                           IN MatrixOrder order = MatrixOrderPrepend)
    {
        return SetStatus(DllExports::GdipRotatePathGradientTransform((GpPathGradient*)nativeBrush,
                                                              angle, order));
    }

    /**
     * Get/set brush focus scales
     */
    Status GetFocusScales(OUT REAL* xScale, 
                          OUT REAL* yScale) const
    {
        return SetStatus(DllExports::GdipGetPathGradientFocusScales(
                            (GpPathGradient*) nativeBrush, xScale, yScale));
    }

    Status SetFocusScales(IN REAL xScale,
                          IN REAL yScale)
    {
        return SetStatus(DllExports::GdipSetPathGradientFocusScales(
                            (GpPathGradient*) nativeBrush, xScale, yScale));
    }

    /**
     * Get/set brush wrapping mode
     */
    WrapMode GetWrapMode() const
    {
        WrapMode wrapMode;

        SetStatus(DllExports::GdipGetPathGradientWrapMode(
                     (GpPathGradient*) nativeBrush, &wrapMode));

        return wrapMode;
    }

    Status SetWrapMode(IN WrapMode wrapMode)
    {
        return SetStatus(DllExports::GdipSetPathGradientWrapMode(
                            (GpPathGradient*) nativeBrush, wrapMode));
    }

protected:

    PathGradientBrush()
    {
    }
};


#endif // !_GRAPHICSPATH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplusstringformat.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   String format specification for DrawString and text APIs
*
* Revision History:
*
*   08/05/1999 dbrown
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSSTRINGFORMAT_H
#define _GDIPLUSSTRINGFORMAT_H

class StringFormat : public GdiplusBase
{
public:
    friend class Graphics;
    friend class GraphicsPath;

    StringFormat(
        IN INT     formatFlags,
        IN LANGID  language = LANG_NEUTRAL
    )
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCreateStringFormat(
            formatFlags,
            language,
            &nativeFormat
        );
    }

    static const StringFormat *GenericDefault();
    static const StringFormat *GenericTypographic();

    // Constructor based on existing string format

    StringFormat(
        IN const StringFormat *format
    )
    {
        lastError = DllExports::GdipCloneStringFormat(
            format->nativeFormat,
            &nativeFormat
        );
    }

    StringFormat *Clone() const
    {
        GpStringFormat *clonedStringFormat = NULL;

        lastError = DllExports::GdipCloneStringFormat(
            nativeFormat,
            &clonedStringFormat
        );

        if (lastError == Ok)
            return new StringFormat(clonedStringFormat, lastError);
        else
            return NULL;
    }

    ~StringFormat()
    {
        DllExports::GdipDeleteStringFormat(nativeFormat);
    }

    Status SetFormatFlags(IN INT flags)
    {
        return SetStatus(DllExports::GdipSetStringFormatFlags(
            nativeFormat,
            flags
        ));
    }

    INT GetFormatFlags() const
    {
        INT flags;
        SetStatus(DllExports::GdipGetStringFormatFlags(nativeFormat, &flags));
        return flags;
    }

    Status SetLineSpacing(
        IN REAL        amount = 1.0f,
        IN LineSpacing method = LineSpacingRecommended
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatLineSpacing(
            nativeFormat,
            amount,
            method
        ));
    }

    Status SetAlignment(IN StringAlignment align)
    {
        return SetStatus(DllExports::GdipSetStringFormatAlign(
            nativeFormat,
            align
        ));
    }

    StringAlignment GetAlignment() const
    {
        StringAlignment alignment;
        SetStatus(DllExports::GdipGetStringFormatAlign(
            nativeFormat,
            &alignment
        ));
        return alignment;
    }

    Status SetLineAlignment(IN StringAlignment align)
    {
        return SetStatus(DllExports::GdipSetStringFormatLineAlign(
            nativeFormat,
            align
        ));
    }

    StringAlignment GetLineAlignment() const
    {
        StringAlignment alignment;
        SetStatus(DllExports::GdipGetStringFormatLineAlign(
            nativeFormat,
            &alignment
        ));
        return alignment;
    }

    Status SetHotkeyPrefix(IN HotkeyPrefix hotkeyPrefix)
    {
        return SetStatus(DllExports::GdipSetStringFormatHotkeyPrefix(
            nativeFormat,
            (INT)hotkeyPrefix
        ));
    }

    HotkeyPrefix GetHotkeyPrefix() const
    {
        HotkeyPrefix hotkeyPrefix;
        SetStatus(DllExports::GdipGetStringFormatHotkeyPrefix(
            nativeFormat,
            (INT*)&hotkeyPrefix
        ));
        return hotkeyPrefix;
    }

    Status SetTabStops(
        IN REAL    firstTabOffset,
        IN INT     count,
        IN REAL    *tabStops
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatTabStops(
            nativeFormat,
            firstTabOffset,
            count,
            tabStops
        ));
    }

    INT GetTabStopCount() const
    {
        INT count;
        SetStatus(DllExports::GdipGetStringFormatTabStopCount(nativeFormat, &count));
        return count;
    }

    Status GetTabStops(
        IN INT     count,
        OUT REAL   *firstTabOffset,
        OUT REAL   *tabStops
    ) const
    {
        return SetStatus(DllExports::GdipGetStringFormatTabStops(
            nativeFormat,
            count,
            firstTabOffset,
            tabStops
        ));
    }

#ifdef DCR_USE_NEW_146933
    Status SetDigitSubstitution(
        IN LANGID                language, 
        IN StringDigitSubstitute substitute
    )
    {
        return SetStatus(DllExports::GdipSetStringFormatDigitSubstitution(
            nativeFormat,        
            language,
            substitute
        ));
    }

    LANGID GetDigitSubstitutionLanguage(
    )
    {
        LANGID language;
        SetStatus(DllExports::GdipGetStringFormatDigitSubstitution(
            nativeFormat,        
            &language,
            NULL
        ));
        return language;
    }
    
    StringDigitSubstitute GetDigitSubstitutionMethod(
    )
    {
        StringDigitSubstitute substitute;
        SetStatus(DllExports::GdipGetStringFormatDigitSubstitution(
            nativeFormat,        
            NULL,
            &substitute
        ));
        return substitute;
    }
#endif // DCR_USE_NEW_146933

    // String trimming. How to handle more text than can be displayed
    // in the limits available.

    Status SetTrimming(IN StringTrimming trimming)
    {
        return SetStatus(DllExports::GdipSetStringFormatTrimming(
            nativeFormat,
            trimming
        ));
    }

    StringTrimming StringFormat::GetTrimming() const
    {
        StringTrimming trimming;
        SetStatus(DllExports::GdipGetStringFormatTrimming(
            nativeFormat,
            &trimming
        ));
        return trimming;
    }

    // GetLastStatus - return last error code and clear error code

    Status GetLastStatus() const
    {
        Status lastStatus = lastError;
        lastError = Ok;

        return lastStatus;
    }


    // Empty constructor used for static generic values

    StringFormat() :
        nativeFormat (NULL),
        lastError    (NotImplemented)
    {}


protected:

    Status SetStatus(GpStatus newStatus) const
    {
        if (newStatus == Ok)
        {
            return Ok;
        }
        else
        {
            return lastError = newStatus;
        }
    }


// Not allowed and move to private
    StringFormat(const StringFormat &source)
    {
        nativeFormat = NULL;
        lastError = DllExports::GdipCloneStringFormat(
            source.nativeFormat,
            &nativeFormat
        );
    }

    StringFormat& operator=(const StringFormat &source)
    {
        DllExports::GdipDeleteStringFormat(nativeFormat);
        lastError = DllExports::GdipCloneStringFormat(
            source.nativeFormat,
            &nativeFormat
        );
        return *this;
    }


    // private constructor for copy
    StringFormat(GpStringFormat * clonedStringFormat, Status status)
    {
        lastError = status;
        nativeFormat = clonedStringFormat;

    }

    GpStringFormat *nativeFormat;
    mutable Status  lastError;
};

// Generic constant string formats.

static BYTE GenericTypographicStringFormatBuffer[sizeof(StringFormat)] = {0};
static BYTE GenericDefaultStringFormatBuffer[sizeof(StringFormat)] = {0};

static StringFormat *GenericTypographicStringFormat = NULL;
static StringFormat *GenericDefaultStringFormat     = NULL;

// Define the generic string formats


inline const StringFormat *StringFormat::GenericDefault()
{
    if (GenericDefaultStringFormat != NULL)
    {
        return GenericDefaultStringFormat;
    }

    GenericDefaultStringFormat =
        (StringFormat*)GenericDefaultStringFormatBuffer;

    GenericDefaultStringFormat->lastError =
        DllExports::GdipStringFormatGetGenericDefault(
            &(GenericDefaultStringFormat->nativeFormat)
        );

    return GenericDefaultStringFormat;
}

inline const StringFormat *StringFormat::GenericTypographic()
{
    if (GenericTypographicStringFormat != NULL)
    {
        return GenericTypographicStringFormat;
    }

    GenericTypographicStringFormat =
        (StringFormat*)GenericTypographicStringFormatBuffer;

    GenericTypographicStringFormat->lastError =
        DllExports::GdipStringFormatGetGenericTypographic(
            &GenericTypographicStringFormat->nativeFormat
        );

    return GenericTypographicStringFormat;
}

#endif // !_GDIPLUSSTRINGFORMAT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\icecap.h ===
//-----------------------------------------------------------------------------
//
//  File: Icecap.h
//  Copyright (C) 1997-1998 Microsoft Corporation
//  All rights reserved.
//
//  This header file is part of IceCAP 4.0.0382.  It is
//  MICROSOFT CONFIDENTIAL, and should not be distributed except under NDA.
//
//-----------------------------------------------------------------------------

// ICECAP.H
// interface to the Datalocality APIs

#ifndef __ICECAP_H__
#define __ICECAP_H__

#ifndef DONTUSEICECAPLIB
#pragma comment(lib, "IceCAP.lib")
#endif	// USEICECAPLIB

#ifdef __cplusplus
extern "C" {
#endif

// Defines for Levels and Id's
#define PROFILE_GLOBALLEVEL 1
#define PROFILE_PROCESSLEVEL 2
#define PROFILE_THREADLEVEL 3
#define PROFILE_CURRENTID ((unsigned long)0xFFFFFFFF)

// Start/Stop Api's
int _declspec(dllimport) _stdcall StopProfile(int nLevel, unsigned long dwId);
int _declspec(dllimport) _stdcall StartProfile(int nLevel, unsigned long dwId);

// Suspend/Resume Api's
int _declspec(dllimport) _stdcall SuspendProfile(int nLevel, unsigned long dwId);
int _declspec(dllimport) _stdcall ResumeProfile(int nLevel, unsigned long dwId);

// Mark Api's
int _declspec(dllimport) _stdcall MarkProfile(long lMarker);

// xxxProfile return codes
#define PROFILE_OK 0						// xxxProfile call successful
#define PROFILE_ERROR_NOT_YET_IMPLEMENTED 1 // api or level,id combination not supported yet
#define PROFILE_ERROR_MODE_NEVER 2		// mode was never when called
#define PROFILE_ERROR_LEVEL_NOEXIST 3	// level doesn't exist
#define PROFILE_ERROR_ID_NOEXIST 4		// id doesn't exist

// MarkProfile return codes
#define MARK_OK			0			// Mark was taken successfully
#define MARK_ERROR_MODE_NEVER	1	// Profiling was never when MarkProfile called
#define MARK_ERROR_PRO_OFF	2		// old define until tests fixed
#define MARK_ERROR_MODE_OFF	2		// Profiling was off when MarkProfile called
#define MARK_ERROR_MARKER_RESERVED 3	// Mark value passed is a reserved value

// Icecap 3.x Compatibility defines
#define StartCAP() StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define StopCAP() StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define SuspendCAP() SuspendProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)
#define ResumeCAP() ResumeProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID)

#define StartCAPAll() StartProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define StopCAPAll() StopProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define SuspendCAPAll() SuspendProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)
#define ResumeCAPAll() ResumeProfile(PROFILE_PROCESSLEVEL, PROFILE_CURRENTID)

#define MarkCAP(mark) MarkProfile(mark)

// DataLocality 1.x Compatibility defines
#define StartDLP() StartCAP()
#define StopDLP() StopCAP()
#define MarkDLP(mark) MarkCAP(mark)

//
// USER DEFINED COUNTER HELPERS AND TYPES
//

// COUNTER_FUNCTION_PROLOGE and EPILOGE
//
// These functions are supplied to protect the state of registers
// that the IceCAP collection probes rely on.  We did everything we
// could to eliminate instructions during collection.  Your mission,
// if you choose to accept it, is the same.
//
#define COUNTER_FUNCTION_PROLOGE	_asm push ecx _asm push ebx _asm push ebp
#define COUNTER_FUNCTION_EPILOGE	_asm pop ebp _asm pop ebx _asm pop ecx _asm ret

#ifndef USER_COUNTER_INFO_DEFINED
#define USER_COUNTER_INFO_DEFINED

// CONSTS AND ENUMS
//

// UserCounterType
//
// These enumerations describe how the counter works.
//
// MonotonicallyIncreasing	--	This describes a counter that will increment
//								by one each time some 'event' occurs.  An
//								example would be a counter that tracks the
//								number of memory allocations.  Each allocation
//								increments the number by one.
//
// MonotonicallyDecreasint	--	This describes a counter that will decrement
//								by one each time some 'event' occurs.  An
//								example would be a counter that tracks a limited
//								resource.  Each use of the resource decrements
//								the number by one.
//
// RandomIncreasing --			This describes a counter that will increase for
//								each 'event' that occurs, but by an undetermined
//								amount.  An example would be the total memory
//								allocated.  Each allocation would add it's size
//								to the counter, but each allocation being potentially
//								different, causes the counter to go up by a random
//								amount each time.
//
// RandomDecreasing --			This describes a coutner that will decrease for
//								each 'event' that occurs, but by an undetermined
//								amount.  An example would be a limited resource
//								that can be used in bunches.  Each use fo the
//								the resource would cause the number to descrease
//								by a random amount.
//
// Random --					This number can either go up, or go down.  An
//								example would be the total amount of available
//								memory, which can either go up (as memory is
//								free'd), or go down (as memory is allocated).
//
enum UserCounterType
{
	MonotonicallyIncreasing,
	MonotonicallyDecreasing,
	RandomIncreasing,
	RandomDecreasing,
	Random
};

// TYPEDEFS
//

typedef signed __int64	COUNTER, *PCOUNTER;

///////////////////////////////////////////////////////////////
// USERCOUNTERINFO
//
// This structure descibes a user defined counter so that
// IceCAP can use it during profiling runs.
//
// History:  9-21-98 BarryNo Created
//
///////////////////////////////////////////////////////////////
typedef struct _USERCOUNTERINFO
{
	char  szCounterFuncName[32];	// Name of the function
	enum UserCounterType	ct;				// Describes the type of number we will be collecting
	char szName[32];				// Name of user counter

} USERCOUNTERINFO, *PUSERCOUNTERINFO;

#endif  // USER_COUNTER_INFO_DEFINED

#ifdef __cplusplus
}
#endif

#endif // __ICECAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\imaging.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   imaging.h
*
* Abstract:
*
*   Public SDK header file for the imaging library
*
* Notes:
*
*   This is hand-coded for now. Eventually it'll be automatically
*   generated from an IDL file.
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _IMAGING_H
#define _IMAGING_H

#include "GdiplusPixelFormats.h"
#include "GdiplusImaging.h"

//
// Imaging library GUIDS:
//  image file format identifiers
//  interface and class identifers
//

#include "imgguids.h"

//
// Image Property types
//

#define TAG_TYPE_BYTE       1   // 8-bit unsigned int
#define TAG_TYPE_ASCII      2   // 8-bit byte containing one 7-bit ASCII code.
                                // NULL terminated.
#define TAG_TYPE_SHORT      3   // 16-bit unsigned int
#define TAG_TYPE_LONG       4   // 32-bit unsigned int
#define TAG_TYPE_RATIONAL   5   // Two LONGs.  The first LONG is the numerator,
                                // the second LONG expresses the denomintor.
#define TAG_TYPE_UNDEFINED  7   // 8-bit byte that can take any value depending
                                // on field definition
#define TAG_TYPE_SLONG      9   // 32-bit singed integer (2's compliment
                                // notation)
#define TAG_TYPE_SRATIONAL  10  // Two SLONGs. First is numerator, second is
                                // denominator.


//
// Image property ID tags (PROPID's from the EXIF tags)
//

#define TAG_EXIF_IFD            0x8769
#define TAG_GPS_IFD             0x8825

#define TAG_NEW_SUBFILE_TYPE    0x00FE
#define TAG_SUBFILE_TYPE        0x00FF
#define TAG_IMAGE_WIDTH         0x0100
#define TAG_IMAGE_HEIGHT        0x0101
#define TAG_BITS_PER_SAMPLE     0x0102
#define TAG_COMPRESSION         0x0103
#define TAG_PHOTOMETRIC_INTERP  0x0106
#define TAG_THRESH_HOLDING      0x0107
#define TAG_CELL_WIDTH          0x0108
#define TAG_CELL_HEIGHT         0x0109
#define TAG_FILL_ORDER          0x010A
#define TAG_DOCUMENT_NAME       0x010D
#define TAG_IMAGE_DESCRIPTION   0x010E
#define TAG_EQUIP_MAKE          0x010F
#define TAG_EQUIP_MODEL         0x0110
#define TAG_STRIP_OFFSETS       0x0111
#define TAG_ORIENTATION         0x0112
#define TAG_SAMPLES_PER_PIXEL   0x0115
#define TAG_ROWS_PER_STRIP      0x0116
#define TAG_STRIP_BYTES_COUNT   0x0117
#define TAG_MIN_SAMPLE_VALUE    0x0118
#define TAG_MAX_SAMPLE_VALUE    0x0119
#define TAG_X_RESOLUTION        0x011A  // Image resolution in width direction
#define TAG_Y_RESOLUTION        0x011B  // Image resolution in height direction
#define TAG_PLANAR_CONFIG       0x011C  // Image data arrangement
#define TAG_PAGE_NAME           0x011D
#define TAG_X_POSITION          0x011E
#define TAG_Y_POSITION          0x011F
#define TAG_FREE_OFFSET         0x0120
#define TAG_FREE_BYTE_COUNTS    0x0121
#define TAG_GRAY_RESPONSE_UNIT  0x0122
#define TAG_GRAY_RESPONSE_CURVE 0x0123
#define TAG_T4_OPTION           0x0124
#define TAG_T6_OPTION           0x0125
#define TAG_RESOLUTION_UNIT     0x0128  // Unit of X and Y resolution
#define TAG_PAGE_NUMBER         0x0129
#define TAG_TRANSFER_FUNCTION   0x012D
#define TAG_SOFTWARE_USED       0x0131
#define TAG_DATE_TIME           0x0132
#define TAG_ARTIST              0x013B
#define TAG_HOST_COMPUTER       0x013C
#define TAG_PREDICTOR           0x013D
#define TAG_WHITE_POINT         0x013E
#define TAG_PRIMAY_CHROMATICS   0x013F
#define TAG_COLOR_MAP           0x0140
#define TAG_HALFTONE_HINTS      0x0141
#define TAG_TILE_WIDTH          0x0142
#define TAG_TILE_LENGTH         0x0143
#define TAG_TILE_OFFSET         0x0144
#define TAG_TILE_BYTE_COUNTS    0x0145
#define TAG_INK_SET             0x014C
#define TAG_INK_NAMES           0x014D
#define TAG_NUMBER_OF_INKS      0x014E
#define TAG_DOT_RANGE           0x0150
#define TAG_TARGET_PRINTER      0x0151
#define TAG_EXTRA_SAMPLES       0x0152
#define TAG_SAMPLE_FORMAT       0x0153
#define TAG_SMIN_SAMPLE_VALUE   0x0154
#define TAG_SMAX_SAMPLE_VALUE   0x0155
#define TAG_TRANSFER_RANGE      0x0156

#define TAG_JPEG_PROC           0x0200
#define TAG_JPEG_INTER_FORMAT   0x0201
#define TAG_JPEG_INTER_LENGTH   0x0202
#define TAG_JPEG_RESTART_INTERVAL     0x0203
#define TAG_JPEG_LOSSLESS_PREDICTORS  0x0205
#define TAG_JPEG_POINT_TRANSFORMS     0x0206
#define TAG_JPEG_Q_TABLES       0x0207
#define TAG_JPEG_DC_TABLES      0x0208
#define TAG_JPEG_AC_TABLES      0x0209

#define TAG_YCbCr_COEFFICIENTS  0x0211
#define TAG_YCbCr_SUBSAMPLING   0x0212
#define TAG_YCbCr_POSITIONING   0x0213
#define TAG_REF_BLACK_WHITE     0x0214

// ICC profile and gamma
#define TAG_ICC_PROFILE         0x0300
#define TAG_GAMMA               0x0301
#define TAG_ICC_PROFILE_DESCRIPTOR  0x0302
#define TAG_SRGB_RENDERING_INTENT   0x0303

#define TAG_IMAGE_TITLE         0x0320

#define TAG_COPYRIGHT           0x8298

// Extra TAGs (Like Adobe Image Information tags etc.)

#define TAG_RESOLUTION_X_UNIT           0x5001
#define TAG_RESOLUTION_Y_UNIT           0x5002
#define TAG_RESOLUTION_X_LENGTH_UNIT    0x5003
#define TAG_RESOLUTION_Y_LENGTH_UNIT    0x5004
#define TAG_PRINT_FLAGS                 0x5005
#define TAG_PRINT_FLAGS_VERSION         0x5006
#define TAG_PRINT_FLAGS_CROP            0x5007
#define TAG_PRINT_FLAGS_BLEEDWIDTH      0x5008
#define TAG_PRINT_FLAGS_BLEEDWIDTHSCALE 0x5009
#define TAG_HALFTONE_LPI                0x500A
#define TAG_HALFTONE_LPI_UNIT           0x500B
#define TAG_HALFTONE_DEGREE             0x500C
#define TAG_HALFTONE_SHAPE              0x500D
#define TAG_HALFTONE_MISC               0x500E
#define TAG_HALFTONE_SCREEN             0x500F
#define TAG_JPEG_QUALITY                0x5010
#define TAG_GRID_SIZE                   0x5011
#define TAG_THUMBNAIL_FORMAT            0x5012  // 1 = JPEG, 0 = RAW RGB
#define TAG_THUMBNAIL_WIDTH             0x5013
#define TAG_THUMBNAIL_HEIGHT            0x5014
#define TAG_THUMBNAIL_COLORDEPTH        0x5015
#define TAG_THUMBNAIL_PLANES            0x5016
#define TAG_THUMBNAIL_RAWBYTES          0x5017
#define TAG_THUMBNAIL_SIZE              0x5018
#define TAG_THUMBNAIL_COMPRESSED_SIZE   0x5019
#define TAG_COLORTRANSFER_FUNCTION      0x501A
#define TAG_THUMBNAIL_DATA              0x501B  // RAW thumbnail bits in JPEG
                                                // format or RGB format depends
                                                // on TAG_THUMBNAIL_FORMAT

// Thumbnail related TAGs
                                                
#define TAG_THUMBNAIL_IMAGE_WIDTH       0x5020  // Thumbnail width
#define TAG_THUMBNAIL_IMAGE_HEIGHT      0x5021  // Thumbnail height
#define TAG_THUMBNAIL_BITS_PER_SAMPLE   0x5022  // Number of bits per component
#define TAG_THUMBNAIL_COMPRESSION       0x5023  // Compression Scheme
#define TAG_THUMBNAIL_PHOTOMETRIC_INTERP 0x5024 // Pixel composition
#define TAG_THUMBNAIL_IMAGE_DESCRIPTION 0x5025  // Image Tile
#define TAG_THUMBNAIL_EQUIP_MAKE        0x5026  // Manufacturer of Image Input
                                                // equipment
#define TAG_THUMBNAIL_EQUIP_MODEL       0x5027  // Model of Image input
                                                // equipment
#define TAG_THUMBNAIL_STRIP_OFFSETS     0x5028  // Image data location
#define TAG_THUMBNAIL_ORIENTATION       0x5029  // Orientation of image
#define TAG_THUMBNAIL_SAMPLES_PER_PIXEL 0x502A  // Number of components
#define TAG_THUMBNAIL_ROWS_PER_STRIP    0x502B  // Number of rows per strip
#define TAG_THUMBNAIL_STRIP_BYTES_COUNT 0x502C  // Bytes per compressed strip
#define TAG_THUMBNAIL_RESOLUTION_X      0x502D  // Resolution in width direction
#define TAG_THUMBNAIL_RESOLUTION_Y      0x502E  // Resolution in height direc
#define TAG_THUMBNAIL_PLANAR_CONFIG     0x502F  // Image data arrangement
#define TAG_THUMBNAIL_RESOLUTION_UNIT   0x5030  // Unit of X and Y Resolution
#define TAG_THUMBNAIL_TRANSFER_FUNCTION 0x5031  // Transfer function
#define TAG_THUMBNAIL_SOFTWARE_USED     0x5032  // Software used
#define TAG_THUMBNAIL_DATE_TIME         0x5033  // File change date and time
#define TAG_THUMBNAIL_ARTIST            0x5034  // Person who created the image
#define TAG_THUMBNAIL_WHITE_POINT       0x5035  // White point chromaticity
#define TAG_THUMBNAIL_PRIMAY_CHROMATICS 0x5036  // Chromaticities of primaries
#define TAG_THUMBNAIL_YCbCr_COEFFICIENTS 0x5037 // Color space transformation
                                                // coefficients
#define TAG_THUMBNAIL_YCbCr_SUBSAMPLING 0x5038  // Subsampling ratio of Y to C
#define TAG_THUMBNAIL_YCbCr_POSITIONING 0x5039  // Y and C position
#define TAG_THUMBNAIL_REF_BLACK_WHITE   0x503A  // Pair of black and white
                                                // reference values
#define TAG_THUMBNAIL_COPYRIGHT         0x503B  // CopyRight holder

// Special JPEG internal values

#define TAG_LUMINANCE_TABLE             0x5090
#define TAG_CHROMINANCE_TABLE           0x5091

// GIF image

#define TAG_FRAMEDELAY                  0x5100
#define TAG_LOOPCOUNT                   0x5101

// PNG Image

#define TAG_PIXEL_UNIT                  0x5110  // Unit specifier for pixel/unit
#define TAG_PIXEL_PER_UNIT_X            0x5111  // Pixels per unit in X
#define TAG_PIXEL_PER_UNIT_Y            0x5112  // Pixels per unit in Y
#define TAG_PALETTE_HISTOGRAM           0x5113  // Palette histogram

// EXIF specific tag

#define EXIF_TAG_EXPOSURE_TIME  0x829A
#define EXIF_TAG_F_NUMBER       0x829D

#define EXIF_TAG_EXPOSURE_PROG  0x8822
#define EXIF_TAG_SPECTRAL_SENSE 0x8824
#define EXIF_TAG_ISO_SPEED      0x8827
#define EXIF_TAG_OECF           0x8828

#define EXIF_TAG_VER            0x9000
#define EXIF_TAG_D_T_ORIG       0x9003 // Date & time of original
#define EXIF_TAG_D_T_DIGITIZED  0x9004 // Date & time of digital data generation

#define EXIF_TAG_COMP_CONFIG    0x9101
#define EXIF_TAG_COMP_BPP       0x9102

#define EXIF_TAG_SHUTTER_SPEED  0x9201
#define EXIF_TAG_APERATURE      0x9202
#define EXIF_TAG_BRIGHTNESS     0x9203
#define EXIF_TAG_EXPOSURE_BIAS  0x9204
#define EXIF_TAG_MAX_APERATURE  0x9205
#define EXIF_TAG_SUBJECT_DIST   0x9206
#define EXIF_TAG_METERING_MODE  0x9207
#define EXIF_TAG_LIGHT_SOURCE   0x9208
#define EXIF_TAG_FLASH          0x9209
#define EXIF_TAG_FOCAL_LENGTH   0x920A
#define EXIF_TAG_MAKER_NOTE     0x927C
#define EXIF_TAG_USER_COMMENT   0x9286
#define EXIF_TAG_D_T_SUBSEC     0x9290  // Date & Time subseconds
#define EXIF_TAG_D_T_ORIG_SS    0x9291  // Date & Time original subseconds
#define EXIF_TAG_D_T_DIG_SS     0x9292  // Date & TIme digitized subseconds

#define EXIF_TAG_FPX_VER        0xA000
#define EXIF_TAG_COLOR_SPACE    0xA001
#define EXIF_TAG_PIX_X_DIM      0xA002
#define EXIF_TAG_PIX_Y_DIM      0xA003
#define EXIF_TAG_RELATED_WAV    0xA004  // related sound file
#define EXIF_TAG_INTEROP        0xA005
#define EXIF_TAG_FLASH_ENERGY   0xA20B
#define EXIF_TAG_SPATIAL_FR     0xA20C  // Spatial Frequency Response
#define EXIF_TAG_FOCAL_X_RES    0xA20E  // Focal Plane X Resolution
#define EXIF_TAG_FOCAL_Y_RES    0xA20F  // Focal Plane Y Resolution
#define EXIF_TAG_FOCAL_RES_UNIT 0xA210  // Focal Plane Resolution Unit
#define EXIF_TAG_SUBJECT_LOC    0xA214
#define EXIF_TAG_EXPOSURE_INDEX 0xA215
#define EXIF_TAG_SENSING_METHOD 0xA217
#define EXIF_TAG_FILE_SOURCE    0xA300
#define EXIF_TAG_SCENE_TYPE     0xA301
#define EXIF_TAG_CFA_PATTERN    0xA302

#define GPS_TAG_VER             0x0000
#define GPS_TAG_LATTITUDE_REF   0x0001
#define GPS_TAG_LATTITUDE       0x0002
#define GPS_TAG_LONGITUDE_REF   0x0003
#define GPS_TAG_LONGITUDE       0x0004
#define GPS_TAG_ALTITUDE_REF    0x0005
#define GPS_TAG_ALTITUDE        0x0006
#define GPS_TAG_GPS_TIME        0x0007
#define GPS_TAG_GPS_SATELLITES  0x0008
#define GPS_TAG_GPS_STATUS      0x0009
#define GPS_TAG_GPS_MEASURE_MODE 0x00A
#define GPS_TAG_GPS_DOP         0x000B  // Measurement precision
#define GPS_TAG_SPEED_REF       0x000C
#define GPS_TAG_SPEED           0x000D
#define GPS_TAG_TRACK_REF       0x000E
#define GPS_TAG_TRACK           0x000F
#define GPS_TAG_IMG_DIR_REF     0x0010
#define GPS_TAG_IMG_DIR         0x0011
#define GPS_TAG_MAP_DATUM       0x0012
#define GPS_TAG_DEST_LAT_REF    0x0013
#define GPS_TAG_DEST_LAT        0x0014
#define GPS_TAG_DEST_LONG_REF   0x0015
#define GPS_TAG_DEST_LONG       0x0016
#define GPS_TAG_DEST_BEAR_REF   0x0017
#define GPS_TAG_DEST_BEAR       0x0018
#define GPS_TAG_DEST_DIST_REF   0x0019
#define GPS_TAG_DEST_DIST       0x001A

#define MAKEARGB(a, r, g, b) \
        (((ARGB) ((a) & 0xff) << ALPHA_SHIFT) | \
         ((ARGB) ((r) & 0xff) <<   RED_SHIFT) | \
         ((ARGB) ((g) & 0xff) << GREEN_SHIFT) | \
         ((ARGB) ((b) & 0xff) <<  BLUE_SHIFT))

typedef PixelFormat PixelFormatID;

// Map COM Flags to GDI+ Flags
#define PIXFMTFLAG_INDEXED      PixelFormatIndexed
#define PIXFMTFLAG_GDI          PixelFormatGDI
#define PIXFMTFLAG_ALPHA        PixelFormatAlpha
#define PIXFMTFLAG_PALPHA       PixelFormatPAlpha
#define PIXFMTFLAG_EXTENDED     PixelFormatExtended
#define PIXFMTFLAG_CANONICAL    PixelFormatCanonical
#define PIXFMT_UNDEFINED        PixelFormatUndefined
#define PIXFMT_DONTCARE         PixelFormatDontCare
#define PIXFMT_1BPP_INDEXED     PixelFormat1bppIndexed
#define PIXFMT_4BPP_INDEXED     PixelFormat4bppIndexed
#define PIXFMT_8BPP_INDEXED     PixelFormat8bppIndexed
#define PIXFMT_16BPP_GRAYSCALE  PixelFormat16bppGrayScale
#define PIXFMT_16BPP_RGB555     PixelFormat16bppRGB555
#define PIXFMT_16BPP_RGB565     PixelFormat16bppRGB565
#define PIXFMT_16BPP_ARGB1555   PixelFormat16bppARGB1555
#define PIXFMT_24BPP_RGB        PixelFormat24bppRGB
#define PIXFMT_32BPP_RGB        PixelFormat32bppRGB
#define PIXFMT_32BPP_ARGB       PixelFormat32bppARGB
#define PIXFMT_32BPP_PARGB      PixelFormat32bppPARGB
#define PIXFMT_48BPP_RGB        PixelFormat48bppRGB
#define PIXFMT_64BPP_ARGB       PixelFormat64bppARGB
#define PIXFMT_64BPP_PARGB      PixelFormat64bppPARGB
#define PIXFMT_24BPP_BGR        PixelFormat24bppBGR
#define PIXFMT_MAX              PixelFormatMax

#define PALFLAG_HASALPHA        PaletteFlagsHasAlpha
#define PALFLAG_GRAYSCALE       PaletteFlagsGrayScale
#define PALFLAG_HALFTONE        PaletteFlagsHalftone

#define IMGLOCK_READ              ImageLockModeRead
#define IMGLOCK_WRITE             ImageLockModeWrite
#define IMGLOCK_USERINPUTBUF      ImageLockModeUserInputBuf

#define IMGFLAG_NONE                ImageFlagsNone
#define IMGFLAG_SCALABLE            ImageFlagsScalable
#define IMGFLAG_HASALPHA            ImageFlagsHasAlpha
#define IMGFLAG_HASTRANSLUCENT      ImageFlagsHasTranslucent
#define IMGFLAG_PARTIALLY_SCALABLE  ImageFlagsPartiallyScalable
#define IMGFLAG_COLORSPACE_RGB      ImageFlagsColorSpaceRGB
#define IMGFLAG_COLORSPACE_CMYK     ImageFlagsColorSpaceCMYK
#define IMGFLAG_COLORSPACE_GRAY     ImageFlagsColorSpaceGRAY
#define IMGFLAG_COLORSPACE_YCBCR    ImageFlagsColorSpaceYCBCR
#define IMGFLAG_COLORSPACE_YCCK     ImageFlagsColorSpaceYCCK
#define IMGFLAG_HASREALDPI          ImageFlagsHasRealDPI
#define IMGFLAG_HASREALPIXELSIZE    ImageFlagsHasRealPixelSize
#define IMGFLAG_READONLY            ImageFlagsReadOnly
#define IMGFLAG_CACHING             ImageFlagsCaching

#define ImageFlag                   ImageFlags


//
// Decoder flags
//

/* Only used in COM interface */
enum DecoderInitFlag
{
    DecoderInitFlagNone        = 0,

    // NOBLOCK indicates that the caller requires non-blocking
    // behavior.  This will be honored only by non-blocking decoders, that
    // is, decoders that don't have the IMGCODEC_BLOCKING_DECODE flag.

    DecoderInitFlagNoBlock     = 0x0001,

    // Choose built-in decoders first before looking at any
    // installed plugin decoders.

    DecoderInitFlagBuiltIn1st  = 0x0002
};

#define DECODERINIT_NONE          DecoderInitFlagNone
#define DECODERINIT_NOBLOCK       DecoderInitFlagNoBlock
#define DECODERINIT_BUILTIN1ST    DecoderInitFlagBuiltIn1st

/* Only used in COM interface */
enum BufferDisposalFlag
{
    BufferDisposalFlagNone,
    BufferDisposalFlagGlobalFree,
    BufferDisposalFlagCoTaskMemFree,
    BufferDisposalFlagUnmapView
};
    
#define DISPOSAL_NONE            BufferDisposalFlagNone
#define DISPOSAL_GLOBALFREE      BufferDisposalFlagGlobalFree
#define DISPOSAL_COTASKMEMFREE   BufferDisposalFlagCoTaskMemFree
#define DISPOSAL_UNMAPVIEW       BufferDisposalFlagUnmapView

//---------------------------------------------------------------------------
// Intepolation hints used by resize/rotation operations
//---------------------------------------------------------------------------
enum InterpolationHint
{
    InterpolationHintDefault,
    InterpolationHintNearestNeighbor,
    InterpolationHintBilinear,
    InterpolationHintAveraging,
    InterpolationHintBicubic
};

#define INTERP_DEFAULT              InterpolationHintDefault
#define INTERP_NEAREST_NEIGHBOR     InterpolationHintNearestNeighbor
#define INTERP_BILINEAR             InterpolationHintBilinear
#define INTERP_AVERAGING            InterpolationHintAveraging
#define INTERP_BICUBIC              InterpolationHintBicubic

#define IMGCODEC_ENCODER          ImageCodecFlagsEncoder
#define IMGCODEC_DECODER          ImageCodecFlagsDecoder
#define IMGCODEC_SUPPORT_BITMAP   ImageCodecFlagsSupportBitmap
#define IMGCODEC_SUPPORT_VECTOR   ImageCodecFlagsSupportVector
#define IMGCODEC_SEEKABLE_ENCODE  ImageCodecFlagsSeekableEncode
#define IMGCODEC_BLOCKING_DECODE  ImageCodecFlagsBlockingDecode

#define IMGCODEC_BUILTIN          ImageCodecFlagsBuiltin
#define IMGCODEC_SYSTEM           ImageCodecFlagsSystem
#define IMGCODEC_USER             ImageCodecFlagsUser

//
// Identifier for channel(s) in a pixel
//
/* Only used internally */
enum ChannelID
{
    ChannelID_Alpha      = 0x00000001,
    ChannelID_Red        = 0x00000002,
    ChannelID_Green      = 0x00000004,
    ChannelID_Blue       = 0x00000008,
    ChannelID_Color      = ChannelID_Red|ChannelID_Green|ChannelID_Blue,
    ChannelID_All        = ChannelID_Color|ChannelID_Alpha,
    
    ChannelID_Intensity  = 0x00010000
};

//
// Data structure for communicating to an image sink
//

/* Only used internally */
enum SinkFlags
{
    // Low-word: shared with ImgFlagx

    SinkFlagsScalable          = ImageFlagsScalable,
    SinkFlagsHasAlpha          = ImageFlagsHasAlpha,
    SinkFlagsPartiallyScalable = ImageFlagsPartiallyScalable,
    
    // High-word

    SinkFlagsTopDown    = 0x00010000,
    SinkFlagsBottomUp   = 0x00020000,
    SinkFlagsFullWidth  = 0x00040000,
    SinkFlagsMultipass  = 0x00080000,
    SinkFlagsComposite  = 0x00100000,
    SinkFlagsWantProps  = 0x00200000
};

#define SINKFLAG_SCALABLE           SinkFlagsScalable
#define SINKFLAG_HASALPHA           SinkFlagsHasAlpha
#define SINKFLAG_PARTIALLY_SCALABLE SinkFlagsPartiallyScalable
#define SINKFLAG_TOPDOWN    SinkFlagsTopDown
#define SINKFLAG_BOTTOMUP   SinkFlagsBottomUp
#define SINKFLAG_FULLWIDTH  SinkFlagsFullWidth
#define SINKFLAG_MULTIPASS  SinkFlagsMultipass
#define SINKFLAG_COMPOSITE  SinkFlagsComposite
#define SINKFLAG_WANTPROPS  SinkFlagsWantProps

/* Only used internally */
struct ImageInfo
{
    GUID RawDataFormat;
    PixelFormat PixelFormat;
    UINT Width, Height;
    UINT TileWidth, TileHeight;
    double Xdpi, Ydpi;
    UINT Flags;
};

//
// Data structure for passing encoder paramaters
//

// NOTE:
//  Should this be in GdiplusTypes.h instead?  Leave imaging.h for stuff
//  shared between the internal stuff and the API?
//
// Note: "EncoderParam" and "EncoderParams" should be removed after SHELL and
// and other team stops using COM interface

// !! To remove
struct EncoderParam
{
    GUID    paramGuid;
    char*   Value;
};

// !! To remove
struct EncoderParams
{
    UINT Count;
    EncoderParam Params[1];
};

//
// Interface and class identifiers
//

interface IImagingFactory;
interface IImage;
interface IBitmapImage;
interface IImageDecoder;
interface IImageEncoder;
interface IImageSink;
interface IBasicBitmapOps;


//--------------------------------------------------------------------------
// Imaging utility factory object
//  This is a CoCreate-able object.
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDA7-072B-11D3-9D7B-0000F81EF32E")
IImagingFactory : public IUnknown
{
public:

    // Create an image object from an input stream
    //  stream doesn't have to seekable
    //  caller should Release the stream if call is successful

    STDMETHOD(CreateImageFromStream)(
        IN IStream* stream,
        OUT IImage** image
        ) = 0;

    // Create an image object from a file

    STDMETHOD(CreateImageFromFile)(
        IN const WCHAR* filename,
        OUT IImage** image
        ) = 0;
    
    // Create an image object from a memory buffer

    STDMETHOD(CreateImageFromBuffer)(
        IN const VOID* buf,
        IN UINT size,
        IN BufferDisposalFlag disposalFlag,
        OUT IImage** image
        ) = 0;

    // Create a new bitmap image object

    STDMETHOD(CreateNewBitmap)(
        IN UINT width,
        IN UINT height,
        IN PixelFormatID pixelFormat,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a bitmap image from an IImage object

    STDMETHOD(CreateBitmapFromImage)(
        IN IImage* image,
        IN OPTIONAL UINT width,
        IN OPTIONAL UINT height,
        IN OPTIONAL PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create a new bitmap image object on user-supplied memory buffer

    STDMETHOD(CreateBitmapFromBuffer)(
        IN BitmapData* bitmapData,
        OUT IBitmapImage** bitmap
        ) = 0;

    // Create an image decoder object to process the given input stream

    STDMETHOD(CreateImageDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags,
        OUT IImageDecoder** decoder
        ) = 0;

    // Create an image encoder object that can output data in the
    // specified image file format.

    STDMETHOD(CreateImageEncoderToStream)(
        IN const CLSID* clsid,
        IN IStream* stream,
        OUT IImageEncoder** encoder
        ) = 0;

    STDMETHOD(CreateImageEncoderToFile)(
        IN const CLSID* clsid,
        IN const WCHAR* filename,
        OUT IImageEncoder** encoder
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledDecoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** decoders
        ) = 0;

    // Get a list of all currently installed image decoders

    STDMETHOD(GetInstalledEncoders)(
        OUT UINT* count,
        OUT ImageCodecInfo** encoders
        ) = 0;

    // Install an image encoder / decoder
    //  caller should do the regular COM component
    //  installation before calling this method

    STDMETHOD(InstallImageCodec)(
        IN const ImageCodecInfo* codecInfo
        ) = 0;

    // Uninstall an image encoder / decoder

    STDMETHOD(UninstallImageCodec)(
        IN const WCHAR* codecName,
        IN UINT flags
        ) = 0;

    // Create an in-memory IPropertySetStorage object

    STDMETHOD(CreateMemoryPropertyStore)(
        IN OPTIONAL HGLOBAL hmem,
        OUT IPropertySetStorage** propSet
        ) = 0;
};


//--------------------------------------------------------------------------
// Image interface
//  bitmap image
//  vector image
//  procedural image
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDA9-072B-11D3-9D7B-0000F81EF32E")
IImage : public IUnknown
{
public:

    // Get the device-independent physical dimension of the image
    //  in unit of 0.01mm

    STDMETHOD(GetPhysicalDimension)(
        OUT SIZE* size
        ) = 0;

    // Get basic image info

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Set image flags

    STDMETHOD(SetImageFlags)(
        IN UINT flags
        ) = 0;

    // Display the image in a GDI device context

    STDMETHOD(Draw)(
        IN HDC hdc,
        IN const RECT* dstRect,
        IN OPTIONAL const RECT* srcRect
        ) = 0;

    // Push image data into an IImageSink

    STDMETHOD(PushIntoSink)(
        IN IImageSink* sink
        ) = 0;

    // Get a thumbnail representation for the image object

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;

    // Get/set the properties in the standard property set
    //  x-res
    //  y-res
    //  gamma
    //  ICC profile
    //  thumbnail
    //  tile width
    //  tile height
    //
    // Property-related methods

    STDMETHOD(GetProperties)(
        IN DWORD mode,
        OUT IPropertySetStorage** propSet
        ) = 0;
};


//--------------------------------------------------------------------------
// Bitmap interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAA-072B-11D3-9D7B-0000F81EF32E")
IBitmapImage : public IUnknown
{
public:

    // Get bitmap dimensions in pixels

    STDMETHOD(GetSize)(
        OUT SIZE* size
        ) = 0;

    // Get bitmap pixel format

    STDMETHOD(GetPixelFormatID)(
        OUT PixelFormatID* pixelFormat
        ) = 0;

    // Access bitmap data in the specified pixel format
    //  must support at least PIXFMT_DONTCARE and
    //  the caninocal formats.

    STDMETHOD(LockBits)(
        IN const RECT* rect,
        IN UINT flags,
        IN PixelFormatID pixelFormat,
        IN OUT BitmapData* lockedBitmapData
        ) = 0;

    STDMETHOD(UnlockBits)(
        IN const BitmapData* lockedBitmapData
        ) = 0;

    // Set/get palette associated with the bitmap image

    STDMETHOD(GetPalette)(
        OUT ColorPalette** palette
        ) = 0;

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;
};


//--------------------------------------------------------------------------
// Interface for performing basic operations on a bitmap image
//  This can be QI'ed from an IBitmapImage object.
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAF-072B-11D3-9D7B-0000F81EF32E")
IBasicBitmapOps : public IUnknown
{
public:

    // Clone an area of the bitmap image

    STDMETHOD(Clone)(
        IN OPTIONAL const RECT* rect,
        OUT IBitmapImage** outbmp
        );

    // Flip the bitmap image in x- and/or y-direction

    STDMETHOD(Flip)(
        IN BOOL flipX,
        IN BOOL flipY,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Resize the bitmap image

    STDMETHOD(Resize)(
        IN UINT newWidth,
        IN UINT newHeight,
        IN PixelFormatID pixelFormat,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Rotate the bitmap image by the specified angle

    STDMETHOD(Rotate)(
        IN FLOAT angle,
        IN InterpolationHint hints,
        OUT IBitmapImage** outbmp
        ) = 0;

    // Adjust the brightness of the bitmap image

    STDMETHOD(AdjustBrightness)(
        IN FLOAT percent
        ) = 0;
    
    // Adjust the contrast of the bitmap image

    STDMETHOD(AdjustContrast)(
        IN FLOAT shadow,
        IN FLOAT highlight
        ) = 0;
    
    // Adjust the gamma of the bitmap image

    STDMETHOD(AdjustGamma)(
        IN FLOAT gamma
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decoder interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAB-072B-11D3-9D7B-0000F81EF32E")
IImageDecoder : public IUnknown
{
public:

    // Initialize the image decoder object

    STDMETHOD(InitDecoder)(
        IN IStream* stream,
        IN DecoderInitFlag flags
        ) = 0;

    // Clean up the image decoder object

    STDMETHOD(TerminateDecoder)() = 0;

    // Start decoding the current frame

    STDMETHOD(BeginDecode)(
        IN IImageSink* sink,
        IN OPTIONAL IPropertySetStorage* newPropSet
        ) = 0;

    // Continue decoding

    STDMETHOD(Decode)() = 0;

    // Stop decoding the current frame

    STDMETHOD(EndDecode)(
        IN HRESULT statusCode
        ) = 0;

    // Query multi-frame dimensions

    STDMETHOD(GetFrameDimensionsCount)(
        OUT UINT* count
        ) = 0;

    STDMETHOD(GetFrameDimensionsList)(
        OUT GUID* dimensionIDs,
        IN OUT UINT count
        ) = 0;
    // To be removed
    STDMETHOD(QueryFrameDimensions)(
        OUT UINT* count,
        OUT GUID** dimensionIDs
        ) = 0;

    // Get number of frames for the specified dimension

    STDMETHOD(GetFrameCount)(
        IN const GUID* dimensionID,
        OUT UINT* count
        ) = 0;

    // Select currently active frame

    STDMETHOD(SelectActiveFrame)(
        IN const GUID* dimensionID,
        IN UINT frameIndex
        ) = 0;

    // Get basic information about the image

    STDMETHOD(GetImageInfo)(
        OUT ImageInfo* imageInfo
        ) = 0;

    // Get image thumbnail

    STDMETHOD(GetThumbnail)(
        IN OPTIONAL UINT thumbWidth,
        IN OPTIONAL UINT thumbHeight,
        OUT IImage** thumbImage
        ) = 0;

    // Property/metadata related methods

    STDMETHOD(GetProperties)(
        OUT IPropertySetStorage** propSet
        ) = 0;

    // Query decoder parameters

    STDMETHOD(QueryDecoderParam)(
        IN GUID     Guid
        ) = 0;

    // Set decoder parameters

    STDMETHOD(SetDecoderParam)(
        IN GUID     Guid,
        IN UINT     Length,
        IN PVOID    Value
        ) = 0;
    
    // Property related functions

    STDMETHOD(GetPropertyCount)(
        OUT UINT* numOfProperty
        ) = 0;

    STDMETHOD(GetPropertyIdList)(
        IN UINT numOfProperty,
  	    IN OUT PROPID* list
        ) = 0;

    STDMETHOD(GetPropertyItemSize)(
        IN PROPID propId, 
        OUT UINT* size
        ) = 0;
    
    STDMETHOD(GetPropertyItem)(
        IN PROPID propId,
        IN UINT propSize,
        IN OUT PropertyItem* buffer
        ) = 0;

    STDMETHOD(GetPropertySize)(
        OUT UINT* totalBufferSize,
		OUT UINT* numProperties
        ) = 0;

    STDMETHOD(GetAllPropertyItems)(
        IN UINT totalBufferSize,
        IN UINT numProperties,
        IN OUT PropertyItem* allItems
        ) = 0;

    STDMETHOD(RemovePropertyItem)(
        IN PROPID   propId
        ) = 0;

    STDMETHOD(SetPropertyItem)(
        IN PropertyItem item
        ) = 0;
};


//--------------------------------------------------------------------------
// Image decode sink interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAE-072B-11D3-9D7B-0000F81EF32E")
IImageSink : public IUnknown
{
public:

    // Begin the sink process

    STDMETHOD(BeginSink)(
        IN OUT ImageInfo* imageInfo,
        OUT OPTIONAL RECT* subarea
        ) = 0;

    // End the sink process

    STDMETHOD(EndSink)(
        IN HRESULT statusCode
        ) = 0;

    // Pass the color palette to the image sink

    STDMETHOD(SetPalette)(
        IN const ColorPalette* palette
        ) = 0;

    // Ask the sink to allocate pixel data buffer

    STDMETHOD(GetPixelDataBuffer)(
        IN const RECT* rect,
        IN PixelFormatID pixelFormat,
        IN BOOL lastPass,
        OUT BitmapData* bitmapData
        ) = 0;

    // Give the sink pixel data and release data buffer

    STDMETHOD(ReleasePixelDataBuffer)(
        IN const BitmapData* bitmapData
        ) = 0;

    // Push pixel data

    STDMETHOD(PushPixelData)(
        IN const RECT* rect,
        IN const BitmapData* bitmapData,
        IN BOOL lastPass
        ) = 0;

    // Push raw image data

    STDMETHOD(PushRawData)(
        IN const VOID* buffer,
        IN UINT bufsize
        ) = 0;

    // Methods for passing metadata / properties

    STDMETHOD(PushProperties)(
        IN IPropertySetStorage* propSet
        ) = 0;
    
    STDMETHOD(NeedTransform)(
        OUT UINT* rotation
        ) = 0;

    STDMETHOD(NeedRawProperty)(
        ) = 0;
    
    STDMETHOD(PushRawInfo)(
        IN OUT void* info
        ) = 0;

    STDMETHOD(GetPropertyBuffer)(
        IN     UINT            uiTotalBufferSize,
        IN OUT PropertyItem**  ppBuffer
        ) = 0;
    
    STDMETHOD(PushPropertyItems)(
        IN UINT             numOfItems,
        IN UINT             uiTotalBufferSize,
        IN PropertyItem*    item
        ) = 0;
};


//--------------------------------------------------------------------------
// Image encoder interface
//--------------------------------------------------------------------------

MIDL_INTERFACE("327ABDAC-072B-11D3-9D7B-0000F81EF32E")
IImageEncoder : public IUnknown
{
public:

    // Initialize the image encoder object

    STDMETHOD(InitEncoder)(
        IN IStream* stream
        ) = 0;
    
    // Clean up the image encoder object

    STDMETHOD(TerminateEncoder)() = 0;

    // Get an IImageSink interface for encoding the next frame

    STDMETHOD(GetEncodeSink)(
        OUT IImageSink** sink
        ) = 0;
    
    // Set active frame dimension

    STDMETHOD(SetFrameDimension)(
        IN const GUID* dimensionID
        ) = 0;
    
    // Query encoder parameters

    STDMETHOD(QueryEncoderParam)(
        OUT EncoderParams** Params
    ) = 0;

    // Set encoder parameters

    STDMETHOD(SetEncoderParam)(
        IN EncoderParams* Param
        ) = 0;
    
    STDMETHOD(GetEncoderParameterListSize)(
       	OUT UINT* size
        ) = 0;

    STDMETHOD(GetEncoderParameterList)(
        IN UINT	  size,
        OUT EncoderParameters* Params
        ) = 0;

    STDMETHOD(SetEncoderParameters)(
        IN const EncoderParameters* Param
        ) = 0;
};


//--------------------------------------------------------------------------
// Imaging library error codes
//
// !!! TODO
//  How does one pick a facility code?
//
// Standard error code used:
//  E_INVALIDARG
//  E_OUTOFMEMORY
//  E_NOTIMPL
//  E_ACCESSDENIED
//  E_PENDING
//--------------------------------------------------------------------------

#define FACILITY_IMAGING        0x87b
#define MAKE_IMGERR(n)          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_IMAGING, n)
#define IMGERR_OBJECTBUSY       MAKE_IMGERR(1)
#define IMGERR_NOPALETTE        MAKE_IMGERR(2)
#define IMGERR_BADLOCK          MAKE_IMGERR(3)
#define IMGERR_BADUNLOCK        MAKE_IMGERR(4)
#define IMGERR_NOCONVERSION     MAKE_IMGERR(5)
#define IMGERR_CODECNOTFOUND    MAKE_IMGERR(6)
#define IMGERR_NOFRAME          MAKE_IMGERR(7)
#define IMGERR_ABORT            MAKE_IMGERR(8)
#define IMGERR_FAILLOADCODEC    MAKE_IMGERR(9)

#endif // !_IMAGING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\imeapp.h ===
//
//	%%Title: IMEAPP
//	%%Unit: COM
//	%%Contact: TakeshiF/SeijiA
//	%%Date: 97/06/20
//	%%File: imeapp.h
//
//	Private API / Message service
//

#ifndef __IMEUP_H__
#define __IMEUP_H__

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#include "actdict.h"

//// START

/***********************************************************************
	Msg:	WM_MSIME_SERVICE
	Desc: 	service functions
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_SERVICE		TEXT("MSIMEService")

#define	VERSION_ID_JAPAN	0x01000000
#define	VERSION_ID_KOREA	0x02000000
#define	VERSION_ID_TC		0x04000000
#define	VERSION_ID_PRC		0x08000000

#define	VERSION_ID_IMEJP98	(VERSION_ID_JAPAN | 0x980)
#define	VERSION_ID_IMEJP98A	(VERSION_ID_JAPAN | 0x98a)


/***********************************************************************
	Msg:	WM_MSIME_AUTOCOMPLETE
	Desc: 	use IImeActiveDict to support auto-complete
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_AUTOCOMPLETE 		TEXT("MSIMEAutoComplete")

// AutoComplete Version
#define VERSION_AUTOCOMPETE		1

// Dictionary Structure
typedef struct _IMEDICT
{
	int				cbSize;			//size of this structure
	HIMC			hIMC;			//IME context
	IImeActiveDict	*pdict;			//program dictionary
} IMEDICT;

//WParam definition
#define FID_AUTO_VERSION		1
#define FID_AUTO_ACTIVATE		2
#define FID_AUTO_DEACTIVATE		3


/***********************************************************************
	Msg:	WM_MSIME_WORDSTAT
	Desc: 	use IImeActiveDict to get word statistics
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_WORDSTAT 		TEXT("MSIMEWordStatistics")

// WordStat Version
#define VERSION_WORDSTAT		1

// WParam definition
#define FID_STAT_VERSION		1
#define FID_STAT_GIVESTAT		2


/***********************************************************************
	Msg:	WM_MSIME_DOCKDICT
	Desc: 	use IImeActiveDict to dock dictionary
	Owner: 	seijia				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_DOCKDICT 		TEXT("MSIMEDockActiveDict")

// Dictionary Docking Version
#define VERSION_DOCKDICT		1

// WParam definition
#define FID_DOCK_VERSION		1
#define FID_DOCK_ACTIVATE		2
#define FID_DOCK_DEACTIVATE		3


/***********************************************************************
	Msg:	WM_MSIME_MOUSE
	Desc: 	mouse operation definition                
	Owner: 	kentu				
 ***********************************************************************/

// Label for RegisterWindowMessage
#define RWM_MOUSE 		TEXT("MSIMEMouseOperation")

// Mouse Operation Version (return value of IMEMOUSE_VERSION)
#define VERSION_MOUSE_OPERATION		1

// Mouse operation result
#define IMEMOUSERET_NOTHANDLED		(-1)

//WParam definition for WM_IME_MOUSE.
#define IMEMOUSE_VERSION	0xff	// mouse supported?

#define IMEMOUSE_NONE		0x00	// no mouse button was pushed
#define IMEMOUSE_LDOWN		0x01
#define IMEMOUSE_RDOWN		0x02
#define IMEMOUSE_MDOWN		0x04
#define IMEMOUSE_WUP		0x10	// wheel up
#define IMEMOUSE_WDOWN		0x20	// wheel down


/***********************************************************************
	Msg:	WM_MSIME_RECONVERT/WM_MSIME_RECONVERTREQUEST
	Desc: 	reconversion
	Owner: 	takeshif				
 ***********************************************************************/

// wParam of WM_MSIME_RECONVERTREQUEST
#define FID_RECONVERT_VERSION	0x10000000

// Private reconversion Version
#define VERSION_RECONVERSION		1

// Label for RegisterWindowMessage
#define	RWM_RECONVERT			TEXT("MSIMEReconvert")
#define	RWM_RECONVERTREQUEST	TEXT("MSIMEReconvertRequest")

/***********************************************************************
	Msg:	WM_MSIME_DOCUMENTFEED
	Desc: 	reconversion
	Owner: 	takeshif				
	Usage: SendMessage( hwndApp, WM_MSIME_DOCUMENTFEED, VERSION_DOCUMENTFEED,
				(RECONVERTSTRING*)pReconv );
	wParam: VERSION_DOCUMENTFEED
	lParam: Pointer of RECONVERTSTRING structure
	return: size of RECONVERTSTRING structure
 ***********************************************************************/

// wParam of WM_MSIME_DOCUMENTFEED (set current docfeed version)
#define VERSION_DOCUMENTFEED		1

// lParam is pointer of RECONVERTSTRING structure

// Label for RegisterWindowMessage
#define	RWM_DOCUMENTFEED	TEXT("MSIMEDocumentFeed")

/***********************************************************************
	Msg:	WM_MSIME_QUERYHIDECARET
	Desc: 	composition UI
	Owner: 	takeshif				
	Usage: SendMessage( hwndDefUI, WM_MSIME_QUERYHIDECARET, 0, 0 );
	wParam: reserved
	lParam: reserved
	return: Non-zero = shows caret. Zero = hide caret.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYHIDECARET
#define VERSION_QUERYHIDECARET		1

// Label for RegisterWindowMessage
#define	RWM_QUERYHIDECARET	TEXT("MSIMEQueryHideCaret")

/***********************************************************************
	Msg:	WM_MSIME_QUERYPOSITION
	Desc: 	composition UI
	Owner: 	takeshif				
	Usage: SendMessage( hwndApp, WM_MSIME_QUERYPOSITION, 0, (IMEPOSITION*)pPs );
	wParam: reserved. must be 0.
	lParam: pointer of IMEPOSITION structure
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// wParam of WM_MSIME_QUERYPOSITION
#define VERSION_QUERYPOSITION		1

// Label for RegisterWindowMessage
#define	RWM_QUERYPOSITION	TEXT("MSIMEQueryPosition")


/***********************************************************************
	Msg:	WM_MSIME_MODEBIAS
	Desc: 	input mode bias
	Owner: 	takeshif
	Usage: SendMessage( hwndDefUI, WM_MSIME_MODEBIAS, MODEBIAS_xxxx, 0 );
	wParam: see below MODEBIAS_xxxx
	lParam: reserved
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_MODEBIAS			TEXT("MSIMEModeBias")

// wParam - bias setting
#define MODEBIAS_DEFAULT				0x00000000	// reset all of bias setting
#define MODEBIAS_FILENAME				0x00000001
#define MODEBIAS_URL					0x00000002
#define MODEBIAS_DISABLEAUTOCONV		0x00000010


/***********************************************************************
	Msg:	WM_MSIME_SHOWIMEPAD
	Desc: 	show ImePad
	Owner: 	toshiaK
	Usage: SendMessage( hwndDefUI, WM_MSIME_SHOWIMEPAD, 0, 0 );
	wParam: reserved
	lParam: reserved
	return: Non-zero = accepted. Zero = not accepted.
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_SHOWIMEPAD			TEXT("MSIMEShowImePad")


/***********************************************************************
	Msg:	WM_MSIME_KEYMAP
	Desc: 	key map sharing with apps
	Owner: 	HiroakiK
 ***********************************************************************/

// Label for RegisterWindowMessage
#define	RWM_KEYMAP				TEXT("MSIMEKeyMap")
#define	RWM_CHGKEYMAP			TEXT("MSIMEChangeKeyMap")
#define	RWM_NTFYKEYMAP			TEXT("MSIMENotifyKeyMap")


#define FID_MSIME_KMS_VERSION		1
#define FID_MSIME_KMS_INIT			2
#define FID_MSIME_KMS_TERM			3
#define FID_MSIME_KMS_DEL_KEYLIST	4
#define FID_MSIME_KMS_NOTIFY		5
#define FID_MSIME_KMS_GETMAP		6
#define FID_MSIME_KMS_INVOKE		7
#define FID_MSIME_KMS_SETMAP		8



#define IMEKMS_NOCOMPOSITION        0
#define IMEKMS_COMPOSITION          1
#define IMEKMS_SELECTION            2
#define IMEKMS_IMEOFF               3
#define IMEKMS_2NDLEVEL             4
#define IMEKMS_INPTGL               5



typedef struct tagIMEKMSINIT {
	INT			cbSize;
	HWND		hWnd;	// Window which receives notification from IME.
						// If hWnd is NULL, no notification is posted
						// to Input context.
} IMEKMSINIT;


typedef struct tagIMEKMSKEY {
	DWORD dwStatus;		//Shift-Control combination status.
						//Any combination of constants below
						//(defined in IMM.H)
						// 0x0000 (default)
						// MOD_CONTROL     0x0002
						// MOD_SHIFT       0x0004
						// Alt key and Win key is not processed by IME. 
	
	DWORD dwCompStatus;	//Composition string status
						//One of the constants below
						// IMEKMS_NOCOMPOSITION  No composition string      
						// IMEKMS_COMPOSITION    Some composition string
						// IMEKMS_SELECTION      Selection exists in apps
						// IMEKMS_IMEOFF         IME Off state
						// IMEKMS_2NDLEVEL       2nd stage on 2 stroke key operation
						
	
	DWORD dwVKEY;		// VKEY code defined in IMM.H
	union {
		DWORD dwControl;// IME Functionality ID
		DWORD dwNotUsed;
	};
	union {
		WCHAR pwszDscr[31];// The pointer to string of description of this functionalify
		WCHAR pwszNoUse[31];
	};
} IMEKMSKEY;

typedef struct tagIMEKMS {
	INT			cbSize;
	HIMC		hIMC;
	LANGID		idLang;
	DWORD		cKeyList;
	IMEKMSKEY	*pKeyList;
} IMEKMS;

typedef struct tagIMEKMSNTFY {
	INT			cbSize;
	HIMC		hIMC;
	BOOL		fSelect;
} IMEKMSNTFY;

typedef struct tagIMEKMSKMP {
	INT			cbSize;			//[in] size of this structure
	HIMC		hIMC;			//[in] Input context
	WORD		wVKStart;		//[in] VKEY start
	WORD		wVKEnd;			//[in] VKEY end
	INT			cKeyList;		//[out] number of IMEKMSKEY
	IMEKMSKEY	*pKeyList;		//[out] retrieve buffer of IMEKMSKEY
								//      Must be GlobalMemFree by clients
} IMEKMSKMP;

typedef struct tagIMEKMSINVK {
	INT			cbSize;
	HIMC		hIMC;
	DWORD		dwControl;
} IMEKMSINVK;


//// END

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif	// __cplusplus


#endif // __IMEUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\ourtypes.h ===
/*
 *	@doc INTERNAL
 *
 *	@module	OURTYPES.H	-- Miscellaneous type declarations |
 *	
 *	Original Author: <nl>
 *		DGreen
 *
 *	History: <nl>
 *		02/19/98  KeithCu  Cleaned up
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _OURTYPES_H_
#define _OURTYPES_H_

// WM_SYSKEYDOWN masks for lKeyData
#define SYS_ALTERNATE		0x20000000
#define SYS_PREVKEYSTATE	0x40000000


#ifndef WINDOWS
#define WINDOWS
#endif

#define CchSzAToSzW(_szA, _szW, _cbSzW)	\
	MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, (_szA), -1, (_szW),	\
						(_cbSzW) / sizeof(WCHAR))

#define CchSzWToSzA(_szW, _szA, _cbSzA)	\
	WideCharToMultiByte(CP_ACP, 0, (_szW), -1, (_szA), (_cbSzA), NULL, NULL)

#define UsesMakeOLESTRX(_cchMax)	WCHAR szWT[_cchMax]
#define UsesMakeOLESTR				UsesMakeOLESTRX(MAX_PATH)
#define MakeOLESTR(_szA)	\
	(CchSzAToSzW((_szA), szWT, sizeof(szWT)) ? szWT : NULL)

#endif //_OURTYPES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\imeshare.h ===
/******************************************************************************
**	I M E  S H A R E  .  H													 **
**			KentU,KotaroY/MSKK											 	 **
**																			 **
**   With this piece of code, the client Applications will be able to refer	 **
**	the same TrueInline style described in the Registry.					 **
**	 This library should allow clients to get decoration style (either color **
**	and various underlines)													 **
**	 For underlines, applications are allowed to substitute some of 		 **
**	predefined underlines to other predefined one.							 **
**																			 **
**	Oct./23/1995 : Start writing.											 **
**  Jun./19/1997 : Add new CPP interface.	[KotaroY]						 **
**  Sep./02/1997 : Rewrite. True object-based architecture.	[KotaroY]		 **
**																			 **
******************************************************************************/

#ifndef __IMESHARE_H__
#define __IMESHARE_H__

#include <windows.h>

#ifdef IMESHARE_CPL
#include "resource.h"
#endif

#define IMECDECL __cdecl
#define IMESHAREAPI  __declspec( dllimport )

typedef WORD	LID;


#define UINTIMEBOGUS 0xffffffff


#define IMESATTR_MIN					0
#define IMESATTR_INPUT 					ATTR_INPUT
#define IMESATTR_TARGET_CONVERTED		ATTR_TARGET_CONVERTED
#define	IMESATTR_CONVERTED				ATTR_CONVERTED
#define IMESATTR_TARGET_NOTCONVERTED	ATTR_TARGET_NOTCONVERTED
#define IMESATTR_INPUT_ERROR			ATTR_INPUT_ERROR
#define IMESATTR_FIXEDCONVERTED			5
#define IMESATTR_MAX					5
#define CATR (IMESATTR_MAX - IMESATTR_MIN + 1)


#define IMESTY_UL_MIN				2002
#define IMESTY_UL_NONE				2002
#define	IMESTY_UL_SINGLE			2003
//OLD #define IMESTY_UL_DOUBLE			2004
#define IMESTY_UL_DOTTED			2005
#define IMESTY_UL_THICK				2006
//OLD #define IMESTY_UL_DASHLINE			2007
//OLD #define IMESTY_UL_DOTDASH			2008
//OLD #define IMESTY_UL_DOTDOTDASH		2009
//OLD #define IMESTY_UL_WAVE				2010
#define IMESTY_UL_LOWER				2011
#define IMESTY_UL_THICKLOWER		2012
#define IMESTY_UL_THICKDITHLOWER	2013
#define IMESTY_UL_DITHLOWER			2014
#define IMESTY_UL_MAX				2014
#define CIMEUL (IMESTY_UL_MAX - IMESTY_UL_MIN + 1)
				//WARNING: Based on an assumption that all IDSsty definitions id are consecutive.


//Naming convention IdstyIMEShare[return type][property][subgrouping]
#define IdstyIMEShareSubText			0x0000
#define IdstyIMEShareSubBack			0x0001
#define IdstyIMEShareSubUl				0x0002
#define IdstyIMEShareFBold				0x0100
#define IdstyIMEShareFItalic			0x0200
#define IdstyIMEShareFUl				0x0300
#define IdstyIMEShareUKul				0x0400
#define IdstyIMEShareFWinCol			0x0500
#define IdstyIMEShareFFundCol			0x0600
#define IdstyIMEShareFRGBCol			0x0700
#define IdstyIMEShareFSpecCol			0x0800
#define IdstyIMEShareRGBCol				0x0900
#define IdstyIMEShareFSpecColText		0x0a00
#define IdstyIMEShareFSpecColWindow		0x0b00

#ifdef IMESHARE_CPL
#define IdstyIMEShareUSpecColId			0x0c00
#define IdstyIMEShareUWinColId			0x0d00
#define IdstyIMEShareUFundColId			0x0e00
#define IdstyIMEShareGrfSty				0x0f00
#endif	// IMESHARE_CPL

#define COLOR_RGB  0	  //RGB()
#define COLOR_WIN  1	  //Windows' color scheme.
#define COLOR_FUND 2	  //one of 16 fundamental color
#define COLOR_SPEC 3	  //special color.


#ifdef IMESHARE_CPL
#define STY_PLAIN					IDS_STYPLAIN
#define	STY_BOLD					IDS_STYBOLD
#define STY_ITALIC					IDS_STYITALIC

#define IMECOL_SPEC_MIN				IDS_COLAPPTEXT
#define IMECOL_APPTEXT					IDS_COLAPPTEXT
#define IMECOL_APPWINDOW				IDS_COLAPPWINDOW
#define IMECOL_SPEC_MAX				IDS_COLAPPWINDOW + 1
#define COL_FUND_MIN				IDS_COLBLACK
#define COL_BLACK					IDS_COLBLACK
#define COL_BLUE					IDS_COLBLUE
#define COL_CYAN					IDS_COLCYAN
#define COL_GREEN					IDS_COLGREEN
#define COL_MAGENTA					IDS_COLMAGENTA
#define COL_RED						IDS_COLRED
#define COL_YELLOW					IDS_COLYELLOW
#define COL_WHITE					IDS_COLWHITE
#define COL_DKBLUE					IDS_COLDKBLUE
#define COL_DKCYAN					IDS_COLDKCYAN
#define COL_DKGREEN					IDS_COLDKGREEN
#define COL_DKMAGENTA				IDS_COLDKMAGENTA
#define COL_DKRED					IDS_COLDKRED
#define COL_DKYELLOW				IDS_COLDKYELLOW
#define COL_DKGRAY					IDS_COLDKGRAY
#define COL_LTGRAY					IDS_COLLTGRAY
#define COL_FUND_MAX				IDS_COLLTGRAY + 1

#define COL_WIN_MIN					IDS_COLSCROLLBAR
#define COL_WIN_SCROLLBAR 			IDS_COLSCROLLBAR
#define COL_WIN_BACKGROUND			IDS_COLBACKGROUND
#define COL_WIN_ACTIVECAPTION		IDS_COLACTIVECAPTION
#define COL_WIN_INACTIVECAPTION		IDS_COLINACTIVECAPTION
#define COL_WIN_MENU				IDS_COLMENU
#define COL_WIN_WINDOW				IDS_COLWINDOW
#define COL_WIN_WINDOWFRAME			IDS_COLWINDOWFRAME
#define COL_WIN_MENUTEXT			IDS_COLMENUTEXT
#define COL_WIN_WINDOWTEXT			IDS_COLWINDOWTEXT
#define COL_WIN_CAPTIONTEXT			IDS_COLCAPTIONTEXT
#define COL_WIN_ACTIVEBORDER		IDS_COLACTIVEBORDER
#define COL_WIN_INACTIVEBORDER		IDS_COLINACTIVEBORDER
#define COL_WIN_APPWORKSPACE		IDS_COLAPPWORKSPACE
#define COL_WIN_HIGHLIGHT			IDS_COLHIGHLIGHT
#define COL_WIN_HIGHLIGHTTEXT		IDS_COLHIGHLIGHTTEXT
#define COL_WIN_BTNFACE				IDS_COLBTNFACE
#define COL_WIN_BTNSHADOW			IDS_COLBTNSHADOW
#define COL_WIN_GRAYTEXT			IDS_COLGRAYTEXT
#define COL_WIN_BTNTEXT				IDS_COLBTNTEXT
#define COL_WIN_INACTIVECAPTIONTEXT	IDS_COLINACTIVECAPTIONTEXT
#define COL_WIN_SHADOW				IDS_COLSHADOW
#define COL_WIN_BTNHIGHLIGHT		IDS_COLBTNHIGHLIGHT
#define COL_WIN_BTNDKSHADOW			IDS_COLBTNDKSHADOW
#define COL_WIN_BTNLIGHT			IDS_COLBTNLIGHT
#define COL_WIN_INFOTEXT			IDS_COLINFOTEXT
#define COL_WIN_INFOWINDOW			IDS_COLINFOWINDOW
#define COL_WIN_MAC					COL_WIN_INFOWINDOW + 1

#define RGB_BLACK	(RGB(  0,  0,  0))
#define RGB_BLUE	(RGB(  0,  0,255))
#define RGB_CYAN	(RGB(  0,255,255))
#define RGB_GREEN   (RGB(  0,255,  0))
#define RGB_MAGENTA (RGB(255,  0,255))
#define RGB_RED		(RGB(255,  0,  0))
#define RGB_YELLOW  (RGB(255,255,  0))
#define RGB_WHITE   (RGB(255,255,255))
#define RGB_DKBLUE  (RGB(  0,  0,127))
#define RGB_DKCYAN  (RGB(  0,127,127))
#define RGB_DKGREEN (RGB(  0,127,  0))
#define RGB_DKMAGENTA (RGB(127,  0,127))
#define RGB_DKRED   (RGB(127,  0,  0))
#define RGB_DKYELLOW (RGB(127,127,  0))
#define RGB_DKGRAY  (RGB(127,127,127))
#define RGB_LTGRAY  (RGB(192,192,192))

#endif	// IMESHARE_CPL


typedef struct {
	union {
		UINT grfsty;
		struct {
			UINT	fBold:1;
			UINT	fItalic:1;
			UINT	fUl:1;
			UINT	idUl:(sizeof(UINT) * 8 - 3);
		};
	};
} GRFSTY;




#ifdef __cplusplus

class CIMEShare{
public:
	virtual void	IMECDECL CustomizeIMEShare()=0;
	virtual BOOL	IMECDECL FSupportSty(UINT sty, UINT styAltered)=0;
	virtual LID		IMECDECL LidSetLid(LID lid)=0;
	virtual LID		IMECDECL LidGetLid(void)=0;
	virtual DWORD	IMECDECL DwGetIMEStyle(const UINT attr, const UINT idsty)=0;
	virtual BOOL	IMECDECL FDeleteIMEShare(void)=0;
	virtual DWORD	IMECDECL DwGetIMEStyleCpl(const UINT attr, const UINT idsty)=0;
	virtual BOOL	IMECDECL FSetIMEStyleCpl(const UINT attr, const UINT idsty, DWORD dwval)=0;
	virtual BOOL	IMECDECL FSaveIMEShareCpl(void)=0;
};

#else  //!__cplusplus

typedef struct _CIMEShare CIMEShare;

typedef struct _CIMEShareVtbl{
	void (IMECDECL *CustomizeIMEShare)(CIMEShare *This);
	BOOL (IMECDECL *FSupportSty)(CIMEShare *This, UINT sty, UINT styAlered);
	unsigned short (IMECDECL *LidSetLid)(CIMEShare *This, unsigned short lid);
    unsigned short (IMECDECL *LidGetLid)(CIMEShare *This);
	DWORD (IMECDECL *DwGetIMEStyle)(CIMEShare *This, UINT attr, UINT idsty);
	BOOL (IMECDECL *FDeleteIMEShare)(CIMEShare *This);

	DWORD (IMECDECL *DwGetIMEStyleCpl)(CIMEShare *This, UINT attr, UINT idsty);
	BOOL (IMECDECL *FSetIMEStyleCpl)(CIMEShare *This, UINT attr, UINT idsty, DWORD dwVal);
	BOOL (IMECDECL *FSaveIMEShareCpl)(CIMEShare *This);
} CIMEShareVtbl;

typedef struct _CIMEShare{
	const CIMEShareVtbl *lpVtbl;
} CIMEShare;

#endif //__cplusplus


#ifdef __cplusplus
extern "C"{
#endif
CIMEShare * IMECDECL PIMEShareCreate();
typedef CIMEShare * (IMECDECL FNPIMESHARECREATE)(void);
#ifdef __cplusplus
}
#endif




#ifdef OBSOLETE

typedef struct {
	UINT colorId;
	union {
		COLORREF	rgb;
		UINT		colorWin;
		UINT		colorSpec;
		UINT		colorFund;
	};
} IMECOLORSTY;

typedef struct {
	union {
		GRFSTY	grfsty;
		struct {
			UINT	fBold:1;
			UINT	fItalic:1;
			UINT	fUl:1;
			UINT	idUl:(sizeof(UINT) * 8 - 3);
		};
	};

	union {
		IMECOLORSTY colorstyText;
		struct {
			UINT	colorIdText;
			union {
				COLORREF	rgbText;
				UINT		colorWinText;
				UINT		colorSpecText;
				UINT		colorFundText;
			};
		};
	};

	union {
		IMECOLORSTY colorstyBack;
		struct {
			UINT	colorIdBack;
			union {
				COLORREF	rgbBack;
				UINT		colorWinBack;
				UINT		colorSpecBack;
				UINT		colorFundBack;
			};
		};
	};

	union {
		IMECOLORSTY colorstyUl;
		struct {
			UINT	colorIdUl;
			union {
				COLORREF	rgbUl;
				UINT		colorWinUl;
				UINT		colorSpecUl;
				UINT		colorFundUl;
			};
		};
	};
} IMESTYLE;

#ifdef __cplusplus
extern "C"{
#endif
//Functions

#if 0	// no need to redefine DllMain.
#ifndef PEGASUS
IMESHAREAPI BOOL	WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved);
#endif
#endif

IMESHAREAPI BOOL	IMECDECL FInitIMEShare();
IMESHAREAPI void	IMECDECL CustomizeIMEShare();
IMESHAREAPI void	IMECDECL EndIMEShare();

// Multilingual support
LID IMECDECL LidGetLid(void);
LID IMECDECL LidSetLid(LID NewValue);

//Refresh notify support
IMESHAREAPI BOOL	IMECDECL FRefreshStyle();

//substitution
IMESHAREAPI BOOL	IMECDECL FSupportSty(UINT sty, UINT styAltered);

//style handling                            
IMESHAREAPI const IMESTYLE * IMECDECL PIMEStyleFromAttr(const UINT attr);
IMESHAREAPI const IMECOLORSTY * IMECDECL PColorStyleTextFromIMEStyle(const IMESTYLE * pimestyle);
IMESHAREAPI const IMECOLORSTY * IMECDECL PColorStyleBackFromIMEStyle(const IMESTYLE * pimestyle);
#define PIMESTY(x) (PIMEStyleFromAttr(x))
#define PTEXTIMECOL(x) (PColorStyleTextFromIMEStyle(PIMESTY(x)))
#define PBACKIMECOL(x) (PColorStyleBackFromIMEStyle(PIMESTY(x)))
IMESHAREAPI BOOL	IMECDECL FBoldIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI BOOL	IMECDECL FItalicIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI BOOL	IMECDECL FUlIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI UINT	IMECDECL IdUlIMEStyle(const IMESTYLE *pimestyle);

//color handling
IMESHAREAPI BOOL	IMECDECL FWinIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FFundamentalIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FRGBIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FSpecialIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FSpecialTextIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI BOOL	IMECDECL FSpecialWindowIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI COLORREF	IMECDECL RGBFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);

#ifdef IMESHARE_CPL
IMESHAREAPI UINT	IMECDECL IdSpecialFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI UINT	IMECDECL IdWinFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI UINT	IMECDECL IdFundamentalFromIMEColorStyle(const IMECOLORSTY *pcolorstyle);
IMESHAREAPI GRFSTY	IMECDECL GrfStyIMEStyle(const IMESTYLE *pimestyle);
IMESHAREAPI BOOL	IMECDECL FGetIMEStyleAttr(IMESTYLE *pimestyle, const UINT attr);
IMESHAREAPI BOOL	IMECDECL FSetIMEStyleAttr(const IMESTYLE *pimestyle, const UINT attr);
IMESHAREAPI BOOL	IMECDECL FSetIMEColorStyle(UINT attr, BOOL fTextCol, UINT id, DWORD col);
IMESHAREAPI BOOL	IMECDECL FSetIMEStyle(const UINT attr, BOOL fBold, BOOL fItalic, BOOL fUl, UINT idUl);
IMESHAREAPI BOOL	IMECDECL FSaveIMEShareSetting(void);
#endif // IMESHARE_CPL
#ifdef __cplusplus
}
#endif
#endif // OBSOLETE


#endif	// __IMESHARE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\gdiplustypes.h ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   GdiplusTypes.hpp
*
* Abstract:
*
*   Basic types used by GDI+
*
* Notes:
*
*   Only simple, generic types should go here. Imaging.dll depends on this file,
*   so it doesn't want to pick up a whole lot of unrelated
*   stuff. If your module needs some new, complicated types, give it its
*   own file.
*
* Revision History:
*
*   12/01/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GDIPLUSTYPES_H
#define _GDIPLUSTYPES_H
    
//--------------------------------------------------------------------------
// LIB version initialization functions
//--------------------------------------------------------------------------

typedef VOID (__cdecl *DEBUGEVENTFUNCTION)(INT level, CHAR *message);

extern "C" BOOL __stdcall InitializeGdiplus(DEBUGEVENTFUNCTION);
extern "C" VOID __stdcall UninitializeGdiplus();

//--------------------------------------------------------------------------
// Callback functions
//--------------------------------------------------------------------------

extern "C" {
typedef BOOL (CALLBACK * ImageAbort)(VOID *);
typedef ImageAbort DrawImageAbort;
typedef ImageAbort GetThumbnailImageAbort;
}

// Callback for EnumerateMetafile methods.  The parameters are:

//      recordType      WMF, EMF, or EMF+ record type
//      flags           (always 0 for WMF/EMF records)
//      dataSize        size of the record data (in bytes), or 0 if no data
//      data            pointer to the record data, or NULL if no data
//      callbackData    pointer to callbackData, if any

// This method can then call Metafile::PlayRecord to play the 
// record that was just enumerated.  If this method  returns 
// FALSE, the enumeration process is aborted.  Otherwise, it continues.

extern "C" {
typedef BOOL (CALLBACK * EnumerateMetafileProc)(EmfPlusRecordType,UINT,UINT,const BYTE*,VOID*);
}

//--------------------------------------------------------------------------
// Primitive data types
//
// NOTE:
//  Types already defined in standard header files:
//      INT32
//      UINT32
//      INT64
//      UINT64
//
//  Avoid using the following types:
//      LONG - use INT
//      ULONG - use UINT
//      DWORD - use UINT32
//--------------------------------------------------------------------------

typedef short INT16;                // signed 16-bit integer
typedef unsigned short UINT16;      // unsigned 16-bit integer
typedef float REAL;                 // double precision floating-point number

#define REAL_MAX            FLT_MAX
#define REAL_MIN            FLT_MIN
#define REAL_TOLERANCE     (FLT_MIN * 100)
#define REAL_EPSILON        1.192092896e-07F        /* FLT_EPSILON */

//--------------------------------------------------------------------------
// Forward declarations of various internal classes
//--------------------------------------------------------------------------

class Size;
class SizeF;
class Point;
class PointF;
class Rect;
class RectF;

//--------------------------------------------------------------------------
// Return values from any GDI+ API
//--------------------------------------------------------------------------

enum Status
{
    Ok = 0,
    GenericError = 1,
    InvalidParameter = 2,
    OutOfMemory = 3,
    ObjectBusy = 4,
    InsufficientBuffer = 5,
    NotImplemented = 6,
    Win32Error = 7,
    WrongState = 8,
    Aborted = 9,
#ifdef DCR_USE_NEW_135429    
    FileNotFound = 10,
    ValueOverflow = 11,
    AccessDenied = 12,
    UnknownImageFormat = 13,
    FontFamilyNotFound = 14,
    FontStyleNotFound = 15,
    NotTrueTypeFont = 16
#else
    NotFound = 10,
    ValueOverflow = 11
#endif    

};

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system
//  (floating-point coordinates)
//--------------------------------------------------------------------------

class SizeF
{
public:

   // Default constructor
    SizeF()
    {
        Width = Height = 0.0f;
    }

    SizeF(IN const SizeF& size)
    {
        Width = size.Width;
        Height = size.Height;
    }

    SizeF(IN REAL width, 
          IN REAL height)
    {
        Width = width;
        Height = height;
    }

    SizeF operator+(IN const SizeF& sz) const
    {
        return SizeF(Width + sz.Width,
                     Height + sz.Height);
    }

    SizeF operator-(IN const SizeF& sz) const
    {
        return SizeF(Width - sz.Width,
                     Height - sz.Height);
    }

    BOOL Equals(IN const SizeF& sz) const
    {
        return (Width == sz.Width) && (Height == sz.Height);
    }

    BOOL Empty() const
    {    
        return (Width == 0.0f && Height == 0.0f);
    }

public:

    REAL Width;
    REAL Height;
};

//--------------------------------------------------------------------------
// Represents a dimension in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class Size
{
public:

   // Default constructor
    Size()
    {
        Width = Height = 0;
    }

    Size(IN const Size& size)
    {
        Width = size.Width;
        Height = size.Height;
    }

    Size(IN INT width,
         IN INT height)
    {
        Width = width;
        Height = height;
    }

    Size operator+(IN const Size& sz) const
    {
        return Size(Width + sz.Width,
                    Height + sz.Height);
    }

    Size operator-(IN const Size& sz) const
    {
        return Size(Width - sz.Width,
                    Height - sz.Height);
    }

    BOOL Equals(IN const Size& sz) const
    {
        return (Width == sz.Width) && (Height == sz.Height);
    }

    BOOL Empty() const
    {    
        return (Width == 0 && Height == 0);
    }

public:

    INT Width;
    INT Height;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system
//  (floating-point coordinates)
//--------------------------------------------------------------------------

class PointF
{
public:
   PointF()
   {
       X = Y = 0.0f;
   }

   PointF(IN const PointF &point)
   {
       X = point.X;
       Y = point.Y;
   }

   PointF(IN const SizeF &size)
   {
       X = size.Width;
       Y = size.Height;
   }

   PointF(IN REAL x, 
          IN REAL y)
   {
       X = x;
       Y = y;
   }
   
   PointF operator+(IN const PointF& point) const
   {
       return PointF(X + point.X,
                     Y + point.Y);
   }

   PointF operator-(IN const PointF& point) const
   {
       return PointF(X - point.X,
                     Y - point.Y);
   }

   BOOL Equals(IN const PointF& point)
   {
       return (X == point.X) && (Y == point.Y);
   }

public:

    REAL X;
    REAL Y;
};

//--------------------------------------------------------------------------
// Represents a location in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class Point
{
public:
   Point()
   {
       X = Y = 0;
   }

   Point(IN const Point &point)
   {
       X = point.X;
       Y = point.Y;
   }

   Point(IN const Size &size)
   {
       X = size.Width;
       Y = size.Height;
   }

   Point(IN INT x,
         IN INT y)
   {
       X = x;
       Y = y;
   }
   
   Point operator+(IN const Point& point) const
   {
       return Point(X + point.X,
                    Y + point.Y);
   }

   Point operator-(IN const Point& point) const
   {
       return Point(X - point.X,
                    Y - point.Y);
   }

   BOOL Equals(IN const Point& point)
   {
       return (X == point.X) && (Y == point.Y);
   }

public:

    INT X;
    INT Y;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system
//  (floating-point coordinates)
//--------------------------------------------------------------------------

class RectF
{
public:

    // Default constructor

    RectF()
    {
        X = Y = Width = Height = 0.0f;
    }

    RectF(IN REAL x, 
          IN REAL y, 
          IN REAL width, 
          IN REAL height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    RectF(IN const PointF& location,
          IN const SizeF& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    RectF* Clone() const
    {
        return new RectF(X, Y, Width, Height);
    }

    VOID GetLocation(OUT PointF* point) const
    {
        point->X = X;
        point->Y = Y;
    }

    VOID GetSize(OUT SizeF* size) const
    {
        size->Width = Width;
        size->Height = Height;
    }

    VOID GetBounds(OUT RectF* rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }

    // Return the left, top, right, and bottom
    // coordinates of the rectangle

    REAL GetLeft() const
    {
        return X;
    }

    REAL GetTop() const
    {
        return Y;
    }
    
    REAL GetRight() const
    {
        return X+Width;
    }

    REAL GetBottom() const
    {
        return Y+Height;
    }

    // Determine if the rectangle is empty
    BOOL IsEmptyArea() const
    {
        return (Width <= REAL_EPSILON) || (Height <= REAL_EPSILON);
    }
    
    BOOL Equals(IN const RectF & rect) const
    {
        return X == rect.X && 
               Y == rect.Y && 
               Width == rect.Width && 
               Height == rect.Height;
    }

    BOOL Contains(IN REAL x, 
                  IN REAL y) const
    {
        return x >= X && x < X+Width &&
               y >= Y && y < Y+Height;
    }

    BOOL Contains(IN const PointF& pt) const
    {
        return Contains(pt.X, pt.Y);
    }

    BOOL Contains(IN const RectF& rect) const
    {
        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&
               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom()); 
    }
    
    VOID Inflate(IN REAL dx, 
                 IN REAL dy)
    {
        X -= dx;
        Y -= dy;
        Width += 2*dx;
        Height += 2*dy;
    }

    VOID Inflate(IN const PointF& point)
    {
        Inflate(point.X, point.Y);
    }
    
    // Intersect the current rect with the specified object

    BOOL Intersect(IN const RectF& rect)
    {
        return Intersect(*this, *this, rect);
    }

    // Intersect rect a and b and save the result into c
    // Notice that c may be the same object as a or b.

    static BOOL Intersect(OUT RectF& c,
                          IN const RectF& a, 
                          IN const RectF& b)
    {
        REAL right = min(a.GetRight(), b.GetRight());
        REAL bottom = min(a.GetBottom(), b.GetBottom());
        REAL left = max(a.GetLeft(), b.GetLeft());
        REAL top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    // Determine if the specified rect intersects with the
    // current rect object.

    BOOL IntersectsWith(IN const RectF& rect) const 
    {
        return (GetLeft() < rect.GetRight() &&
                GetTop() < rect.GetTop() &&
                GetRight() > rect.GetLeft() &&
                GetBottom() > rect.GetTop());
    }

    static BOOL Union(OUT RectF& c, 
                      IN const RectF& a, 
                      IN const RectF& b)
    {
        REAL right = max(a.GetRight(), b.GetRight());
        REAL bottom = max(a.GetBottom(), b.GetBottom());
        REAL left = min(a.GetLeft(), b.GetLeft());
        REAL top = min(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    VOID Offset(IN const PointF& point)
    {
        Offset(point.X, point.Y);
    }

    VOID Offset(IN REAL dx, 
                IN REAL dy)
    {
        X += dx;
        Y += dy;
    }

public:

    REAL X;
    REAL Y;
    REAL Width;
    REAL Height;
};

//--------------------------------------------------------------------------
// Represents a rectangle in a 2D coordinate system
//  (integer coordinates)
//--------------------------------------------------------------------------

class Rect
{
public:

    // Default constructor

    Rect()
    {
        X = Y = Width = Height = 0;
    }

    Rect(IN INT x, 
         IN INT y, 
         IN INT width, 
         IN INT height)
    {
        X = x;
        Y = y;
        Width = width;
        Height = height;
    }

    Rect(IN const Point& location, 
         IN const Size& size)
    {
        X = location.X;
        Y = location.Y;
        Width = size.Width;
        Height = size.Height;
    }

    Rect* Clone() const
    {
        return new Rect(X, Y, Width, Height);
    }

    VOID GetLocation(OUT Point* point) const
    {
        point->X = X;
        point->Y = Y;
    }

    VOID GetSize(OUT Size* size) const
    {
        size->Width = Width;
        size->Height = Height;
    }

    VOID GetBounds(OUT Rect* rect) const
    {
        rect->X = X;
        rect->Y = Y;
        rect->Width = Width;
        rect->Height = Height;
    }

    // Return the left, top, right, and bottom
    // coordinates of the rectangle

    INT GetLeft() const
    {
        return X;
    }

    INT GetTop() const
    {
        return Y;
    }
    
    INT GetRight() const
    {
        return X+Width;
    }

    INT GetBottom() const
    {
        return Y+Height;
    }

    // Determine if the rectangle is empty
    BOOL IsEmptyArea() const
    {
        return (Width <= 0) || (Height <= 0);
    }

    BOOL Equals(IN const Rect & rect) const
    {
        return X == rect.X &&
               Y == rect.Y &&
               Width == rect.Width &&
               Height == rect.Height;
    }

    BOOL Contains(IN INT x, 
                  IN INT y) const
    {
        return x >= X && x < X+Width &&
               y >= Y && y < Y+Height;
    }

    BOOL Contains(IN const Point& pt) const 
    {
        return Contains(pt.X, pt.Y);
    }

    BOOL Contains(IN Rect& rect) const
    {
        return (X <= rect.X) && (rect.GetRight() <= GetRight()) &&
               (Y <= rect.Y) && (rect.GetBottom() <= GetBottom()); 
    }
    
    VOID Inflate(IN INT dx, 
                 IN INT dy)
    {
        X -= dx;
        Y -= dy;
        Width += 2*dx;
        Height += 2*dy;
    }

    VOID Inflate(IN const Point& point)
    {
        Inflate(point.X, point.Y);
    }
    
    // Intersect the current rect with the specified object

    BOOL Intersect(IN const Rect& rect)
    {
        return Intersect(*this, *this, rect);
    }

    // Intersect rect a and b and save the result into c
    // Notice that c may be the same object as a or b.

    static BOOL Intersect(OUT Rect& c,
                          IN const Rect& a, 
                          IN const Rect& b)
    {
        INT right = min(a.GetRight(), b.GetRight());
        INT bottom = min(a.GetBottom(), b.GetBottom());
        INT left = max(a.GetLeft(), b.GetLeft());
        INT top = max(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    // Determine if the specified rect intersects with the
    // current rect object.

    BOOL IntersectsWith(IN const Rect& rect) const
    {
        return (GetLeft() < rect.GetRight() &&
                GetTop() < rect.GetTop() &&
                GetRight() > rect.GetLeft() &&
                GetBottom() > rect.GetTop());
    }

    static BOOL Union(OUT Rect& c,
                      IN const Rect& a,
                      IN const Rect& b)
    {
        INT right = max(a.GetRight(), b.GetRight());
        INT bottom = max(a.GetBottom(), b.GetBottom());
        INT left = min(a.GetLeft(), b.GetLeft());
        INT top = min(a.GetTop(), b.GetTop());

        c.X = left;
        c.Y = top;
        c.Width = right - left;
        c.Height = bottom - top;
        return !c.IsEmptyArea();
    }

    VOID Offset(IN const Point& point)
    {
        Offset(point.X, point.Y);
    }

    VOID Offset(IN INT dx, 
                IN INT dy)
    {
        X += dx;
        Y += dy;
    }

public:

    INT X;
    INT Y;
    INT Width;
    INT Height;
};

// A user must mange memory for PathData.

class PathData
{
public:
    PathData()
    {
        Count = 0;
        Points = NULL;
        Types = NULL;
    }

    ~PathData()
    {
        if (Points != NULL) 
        {
            delete Points;
        }
        
        if (Types != NULL) 
        {
            delete Types;
        }
    }

public:
    INT Count;
    PointF* Points;
    BYTE* Types;
};

#endif // !_GDIPLUSTYPES_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\outpos.h ===
/*----------------------------------------------------------------------------
	%%File: OUTPOS.H
	%%Unit: OUTPOS
	%%Contact: seijia

	mapping from public and private pos
----------------------------------------------------------------------------*/

#ifndef __OUTPOS_H__
#define __OUTPOS_H__

#define JPOS_UNDEFINED		0

#define JPOS_MEISHI_FUTSU		100		//
#define JPOS_MEISHI_SAHEN		101		//ϖ
#define JPOS_MEISHI_ZAHEN		102		//ϖ
#define JPOS_MEISHI_KEIYOUDOUSHI		103		//`
#define JPOS_HUKUSIMEISHI		104		//I
#define JPOS_MEISA_KEIDOU		105		//ό`
#define JPOS_JINMEI		106		//l
#define JPOS_JINMEI_SEI		107		//
#define JPOS_JINMEI_MEI		108		//
#define JPOS_CHIMEI		109		//n
#define JPOS_CHIMEI_KUNI		110		//
#define JPOS_CHIMEI_KEN		111		//
#define JPOS_CHIMEI_GUN		112		//S
#define JPOS_CHIMEI_KU		113		//
#define JPOS_CHIMEI_SHI		114		//s
#define JPOS_CHIMEI_MACHI		115		//
#define JPOS_CHIMEI_MURA		116		//
#define JPOS_CHIMEI_EKI		117		//w
#define JPOS_SONOTA		118		//ŗL
#define JPOS_SHAMEI		119		//Ж
#define JPOS_SOSHIKI		120		//gD
#define JPOS_KENCHIKU		121		//z
#define JPOS_BUPPIN		122		//i
#define JPOS_DAIMEISHI		123		//㖼
#define JPOS_DAIMEISHI_NINSHOU		124		//l̑㖼
#define JPOS_DAIMEISHI_SHIJI		125		//w㖼
#define JPOS_KAZU		126		//
#define JPOS_KAZU_SURYOU		127		//
#define JPOS_KAZU_SUSHI		128		//
#define JPOS_5DAN_AWA		200		//s
#define JPOS_5DAN_KA		201		//s
#define JPOS_5DAN_GA		202		//s
#define JPOS_5DAN_SA		203		//s
#define JPOS_5DAN_TA		204		//s
#define JPOS_5DAN_NA		205		//ȍs
#define JPOS_5DAN_BA		206		//΍s
#define JPOS_5DAN_MA		207		//܍s
#define JPOS_5DAN_RA		208		//s
#define JPOS_5DAN_AWAUON		209		//s
#define JPOS_5DAN_KASOKUON		210		//s
#define JPOS_5DAN_RAHEN		211		//sϊi
#define JPOS_4DAN_HA		212		//͍sli
#define JPOS_1DAN		213		//i
#define JPOS_TOKUSHU_KAHEN		214		//ϓ
#define JPOS_TOKUSHU_SAHENSURU		215		//ϓ
#define JPOS_TOKUSHU_SAHEN		216		//sϊi
#define JPOS_TOKUSHU_ZAHEN		217		//sϊi
#define JPOS_TOKUSHU_NAHEN		218		//ȍsϊi
#define JPOS_KURU_KI		219		//
#define JPOS_KURU_KITA		220		//
#define JPOS_KURU_KITARA		221		//
#define JPOS_KURU_KITARI		222		//
#define JPOS_KURU_KITAROU		223		//낤
#define JPOS_KURU_KITE		224		//
#define JPOS_KURU_KUREBA		225		//
#define JPOS_KURU_KO		226		//iȂj
#define JPOS_KURU_KOI		227		//
#define JPOS_KURU_KOYOU		228		//悤
#define JPOS_SURU_SA		229		//
#define JPOS_SURU_SI		230		//
#define JPOS_SURU_SITA		231		//
#define JPOS_SURU_SITARA		232		//
#define JPOS_SURU_SIATRI		233		//
#define JPOS_SURU_SITAROU		234		//낤
#define JPOS_SURU_SITE		235		//
#define JPOS_SURU_SIYOU		236		//悤
#define JPOS_SURU_SUREBA		237		//
#define JPOS_SURU_SE		238		//
#define JPOS_SURU_SEYO		239		//^
#define JPOS_KEIYOU		300		//`e
#define JPOS_KEIYOU_GARU		301		//`e
#define JPOS_KEIYOU_GE		302		//`e
#define JPOS_KEIYOU_ME		303		//`e
#define JPOS_KEIYOU_YUU		304		//`e
#define JPOS_KEIYOU_U		305		//`e
#define JPOS_KEIDOU		400		//`e
#define JPOS_KEIDOU_NO		401		//`e
#define JPOS_KEIDOU_TARU		402		//`e
#define JPOS_KEIDOU_GARU		403		//`e
#define JPOS_FUKUSHI		500		//
#define JPOS_FUKUSHI_SAHEN		501		//ϕ
#define JPOS_FUKUSHI_NI		502		//
#define JPOS_FUKUSHI_NANO		503		//
#define JPOS_FUKUSHI_DA		504		//
#define JPOS_FUKUSHI_TO		505		//
#define JPOS_FUKUSHI_TOSURU		506		//Ă
#define JPOS_RENTAISHI		600		//A̎
#define JPOS_RENTAISHI_SHIJI		601		//wA̎
#define JPOS_SETSUZOKUSHI		650		//ڑ
#define JPOS_KANDOUSHI		670		//
#define JPOS_SETTOU		700		//ړ
#define JPOS_SETTOU_KAKU		701		//Pړ
#define JPOS_SETTOU_SAI		702		//Qړ
#define JPOS_SETTOU_FUKU		703		//Rړ
#define JPOS_SETTOU_MI		704		//Sړ
#define JPOS_SETTOU_DAISHOU		705		//Tړ
#define JPOS_SETTOU_KOUTEI		706		//Uړ
#define JPOS_SETTOU_CHOUTAN		707		//Vړ
#define JPOS_SETTOU_SHINKYU		708		//Wړ
#define JPOS_SETTOU_JINMEI		709		//lړ
#define JPOS_SETTOU_CHIMEI		710		//nړ
#define JPOS_SETTOU_SONOTA		711		//ŗLړ
#define JPOS_SETTOU_JOSUSHI		712		//Ou
#define JPOS_SETTOU_TEINEI_O		713		//JPړ
#define JPOS_SETTOU_TEINEI_GO		714		//JQړ
#define JPOS_SETTOU_TEINEI_ON		715		//JRړ
#define JPOS_SETSUBI		800		//ڔ
#define JPOS_SETSUBI_TEKI		801		//Pڔ
#define JPOS_SETSUBI_SEI		802		//Qڔ
#define JPOS_SETSUBI_KA		803		//Rڔ
#define JPOS_SETSUBI_CHU		804		//Sڔ
#define JPOS_SETSUBI_FU		805		//Tڔ
#define JPOS_SETSUBI_RYU		806		//Uڔ
#define JPOS_SETSUBI_YOU		807		//Vڔ
#define JPOS_SETSUBI_KATA		808		//Wڔ
#define JPOS_SETSUBI_MEISHIRENDAKU		809		//A
#define JPOS_SETSUBI_JINMEI		810		//lڔ
#define JPOS_SETSUBI_CHIMEI		811		//nڔ
#define JPOS_SETSUBI_KUNI		812		//ڔ
#define JPOS_SETSUBI_KEN		813		//ڔ
#define JPOS_SETSUBI_GUN		814		//Sڔ
#define JPOS_SETSUBI_KU		815		//ڔ
#define JPOS_SETSUBI_SHI		816		//sڔ
#define JPOS_SETSUBI_MACHI		817		//Pڔ
#define JPOS_SETSUBI_CHOU		818		//Qڔ
#define JPOS_SETSUBI_MURA		819		//Pڔ
#define JPOS_SETSUBI_SON		820		//Qڔ
#define JPOS_SETSUBI_EKI		821		//wڔ
#define JPOS_SETSUBI_SONOTA		822		//ŗLڔ
#define JPOS_SETSUBI_SHAMEI		823		//Жڔ
#define JPOS_SETSUBI_SOSHIKI		824		//gDڔ
#define JPOS_SETSUBI_KENCHIKU		825		//zڔ
#define JPOS_RENYOU_SETSUBI		826		//Apڔ
#define JPOS_SETSUBI_JOSUSHI		827		//u
#define JPOS_SETSUBI_JOSUSHIPLUS		828		//u{
#define JPOS_SETSUBI_JIKAN		829		//ԏ
#define JPOS_SETSUBI_JIKANPLUS		830		//ԏ{
#define JPOS_SETSUBI_TEINEI		831		//Jڔ
#define JPOS_SETSUBI_SAN		832		//JPڔ
#define JPOS_SETSUBI_KUN		833		//JQڔ
#define JPOS_SETSUBI_SAMA		834		//JRڔ
#define JPOS_SETSUBI_DONO		835		//JSڔ
#define JPOS_SETSUBI_FUKUSU		836		//ڔ
#define JPOS_SETSUBI_TACHI		837		//Pڔ
#define JPOS_SETSUBI_RA		838		//Qڔ
#define JPOS_TANKANJI		900		//P
#define JPOS_TANKANJI_KAO		901		//
#define JPOS_KANYOUKU		902		//p
#define JPOS_DOKURITSUGO		903		//Ɨ
#define JPOS_FUTEIGO		904		//s
#define JPOS_KIGOU		905		//L
#define JPOS_EIJI		906		//p
#define JPOS_KUTEN		907		//_
#define JPOS_TOUTEN		908		//Ǔ_
#define JPOS_KANJI		909		//͕s\
#define JPOS_OPENBRACE		910		//J
#define JPOS_CLOSEBRACE		911		//


#pragma pack (push, 1)
//POS table data structure
typedef struct _POSTBL
{
	WORD		nPos;					//pos number
	BYTE		*szName;				//name of pos
} POSTBL;
#pragma pack (pop)

#ifdef __cplusplus
extern "C" {
#endif

//function prototypes
extern POSTBL *ObtainPosTable(int *pcPos);
extern WORD WPosExtFromIn(WORD wPos);
extern WORD WPosInFromExt(WORD wPos);
#ifdef __cplusplus
} /* end of 'extern "C" {' */
#endif

#endif //__OUTPOS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\zmouse.h ===
/******************************************************************************\
*       ZMOUSE.H - Include file for MSDELTA Zoom mouse DLL. 
*
*       AUTHOR - Paul Henderson, July 1995
*                Lora McCambridge January 1996
*       REVISIONS - 
*        Lora McCambridge April 1996 - removing WM_MOUSEWHEEL, this
*             message will only be available via the OS.  Applications
*             must now register the message MSH_MOUSEWHEEL, and
*             use that message for messages from MSWHEEL.  
*       LKM May 1996 - Added add'l #defines for class and title of the wheel
*                      module window to reflect the MSH_ style.
*                    - Added #defines for WHEEL SUPPORT and Scroll Lines
*                    - Added inline function HwndMsWheel, apps can use
*                      this function to retrieve the handle to mswheel,
*                      get the message ID's for the registered messages,
*                      the flag for 3d support, and the value for scroll
*                      lines. Please in function at end of file.
*
*       Copyright (C) 1995, 1996 Microsoft Corporation.
*       All rights reserved. 
\******************************************************************************/


/**************************************************************************
	 Client Appplication (API) Defines for Wheel rolling
***************************************************************************/


// Apps need to call RegisterWindowMessage using the #define below to
// get the message number that is sent to the foreground window
// when a wheel roll occurs

#define MSH_MOUSEWHEEL "MSWHEEL_ROLLMSG"
   // wParam = zDelta expressed in multiples of WHEEL_DELTA
   // lParam is the mouse coordinates

#define WHEEL_DELTA      120      // Default value for rolling one detent


#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL (WM_MOUSELAST+1)  // message that will be supported
                                        // by the OS 
#endif


/**************************************************************************
    Client Appplication (API) Defines for
	 determining 3D support active
	 determining # of Scroll Lines
***************************************************************************/

// Class name for Magellan/Z MSWHEEL window
// use FindWindow to get hwnd to MSWHEEL
#define MOUSEZ_CLASSNAME  "MouseZ"           // wheel window class  
#define MOUSEZ_TITLE      "Magellan MSWHEEL" // wheel window title

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

// Apps need to call RegisterWindowMessage using the #defines below to
// get the message number that can be sent to the MSWHEEL window to
// query if wheel support is active (MSH_WHEELSUPPORT), and the message
// number to query the number of scroll lines (MSH_SCROLLLINES).  
// To send a message to MSWheel window, use FindWindow with the #defines
// for CLASS and TITLE above.  If FindWindow fails to find the MSWHEEL
// window or the return from SendMessage is false, then Wheel support
// is currently not available.

#define MSH_WHEELSUPPORT "MSH_WHEELSUPPORT_MSG" // name of msg to send
                                                // to query for wheel support
// MSH_WHEELSUPPORT
//    wParam - not used 
//    lParam - not used
//    returns BOOL - TRUE if wheel support is active, FALSE otherwise

                                
#define MSH_SCROLL_LINES "MSH_SCROLL_LINES_MSG"

// MSH_SCROLL_LINES
//    wParam - not used 
//    lParam - not used
//    returns int  - number of lines to scroll on a wheel roll

#ifndef  WHEEL_PAGESCROLL  
#define WHEEL_PAGESCROLL  (UINT_MAX)    // signifies to scroll a page, to
					// be defined in updated winuser.h
					// in SDK release for NT4.0
#endif 


// NB!! The remainder of the original header file has been deleted since it
// doesn't compile.  RichEdit doesn't need the remainder in any event.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\imm.h ===
/**********************************************************************/
/*      IMM.H - Input Method Manager definitions                      */
/*                                                                    */
/*      Copyright (c) 1993-1995  Microsoft Corporation                */
/**********************************************************************/

#ifndef _IMM_
#define _IMM_        // defined if IMM.H has been included

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _WINUSER_
#define VK_PROCESSKEY 0x0E5
#endif

#ifndef IMM_WINVER
#define IMM_WINVER 0x040A
#endif

//#if(IMM_WINVER >= 0x040A)
//DECLARE_HANDLE(HIMC);
//#else
typedef DWORD     HIMC;
//#endif

//#if(IMM_WINVER >= 0x040A)
//DECLARE_HANDLE(HIMCC);
//#else
typedef DWORD     HIMCC;
//#endif

typedef HKL FAR  *LPHKL;
typedef UINT FAR *LPUINT;

#define NULLIMC  ((HIMC)0)

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, NEAR *NPCOMPOSITIONFORM, FAR *LPCOMPOSITIONFORM;

typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, NEAR *NPCANDIDATEFORM, FAR *LPCANDIDATEFORM;

typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, NEAR *NPCANDIDATELIST, FAR *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA, NEAR *NPREGISTERWORDA, FAR *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW, NEAR *NPREGISTERWORDW, FAR *LPREGISTERWORDW;
#ifdef UNICODE
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#else
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#endif // UNICODE

#if(IMM_WINVER >= 0x040A)
typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, NEAR *NPRECONVERTSTRING, FAR *LPRECONVERTSTRING;
#endif

#define STYLE_DESCRIPTION_SIZE  32

typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFA, *PSTYLEBUFA, NEAR *NPSTYLEBUFA, FAR *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFW, *PSTYLEBUFW, NEAR *NPSTYLEBUFW, FAR *LPSTYLEBUFW;
#ifdef UNICODE
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#else
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#endif // UNICODE

#if(IMM_WINVER >= 0x040A)
#define IMEMENUITEM_STRING_SIZE 80 

typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, NEAR *NPIMEMENUITEMINFOA, FAR *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, NEAR *NPIMEMENUITEMINFOW, FAR *LPIMEMENUITEMINFOW;
#ifdef UNICODE
typedef IMEMENUITEMINFOW IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOW PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOW NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOW LPIMEMENUITEMINFO;
#else
typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#endif // UNICODE

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, NEAR *NPIMECHARPOSITION, FAR *LPIMECHARPOSITION;

#endif /* IMM_WINVER >= 0x040A */

// prototype of IMM API

HKL  WINAPI ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
HKL  WINAPI ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);
#ifdef UNICODE
#define ImmInstallIME  ImmInstallIMEW
#else
#define ImmInstallIME  ImmInstallIMEA
#endif // !UNICODE

HWND WINAPI ImmGetDefaultIMEWnd(HWND);

UINT WINAPI ImmGetDescriptionA(HKL, LPSTR, UINT uBufLen);
UINT WINAPI ImmGetDescriptionW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetDescription  ImmGetDescriptionW
#else
#define ImmGetDescription  ImmGetDescriptionA
#endif // !UNICODE

UINT WINAPI ImmGetIMEFileNameA(HKL, LPSTR, UINT uBufLen);
UINT WINAPI ImmGetIMEFileNameW(HKL, LPWSTR, UINT uBufLen);
#ifdef UNICODE
#define ImmGetIMEFileName  ImmGetIMEFileNameW
#else
#define ImmGetIMEFileName  ImmGetIMEFileNameA
#endif // !UNICODE

DWORD WINAPI ImmGetProperty(HKL, DWORD);

BOOL WINAPI ImmIsIME(HKL);

BOOL WINAPI ImmSimulateHotKey(HWND, DWORD);

HIMC WINAPI ImmCreateContext(void);
BOOL WINAPI ImmDestroyContext(HIMC);
HIMC WINAPI ImmGetContext(HWND);
BOOL WINAPI ImmReleaseContext(HWND, HIMC);
HIMC WINAPI ImmAssociateContext(HWND, HIMC);
#if(IMM_WINVER >= 0x040A)
BOOL WINAPI ImmAssociateContextEx(HWND, HIMC, DWORD);
#endif /* IMM_WINVER >= 0x040A */

LONG  WINAPI ImmGetCompositionStringA(HIMC, DWORD, LPVOID, DWORD);
LONG  WINAPI ImmGetCompositionStringW(HIMC, DWORD, LPVOID, DWORD);
#ifdef UNICODE
#define ImmGetCompositionString  ImmGetCompositionStringW
#else
#define ImmGetCompositionString  ImmGetCompositionStringA
#endif // !UNICODE

BOOL  WINAPI ImmSetCompositionStringA(HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);
BOOL  WINAPI ImmSetCompositionStringW(HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD);
#ifdef UNICODE
#define ImmSetCompositionString  ImmSetCompositionStringW
#else
#define ImmSetCompositionString  ImmSetCompositionStringA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListCountA(HIMC, LPDWORD);
DWORD WINAPI ImmGetCandidateListCountW(HIMC, LPDWORD);
#ifdef UNICODE
#define ImmGetCandidateListCount  ImmGetCandidateListCountW
#else
#define ImmGetCandidateListCount  ImmGetCandidateListCountA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListA(HIMC, DWORD, LPCANDIDATELIST, DWORD);
DWORD WINAPI ImmGetCandidateListW(HIMC, DWORD, LPCANDIDATELIST, DWORD);
#ifdef UNICODE
#define ImmGetCandidateList  ImmGetCandidateListW
#else
#define ImmGetCandidateList  ImmGetCandidateListA
#endif // !UNICODE

DWORD WINAPI ImmGetGuideLineA(HIMC, DWORD, LPSTR, DWORD);
DWORD WINAPI ImmGetGuideLineW(HIMC, DWORD, LPWSTR, DWORD);
#ifdef UNICODE
#define ImmGetGuideLine  ImmGetGuideLineW
#else
#define ImmGetGuideLine  ImmGetGuideLineA
#endif // !UNICODE

BOOL WINAPI ImmGetConversionStatus(HIMC, LPDWORD, LPDWORD);
BOOL WINAPI ImmSetConversionStatus(HIMC, DWORD, DWORD);
BOOL WINAPI ImmGetOpenStatus(HIMC);
BOOL WINAPI ImmSetOpenStatus(HIMC, BOOL);

BOOL WINAPI ImmGetCompositionFontA(HIMC, LPLOGFONTA);
BOOL WINAPI ImmGetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmGetCompositionFont  ImmGetCompositionFontW
#else
#define ImmGetCompositionFont  ImmGetCompositionFontA
#endif // !UNICODE

BOOL WINAPI ImmSetCompositionFontA(HIMC, LPLOGFONTA);
BOOL WINAPI ImmSetCompositionFontW(HIMC, LPLOGFONTW);
#ifdef UNICODE
#define ImmSetCompositionFont  ImmSetCompositionFontW
#else
#define ImmSetCompositionFont  ImmSetCompositionFontA
#endif // !UNICODE

BOOL    WINAPI ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID);
BOOL    WINAPI ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID);
#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE

LRESULT WINAPI ImmEscapeA(HKL, HIMC, UINT, LPVOID);
LRESULT WINAPI ImmEscapeW(HKL, HIMC, UINT, LPVOID);
#if 0
#ifdef UNICODE
#define ImmEscape  ImmEscapeW
#else
#define ImmEscape  ImmEscapeA
#endif // !UNICODE
#endif
DWORD   WINAPI ImmGetConversionListA(HKL, HIMC, LPCSTR, LPCANDIDATELIST, DWORD, UINT);
DWORD   WINAPI ImmGetConversionListW(HKL, HIMC, LPCWSTR, LPCANDIDATELIST, DWORD, UINT);
#ifdef UNICODE
#define ImmGetConversionList  ImmGetConversionListW
#else
#define ImmGetConversionList  ImmGetConversionListA
#endif // !UNICODE

BOOL    WINAPI ImmNotifyIME(HIMC, DWORD, DWORD, DWORD);

BOOL WINAPI ImmGetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmSetStatusWindowPos(HIMC, LPPOINT);
BOOL WINAPI ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM);
BOOL WINAPI ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM);
BOOL WINAPI ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM);

BOOL WINAPI ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM);
BOOL WINAPI ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM);
#ifdef UNICODE
#define ImmIsUIMessage  ImmIsUIMessageW
#else
#define ImmIsUIMessage  ImmIsUIMessageA
#endif // !UNICODE

UINT WINAPI ImmGetVirtualKey(HWND);

typedef int (CALLBACK *REGISTERWORDENUMPROCA)(LPCSTR, DWORD, LPCSTR, LPVOID);
typedef int (CALLBACK *REGISTERWORDENUMPROCW)(LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCW
#else
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCA
#endif // !UNICODE

BOOL WINAPI ImmRegisterWordA(HKL, LPCSTR, DWORD, LPCSTR);
BOOL WINAPI ImmRegisterWordW(HKL, LPCWSTR, DWORD, LPCWSTR);
#ifdef UNICODE
#define ImmRegisterWord  ImmRegisterWordW
#else
#define ImmRegisterWord  ImmRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmUnregisterWordA(HKL, LPCSTR, DWORD, LPCSTR);
BOOL WINAPI ImmUnregisterWordW(HKL, LPCWSTR, DWORD, LPCWSTR);
#ifdef UNICODE
#define ImmUnregisterWord  ImmUnregisterWordW
#else
#define ImmUnregisterWord  ImmUnregisterWordA
#endif // !UNICODE

UINT WINAPI ImmGetRegisterWordStyleA(HKL, UINT, LPSTYLEBUFA);
UINT WINAPI ImmGetRegisterWordStyleW(HKL, UINT, LPSTYLEBUFW);
#ifdef UNICODE
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleW
#else
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleA
#endif // !UNICODE

UINT WINAPI ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR, DWORD, LPCSTR, LPVOID);
UINT WINAPI ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR, DWORD, LPCWSTR, LPVOID);
#ifdef UNICODE
#define ImmEnumRegisterWord  ImmEnumRegisterWordW
#else
#define ImmEnumRegisterWord  ImmEnumRegisterWordA
#endif // !UNICODE

#if(IMM_WINVER >= 0x040A)
BOOL WINAPI ImmDisableIME(DWORD);
DWORD WINAPI ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA, LPIMEMENUITEMINFOA, DWORD);
DWORD WINAPI ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW, LPIMEMENUITEMINFOW, DWORD);
#ifdef UNICODE
#define ImmGetImeMenuItems  ImmGetImeMenuItemsW
#else
#define ImmGetImeMenuItems  ImmGetImeMenuItemsA
#endif // !UNICODE
#ifdef UNICODE
#define ImmRequestMessage  ImmRequestMessageW
#else
#define ImmRequestMessage  ImmRequestMessageA
#endif // !UNICODE
#endif /* IMM_WINVER >= 0x040A */

// the IME related messages
#define WM_CONVERTREQUESTEX             0x0108
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F

#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286
#define WM_IME_REQUEST                  0x0288

#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291

// wParam for WM_IME_CONTROL                 
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022

// wParam for WM_IME_CONTROL to the soft keyboard
// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE                0x0010
#define NI_CLOSECANDIDATE               0x0011
#define NI_SELECTCANDIDATESTR           0x0012
#define NI_CHANGECANDIDATELIST          0x0013
#define NI_FINALIZECONVERSIONRESULT     0x0014
#define NI_COMPOSITIONSTR               0x0015
#define NI_SETCANDIDATE_PAGESTART       0x0016
#define NI_SETCANDIDATE_PAGESIZE        0x0017
#define NI_IMEMENUSELECTED              0x0018

// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW       0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW     0x80000000
#define ISC_SHOWUIGUIDELINE             0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW    0x0000000F
#define ISC_SHOWUIALL                   0xC000000F

// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE                    0x0001
#define CPS_CONVERT                     0x0002
#define CPS_REVERT                      0x0003
#define CPS_CANCEL                      0x0004

// the modifiers of hot key
#define MOD_ALT                         0x0001
#define MOD_CONTROL                     0x0002
#define MOD_SHIFT                       0x0004

#define MOD_LEFT                        0x8000
#define MOD_RIGHT                       0x4000

#define MOD_ON_KEYUP                    0x0800
#define MOD_IGNORE_ALL_MODIFIER         0x0400

// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_IME_NONIME_TOGGLE           0x10
#define IME_CHOTKEY_SHAPE_TOGGLE                0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE               0x12

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_CLOSE_OPEN                  0x30

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_SHAPE_TOGGLE                0x50
#define IME_KHOTKEY_HANJACONVERT                0x51
#define IME_KHOTKEY_ENGLISH                     0x52

// Windows for Tranditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_IME_NONIME_TOGGLE           0x70
#define IME_THOTKEY_SHAPE_TOGGLE                0x71
#define IME_THOTKEY_SYMBOL_TOGGLE               0x72

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST                0x100
#define IME_HOTKEY_DSWITCH_LAST                 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_HOTKEY_PRIVATE_FIRST                0x200
#define IME_ITHOTKEY_RESEND_RESULTSTR           0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION       0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE             0x202
#define IME_ITHOTKEY_RECONVERTSTRING            0x203
#define IME_HOTKEY_PRIVATE_LAST                 0x21F

// dwSystemInfoFlags bits

// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR                 0x0001
#define GCS_COMPREADATTR                0x0002
#define GCS_COMPREADCLAUSE              0x0004
#define GCS_COMPSTR                     0x0008
#define GCS_COMPATTR                    0x0010
#define GCS_COMPCLAUSE                  0x0020
#define GCS_CURSORPOS                   0x0080
#define GCS_DELTASTART                  0x0100
#define GCS_RESULTREADSTR               0x0200
#define GCS_RESULTREADCLAUSE            0x0400
#define GCS_RESULTSTR                   0x0800
#define GCS_RESULTCLAUSE                0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR                   0x2000
#define CS_NOMOVECARET                  0x4000

// bits of fdwInit of INPUTCONTEXT
// IME version constants
#define IMEVER_0310                     0x0003000A
#define IMEVER_0400                     0x00040000

// IME property bits
#define IME_PROP_AT_CARET               0x00010000
#define IME_PROP_SPECIAL_UI             0x00020000
#define IME_PROP_CANDLIST_START_FROM_1  0x00040000
#define IME_PROP_UNICODE                0x00080000
#define IME_PROP_COMPLETE_ON_UNSELECT   0x00100000

// IME UICapability bits
#define UI_CAP_2700                     0x00000001
#define UI_CAP_ROT90                    0x00000002
#define UI_CAP_ROTANY                   0x00000004

// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR                 0x00000001
#define SCS_CAP_MAKEREAD                0x00000002
#define SCS_CAP_SETRECONVERTSTRING      0x00000004

// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION           0x00000001
#define SELECT_CAP_SENTENCE             0x00000002

// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL                       0x00000001
#define GGL_INDEX                       0x00000002
#define GGL_STRING                      0x00000003
#define GGL_PRIVATE                     0x00000004

// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE            0x00000000
#define GL_LEVEL_FATAL                  0x00000001
#define GL_LEVEL_ERROR                  0x00000002
#define GL_LEVEL_WARNING                0x00000003
#define GL_LEVEL_INFORMATION            0x00000004

// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN                   0x00000000
#define GL_ID_NOMODULE                  0x00000001
#define GL_ID_NODICTIONARY              0x00000010
#define GL_ID_CANNOTSAVE                0x00000011
#define GL_ID_NOCONVERT                 0x00000020
#define GL_ID_TYPINGERROR               0x00000021
#define GL_ID_TOOMANYSTROKE             0x00000022
#define GL_ID_READINGCONFLICT           0x00000023
#define GL_ID_INPUTREADING              0x00000024
#define GL_ID_INPUTRADICAL              0x00000025
#define GL_ID_INPUTCODE                 0x00000026
#define GL_ID_INPUTSYMBOL               0x00000027
#define GL_ID_CHOOSECANDIDATE           0x00000028
#define GL_ID_REVERSECONVERSION         0x00000029
#define GL_ID_PRIVATE_FIRST             0x00008000
#define GL_ID_PRIVATE_LAST              0x0000FFFF

// ID for dwIndex of ImmGetProperty
#define IGP_GETIMEVERSION               (DWORD)(-4)
#define IGP_PROPERTY                    0x00000004
#define IGP_CONVERSION                  0x00000008
#define IGP_SENTENCE                    0x0000000c
#define IGP_UI                          0x00000010
#define IGP_SETCOMPSTR                  0x00000014
#define IGP_SELECT                      0x00000018

// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR                      (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR                  (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE                (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)
#define SCS_SETRECONVERTSTRING          0x00010000
#define SCS_QUERYRECONVERTSTRING        0x00020000

// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT                      0x00
#define ATTR_TARGET_CONVERTED           0x01
#define ATTR_CONVERTED                  0x02
#define ATTR_TARGET_NOTCONVERTED        0x03
#define ATTR_INPUT_ERROR                0x04
#define ATTR_FIXEDCONVERTED             0x05

// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT                     0x0000
#define CFS_RECT                        0x0001
#define CFS_POINT                       0x0002
#define CFS_FORCE_POSITION              0x0020
#define CFS_CANDIDATEPOS                0x0040
#define CFS_EXCLUDE                     0x0080

// conversion direction for ImmGetConversionList
#define GCL_CONVERSION                  0x0001
#define GCL_REVERSECONVERSION           0x0002
#define GCL_REVERSE_LENGTH              0x0003

// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC          0x0000
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_CHINESE               IME_CMODE_NATIVE
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE              IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA              0x0002  // only effect under IME_CMODE_NATIVE
#define IME_CMODE_LANGUAGE              0x0003
#define IME_CMODE_FULLSHAPE             0x0008
#define IME_CMODE_ROMAN                 0x0010
#define IME_CMODE_CHARCODE              0x0020
#define IME_CMODE_HANJACONVERT          0x0040
#define IME_CMODE_SOFTKBD               0x0080
#define IME_CMODE_NOCONVERSION          0x0100
#define IME_CMODE_EUDC                  0x0200
#define IME_CMODE_SYMBOL                0x0400
#define IME_CMODE_FIXED                 0x0800

#define IME_SMODE_NONE                  0x0000
#define IME_SMODE_PLAURALCLAUSE         0x0001
#define IME_SMODE_SINGLECONVERT         0x0002
#define IME_SMODE_AUTOMATIC             0x0004
#define IME_SMODE_PHRASEPREDICT         0x0008
#define IME_SMODE_CONVERSATION          0x0010

// style of candidate
#define IME_CAND_UNKNOWN                0x0000
#define IME_CAND_READ                   0x0001
#define IME_CAND_CODE                   0x0002
#define IME_CAND_MEANING                0x0003
#define IME_CAND_RADICAL                0x0004
#define IME_CAND_STROKE                 0x0005

// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW            0x0001
#define IMN_OPENSTATUSWINDOW             0x0002
#define IMN_CHANGECANDIDATE              0x0003
#define IMN_CLOSECANDIDATE               0x0004
#define IMN_OPENCANDIDATE                0x0005
#define IMN_SETCONVERSIONMODE            0x0006
#define IMN_SETSENTENCEMODE              0x0007
#define IMN_SETOPENSTATUS                0x0008
#define IMN_SETCANDIDATEPOS              0x0009
#define IMN_SETCOMPOSITIONFONT           0x000A
#define IMN_SETCOMPOSITIONWINDOW         0x000B
#define IMN_SETSTATUSWINDOWPOS           0x000C
#define IMN_GUIDELINE                    0x000D
#define IMN_PRIVATE                      0x000E

#if(IMM_WINVER >= 0x040A)
// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW      0x0001
#define IMR_CANDIDATEWINDOW        0x0002
#define IMR_COMPOSITIONFONT        0x0003
#define IMR_RECONVERTSTRING        0x0004
#define IMR_CONFIRMRECONVERTSTRING 0x0005
#define IMR_QUERYCHARPOSITION      0x0006
#define IMR_DOCUMENTFEED           0x0007
#endif

// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA                (-1)
#define IMM_ERROR_GENERAL               (-2)

// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL              1
#define IME_CONFIG_REGISTERWORD         2
#define IME_CONFIG_SELECTDICTIONARY     3

// dialog mode of ImmEscape
#define IME_ESC_QUERY_SUPPORT           0x0003
#define IME_ESC_RESERVED_FIRST          0x0004
#define IME_ESC_RESERVED_LAST           0x07FF
#define IME_ESC_PRIVATE_FIRST           0x0800
#define IME_ESC_PRIVATE_LAST            0x0FFF
#define IME_ESC_SEQUENCE_TO_INTERNAL    0x1001
#define IME_ESC_GET_EUDC_DICTIONARY     0x1003
#define IME_ESC_SET_EUDC_DICTIONARY     0x1004
#define IME_ESC_MAX_KEY                 0x1005
#define IME_ESC_IME_NAME                0x1006
#define IME_ESC_SYNC_HOTKEY             0x1007
#define IME_ESC_HANJA_MODE              0x1008
#define IME_ESC_AUTOMATA                0x1009
#define IME_ESC_PRIVATE_HOTKEY          0x100a
#define IME_ESC_GETHELPFILENAME         0x100b

// style of word registration
#define IME_REGWORD_STYLE_EUDC          0x00000001
#define IME_REGWORD_STYLE_USER_FIRST    0x80000000
#define IME_REGWORD_STYLE_USER_LAST     0xFFFFFFFF

#if(IMM_WINVER >= 0x040A)
// dwFlags for ImmAssociateContextEx
#define IACE_CHILDREN                   0x0001
#define IACE_DEFAULT                    0x0010
#define IACE_IGNORENOCONTEXT            0x0020

// dwFlags for ImmGetImeMenuItems
#define IGIMIF_RIGHTMENU                0x00000001

// dwType for ImmGetImeMenuItems
#define IGIMII_CMODE                    0x00000001
#define IGIMII_SMODE                    0x00000002
#define IGIMII_CONFIGURE                0x00000004
#define IGIMII_TOOLS                    0x00000008
#define IGIMII_HELP                     0x00000010
#define IGIMII_OTHER                    0x00000020
#define IGIMII_INPUTTOOLS               0x00000040

// fType of IMEMENUITEMINFO structure
#define IMFT_RADIOCHECK 0x00001
#define IMFT_SEPARATOR  0x00002
#define IMFT_SUBMENU    0x00004

// fState of IMEMENUITEMINFO structure
#define IMFS_GRAYED          MFS_GRAYED
#define IMFS_DISABLED        MFS_DISABLED
#define IMFS_CHECKED         MFS_CHECKED
#define IMFS_HILITE          MFS_HILITE
#define IMFS_ENABLED         MFS_ENABLED
#define IMFS_UNCHECKED       MFS_UNCHECKED
#define IMFS_UNHILITE        MFS_UNHILITE
#define IMFS_DEFAULT         MFS_DEFAULT
#endif /* IMM_WINVER >= 0x040A */

// type of soft keyboard
// for Windows Tranditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1            0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1            0x0002

#ifdef __cplusplus
}
#endif

#endif  // _IMM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\imgguids.h ===
/**************************************************************************\
* 
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   imgguids.h
*
* Abstract:
*
*   GUIDs defined and used by the imaging library
*
* Revision History:
*
*   05/10/1999 davidx
*       Created it.
*
\**************************************************************************/

//
// Image file format identifiers
//

DEFINE_GUID(IMGFMT_UNDEFINED, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_MEMORYBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_BMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_WMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_JPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_GIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_TIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_EXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_PHOTOCD, 0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_FLASHPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IMGFMT_ICO, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Interface and class identifiers
//

DEFINE_GUID(IID_IImagingFactory, 0x327abda7,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(CLSID_ImagingFactory, 0x327abda8,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImage, 0x327abda9,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBitmapImage, 0x327abdaa,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageDecoder, 0x327abdab,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageEncoder, 0x327abdac,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IImageSink, 0x327abdae,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(IID_IBasicBitmapOps, 0x327abdaf,0x072b,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);

//
// Predefined multi-frame dimension IDs
//

DEFINE_GUID(FRAMEDIM_TIME, 0x6aedbd6d,0x3fb5,0x418a,0x83,0xa6,0x7f,0x45,0x22,0x9d,0xc8,0x72);
DEFINE_GUID(FRAMEDIM_RESOLUTION, 0x84236f7b,0x3bd3,0x428f,0x8d,0xab,0x4e,0xa1,0x43,0x9c,0xa3,0x15);
DEFINE_GUID(FRAMEDIM_PAGE, 0x7462dc86,0x6180,0x4c7e,0x8e,0x3f,0xee,0x73,0x33,0xa7,0xa4,0x83);

//
// Property sets
//

DEFINE_GUID(FMTID_ImageInformation, 0xe5836cbe,0x5eef,0x4f1d,0xac,0xde,0xae,0x4c,0x43,0xb6,0x08,0xce);
DEFINE_GUID(FMTID_JpegAppHeaders, 0x1c4afdcd,0x6177,0x43cf,0xab,0xc7,0x5f,0x51,0xaf,0x39,0xee,0x85);

//
// Decoder parameter sets
//
DEFINE_GUID(DECODER_TRANSCOLOR, 0xb7a98c8f,0xdce7,0x457d,0xbf,0xa5,0xce,0xa7,0x1b,0xd1,0x4d,0xd6);
DEFINE_GUID(DECODER_TRANSRANGE, 0xabeed189,0xd988,0x4d03,0xb4,0x25,0x57,0x10,0x55,0xc7,0x6a,0xd1);
DEFINE_GUID(DECODER_OUTPUTCHANNEL, 0x2ff8f51e,0x724d,0x45fe,0x86,0xce,0x17,0x77,0xa0,0x56,0xda,0x60);
DEFINE_GUID(DECODER_ICONRES, 0x5c656eec,0xe94f,0x45ba,0xa6,0xf6,0x10,0x62,0xe8,0x5f,0x4a,0x7f);
 
//
// Encoder parameter sets
//
DEFINE_GUID(ENCODER_COMPRESSION, 0xe09d739d,0xccd4,0x44ee,0x8e,0xba,0x3f,0xbf,0x8b,0xe4,0xfc,0x58);
DEFINE_GUID(ENCODER_COLORDEPTH, 0x66087055,0xad66,0x4c7c,0x9a,0x18,0x38,0xa2,0x31,0x0b,0x83,0x37);
DEFINE_GUID(ENCODER_SCANMETHOD, 0x3a4e2661,0x3109,0x4e56,0x85,0x36,0x42,0xc1,0x56,0xe7,0xdc,0xfa);
DEFINE_GUID(ENCODER_VERSION, 0x24d18c76,0x814a,0x41a4,0xbf,0x53,0x1c,0x21,0x9c,0xcc,0xf7,0x97);
DEFINE_GUID(ENCODER_RENDERMETHOD, 0x6d42c53a,0x229a,0x4825,0x8b,0xb7,0x5c,0x99,0xe2,0xb9,0xa8,0xb8);
DEFINE_GUID(ENCODER_QUALITY, 0x1d5be4b5,0xfa4a,0x452d,0x9c,0xdd,0x5d,0xb3,0x51,0x05,0xe7,0xeb);
DEFINE_GUID(ENCODER_ROTATION,0x109555d4,0x2ab6,0x4379,0xa8,0x3f,0x5d,0x78,0xfa,0x53,0x8c,0x45);
DEFINE_GUID(ENCODER_TRANSFORMATION,0x8d0eb2d1,0xa58e,0x4ea8,0xaa,0x14,0x10,0x80,0x74,0xb7,0xb6,0xf9);
DEFINE_GUID(ENCODER_LUMINANCE_TABLE,0xedb33bce,0x0266,0x4a77,0xb9,0x04,0x27,0x21,0x60,0x99,0xe7,0x17);
DEFINE_GUID(ENCODER_CHROMINANCE_TABLE,0xf2e455dc,0x09b3,0x4316,0x82,0x60,0x67,0x6a,0xda,0x32,0x48,0x1c);
DEFINE_GUID(ENCODER_SAVE_FLAG,0x292266fc,0xac40,0x47bf,0x8c, 0xfc, 0xa8, 0x5b, 0x89, 0xa6, 0x55, 0xde);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\dispmain.h ===
#ifndef DISPMAIN_DEFINED
#define DISPMAIN_DEFINED

#include "lsidefs.h"

#include "lsc.h"
#include "lsdnode.h"
#include "lssubl.h"
#include "lstflow.h"
#include "plssubl.h"
#include "dispmisc.h"
#include "dispi.h"
#include "dispul.h"	


LSERR DisplaySublineCore(		
						PLSSUBL,		/* subline to display */
						const POINT*, 	/* pptOrg (x,y) starting point */
						UINT, 			/* kDisp : transparent or opaque */
						const RECT*, 	/* &rcClip: clipping rect (x,y) */
						long, 			/* upLimUnderline */
						long); 			/* upStartLine */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\break.h ===
#ifndef BREAK_DEFINED
#define BREAK_DEFINED

#include "lsdefs.h"
#include "fmtres.h"
#include "objdim.h"
#include "plssubl.h"
#include "breakrec.h"
#include "brkpos.h"
#include "brkkind.h"
#include "endres.h"
#include "plsdnode.h"



LSERR BreakGeneralCase(
					  PLSC,				/* IN: LineServices context		*/
					  BOOL,  			/* fHardStop				*/
					  DWORD,			/* IN: size of the output array			*/
					  BREAKREC*,		/* OUT: output array of break records	*/
					  DWORD*,			/* OUT:actual number of records in array*/
					  LSDCP*,			/* OUT: dcpDepend				*/
					  LSCP*,			/* OUT: cpLim					*/
					  ENDRES*,			/* OUT: how line ended			*/
					  BOOL*);			/* OUT fSuccessful: false means insufficient fetch */

LSERR BreakQuickCase(
					  PLSC,			/* IN: LineServices context		*/
					  BOOL,  		/* fHardStop				*/
					  LSDCP*,		/* OUT: dcpDepend				*/
					  LSCP*,		/* OUT: cpLim					*/
					  BOOL* ,		/* OUT: fSuccessful?			*/
					  ENDRES*);		/* OUT: how line ended			*/

LSERR TruncateSublineCore(
							PLSSUBL,		/* IN: subline context			*/
							long,			/* IN: urColumnMax				*/
							LSCP*);			/* OUT: cpTruncate 				*/

LSERR FindPrevBreakSublineCore(
							PLSSUBL,		/* IN: subline context			*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp			*/
							long,			/* IN: urColumnMax				*/
							BOOL*,			/* OUT: fSuccessful?			*/
							LSCP*,			/* OUT: cpBreak					*/
							POBJDIM,		/* OUT: objdimSub up to break	*/
							BRKPOS*);		/* OUT: Before/Inside/After		*/


LSERR FindNextBreakSublineCore(
							PLSSUBL,		/* IN: subline context			*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp			*/
							long,			/* IN: urColumnMax				*/
							BOOL*,			/* OUT: fSuccessful?			*/
							LSCP*,			/* OUT: cpBreak					*/
							POBJDIM,		/* OUT: objdimSub up to break	*/			
							BRKPOS*);		/* OUT: Before/Inside/After		*/

LSERR ForceBreakSublineCore(
							PLSSUBL,		/* IN: subline context			*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp			*/
							long,			/* IN: urColumnMax				*/
							LSCP*,			/* OUT: cpBreak					*/
							POBJDIM,		/* OUT: objdimSub up to break	*/			
							BRKPOS*);		/* OUT: Before/Inside/After		*/

LSERR SetBreakSublineCore(
							PLSSUBL,		/* IN: subline context			*/
							BRKKIND,		/* IN: Prev/Next/Force/Imposed	*/					
							DWORD,			/* IN: size of the output array			*/
							BREAKREC*,		/* OUT: output array of break records	*/
							DWORD*);		/* OUT:actual number of records in array*/

LSERR WINAPI SqueezeSublineCore(
							  PLSSUBL,		/* IN: subline context		*/
							  long,			/* IN: durTarget			*/
							  BOOL*,		/* OUT: fSuccessful?		*/
							  long*);		/* OUT: if nof successful, 
													extra dur 			*/

LSERR  GetMinDurBreaksCore	(PLSC plsc, /* IN: LineServices context		*/
							 long* pdurMinInclTrail, /* OUT: min dur between breaks including trailing area */
							 long* pdurMinExclTrail);/* OUT: min dur between breaks excluding trailing area */

LSERR  GetLineDurCore		(PLSC plsc, /* IN: LineServices context		*/
							 long* pdurInclTrail, /* OUT: dur of line incl. trailing area */
							 long* pdurExclTrail);/* OUT: dur of line excl. trailing area */

LSERR FCanBreakBeforeNextChunkCore(PLSC  plsc,  /* IN: LineServices context		*/
								   PLSDNODE plsdn,	/* IN: Last DNODE of the current chunk */
								   BOOL* pfCanBreakBeforeNextChunk); /* OUT: Can break before next chunk ? */



#endif /* BREAK_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\autonum.h ===
#ifndef AUTONUM_DEFINED
#define AUTONUM_DEFINED

#include "lsdefs.h"

#include "plscbk.h"
#include "plsrun.h"
#include "pilsobj.h"
#include "plnobj.h"
#include "pdobj.h"
#include "pfmti.h"
#include "pbrko.h"
#include "pobjdim.h"
#include "pdispi.h"
#include "plsdocin.h"
#include "pposichn.h"
#include "plocchnk.h"
#include "plsfgi.h"
#include "pheights.h"
#include "plsqin.h"
#include "plsqout.h"
#include "plssubl.h"
#include "breakrec.h"
#include "brkcond.h"
#include "fmtres.h"
#include "mwcls.h"
#include "lstxtcfg.h"
#include "lskalign.h"
#include "lskjust.h"
#include "plsdnode.h"
#include "plstbcon.h"
#include "plschp.h"
#include "lstflow.h"
#include "brkkind.h"

	LSERR WINAPI AutonumCreateILSObj(POLS, PLSC,  PCLSCBK, DWORD, PILSOBJ*);
	/* CreateILSObj
	 *  pols (IN):
	 *  plsc (IN): LS context
	 *  plscbk (IN): callbacks
	 *  idObj (IN): id of the object
	 *  &pilsobj (OUT): object ilsobj
	*/

	LSERR  SetAutonumConfig(PILSOBJ , const LSTXTCFG*);
	/* SetAutonumConfig
	*	pilsobj	(IN): object ilsobj
	*	plstxtconfig  (IN): definition of special characters 
	*/


	LSERR WINAPI AutonumDestroyILSObj(PILSOBJ);
	/* DestroyILSObj
	 *  pilsobj (IN): object ilsobj
	*/

	LSERR WINAPI AutonumSetDoc(PILSOBJ, PCLSDOCINF);
	/* SetDoc
	 *  pilsobj (IN): object ilsobj
	 *  lsdocinf (IN): initialization data at document level
	*/

	LSERR WINAPI AutonumCreateLNObj(PCILSOBJ, PLNOBJ*);
	/* CreateLNObj
	 *  pilsobj (IN): object ilsobj
	 *  &plnobj (OUT): object lnobj
	*/

	LSERR WINAPI AutonumDestroyLNObj(PLNOBJ);
	/* DestroyLNObj
	 *  plnobj (OUT): object lnobj
	*/

	LSERR WINAPI AutonumFmt(PLNOBJ, PCFMTIN, FMTRES*);
	/* Fmt
	 *  plnobj (IN): object lnobj
	 *  pfmtin (IN): formatting input
	 *  &fmtres (OUT): formatting result
	*/

	LSERR WINAPI AutonumTruncateChunk(PCLOCCHNK, PPOSICHNK);
	/* Truncate
	 *  plocchnk (IN): locchnk to truncate
	 *  posichnk (OUT): truncation point
	*/

	LSERR WINAPI AutonumFindPrevBreakChunk(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
	/* FindPrevBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  brkcond (IN): recommmendation about the break after chunk
	 *  &brkout (OUT): results of breaking
	*/

	LSERR WINAPI AutonumFindNextBreakChunk(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
	/* FindNextBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  brkcond (IN): recommmendation about the break before chunk
	 *  &brkout (OUT): results of breaking
	*/

	LSERR WINAPI AutonumForceBreakChunk(PCLOCCHNK, PCPOSICHNK, PBRKOUT);
	/* ForceBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  &brkout (OUT): results of breaking
	*/

	LSERR WINAPI AutonumSetBreak(PDOBJ, BRKKIND, DWORD, BREAKREC*, DWORD*);
	/* SetBreak
	 *  pdobj (IN): dobj which is broken
	 *  brkkind (IN): Previous/Next/Force/Imposed was chosen
	 *  rgBreakRecord (IN): array of break records
	 *	nBreakRecord (IN): size of array
	 *	nActualBreakRecord (IN): actual number of used elements in array
	*/

	LSERR WINAPI AutonumGetSpecialEffectsInside(PDOBJ, UINT*);
	/* GetSpecialEffects
	 *  pdobj (IN): dobj
	 *  &EffectsFlags (OUT): Special effects inside of this object
	*/

	LSERR WINAPI AutonumCalcPresentation(PDOBJ, long, LSKJUST, BOOL);
	/* CalcPresentation
	 *  pdobj (IN): dobj
	 *  dup (IN): dup of dobj
	 *  lskj (IN) current justification mode
	 *  fLastOnLine (IN) this boolean is ignored by autonumbering object
	*/

	LSERR WINAPI AutonumQueryPointPcp(PDOBJ, PCPOINTUV, PCLSQIN, PLSQOUT);
	/* QueryPointPcp
	 *  pdobj (IN): dobj to query
	 * 	ppointuvQuery (IN): query point (uQuery,vQuery)
     *	plsqin (IN): query input
     *	plsqout (OUT): query output
	*/
	
	LSERR WINAPI AutonumQueryCpPpoint(PDOBJ, LSDCP, PCLSQIN, PLSQOUT);
	/* QueryCpPpoint
	 *  pdobj (IN): dobj to query
	 *  dcp (IN):  dcp for the query
     *	plsqin (IN): query input
     *	plsqout (OUT): query output
	*/
	
	LSERR WINAPI AutonumEnumerate(PDOBJ, PLSRUN, PCLSCHP, LSCP, LSDCP, LSTFLOW, BOOL,
												BOOL, const POINT*, PCHEIGHTS, long);
	/* Enum object
	 *  pdobj (IN): dobj to enumerate
	 *  plsrun (IN): from DNODE
	 *  plschp (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  dcp (IN): from DNODE
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryNeeded (IN):
	 *  pptStart (IN): starting position (top left), iff fGeometryNeeded
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryNeeded
	 *  dupRun(IN): from DNODE, relevant iff fGeometryNeeded
	*/


	LSERR WINAPI AutonumDisplay(PDOBJ, PCDISPIN);
	/* Display
	 *  pdobj (IN): dobj to display
	 *  pdispin (IN): input display info
	*/

	LSERR WINAPI AutonumDestroyDobj(PDOBJ);
	/* DestroyDObj
	 *  pdobj (IN): dobj to destroy
	*/


	void AllignAutonum95(long, long, LSKALIGN, long, PLSDNODE, long*, long*);
	/* 
	 * AllignAutotonum95 
	 *	durSpaceAnm (IN) : space after autonumber
	 *	durWidthAnm (IN) : distance from indent to main text
	 *	lskalign (IN) : allignment for autonumber
	 *	durUsed (IN) : width of autonumbering text
	 *	plsdnAnmAfter( IN) : tab dnode to put durAfter
	 *	pdurBefore (OUT) : calculated distance from indent to autonumber 
	 *	pdurAfter (OUT) : calculated distance from autonumber to main text
	 */

	LSERR AllignAutonum(PLSTABSCONTEXT, LSKALIGN, BOOL, PLSDNODE , long, long, long*, long*);
	/* 
	 * AllignAutonum95 
	 *	plstabscontext (IN) : tabs context
	 *	lskalign (IN) : allignment for autonumber
	 *	fAllignmentAfter (IN) : is there tab after autonumber
	 *	plsdnAnmAfter ( IN) : tab dnode to put durAfter
	 *	urAfterAnm (IN) : pen position after autonumber
	 *	durUsed (IN) : width of autonumbering text
	 *	pdurBefore (OUT) : calculated distance from indent to autonumber 
	 *	pdurAfter (OUT) : calculated distance from autonumber to main text
	 */

#endif /* AUTONUM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\warning.h ===
#pragma warning(3:4092)   // sizeof returns 'unsigned long'
#pragma warning(3:4121)   // structure is sensitive to alignment
#pragma warning(3:4125)   // decimal digit in octal sequence
#pragma warning(3:4130)   // logical operation on address of string constant
#pragma warning(3:4132)   // const object should be initialized
#pragma warning(4:4206)   // Source File is empty
#pragma warning(4:4101)   // Unreferenced local variable
#pragma warning(4:4208)   // delete[exp] - exp evaluated but ignored
#pragma warning(3:4212)   // function declaration used ellipsis
#pragma warning(3:4242)   // convertion possible loss of data
#pragma warning(4:4312)   // conversion to type of greater size
#pragma warning(error:4700)    // Local used w/o being initialized
#pragma warning(error:4259)    // pure virtual function was not defined
#pragma warning(error:4071)    // no function prototype given
#pragma warning(error:4072)    // no function prototype given (fastcall)
#pragma warning(error:4171)    // no function prototype given (old style)
#pragma warning(error:4013)    // 'function' undefined - assuming extern returning int
#pragma warning(error:4551)    // Function call missing argument list
#pragma warning(error:4806)    // unsafe operation involving type 'bool'
#pragma warning(4:4509)   // use of SEH with destructor
#pragma warning(4:4177)   // pragma data_seg s/b at global scope
#pragma warning(disable:4786)  // identifier was truncated to 255 chararcers in debug information.

#if 0
#pragma warning(3:4100)   // Unreferenced formal parameter
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4706)   // assignment w/i conditional expression
#pragma warning(3:4709)   // command operator w/o index expression
#endif

#ifndef __cplusplus
#undef try
#undef except
#undef finally
#undef leave
#define try                         __try
#define except                      __except
#define finally                     __finally
#define leave                       __leave
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\chnutils.h ===
#ifndef CHNUTILS_DEFINED
#define CHNUTILS_DEFINED

/*   Chunk & group chunk utilities   							*/

#include "lsidefs.h"
#include "plsdnode.h"
#include "lsgrchnk.h"
#include "plocchnk.h"
#include "pposichn.h"
#include "dninfo.h"
#include "plschcon.h"
#include "lstflow.h"
#include "lschcon.h"
#include "lscbk.h"
#include "port.h"
#include "posichnk.h"


/*  MACROS -----------------------------------------------------------------*/

#define  FlushSublineChunkContext(plschnkcontext)		\
					(plschnkcontext)->FLocationValid = fFalse;\
					(plschnkcontext)->FChunkValid = fFalse;\
					(plschnkcontext)->FGroupChunk = fFalse;\
					(plschnkcontext)->FBorderInside = fFalse;\
					(plschnkcontext)->grpfTnti = 0;\
					(plschnkcontext)->fNTIAppliedToLastChunk = fFalse;\
					(plschnkcontext)->locchnkCurrent.clschnk = 0;\


#define  InitSublineChunkContext(plschnkcontext, urFirst, vrFirst)		\
					FlushSublineChunkContext(plschnkcontext); \
					(plschnkcontext)->urFirstChunk = (urFirst); \
					(plschnkcontext)->vrFirstChunk = (vrFirst); 

#define   IdObjFromChnk(plocchnk)	(Assert((plocchnk)->clschnk > 0),	\
		  						((plocchnk)->plschnk[0].plschp->idObj))

#define InvalidateChunk(plschnkcontext) \
	(plschnkcontext)->FChunkValid = fFalse;

#define InvalidateChunkLocation(plschnkcontext) \
	(plschnkcontext)->FLocationValid = fFalse;

#define SetNTIAppliedToLastChunk(plschnkcontext) \
		(plschnkcontext)->fNTIAppliedToLastChunk = fTrue;

#define FlushNTIAppliedToLastChunk(plschnkcontext) \
		(plschnkcontext)->fNTIAppliedToLastChunk = fFalse;

#define FNTIAppliedToLastChunk(plschnkcontext) \
		(plschnkcontext)->fNTIAppliedToLastChunk


#define FIsChunkBoundary(plsdn, idObjChnk, cpBase)  \
		(((plsdn) == NULL) || \
		 (FIsDnodeBorder(plsdn) ? fFalse : \
			((FIsDnodePen(plsdn))  \
			||  ((plsdn)->fTab) \
			|| ((idObjChnk) != IdObjFromDnode(plsdn)) \
			||  (((cpBase) >= 0) ? ((plsdn)->cpFirst < 0) : ((plsdn)->cpFirst >= 0)))))
/* last check verifies that we are not crossing boundaries of autonumber */

#define SetUrColumnMaxForChunks(plschnkcontext, Ur)   \
	(plschnkcontext)->locchnkCurrent.lsfgi.urColumnMax = Ur;

#define GetUrColumnMaxForChunks(plschnkcontext)   \
		(plschnkcontext)->locchnkCurrent.lsfgi.urColumnMax 

#define GetChunkArray(plschnkcontext)  (plschnkcontext)->locchnkCurrent.plschnk

#define GetChunkSize(plschnkcontext)  (plschnkcontext)->locchnkCurrent.clschnk


#define 		FlushNominalToIdealState(plschnkcontext)  \
				(plschnkcontext)->grpfTnti = 0;

#define   		SetNominalToIdealFlags(plschnkcontext, plschp)  \
				AddNominalToIdealFlags(((plschnkcontext)->grpfTnti), plschp);

#define DnodeFromChunk(plschunkcontext, ichnk) \
		(Assert(((DWORD) ichnk) < (plschunkcontext)->locchnkCurrent.clschnk), \
		 (plschunkcontext)->pplsdnChunk[ichnk])

#define LastDnodeFromChunk(plschunkcontext) \
		 DnodeFromChunk(plschunkcontext, (plschunkcontext)->locchnkCurrent.clschnk - 1)

/* L O C  D N O D E  F R O M  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: LocDnodeFromChunk
    %%Contact: igorzv

Parameters:
	plschuncontext	-	(IN) LineServices context
	ichnk			-	(IN) index in chunk
	pplsdn			-	(OUT) dnode to fill in
	ppoint				(OUT) position of dnode

----------------------------------------------------------------------------*/

#define LocDnodeFromChunk(plschunkcontext, ichnk, pplsdn, ppoint) \
	Assert((DWORD)(ichnk) < (plschunkcontext)->locchnkCurrent.clschnk); \
	Assert((ichnk) != ichnkOutside); \
	(ppoint)->u = (plschunkcontext)->locchnkCurrent.ppointUvLoc[ichnk].u; \
	(ppoint)->v = (plschunkcontext)->locchnkCurrent.ppointUvLoc[ichnk].v; \
	*(pplsdn) = (plschunkcontext)->pplsdnChunk[ichnk];


	
#define 	ApplyFFirstSublineToChunk(plschunkcontext, fFirstSubline) \
	(plschunkcontext)->locchnkCurrent.lsfgi.fFirstOnLine = \
		FIsFirstOnLine(plschunkcontext->pplsdnChunk[0]) \
									&& fFirstSubline ;	


#define GetFFirstOnLineChunk(plocchnk) \
	(plocchnk)->lsfgi.fFirstOnLine 


#define NumberOfDnodesInChunk(plocchnk) \
			(plocchnk)->clschnk


#define GetPointChunkStart(plocchnk, point) \
			point.u = plocchnk->lsfgi.urPen;  \
			point.v = plocchnk->lsfgi.vrPen; 

#define PosInChunkAfterChunk(plocchnk, posichnk) \
			posichnk.ichnk = plocchnk->clschnk - 1; \
			posichnk.dcp = plocchnk->plschnk[plocchnk->clschnk - 1].dcp;

/* ROUTINES ----------------------------------------------------------------------*/


LSERR 	FillChunkArray(PLSCHUNKCONTEXT plschunkcontext ,	/* IN: LS chunk context */
					   PLSDNODE plsdn);	 				/* IN: last dnode in a chunk  */


LSERR CollectChunkAround(PLSCHUNKCONTEXT plschnukcontext,	/* IN: LS chunk context */
					     PLSDNODE plsdn,	 		    /* IN:  dnode to collect chunk arround  */
						 LSTFLOW  lstflow,				/* IN: text flow */
						 POINTUV* ppoint);  			/* IN: position of dnode */

LSERR CollectPreviousChunk(PLSCHUNKCONTEXT plschunkcontext,/* IN: LS chunk context */
					      BOOL* pfSuccessful);			/* fSuccessful does previous chunk exist  */

LSERR CollectNextChunk(PLSCHUNKCONTEXT plschunkcontext,	/* IN: LS chunk context */
					   BOOL* pfSuccessful);				/* fSuccessful does next chunk exist  */

LSERR GetUrPenAtBeginingOfLastChunk(PLSCHUNKCONTEXT plschunkcontext,	/* IN: LS chunk context */
									PLSDNODE plsdnFirst,	/* IN: First dnode in a chunk (used for checks */
									PLSDNODE plsdnLast,		/* IN: last dnode in a chunk */
									POINTUV* ppoint,			/* IN: point after lst dnode */
									long* purPen);			/* OUT: ur before chunk */



void SetPosInChunk(PLSCHUNKCONTEXT plschunkcontext,		/* IN: LS chunk context */
				   PLSDNODE	plsdn,						/* IN: position to convert to position in a current chunk */
				   LSDCP dcp,							/* IN: dcp in the dnode	*/
				   PPOSICHNK pposinchnk);				/* OUT: position in a current chunk */



enum CollectSublines
{
	CollectSublinesNone,
	CollectSublinesForJustification,
	CollectSublinesForCompression,
	CollectSublinesForDisplay,
	CollectSublinesForDecimalTab,
	CollectSublinesForTrailingArea,
};

typedef enum CollectSublines COLLECTSUBLINES;


typedef struct grchunkext
{
	PLSCHUNKCONTEXT plschunkcontext;/* Chunk context  */
	DWORD	iobjText;				/* idobj of text 	*/
	enum COLLECTSUBLINES Purpose;	/* for what purpose we are collecting group chunk */
	LSGRCHNK lsgrchnk;				/* group chunk   */
	PLSDNODE plsdnFirst;			/* group chunk was collected between plsdnFirst */
	PLSDNODE plsdnNext;				/* and plsdnNext */
									/*(both plsdnFirst and plsdnNext are in a main subline)*/
	PLSDNODE plsdnLastUsed;			/* last dnode that participates in calculation of above fields*/
									/* can be on the second level */
	long durTotal;					/* durTotal of all dnodes between First and Last */
	long durTextTotal;				/* durTextTotal of all text dnodes between First and Last */
	long dupNonTextTotal;			/* dupNonTextTotal of all non text dnodes between First and Last (including pens) */
	DWORD cNonTextObjects;			/* number of non text objects  (excliding pens)    */
	PLSDNODE* pplsdnNonText;		/* array of non text objects */
	BOOL* pfNonTextExpandAfter;			/* array of flags for non text objects */
	DWORD cNonTextObjectsExpand;	/* number of non text objects that can be expanded */
	/* fields below are valid only for group chunk collected for compression or justification */
	POSICHNK posichnkBeforeTrailing;/* information about last text cp before trailing area */
	PLSDNODE plsdnStartTrailing;	/* dnode where trailing area starts */
	long durTrailing;				/* dur of trailing area in  group chunk */
	LSDCP dcpTrailing;				/* amount of characters in trailing are */
	BOOL fClosingBorderStartsTrailing;/* closing border located just before trailing area */

} GRCHUNKEXT;


#define FFirstOnLineGroupChunk(pgrchunkext, plsc)  \
		(Assert(FIsLSDNODE((pgrchunkext)->plsdnFirst)), \
		((pgrchunkext)->plsdnFirst->plsdnPrev == NULL && \
		(IdObjFromDnode((pgrchunkext)->plsdnFirst) == IobjTextFromLsc(&(plsc)->lsiobjcontext))))
				

void InitGroupChunkExt(PLSCHUNKCONTEXT plschnkcontext,  /* Chunk context  */
					   DWORD iobjText,					/* text iobj      */
			  	       GRCHUNKEXT* pgrchunkext);		/* OUT: structure to initialize */




LSERR CollectTextGroupChunk(
			 		 PLSDNODE plsdnFirst,			/* IN: First Dnode				*/
					 LSCP cpLim,					/* IN: cpLim(boundary) for collecting,
										 			group chunk can stop before this boundary but can't go beyond */
					 COLLECTSUBLINES Purpose, 		/* IN: what sublines to take from complex object */

					 GRCHUNKEXT* pgrchunkext);		/* OUT: extended group chunk	*/

LSERR CollectPreviousTextGroupChunk(		
			 		 PLSDNODE plsdnEnd,				/* IN: last dnode of a chunk */
					 COLLECTSUBLINES Purpose, 		/* IN: what sublines to take from complex object */
					 BOOL fAllSimpleText,			/* IN: we have only simple text in this line */
					 GRCHUNKEXT* pgrchunkext);  	/* OUT: extended group chunk	*/

/* G E T  T R A I L I N G  I N F O  F O R  T E X T  G R O U P  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: GetTrailingInfoForTextGroupChunk
    %%Contact: igorzv

Parameters:
	plsdnLastDnode		-	(IN) dnode where to start calculation of trailing area
	dcpLastDnode			(IN) dcp in this dnode
	iobjText			-	(IN) iobj of text
	pdurTrailing		-	(OUT) dur of trailing area in  group chunk
	pdcpTrailing		-	(OUT) dcp of trailing area in chunk
	pplsdnStartTrailingText -	(OUT) dnode where trailing area starts
	pdcpStartTrailingText-	(OUT) with pcDnodesTrailing defines last character in text before
								  trailing area, doesn't valid if pcDnodesTrailing == 0
	pcDnodesTrailing	-	(OUT) number of dnodes in trailing area
	pplsdnStartTrailingObject -(OUT) dnode on the upper level where trailing are starts
	pdcpStartTrailingText	-(OUT) dcp in such dnode 
	pfClosingBorderStartsTrailing - (OUT) closing border located just before trailing area
----------------------------------------------------------------------------*/
	
LSERR GetTrailingInfoForTextGroupChunk
				(PLSDNODE plsdnLast, LSDCP dcpLastDnode, DWORD iobjText,
				 long* pdurTrailing, LSDCP* pdcpTrailing,
				 PLSDNODE* pplsdnStartTrailingText, LSDCP* pdcpStartTrailingText,
				 int* pcDnodesTrailing, PLSDNODE* pplsdnStartTrailingObject,
				 LSDCP* pdcpStartTrailingObject, BOOL* pfClosingBorderStartsTrailing);


LSERR AllocChunkArrays(PLSCHUNKCONTEXT plschunkcontext, LSCBK* plscbk, POLS pols,
					   PLSIOBJCONTEXT plsiobjcontext);

void DisposeChunkArrays(PLSCHUNKCONTEXT plschunkcontext);


LSERR DuplicateChunkContext(PLSCHUNKCONTEXT plschunkcontextOld, 
							PLSCHUNKCONTEXT* pplschunkcontextNew);

void DestroyChunkContext(PLSCHUNKCONTEXT plschunkcontext);


void FindPointOffset(
			  PLSDNODE plsdnFirst,			/* IN: dnode from the boundaries of which
											to calculate offset  */
			  enum lsdevice lsdev,			/* IN: presentation or reference device */
			  LSTFLOW lstflow,				/* IN: text flow to use for calculation */
			  COLLECTSUBLINES Purpose,		/* IN: what sublines to take from a complex object */
			  PLSDNODE plsdnContainsPoint,	/* IN: dnode contains point */
			  long duInDnode,				/* IN: offset in the dnode */
			  long* pduOffset);				/* OUT: offset from the starting point */

#endif /* CHNUTILS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inc41\richole.h ===
#ifndef _RICHOLE_
#define _RICHOLE_

/*
 *	RICHOLE.H
 *
 *	Purpose:
 *		OLE Extensions to the Rich Text Editor
 *
 *	Copyright (c) 1985-1996, Microsoft Corporation
 */

// Structure passed to GetObject and InsertObject
typedef struct _reobject
{
	DWORD			cbStruct;			// Size of structure
	LONG			cp;					// Character position of object
	CLSID			clsid;				// Class ID of object
	LPOLEOBJECT		poleobj;			// OLE object interface
	LPSTORAGE		pstg;				// Associated storage interface
	LPOLECLIENTSITE	polesite;			// Associated client site interface
	SIZEL			sizel;				// Size of object (may be 0,0)
	DWORD			dvaspect;			// Display aspect to use
	DWORD			dwFlags;			// Object status flags
	DWORD			dwUser;				// Dword for user's use
} REOBJECT;

// Flags to specify which interfaces should be returned in the structure above
#define REO_GETOBJ_NO_INTERFACES	(0x00000000L)
#define REO_GETOBJ_POLEOBJ			(0x00000001L)
#define REO_GETOBJ_PSTG				(0x00000002L)
#define REO_GETOBJ_POLESITE			(0x00000004L)
#define REO_GETOBJ_ALL_INTERFACES	(0x00000007L)

// Place object at selection
#define REO_CP_SELECTION ((ULONG) -1L)

// Use character position to specify object instead of index
#define REO_IOB_SELECTION ((ULONG) -1L)
#define REO_IOB_USE_CP ((ULONG) -2L)

// Object flags
#define REO_NULL			(0x00000000L)	// No flags
#define REO_READWRITEMASK	(0x000007FFL)	// Mask out RO bits
#define REO_CANROTATE		(0x00000080L)	// Object knows how to display itself rotated
#define REO_OWNERDRAWSELECT	(0x00000040L)	// Owner draws selected object
#define REO_DONTNEEDPALETTE	(0x00000020L)	// Object doesn't need palette
#define REO_BLANK			(0x00000010L)	// Object is blank
#define REO_DYNAMICSIZE		(0x00000008L)	// Object defines size always
#define REO_INVERTEDSELECT	(0x00000004L)	// Object drawn all inverted if sel
#define REO_BELOWBASELINE	(0x00000002L)	// Object sits below the baseline
#define REO_RESIZABLE		(0x00000001L)	// Object may be resized
#define REO_USEASBACKGROUND	(0x00000400L)	// Use object as background picture
#define REO_WRAPTEXTAROUND  (0x00000200L)	// Wrap text around the object
#define REO_ALIGNTORIGHT	(0x00000100L)	// Align object to view's right side
											// Only makes sense when REO_WRAPTEXTAROUND is set

#define REO_LINK			(0x80000000L)	// Object is a link (RO)
#define REO_STATIC			(0x40000000L)	// Object is static (RO)
#define REO_SELECTED		(0x08000000L)	// Object selected (RO)
#define REO_OPEN			(0x04000000L)	// Object open in its server (RO)
#define REO_INPLACEACTIVE	(0x02000000L)	// Object in place active (RO)
#define REO_HILITED			(0x01000000L)	// Object is to be hilited (RO)
#define REO_LINKAVAILABLE	(0x00800000L)	// Link believed available (RO)
#define REO_GETMETAFILE		(0x00400000L)	// Object requires metafile (RO)

// Flags for IRichEditOle::GetClipboardData(),
// IRichEditOleCallback::GetClipboardData() and
// IRichEditOleCallback::QueryAcceptData()
#define RECO_PASTE			(0x00000000L)	// paste from clipboard
#define RECO_DROP			(0x00000001L)	// drop
#define RECO_COPY			(0x00000002L)	// copy to the clipboard
#define RECO_CUT			(0x00000003L)	// cut to the clipboard
#define RECO_DRAG			(0x00000004L)	// drag

/*
 *	IRichEditOle
 *
 *	Purpose:
 *		Interface used by the client of RichEdit to perform OLE-related
 *		operations.
 *
 *	//$ REVIEW:
 *		The methods herein may just want to be regular Windows messages.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOle

DECLARE_INTERFACE_(IRichEditOle, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOle methods ***
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR * lplpolesite) PURE;
	STDMETHOD_(LONG,GetObjectCount) (THIS) PURE;
	STDMETHOD_(LONG,GetLinkCount) (THIS) PURE;
	STDMETHOD(GetObject) (THIS_ LONG iob, REOBJECT FAR * lpreobject,
						  DWORD dwFlags) PURE;
    STDMETHOD(InsertObject) (THIS_ REOBJECT FAR * lpreobject) PURE;
	STDMETHOD(ConvertObject) (THIS_ LONG iob, REFCLSID rclsidNew,
							  LPCSTR lpstrUserTypeNew) PURE;
	STDMETHOD(ActivateAs) (THIS_ REFCLSID rclsid, REFCLSID rclsidAs) PURE;
	STDMETHOD(SetHostNames) (THIS_ LPCSTR lpstrContainerApp,
							 LPCSTR lpstrContainerObj) PURE;
	STDMETHOD(SetLinkAvailable) (THIS_ LONG iob, BOOL fAvailable) PURE;
	STDMETHOD(SetDvaspect) (THIS_ LONG iob, DWORD dvaspect) PURE;
	STDMETHOD(HandsOffStorage) (THIS_ LONG iob) PURE;
	STDMETHOD(SaveCompleted) (THIS_ LONG iob, LPSTORAGE lpstg) PURE;
	STDMETHOD(InPlaceDeactivate) (THIS) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(ImportDataObject) (THIS_ LPDATAOBJECT lpdataobj,
									CLIPFORMAT cf, HGLOBAL hMetaPict) PURE;
};
typedef         IRichEditOle FAR * LPRICHEDITOLE;

/*
 *	IRichEditOleCallback
 *
 *	Purpose:
 *		Interface used by the RichEdit to get OLE-related stuff from the
 *		application using RichEdit.
 */
#undef INTERFACE
#define INTERFACE   IRichEditOleCallback

DECLARE_INTERFACE_(IRichEditOleCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * lplpObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRichEditOleCallback methods ***
	STDMETHOD(GetNewStorage) (THIS_ LPSTORAGE FAR * lplpstg) PURE;
    STDMETHOD(GetInPlaceContext) (THIS_ LPOLEINPLACEFRAME FAR * lplpFrame,
								  LPOLEINPLACEUIWINDOW FAR * lplpDoc,
								  LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
	STDMETHOD(ShowContainerUI) (THIS_ BOOL fShow) PURE;
	STDMETHOD(QueryInsertObject) (THIS_ LPCLSID lpclsid, LPSTORAGE lpstg,
									LONG cp) PURE;
	STDMETHOD(DeleteObject) (THIS_ LPOLEOBJECT lpoleobj) PURE;
	STDMETHOD(QueryAcceptData) (THIS_ LPDATAOBJECT lpdataobj,
								CLIPFORMAT FAR * lpcfFormat, DWORD reco,
								BOOL fReally, HGLOBAL hMetaPict) PURE;
	STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
	STDMETHOD(GetClipboardData) (THIS_ CHARRANGE FAR * lpchrg, DWORD reco,
									LPDATAOBJECT FAR * lplpdataobj) PURE;
	STDMETHOD(GetDragDropEffect) (THIS_ BOOL fDrag, DWORD grfKeyState,
									LPDWORD pdwEffect) PURE;
	STDMETHOD(GetContextMenu) (THIS_ WORD seltype, LPOLEOBJECT lpoleobj,
									CHARRANGE FAR * lpchrg,
									HMENU FAR * lphmenu) PURE;
};
typedef         IRichEditOleCallback FAR * LPRICHEDITOLECALLBACK;

#ifndef MAC
// RichEdit interface GUIDs
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
#endif // !MAC

#endif // _RICHOLE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\dispmisc.h ===
#ifndef DISPMISC_DEFINED
#define DISPMISC_DEFINED

#include "lsidefs.h"
#include "plsdnode.h"
#include "plssubl.h"
#include "lstflow.h"


// 			Rectangle (usually clip rectangle) in local coordinate system
//
//	U grows to the right, v grows up, so normally upLeft < upRight, vpTop > vpBottom
//	Upper left corner belongs to the rectangle, lower right corner doesn't.
//	That means:
//	upRight - upLeft equals dupLength.
//	Rectangle that contains one point (0,0) is {0,0,-1,1}.
//	Shading rectangle for dnode starting at (u0,v0) is {u0, v0+dvpAscent, u0+dupLen, v0-dvpDescent}
//	Note this last line reflects the big LS convention: 
//			v0+dvpAscent belongs to line, v0-dvpDescent doesn't.


typedef struct tagRECTUV
{
    long    upLeft;
    long    vpTop;
    long    upRight;
    long    vpBottom;
} RECTUV;

typedef const RECTUV* 	PCRECTUV;
typedef RECTUV* 		PRECTUV;


/* 	CreateDisplayTree sets plsdnUpTemp in sublines to be displayed with given subline,
 *	rejects wrong sublines, submitted for display, sets fAcceptedForDisplay in good ones
 */

void CreateDisplayTree(PLSSUBL);		/* IN: the uppermost subline */

/* 	DestroyDisplayTree nulls plsdnUpTemp in sublines displayed with given subline.
 */
 
void DestroyDisplayTree(PLSSUBL);		/* IN: the uppermost subline */


/* AdvanceToNextNode moves to the next dnode to be displayed (maybe changing sublines),
 * updating current pen, returning pointer to the next dnode 
 */

PLSDNODE AdvanceToNextDnode(PLSDNODE,	/* IN: current dnode */
							LSTFLOW, 	/* IN: current (main) text flow */
							POINTUV*);	/* INOUT: current pen position (u,v) */

PLSDNODE AdvanceToFirstDnode(PLSSUBL,	/* IN: main subline */
							LSTFLOW, 	/* IN: current (main) text flow */
							POINTUV*);	/* INOUT: current pen position (u,v) */

/* AdvanceToNextSubmittingDnode moves to the next dnode which submitted for display,
 * updating current pen, returning pointer to the next dnode 
 */

PLSDNODE AdvanceToNextSubmittingDnode(
							PLSDNODE,	/* IN: current dnode */
							LSTFLOW, 	/* IN: current (main) text flow */
							POINTUV*);	/* INOUT: current pen position (u,v) */

PLSDNODE AdvanceToFirstSubmittingDnode(
							PLSSUBL,	/* IN: main subline */
							LSTFLOW, 	/* IN: current (main) text flow */
							POINTUV*);	/* INOUT: current pen position (u,v) */

							
// NB Victork - following functions were used only for upClipLeft, upClipRight optimization.
// If we'll decide that we do need that optimization after Word integration - I'll uncomment.


#ifdef NEVER
/* RectUVFromRectXY calculates (clip) rectangle in local (u,v) coordinates given
								(clip) rectangle in (x,y) and point of origin */

void RectUVFromRectXY(const POINT*, 	/* IN: point of origin for local coordinates (x,y) */
						const RECT*,	/* IN: input rectangle (x,y) */
						LSTFLOW, 		/* IN: local text flow */
						PRECTUV);		/* OUT: output rectangle (u,v) */


/* RectXYFromRectUV calculates rectangle in (x,y) coordinates given
					rectangle in local (u,v) coordinates and point of origin (x,y) */

void RectXYFromRectUV(const POINT*, 	/* IN: point of origin for local coordinates (x,y) */
						PCRECTUV,		/* IN: input rectangle (u,v) */
						LSTFLOW, 		/* IN: local text flow */
						RECT*);			/* OUT: output rectangle (x,y) */
#endif /* NEVER */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\disptext.h ===
#ifndef DISPTEXT_DEFINED
#define DISPTEXT_DEFINED

#include "lsidefs.h"
#include "pdobj.h"
#include "pdispi.h"
#include "lskjust.h"

LSERR WINAPI DisplayText(PDOBJ, PCDISPIN);
LSERR WINAPI CalcPresentationText(PDOBJ, long, LSKJUST, BOOL);

#endif /* ndef DISPTEXT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\dninfo.h ===
#ifndef DNINFO_DEFINED
#define DNINFO_DEFINED

#include "lsdnode.h"
#include "lssubl.h"

/* MACROS --------------------------------------------------------------------------*/


#define IdObjFromDnode(p)  (Assert((p)->klsdn == klsdnReal), (p)->u.real.lschp.idObj)

#define PdobjFromDnode(p)  (Assert((p)->klsdn == klsdnReal), (p)->u.real.pdobj)

#define DupFromRealDnode(p) ((Assert((p)->klsdn == klsdnReal), \
							(p)->u.real.dup ))
#define DurFromRealDnode(p) ((Assert((p)->klsdn == klsdnReal), \
							(p)->u.real.objdim.dur ))

#define DvrFromRealDnode(p) (Assert((p)->klsdn == klsdnReal), \
							0)

#define DvpFromRealDnode(p) (Assert((p)->klsdn == klsdnReal), \
							0)

#define DupFromDnode(p)  (((p)->klsdn == klsdnReal)  ? \
						     DupFromRealDnode(p) : \
							 (Assert((p)->klsdn == klsdnPenBorder), (p)->u.pen.dup))
#define DurFromDnode(p)  (((p)->klsdn == klsdnReal)  ? \
						     DurFromRealDnode(p) : \
							 (Assert((p)->klsdn == klsdnPenBorder), (p)->u.pen.dur))
#define DvrFromDnode(p)  (((p)->klsdn == klsdnReal)  ? \
						     DvrFromRealDnode(p) : \
							 (Assert((p)->klsdn == klsdnPenBorder), (p)->u.pen.dvr))

#define DvpFromDnode(p)  (((p)->klsdn == klsdnReal)  ? \
						     DvpFromRealDnode(p) : \
							 (Assert((p)->klsdn == klsdnPenBorder), (p)->u.pen.dvp))


/* dnode is not in content if it either  auto-decimal tab or was created as a part 
of autonumbering. In both these cases and only in them it's cpFirst is negative  */
#define  FIsNotInContent(plsdn)   (Assert(FIsLSDNODE(plsdn)), ((plsdn)->cpFirst < 0 ))

#define  SublineFromDnode(plsdn)   ((plsdn)->plssubl)

#define  LstflowFromDnode(plsdn)   (LstflowFromSubline(SublineFromDnode(plsdn)))

/* dnode is first on line if it in content (not autonumber) and previous dnode either
null or not in content or is opening border which has previous dnode satisfying two
coditions above */
#define FIsFirstOnLine(plsdn)		( \
									!FIsNotInContent(plsdn) \
									&& \
										(	((plsdn)->plsdnPrev == NULL) \
										||	FIsNotInContent((plsdn)->plsdnPrev) \
										||	(	FIsDnodeOpenBorder((plsdn)->plsdnPrev) \
											&&	(	((plsdn)->plsdnPrev->plsdnPrev  == NULL)\
												||	FIsNotInContent((plsdn)->plsdnPrev->plsdnPrev) \
												) \
											) \
										) \
									)


#define FIsOutOfBoundary(plsdn, cpLim) \
		(((plsdn) == NULL) || \
		 ((plsdn)->cpLimOriginal > (cpLim)) || \
		 (FIsDnodeOpenBorder(plsdn) && ((plsdn)->cpLimOriginal == (cpLim))) \
		)

#define FDnodeBeforeCpLim(plsdn, cpLim) \
		!FIsOutOfBoundary((plsdn), (cpLim))

#define FDnodeAfterCpFirst(plsdn, cpF) \
		( \
		((plsdn) != NULL) \
		&&	( \
		    ((plsdn)->cpFirst > (cpF)) \
		    ||	( \
				((plsdn)->cpFirst == (cpF)) \
				&& (FIsDnodeReal(plsdn) || FIsDnodeOpenBorder(plsdn)) \
				) \
			) \
		) 

#define FDnodeHasBorder(plsdn)     /* doesn't work properly for pens */ \
	   (Assert(((plsdn) == NULL || !FIsDnodePen(plsdn))), \
		((plsdn) == NULL ? fFalse : \
		 ((FIsDnodeBorder(plsdn) ? fTrue : \
		   (plsdn)->u.real.lschp.fBorder))) \
       )

/*  macros bellow handle dup in sync with dur during formatting */
		 
#define SetDnodeDurFmt(plsdn, durNew) \
		Assert(FIsDnodeReal(plsdn)); \
		(plsdn)->u.real.objdim.dur = (durNew); \
		if (!(plsdn)->fRigidDup) \
			(plsdn)->u.real.dup = (durNew);

#define ModifyDnodeDurFmt(plsdn, ddur) \
		Assert(FIsDnodeReal(plsdn)); \
		(plsdn)->u.real.objdim.dur += (ddur); \
		if (!(plsdn)->fRigidDup) \
			(plsdn)->u.real.dup += (ddur);

#define SetDnodeObjdimFmt(plsdn, objdimNew) \
		Assert(FIsDnodeReal(plsdn)); \
		(plsdn)->u.real.objdim = (objdimNew); \
		if (!(plsdn)->fRigidDup) \
			(plsdn)->u.real.dup = (objdimNew).dur;

#define SetPenBorderDurFmt(plsdn, durNew) \
		Assert(!FIsDnodeReal(plsdn)); \
		(plsdn)->u.pen.dur = (durNew); \
		if (!(plsdn)->fRigidDup) \
			(plsdn)->u.pen.dup = (durNew);

#define ModifyPenBorderDurFmt(plsdn, ddur) \
		Assert(!FIsDnodeReal(plsdn)); \
		(plsdn)->u.pen.dur += (ddur); \
		if (!(plsdn)->fRigidDup) \
			(plsdn)->u.pen.dup += (ddur);


#endif /* DNINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\dispul.h ===
#ifndef DISPUL_DEFINED
#define DISPUL_DEFINED

#include "lsdefs.h"
#include "dispi.h"
#include "plsdnode.h"

/* all we need to remember about a merge is in this structure - enough to draw UL */
/* in case of bad metrics, only first three are filled. */
typedef struct {
	UINT kul;						/* kind of UL-line, simple, wavy, etc, opaque to LS */
    DWORD cNumberOfLines;			/* number of lines in UL: possible values 1,2 */
	long vpUnderlineOrigin;			/* UnderlineOrigin position */
	long dvpFirstUnderlineOffset;	/* from UnderlineOrigin position */
	long dvpFirstUnderlineSize;		
	long dvpGapBetweenLines;		
	long dvpSecondUnderlineSize;	
} LSULMETRIC;

/* all we need to remember - enough to draw SS */
typedef struct {
	UINT kul;				/* kind of SS-line, same as UL-types */
    DWORD cNumberOfLines;	/* number of lines in SS: possible values 1,2 */
	long dvp1stSSSize;		/* SS line width */
	long dvp1stSSOffset;	/* position relative to the baseline, filled page direction (normally > 0) */
	long dvp2ndSSSize;		/* 1stSS is common for single and double SS, save space */
	long dvp2ndSSOffset;	/* normally dvp1stSSOffset < dvp2ndSSOffset */
} LSSTRIKEMETRIC;

LSERR GetUnderlineMergeMetric(
				PLSC, 
				PLSDNODE, 			/* dnode to start UL merging */
				POINTUV,			/* starting pen point (u,v) */
				long,				/* upLimUnderline */
				LSTFLOW, 
				LSCP, 				/* cpLimBreak */
				LSULMETRIC*,	 	/* merge metrics */
				int*, 				/* nodes to display in the merge */
				BOOL*);				/* good metrics? */

LSERR DrawUnderlineMerge(
				PLSC, 
				PLSDNODE, 			/* dnode to start underlining */
				const POINT*, 		/* pptOrg (x,y) */
				int, 				/* nodes to display in the merge */
				long,				/* upStartUnderline */
				BOOL,				/* good metrics? */
				const LSULMETRIC*, 	/* merge metrics */
				UINT, 				/* kDisp : transparent or opaque */
				const RECT*, 		/* &rcClip: clipping rect (x,y) */
				long,				/* upLimUnderline */
				LSTFLOW); 


LSERR GetStrikeMetric(
				PLSC,
				PLSDNODE, 			/* dnode to strike */
				LSTFLOW, 
				LSSTRIKEMETRIC*,	/* strike metrics */
				BOOL*);				/* good metrics? */

LSERR StrikeDnode(PLSC,
				PLSDNODE, 				/* dnode to start underlining */
				const POINT*, 			/* pptOrg (x,y) */
				POINTUV,				/* starting pen point (u,v) */
				const LSSTRIKEMETRIC*,	/* merge metrics */
				UINT, 					/* kDisp : transparent or opaque */
				const RECT*, 			/* &rcClip: clipping rect (x,y) */
				long,					/* upLimUnderline */
				LSTFLOW); 

#endif /* ndef DISPUL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\dnutils.h ===
#ifndef DNUTILS_DEFINED
#define DNUTILS_DEFINED

#include "lsdefs.h"
#include "plsdnode.h"
#include "objdim.h"
#include "lscbk.h"
#include "plsiocon.h"
#include "pqheap.h"



/* ROUTINES ---------------------------------------------------------------------------*/


LSERR FindListDims(PLSDNODE, PLSDNODE, OBJDIM*);

void FindListDup(PLSDNODE, LSCP, long*);

void FindListFinalPenMovement(PLSDNODE plsdnFirst, PLSDNODE plsdnLast, long *pdur, long *pdvr, long *pdvp);

LSERR DestroyDnodeList(LSCBK*, POLS, PLSIOBJCONTEXT, PLSDNODE plsdn, BOOL fDontReleaseRuns);

long DurBorderFromDnodeInside(PLSDNODE plsdn); /* IN: dnode inside borders */

BOOL FSpacesOnly(PLSDNODE plsdn, DWORD iObjText);

#define MovePointBack(ptpen, dur, dvr) \
		(ptpen)->u -= (dur); \
		(ptpen)->v -= (dvr); 


#define  GetPointBeforeDnodeFromPointAfter(pnode, ptpen) \
	MovePointBack(ptpen, DurFromDnode(pnode), DvrFromDnode(pnode));


#endif /* DNUTILS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\getfmtst.h ===
#ifndef GETFMTST_DEFINED
#define GETFMTST_DEFINED

#include "lsline.h"

/*  MACROS ---------------------------------------------------------------*/

#define GetDnodeToFinish(plsc)	((plsc)->lslistcontext.plsdnToFinish)


#define GetCurrentSubline(plsc)	((plsc)->lslistcontext.plssublCurrent)


#define GetCurrentCpLimSubl(plssubl)	((plssubl)->cpLim)
#define GetCurrentCpLim(plsc)			GetCurrentCpLimSubl(GetCurrentSubline(plsc))

#define GetCurrentUrSubl(plssubl)		((plssubl)->urCur)
#define GetCurrentUr(plsc)			GetCurrentUrSubl(GetCurrentSubline(plsc))

#define GetCurrentVrSubl(plssubl)		((plssubl)->vrCur)
#define GetCurrentVr(plsc)			GetCurrentVrSubl(GetCurrentSubline(plsc))

#define GetCurrentPointSubl(plssubl,point)	(((point).u =(plssubl)->urCur), \
									 ((point).v =(plssubl)->vrCur))
#define GetCurrentPoint(plsc, point)			GetCurrentPointSubl(GetCurrentSubline(plsc), point)


#define GetCurrentDnodeSubl(plssubl)	((plssubl)->plsdnLast)
#define GetCurrentDnode(plsc)			GetCurrentDnodeSubl(GetCurrentSubline(plsc))

#define GetWhereToPutLinkSubl(plssubl, Append) \
							(((Append) != NULL)   ?  \
								(&((Append)->plsdnNext)) : \
									(&((plssubl)->plsdnFirst)))
#define GetWhereToPutLink(plsc,Append)			GetWhereToPutLinkSubl(GetCurrentSubline(plsc), (Append))


#define GetCurrentLstflow(plsc)		LstflowFromSubline(GetCurrentSubline(plsc))

#define GetLastDnodeDisplaySubl(plssubl)	((plssubl)->plsdnLastDisplay)
#define GetLastDnodeDisplay(plsc)		GetLastDnodeDisplaySubl(GetCurrentSubline(plsc))

#endif /* GETFMTST_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\enumcore.h ===
#ifndef ENUMCORE_DEFINED
#define ENUMCORE_DEFINED

#include "lsidefs.h"

#include "lsdnode.h"
#include "plssubl.h"

LSERR EnumSublineCore(PLSSUBL plssubl, BOOL fReverseOrder, BOOL fGeometryNeeded, 
					const POINT* pptOrg, long upLeftIndent);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\iobj.h ===
#ifndef IOBJ_DEFINED
#define IOBJ_DEFINED

#include "lsdefs.h"
#include "lsimeth.h"
#include "lsdocinf.h"
#include "plsiocon.h"
#include "lsiocon.h"

#define IobjTextFromLsc(plsiobjcontext)		((plsiobjcontext)->iobjMac - 2)

#define IobjAutonumFromLsc(plsiobjcontext)		((plsiobjcontext)->iobjMac - 1)

#define FIobjValid(plsiobjcontext,iobj)  (iobj < (plsiobjcontext)->iobjMac)

#define PilsobjFromLsc(plsiobjcontext,iobj)	( Assert(FIobjValid((plsiobjcontext),(iobj))),\
								 (plsiobjcontext)->rgobj[iobj].pilsobj)
#define PLsimFromLsc(plsiobjcontext,iobj)	( Assert(FIobjValid((plsiobjcontext),(iobj))),\
								&((plsiobjcontext)->rgobj[iobj].lsim))



#endif /* IOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\iobjln.h ===
#ifndef IOBJLN_DEFINED
#define IOBJLN_DEFINED

#include "lsdefs.h"
#include "plsline.h"

#define PlnobjFromLsline(plsline,iobj)   \
						((Assert(FIsLSLINE(plsline)),\
						Assert(iobj < (plsline)->lssubl.plsc->lsiobjcontext.iobjMac),\
						(plsline)->rgplnobj[iobj]))




#endif /* IOBJLN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\limqmem.h ===
#define limLines		1
#define limAllDNodes	8
#define limCaltbd		64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lscaltbd.h ===
#ifndef LSCALTBD_DEFINED
#define LSCALTBD_DEFINED

#include "lsdefs.h"
#include "lsktab.h"


typedef struct
{
	enum lsktab lskt;					/* Kind of tab */
	long ur;							/* Offset of tab position */
	WCHAR wchTabLeader;					/* character for tab leader */
										/*   if 0, no leader is used*/
	WCHAR wchCharTab;					/* character for tab allignment for the special kind of tab stop */
	BYTE fDefault;						/* default tab position */
	BYTE fHangingTab;					/* hanging tab			*/
} LSCALTBD;


#endif /* !LSCALTBD_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsc.h ===
#ifndef LSC_DEFINED
#define LSC_DEFINED


#include "lsidefs.h"
#include "plsdnode.h" 
#include "plsline.h"
#include "plssubl.h"
#include "pqheap.h"
#include "lsiocon.h"
#include "lstbcon.h"
#include "lscbk.h"
#include "lsdocinf.h"
#include "lschcon.h"
#include "lsbrjust.h"


typedef LSCHUNKCONTEXT LSCHUNKCONTEXTSTORAGE;



#define tagLSC		Tag('L','S','C',':')	 
#define FIsLSC(p)	FHasTag(p,tagLSC)


enum LsState		/* state and activity of Line Services */				
{
	LsStateNotReady,				/*  doc properties has not been set		*/
	LsStateFree,					/*  ready and are not involved in any activity */
	LsStateCreatingContext,			/*  LsCreatContext is working		*/
	LsStateDestroyingContext,		/*  LsDestroyContext is working		*/
	LsStateSettingDoc,				/*  LsSetDoc is working 			*/
	LsStateFormatting,    			/*  LsCreateLine (formating stage) is working 		*/
	LsStateBreaking,    			/*  LsCreateLine (breaking stage) is working 		*/
	LsStateDestroyingLine,			/*  LsDestroyLine is working						*/
	LsStatePreparingForDisplay,		/*  PrepareLineForDisplayProc called from LsDisplay or queries is working */
	LsStateDisplaying,				/*  LsDisplayLine is working						*/
	LsStateQuerying,				/*  we are within one of queries					*/
	LsStateEnumerating				/*  LsEnumLine is working					*/
};

typedef enum LsState LSSTATE;


typedef struct
/* this contains information that is used during preparaning for display time */
{
	BOOL fLineCompressed;  /* default value is fFalse, 
							is set to fTrue in breaking time if we apply compression to fit text into a line */
	BOOL fLineContainsAutoNumber;

	BOOL fUnderlineTrailSpacesRM;		/* Underline trailing spaces until RM?*/

	BOOL fForgetLastTabAlignment;		/* disregard dup of the last tab during center or right aligment
											if last tab is not left tab Word - bug compatibility */

	BOOL fNominalToIdealEncounted;		/* nominal to ideal has been applied during formatting */

	BOOL fForeignObjectEncounted;		/* object different from text happend during formatting */

	BOOL fTabEncounted;					/* tab dnode was created during formatting */


	BOOL fNonLeftTabEncounted;			/* tab dnode with non left tab stop was created */

	BOOL fSubmittedSublineEncounted;	/* LsdnSubmitSublines was called during formatting */

	BOOL fAutodecimalTabPresent;		/* there is autodecimal tab on this line */

	
	LSKJUST lskj;						/* justification type */

	LSKALIGN lskalign;					/* Alignment type */

	LSBREAKJUST lsbrj;					/* break/justification behavior */

	long urLeftIndent;					/* left indent */

	long urStartAutonumberingText;		/* starting position of autonumbering text */

	long urStartMainText;				/* starting position of text after autonumber */

	long urRightMarginJustify;			/* right margin for justification	*/

}  LSADJUSTCONTEXT;


typedef struct
/* This structure contains information which is used for snap to grid allignment. Is not valid if snap to 
grid is off */ 
{
	long urColumn; /* scaled to reference device value of uaColumn which has been passed to LsCreateLine */
}  LSGRIDTCONTEXT;


typedef struct
/* This structure contains current state of a formatting process. Good place for all information that is
   important only during formatting time */ 
{
	PLSDNODE plsdnToFinish;
	PLSSUBL	 plssublCurrent;
	DWORD	 nDepthFormatLineCurrent;

}  LSLISTCONTEXT;

struct lscontext
{
	DWORD tag;
	
	POLS pols;

	LSCBK lscbk;

	BOOL fDontReleaseRuns;
	
	long cLinesActive;
	PLSLINE plslineCur;

	PLSLINE plslineDisplay;		/* temporary */

	PQHEAP pqhLines;
	PQHEAP pqhAllDNodesRecycled;
	LSCHUNKCONTEXTSTORAGE lschunkcontextStorage;	/* memory that is shared by all main sublines */

   	LSSTATE lsstate;

	BOOL  fIgnoreSplatBreak; 

	BOOL fLimSplat;						/* Splat to display at cpLimPara */

	BOOL fHyphenated;	   /* current line was ended by hyphen */

	BOOL fAdvanceBack;	  /* current line contains advance pen with negative move */

	DWORD grpfManager;				/* Manager part of lsffi flags 			*/

	long urRightMarginBreak;

	long lMarginIncreaseCoefficient;	/* used for increasing right margin
										 LONG_MIN means don't increase */

	long urHangingTab;		/* used by autonumber */

	LSDOCINF lsdocinf;

    LSTABSCONTEXT lstabscontext;

	LSADJUSTCONTEXT lsadjustcontext;

	LSGRIDTCONTEXT lsgridcontext;

	LSLISTCONTEXT lslistcontext;

	LSIOBJCONTEXT lsiobjcontext;  /* should be last*/

};

#define FDisplay(p)			(Assert(FIsLSC(p)), (p)->lsdocinf.fDisplay)
#define FIsLSCBusy(p)		(Assert(FIsLSC(p)), \
							!(((p)->lsstate == LsStateNotReady) || ((p)->lsstate == LsStateFree))) 
#define FFormattingAllowed(p)	(Assert(FIsLSC(p)), (p)->lsstate == LsStateFormatting)
#define FBreakingAllowed(p)		(Assert(FIsLSC(p)), (p)->lsstate == LsStateBreaking)

#define FWorkWithCurrentLine(plsc) (Assert(FIsLSC(plsc)), \
								    ((plsc)->lsstate == LsStateFormatting || \
									 (plsc)->lsstate == LsStateBreaking || \
									 (plsc)->lsstate == LsStatePreparingForDisplay))

#define FBreakthroughLine(plsc)     ((plsc)->plslineCur->lslinfo.fTabInMarginExLine)

#define GetPqhAllDNodes(plsc)   ((plsc)->plslineCur->pqhAllDNodes) 


#ifdef DEBUG
/* this function verify that nobody spoiled context */
BOOL FIsLsContextValid(PLSC plsc);
#endif 


#endif /* LSC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lscfmtfl.h ===
#ifndef LSCFMTFL_DEFINED
#define LSCFMTFL_DEFINED

#include "port.h"

#define TurnOnAllSimpleText(plsc) \
		(plsc)->plslineCur->fAllSimpleText = fTrue;

#define TurnOffAllSimpleText(plsc) \
		(plsc)->plslineCur->fAllSimpleText = fFalse;

#define FAllSimpleText(plsc) \
		(plsc)->plslineCur->fAllSimpleText
//---------------------------------------------------------------

#define TurnOnLineCompressed(plsc) \
		(plsc)->lsadjustcontext.fLineCompressed = fTrue;

#define TurnOffLineCompressed(plsc) \
		(plsc)->lsadjustcontext.fLineCompressed = fFalse;

#define FLineCompressed(plsc) \
		(plsc)->lsadjustcontext.fLineCompressed

#define SetLineCompressed(plsc,f) \
		(plsc)->lsadjustcontext.fLineCompressed = (f);
//---------------------------------------------------------------

#define FLineContainsAutoNumber(plsc) \
		(plsc)->lsadjustcontext.fLineContainsAutoNumber

#define SetLineLineContainsAutoNumber(plsc,f) \
		(plsc)->lsadjustcontext.fLineContainsAutoNumber = (f);
//---------------------------------------------------------------

#define FUnderlineTrailSpacesRM(plsc) \
		(plsc)->lsadjustcontext.fUnderlineTrailSpacesRM

#define SetUnderlineTrailSpacesRM(plsc,f) \
		(plsc)->lsadjustcontext.fUnderlineTrailSpacesRM = (f);


//---------------------------------------------------------------

#define FForgetLastTabAlignment(plsc) \
		(plsc)->lsadjustcontext.ForgetLastTabAlignment

#define SetForgetLastTabAlignment(plsc,f) \
		(plsc)->lsadjustcontext.fForgetLastTabAlignment = (f);

//---------------------------------------------------------------

#define TurnOnNonRealDnodeEncounted(plsc) \
		(plsc)->plslineCur->fNonRealDnodeEncounted = fTrue;

#define TurnOffNonRealDnodeEncounted(plsc) \
		(plsc)->plslineCur->fNonRealDnodeEncounted = fFalse;

#define FNonRealDnodeEncounted(plsc) \
		(plsc)->plslineCur->fNonRealDnodeEncounted

//---------------------------------------------------------------

#define TurnOnNonZeroDvpPosEncounted(plsc) \
		(plsc)->plslineCur->fNonZeroDvpPosEncounted = fTrue;

#define TurnOffNonZeroDvpPosEncounted(plsc) \
		(plsc)->plslineCur->fNonZeroDvpPosEncounted = fFalse;

#define FNonZeroDvpPosEncounted(plsc) \
		(plsc)->plslineCur->fNonZeroDvpPosEncounted
//---------------------------------------------------------------

#define FlushAggregatedDisplayFlags(plsc) \
		(plsc)->plslineCur->AggregatedDisplayFlags = 0;

#define AddToAggregatedDisplayFlags(plsc, plschp) \
		AddDisplayFlags((plsc)->plslineCur->AggregatedDisplayFlags, (plschp)) 

#define AggregatedDisplayFlags(plsc) \
		(plsc)->plslineCur->AggregatedDisplayFlags

//---------------------------------------------------------------

#define TurnOnNominalToIdealEncounted(plsc) \
		(plsc)->lsadjustcontext.fNominalToIdealEncounted = fTrue;

#define TurnOffNominalToIdealEncounted(plsc) \
		(plsc)->lsadjustcontext.fNominalToIdealEncounted = fFalse;

#define FNominalToIdealEncounted(plsc) \
		(plsc)->lsadjustcontext.fNominalToIdealEncounted
//---------------------------------------------------------------

#define TurnOnForeignObjectEncounted(plsc) \
		(plsc)->lsadjustcontext.fForeignObjectEncounted = fTrue;

#define TurnOffForeignObjectEncounted(plsc) \
		(plsc)->lsadjustcontext.fForeignObjectEncounted = fFalse;

#define FForeignObjectEncounted(plsc) \
		(plsc)->lsadjustcontext.fForeignObjectEncounted

//---------------------------------------------------------------

#define TurnOnTabEncounted(plsc) \
		(plsc)->lsadjustcontext.fTabEncounted = fTrue;

#define TurnOffTabEncounted(plsc) \
		(plsc)->lsadjustcontext.fTabEncounted = fFalse;

#define FTabEncounted(plsc) \
		(plsc)->lsadjustcontext.fTabEncounted

//---------------------------------------------------------------

#define TurnOnNonLeftTabEncounted(plsc) \
		(plsc)->lsadjustcontext.fNonLeftTabEncounted = fTrue;

#define TurnOffNonLeftTabEncounted(plsc) \
		(plsc)->lsadjustcontext.fNonLeftTabEncounted = fFalse;

#define FNonLeftTabEncounted(plsc) \
		(plsc)->lsadjustcontext.fNonLeftTabEncounted


//---------------------------------------------------------------

#define TurnOnSubmittedSublineEncounted(plsc) \
		(plsc)->lsadjustcontext.fSubmittedSublineEncounted = fTrue;

#define TurnOffSubmittedSublineEncounted(plsc) \
		(plsc)->lsadjustcontext.fSubmittedSublineEncounted = fFalse;

#define FSubmittedSublineEncounted(plsc) \
		(plsc)->lsadjustcontext.fSubmittedSublineEncounted

//---------------------------------------------------------------

#define TurnOnAutodecimalTabPresent(plsc) \
		(plsc)->lsadjustcontext.fAutodecimalTabPresent = fTrue;

#define TurnOffAutodecimalTabPresent(plsc) \
		(plsc)->lsadjustcontext.fAutodecimalTabPresent = fFalse;

#define FAutodecimalTabPresent(plsc) \
		(plsc)->lsadjustcontext.fAutodecimalTabPresent

//---------------------------------------------------------------
#define FBorderEncounted(plsc) \
		(AggregatedDisplayFlags(plsc) & fPortDisplayBorder)
	

#endif /* LSCFMTFL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsdnode.h ===
#ifndef LSDNODE_DEFINED
#define LSDNODE_DEFINED

#include "lsidefs.h"
#include "plsdnode.h"
#include "pdobj.h"
#include "objdim.h"
#include "plsrun.h"
#include "lschp.h"
#include "plssubl.h"

#define klsdnReal	0
#define klsdnPenBorder	1

#define tagLSDNODE		Tag('L','S','D', 'N')
#define FIsLSDNODE(plsdn)	(FHasTag(plsdn,tagLSDNODE))

struct lsdnode
{
	DWORD tag;

	PLSDNODE plsdnNext,plsdnPrev;
	LSCP cpFirst;
	LSCP cpLimOriginal;				/* is not equal to cpFirst + dcp in a case when 
									   glyph context goes across hidden text */
	PLSSUBL plssubl;  				/* subline which contains this dnode */

	LSDCP dcp;							/* 					 */
	UINT klsdn : 1;						/* klsdnReal, klsdnPenBorder */
	UINT fAdvancedPen : 1;				/* advanced pen, valid only if kldnPenBorder and not fBorder */
	UINT fBorderNode : 1;				/* border, valid only if kldnPenBorder  */
	UINT fOpenBorder :1;				/* open or close border, valid only if fBorder */
	UINT fRigidDup : 1;					/* Rigid dup is set		 */
	UINT fTab : 1;						/* tab 					*/
	UINT icaltbd : 8;					/* index in the lscaltbd array in lsc.h */
	UINT fEndOfColumn : 1;				/* dnode represents end of column */
	UINT fEndOfSection : 1;				/* dnode represents end of section */
	UINT fEndOfPage : 1;				/* dnode represents end of page */			
	UINT fEndOfPara : 1;				/* dnode represents end of paragraph */			
	UINT fAltEndOfPara : 1;				/* dnode represents alternative end of paragraphe */			
	UINT fSoftCR : 1;					/* dnode represents end of line */
	UINT fInsideBorder: 1;				/* is true if dnode is inside bordered sequence or one
										of the dnodes under him is inside bordered sequence */
	UINT fAutoDecTab: 1;				/* auto decimal tab */
	UINT fTabForAutonumber: 1;			/* tab which is added at the end of autonumber */
	UINT fBorderMovedFromTrailingArea: 1;/* closing border which was moved to the begining of
										    trailing area */

	UINT pad1 : 8;

	union								/* variant record */
	{
		struct							/* valid iff klsdn==klsdnReal */
		{
			LSCHP lschp;
			PLSRUN plsrun;
			OBJDIM objdim;
			long dup;					/* width of object in pres pixels	*/
			PDOBJ pdobj;

			struct
			{
				DWORD cSubline;				/* number of sublines 	*/
				PLSSUBL* rgpsubl;			/* array of such sublines 	*/
				BOOL fUseForJustification;
				BOOL fUseForCompression;
				BOOL fUseForDisplay;
				BOOL fUseForDecimalTab;
				BOOL fUseForTrailingArea;
	
			} * pinfosubl;					/* information how object participates in 
											justification or display*/

		} real;

		struct							/* valid iff klsdn==klsdnPen */
		{
			long dup,dvp;
			long dur,dvr;
		} pen;


	} u;
};

#define FIsDnodeReal(plsdn) 	(Assert(FIsLSDNODE(plsdn)), 	((plsdn)->klsdn == klsdnReal))

#define FIsDnodePen(plsdn) 		(Assert(FIsLSDNODE(plsdn)), \
								(((plsdn)->klsdn == klsdnPenBorder) && \
								 (!(plsdn)->fBorderNode)))

#define FIsDnodeBorder(plsdn) 	(Assert(FIsLSDNODE(plsdn)), \
								(((plsdn)->klsdn == klsdnPenBorder) && \
								 ((plsdn)->fBorderNode)))

#define FIsDnodeOpenBorder(plsdn)  (FIsDnodeBorder(plsdn) && \
								   ((plsdn)->fOpenBorder))	

#define FIsDnodeCloseBorder(plsdn)  (FIsDnodeBorder(plsdn) && \
								   !((plsdn)->fOpenBorder))	

#define FIsDnodeSplat(plsdn) ((plsdn)->fEndOfSection || \
								(plsdn)->fEndOfColumn || (plsdn)->fEndOfPage )	
	
#define FIsDnodeEndPara(plsdn) (plsdn)->fEndOfPara
								
#define FIsDnodeAltEndPara(plsdn) (plsdn)->fAltEndOfPara

#define FIsDnodeSoftCR(plsdn) (plsdn)->fSoftCr


#endif /* !LSDNODE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsdnfinp.h ===
#ifndef LSDNFINT_DEFINED
#define LSDNFINT_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plssubl.h"
#include "plsrun.h"
#include "plschp.h"
#include "fmtres.h"


LSERR WINAPI LsdnFinishDelete(
							  PLSC,				/* IN: Pointer to LS Context */
					  		  LSDCP);			/* IN: dcp to add			 */

LSERR WINAPI LsdnFinishBySubline(PLSC,			/* IN: Pointer to LS Context */
							  	LSDCP,     		/* IN: dcp adopted           */
								PLSSUBL);		/* IN: Subline context		 */

LSERR WINAPI LsdnFinishByOneChar(				/* allows replacement by simple DNODE only */
							  PLSC,				/* IN: Pointer to LS Context */
							  long,				/* IN: urColumnMax			 */
							  WCHAR,			/* IN: character to replace	 */
							  PCLSCHP,			/* IN: lschp for character   */
							  PLSRUN,			/* IN: plsrun for character  */
							  FMTRES*);			/* OUT:Result of the Repl formatter*/


#endif /* !LSDNFINT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lschcon.h ===
#ifndef LSCHCON_DEFINED
#define LSCHCON_DEFINED

#include "lsidefs.h"
#include "plsdnode.h"
#include "locchnk.h"
#include "plscbk.h"
#include "plssubl.h"
#include "plsiocon.h"

typedef struct lschunkcontext
{
	DWORD cchnkMax;  /* current restriction on size of arrays */
	BOOL FChunkValid; /* because of some operations with glyphs (ligatures across dnodes )
					  chunk can not be reused */
	BOOL  FLocationValid; /* location has been calculated for this array */
		/* for chunk (not group chunk) until location is not valid locchnkCurrent.ppointUv
		  contains witdth of border may be two before dnode */
	BOOL  FGroupChunk; /* current chunk is group chunk */
	BOOL  FBorderInside; /* there is a border inside chunk or group chunk */
	PLSDNODE* pplsdnChunk; /* dnodes in chunk */
	DWORD grpfTnti;  /* summarized nominal to ideal flags of chunk */
	BOOL fNTIAppliedToLastChunk; /* nominal to ideal has been applied to the last chunk */
	LOCCHNK locchnkCurrent; /* current located chunk */ 
	DWORD* pcont; /* array that used for group chuncks */
	PLSCBK plscbk;		/* call backs */
	POLS pols;			/* clients information for callbacks */
	long urFirstChunk;	/* ur of the first chunk : for optimization */
	long vrFirstChunk;	/* vr of the first chunk : for optimization */
	DWORD cNonTextMax;  /* current restriction on size of arrays of non text objects*/
	PLSDNODE* pplsdnNonText;	/* array of non text objects */
	BOOL* pfNonTextExpandAfter;	/* array of flags for non text objects */
	LONG* pdurOpenBorderBefore;	/* array of widths of previous open border */
	LONG* pdurCloseBorderAfter;	/* array of widths of next close border */
	PLSIOBJCONTEXT plsiobjcontext; /* object methods */
	
	
}  LSCHUNKCONTEXT;

#endif /* LSCHCON_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsdntext.h ===
#ifndef LSDNTEXT_DEFINED
#define LSDNTEXT_DEFINED

/* Text to manager interface routines */

#include "lsidefs.h"
#include "plsdnode.h"
#include "pobjdim.h"
#include "plsrun.h"
#include "stopres.h"

LSERR LsdnSetSimpleWidth(
						   PLSC,		/* IN: Pointer to LS Context */
						   PLSDNODE,	/* IN: DNODE to be modified  */
						   long);		/* IN: dur */

LSERR LsdnModifySimpleWidth(
						   PLSC,		/* IN: Pointer to LS Context */
						   PLSDNODE,	/* IN: DNODE to be modified  */
						   long);		/* IN: ddur */

LSERR LsdnSetTextDup(PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the dnode	 */
					 long);    			/* IN: dup to be set		 */

LSERR LsdnModifyTextDup(PLSC,			/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the dnode	 */
					 long);    			/* IN: ddup					 */

LSERR LsdnGetObjDim(
						  PLSC,			/* IN: Pointer to LS Context */
					 	  PLSDNODE,		/* IN: plsdn -- DNODE */
					 	  POBJDIM);		/* OUT: dimensions of DNODE */

LSERR LsdnFInChildList(					/* Used to switch off hyphenation in child list */ 
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the dnode	 */
					 BOOL*);   			/* OUT: fInChildList		 */

LSERR LsdnResetWidthInPreviousDnodes(	/* Used at SetBreak time for hyphen/nonreqhyphen cases */ 
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the dnode	 */
					 long,				/* IN: durChangePrev (don't change if 0)	*/
					 long);   			/* IN: durChangePrevPrev (don't change if 0)  */

LSERR LsdnGetUrPenAtBeginningOfChunk(	/* Used by SnapGrid 			*/ 
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the first dnode in chunk */
					 long*,   			/* OUT: purPen							  */
					 long*);   			/* OUT: purColumnMax					  */

LSERR LsdnResetDcpMerge(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the first dnode in chunk */
					 LSCP,				/* IN: cpFirstNew	*/
					 LSDCP);			/* IN: dcpNew	*/

LSERR LsdnResetDcp(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the first dnode in chunk */
					 LSDCP);			/* IN: dcpNew	*/

LSERR LsdnSetStopr(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the dnode */
					 STOPRES);			/* IN: Stop result			*/


LSERR LsdnSetHyphenated(PLSC);			/* IN: Pointer to LS Context */

LSERR LsdnGetBorderAfter(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the first dnode in chunk */
					 long*);			/* OUT: dur of the border after this DNODE */

LSERR LsdnGetCpFirst(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the first dnode in chunk */
					 LSCP*);			/* OUT: cpFirst of this DNODE */

LSERR LsdnGetPlsrun(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Pointer to the first dnode in chunk */
					 PLSRUN*);			/* OUT: plsrun of this DNODE */

LSERR LsdnGetLeftIndentDur(
					 PLSC,				/* IN: Pointer to LS Context */
					 long*);			/* OUT: dur of the left margin */

LSERR LsdnFCanBreakBeforeNextChunk(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Last DNODE of the current chunk */
					 BOOL*);			/* OUT: Can break before next chunk ? */

LSERR LsdnFStoppedAfterChunk(
					 PLSC,				/* IN: Pointer to LS Context */
					 PLSDNODE,			/* IN: Last DNODE of the current chunk */
					 BOOL*);			/* OUT: Splat or Hidden Text, producing fmtrStopped after chunk? */

#endif /* !LSDNTEXT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsfetch.h ===
#ifndef LSFETCH_DEFINED
#define LSFETCH_DEFINED

#include "lsdefs.h"
#include "lsfrun.h"
#include "lsesc.h"
#include "fmtres.h"
#include "plsdnode.h"
#include "lstflow.h"
#include "plssubl.h"
#include "tabutils.h"
#include "chnutils.h"
#include "lsffi.h"


#define InitFormattingContext(plsc, urLeft, cpLimStart)		\
							InitLineTabsContext((plsc)->lstabscontext,(plsc)->urRightMarginBreak, \
												(cpLimStart),\
												(plsc)->grpfManager & fFmiResolveTabsAsWord97);\
							InitSublineChunkContext((plsc)->plslineCur->lssubl.plschunkcontext,\
										urLeft, 0);\
							(plsc)->lslistcontext.plsdnToFinish = NULL;\
							(plsc)->lslistcontext.plssublCurrent = &((plsc)->plslineCur->lssubl);\
							(plsc)->lslistcontext.plssublCurrent->cpLim = (cpLimStart);\
							(plsc)->lslistcontext.plssublCurrent->urCur = (urLeft);\
							(plsc)->lslistcontext.plssublCurrent->urColumnMax = (plsc)->urRightMarginBreak;\
							(plsc)->lslistcontext.nDepthFormatLineCurrent = 1;\
							Assert((plsc)->lslistcontext.plssublCurrent->vrCur == 0);\
							Assert((plsc)->lslistcontext.plssublCurrent->plsdnLast == NULL);


LSERR 	FetchAppendEscResumeCore(
			PLSC plsc,					/* IN: LineServices context 	*/
			long urColumnMax,			/* IN: urColumnMax				*/
			const LSESC* plsesc,		/* IN: escape characters		*/
			DWORD clsesc,				/* IN: # of escape characters	*/
			const BREAKREC* rgbreakrec,	/* IN: input array of break records */
			DWORD cbreakrec,			/* IN: number of records in input array */
			FMTRES* pfmtres,			/* OUT: result of last formatter*/
			LSCP*	  pcpLim,			/* OUT: cpLim */
			PLSDNODE* pplsdnFirst,		/* OUT: plsdnFirst				*/
			PLSDNODE* pplsdnLast,		/* OUT: plsdnLast				*/
			long*	  pur);				/* OUT: result pen position 	*/

LSERR 	FetchAppendEscCore(
			PLSC plsc,					/* IN: LineServices context		*/
			long urColumnMax,			/* IN: urColumnMax				*/
			const LSESC* plsesc,		/* IN: escape characters		*/
			DWORD clsesc,				/* IN: # of escape characters	*/
			FMTRES* pfmtres,			/* OUT: result of last formatter*/
			LSCP*	  pcpLim,			/* OUT: cpLim */
			PLSDNODE* pplsdnFirst,		/* OUT: plsdnFirst				*/
			PLSDNODE* pplsdnLast,		/* OUT: plsdnLast				*/
			long*    pur);				/* OUT: result pen position		*/

LSERR	QuickFormatting(
			PLSC plsc,					/* IN: LineServices context		*/
	        LSFRUN* plsfrun,			/* IN: already featched run				*/
			long urColumnMax,			/* IN: urColumnMax				*/
			BOOL* pfGeneral,			/* OUT: quick formatting was stopped: we should general formatting */
			BOOL* pfHardStop,			/* OUT: formatting has been stoped due to special situation, not because
												exceeded margin*/
			LSCP*	  pcpLim,			/* OUT: cpLim */
			long*   pur);				/* OUT: result pen position		*/



LSERR	ProcessOneRun(	
			PLSC plsc,					/* IN: LineServices context		*/
		    long urColumnMax,			/* IN: urColumnMax				*/
		    const LSFRUN* plsfrun,		/* IN: given run				*/
			const BREAKREC* rgbreakrec,	/* IN: input array of break records */
			DWORD cbreakrec,			/* IN: number of records in input array */
		    FMTRES* pfmtres);			/* OUT: result of last formatter*/

LSERR 	CreateSublineCore(
			 PLSC plsc,			/* IN: LS context			*/
			 LSCP cpFirst,		/* IN: cpFirst				*/
			 long urColumnMax,	/* IN: urColumnMax			*/
			 LSTFLOW lstflow,	/* IN: text flow			*/
			 BOOL);				/* IN: fContiguos 			*/
						  

LSERR   FinishSublineCore(
			 PLSSUBL);			/* IN: subline to finish	*/

LSERR FormatAnm(
			 PLSC plsc,					/* IN: LS context			*/
			 PLSFRUN plsfrunMainText);
LSERR InitializeAutoDecTab(
			 PLSC plsc,		/* IN: LS context			*/
			 long durAutoDecimalTab); /* IN:auto decimal tab offset */

LSERR HandleTab( 
			 PLSC plsc);	/* IN: LS context			*/


LSERR  CloseCurrentBorder(PLSC plsc);  /* IN: LS context			*/

long RightMarginIncreasing(PLSC plsc, long urColumnMax);



#endif /* LSFETCH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsgrchnk.h ===
#ifndef LSGRCHNK_DEFINED
#define LSGRCHNK_DEFINED

#include "lsidefs.h"
#include "lschnke.h"

#define fcontNonTextBefore	1
#define fcontExpandBefore	2
#define fcontNonTextAfter	4
#define fcontExpandAfter	8

typedef	struct lsgrchnk
{
	DWORD clsgrchnk;
	PLSCHNK plschnk;
	DWORD* pcont;
} LSGRCHNK;

#endif  /* !LSGRCHNK_DEFINED   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsidefs.h ===
#ifndef LSIDEFS_DEFINED
#define LSIDEFS_DEFINED

/*
	Disable non standard comment warning to allow "//" comments since such
	comments are in the public headers.
*/
#pragma warning (disable : 4001)

/* For ICECAP builds turn off the static directive */
#ifdef ICECAP
#define static
#endif /* ICECAP */

/* Common utility macros shared by all of Line Services
 */

#include "lsdefs.h"		/* Make external common defines visible internally */

/* ****************************************************************** */
/* Item #1: The Assert() family of macros.
 *
 *  Assert() generates no code for non-debug builds.
 *  AssertSz() is like Assert(), but you specify a string to print.
 *      victork: AssertSz() is unaccessible 
 *  AssertBool() validates that its parameter is either "1" or "0".
 *  AssertDo() checks the result of an expression that is ALWAYS
 *   compiled, even in non-debug builds.
 *  AssertErr asserts there is an error with displaying a string
 *  AssertImplies(a, b) checks that a implies b
 */
#ifdef DEBUG

 void (WINAPI* pfnAssertFailed)(char*, char*, int);
 #define AssertSz(f, sz)	\
	 (void)( (f) || (pfnAssertFailed(sz, __FILE__, __LINE__), 0) )
 #define AssertDo(f)		Assert((f) != 0)

#else /* !DEBUG */

 #define AssertSz(f, sz) 	(void)(0)
 #define AssertDo(f)		(f)

#endif /* DEBUG */

#define AssertEx(f)		AssertSz((f), "!(" #f ")")
#define AssertBool(f)	AssertSz(((f) | 1) == 1, "boolean not zero or one");
 /* use AssertBool(fFoo) before assuming "(fFoo == 1 || fFoo == 0)" */
#define Assert(f)		AssertEx(f)
#define NotReached()	AssertSz(fFalse, "NotReached() declaration reached")
#define AssertErr(sz)	(pfnAssertFailed(sz, __FILE__, __LINE__), 0)
#define FImplies(a,b) (!(a)||(b))
#define AssertImplies(a, b) AssertSz(FImplies(a, b), #a " => " #b)


#pragma warning(disable:4705)		/* Disable "Code has no effect" */


/* ****************************************************************** */
/* Item #2:
 *  A macro to compute the amount of storage required for an instance
 *  of a datatype which is defined with a repeating last element:
 *
 *	struct s
 *	{
 *		int a,b,c;
 *		struct q
 *		{
 *			long x,y,z;
 *		} rgq[1];
 *	};
 *
 * To determine the number of bytes required to hold a "struct s" 
 * with "N" repeating elements of type "rgq", use "cbRep(struct s, rgq, N)";
 */

#include <stddef.h>
#define cbRep(s,r,n)	(offsetof(s,r) + (n) * (sizeof(s) - offsetof(s,r)))


/* ****************************************************************** */
/* Item #3:
 *  Macros which work with tags for validating the types of structures.
 *
 *   tagInvalid denotes a tag which will not be used for valid object types.
 *
 *   Tag('A','B','C','D') generates a DWORD which looks like "ABCD" in a
 *   Little-Endian debugger memory dump.
 *
 *   FHasTag() assumes that the structure parameter has a DWORD member
 *   named "tag", and checks it against the tag parameter.
 *
 * To use these macros, define a unique tag for each data type and a macro
 * which performs typechecking for the type:
 *  #define tagFOO		tag('F','O','O','@')
 *  #define FIsFoo(p)	FHasTag(p,tagFoo)
 *
 * Next, initialize the tag when the structure is allocated:
 *
 *  pfoo->tag = tagFOO;
 *
 * Then, for all APIs which manipulate items of type FOO, validate the
 * type of the parameter before doing any work with it.
 *
 *  if (!FIsFoo(pfoo))
 *     {
 *     // return an error.
 *     }
 */

#define tagInvalid		((DWORD) 0xB4B4B4B4)
#define Tag(a,b,c,d)	((DWORD)(d)<<24 | (DWORD)(c)<<16 | (DWORD)(b)<<8 | (a))
#define FHasTag(p,t)	((p) != NULL && (p)->tag == (t))

/* ****************************************************************** */
/* Item #4:
 *
 * Clever code from Word.h meaning:  "a >= b && a <= c"
 * (When b and c are constants, this can be done with one test and branch.)
 */

#define FBetween(a, b, c)	(Assert(b <= c), \
		(unsigned)((a) - (b)) <= (unsigned)((c) - (b))\
		)


/* ****************************************************************** */
/* Item #4:
 *
 * Macro meaning:  I'm ignoring this parameter on purpose.
 */
#define Unreferenced(a)	((void)a)


#endif /* LSIDEFS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsmem.h ===
#ifndef LSMEM_DEFINED
#define LSMEM_DEFINED

#include <string.h>

#pragma intrinsic(memset, memcpy, memcmp)			/* To avoid c run-time */

#endif /* !LSMEM_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsiocon.h ===
#ifndef LSIOCON_DEFINED
#define LSIOCON_DEFINED

#include "lsdefs.h"
#include "pilsobj.h"
#include "lsimeth.h"

typedef struct lsiobjcontext
{
	DWORD iobjMac;
	struct OBJ
    {
		PILSOBJ pilsobj;
		LSIMETHODS lsim;
	} rgobj[1];
}  LSIOBJCONTEXT;


#endif /* LSIOCON_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsline.h ===
#ifndef LSLINE_DEFINED
#define LSLINE_DEFINED

#include "plsline.h"
#include "plsdnode.h"
#include "plnobj.h"
#include "lslinfo.h"
#include "lspap.h"
#include "lsidefs.h"
#include "lssubl.h"

#define tagLSLINE		Tag('L','I','N','E')
#define FIsLSLINE(plsline)	FHasTag(plsline,tagLSLINE)
#define FLineValid(plsline, plsc)	((FIsLSLINE(plsline)) && (plsline->lssubl.plsc == plsc))


struct lsline
{
	DWORD tag;

	LSSUBL lssubl;			/* structure that describes main subline */

	LSLINFO	lslinfo;

	PQHEAP pqhAllDNodes;

	long upStartAutonumberingText;	/* starting position of autonumering text
									calculated in PrepForDisplay*/
	long upLimAutonumberingText;	/* end of autonumering text	
									calculated in PrepForDisplay*/
	long upStartMainText;			/* starting position of main text
									calculated in PrepForDisplay*/
	long upStartTrailing;
	long upLimLine;					/* end of line
									calculated in PrepForDisplay*/

	long dvpAbove;				/* Vertical extent -- prev. & ref. coords */
	long dvpBelow;

	long upRightMarginJustify;	/* Width of column, calculated in PrepForDisplay            */

	long upLimUnderline;    	/* boundary of underlining, calculated in PrepForDisplay    */


	enum ksplat kspl;		   /* kind of splat to show on this line */

	
	BOOL fAllSimpleText;  /* this variable is used only for optimization and is not handled 
							 strictly:  if it is true then only text can be in a line,
							 but backward sometimes (when dnode was deleted or after break)
							 is not true;  */
 
	BOOL fCollectVisual;

	BOOL fNonRealDnodeEncounted;		/* pen dnode was created during formatting */

	BOOL fNonZeroDvpPosEncounted;		/* run with non zero  was formatted in the line */

	WORD  AggregatedDisplayFlags;		/* aggregated bites from all runs formatted on this line */

	WORD pad;

	PLNOBJ rgplnobj[1];  		/*  array of plnobj    	*/
								/* should be the last	*/
};


enum ksplat	
{
	ksplNone,
	ksplColumnBreak,
	ksplSectionBreak,
	ksplPageBreak
};


#endif /* !LSLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsqcore.h ===
#ifndef LSQCORE_DEFINED
#define LSQCORE_DEFINED

#include "lsdefs.h"
#include "plssubl.h"
#include "plsqsinf.h"
#include "plscell.h"


LSERR QuerySublineCpPpointCore(
								PLSSUBL,		/* IN: pointer to subline info 				*/
								LSCP,			/* IN: cpQuery 								*/
								DWORD,      	/* IN: nDepthQueryMax						*/
								PLSQSUBINFO,	/* OUT: array[nDepthQueryMax] of LSQSUBINFO	*/
								DWORD*,		 	/* OUT: nActualDepth						*/
								PLSTEXTCELL);	/* OUT: Text cell info						*/

LSERR QuerySublinePointPcpCore(
								PLSSUBL,		/* IN: pointer to subline info 				*/
						 	   	PCPOINTUV,		/* IN: query point in the subline coordinate system:
						 	   						Text flow is the text flow of the subline,
 													zero point is at the starting point.   	*/
								DWORD,      	/* IN: 	nDepthQueryMax						*/
								PLSQSUBINFO,	/* OUT: array[nDepthQueryMax] of LSQSUBINFO	*/
								DWORD*,			/* OUT: nActualDepth						*/
								PLSTEXTCELL);	/* OUT: Text cell info						*/

#define idObjText	idObjTextChp		
#define idObjNone	(idObjTextChp - 1)


#endif /* !LSQCORE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsqrycon.h ===
#ifndef LSQUERYCONTEXT_DEFINED
#define LSQUERYCONTEXT_DEFINED

#include "lsdefs.h"
#include "plsqsinf.h"
#include "lscell.h"


typedef struct lsquerycontext			
{
	PLSQSUBINFO	plsqsubinfo;		/* array of query results, allocated by client */
	DWORD		cQueryMax;			/* size of the array (maximum query depth) */
	DWORD		cQueryLim;			/* size of already filled part of the array */
	LSTEXTCELL	lstextcell;			/* text cell info and pointer to the text dnode */

} LSQUERYCONTEXT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lssubl.h ===
#ifndef LSSUBL_DEFINED
#define LSSUBL_DEFINED


#include "lsidefs.h"
#include "plsdnode.h"
#include "lstflow.h"
#include "plschcon.h"
#include "posinln.h"
#include "objdim.h"
#include "brkkind.h"




#define tagLSSUBL		Tag('L','S','S','L')	 
#define FIsLSSUBL(p)	FHasTag(p,tagLSSUBL)


typedef struct brkcontext
	{
	POSINLINE posinlineBreakPrev; /* information about previous break */
	OBJDIM objdimBreakPrev;
	BRKKIND brkkindForPrev;
	BOOL fBreakPrevValid;

	POSINLINE posinlineBreakNext; /* information about next break */
	OBJDIM objdimBreakNext;
	BRKKIND brkkindForNext;
	BOOL fBreakNextValid;

	POSINLINE posinlineBreakForce; /* information about force break */
	OBJDIM objdimBreakForce;
	BRKKIND brkkindForForce;
	BOOL fBreakForceValid;
	}
BRKCONTEXT;


typedef struct lssubl

{
	DWORD tag;     						/* tag for safety checks   */

	PLSC plsc;							/* LineServices context
										   parameter to CreateSubLine */
	LSCP cpFirst;						/* cp for the first fetch
										   parameter to CreateSubLine */
	LSTFLOW lstflow;					/* text flow of the subline
										   parameter to CreateSubLine */

	long urColumnMax;					/* max lenght to fit into a main line
										   parameter to CreateSubLine */


	LSCP cpLim;							/* during formatting is a cpFirst for the next fetch 		
										   after SetBreak indicates boundary of the line */

	LSCP cpLimDisplay;					/* doesn't consider splat char */

	PLSDNODE plsdnFirst;				/* starting dnode in a subline */

	PLSDNODE plsdnLast;					/* last dnode in a subline 
										   during formatting serves as psdnToAppend */

	PLSDNODE plsdnLastDisplay;			/* doesn't consider splat dnode */

	PLSCHUNKCONTEXT plschunkcontext;

	PLSDNODE plsdnUpTemp;				/* temporary used for collecting group chunk */

	long urCur, vrCur;					/* Current pen position in reference units */

	BRKCONTEXT* pbrkcontext;			/* information about break opportunites */

	BYTE fContiguous;					/* if TRUE such line has the same coordinate system as main line
										   and is allowed to have tabs,
										   otherwise coordinates of the line starts from 0,0
										   parameter to CreateSubLine */


	BYTE fDupInvalid;					/* TRUE before preparing line for display */
	BYTE fMain;							/* is this subline main */

	BYTE fAcceptedForDisplay;			/* subline was submitted for display and accepted */

	BYTE fRightMarginExceeded;			/* used for low level subline to avoid double call to
										   nominal to ideal */

} LSSUBL;


#define LstflowFromSubline(plssubl)  ((plssubl)->lstflow)

#define PlschunkcontextFromSubline(plssubl)  ((plssubl)->plschunkcontext)

#define FIsSubLineMain(plssubl) (plssubl)->fMain

#endif /* LSSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lsstring.h ===
#ifndef LSSTRING_DEFINED
#define LSSTRING_DEFINED

#include "lsidefs.h"
#include "pilsobj.h"
#include "plnobj.h"
#include "plsrun.h"
#include "lstflow.h"
#include "txtobj.h"

LSERR GetWidths(PLNOBJ, PLSRUN, long, LPWSTR, LSCP, long, long, LSTFLOW, long*, long*);
/*
  PLNOBJ (IN) - pointer to lnobj
  PLSRUN (IN) - plsrun
  long (IN) - first index in dur array to use
  LPWSTR (IN) - array of characters
  LSCP (IN) - cpFirst
  long(IN) - number of characters
  long (IN) - width until right margin
  LSTFLOW (IN) - text flow
  long* (OUT) - number of characters for which width has been fetched
  long* (OUT) - total width of these characters
*/


LSERR FormatString(PLNOBJ, PTXTOBJ, WCHAR*, long, long*, long, long);
/* function is called to format  a Local Run
  PLNOBJ (IN) - pointer to lnobj
  PTXTOBJ (IN) - pointer to dobj
  WCHAR* (IN) - pointer to the character array
  long (IN) - number of characters
  long* (IN) - pointer to the spaces array
  long (IN) - number of spaces
  long (IN) - width of all chars
*/

LSERR FillRegularPresWidths(PLNOBJ, PLSRUN, LSTFLOW, PTXTOBJ);
/*
  PLNOBJ (IN) - pointer to lnobj
  PLSRUN (IN) - plsrun
  LSTFLOW (IN) - lstflow
  PTXTOBJ (IN) - pointer to dobj
*/


LSERR GetOneCharDur(PILSOBJ, PLSRUN, WCHAR, LSTFLOW, long*);
/*
  PILSOBJ (IN) - pointer to the ilsobj 
  PLSRUN (IN) - plsrun
  WCHAR (IN) - character code
  LSTFLOW (IN) - text flow
  long* (OUT) - presentation width of the character
*/

LSERR GetOneCharDup(PILSOBJ, PLSRUN, WCHAR, LSTFLOW, long, long*);
/*
  PILSOBJ (IN) - pointer to the ilsobj 
  PLSRUN (IN) - plsrun
  WCHAR (IN) - character code
  LSTFLOW (IN) - text flow
  long (IN) - reference width of the character
  long* (OUT) - presentation width of the character
*/

LSERR GetVisiCharDup(PILSOBJ, PLSRUN, WCHAR, LSTFLOW, long*);
/*
  PILSOBJ (IN) - pointer to the ilsobj 
  PLSRUN (IN) - plsrun
  WCHAR (IN) - visi character code
  LSTFLOW (IN) - text flow
  long* (OUT) - presentation width of the character
*/

LSERR AddCharacterWithWidth(PLNOBJ, PTXTOBJ, WCHAR, long, WCHAR, long);
/* adds character with specified width in the display list
  PLNOBJ (IN) - pointer to lnobj
  PTXTOBJ (IN) - pointer to dobj
  WCHAR (IN)  - character for rgwchOrig
  long (IN) - width in reference units
  WCHAR (IN)  - character for rgwch
  long (IN) - width in preview units
*/

void FixSpaces(PLNOBJ, PTXTOBJ, WCHAR);
/*
  PLNOBJ (IN) - pointer to lnobj
  PTXTOBJ (IN) - pointer to dobj
  WCHAR (IN) - VisiSpace code
*/

LSERR AddSpaces(PLNOBJ, PTXTOBJ, long, long);
/*
  PLNOBJ (IN) - pointer to the lnobj
  PTXTOBJ (IN) - poiter to dobj
  long (IN) - reference width of space;
  long (IN) - number of trailing spaces to be added 
*/

void FlushStringState(PILSOBJ);
/*
  PILSOBJ (IN) - pointer to the ilsobj 
*/

LSERR IncreaseWchMacBy2(PLNOBJ);
/*
  PLNOBJ (IN) - pointer to the lnobj
*/

#endif /* !LSSTRING_DEFINED                                                */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstext.h ===
#ifndef LSTEXT_DEFINED
#define LSTEXT_DEFINED

#include "lsidefs.h"
#include "pdobj.h"
#include "lsgrchnk.h"

/* Standard methods */
#include "lstxtini.h"
#include "lstxtfmt.h"
#include "lstxtjst.h"
#include "disptext.h"
#include "lstxtbrk.h"
#include "lstxtbr1.h"
#include "lstxtnti.h"
#include "lstxttab.h"
#include "lstxtqry.h"
#include "textenum.h"


#endif /* !LSTEXT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtbr1.h ===
#ifndef LSTXTBR1_DEFINED
#define LSTXTBR1_DEFINED

#include "lsidefs.h"
#include "breakrec.h"
#include "brkkind.h"
#include "pdobj.h"
#include "plocchnk.h"
#include "pposichn.h"
#include "plsfgi.h"
#include "pbrko.h"
#include "pobjdim.h"


LSERR QuickBreakText(PDOBJ, BOOL*, LSDCP*, POBJDIM);	
LSERR WINAPI SetBreakText(PDOBJ, BRKKIND, DWORD, BREAKREC*, DWORD*);
LSERR WINAPI ForceBreakText(PCLOCCHNK, PCPOSICHNK, PBRKOUT);
LSERR WINAPI TruncateText(PCLOCCHNK, PPOSICHNK);
#endif  /* !LSTXTBR1_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstbcon.h ===
#ifndef LSTBCON_DEFINED
#define LSTBCON_DEFINED

#include "lsdefs.h"
#include "lscaltbd.h"
#include "plsdnode.h"
#include "plscbk.h"
#include "plschcon.h"
#include "lsdocinf.h"

typedef struct lstabscontext
{
/* tabs from current PAP */	
	BYTE fTabsInitialized;
	long durIncrementalTab;	   	   /* scaled from LSPAP.lstabs                                 */
	DWORD ccaltbdMax;			/* Maximum number of records in pTbd */
	DWORD icaltbdMac;			   /* number of tabs records in pTbd */
	LSCALTBD* pcaltbd; 		/* distilled from LSPAP.lstabs, with effect of hanging tab  */
							   	   /*  factored in                                             */
	/* Pending Tab info */
	long urBeforePendingTab;
	PLSDNODE plsdnPendingTab;

	PLSCBK   plscbk;			/* call backs */
	POLS pols;					/* client's information for callbacks */
	LSDOCINF* plsdocinf;		/* here we can take resolution */
	long urColumnMax;			/* column width to solve break through tab  problem */
	LSCP cpInPara;				/* cp to use for fetching tabs						*/
	BOOL fResolveTabsAsWord97;

}  LSTABSCONTEXT;

#endif /* LSTBCON_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtbrk.h ===
#ifndef LSTXTBRK_DEFINED
#define LSTXTBRK_DEFINED

#include "lsidefs.h"
#include "pdobj.h"
#include "plocchnk.h"
#include "pposichn.h"
#include "pbrko.h"
#include "brkcond.h"

LSERR WINAPI FindPrevBreakText(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
LSERR WINAPI FindNextBreakText(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);

#endif  /* !LSTXTBRK_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtbrs.h ===
#ifndef LSTXTBRS_DEFINED
#define LSTXTBRS_DEFINED

#include "lsidefs.h"
#include "pdobj.h"
#include "plocchnk.h"
#include "pobjdim.h"
#include "lstflow.h"
#include "lschnke.h"
#include "txtils.h"
#include "txtobj.h"

typedef struct hyphout
{
	long durHyphen;
	long dupHyphen;
	long durPrev;
	long dupPrev;
	long durPrevPrev;
	long dupPrevPrev;
	long ddurDnodePrev;
	long ddurDnodePrevPrev;
	long durChangeTotal;
	long iwchLim;
	long dwchYsr;
	WCHAR wchPrev;
	WCHAR wchPrevPrev;
	long igindHyphen;
	long igindPrev;
	long igindPrevPrev;

	GINDEX gindHyphen;
	GINDEX gindPrev;
	GINDEX gindPrevPrev;
} HYPHOUT;

typedef struct ysrinf
{
	WORD kysr;							/* Kind of Ysr - see "lskysr.h" */
	WCHAR wchYsr;						/* YSR char code  */
} YSRINF;


#define FCanBreak(pilsobj,b1, b2) \
	((pilsobj)->plsbrk[(pilsobj)->pilsbrk[(pilsobj)->cBreakingClasses * (b1) + (b2)]].fBreak)

#define FCanBreakAcrossSpaces(pilsobj, b1, b2) \
	((pilsobj)->plsbrk[(pilsobj)->pilsbrk[pilsobj->cBreakingClasses * (b1) + (b2)]].fBreakAcrossSpaces)

BOOL FindNonSpaceBefore(PCLSCHNK rglschnk, long itxtobjCur, long iwchCur,
									long* pitxtobjBefore, long* piwchBefore);
BOOL FindNonSpaceAfter(PCLSCHNK rglschnk, DWORD clschnk, long itxtobjCur, long iwchCur,
									long* pitxtobjAfter, long* piwchAfter);
BOOL FindPrevChar(PCLSCHNK rglschnk, long itxtobjCur, long iwchCur,
																long* pitxtobjBefore, long* piwchBefore);
BOOL FindNextChar(PCLSCHNK rglschnk, DWORD clschnk, long itxtobjSpace, long iwchSpace,
									long* pitxtobjAfter, long* piwchAfter);
LSERR CalcPartWidths(PTXTOBJ ptxtobj, long dwchLim, POBJDIM pobjdim, long* pdur);
LSERR CalcPartWidthsGlyphs(PTXTOBJ ptxtobj, long dwchLim, POBJDIM pobjdim, long* pdur);
LSERR CheckHotZone(PCLOCCHNK plocchnk, long itxtobj, long iwch, BOOL* pfInHyphenZone);
LSERR ProcessYsr(PCLOCCHNK plocchnk, long itxtobjYsr, long dwchYsr, long itxtobjPrev, long itxtobjPrevPrev, 
														YSRINF ysrinf, BOOL* pfSuccess, HYPHOUT* phyphout);
LSERR GetPbrkinf(PILSOBJ pilsobj, PDOBJ pdobj, BRKKIND brkkind, BREAKINFO** ppbrkinf);


#endif  /* !LSTXTBRS_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtcmp.h ===
#ifndef LSTXTCMP_DEFINED
#define LSTXTCMP_DEFINED

#include "lsidefs.h"
#include "pilsobj.h"
#include "lsgrchnk.h"
#include "lstflow.h"
#include "mwcls.h"

LSERR FetchCompressInfo(const LSGRCHNK* plsgrchnk, BOOL fFirstOnLine, LSTFLOW lstflow,
							long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim,
							long durCompressMaxStop, long* pdurCompressTotal);
void GetCompLastCharInfo(PILSOBJ pilsobj, long iwchLast, MWCLS* pmwcls,
														long* pdurCompRight, long* pdurCompLeft);

void CompressLastCharRight(PILSOBJ pilsobj, long iwchLast, long durToAdjustRight);
LSERR ApplyCompress(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, 
					long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim, long durToCompress);
LSERR ApplyExpand(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, BOOL fScaled,
				long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim,
				DWORD cNonTextObjects, long durToExpand, long* pdurExtNonText, BOOL* pfFinalAdjustNeeded);
void ApplyDistribution(const LSGRCHNK* plsgrchnk, DWORD cNonText,
									   long durToDistribute, long* pdurNonTextObjects);

#endif  /* !LSTXTCMP_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtfmt.h ===
#ifndef LSTXTFMT_DEFINED
#define LSTXTFMT_DEFINED

#include "lsidefs.h"
#include "plnobj.h"
#include "pdobj.h"
#include "pfmti.h"
#include "fmtres.h"


LSERR WINAPI FmtText(PLNOBJ, PCFMTIN, FMTRES*);
LSERR WINAPI DestroyDObjText(PDOBJ);

LSERR LsSublineFinishedText(PLNOBJ plnobj);

#endif  /* !LSTXTFMT_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtjst.h ===
#ifndef LSTXTJST_DEFINED
#define LSTXTJST_DEFINED

#include "lsidefs.h"
#include "plnobj.h"
#include "lskjust.h"
#include "plocchnk.h"
#include "pposichn.h"
#include "lsgrchnk.h"
#include "lstflow.h"

LSERR AdjustText(
					LSKJUST, 			/* IN: justification type			*/
					long,				/* IN: durColumnMax	(from the last
											   tab	position)				*/
					long,				/* IN: durTotal	(from the last tab
										   position without trailing area)	*/
					long,				/* IN: dup available				*/
					const LSGRCHNK*,	/* IN: Group of chunks				*/
					PCPOSICHNK pposichnkBeforeTrailing,
										/* Information about last
												 cp before trailing area	*/
					LSTFLOW,			/* IN: Text flow					*/
					BOOL,				/* IN: compression?					*/
					DWORD,				/* IN: Number of non-text objects	*/
					BOOL,				/* IN: Suppress wiggling?			*/
					BOOL,				/* IN: Exact synchronization?		*/
					BOOL,				/* IN: fForcedBreak?				*/
					BOOL,				/* IN: Suppress trailing spaces?	*/
					long*,				/* OUT: dup of text in chunk		*/
					long*,				/* OUT: dup of trailing part		*/
					long*,				/* OUT: additional dup of non-text	*/
					DWORD*);			/* OUT: pcExtNonTextObjects			*/

void GetTrailInfoText(
					PDOBJ,				/* IN: pdobj						*/
					LSDCP,				/* IN: dcp in dobj					*/
					DWORD*,				/* OUT: number of trailing spaces	*/
					long*);				/* OUT: dur of the trailing area	*/


BOOL FSuspectDeviceDifferent(
					PLNOBJ);				/* IN: Text plnobj	
					*/
/* Returns True if: no dangerous Visi Characters, no non-req hyphens, opt. non-break, opt. break */

BOOL FQuickScaling(
					PLNOBJ,				/* IN: Text plnobj					*/
					BOOL,				/* IN: fVertical					*/
					long);				/* IN: durTotal						*/
/* Returns True if: no dangerous Visi Characters, no additional allocations for DOBJ's, durTotal is
	less than accepatable for fast scaling
*/

void QuickAdjustExact(
					PDOBJ*,				/* IN: array of PDOBJs				*/
					DWORD,				/* IN: number of elements in array	*/
					DWORD,				/* IN: number of trailing spaces	*/
					BOOL,				/* IN: fVertical					*/
					long*,				/* OUT: dup of text in chunk		*/
					long*);				/* OUT: dup of trailing part		*/


LSERR CanCompressText(
					const LSGRCHNK*,	/* IN: Group of chunks				*/
					PCPOSICHNK pposichnkBeforeTrailing,
										/* Information about last
												 cp before trailing area	*/
					LSTFLOW,			/* IN: Text flow					*/
					long,				/* IN: dur to compress				*/
					BOOL*,				/* OUT: can compress?				*/
					BOOL*,				/* OUT: actual compression?			*/
					long*);				/* OUT: pdurNonSufficient			*/


LSERR DistributeInText(					/* 									*/
					const LSGRCHNK*,	/* IN: group chunk of text			*/
					LSTFLOW,			/* IN: Text flow					*/
					DWORD,				/* IN: Number of non-text objects	*/
				   	long,	            /* IN: durToDistribute				*/
					long*);				/*OUT: additional dur of  non-text  */

#endif  /* !LSTXTJST_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtmap.h ===
#ifndef LSTXTMAP_DEFINED
#define LSTXTMAP_DEFINED

#include "lsidefs.h"
#include "pilsobj.h"
#include "txtobj.h"

long IgindFirstFromIwchVeryFirst (PTXTOBJ ptxtobj, long igindVeryFirst, long iwch);
long IgindLastFromIwchVeryFirst (PTXTOBJ ptxtobj, long igindVeryFirst, long iwch);

long IgindFirstFromIwch(PTXTOBJ ptxtobj, long iwch); /* iwch can be Lim for ptxtobj */
long IgindLastFromIwch(PTXTOBJ ptxtobj, long iwch);
long IgindBaseFromIgind(PILSOBJ pilsobj, long igind); /* Last glyph with non-zero width before igind */
long IwchFirstFromIgind(PTXTOBJ ptxtobj, long igind);
long IwchLastFromIwch(PTXTOBJ ptxtobj, long iwch);
long IwchPrevLastFromIwch(PTXTOBJ ptxtobj, long iwch);
BOOL FIwchOneToOne(PILSOBJ pilsobj, long iwch);
BOOL FIwchLastInContext(PILSOBJ pilsobj, long iwch);
BOOL FIwchFirstInContext(PILSOBJ pilsobj, long iwch);
BOOL FIgindLastInContext(PILSOBJ pilsobj, long igind);
BOOL FIgindFirstInContext(PILSOBJ pilsobj, long igind);
long DcpAfterContextFromDcp(PTXTOBJ ptxtobj, long dcp);
void InterpretMap(PLNOBJ pilsobj, long iwchFirst, long dwch, long igindFirst, long cgind);

#endif  /* !LSTXTMAP_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtini.h ===
#ifndef LSTXTINI_DEFINED
#define LSTXTINI_DEFINED

#include "lsidefs.h"
#include "lstxtcfg.h"
#include "lsbrk.h"
#include "lspairac.h"
#include "lspract.h"
#include "lsexpan.h"
#include "pilsobj.h"
#include "plnobj.h"
#include "plscbk.h"
#include "plsdocin.h"
#include "tlpr.h"

/* Standard methods */
LSERR WINAPI CreateILSObjText(POLS, PCLSC, PCLSCBK, DWORD, PILSOBJ*);
LSERR WINAPI DestroyILSObjText(PILSOBJ);
LSERR WINAPI SetDocText(PILSOBJ, PCLSDOCINF);
LSERR WINAPI CreateLNObjText(PCILSOBJ, PLNOBJ*);
LSERR WINAPI DestroyLNObjText(PLNOBJ);

/* Text-specific interface */
LSERR SetTextConfig(PILSOBJ,			/* IN: Text ILSOBJ					*/
					const LSTXTCFG*);	/* IN: HLSC-specific text config	*/

LSERR SetTextLineParams(PLNOBJ,			/* IN: Text LNOBJ					*/
						const TLPR*);	/* IN: text doc props				*/

LSERR ModifyTextLineEnding(
					PLNOBJ,				/* IN: Text LNOBJ					*/
					LSKEOP);			/* IN: Kind of line ending			*/

LSERR SetTextBreaking(
					PILSOBJ,			/* IN: Text ILSOBJ					*/
					DWORD,				/* IN: Number of breaking info units*/
					const LSBRK*,		/* IN: Breaking info units array	*/
					DWORD,				/* IN: Number of breaking classes	*/
					const BYTE*);		/* IN: Breaking information(square):
											  indexes in the LSEXPAN array  */
LSERR SetTextModWidthPairs(
					PILSOBJ,			/* IN: Text ILSOBJ					 */
					DWORD,				/* IN: Number of mod pairs info units*/ 
					const LSPAIRACT*,	/* IN: Mod pairs info units array  	 */
					DWORD,				/* IN: Number of Mod Width classes	 */
					const BYTE*);		/* IN: Mod width information:
											  indexes in the LSPAIRACT array */
LSERR SetTextCompression(
					PILSOBJ,			/* IN: Text ILSOBJ					 */
				  	DWORD,				/* IN: Number of compression priorities*/
					DWORD,				/* IN: Number of compression info units*/
					const LSPRACT*,		/* IN: Compession info units array 	*/
					DWORD,				/* IN: Number of Mod Width classes	*/
					const BYTE*);		/* IN: Compression information:
											  indexes in the LSPRACT array  */
LSERR SetTextExpansion(
					PILSOBJ,			/* IN: Text ILSOBJ					 */
					DWORD,				/* IN: Number of expansion info units*/
					const LSEXPAN*,		/* IN: Expansion info units array	*/
					DWORD,				/* IN: Number of Mod Width classes	*/
					const BYTE*);		/* IN: Expansion information:
											  indexes in the LSEXPAN array  */

#endif /* !LSTXTINI_DEFINED											  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtffi.h ===
#ifndef LSTXTFFI_DEFINED
#define LSTXTFFI_DEFINED

#include "lsffi.h"

#define fTxtVisiCondHyphens			fFmiVisiCondHyphens
#define fTxtVisiParaMarks			fFmiVisiParaMarks
#define fTxtVisiSpaces				fFmiVisiSpaces
#define fTxtVisiTabs				fFmiVisiTabs
#define fTxtVisiBreaks				fFmiVisiBreaks
#define fTxtDoHyphenation			fFmiDoHyphenation
#define fTxtWrapTrailingSpaces		fFmiWrapTrailingSpaces
#define fTxtWrapAllSpaces			fFmiWrapAllSpaces
#define fTxtPunctStartLine			fFmiPunctStartLine
#define fTxtHangingPunct			fFmiHangingPunct
#define fTxtApplyBreakingRules		fFmiApplyBreakingRules
#define fTxtFCheckTruncateBefore	fFmiFCheckTruncateBefore
#define fTxtDrawInCharCodes			fFmiDrawInCharCodes
#define fTxtSpacesInfluenceHeight	fFmiSpacesInfluenceHeight
#define fTxtIndentChangesHyphenZone	fFmiIndentChangesHyphenZone
#define fTxtNoPunctAfterAutoNumber	fFmiNoPunctAfterAutoNumber	
#define	fTxtTreatHyphenAsRegular	fFmiTreatHyphenAsRegular
#endif /* !LSTXTFFI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtglf.h ===
#ifndef LSTXTGLF_DEFINED
#define LSTXTGLF_DEFINED

#include "lsidefs.h"
#include "pilsobj.h"
#include "lsgrchnk.h"
#include "lsdevice.h"
#include "lstflow.h"

LSERR ApplyGlyphExpand(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev,
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
						long duToDistribute, long* rgdu, long* rgduGind, long* rgduRight, long* rgduGright,
						BOOL* pfFullyJustified);


#endif  /* !LSTXTGLF_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtmod.h ===
#ifndef LSTXTMOD_DEFINED
#define LSTXTMOD_DEFINED

#include "lsidefs.h"

#include "pilsobj.h"
#include "plsems.h"
#include "lsact.h"

void GetChanges(LSACT lsact, PLSEMS plsems, long durCur, BOOL fByIsPlus, BYTE* pside, long* pddurChange);
void TranslateChanges(BYTE sideRecom, long durAdjustRecom, long durCur, long durRight, long durLeft,
														 BYTE* psideFinal, long* pdurChange);
void InterpretChanges(PILSOBJ pilsobj, long iwch, BYTE side, long ddurChange, long* pddurChangeLeft, long* pddurChangeRight);
void ApplyChanges(PILSOBJ pilsobj, long iwch, BYTE side, long ddurChange);
void UndoAppliedChanges(PILSOBJ pilsobj, long iwch, BYTE side, long* pddurChange);
void ApplyGlyphChanges(PILSOBJ pilsobj, long igind, long ddurChange);
#endif  /* !LSTXTMOD_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtnti.h ===
#ifndef LSTXTNTI_DEFINED
#define LSTXTNTI_DEFINED

#include "lsidefs.h"
#include "lstflow.h"
#include "mwcls.h"
#include "lschnke.h"
#include "pheights.h"

LSERR NominalToIdealText(
					DWORD,				/* IN: grpfTnti flags---see tnti.h	*/
					LSTFLOW,			/* IN: lstflow						*/
					BOOL,				/* IN: fFirstOnLine					*/
					BOOL,				/* IN: fAutoNumberPresent			*/
					DWORD,				/* IN: number of dobj's in chunk	*/
					const LSCHNKE*);	/* IN: rgchnk--chunk				*/

LSERR GetFirstCharInChunk(
					DWORD,				/* IN: number of dobj's in chunk	*/
					const LSCHNKE*,		/* IN: rgchnk--chunk				*/
					BOOL*,				/* OUT: fSuccessful					*/
					WCHAR*,				/* OUT: char code					*/
					PLSRUN*,			/* OUT: plsrun of character			*/
					PHEIGHTS,			/* OUT: heightsPres of character	*/
					MWCLS*);			/* OUT: ModWidthClass of char		*/

LSERR GetLastCharInChunk(
					DWORD,				/* IN: number of dobj's in chunk	*/
					const LSCHNKE*,		/* IN: rgchnk--chunk				*/
					BOOL*,				/* OUT: fSuccessful					*/
					WCHAR*,				/* OUT: char code					*/
					PLSRUN*,			/* OUT: plsrun of character			*/
					PHEIGHTS,			/* OUT: heightsPres of character	*/
					MWCLS*);			/* OUT: ModWidthClass of char		*/

LSERR ModifyFirstCharInChunk(
					DWORD,				/* IN: number of dobj's in chunk	*/
					const LSCHNKE*,		/* IN: rgchnk--chunk				*/
					long);				/* IN: durChange					*/

LSERR ModifyLastCharInChunk(
					DWORD,				/* IN: number of dobj's in chunk	*/
					const LSCHNKE*,		/* IN: rgchnk--chunk				*/
					long);				/* IN: durChange					*/

LSERR CutTextDobj(
					DWORD,				/* IN: number of dobj's in chunk	*/
					const LSCHNKE*);	/* IN: rgchnk--chunk				*/

#endif  /* !LSTXTNTI_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtqry.h ===
#ifndef LSTXTQRY_DEFINED
#define LSTXTQRY_DEFINED

#include "lsdefs.h"
#include "pdobj.h"
#include "plsqin.h"
#include "plsqout.h"
#include "gprop.h"

LSERR WINAPI QueryPointPcpText(PDOBJ, PCPOINTUV, PCLSQIN, PLSQOUT);
/* QueryTextPointPcp
 *  pdobj (IN): dobj to query
 * 	ppointuvQuery (IN): query point (uQuery,vQuery)
 *	plsqin (IN): query input
 *	plsqout (OUT): query output
 */

LSERR WINAPI QueryCpPpointText(PDOBJ, LSDCP, PCLSQIN, PLSQOUT);
/* QueryTextPointPcp
 *  pdobj (IN): dobj to query
 *  dcp (IN):  dcp for the query
 *	plsqin (IN): query input
 *	plsqout (OUT): query output
 */
LSERR WINAPI QueryTextCellDetails(
						 	PDOBJ,
							LSDCP,		/* IN: dcpStartCell	*/
							DWORD,		/* IN: cCharsInCell */
							DWORD,		/* IN: cGlyphsInCell */
							LPWSTR,		/* OUT: pointer array[nCharsInCell] of char codes */
							PGINDEX,	/* OUT: pointer array[nGlyphsInCell] of glyph indices */
							long*,		/* OUT: pointer array[nGlyphsCell] of glyph widths */
							PGOFFSET,	/* OUT: pointer array[nGlyphsInCell] of glyph offsets */
							PGPROP);	/* OUT: pointer array[nGlyphsInCell] of glyph handles */


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\ntiman.h ===
#ifndef NTIMAN_DEFINED
#define NTIMAN_DEFINED

#include "lsidefs.h"
#include "tnti.h"
#include "plsdnode.h"
#include "plschcon.h"
#include "plsiocon.h"
#include "lskjust.h"
#include "port.h"

/* MACROS ---------------------------------------------------------------------------*/

			

#define 		FApplyNominalToIdeal(plschp)\
				(GetNominalToIdealFlagsFromLschp(plschp) != 0)


#define			GetNominalToIdealFlags(plschnkcontext) \
				(plschnkcontext)->grpfTnti

#define			FNominalToIdealBecauseOfParagraphProperties(grpf, lskjust) \
				 ((grpf) & fFmiPunctStartLine) || \
				 ((grpf) & fFmiHangingPunct) || \
				 ((lskjust) == lskjSnapGrid)


/* ROUTINES ---------------------------------------------------------------*/

LSERR ApplyNominalToIdeal(
						  PLSCHUNKCONTEXT, /* LS chunk context */
						  PLSIOBJCONTEXT, /* installed objects */
						  DWORD ,		/* grpf */
						  LSKJUST,		/* kind of justification */
						  BOOL,			/* fIsSubLineMain */
						  BOOL,			/* fLineContainsAutoNumber*/
						  PLSDNODE);	/* last dnode of text */

LSERR ApplyModWidthToPrecedingChar(
						  PLSCHUNKCONTEXT, /* LS chunk context */
						  PLSIOBJCONTEXT, /* installed objects */
						  DWORD ,		/* grpf */
						  LSKJUST,		/* kind of justification */
    					  PLSDNODE); /* non-text dnode after text */

LSERR CutPossibleContextViolation(
						  PLSCHUNKCONTEXT, /* LS chunk context */
						  PLSDNODE ); /* last dnode of text */ 

#endif /* NTIMAN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxttab.h ===
#ifndef LSTXTTAB_DEFINED
#define LSTXTTAB_DEFINED

#include "lsidefs.h"
#include "lsgrchnk.h"
#include "lsdevice.h"
#include "pdobj.h"

#define idobjOutside 0xFFFFFFFF


LSERR SetTabLeader(PDOBJ,				/* IN: Tab dobj */
				   WCHAR);	            /* IN: wchTabLeader */

LSERR LsGetDecimalPoint(
					const LSGRCHNK*,	/* IN: group chunk of tab-to-tab text */
					enum lsdevice,		/* IN: lsdevice						*/
					DWORD*,				/* OUT: index of DObj with decimal */
					long*);				/* OUT: duToDecimalPoint */

LSERR LsGetCharTab(
					const LSGRCHNK*,	/* IN: group chunk of tab-to-tab text */
					WCHAR wchCharTab,	/* IN: Character for CharTab		*/
					enum lsdevice,		/* IN: lsdevice						*/
					DWORD*,				/* OUT: index of DObj with Character */
					long*);				/* OUT: duToCharacter */

#endif  /* !LSTXTTAB_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtscl.h ===
#ifndef LSTXTSCL_DEFINED
#define LSTXTSCL_DEFINED

#include "lsidefs.h"
#include "pilsobj.h"
#include "lsgrchnk.h"
#include "lskjust.h"
#include "lstflow.h"

void ApplyWysi(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow);
void ApplyNonExactWysi(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow);
void ScaleSpaces(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, long itxtobjLast, long iwchLast);
void ScaleCharSides(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, BOOL* pfLeftSideAffected, BOOL* pfGlyphsDetected);
void ScaleExtNonText(PILSOBJ pilsobj, LSTFLOW lstflow, long durExtNonText, long* pdupExtNonText);
void GetDupLastChar(const LSGRCHNK* plsgrchnk, long iwchLast, long* pdupHangingChar);
void ScaleGlyphSides(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow);
void UpdateGlyphOffsets(const LSGRCHNK* plsgrchnk);
void SetBeforeJustCopy(const LSGRCHNK* plsgrchnk);
LSERR FillDupPen(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, long itxtobjLast, long iwchLast);
LSERR FinalAdjustmentOnPres(const LSGRCHNK* plsgrchnk, long itxtobjLast, long iwchLast,
			long dupAvailable, BOOL fFinalAdjustNeeded, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			long* pdupText, long* pdupTail);

#endif  /* !LSTXTSCL_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\plschcon.h ===
#ifndef PLSCHCON_DEFINED
#define PLSCHCON_DEFINED

struct lschunkcontext;
typedef struct lschunkcontext* PLSCHUNKCONTEXT;

#endif /* PLSCHCON_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\objhelp.h ===
#ifndef OBJHELP_DEFINED
#define OBJHELP_DEFINED

#include	"lsdefs.h"
#include	"lstflow.h"
#include	"pobjdim.h"
#include	"plssubl.h"
#include	"lsesc.h"
#include	"plsdnode.h"
#include	"fmtres.h"
#include	"plsqin.h"
#include	"plsqout.h"
#include	"breakrec.h"
#include	"plnobj.h"
#include	"pdobj.h"
#include	"pfmti.h"
#include	"plsrun.h"
#include	"pheights.h"
#include	"mwcls.h"
#include	"brkkind.h"
#include	"pbrko.h"

#define ZeroMemory(a, b) memset(a, 0, b);

#ifdef DEBUG

#define Undefined(pvar) \
{int i; for (i=0; i<sizeof(*pvar); i++) ((BYTE*)pvar) [i] = 255; };

#else

#define Undefined(var) ; /* Nothing in ship-version */

#endif

#define AllocateMemory(pilsobj, cb) ((pilsobj)->lscbk.pfnNewPtr((pilsobj)->pols, (cb)))
#define FreeMemory(pilsobj, ptr) (pilsobj)->lscbk.pfnDisposePtr((pilsobj)->pols, (ptr))

#define NBreaksToSave 3 /* Number of break records to store in objects */

/*
 *	Proc: GetBreakRecordIndex 
 *	Return number of break record based on brkkind enumeration.
 *
 */


DWORD GetBreakRecordIndex (BRKKIND brkkind);

/*
 *	Proc: GetBreakRecordIndex 
 *  Fill trailing info in BRKOUT as if there is no trailing spaces
 *	
 */


LSERR FormatLine(
	PLSC plsc,
	LSCP cpStart,
	long durColMax,
	LSTFLOW lstflow,
	PLSSUBL *pplssubl,
	DWORD cdwlsesc,
	const LSESC *plsesc,
	POBJDIM pobjdim,
	LSCP *pcpOut,
	PLSDNODE *pplsdnStart,
	PLSDNODE *pplsdnEnd,
	FMTRES *pfmtres);

LSERR FormatResumedLine(
	PLSC plsc,
	LSCP cpStart,
	long durColMax,
	LSTFLOW lstflow,
	PLSSUBL *pplssubl,
	DWORD cdwlsesc,
	const LSESC *plsesc,
	POBJDIM pobjdim,
	LSCP *pcpOut,
	PLSDNODE *pplsdnStart,
	PLSDNODE *pplsdnEnd,
	FMTRES *pfmtres,
	const BREAKREC *pbreakrec,
	DWORD cbreakrec);

LSERR CreateQueryResult(
	PLSSUBL plssubl,			/*(IN): subline of ruby */
	long dupAdj,				/*(IN): u offset of start of subline */
	long dvpAdj,				/*(IN): v offset of start of subline */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout);			/*(OUT): query output */

/*
 *  Implementation of LSIMETHOD for objects that do not support the resuming
 *	of formatting. Ruby, Tatenakayoko and Hih are examples of this kind of
 *	object.
 */
LSERR WINAPI ObjHelpFmtResume(
	PLNOBJ plnobj,				/* (IN): object lnobj */
	const BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD nBreakRecord,			/* (IN): size of the break records array */
	PCFMTIN pcfmtin,			/* (IN): formatting input */
	FMTRES *pfmtres);			/* (OUT): formatting result */

/*
 *  Implementation of LSIMETHOD for objects that do nothing for mod width.
 *	Tatenakayoko and Hih are examples of this kind of object.
 */
LSERR WINAPI ObjHelpGetModWidthChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
	PCHEIGHTS pcheightsRef,		/* (IN): height info about character */
	WCHAR wchar,				/* (IN): preceding character */
	MWCLS mwcls,				/* (IN): ModWidth class of preceding character */
	long *pdurChange);			/* (OUT): amount by which width of the preceding char is to be changed */

/*
 *		Implementation of LSIMETHOD for objects that do nothing for SetBreak.
 *		Tatenakayoko and Hih are examples of this kind of object.
 */

LSERR WINAPI ObjHelpSetBreak(
	PDOBJ pdobj,				/* (IN): dobj which is broken */
	BRKKIND brkkind,			/* (IN): Previous / Next / Force / Imposed was chosen */
	DWORD cBreakRecord,			/* (IN): size of array */
	BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD *pcActualBreakRecord);	/* (IN): actual number of used elements in array */

/*
 *		Default implementation of LSIMETHOD for objects that do not
 *		allow expanding the previous character.
 */

LSERR WINAPI ObjHelpFExpandWithPrecedingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
	WCHAR wchar,				/* (IN): preceding character */
	MWCLS mwcls,				/* (IN): ModWidth class of preceding character*/ 
	BOOL *pfExpand);			/* (OUT): (OUT): expand preceding character? */

/*
 *		Default implementation of LSIMETHOD for objects that do not
 *		allow expanding themselves.
 */
LSERR WINAPI ObjHelpFExpandWithFollowingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the following char */
	WCHAR wchar,				/* (IN): following character */
	MWCLS mwcls,				/* (IN): ModWidth class of following character*/ 
	BOOL *pfExpand);			/* (OUT): expand object? */

#endif /* !OBJHELP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\lstxtwrd.h ===
#ifndef LSTXTWRD_DEFINED
#define LSTXTWRD_DEFINED

#include "lsidefs.h"
#include "lsgrchnk.h"

void FullPositiveSpaceJustification(
		const LSGRCHNK*,				/* IN: Group chunk to justify   */
		long,							/* IN: itxtobjAfterStartSpaces  */
		long,							/* IN: iwchAfterStartSpaces     */
		long,						 	/* IN: itxtobjLast				*/
		long,							/* IN: iwchLast					*/
		long*, 							/* IN: rgdu						*/
 		long*,							/* IN: rgduGind					*/
		long,							/* IN: duToDistribute			*/
		BOOL*);							/* OUT: pfSpaceFound			*/

void NegativeSpaceJustification(
		const LSGRCHNK*,				/* IN: Group chunk to justify   */
		long,							/* IN: itxtobjAfterStartSpaces  */
		long,							/* IN: iwchAfterStartSpaces     */
		long,						 	/* IN: itxtobjLast				*/
		long,							/* IN: iwchLast					*/
		long*, 							/* IN: rgdu						*/
 		long*,							/* IN: rgduGind					*/
		long);							/* IN: duSqueeze				*/

#endif  /* !LSTXTWRD_DEFINED                           */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\plstbcon.h ===
#ifndef PLSTBCON_DEFINED
#define PLSTBCON_DEFINED

struct lstabscontext;
typedef struct lstabscontext* PLSTABSCONTEXT;

#endif /* PLSTBCON_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\plsiocon.h ===
#ifndef PLSIOCON_DEFINED
#define PLSIOCON_DEFINED

struct lsiobjcontext;
typedef struct lsiobjcontext* PLSIOBJCONTEXT;

#endif /* PLSIOCON_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\posinln.h ===
#ifndef POSINLN_DEFINED
#define POSINLN_DEFINED

#include "lsdefs.h"
#include "plssubl.h"
#include "plsdnode.h"

typedef struct posinline
{
	PLSSUBL plssubl;			/* subline where position is located */
	PLSDNODE plsdn;				/* dnode where position is located */
	POINTUV  pointStart;		/* pen position before this dnode */
	LSDCP 	 dcp;				/* dcp in the dnode 			  */
} POSINLINE;

#endif /* POSINLN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\qheap.h ===
#ifndef QHEAP_DEFINED
#define QHEAP_DEFINED

#include "lsidefs.h"
#include "pqheap.h"

PQHEAP CreateQuickHeap(PLSC, DWORD, DWORD, BOOL);
void DestroyQuickHeap(PQHEAP);
void* PvNewQuickProc(PQHEAP);
void DisposeQuickPvProc(PQHEAP, void*);
void FlushQuickHeap(PQHEAP);

#ifdef DEBUG
DWORD CbObjQuick(PQHEAP);
#endif


#define PvNewQuick(pqh, cb) \
		(Assert((cb) == CbObjQuick(pqh)), PvNewQuickProc(pqh))

#define DisposeQuickPv(pqh, pv, size) \
		(Assert(size == CbObjQuick(pqh)), DisposeQuickPvProc(pqh,pv))

#endif /* QHEAP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\port.h ===
#ifndef PORT_DEFINED
#define PORT_DEFINED

#include "lsdefs.h"

#ifndef BIG_ENDIAN
#define fPortTntiKern				0x0001
#define fPortTntiModWidthOnRun		0x0002
#define fPortTntiModWidthSpace		0x0004
#define fPortTntiModWidthPairs		0x0008
#define fPortTntiCompressOnRun		0x0010
#define fPortTntiCompressSpace		0x0020
#define fPortTntiCompressTable		0x0040
#define fPortTntiExpandOnRun		0x0080
#define fPortTntiExpandSpace		0x0100
#define fPortTntiExpandTable		0x0200
#define fPortTntiGlyphBased			0x0400
#else
#define fPortTntiKern				0x8000
#define fPortTntiModWidthOnRun		0x4000
#define fPortTntiModWidthSpace		0x2000
#define fPortTntiModWidthPairs		0x1000
#define fPortTntiCompressOnRun		0x0800
#define fPortTntiCompressSpace		0x0400
#define fPortTntiCompressTable		0x0200
#define fPortTntiExpandOnRun		0x0100
#define fPortTntiExpandSpace		0x0080
#define fPortTntiExpandTable		0x0040
#define fPortTntiGlyphBased			0x0020
#endif

#ifndef BIG_ENDIAN
#define fPortDisplayInvisible		0x0001
#define fPortDisplayUnderline		0x0002
#define fPortDisplayStrike			0x0004
#define fPortDisplayShade			0x0008
#define fPortDisplayBorder			0x0010
#define fPortDisplayHyphen			0x0020
#define fPortDisplayCheckForReplaceChar		0x0040
#else
#define fPortDisplayInvisible		0x8000
#define fPortDisplayUnderline		0x4000
#define fPortDisplayStrike			0x2000
#define fPortDisplayShade			0x1000
#define fPortDisplayBorder			0x0800
#define fPortDisplayHyphen			0x0400
#define fPortDisplayCheckForReplaceChar		0x0200
#endif


struct lschpint							/* Character properties */
{
	WORD idObj;							/* Object type */
	BYTE dcpMaxContext;

	BYTE EffectsFlags;

    /* Property flags */
	struct 
		{
		WORD Flags1;
		WORD Flags2;
		} cast;

	
	long dvpPos;  		/* for dvpPos values, */
						/*  pos => raised, neg => lowered, */
};

typedef struct lschpint LSCHPINT;



#define 		FIsTntiFlagsCastWorks(plschp) \
				((UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiKern) != 0) \
						== (plschp)->fApplyKern && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiModWidthOnRun) != 0) \
						== (plschp)->fModWidthOnRun && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiModWidthSpace) != 0) \
						== (plschp)->fModWidthSpace && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiModWidthPairs) != 0) \
						== (plschp)->fModWidthPairs && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiCompressOnRun) != 0) \
						== (plschp)->fCompressOnRun && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiCompressSpace) != 0) \
						== (plschp)->fCompressSpace && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiCompressTable) != 0) \
						== (plschp)->fCompressTable && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiExpandOnRun) != 0) \
						== (plschp)->fExpandOnRun && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiExpandSpace) != 0) \
						== (plschp)->fExpandSpace && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiExpandTable) != 0) \
						== (plschp)->fExpandTable  && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags1) &  fPortTntiGlyphBased) != 0) \
						== (plschp)->fGlyphBased  \
				)

#define   		AddNominalToIdealFlags(storage, plschp)  \
				Assert(FIsTntiFlagsCastWorks(plschp)); \
				(storage) |= \
				((LSCHPINT*) (plschp))->cast.Flags1  ;

#define 		GetNominalToIdealFlagsFromLschp(plschp) \
				( Assert(FIsTntiFlagsCastWorks(plschp)), \
				  (((LSCHPINT*) (plschp))->cast.Flags1) \
				)  


#define 		FIsDisplayFlagsCastWorks(plschp) \
				((UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayInvisible) != 0) \
						== (plschp)->fInvisible && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayUnderline) != 0) \
						== (plschp)->fUnderline && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayStrike) != 0) \
						== (plschp)->fStrike && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayShade) != 0) \
						== (plschp)->fShade && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayBorder) != 0) \
						== (plschp)->fBorder && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayHyphen) != 0) \
						== (plschp)->fHyphen && \
				 (UINT)(((((LSCHPINT*) (plschp))->cast.Flags2) &  fPortDisplayCheckForReplaceChar) != 0) \
						== (plschp)->fCheckForReplaceChar  \
				)

				
#define   		AddDisplayFlags(storage, plschp)  \
				Assert(FIsDisplayFlagsCastWorks((plschp)));   \
				(storage) |= \
				((LSCHPINT*) (plschp))->cast.Flags2  ;


#endif /* CHNUTILS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\pqheap.h ===
#ifndef PQHEAP_DEFINED
#define PQHEAP_DEFINED

typedef struct qheap* PQHEAP;

#endif /* PQHEAP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\setfmtst.h ===
#ifndef SETFMTST_DEFINED
#define SETFMTST_DEFINED

#include "zqfromza.h"
#include "lsdefs.h"


/* M A X */
/*----------------------------------------------------------------------------
    %%Macro: Max
    %%Contact: igorzv

	Returns the maximum of two values a and b.
----------------------------------------------------------------------------*/
#define Max(a,b)			((a) < (b) ? (b) : (a))



#define SetDnodeToFinish(plsc, plsdn)	((plsc)->lslistcontext.plsdnToFinish = plsdn)

#define SetCurrentSubline(plsc, plssubl)	((plsc)->lslistcontext.plssublCurrent = plssubl)

#define AdvanceCurrentCpLimSubl(plssubl, dcp)  ((plssubl)->cpLim += dcp)
#define AdvanceCurrentCpLim(plsc, dcp)			AdvanceCurrentCpLimSubl(GetCurrentSubline(plsc), dcp)

#define SetCurrentCpLimSubl(plssubl, cp)  ((plssubl)->cpLim = cp)
#define SetCurrentCpLim(plsc, cp)			SetCurrentCpLimSubl(GetCurrentSubline(plsc), cp)

#define SetCurrentUrSubl(plssubl, ur)		((plssubl)->urCur = ur)
#define SetCurrentUr(plsc, ur)			SetCurrentUrSubl(GetCurrentSubline(plsc), ur)

#define SetCurrentVrSubl(plssubl, vr)		((plssubl)->vrCur = vr)
#define SetCurrentVr(plsc, vr)			SetCurrentVrSubl(GetCurrentSubline(plsc), vr)

#define AdvanceCurrentUrSubl(plssubl, dur)		if ((plssubl)->urCur >= uLsInfiniteRM - dur) \
													return lserrTooLongParagraph; \
												((plssubl)->urCur += dur);
#define AdvanceCurrentUr(plsc, dur)			AdvanceCurrentUrSubl(GetCurrentSubline(plsc), dur)

#define AdvanceCurrentVrSubl(plssubl, dvr)		if ((plssubl)->vrCur >= uLsInfiniteRM - dvr) \
													return lserrTooLongParagraph; \
												((plssubl)->vrCur += dvr);

#define AdvanceCurrentVr(plsc, dvr)			AdvanceCurrentVrSubl(GetCurrentSubline(plsc), dvr)

#define SetCurrentDnodeSubl(plssubl, plsdn)	((plssubl)->plsdnLast = (plsdn)); \
											if ((plsdn) == NULL) ((plssubl)->plsdnFirst = NULL);
#define SetCurrentDnode(plsc, plsdn)			SetCurrentDnodeSubl(GetCurrentSubline(plsc), plsdn)

#define SetBreakthroughLine(plsc, urRightMargin)    \
				(plsc)->plslineCur->lslinfo.fTabInMarginExLine = fTrue; \
				(plsc)->lsadjustcontext.urRightMarginJustify = \
				(plsc)->urRightMarginBreak == 0 ?  \
						(plsc)->lsadjustcontext.urRightMarginJustify + (urRightMargin) \
						: \
							((plsc)->lsadjustcontext.urRightMarginJustify / \
									(plsc)->urRightMarginBreak )\
							* (urRightMargin); \
				(plsc)->urRightMarginBreak = (urRightMargin); \
				(plsc)->plslineCur->lssubl.urColumnMax = (urRightMargin); \

#define IncreaseFormatDepth(plsc)  ((plsc)->lslistcontext.nDepthFormatLineCurrent++, \
									(plsc)->plslineCur->lslinfo.nDepthFormatLineMax = \
										Max((plsc)->lslistcontext.nDepthFormatLineCurrent, \
											(plsc)->plslineCur->lslinfo.nDepthFormatLineMax))

#define DecreaseFormatDepth(plsc)  ((plsc)->lslistcontext.nDepthFormatLineCurrent--)

#define SetCpLimDisplaySubl(plssubl, cp)	((plssubl)->cpLimDisplay = cp)
#define SetCpLimDisplay(plsc, cp)	SetCpLimDisplaySubl(GetCurrentSubline(plsc), cp)

#define SetLastDnodeDisplaySubl(plssubl, plsdn)	((plssubl)->plsdnLastDisplay = plsdn)
#define SetLastDnodeDisplay(plsc, plsdn)		SetLastDnodeDisplaySubl(GetCurrentSubline(plsc), plsdn)

#endif /* SETFMTST_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\prepdisp.h ===
#ifndef PREPDISP_DEFINED
#define PREPDISP_DEFINED

#include "lsidefs.h"
#include "plsline.h"
#include "plssubl.h"
#include "lskjust.h"

LSERR PrepareLineForDisplayProc(PLSLINE);

LSERR MatchPresSubline(PLSSUBL);		/* IN: subline context		*/

LSERR AdjustSubline(PLSSUBL,			/* IN: subline context		*/
						LSKJUST,		/* IN: justification type	*/
						long,			/* IN: dup desired			*/
						BOOL);			/* IN: fTrue - compress, fFalse - expand */
						

#endif /* PREPDISP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\stopres.h ===
#ifndef STOPRES_DEFINED
#define STOPRES_DEFINED


enum stopres
{
	stoprEndPara,						/* reached defined para end (from LSPAP) */
	stoprAltEndPara,					/* reached defined alt para end (LSPAP) */
	stoprSoftCR,						/* reached Soft CR (from LSTXTCFG) */
	stoprEndColumn,						/* reached end column character */
	stoprEndSection,					/* reached end section character */
	stoprEndPage,						/* reached end page character */
};

typedef enum stopres STOPRES;

#endif /* !FMTRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\sublutil.h ===
#ifndef SUBLUTIL_DEFINED
#define SUBLUTIL_DEFINED

#include "lsdefs.h"
#include "plssubl.h"
#include "plsrun.h"
#include "pobjdim.h"
#include "plsiocon.h"
#include "lscbk.h"
#include "pqheap.h"

/* ROUTINES ------------------------------------------------------------------------------*/

LSERR	DestroySublineCore(PLSSUBL plssubl,LSCBK* plscbk, POLS pols,
						   PLSIOBJCONTEXT plsiobjcontext, BOOL fDontReleaseRuns);

LSERR	GetObjDimSublineCore(
							 PLSSUBL plssubl,			/* IN: subline			*/
							 POBJDIM pobjdim);			/* OUT: dimension of subline */

LSERR  GetDupSublineCore(
							PLSSUBL plssubl,			/* IN: Subline Context			*/
					 	    long* pdup);				/* OUT: dup of subline			*/


LSERR   GetSpecialEffectsSublineCore(
									 PLSSUBL plssubl,	/* IN: subline			*/
									 PLSIOBJCONTEXT plsiobjcontext, /* objects methods */
									 UINT* pEffectsFlags);	/* OUT: special effects */

BOOL   FAreTabsPensInSubline(
						   PLSSUBL plssubl);				/* IN: subline */

LSERR	GetPlsrunFromSublineCore(
							    PLSSUBL	plssubl,		/* IN: subline */
								DWORD   crgPlsrun,		/* IN: size of array */
								PLSRUN* rgPlsrun);		/* OUT: array of plsruns */

LSERR	GetNumberDnodesCore(
							PLSSUBL	plssubl,	/* IN: subline */
							DWORD* cDnodes);	/* OUT: numberof dnodes in subline */


							
LSERR 	GetVisibleDcpInSublineCore(
								   PLSSUBL plssubl,	 /* IN: subline						*/
								   LSDCP*  pndcp);	 /* OUT:amount of visible characters in subline */

LSERR 	FIsSublineEmpty(
						PLSSUBL plssubl,		/* IN: subline						*/
						 BOOL*  pfEmpty);		/* OUT:is this subline empty */

LSERR GetDurTrailInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							long*);				/* OUT: width of trailing area
																 in subline		*/

LSERR GetDurTrailWithPensInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							long*);				/* OUT: width of trailing area
																 in subline		*/

#endif /* SUBLUTIL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\txtconst.h ===
#ifndef TXTCONST_DEFINED
#define TXTCONST_DEFINED

#define txtobjMaxM 10

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\sobjhelp.h ===
#ifndef SOBJHELP_DEFINED
#define SOBJHELP_DEFINED

/*
 *	sobjhelp.h
 *
 *	This file contains interface that help simple objects (objects
 *	which don't break internally) handle breaking and queries. All objects
 *	that use these routines must as the first entry in their dobj
 *	structure define an SObjCommon entry which these routines 
 *	will cast dobj's to. Current users of this interface are
 *	HIH, Ruby and Tatenakayoko.
 *
 */

typedef struct SOBJHELP
{
	OBJDIM		objdimAll;		/* dimensions of object */
	LSDCP		dcp;			/* characters contained in objects */
	long		durModAfter;	/* Mod width after - need if we break to remove
								   the character following we naturally have to
								   remove the space modification it caused. */
} SOBJHELP, *PSOBJHELP;

LSERR WINAPI SobjTruncateChunk(
	PCLOCCHNK plocchnk,			/* (IN): locchnk to truncate */
	PPOSICHNK posichnk);		/* (OUT): truncation point */

LSERR WINAPI SobjFindPrevBreakChunk(
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
	BRKCOND brkcond,			/* (IN): recommmendation about the break after chunk */
	PBRKOUT pbrkout);			/* (OUT): results of breaking */

LSERR WINAPI SobjFindNextBreakChunk(
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
	BRKCOND brkcond,			/* (IN): recommmendation about the break before chunk */
	PBRKOUT pbrkout);			/* (OUT): results of breaking */

LSERR WINAPI SobjForceBreakChunk(
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcposichnk,		/* (IN): place to start looking for break */
	PBRKOUT pbrkout);			/* (OUT): results of breaking */

#endif /* SOBJHELP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\textenum.h ===
#ifndef TEXTENUM_DEFINED
#define TEXTENUM_DEFINED

#include "lsidefs.h"
#include "plsrun.h"
#include "pdobj.h"

LSERR WINAPI EnumObjText(PDOBJ, PLSRUN, PCLSCHP, LSCP, LSDCP, LSTFLOW, BOOL,
												BOOL, const POINT*, PCHEIGHTS, long);
	/* Enum object
	 *  pdobj (IN): dobj to enumerate
	 *  plsrun (IN): from DNODE
	 *  plschp (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  dcp (IN): from DNODE
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryNeeded (IN):
	 *  pptStart (IN): starting position (top left), iff fGeometryNeeded
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryNeeded
	 *  dupRun(IN): from DNODE, relevant iff fGeometryNeeded
	*/


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\tlpr.h ===
#ifndef TLPR_DEFINED
#define TLPR_DEFINED

#include "lsdefs.h"
#include "lskeop.h"

#include "lstxtffi.h"

typedef struct tlpr						/* text line properties */
{
	DWORD grpfText;						/* text part of lsffi.h---fTxt flags */
	BOOL fSnapGrid;
	long duaHyphenationZone;			/* Hyphenation zone --- document property */
	LSKEOP lskeop;						/* Kind of para ending	*/
} TLPR;			

#endif /* !TLPR_DEFINED                          */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\tabutils.h ===
#ifndef TABUTILS_DEFINED
#define TABUTILS_DEFINED

#include "lsdefs.h"
#include "plstbcon.h"
#include "plsdnode.h"
#include "lsktab.h"
#include "plssubl.h"

#define SetCpInPara(lstabscontext, cp) \
						lstabscontext.cpInPara = (cp);
   

#define InitLineTabsContext(lstabscontext, ColumnMax, cp, ResolveTabsAsWord97)      \
						lstabscontext.fTabsInitialized = fFalse;\
						lstabscontext.urColumnMax = (ColumnMax);\
						lstabscontext.plsdnPendingTab = NULL;\
						lstabscontext.fResolveTabsAsWord97 = (ResolveTabsAsWord97);\
						SetCpInPara(lstabscontext, cp);


#define CancelPendingTab(plstabscontext) 		((plstabscontext)->plsdnPendingTab = NULL)


LSERR GetCurTabInfoCore(
							PLSTABSCONTEXT plstabscontext,	/* IN: Pointer to LS tabs context */
							PLSDNODE plsdnTab,				/* IN: plsdnTab		*/
							long urBeforeTab,				/* IN: position before this tab */
							BOOL fResolveAllTabsAsLeft,		/* IN: switch all other tab to left */
							LSKTAB* plsktab,				/* OUT: Type of current tab  */
							BOOL* pfBreakThroughTab);		/* OUT: fBreakThroughTab		*/						

LSERR ResolvePrevTabCore(
						PLSTABSCONTEXT plstabscontext,	/* IN: Pointer to LS tabs context */
						PLSDNODE plsdnCurrent,			/* IN: current dnode */
						long urCurrentPen,				/* IN: Current pen position */
						long* pdurPendingTab);			/* OUT: offset because of pending tab */

LSERR InitTabsContextForAutoDecimalTab(PLSTABSCONTEXT plstabscontext,	/* IN: Pointer to LS tabs context */
									  long durAutoDecimalTab);			/* IN: durAutoDecimalTab */

LSERR GetMarginAfterBreakThroughTab(PLSTABSCONTEXT plstabscontext,	/* IN: pointer to LS tabs context */
								   PLSDNODE plsdnTab,				/* IN: tab which triggered breakthrough tab */
								   long* purNewMargin);				/* OUT: new margin because of breakthrough tab */


#endif /* TABUTILS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\tnti.h ===
#ifndef TNTI_DEFINED
#define TNTI_DEFINED

#include "lsdefs.h"
#include "port.h"

#define fTntiKern				fPortTntiKern
#define fTntiModWidthOnRun		fPortTntiModWidthOnRun
#define fTntiModWidthSpace		fPortTntiModWidthSpace
#define fTntiModWidthPairs		fPortTntiModWidthPairs
#define fTntiCompressOnRun		fPortTntiCompressOnRun
#define fTntiCompressSpace		fPortTntiCompressSpace
#define fTntiCompressTable		fPortTntiCompressTable
#define fTntiExpandOnRun		fPortTntiExpandOnRun
#define fTntiExpandSpace		fPortTntiExpandSpace
#define fTntiExpandTable		fPortTntiExpandTable
#define fTntiGlyphBased			fPortTntiGlyphBased

#endif /* !TNTI_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\txtginf.h ===
#ifndef TXTGINF_DEFINED
#define TXTGINF_DEFINED

#include "lsidefs.h"

#define		ginffFirstInContext	1
#define		ginffLastInContext	2
#define		ginffOneToOne		4

typedef BYTE TXTGINF;

#endif /* !TXTGINF_DEFINED													*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\txtils.h ===
#ifndef TXTILS_DEFINED
#define TXTILS_DEFINED

#include "lsidefs.h"
#include "pilsobj.h"
#include "plsrun.h"
#include "plshyph.h"
#include "pheights.h"
#include "plsems.h"
#include "pdobj.h"
#include "lsdevres.h"
#include "lsdevice.h"
#include "lskeop.h"
#include "lstflow.h"
#include "lsact.h"
#include "lspract.h"
#include "lspairac.h"
#include "lsexpan.h"
#include "lsbrk.h"
#include "mwcls.h"
#include "brkcls.h"
#include "brkcond.h"
#include "brkkind.h"
#include "lsexpinf.h"
#include "txtln.h"
#include "txtobj.h"
#include "txtinf.h"
#include "txtginf.h"
#include "lscbk.h"

typedef	enum {
	brktNormal,
	brktHyphen,
	brktNonReq,
	brktOptBreak
} BRKT;

typedef struct
{
	PDOBJ pdobj;
	BRKKIND brkkind;
	LSDCP dcp;
	BRKT brkt;	
	union {
		struct {
			long durFix;
			long igindLim;
		} normal;
		struct {
			long iwchLim;
			long dwchYsr;
			long durHyphen;
			long dupHyphen;
			long durPrev;
			long dupPrev;
			long durPrevPrev;
			long dupPrevPrev;
			long ddurDnodePrev;
			WCHAR wchPrev;
			WCHAR wchPrevPrev;
			GINDEX gindHyphen;
			GINDEX gindPrev;
			GINDEX gindPrevPrev;
			GINDEX gindPad1;	/* makes number of gind's even */
			long igindHyphen;
			long igindPrev;
			long igindPrevPrev;
		} hyphen;
		struct {
			long iwchLim;
			long dwchYsr;
			long durHyphen;
			long dupHyphen;
			long durPrev;
			long dupPrev;
			long durPrevPrev;
			long dupPrevPrev;
			long ddurDnodePrev;
			long ddurDnodePrevPrev;
			long ddurTotal;
			WCHAR wchHyphenPres;
			WCHAR wchPrev;
			WCHAR wchPrevPrev;
			WCHAR wchPad1;	/* makes number of wch's even */
			GINDEX gindPrev;
			GINDEX gindPrevPrev;
			long igindPrev;
			long igindPrevPrev;
		} nonreq;
	} u;
} BREAKINFO;

#define clabRegular 0
#define clabSpace 1
#define clabTab 2
#define clabEOP1 3
#define clabEOP2 4
#define clabAltEOP 5
#define clabEndLineInPara 6
#define clabColumnBreak 7
#define clabSectionBreak 8
#define clabPageBreak 9
#define clabNonBreakSpace 10
#define clabNonBreakHyphen 11
#define clabNonReqHyphen 12
#define clabEmSpace 13
#define clabEnSpace 14
#define clabNull 15
#define clabHardHyphen 16
#define clabNarrowSpace 17
#define clabOptBreak 18
#define clabNonBreak 19
#define clabFESpace	20
#define clabJoiner	21
#define clabNonJoiner 22
#define clabToReplace 23
#define clabSuspicious 32

#define fSpecMask 0x1F

#define wchSpecMax  24

#define wchAddM 50
#define gindAddM 30
#define wSpacesMaxM 30

typedef BYTE CLABEL;

struct ilsobj
{
	PCLSCBK plscbk;				/* Callbacks								*/

	POLS pols;					/* Line Services owner's context			*/
	PLSC plsc;					/* LS's context								*/
	PLNOBJ plnobj;				/* Available lnobj							*/
	
	long wchMax;				/* size of char-based arrays				*/
	long wchMac;				/* last used index in char-based arrays		*/
	WCHAR* pwchOrig;			/* pointer to rgwchOrig (char-based)		*/
	long* pdur;					/* pointer to rgdur	(char-based)			*/
	long* pdurLeft;				/* pointer to rgdurLeft	(char-based)		*/
	long* pdurRight;			/* pointer to rgdurRight (char-based)		*/
	long* pduAdjust;			/* useful compression/expansion/kerning info
									(char-based)							*/
	TXTINF* ptxtinf;			/* pointer to rgtxtinf (char-based)			*/

	long wSpacesMax;			/* size of rgwSpaces array					*/
	long wSpacesMac;			/* last used index in rgwSpaces array		*/
	long* pwSpaces;				/* pointer to rgwSpaces						*/

	long gindMax;				/* size of glyph-based arrays				*/
	long gindMac;				/* last used index in glyph-based arrays	*/

	long* pdurGind;				/* pointer to rgdurGind array (glyph-based)	*/
	TXTGINF* pginf;				/* pointer to rgginf						*/
	
	long* pduGright;			/* pointer to rgduGright (glyph-based)		*/
	LSEXPINFO* plsexpinf;		/* useful glyph-expandion info (glyph-based)*/


	DWORD txtobjMac;			/* last used index in rgtxtobj array		*/
  
	BOOL fNotSimpleText;		/* Set at NTI time; used in AdjustText		*/ 
	BOOL fDifficultForAdjust;	/* Set at formatting time; used to decide if 
								 			QuickAdjustText possible		*/ 

	long iwchCompressFetchedFirst;/* index of the first char with known compr. */
	long itxtobjCompressFetchedLim;/* index of the lim chunk element with known compr. */
	long iwchCompressFetchedLim;/* index of the lim char with known compr. */

	long iwchFetchedWidth;		/* Fetched unused width starts here			*/	
	WCHAR wchFetchedWidthFirst;	/* Expected first char of run				*/
	WCHAR wchPad1;				/* Makes number of chars even				*/
	LSCP cpFirstFetchedWidth;	/* cp from which we expect next run to start */
	long dcpFetchedWidth;		/* N of chars with fetched width			 */
	long durFetchedWidth;		/* width of the piece						*/

	BOOL fTruncatedBefore;

	DWORD breakinfMax;
	DWORD breakinfMac;
	BREAKINFO* pbreakinf;

	long MagicConstantX;
	long durRightMaxX;
	long MagicConstantY;
	long durRightMaxY;

	BOOL fDisplay;				
	BOOL fPresEqualRef;			/* Modified due to Visi issues				*/
	LSDEVRES lsdevres;

	DWORD grpf;					/* flags from lsffi.h --- includes			*/
								/* fHyphenate and fWrapspaces				*/
	BOOL fSnapGrid;
	long duaHyphenationZone;

	LSKEOP lskeop;				/* Kind of line ending						*/

	WCHAR wchSpace;				/* space code								*/
	WCHAR wchHyphen;			/* hyphen code								*/
	WCHAR wchReplace;			/* replace char code						*/
	WCHAR wchNonBreakSpace;		/* non-break space char code				*/

	WCHAR wchVisiNull;			/* visi char for wch=0						*/
	WCHAR wchVisiEndPara;		/* visi char for end of paragraph			*/
	WCHAR wchVisiAltEndPara;	/* visi char for end of table cell			*/
	WCHAR wchVisiEndLineInPara;	/* visi char for wchEndLineInPara (CCRJ)	*/
	WCHAR wchVisiSpace;			/* visi space								*/
	WCHAR wchVisiNonBreakSpace;	/* visi NonBreakSpace						*/
	WCHAR wchVisiNonBreakHyphen;/* visi NonBreakHyphen						*/
	WCHAR wchVisiNonReqHyphen;	/* visi NonReqHyphen						*/
	WCHAR wchVisiTab;			/* visi Tab									*/
	WCHAR wchVisiEmSpace;		/* visi emSpace								*/
	WCHAR wchVisiEnSpace;		/* visi enSpace								*/
	WCHAR wchVisiNarrowSpace;	/* visi NarrowSpace							*/
	WCHAR wchVisiOptBreak;      /* visi char for wchOptBreak				*/
	WCHAR wchVisiNoBreak;		/* visi char for wchNoBreak					*/
	WCHAR wchVisiFESpace;		/* visi char for wchOptBreak				*/
	WCHAR wchPad2;				/* makes number of wch's even				*/

	DWORD cwchSpec;				/* number of special characters > 255		*/
	WCHAR rgwchSpec[wchSpecMax];/* array of special characters  > 255		*/
	CLABEL rgbKind[wchSpecMax];	/* array of meanings of Spec characters>255	*/
	CLABEL rgbSwitch[256];		/* switch table with Special Characters		*/

	DWORD cModWidthClasses;		/* number of ModWidth classes				*/
	DWORD cCompPrior;			/* number of compression priorities			*/

	DWORD clspairact;			/* number of mod pairs info units			*/
	LSPAIRACT* plspairact;		/* pointer to rglspairact(ModPair info unts)*/
	BYTE* pilspairact;			/* rgilspairact(ModPair info---square)		*/

	DWORD clspract;				/* number of compression info units			*/
	LSPRACT* plspract;			/* pointer to rglspract(compress info units)*/
	BYTE* pilspract;			/* rgilspract(comp info---linear)			*/

	DWORD clsexpan;				/* number of expansion info units			*/
	LSEXPAN* plsexpan;			/* pointer to rglsexpan(expan info units)	*/
	BYTE* pilsexpan;			/* rgilsexpan(expan info---square)			*/

	DWORD cBreakingClasses;		/* number of ModWidth classes				*/
	DWORD clsbrk;				/* number of breaking info units			*/
	LSBRK* plsbrk;				/* pointer to rglsbrk(breaking info units)	*/
	BYTE* pilsbrk;				/* rgilsbrk(breaking info---square)			*/
};


#endif /* !TXTILS_DEFINED													*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\txtln.h ===
#ifndef TXTLN_DEFINED
#define TXTLN_DEFINED

#include "lsidefs.h"
#include "plnobj.h"
#include "pilsobj.h"
#include "txtobj.h"
#include "txtginf.h"
#include "gmap.h"
#include "gprop.h"
#include "exptype.h"


struct lnobj
{
	PILSOBJ pilsobj;			/* pointer to txtils						*/
	long wchMax;				/* size of char-based arrays				*/
	TXTOBJ* ptxtobj;			/* pointer to current rgtxtobj array		*/
	TXTOBJ* ptxtobjFirst;		/* pointer to the first rgtxtobj array		*/
	WCHAR* pwch;				/* pointer to rgwch	(char-based)			*/
	long* pdup;					/* pointer to rgdup (char-based)			*/
	long* pdupPenAlloc;			/* pointer to rgdupPen after
								   allocation (char-based)					*/
	long* pdupPen;				/* pointer to rgdupPen 
									 equals pdup or pdupPenAlloc			*/

	long gindMax;				/* size of glyph-based arrays				*/
	GINDEX* pgind;				/* pointer to rggind (glyph-based)			*/
	long* pdupGind;				/* pointer to rgdup (glyph-based)			*/
	GOFFSET* pgoffs;			/* pointer to rggoffs						*/
	long* pdupBeforeJust;		/* pointer to rgdupBeforeJust (glyph-based)	*/
	GMAP* pgmap;				/* pointer to rggmap array (char-based)		*/
	GPROP* pgprop;				/* pointer to rggprop						*/
	EXPTYPE* pexpt;				/* pointer to rgexpt						*/

	PTXTOBJ pdobjHyphen;		/* in case hyphenation took place---
									dobj of YSR char, otehrwise---NULL		*/
	DWORD dwchYsr;				/* length (in iwch) of the Ysr sequence
									including hyphen sign					*/
	BOOL fDrawInCharCodes;		/* Output in metafile---no glyphs, please	*/
};

#endif /* !TXTLN_DEFINED									*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\txtinf.h ===
#ifndef TXTINF_DEFINED
#define TXTINF_DEFINED

#include "lsidefs.h"

struct txtinf
{
	UINT mwcls : 7;

	UINT fModWidthOnRun : 1;
	UINT fModWidthSpace : 1;
	UINT fHangingPunct : 1;
	UINT fFirstInContext : 1;
	UINT fLastInContext : 1;
	UINT fOneToOne : 1;
		
	UINT prior : 3;
	UINT side : 2;
	UINT fExpand : 1;
};

typedef struct txtinf TXTINF;

#endif /* !TXTINF_DEFINED													*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\brkcls.h ===
#ifndef BRKCLS_DEFINED
#define BRKCLS_DEFINED

#include "lsdefs.h"

typedef DWORD BRKCLS;

#endif /* !BRKCLS_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\breakrec.h ===
#ifndef BREAKREC_DEFINED
#define BREAKREC_DEFINED

#include "lsdefs.h"

/* ---------------------------------------------------------------------- */

struct breakrec
{
	DWORD idobj;
	LSCP cpFirst;
};

typedef struct breakrec BREAKREC;

#endif /* !BREAKREC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\brkkind.h ===
#ifndef BRKKIND_DEFINED
#define BRKKIND_DEFINED

#include "lsdefs.h"

typedef enum
{
	brkkindImposedAfter,
	brkkindPrev,
	brkkindNext,
	brkkindForce

} BRKKIND;


#endif /* !BRKKIND_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\inci\txtobj.h ===
#ifndef TXTOBJ_DEFINED
#define TXTOBJ_DEFINED

#include "lsidefs.h"
#include "plsdnode.h"
#include "plnobj.h"

#define txtkindRegular 0
#define txtkindHardHyphen 1
#define txtkindTab 2
#define txtkindNonReqHyphen 3
#define txtkindYsrChar 4
#define txtkindNonBreakSpace 5			/* Used in decimal tab logic		*/
#define txtkindNonBreakHyphen 6
#define txtkindOptNonBreak 7
#define txtkindSpecSpace 8
#define txtkindOptBreak 9
#define txtkindEOL 10

#define txtfMonospaced 		1
#define txtfVisi			2
#define txtfModWidthClassed	4
#define txtfGlyphBased		8
#define txtfSkipAtNti		16
#define txtfSkipAtWysi		32
#define txtfFirstShaping	64
#define txtfLastShaping		128


struct txtobj
{
	PLSDNODE plsdnUpNode;		/* upper DNode								*/
	PLNOBJ plnobj;

	long iwchFirst; 			/* index of the first char of dobj in rgwch */
	long iwchLim;				/* index of the lim char of dobj in rgwch	*/

	WORD txtkind;
	WORD txtf;

	union
	{
		struct
		{
			long iwSpacesFirst;	/* index of the first Space-index in wSpaces*/
			long iwSpacesLim;	/* index of the lim  Space-index in wSpaces	*/
		} reg;

		struct
		{	  
			WCHAR wch;			/* char code for Tab or Visi Tab			*/
			WCHAR wchTabLeader;	/* leaders info								*/
		} tab;					/* use this for the txtkindTab				*/

	} u;
 
	long igindFirst; 			/* index of the first glyph of dobj in rgwch*/
	long igindLim;				/* index of the lim glyph of dobj in rgwch	*/

	long dupBefore;
};

typedef struct txtobj TXTOBJ;
typedef TXTOBJ* PTXTOBJ;

#endif /* !TXTOBJ_DEFINED													*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\brkcond.h ===
#ifndef BRKCOND_DEFINED
#define BRKCOND_DEFINED

#include "lsdefs.h"

typedef enum
{
	brkcondPlease,
	brkcondCan,
	brkcondNever
} BRKCOND;


#endif /* !BRKCOND_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\dispi.h ===
#ifndef DISPI_DEFINED
#define DISPI_DEFINED

#include "lsdefs.h"
#include "pdispi.h"
#include "plsrun.h"
#include "plschp.h"
#include "heights.h"
#include "lstflow.h"

typedef struct dispin
{
	POINT 	ptPen;					/* starting pen position (x,y) */
	PCLSCHP plschp;					/* CHP for this display object */
	PLSRUN 	plsrun;					/* client pointer to run */

	UINT 	kDispMode;				/* display mode, opaque, etc */
	LSTFLOW lstflow;	 			/* text direction and orientation */
	RECT* 	prcClip;				/* clip rectangle (x,y) */

	BOOL 	fDrawUnderline;			/* Draw underline while displaying */
	BOOL 	fDrawStrikethrough;		/* Draw strikethrough while Displaying */

	HEIGHTS heightsPres;
	long 	dup;
	long	dupLimUnderline;		/* less than dup if trailing spaces */
} DISPIN;	

#endif /* !DISPI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\brko.h ===
#ifndef BRKO_DEFINED
#define BRKO_DEFINED

#include "lsdefs.h"
#include "pbrko.h"
#include "objdim.h"
#include "posichnk.h"
#include "brkcond.h"

typedef struct brkout						/* break output */ 
{
	BOOL fSuccessful;						/* break result */
	BRKCOND brkcond;						/* iff !fSuccessful, recommendation on the other side */
	POSICHNK posichnk;
	OBJDIM objdim;
} BRKOUT;


#endif /* !BRKO_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\endres.h ===
#ifndef ENDRES_DEFINED
#define ENDRES_DEFINED

enum endres
{
	endrNormal,
	endrHyphenated,
	endrEndPara,
	endrAltEndPara,
	endrSoftCR,
	endrEndColumn,
	endrEndSection,
	endrEndPage,
	endrEndParaSection,
	endrStopped
};

typedef enum endres ENDRES;

#endif /* ENDRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\exptype.h ===
#ifndef EXPTYPE_DEFINED
#define EXPTYPE_DEFINED

#include "lsdefs.h"

typedef BYTE EXPTYPE;

/* kinds of glyph expansion */
#define	exptNone  0
#define	exptAddWhiteSpace 1
#define	exptAddInkContinuous 2
#define	exptAddInkDiscrete 3

typedef EXPTYPE* PEXPTYPE;
typedef const EXPTYPE* PCEXPTYPE;


#endif /* !EXPTYPE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\brkpos.h ===
#ifndef BRKPOS_DEFINED
#define BRKPOS_DEFINED

#include "lsdefs.h"

typedef enum
{
	brkposBeforeFirstDnode,
	brkposInside,
	brkposAfterLastDnode

} BRKPOS;


#endif /* !BRKPOS_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\gmap.h ===
#ifndef GMAP_DEFINED
#define GMAP_DEFINED

#include "lsdefs.h"

typedef WORD GMAP;
typedef GMAP* PGMAP;
typedef const GMAP* PCGMAP;

#endif /* !GMAP_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\fmti.h ===
#ifndef FMTIO_DEFINED
#define FMTIO_DEFINED

#include "lsdefs.h"
#include "pfmti.h"
#include "plsdnode.h"
#include "lsfgi.h"
#include "lsfrun.h"
#include "lstxm.h"

/* ------------------------------------------------------------------------ */

struct fmtin
{
	LSFGI lsfgi;
	LSFRUN lsfrun;
	PLSDNODE plsdnTop;
	LSTXM lstxmPres;
	LSTXM lstxmRef;
};

/* ------------------------------------------------------------------------ */


#endif /* !FMTIO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\fmtres.h ===
#ifndef FMTRES_DEFINED
#define FMTRES_DEFINED

/* used in fmtio.h and lsfd.h */

enum fmtres							/* Why did the formatter return? */
{
	fmtrCompletedRun,				/* no problems */
	fmtrExceededMargin,				/* reached right margin */
	fmtrTab,						/* reached tab				  */
	fmtrStopped						
};

typedef enum fmtres FMTRES;

#endif /* !FMTRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\locchnk.h ===
#ifndef LOCCHNK_DEFINED
#define LOCCHNK_DEFINED

#include "lsdefs.h"
#include "lsfgi.h"
#include "lschnke.h"

typedef struct locchnk					/* located chnk					*/
{
	LSFGI lsfgi;						/* location of chunk			*/
	DWORD clschnk;						/* number of dobj's in chunk	*/
	PLSCHNK plschnk;					/* chunk 						*/
	PPOINTUV ppointUvLoc;				/* location of each chunk's node*/
} LOCCHNK;



#endif /* !LOCCHNK_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\kamount.h ===
#ifndef KAMOUNT_DEFINED
#define KAMOUNT_DEFINED

#include "lsdefs.h"
/* Interpretation for kamnBy... is as follows:
	Compression			-
	Expansion			+
	PunctStartLine   	-
	ModWidthPairs		-
	ModWidthSpace		+
	ModWidthOnRun		+
*/


typedef BYTE KAMOUNT;

#define kamntNone				0
#define kamntToHalfEm			1
#define kamntToQuarterEm		2
#define kamntToThirdEm			3
#define kamntTo15Sixteenth		4
#define kamntByHalfEm			5
#define kamntByQuarterEm		6
#define kamntByEighthEm			7
#define kamntByUserDefinedExpan	8	
#define kamntByUserDefinedComp	9	
#define kamntToUserDefinedExpan	10	
#define kamntToUserDefinedComp	11	


#endif /* !KAMOUNT_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\hih.h ===
#ifndef HIH_DEFINED
#define HIH_DEFINED

#include "lsimeth.h"

/*
 *	H(orizontal)I(n)H(orizontal)
 *
 *	This object is designed to help client implementations which use 
 *	Tatenakayoko and wish to be able to convert the display from vertical
 *	to horizontal and then to display the Tatenakayoko text as horizontal.
 *	To do this the client application simply changes the object handler
 *	from the Tatenakayoko handler to this object handler and the text
 *	will be displayed horizontally.
 *	
 */

/* typedef for callback to client for enumeration */
typedef LSERR(WINAPI * PFNHIHENUM)(
	POLS pols,				/*(IN): client context */
	PLSRUN plsrun,			/*(IN): from DNODE */
	PCLSCHP plschp,			/*(IN): from DNODE */
	LSCP cp,				/*(IN): from DNODE */
	LSDCP dcp,				/*(IN): from DNODE */
	LSTFLOW lstflow,		/*(IN): text flow*/
	BOOL fReverse,			/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,	/*(IN): */
	const POINT* pt,		/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,	/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun,			/*(IN): from DNODE, relevant iff fGeometryNeeded*/
	PLSSUBL plssubl);		/*(IN): subline in hih object. */

/*
 *
 *	HIH object initialization data that the client application must return
 *	when the HIH object handler calls the GetObjectHandlerInfo callback.
 */

#define HIH_VERSION 0x300

typedef struct HIHINIT
{
	DWORD				dwVersion;		/* Version. Must be HIH_VERSION */
	WCHAR				wchEndHih;		/* Escape for end of HIH object */
	WCHAR				wchUnused1;
	WCHAR				wchUnused2;
	WCHAR				wchUnused3;
	PFNHIHENUM			pfnEnum;		/* Enumeration callback */
} HIHINIT, *PHIHINIT;

LSERR WINAPI LsGetHihLsimethods(
	LSIMETHODS *plsim);

/* GetHihLsimethods
 *	
 *	plsim (OUT): Hih object methods for Line Services
 *
 */

#endif /* HIH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\gprop.h ===
#ifndef GPROP_DEFINED
#define GPROP_DEFINED

#include "lsdefs.h"

typedef WORD GPROP;
typedef GPROP* PGPROP;
typedef const GPROP* PCGPROP;

#endif /* !GPROPS_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\heights.h ===
#ifndef HEIGHTS_DEFINED
#define HEIGHTS_DEFINED

#include "lsdefs.h"
#include "pheights.h"

#define dvHeightIgnore 0x7FFFFFFF

typedef struct heights
{
	long dvAscent;
	long dvDescent;
	long dvMultiLineHeight;
} HEIGHTS;

#endif /* !HEIGHTS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsact.h ===
#ifndef LSACT_DEFINED
#define LSACT_DEFINED

#include "lsdefs.h"
#include "kamount.h"

#define sideNone				0		/* means no action				*/
#define sideLeft				1
#define sideRight				2
#define sideLeftRight			3		/* Review(segeyge): how to distribute?*/

typedef struct lsact					/* action							*/
{
	BYTE side;							/* side of action (left/right/both)	*/
	KAMOUNT kamnt;						/* amount of action					*/
} LSACT;


#endif /* !LSACT_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lscell.h ===
#ifndef LSCELL_DEFINED
#define LSCELL_DEFINED

#include "lsdefs.h"
#include "plscell.h"
#include "pcelldet.h"
#include "plscell.h"

struct lstextcell
{
	LSCP cpStartCell;
	LSCP cpEndCell;
 	POINTUV pointUvStartCell;		/* In coordinate system of main line/subline */
	long dupCell;					/* In direction lstflowSubline			*/

	DWORD cCharsInCell;
	DWORD cGlyphsInCell;

	PCELLDETAILS pCellDetails;

};

typedef struct lstextcell LSTEXTCELL;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsbrjust.h ===
#ifndef LSBRJUST_DEFINED
#define LSBRJUST_DEFINED

enum lsbreakjust							/* kinds of breaking/justification */
{
	lsbrjBreakJustify,						/* Regular US */
	lsbrjBreakWithCompJustify,				/* FE & Newspaper */
	lsbrjBreakThenExpand,					/* Arabic			 */
	lsbrjBreakThenSqueeze					/* Word Perfect			 */
};

typedef enum lsbreakjust LSBREAKJUST;

#endif /* !LSBRJUST_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsbrk.h ===
#ifndef LSBRK_DEFINED
#define LSBRK_DEFINED

#include "lsdefs.h"

typedef struct lsbrk					/* breaking information unit		*/
{
	BYTE fBreak;						/* break for neibours	*/
	BYTE fBreakAcrossSpaces;			/* break across spaces	*/
} LSBRK;									


#endif /* !LSBRK_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lschnke.h ===
#ifndef LSCHNKE_DEFINED
#define LSCHNKE_DEFINED

#include "lsdefs.h"
#include "plschp.h"
#include "plsrun.h"
#include "pdobj.h"

typedef struct lschnke
{
	LSCP cpFirst;
	LSDCP dcp;
	PCLSCHP plschp;
	PLSRUN plsrun;
	PDOBJ pdobj;
} LSCHNKE;

typedef LSCHNKE* PLSCHNK;
typedef const LSCHNKE* PCLSCHNK;

#endif  /* !LSCHNKE_DEFINED   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lscontxt.h ===
#ifndef LSCONTXT_DEFINED
#define LSCONTXT_DEFINED

#include "lsdefs.h"
#include "lscbk.h"
#include "lstxtcfg.h"
#include "lsimeth.h"


typedef struct 
{
	DWORD version;						/* version number	*/
	DWORD cInstalledHandlers;
	const LSIMETHODS* pInstalledHandlers; /* Installed handlers */
	LSTXTCFG lstxtcfg;					/* Straight-text configuration data */
	POLS pols;							/* Client data for this context */
	LSCBK lscbk;						/* LineServices client callbacks */
	BOOL fDontReleaseRuns;				/* Optimization---don't call pfnReleaseRun */
} LSCONTEXTINFO;


LSERR WINAPI LsCreateContext(const LSCONTEXTINFO*, PLSC*);
LSERR WINAPI LsDestroyContext(PLSC);

#endif /* LSCONTXT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lschp.h ===
#ifndef LSCHP_DEFINED
#define LSCHP_DEFINED

#include "lsdefs.h"
#include "plschp.h"

#define idObjTextChp	((WORD)~0)		/* idObj for FetchRun to use  */
										/*  when returning a text run */
										/*  (Internal id will differ.) */

/* LS expects that for GlyphBased runs the following flags are set to FALSE:
			fApplyKern
			fModWidthSpace
			fModWidthPairs
			fCompressTable
*/

struct lschp							/* Character properties */
{
	WORD idObj;							/* Object type */
	BYTE dcpMaxContext;

	BYTE EffectsFlags;

    /* Property flags */
	UINT fApplyKern : 1;
	UINT fModWidthOnRun:1;
	UINT fModWidthSpace:1;
	UINT fModWidthPairs:1;
	UINT fCompressOnRun:1;
	UINT fCompressSpace:1;
	UINT fCompressTable:1;
	UINT fExpandOnRun:1;
	UINT fExpandSpace:1;
	UINT fExpandTable:1;
	UINT fGlyphBased : 1;

	UINT pad1:5;

	UINT fInvisible : 1;
	UINT fUnderline : 1;				
	UINT fStrike : 1;
	UINT fShade : 1;				
	UINT fBorder : 1;				
	UINT fHyphen : 1;					/* Hyphenation opportunity (YSR info) */
	UINT fCheckForReplaceChar : 1;		/* Activate the replace char mechanizm for Yen	*/

	UINT pad2:9;
										/* for dvpPos values, */
										/*  pos => raised, neg => lowered, */
	long dvpPos;
};

typedef struct lschp LSCHP;

#endif /* !LSCHP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lscbk.h ===
#ifndef LSCBK_DEFINED
#define LSCBK_DEFINED

/* LineServices callbacks */

#include "lsdefs.h"
#include "lsdevice.h"
#include "lsksplat.h"
#include "lskjust.h"
#include "lstflow.h"
#include "endres.h"
#include "mwcls.h"
#include "lsact.h"
#include "lspract.h"
#include "brkcond.h"
#include "brkcls.h"
#include "gprop.h"
#include "gmap.h"
#include "lsexpinf.h"
#include "lskalign.h"
#include "plstabs.h"
#include "pheights.h"
#include "plsrun.h"
#include "plscbk.h"
#include "plschp.h"
#include "plspap.h"
#include "plstxm.h"
#include "plshyph.h"
#include "plsstinf.h"
#include "plsulinf.h"
#include "plsems.h"

#define cpFirstAnm (-0x7FFFFFFF)   /* Used for the fetch of the first Autonumber run */


struct lscbk	/* Interfaces to application-specific callbacks */
{
	/* Dynamic memory APIs */
	void* (WINAPI* pfnNewPtr)(POLS, DWORD);
	void  (WINAPI* pfnDisposePtr)(POLS, void*);
	void* (WINAPI* pfnReallocPtr)(POLS, void*, DWORD);


	LSERR (WINAPI* pfnFetchRun)(POLS, LSCP,
							    LPCWSTR*, DWORD*, BOOL*, PLSCHP, PLSRUN*);
	/* FetchRun:
	 *  pols (IN):
	 *  cp (IN):
	 *  &lpwchRun (OUT): run of characters.
	 *  &cchRun (OUT): number of characters in run
	 *  &fHidden (OUT) : hidden run?
	 *  &lsChp (OUT): char properties of run 
	 *  &plsrun (OUT): abstract representation of run properties
	 */

	LSERR (WINAPI* pfnGetAutoNumberInfo)(POLS, LSKALIGN*, PLSCHP, PLSRUN*, WCHAR*, PLSCHP, PLSRUN*, BOOL*, long*, long*);

	/* GetAutoNumberInfo:
	 *  pols (IN):
	 *  &lskalAnm (OUT):
	 *  &lschpAnm (OUT): lschp for Anm
	 *  &plsrunAnm (OUT): plsrun for Anm
	 *  &wchAdd (OUT): character to add (Nil is treated as none)
	 *  &lschpWch (OUT): lschp for added char
	 *  &plsrunWch (OUT): plsrun for added char
	 *  &fWord95Model(OUT):
	 *  &duaSpaceAnm(OUT):	relevant iff fWord95Model
	 *  &duaWidthAnm(OUT):	relevant iff fWord95Model
	 */

	LSERR (WINAPI* pfnGetNumericSeparators)(POLS, PLSRUN, WCHAR*,WCHAR*);
	/* GetNumericSeparators:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  &wchDecimal (OUT): decimal separator for this run.
	 *  &wchThousands (OUT): thousands separator for this run
	 */

	LSERR (WINAPI* pfnCheckForDigit)(POLS, PLSRUN, WCHAR, BOOL*);
	/* GetNumericSeparators:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  wch (IN): character to check
	 *  &fIsDigit (OUT): this character is digit
	 */

	LSERR (WINAPI* pfnFetchPap)(POLS, LSCP, PLSPAP);
	/* FetchPap:
	 *  pols (IN):
	 *  cp (IN): an arbitrary cp value inside the paragraph
	 *  &lsPap (OUT): Paragraph properties.
	 */

	LSERR (WINAPI* pfnFetchTabs)(POLS, LSCP, PLSTABS, BOOL*, long*, WCHAR*);
	/* FetchTabs:
	 *  pols (IN):
	 *  cp (IN): an arbitrary cp value inside the paragraph
	 *  &lstabs (OUT): tabs array
	 *  &fHangingTab (OUT): there is hanging tab
	 *  &duaHangingTab (OUT): dua of hanging tab
	 *  &wchHangingTabLeader (OUT): leader of hanging tab
	 */

	LSERR (WINAPI* pfnGetBreakThroughTab)(POLS, long, long, long*);
	/* GetBreakThroughTab:
	 *  pols (IN):
	 *  uaRightMargin (IN): right margin for breaking
	 *  uaTabPos (IN): breakthrough tab position
	 *  uaRightMarginNew (OUT): new right margin
	 */

	LSERR (WINAPI* pfnFGetLastLineJustification)(POLS, LSKJUST, LSKALIGN, ENDRES, BOOL*, LSKALIGN*);
	/* FGetLastLineJustification:
	 *  pols (IN):
	 *  lskj (IN): kind of justification for the paragraph
	 *  lskal (IN): kind of alignment for the paragraph
	 *  endr (IN): result of formatting
	 *  &fJustifyLastLine (OUT): should last line be fully justified
	 *  &lskalLine (OUT): kind of alignment for this line
	 */

	LSERR (WINAPI* pfnCheckParaBoundaries)(POLS, LSCP, LSCP, BOOL*);
	/* CheckParaBoundaries:
	 *  pols (IN):
	 *  cpOld (IN):
	 *  cpNew (IN):
	 *  &fChanged (OUT): "Dangerous" change between paragraph properties.
	 */

	LSERR (WINAPI* pfnGetRunCharWidths)(POLS, PLSRUN, 
									 	LSDEVICE, LPCWSTR,
										DWORD, long, LSTFLOW,
										int*,long*,long*);
	/* GetRunCharWidths:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  lsDeviceID (IN): presentation or reference
	 *  lpwchRun (IN): run of characters
	 *  cwchRun (IN): number of characters in run
	 *  du (IN): available space for characters
	 *  kTFlow (IN): text direction and orientation
	 *  rgDu (OUT): widths of characters
	 *  &duRun (OUT): sum of widths in rgDx[0] to rgDu[limDx-1]
	 *  &limDu (OUT): number of widths fetched
	 */

	LSERR (WINAPI* pfnCheckRunKernability)(POLS, PLSRUN,PLSRUN, BOOL*);
	/* CheckRunKernability:
	 *  pols (IN):
	 *  plsrunLeft (IN): 1st of pair of adjacent runs
	 *  plsrunRight (IN): 2nd of pair of adjacent runs
	 *  &fKernable (OUT) : if TRUE, Line Service may kern between these runs
	 */

	LSERR (WINAPI* pfnGetRunCharKerning)(POLS, PLSRUN,
										 LSDEVICE, LPCWSTR,
										 DWORD, LSTFLOW, int*);
	/* GetRunCharKerning:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  lsDeviceID (IN): presentation or reference
	 *  lpwchRun (IN): run of characters
	 *  cwchRun (IN): number of characters in run
	 *  kTFlow (IN): text direction and orientation
	 *  rgDu (OUT): widths of characters
	 */

	LSERR (WINAPI* pfnGetRunTextMetrics)(POLS, PLSRUN,
										 LSDEVICE, LSTFLOW, PLSTXM);
	/* GetRunTextMetrics:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  deviceID (IN):  presentation, reference, or absolute
	 *  kTFlow (IN): text direction and orientation
	 *  &lsTxMet (OUT): Text metrics
	 */

	LSERR (WINAPI* pfnGetRunUnderlineInfo)(POLS, PLSRUN, PCHEIGHTS, LSTFLOW,
										   PLSULINFO);
	/* GetRunUnderlineInfo:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  heightsPres (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  &lsUlInfo (OUT): Underline information
	 */

	LSERR (WINAPI* pfnGetRunStrikethroughInfo)(POLS, PLSRUN, PCHEIGHTS, LSTFLOW,
											  PLSSTINFO);
	/* GetRunStrikethroughInfo:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  heightsPres (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  &lsStInfo (OUT): Strikethrough information
	 */

	LSERR (WINAPI* pfnGetBorderInfo)(POLS, PLSRUN, LSTFLOW, long*, long*);
	/* GetBorderInfo:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  &durBorder (OUT): Width of the border on the reference device
	 *  &dupBorder (OUT): Width of the border on the presentation device
	 */


	LSERR (WINAPI* pfnReleaseRun)(POLS, PLSRUN);
	/* ReleaseRun:
	 *  pols (IN):
	 *  plsrun (IN): run to be released, from GetRun() or FetchRun()
	 */

	LSERR (WINAPI* pfnHyphenate)(POLS, PCLSHYPH, LSCP, LSCP, PLSHYPH);
	/* Hyphenate:
	 *  pols (IN):
	 *  &lsHyphLast (IN): last hyphenation found. kysr==kysrNil means "none"
	 *  cpBeginWord (IN): 1st cp in word which exceeds column
	 *  cpExceed (IN): 1st which exceeds column, in this word
	 *  &lsHyph (OUT): hyphenation results. kysr==kysrNil means "none"
	 */

	LSERR (WINAPI* pfnGetHyphenInfo)(POLS, PLSRUN, DWORD*, WCHAR*);
	/* GetHyphenInfo:
	 *  pols (IN):
	 *  plsrun (IN):
     *  kysr (OUT)	  Ysr type - see "lskysr.h"
     *  wchYsr (OUT)  Character code of YSR
	*/

	LSERR (WINAPI* pfnDrawUnderline)(POLS, PLSRUN, UINT,
								const POINT*, DWORD, DWORD, LSTFLOW,
								UINT, const RECT*);
	/* DrawUnderline:
	 *  pols (IN):
	 *  plsrun (IN): run to use for the underlining
	 *  kUlbase (IN): underline kind 
	 *  pptStart (IN): starting position (top left)
	 *  dupUL (IN): underline width
	 *  dvpUL (IN) : underline thickness
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawStrikethrough)(POLS, PLSRUN, UINT,
								const POINT*, DWORD, DWORD, LSTFLOW,
								UINT, const RECT*);
	/* DrawStrikethrough:
	 *  pols (IN):
	 *  plsrun (IN): the run for the strikethrough
	 *  kStbase (IN): strikethrough kind 
	 *  pptStart (IN): starting position (top left)
	 *  dupSt (IN): strikethrough width
	 *  dvpSt (IN) : strikethrough thickness
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawBorder)(POLS, PLSRUN, const POINT*, PCHEIGHTS, PCHEIGHTS,
								  PCHEIGHTS, PCHEIGHTS, long, long, LSTFLOW, UINT, const RECT*);

	/* DrawBorder:
	 *  pols (IN):
	 *  plsrun (IN): plsrun of the first bordered run
	 *  pptStart (IN): starting point for the border
	 *  pheightsLineFull (IN): height of the line including SpaceBefore & SpaceAfter
	 *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
	 *  pheightsSubline (IN): height of subline
	 *  pheightsRuns (IN): height of collected runs to be bordered
	 *  dupBorder (IN): width of one border
	 *  dupRunsInclBorders (IN): width of collected runs
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawUnderlineAsText)(POLS, PLSRUN, const POINT*,
										   long, LSTFLOW, UINT, const RECT*);
	/* DrawUnderlineAsText:
	 *  pols (IN):
	 *  plsrun (IN): run to use for the underlining
	 *  pptStart (IN): starting pen position
	 *  dupLine (IN): length of UL
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnFInterruptUnderline)(POLS, PLSRUN, LSCP, PLSRUN, LSCP,BOOL*);
	/* FInterruptUnderline:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  cpLastFirst (IN): cp of the last character of the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  cpStartSecond (IN): cp of the first character of the current run
	 *  &fInterruptUnderline (OUT): do you want to interrupt drawing of the underline between these runs
	 */

	LSERR (WINAPI* pfnFInterruptShade)(POLS, PLSRUN, PLSRUN, BOOL*);
	/* FInterruptShade:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  &fInterruptShade (OUT): do you want to interrupt shading between these runs
	 */

	LSERR (WINAPI* pfnFInterruptBorder)(POLS, PLSRUN, PLSRUN, BOOL*);
	/* FInterruptBorder:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  &fInterruptBorder (OUT): do you want to interrupt border between these runs
	 */


	LSERR (WINAPI* pfnShadeRectangle)(POLS, PLSRUN, const POINT*, PCHEIGHTS, PCHEIGHTS,
								  PCHEIGHTS, PCHEIGHTS, PCHEIGHTS, long, long, LSTFLOW, UINT, const RECT*);

	/* ShadeRectangle:
	 *  pols (IN):
	 *  plsrun (IN): plsrun of the first shaded run
	 *  pptStart (IN): starting point for the shading rectangle
	 *  pheightsLineWithAddSpace(IN): height of the line including SpaceBefore & SpaceAfter (main baseline, 
	 *						lstflow of main line)
	 *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
	 *  pheightsSubline (IN): height of subline (local baseline, lstflow of subline)
	 *  pheightsRunsExclTrail (IN): height of collected runs to be shaded excluding 
	 *									trailing spaces area (local baseline, lstflow of subline)
	 *  pheightsRunsInclTrail (IN): height of collected runs to be shaded including
	 *									trailing spaces area (local baseline, lstflow of subline)
	 *  dupRunsExclTrail (IN): width of collected runs excluding trailing spaces area
	 *  dupRunsInclTrail (IN): width of collected runs including trailing spaces area
	 *  kTFlow (IN): text direction and orientation of subline
	 *  kDisp (IN) : display mode - opaque, transparent
	 *  prcClip (IN) : clipping rectangle
	 */

	LSERR (WINAPI* pfnDrawTextRun)(POLS, PLSRUN, BOOL, BOOL, 
								   const POINT*, LPCWSTR, const int*, DWORD, 
								   LSTFLOW, UINT, const POINT*, PCHEIGHTS, long, long, const RECT*);
	/* DrawTextRun:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  fStrikeout (IN) :
	 *  fUnderline (IN) :
	 *  pptText (IN): starting point for the text output
	 *  lpwchRun (IN): run of characters
	 *  rgDupRun (IN): widths of characters
	 *  cwchRun (IN): number of characters in run
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  pptRun (IN): starting point of the run
	 *  heightsPres (IN): presentation heights for this run
	 *  dupRun (IN): presentation width for this run
	 *  dupLimUnderline (IN): underlining limit
	 *  pRectClip (IN): clipping rectangle
	 */

    LSERR (WINAPI* pfnDrawSplatLine)(POLS, enum lsksplat, LSCP, const POINT*,
									 PCHEIGHTS, PCHEIGHTS, PCHEIGHTS, long, LSTFLOW,
									 UINT, const RECT*);
	/* DrawSplatLine:
	 *  pols (IN):
	 *  ksplat (IN): See definitions in lsksplat.h
	 *  cpSplat (IN): location of the break character which caused the splat.
	 *  pptSplatLine (IN) : starting position of the splat line
	 *  pheightsLineFull (IN): height of the line including SpaceBefore & SpaceAfter
	 *  pheightsLineWithoutAddedSpace (IN): height of the line without SpaceBefore & SpaceAfter
	 *  pheightsSubline (IN): height of subline
	 *  dup (IN): distance to right margin
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  &rcClip (IN) : clipping rectangle
	 */


/* Advanced typography enabling API's */

	/* Glyph enabling */

	LSERR (WINAPI* pfnFInterruptShaping)(POLS, LSTFLOW, PLSRUN, PLSRUN, BOOL*);
	/* FInterruptShaping:
	 *  pols (IN):
	 *  kTFlow (IN): text direction and orientation
	 *  plsrunFirst (IN): run pointer for the previous run
	 *  plsrunSecond (IN): run pointer for the current run
	 *  &fInterruptShaping (OUT): do you want to interrupt character shaping between these runs
	*/

	LSERR (WINAPI* pfnGetGlyphs)(POLS, PLSRUN, LPCWSTR, DWORD, LSTFLOW, PGMAP, PGINDEX*, PGPROP*, DWORD*);
	/* GetGlyphs:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  pwch (IN): pointer to the string of character codes
	 *  cwch (IN): number of characters to be shaped
	 *  kTFlow (IN): text direction and orientation
	 *  rgGmap (OUT): parallel to the char codes mapping wch->glyph info
	 *  &rgGindex (OUT): array of output glyph indices
	 *  &rgGprop (OUT): array of output glyph properties
	 *  &cgindex (OUT): number of output glyph indices
	 */

	LSERR (WINAPI* pfnGetGlyphPositions)(POLS, PLSRUN, LSDEVICE, LPWSTR, PCGMAP, DWORD,
											PCGINDEX, PCGPROP, DWORD, LSTFLOW, int*, PGOFFSET);
	/* GetGlyphPositions:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  lsDeviceID (IN): presentation or reference
	 *  pwch (IN): pointer to the string of character codes
	 *  pgmap (IN): array of wch->glyph mapping
	 *  cwch (IN): number of characters to be shaped
	 *  rgGindex (IN): array of glyph indices
	 *  rgGprop (IN): array of glyph properties
	 *  cgindex (IN): number glyph indices
	 *  kTFlow (IN): text direction and orientation
	 *  rgDu (OUT): array of widths of glyphs
	 *  rgGoffset (OUT): array of offsets of glyphs
	 */

	LSERR (WINAPI* pfnResetRunContents)(POLS, PLSRUN, LSCP, LSDCP, LSCP, LSDCP);
	/* ResetRunContents:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  cpFirstOld (IN): cpFirst before shaping
	 *  dcpOld (IN): dcp before shaping
	 *  cpFirstNew (IN): cpFirst after shaping
	 *  dcpNew (IN): dcp after shaping
	 */

	LSERR (WINAPI* pfnDrawGlyphs)(POLS, PLSRUN, BOOL, BOOL, PCGINDEX, const int*, const int*,
						PGOFFSET, PGPROP, PCEXPTYPE, DWORD,
						LSTFLOW, UINT, const POINT*, PCHEIGHTS, long, long, const RECT*);
	/* DrawGlyphs:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  fStrikeout (IN) :
	 *  fUnderline (IN) :
	 *  pglyph (IN): array of glyph indices
	 *  rgDu (IN): array of widths of glyphs
	 *  rgDuBeforeJust (IN): array of widths of glyphs before justification
	 *  rgGoffset (IN): array of offsets of glyphs
	 *  rgGprop (IN): array of glyph properties
	 *  rgExpType (IN): array of glyph expansion types
	 *  cglyph (IN): number glyph indices
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  pptRun (IN): starting point of the run
	 *  heightsPres (IN): presentation heights for this run
	 *  dupRun (IN): presentation width for this run
	 *  dupLimUnderline (IN): underlining limit
	 *  pRectClip (IN): clipping rectangle
	 */

	/* Glyph justification */

	LSERR (WINAPI* pfnGetGlyphExpansionInfo)(POLS, PLSRUN, LSDEVICE, LPCWSTR, PCGMAP, DWORD, 
							PCGINDEX, PCGPROP, DWORD, LSTFLOW, BOOL, PEXPTYPE, LSEXPINFO*);
	/* GetGlyphExpansionInfo:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  lsDeviceID (IN): presentation or reference
	 *  pwch (IN): pointer to the string of character codes
	 *  rggmap (IN): array of wchar->glyph mapping
	 *  cwch (IN): number of characters to be shaped
	 *  rgglyph (IN): array of glyph indices
	 *  rgProp (IN): array of glyph properties
	 *  cglyph (IN): number glyph indices
	 *  kTFlow (IN): text direction and orientation
	 *  fLastTextChunkOnLine (IN): Last text chunk on line?
	 *  rgExpType (OUT): array of glyph expansion types
	 *  rgexpinfo (OUT): array of glyph expansion info
	 */

	LSERR (WINAPI* pfnGetGlyphExpansionInkInfo)(POLS, PLSRUN, LSDEVICE, GINDEX, GPROP, LSTFLOW, DWORD, long*);
	/* GetGlyphExpansionInkInfo:
	 *  pols (IN):
	 *  plsrun (IN): run pointer of the first run
	 *  lsDeviceID (IN): presentation or reference
	 *  gindex (IN): glyph index
	 *  gprop (IN): glyph properties
	 *  kTFlow (IN): text direction and orientation
	 *  cAddInkDiscrete (IN): number of discrete values (minus 1, because maximum is already known)
	 *  rgDu (OUT): array of discrete values
	 */

	/* FarEast realted typograpy issues */

	LSERR (WINAPI* pfnGetEms)(POLS, PLSRUN, LSTFLOW, PLSEMS);
	/* GetEms:
	 *  pols (IN):
	 *  plsrun (IN): run pointer as returned from FetchRun
	 *  kTFlow (IN): text direction and orientation
	 *  &lsems (OUT): different fractions of EM in appropriate pixels
	 */

	LSERR (WINAPI* pfnPunctStartLine)(POLS, PLSRUN, MWCLS, WCHAR, LSACT*);
	/* PunctStartLine:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the char
	 *  mwcls (IN): mod width class for the char
	 *  wch (IN): char
	 *  &lsact (OUT): action on the first char on the line
	 */

	LSERR (WINAPI* pfnModWidthOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
									   LSACT*);
	/* ModWidthOnRun:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the first char
	 *  wchFirst (IN): first char
	 *  plsrunSecond (IN): run pointer for the second char
	 *  wchSecond (IN): second char
	 *  &lsact (OUT): action on the last char in 1st run
	 */

	LSERR (WINAPI* pfnModWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN, WCHAR,
									 LSACT*);
	/* ModWidthSpace:
	 *  pols (IN):
	 *  plsrunCur (IN): run pointer for the current run
	 *  plsrunPrev (IN): run pointer for the previous char
	 *  wchPrev (IN): previous char
	 *  plsrunNext (IN): run pointer for the next char
	 *  wchNext (IN): next char
	 *  &lsact (OUT): action on space's width
	 */

	LSERR (WINAPI* pfnCompOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
								   LSPRACT*);
	/* CompOnRun:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the first char
	 *  wchFirst (IN): first char
	 *  plsrunSecond (IN): run pointer for the second char
	 *  wchSecond (IN): second char
	 *  &lspract (OUT): prioritized action on the last char in 1st run
	 */

	LSERR (WINAPI* pfnCompWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN, WCHAR,
									  LSPRACT*);
	/* CompWidthSpace:
	 *  pols (IN):
	 *  plsrunCur (IN): run pointer for the current run
	 *  plsrunPrev (IN): run pointer for the previous char
	 *  wchPrev (IN): previous char
	 *  plsrunNext (IN): run pointer for the next char
	 *  wchNext (IN): next char
	 *  &lspract (OUT): prioritized action on space's width
	 */


	LSERR (WINAPI* pfnExpOnRun)(POLS, PLSRUN, WCHAR, PLSRUN, WCHAR,
								  LSACT*);
	/* ExpOnRun:
	 *  pols (IN):
	 *  plsrunFirst (IN): run pointer for the first char
	 *  wchFirst (IN): first char
	 *  plsrunSecond (IN): run pointer for the second char
	 *  wchSecond (IN): second char
	 *  &lsact (OUT): action on the last run char from 1st run
	 */

	LSERR (WINAPI* pfnExpWidthSpace)(POLS, PLSRUN, PLSRUN, WCHAR, PLSRUN,
									   WCHAR, LSACT*);
	/* ExpWidthSpace:
	 *  pols (IN):
	 *  plsrunCur (IN): run pointer for the current run
	 *  plsrunPrev (IN): run pointer for the previous char
	 *  wchPrev (IN): previous char
	 *  plsrunNext (IN): run pointer for the next char
	 *  wchNext (IN): next char
	 *  &lsact (OUT): action on space's width
	 */

	LSERR (WINAPI* pfnGetModWidthClasses)(POLS, PLSRUN, const WCHAR*, DWORD, MWCLS*);
	/* GetModWidthClasses:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the characters
	 *  rgwch (IN): array of characters
	 *  cwch (IN): number of characters in the rgwch array
	 *  rgmwcls(OUT): array of ModWidthClass's for chars from the rgwch array
	 */

	LSERR (WINAPI* pfnGetBreakingClasses)(POLS, PLSRUN, LSCP, WCHAR, BRKCLS*, BRKCLS*);
	/* GetBreakingClasses:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the char
	 *  cp (IN): cp of the character
	 *  wch (IN): character
	 *  &brkclsFirst (OUT): breaking class for this char as the leading one in a pair
	 *  &brkclsSecond (OUT): breaking class for this char as the following one in a pair
	 */

	LSERR (WINAPI* pfnFTruncateBefore)(POLS, PLSRUN, LSCP, WCHAR, long, PLSRUN, LSCP, WCHAR, long, long, BOOL*);
	/* FTruncateBefore:
	 *  pols (IN):
	 *	plsrunCur (IN): plsrun of the current character 
	 *  cpCur (IN): cp of truncation char
	 *  wchCur (IN): truncation character 
	 *  durCur (IN): width of truncation character
	 *	plsrunPrev (IN): plsrun of the previous character 
	 *  cpPrev (IN): cp of the previous character
	 *  wchPrev (IN): previous character 
	 *  durPrev (IN): width of truncation character
	 *  durCut (IN): width from the RM until the end of the current character
	 *  &fTruncateBefore (OUT): truncation point is before this character
	 * 			(if it exceeds RM)
	 */
	
	LSERR (WINAPI* pfnCanBreakBeforeChar)(POLS, BRKCLS, BRKCOND*);
	/* CanBreakBeforeChar:
	 *  pols (IN):
	 *	brkcls (IN): breaking class for the char as the following one in a pair
	 *  &brktxtBefore (OUT): break condition before the character
	 */

	LSERR (WINAPI* pfnCanBreakAfterChar)(POLS, BRKCLS, BRKCOND*);
	/* CanBreakAfterChar:
	 *  pols (IN):
	 *  brkcls (IN): breaking class for the char as the leading one in a pair
	 *  &brktxtAfter (OUT): break text condition after the character
	 */


	LSERR (WINAPI* pfnFHangingPunct)(POLS, PLSRUN, MWCLS, WCHAR, BOOL*);
	/* FHangingPunct:
	 *  pols (IN):
	 *  plsrun (IN): run pointer for the char
	 *  mwcls (IN): mod width class of this char
	 *  wch (IN): character
	 *  &fHangingPunct (OUT): can be pushed to the right margin?
	 */

	LSERR (WINAPI* pfnGetSnapGrid)(POLS, WCHAR*, PLSRUN*, LSCP*, DWORD, BOOL*, DWORD*);
	/* GetGridInfo:
	 *  pols (IN):
	 *  rgwch (IN): array of characters
	 *  rgplsrun (IN): array of corresponding plsrun's
	 *  rgcp (IN): array of corresponding cp's
	 *  iwch (IN): number of characters
	 *	rgfSnap (OUT): array of fSnap flags for all characters
	 *	pwGridNumber (OUT): number of grid points on the line
	 */

	LSERR (WINAPI* pfnDrawEffects)(POLS, PLSRUN, UINT,
								   const POINT*, LPCWSTR, const int*, const int*, DWORD, 
								   LSTFLOW, UINT, PCHEIGHTS, long, long, const RECT*);
	/* DrawTextRun:
	 *  pols (IN):
	 *  plsrun (IN):
	 *  EffectsFlags (IN): set of client defined special effects bits
	 *  ppt (IN): output location
	 *  lpwchRun (IN): run of characters
	 *  rgDupRun (IN): widths of characters
	 *  rgDupLeftCut (IN): dup cut from the left side of the char
	 *  cwchRun (IN): number of characters in run
	 *  kTFlow (IN): text direction and orientation
	 *  kDisp (IN): display mode - opaque, transparent
	 *  heightsPres (IN): presentation heights for this run
	 *  dupRun (IN): presentation width for this run
	 *  dupLimUnderline (IN): underlining limit
	 *  pRectClip (IN): clipping rectangle
	 */

	LSERR (WINAPI* pfnFCancelHangingPunct)(POLS, LSCP, LSCP, WCHAR, MWCLS, BOOL*);

	/* FCancelHangingPunct:
	 *  pols (IN):
	 *  cpLim (IN): cpLim of the line
	 *  cpLastAdjustable (IN): cp of the last adjustable character on the line
	 *  wch (IN): last character
	 *  mwcls (IN): mod width class of this char
	 *  pfCancelHangingPunct (OUT): cancel hanging punctuation?
	*/

	LSERR (WINAPI* pfnModifyCompAtLastChar)(POLS, LSCP, LSCP, WCHAR, MWCLS, long, long, long*);

	/* ModifyCompAtLastChar:
	 *  pols (IN):
	 *  cpLim (IN): cpLim of the line
	 *  cpLastAdjustable (IN): cp of the last adjustable character on the line
	 *  wch (IN): last character
	 *  mwcls (IN): mod width class of this char
	 *  durCompLastRight (IN): suggested compression on the right side
	 *  durCompLastLeft (IN): suggested compression on the left side
	 *  pdurCahngeComp (OUT): change compression amount on the last char
	*/

	/* Enumeration callbacks */

	LSERR (WINAPI* pfnEnumText)(POLS, PLSRUN, LSCP, LSDCP, LPCWSTR, DWORD, LSTFLOW, BOOL,
											BOOL, const POINT*, PCHEIGHTS, long, BOOL, long*);
	/* EnumText:
	 *  pols (IN):
	 *  plsrun (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  dcp (IN): from DNODE
	 *  rgwch(IN): array of characters
	 *  cwch(IN): number of characters
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryProvided (IN):
	 *  pptStart (IN): starting position, iff fGeometryProvided
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryProvided
	 *  dupRun(IN): from DNODE, relevant iff fGeometryProvided
	 *  fCharWidthProvided (IN):
	 *  rgdup(IN): array of character widths, iff fCharWidthProvided
	*/

	LSERR (WINAPI* pfnEnumTab)(POLS, PLSRUN, LSCP, LPCWSTR, WCHAR, LSTFLOW, BOOL,
													BOOL, const POINT*, PCHEIGHTS, long);
	/* EnumTab:
	 *  pols (IN):
	 *  plsrun (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  rgwch(IN): Pointer to one Tab character
	 *  wchTabLeader (IN): tab leader
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryProvided (IN):
	 *  pptStart (IN): starting position, iff fGeometryProvided
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryProvided
	 *  dupRun(IN): from DNODE, relevant iff fGeometryProvided
	*/

	LSERR (WINAPI* pfnEnumPen)(POLS, BOOL, LSTFLOW, BOOL, BOOL, const POINT*, long, long);
	/* EnumPen:
	 *  pols (IN):
	 *  fBorder (IN):
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryProvided (IN):
	 *  pptStart (IN): starting position, iff fGeometryProvided
	 *  dup(IN): from DNODE iff fGeometryProvided
	 *  dvp(IN): from DNODE iff fGeometryProvided
	*/

	/* Objects bundling */

	LSERR (WINAPI* pfnGetObjectHandlerInfo)(POLS, DWORD, void*);
	/* GetObjectHandlerInfo:
	 *  pols (IN):
	 *  idObj (IN): id of the object handler
	 *  pObjectInfo (OUT): initialization information of the specified object
	*/


	/* Debugging APIs */
	void (WINAPI *pfnAssertFailed)(char*, char*, int);

};
typedef struct lscbk LSCBK;

#endif /* !LSCBK_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsdevres.h ===
#ifndef LSDEVRES_DEFINED
#define LSDEVRES_DEFINED

typedef struct
{
	long dxpInch, dypInch;				/* resolution of preview device */
	long dxrInch, dyrInch;				/* resolution of reference device */
} LSDEVRES;

#endif /* !LSDEVRES_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsdevice.h ===
#ifndef LSDEVICE_DEFINED
#define LSDEVICE_DEFINED

enum lsdevice				/* Parameter for pfnGetRunTextMetrics callback */
{
	lsdevPres,
	lsdevReference
};

typedef enum lsdevice LSDEVICE;

#endif /* !LSDEVICE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lscrline.h ===
#ifndef LSCRLINE_DEFINED
#define LSCRLINE_DEFINED

#include "lsdefs.h"
#include "plsline.h"
#include "breakrec.h"
#include "lslinfo.h"

LSERR WINAPI LsCreateLine(PLSC,				/* IN: ptr to line services context		*/
						  LSCP,				/* IN: cpFirst							*/
						  long,				/* IN: duaColumn						*/
						  const BREAKREC*,	/* IN: input array of break records		*/
						  DWORD,			/* IN: number of records in input array	*/
						  DWORD,			/* IN: size of the output array			*/
						  BREAKREC*,		/* OUT: output array of break records	*/
						  DWORD*,			/* OUT:actual number of records in array*/
						  LSLINFO*,			/* OUT: visible line info				*/
						  PLSLINE*);		/* OUT: ptr to line opaque to client	*/

LSERR WINAPI LsModifyLineHeight(PLSC,		/* IN: ptr to line services context 	*/
								PLSLINE,	/* IN: ptr to line -- opaque to client	*/
								long,		/* IN: dvpAbove							*/
								long,		/* IN: dvpAscent						*/
								long,		/* IN: dvpDescent						*/	
								long);		/* IN: dvpBelow							*/	

LSERR WINAPI LsDestroyLine(PLSC,			/* IN: ptr to line services context		*/
						   PLSLINE);		/* IN: ptr to line -- opaque to client	*/

LSERR WINAPI LsGetLineDur(PLSC,				/* IN: ptr to line services context 	*/
						  PLSLINE,			/* IN: ptr to line -- opaque to client	*/
						  long*,			/* OUT: dur of line incl. trailing area	*/
						  long*);			/* OUT: dur of line excl. trailing area	*/

LSERR WINAPI LsGetMinDurBreaks(PLSC,		/* IN: ptr to line services context 	*/
						  	   PLSLINE,		/* IN: ptr to line -- opaque to client	*/
						  	   long*,		/* OUT: min dur between breaks including 
																	trailing area	*/
						  	   long*);		/* OUT: min dur between breaks excluding 
																	trailing area	*/

#endif /* !LSCRLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsdnset.h ===
#ifndef LSDNSET_DEFINED
#define LSDNSET_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plssubl.h"
#include "plsdnode.h"
#include "pobjdim.h"
#include "lsktab.h"
#include "lskeop.h"

LSERR WINAPI LsdnQueryObjDimRange(
								  PLSC,			/* IN: Pointer to LS Context */
							 	  PLSDNODE,		/* IN: plsdnFirst -- First DNODE in range */
								  PLSDNODE,		/* IN: plsdnLast -- Last DNODE in range */
							 	  POBJDIM);		/* OUT: dimensions of range */


LSERR WINAPI LsdnResetObjDim(
								 PLSC,			/* IN: Pointer to LS Context	*/
								 PLSDNODE,		/* IN: plsdnFirst 				*/
								 PCOBJDIM);		/* IN: dimensions of dnode 		*/


LSERR WINAPI LsdnQueryPenNode(
							  PLSC,				/* IN: Pointer to LS Context*/
						  	  PLSDNODE,			/* IN: DNODE queried		*/
						  	  long*,			/* OUT: &dvpPen				*/
						  	  long*,			/* OUT: &durPen				*/
						  	  long*);			/* OUT: &dvrPen				*/


LSERR WINAPI LsdnResetPenNode(
							  PLSC,				/* IN: Pointer to LS Context */
						  	  PLSDNODE,			/* IN: DNODE to be modified */
						  	  long,				/* IN: dvpPen */
						  	  long,				/* IN: durPen */
						  	  long);			/* IN: dvrPen */

LSERR WINAPI LsdnSetRigidDup(
							 PLSC,				/* IN: Pointer to LS Context */
							 PLSDNODE,			/* IN: DNODE to be modified	 */
							 long);				/* IN: dup					 */

LSERR WINAPI LsdnGetDup(
							 PLSC,				/* IN: Pointer to LS Context */
							 PLSDNODE,			/* IN: DNODE queried		 */
							 long*);			/* OUT: dup					 */

LSERR WINAPI LsdnSetAbsBaseLine(
								PLSC,			/* IN: Pointer to LS Context */
							  	long);    		/* IN: new vaBase            */

LSERR WINAPI LsdnModifyParaEnding(
								PLSC,			/* IN: Pointer to LS Context */
								LSKEOP);		/* IN: Kind of line ending			*/

LSERR WINAPI LsdnResolvePrevTab(PLSC);			/* IN: Pointer to LS Context */

LSERR WINAPI LsdnGetCurTabInfo(
							PLSC,				/* IN: Pointer to LS Context */
							LSKTAB*);			/* OUT: Type of current tab  */

LSERR WINAPI LsdnSkipCurTab(PLSC);					/* IN: Pointer to LS Context */

LSERR WINAPI LsdnDistribute(
							PLSC,				/* IN: Pointer to LS Context	*/
							PLSDNODE,			/* IN: First DNODE				*/
							PLSDNODE,			/* IN: Last DNODE				*/
							long);				/* IN: durToDistribute			*/

LSERR WINAPI LsdnSubmitSublines(
							PLSC,				/* IN: Pointer to LS Context	*/
							PLSDNODE,			/* IN: DNODE					*/
							DWORD,				/* IN: cSublinesSubmitted		*/
							PLSSUBL*,			/* IN: rgpsublSubmitted			*/
							BOOL,				/* IN: fUseForJustification		*/
							BOOL,				/* IN: fUseForCompression		*/
							BOOL,				/* IN: fUseForDisplay			*/
							BOOL,				/* IN: fUseForDecimalTab		*/
							BOOL				/* IN: fUseForTrailingArea		*/
							);											
LSERR WINAPI LsdnGetFormatDepth(
							PLSC,				/* IN: Pointer to LS Context	*/
							DWORD*);			/* OUT: nDepthFormatLineMax		*/

#endif /* !LSDNSET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsdnfin.h ===
#ifndef LSDNFIN_DEFINED
#define LSDNFIN_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plsrun.h"
#include "plsfrun.h"
#include "plschp.h"
#include "pobjdim.h"
#include "pdobj.h"


LSERR WINAPI LsdnFinishRegular(
							  PLSC,				/* IN: Pointer to LS Context */
							  LSDCP,     		/* IN: dcp adopted           */
							  PLSRUN,   		/* IN: PLSRUN  		         */
							  PCLSCHP,  		/* IN: CHP          	     */
							  PDOBJ,    		/* IN: PDOBJ             	 */ 
							  PCOBJDIM);		/* IN: OBJDIM      		     */

LSERR WINAPI LsdnFinishRegularAddAdvancePen(
							  PLSC,				/* IN: Pointer to LS Context */
							  LSDCP,     		/* IN: dcp adopted           */
							  PLSRUN,   		/* IN: PLSRUN  		         */
							  PCLSCHP,  		/* IN: CHP          	     */
							  PDOBJ,    		/* IN: PDOBJ             	 */ 
							  PCOBJDIM,			/* IN: OBJDIM      		     */
							  long,				/* IN: durPen				 */
							  long,				/* IN: dvrPen				 */
							  long);			/* IN: dvpPen 				 */

LSERR WINAPI LsdnFinishByPen(PLSC,				/* IN: Pointer to LS Context */
						   LSDCP, 	    		/* IN: dcp	adopted          */
						   PLSRUN,		   		/* IN: PLSRUN  		         */
						   PDOBJ,	    		/* IN: PDOBJ             	 */ 
						   long,    	 		/* IN: dur         		     */
						   long,     			/* IN: dvr             		 */
						   long);   			/* IN: dvp          	     */

LSERR WINAPI LsdnFinishDeleteAll(PLSC,			/* IN: Pointer to LS Context */
					  			LSDCP);			/* IN: dcp adopted			 */

#endif /* !LSDNFIN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lscrsubl.h ===
#ifndef LSCRSUBL_DEFINED
#define LSCRSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "lsfrun.h"
#include "lsesc.h"
#include "plssubl.h"
#include "plsdnode.h"
#include "fmtres.h"
#include "objdim.h"
#include "lstflow.h"
#include "lskjust.h"
#include "breakrec.h"
#include "brkkind.h"
#include "brkpos.h"

LSERR WINAPI LsCreateSubline(
							PLSC,			/* IN: LS context						*/
							LSCP,			/* IN: cpFirst							*/
						    long,			/* IN: urColumnMax						*/
							LSTFLOW,		/* IN: text flow						*/
							BOOL);			/* IN: fContiguous						*/

LSERR WINAPI LsFetchAppendToCurrentSubline(
							PLSC,			/* IN: LS context						*/
							LSDCP,			/* IN:Increase cp before fetching		*/
						    const LSESC*,	/* IN: escape characters				*/
						    DWORD,			/* IN: # of escape characters			*/
							BOOL*,			/* OUT: Successful?---if not, finish 
												subline, destroy it and start anew	*/
						    FMTRES*,		/* OUT: result of last formatter		*/
						    LSCP*,			/* OUT: cpLim							*/
						    PLSDNODE*,		/* OUT: First DNODE created				*/
						 	PLSDNODE*);		/* OUT: Last DNODE created				*/

LSERR WINAPI LsFetchAppendToCurrentSublineResume(
							PLSC,			/* IN: LS context						*/
							const BREAKREC*,/* IN: array of break records			*/
							DWORD,			/* IN: number of records in array		*/
							LSDCP,			/* IN:Increase cp before fetching		*/
						    const LSESC*,	/* IN: escape characters				*/
						    DWORD,			/* IN: # of escape characters			*/
							BOOL*,			/* OUT: Successful?---if not, finish 
												subline, destroy it and start anew	*/
						    FMTRES*,		/* OUT: result of last formatter		*/
						    LSCP*,			/* OUT: cpLim							*/
						    PLSDNODE*,		/* OUT: First DNODE created				*/
						 	PLSDNODE*);		/* OUT: Last DNODE created				*/

LSERR WINAPI LsAppendRunToCurrentSubline(		/* Simple runs only	*/
							PLSC,			/* IN: LS context						*/
						    const LSFRUN*,	/* IN: given run						*/
							BOOL*,			/* OUT: Successful?---if not, finish 
												subline, destroy it and start anew	*/
						    FMTRES*,		/* OUT: result of last formatter		*/
						    LSCP*,			/* OUT: cpLim							*/
						    PLSDNODE*);		/* OUT: DNODE created					*/

LSERR WINAPI LsResetRMInCurrentSubline(
							PLSC,			/* IN: LS context						*/
						    long);			/* IN: urColumnMax						*/

LSERR WINAPI LsFinishCurrentSubline(
							PLSC,			/* IN: LS context						*/
							PLSSUBL*);		/* OUT: subline context					*/


LSERR WINAPI LsTruncateSubline(
							PLSSUBL,		/* IN: subline context					*/
							long,			/* IN: urColumnMax						*/
							LSCP*);			/* OUT: cpTruncate 						*/

LSERR WINAPI LsFindPrevBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp					*/
						    long,			/* IN: urColumnMax						*/
							BOOL*,			/* OUT: fSuccessful?					*/
							LSCP*,			/* OUT: cpBreak							*/
							POBJDIM,		/* OUT: objdimSub up to break			*/
							BRKPOS*);		/* OUT: Before/Inside/After				*/

LSERR WINAPI LsFindNextBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp					*/
						    long,			/* IN: urColumnMax						*/
							BOOL*,			/* OUT: fSuccessful?					*/
							LSCP*,			/* OUT: cpBreak							*/
							POBJDIM,		/* OUT: objdimSub up to break			*/			
							BRKPOS*);		/* OUT: Before/Inside/After				*/

LSERR WINAPI LsForceBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BOOL,			/* IN: fFirstSubline					*/
							LSCP,			/* IN: truncation cp					*/
						    long,			/* IN: urColumnMax						*/
							LSCP*,			/* OUT: cpBreak							*/
							POBJDIM,		/* OUT: objdimSub up to break			*/			
							BRKPOS*);		/* OUT: Before/Inside/After				*/

LSERR WINAPI LsSetBreakSubline(
							PLSSUBL,		/* IN: subline context					*/
							BRKKIND,		/* IN: Prev/Next/Force/Imposed			*/			
							DWORD,			/* IN: size of array					*/
							BREAKREC*, 		/* OUT: array of break records			*/
							DWORD*);		/* OUT: number of used elements of the array*/

LSERR WINAPI LsDestroySubline(PLSSUBL);

LSERR WINAPI LsMatchPresSubline(
							  PLSSUBL);		/* IN: subline context		*/

LSERR WINAPI LsExpandSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  LSKJUST,		/* IN: justification type	*/
							  long);		/* IN: dup					*/

LSERR WINAPI LsCompressSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  LSKJUST,		/* IN: justification type	*/
							  long);		/* IN: dup					*/

LSERR WINAPI LsSqueezeSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  long,			/* IN: durTarget			*/
							  BOOL*,		/* OUT: fSuccessful?		*/
							  long*);		/* OUT: if nof successful, 
													extra dur 			*/

LSERR WINAPI LsGetSpecialEffectsSubline(
							  PLSSUBL,		/* IN: subline context		*/
							  UINT*);		/* OUT: special effects		*/

#endif /* !LSCRSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsdefs.h ===
/* Common definitions for line services
 */

#ifndef LSDEFS_DEFINED
#define LSDEFS_DEFINED

#ifdef UNIX
#include <wchar.h>
#endif

#if defined(_NO_WINDOWS)

/* <windows.h> must be included FIRST, if at all. */
/* We define basic types if <windows.h> is not included. */

#ifndef NULL
#define NULL    ((void *)0)
#endif /* NULL */

#define WINAPI __stdcall
#define FALSE	0
#define TRUE	1

typedef int BOOL;
typedef long LONG;
typedef unsigned long DWORD;
typedef unsigned short WORD;
typedef unsigned int UINT;
typedef unsigned char BYTE;
typedef int INT;
#ifdef UNIX
typedef wchar_t WCHAR;
#else
typedef WORD WCHAR;
#endif
typedef const WCHAR* LPCWSTR;
typedef WCHAR* LPWSTR;

typedef struct tagRECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECT;

typedef struct tagPOINT
{
    LONG  x;
    LONG  y;
} POINT;

#endif /* WINVER */


/* Line services definitions */
struct lscontext;					/* Opaque to clients */
typedef struct lscontext* PLSC;
typedef const struct lscontext* PCLSC;

struct ols;								/* Owner of LineServices */
typedef struct ols* POLS;				/*  (Opaque to LineService) */

typedef long LSCP;
typedef DWORD LSDCP;

typedef WORD GINDEX;
typedef GINDEX* PGINDEX;
typedef const GINDEX* PCGINDEX;

typedef struct tagPOINTUV
{
    LONG  u;
    LONG  v;
} POINTUV;

typedef POINTUV* PPOINTUV;
typedef const POINTUV* PCPOINTUV;

typedef struct tagGOFFSET
{
    LONG  du;
    LONG  dv;
} GOFFSET;

typedef GOFFSET* PGOFFSET;
typedef const GOFFSET* PCGOFFSET;

/* Line services error codes */
typedef long LSERR;
#define lserrNone						( 0L)
#ifdef LSERRSTOP				/* stop immediately, don't return error */
#define lserrInvalidParameter   		AssertErr("lserrInvalidParameter")  	
#define lserrOutOfMemory    			AssertErr("lserrOutOfMemory")
#define lserrNullOutputParameter  		AssertErr("lserrNullOutputParameter")
#define lserrInvalidContext    			AssertErr("lserrInvalidContext")
#define lserrInvalidLine    			AssertErr("lserrInvalidLine")
#define lserrInvalidDnode    			AssertErr("lserrInvalidDnode")
#define lserrInvalidDeviceResolution 	AssertErr("lserrInvalidDeviceResolution")
#define lserrInvalidRun  			   	AssertErr("lserrInvalidRun")
#define lserrMismatchLineContext  		AssertErr("lserrMismatchLineContext")
#define lserrContextInUse    			AssertErr("lserrContextInUse")
#define lserrDuplicateSpecialCharacter 	AssertErr("lserrDuplicateSpecialCharacter")
#define lserrInvalidAutonumRun  		AssertErr("lserrInvalidAutonumRun")
#define lserrFormattingFunctionDisabled AssertErr("lserrFormattingFunctionDisabled")
#define lserrUnfinishedDnode   			AssertErr("lserrUnfinishedDnode")
#define lserrInvalidDnodeType   		AssertErr("lserrInvalidDnodeType")
#define lserrInvalidPenDnode   			AssertErr("lserrInvalidPenDnode")
#define lserrInvalidNonPenDnode   		AssertErr("lserrInvalidNonPenDnode")
#define lserrInvalidBaselinePenDnode 	AssertErr("lserrInvalidBaselinePenDnode")
#define lserrInvalidFormatterResult  	AssertErr("lserrInvalidFormatterResult")
#define lserrInvalidObjectIdFetched  	AssertErr("lserrInvalidObjectIdFetched")
#define lserrInvalidDcpFetched   		AssertErr("lserrInvalidDcpFetched")
#define lserrInvalidCpContentFetched 	AssertErr("lserrInvalidCpContentFetched")
#define lserrInvalidBookmarkType  		AssertErr("lserrInvalidBookmarkType")
#define lserrSetDocDisabled    			AssertErr("lserrSetDocDisabled")
#define lserrFiniFunctionDisabled  		AssertErr("lserrFiniFunctionDisabled")
#define lserrCurrentDnodeIsNotTab  		AssertErr("lserrCurrentDnodeIsNotTab")
#define lserrPendingTabIsNotResolved	AssertErr("lserrPendingTabIsNotResolved")
#define lserrWrongFiniFunction 			AssertErr("lserrWrongFiniFunction")
#define lserrInvalidBreakingClass		AssertErr("lserrInvalidBreakingClass")
#define lserrBreakingTableNotSet		AssertErr("lserrBreakingTableNotSet")
#define lserrInvalidModWidthClass		AssertErr("lserrInvalidModWidthClass")
#define lserrModWidthPairsNotSet		AssertErr("lserrModWidthPairsNotSet")
#define lserrWrongTruncationPoint 		AssertErr("lserrWrongTruncationPoint")
#define lserrWrongBreak 				AssertErr("lserrWrongBreak")
#define lserrDupInvalid 				AssertErr("lserrDupInvalid")
#define lserrRubyInvalidVersion			AssertErr("lserrRubyVersionInvalid")
#define lserrTatenakayokoInvalidVersion	AssertErr("lserrTatenakayokoInvalidVersion")
#define lserrWarichuInvalidVersion		AssertErr("lserrWarichuInvalidVersion")
#define lserrWarichuInvalidData			AssertErr("lserrWarichuInvalidData")
#define lserrCreateSublineDisabled		AssertErr("lserrCreateSublineDisabled")
#define lserrCurrentSublineDoesNotExist	AssertErr("lserrCurrentSublineDoesNotExist")
#define lserrCpOutsideSubline			AssertErr("lserrCpOutsideSubline")
#define lserrHihInvalidVersion			AssertErr("lserrHihInvalidVersion")
#define lserrInsufficientQueryDepth		AssertErr("lserrInsufficientQueryDepth")
#define lserrInsufficientBreakRecBuffer	AssertErr("lserrInsufficientBreakRecBuffer")
#define lserrInvalidBreakRecord			AssertErr("lserrInvalidBreakRecord")
#define lserrInvalidPap					AssertErr("lserrInvalidPap")
#define lserrContradictoryQueryInput	AssertErr("lserrContradictoryQueryInput")
#define lserrLineIsNotActive			AssertErr("lserrLineIsNotActive")
#define lserrTooLongParagraph			AssertErr("lserrTooLongParagraph")
#else
#define lserrInvalidParameter			(-1L)
#define lserrOutOfMemory				(-2L)
#define lserrNullOutputParameter		(-3L)
#define lserrInvalidContext				(-4L)
#define lserrInvalidLine				(-5L)
#define lserrInvalidDnode				(-6L)
#define lserrInvalidDeviceResolution	(-7L)
#define lserrInvalidRun					(-8L)
#define lserrMismatchLineContext		(-9L)
#define lserrContextInUse				(-10L)
#define lserrDuplicateSpecialCharacter	(-11L)
#define lserrInvalidAutonumRun			(-12L)
#define lserrFormattingFunctionDisabled	(-13L)
#define lserrUnfinishedDnode			(-14L)
#define lserrInvalidDnodeType			(-15L)
#define lserrInvalidPenDnode			(-16L)
#define lserrInvalidNonPenDnode			(-17L)
#define lserrInvalidBaselinePenDnode	(-18L)
#define lserrInvalidFormatterResult		(-19L)
#define lserrInvalidObjectIdFetched		(-20L)
#define lserrInvalidDcpFetched			(-21L)
#define lserrInvalidCpContentFetched	(-22L)
#define lserrInvalidBookmarkType		(-23L)
#define lserrSetDocDisabled				(-24L)
#define lserrFiniFunctionDisabled		(-25L)
#define lserrCurrentDnodeIsNotTab		(-26L)
#define lserrPendingTabIsNotResolved    (-27L)
#define lserrWrongFiniFunction 			(-28L)
#define lserrInvalidBreakingClass		(-29L)
#define lserrBreakingTableNotSet		(-30L)
#define lserrInvalidModWidthClass		(-31L)
#define lserrModWidthPairsNotSet		(-32L)
#define lserrWrongTruncationPoint 		(-33L)
#define lserrWrongBreak 				(-34L)
#define	lserrDupInvalid					(-35L)
#define lserrRubyInvalidVersion			(-36L)
#define lserrTatenakayokoInvalidVersion	(-37L)
#define lserrWarichuInvalidVersion		(-38L)
#define lserrWarichuInvalidData			(-39L)
#define lserrCreateSublineDisabled		(-40L)
#define lserrCurrentSublineDoesNotExist	(-41L)
#define lserrCpOutsideSubline			(-42L)
#define lserrHihInvalidVersion			(-43L)
#define lserrInsufficientQueryDepth		(-44L)
#define lserrInsufficientBreakRecBuffer	(-45L)
#define lserrInvalidBreakRecord			(-46L)
#define lserrInvalidPap					(-47L)
#define lserrContradictoryQueryInput	(-48L)
#define lserrLineIsNotActive			(-49L)
#define lserrTooLongParagraph			(-50L)
#endif	/* LSERRORSTOP */


#ifndef fTrue
#define fTrue	1
#define fFalse	0
#endif

#define uLsInfiniteRM	0x3FFFFFFF

#define czaUnitInch					(1440L) /* 1440 absolute units per inch */

#endif /* LSDEFS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsdocinf.h ===
#ifndef LSDOCINF_DEFINED
#define LSDOCINF_DEFINED

#include "lsdefs.h"
#include "plsdocin.h"
#include "lsdevres.h"

typedef struct lsdocinf
{
	BOOL fDisplay;
	BOOL fPresEqualRef;
	LSDEVRES lsdevres;
} LSDOCINF;

#endif /* !LSDOCINF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsems.h ===
#ifndef LSEMS_DEFINED
#define LSEMS_DEFINED

#include "lsdefs.h"

typedef struct lsems
{
	long em;		/* one em			*/
	long em2;		/* half em			*/
	long em3;		/* third em			*/
	long em4;		/* quater em		*/
	long em8;		/* eighth em		*/
	long em16;		/* 15/16 of em		*/
	long udExp;		/* user defined expansion	*/
	long udComp;	/* user defined compression*/
} LSEMS;



#endif /* !LSEMS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsdsply.h ===
#ifndef LSDSPLY_DEFINED
#define LSDSPLY_DEFINED

#include "lsdefs.h"
#include "plsline.h"

LSERR WINAPI LsDisplayLine(PLSLINE, const POINT*, UINT, const RECT*);
/* LsDisplayLine
 *  pline (IN)
 *  ppt (IN)
 *  kDisp (IN): transparent or opaque
 *  &rcClip (IN): clipping rect
 */

#endif /* !LSDSPLY_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsdssubl.h ===
#ifndef LSDSSUBL_DEFINED
#define LSDSSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "plssubl.h"


LSERR WINAPI LsDisplaySubline(
							PLSSUBL,			/* IN: subline context			*/
							const POINT*,		/* IN: starting position(xp, yp)*/
							UINT,				/* IN: display mode, opaque, etc */
							const RECT*);		/* IN: clip rectangle (xp, yp,...) */

#endif /* !LSDSSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsensubl.h ===
#ifndef LSENSUBL_DEFINED
#define LSENSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "plssubl.h"


LSERR WINAPI LsEnumSubline(PLSSUBL,
						   BOOL,			/* IN: enumerate in reverse order?					*/
						   BOOL,			/* IN: geometry needed?								*/
						   const POINT*);	/* IN: starting position(xp, yp) iff fGeometryNeeded*/
#endif /* !LSENSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsexpan.h ===
#ifndef LSEXPAN_DEFINED
#define LSEXPAN_DEFINED

#include "lsdefs.h"
#include "lsact.h"

typedef struct lsexpan					/* expansion information unit		*/
{
	BYTE fFullScaled;					/* expand for full justification	*/
	BYTE fFullInterletter;				/* expand for distributed justification	*/
} LSEXPAN;									


#endif /* !LSEXPAN_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsexpinf.h ===
#ifndef LSEXPINF_DEFINED
#define LSEXPINF_DEFINED

#include "lsdefs.h"
#include "exptype.h"

#define lsexpinfInfinity	0x1FFFFF

/* ------------------------------------------------------------------------ */

struct lsexpinfo							/* Expansion info */
{
	long duMax;
	union
	{
		struct
		{
			long duMin;
		} AddInkContinuous;
	
		struct
		{
			DWORD cwidths;
		} AddInkDiscrete;

	} u;

	BYTE prior;
	BYTE fCanBeUsedForResidual;
	WORD pad;
};

typedef struct lsexpinfo LSEXPINFO;

#endif /* !LSEXPINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsesc.h ===
#ifndef LSESC_DEFINED
#define LSESC_DEFINED

/* Definition of Line Services escape characters.
 * Used for LsFetchDispatchEsc().
 */

#include "lsdefs.h"

typedef struct
{
	WCHAR wchFirst, wchLast;			/* Range of chars codes */
} LSESC;


#endif /* !LSESC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsffi.h ===
#ifndef LSFFI_DEFINED
#define LSFFI_DEFINED


/* Line Services "format flags" (from LSPAP ) */

/* Visi flags	*/
#define fFmiVisiCondHyphens			0x00000001L
#define fFmiVisiParaMarks			0x00000002L
#define fFmiVisiSpaces				0x00000004L
#define fFmiVisiTabs				0x00000008L
#define fFmiVisiSplats				0x00000010L
#define fFmiVisiBreaks				0x00000020L


/* Advanced typography enabling    */
#define fFmiPunctStartLine			0x00000040L
#define fFmiHangingPunct			0x00000080L
#define fFmiApplyBreakingRules		0x00000100L

/* WYSIWYG flags */
#define fFmiPresSuppressWiggle		0x00000200L
#define fFmiPresExactSync			0x00000400L

/* Autonumbering flags */
#define fFmiAnm						0x00000800L

/* Miscellaneous flags */
#define fFmiAutoDecimalTab			0x00001000L
#define fFmiUnderlineTrailSpacesRM	0x00002000L

#define fFmiSpacesInfluenceHeight	0x00004000L

#define fFmiIgnoreSplatBreak		0x00010000L
#define fFmiLimSplat				0x00020000L
#define fFmiAllowSplatLine			0x00040000L

#define	fFmiForceBreakAsNext		0x00080000L
#define fFmiFCheckTruncateBefore	0x00100000L

#define fFmiDoHyphenation			0x00200000L

#define fFmiDrawInCharCodes			0x00400000L

#define	fFmiTreatHyphenAsRegular	0x00800000L
#define fFmiWrapTrailingSpaces		0x01000000L
#define fFmiWrapAllSpaces			0x02000000L

/* Compatibility flags for bugs in older versions of WORD */
#define fFmiForgetLastTabAlignment	0x10000000L
#define fFmiIndentChangesHyphenZone	0x20000000L
#define fFmiNoPunctAfterAutoNumber	0x40000000L
#define fFmiResolveTabsAsWord97		0x80000000L

#endif /* !LSFFI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsenum.h ===
#ifndef LSENUM_DEFINED
#define LSENUM_DEFINED

#include "lsdefs.h"
#include "plsline.h"

LSERR WINAPI LsEnumLine(PLSLINE,
					   	BOOL,			/* IN: enumerate in reverse order?					*/
						BOOL,			/* IN: geometry needed?								*/
						const POINT*);	/* IN: starting position(xp, yp) iff fGeometryNeeded*/

#endif /* LSENUM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsfrun.h ===
#ifndef LSFRUN_DEFINED
#define LSFRUN_DEFINED

#include "lsdefs.h"
#include "plschp.h"
#include "plsrun.h"
#include "plsfrun.h"

struct lsfrun							/* Formatter run */
{
	PCLSCHP plschp;
	PLSRUN plsrun;
	LPCWSTR lpwchRun;
	DWORD cwchRun;
};
typedef struct lsfrun LSFRUN;

#endif /* !LSFRUN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsfgi.h ===
#ifndef LSFGI_DEFINED
#define LSFGI_DEFINED

#include "lsdefs.h"
#include "lstflow.h"
#include "plsfgi.h"

/* ------------------------------------------------------------------------ */

struct lsfgi							/* Formatter geometry input */
{
	BOOL fFirstOnLine;	/* REVIEW sergeyge(elik): Query instead of this member? */
	LSCP cpFirst;
	long urPen,vrPen;
	long urColumnMax;
	LSTFLOW lstflow;
};
typedef struct lsfgi LSFGI;

#endif /* !LSFGI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lshyph.h ===
#ifndef LSHYPH_DEFINED
#define LSHYPH_DEFINED

#include "lsdefs.h"
#include "plshyph.h"

struct lshyph							/* Output of pfnHyphenate callback */
{
	UINT kysr;							/* Kind of Ysr - see "lskysr.h" */
	LSCP cpYsr;							/* cp value of YSR */
	WCHAR wchYsr;						/* YSR char code  */
};

#endif /* !LSHYPH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lskeop.h ===
#ifndef LSKEOP_DEFINED
#define LSKEOP_DEFINED

enum lskeop							/* kinds of para ending */
{
	lskeopEndPara1,
	lskeopEndPara2,
	lskeopEndPara12,
	lskeopEndParaAlt
};

typedef enum lskeop LSKEOP;

#endif /* !LSKEOP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsimeth.h ===
#ifndef LSIMETH_DEFINED
#define LSIMETH_DEFINED

#include "lsdefs.h"

#include "plscbk.h"
#include "plsrun.h"
#include "pilsobj.h"
#include "plnobj.h"
#include "pdobj.h"
#include "pfmti.h"
#include "pbrko.h"
#include "pobjdim.h"
#include "pdispi.h"
#include "plsdocin.h"
#include "pposichn.h"
#include "plocchnk.h"
#include "plsfgi.h"
#include "pheights.h"
#include "plsqin.h"
#include "plsqout.h"
#include "plssubl.h"
#include "plschp.h"
#include "lstflow.h"
#include "lskjust.h"
#include "breakrec.h"
#include "brkcond.h"
#include "brkkind.h"
#include "fmtres.h"
#include "mwcls.h"

typedef struct
{
	LSERR (WINAPI* pfnCreateILSObj)(POLS, PLSC,  PCLSCBK, DWORD, PILSOBJ*);
	/* CreateILSObj
	 *  pols (IN):
	 *  plsc (IN): LS context
	 *  plscbk (IN): callbacks
	 *  idObj (IN): id of the object
	 *  &pilsobj (OUT): object ilsobj
	*/

	LSERR (WINAPI* pfnDestroyILSObj)(PILSOBJ);
	/* DestroyILSObj
	 *  pilsobj (IN): object ilsobj
	*/

	LSERR (WINAPI* pfnSetDoc)(PILSOBJ, PCLSDOCINF);
	/* SetDoc
	 *  pilsobj (IN): object ilsobj
	 *  lsdocinf (IN): initialization data at document level
	*/

	LSERR (WINAPI* pfnCreateLNObj)(PCILSOBJ, PLNOBJ*);
	/* CreateLNObj
	 *  pilsobj (IN): object ilsobj
	 *  &plnobj (OUT): object lnobj
	*/

	LSERR (WINAPI* pfnDestroyLNObj)(PLNOBJ);
	/* DestroyLNObj
	 *  plnobj (OUT): object lnobj
	*/

	LSERR (WINAPI* pfnFmt)(PLNOBJ, PCFMTIN, FMTRES*);
	/* Fmt
	 *  plnobj (IN): object lnobj
	 *  pfmtin (IN): formatting input
	 *  &fmtres (OUT): formatting result
	*/

	LSERR (WINAPI* pfnFmtResume)(PLNOBJ, const BREAKREC*, DWORD, PCFMTIN, FMTRES*);
	/* FmtResume
	 *  plnobj (IN): object lnobj
	 *  rgBreakRecord (IN): array of break records
	 *	nBreakRecord (IN): size of the break records array
	 *  pfmtin (IN): formatting input
	 *  &fmtres (OUT): formatting result
	*/

	LSERR (WINAPI* pfnGetModWidthPrecedingChar)(PDOBJ, PLSRUN, PLSRUN, PCHEIGHTS, WCHAR, MWCLS, long*);
	/* GetModWidthPrecedingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the preceding char
     *  heightsRef (IN): height info about character
	 *  wchar (IN): preceding character
	 *  mwcls (IN): ModWidth class of preceding character
	 *  &durChange (OUT): amount by which width of the preceding char is to be changed
	*/

	LSERR (WINAPI* pfnGetModWidthFollowingChar)(PDOBJ, PLSRUN, PLSRUN, PCHEIGHTS, WCHAR, MWCLS, long*);
	/* GetModWidthPrecedingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the following char
     *  heightsRef (IN): height info about character
	 *  wchar (IN): following character
	 *  mwcls (IN): ModWidth class of the following character
	 *  &durChange (OUT): amount by which width of the following char is to be changed
	*/

	LSERR (WINAPI* pfnTruncateChunk)(PCLOCCHNK, PPOSICHNK);
	/* Truncate
	 *  plocchnk (IN): locchnk to truncate
	 *  posichnk (OUT): truncation point
	*/

	LSERR (WINAPI* pfnFindPrevBreakChunk)(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
	/* FindPrevBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  brkcond (IN): recommmendation about the break after chunk
	 *  &brkout (OUT): results of breaking
	*/

	LSERR (WINAPI* pfnFindNextBreakChunk)(PCLOCCHNK, PCPOSICHNK, BRKCOND, PBRKOUT);
	/* FindNextBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  brkcond (IN): recommmendation about the break before chunk
	 *  &brkout (OUT): results of breaking
	*/

	LSERR (WINAPI* pfnForceBreakChunk)(PCLOCCHNK, PCPOSICHNK, PBRKOUT);
	/* ForceBreakChunk
	 *  plocchnk (IN): locchnk to break
	 *  pposichnk (IN): place to start looking for break
	 *  &brkout (OUT): results of breaking
	*/

	LSERR (WINAPI* pfnSetBreak)(PDOBJ, BRKKIND, DWORD, BREAKREC*, DWORD*);
	/* SetBreak
	 *  pdobj (IN): dobj which is broken
	 *  brkkind (IN): Previous/Next/Force/Imposed was chosen
	 *	nBreakRecord (IN): size of array
	 *  rgBreakRecord (OUT): array of break records
	 *	nActualBreakRecord (OUT): actual number of used elements in array
	*/

	LSERR (WINAPI* pfnGetSpecialEffectsInside)(PDOBJ, UINT*);
	/* GetSpecialEffects
	 *  pdobj (IN): dobj
	 *  &EffectsFlags (OUT): Special effects inside of this object
	*/

	LSERR (WINAPI* pfnFExpandWithPrecedingChar)(PDOBJ, PLSRUN, PLSRUN, WCHAR, MWCLS, BOOL*);
	/* FExpandWithPrecedingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the preceding char
	 *  wchar (IN): preceding character
	 *  mwcls (IN): ModWidth class of preceding character
	 *  &fExpand (OUT): expand preceding character?
	*/

	LSERR (WINAPI* pfnFExpandWithFollowingChar)(PDOBJ, PLSRUN, PLSRUN, WCHAR, MWCLS, BOOL*);
	/* FExpandWithFollowingChar
	 *  pdobj (IN): dobj
     *  plsrun (IN): plsrun of the object
     *  plsrunText (IN): plsrun of the following char
	 *  wchar (IN): following character
	 *  mwcls (IN): ModWidth class of the following character
	 *  &fExpand (OUT): expand object?
	*/
	LSERR (WINAPI* pfnCalcPresentation)(PDOBJ, long, LSKJUST, BOOL);
	/* CalcPresentation
	 *  pdobj (IN): dobj
	 *  dup (IN): dup of dobj
	 *  lskj (IN): current justification mode
	 *  fLastVisibleOnLine (IN): this object is last visible object on line
	*/

	LSERR (WINAPI* pfnQueryPointPcp)(PDOBJ, PCPOINTUV, PCLSQIN, PLSQOUT);
	/* QueryPointPcp
	 *  pdobj (IN): dobj to query
	 * 	ppointuvQuery (IN): query point (uQuery,vQuery)
     *	plsqin (IN): query input
     *	plsqout (OUT): query output
	*/
	
	LSERR (WINAPI* pfnQueryCpPpoint)(PDOBJ, LSDCP, PCLSQIN, PLSQOUT);
	/* QueryCpPpoint
	 *  pdobj (IN): dobj to query
	 *  dcp (IN):  dcp for the query
     *	plsqin (IN): query input
     *	plsqout (OUT): query output
	*/

	LSERR (WINAPI* pfnEnum)(PDOBJ, PLSRUN, PCLSCHP, LSCP, LSDCP, LSTFLOW, BOOL,
												BOOL, const POINT*, PCHEIGHTS, long);
	/* Enum object
	 *  pdobj (IN): dobj to enumerate
	 *  plsrun (IN): from DNODE
	 *  plschp (IN): from DNODE
	 *  cpFirst (IN): from DNODE
	 *  dcp (IN): from DNODE
	 *  lstflow (IN): text flow
	 *  fReverseOrder (IN): enumerate in reverse order
	 *  fGeometryNeeded (IN):
	 *  pptStart (IN): starting position, iff fGeometryNeeded
	 *  pheightsPres(IN): from DNODE, relevant iff fGeometryNeeded
	 *  dupRun(IN): from DNODE, relevant iff fGeometryNeeded
	*/

	LSERR (WINAPI* pfnDisplay)(PDOBJ, PCDISPIN);
	/* Display
	 *  pdobj (IN): dobj to display
	 *  pdispin (IN): input display info
	*/

	LSERR (WINAPI* pfnDestroyDObj)(PDOBJ);
	/* DestroyDObj
	 *  pdobj (IN): dobj to destroy
	*/

} LSIMETHODS;

#endif /* LSIMETH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lskjust.h ===
#ifndef LSKJUST_DEFINED
#define LSKJUST_DEFINED

enum lskjust							/* kinds of para justification */
{
	lskjNone,
	lskjFullInterWord,
	lskjFullInterLetterAligned,
	lskjFullScaled,
	lskjFullGlyphs,
	lskjSnapGrid
};

typedef enum lskjust LSKJUST;

#endif /* !LSKJUST_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lskalign.h ===
#ifndef LSKALIGN_DEFINED
#define LSKALIGN_DEFINED

enum lskalign							/* kinds of para alignment */
{
	lskalLeft,
	lskalCentered,
	lskalRight,
};

typedef enum lskalign LSKALIGN;

#endif /* !LSKALIGN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lskysr.h ===
#ifndef LSKYSR_DEFINED
#define LSKYSR_DEFINED

/* kysr codes: for LSCHP.kysr - Kind of YSR */
#define	kysrNil				0		/* No Hyphenation				*/
#define kysrNormal			1		/* Normal Hyphenation			*/
#define kysrAddBefore		2		/* Add letter before hyphen		*/
#define kysrChangeBefore	3		/* Change letter before hyphen	*/
#define kysrDeleteBefore	4		/* Delete letter before hyphen	*/
#define kysrChangeAfter		5		/* Change letter after hyphen	*/
#define kysrDelAndChange	6		/* Delete letter before the hyphen and */
									/* change the letter preceding the ... */

#endif /* !LSKYSR_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lslinfo.h ===
#ifndef LSLINFO_DEFINED
#define LSLINFO_DEFINED

#include "lsdefs.h"
#include "endres.h"

typedef struct
{
	long dvpAscent;
	long dvrAscent;
	long dvpDescent;
	long dvrDescent;

	long dvpMultiLineHeight;
	long dvrMultiLineHeight;

	long dvpAscentAutoNumber;
	long dvrAscentAutoNumber;
	long dvpDescentAutoNumber;
	long dvrDescentAutoNumber;

	LSCP cpLim;					/* First cp which is NOT on this line */
	LSDCP dcpDepend;			/* # of chars wrapped to next line  */
	LSCP cpFirstVis;			/* First actual (not hidden) character in a line*/
								/* allows client to use character properties from the correct paragraph */


	ENDRES endr;				/* How line ended */
	BOOL fAdvanced;
	long vaAdvance;				/* Valid iff (fAdvanced != 0) */

	BOOL fFirstLineInPara;
	BOOL fTabInMarginExLine;
	BOOL fForcedBreak;

	DWORD nDepthFormatLineMax;  /* Formatting depth of the line (1--for plain line) */

	UINT EffectsFlags;			/* set of client defined special effects flags */
} LSLINFO;

#endif /* !LSLINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsksplat.h ===
#ifndef LSKSPLAT_DEFINED
#define LSKSPLAT_DEFINED

enum lsksplat							/* Kind of splat */
{
	lsksplPageBreak,
	lsksplColumnBreak,
	lsksplSectionBreak
};

#endif /* !LSKSPLAT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsktab.h ===
#ifndef LSKTAB_DEFINED
#define LSKTAB_DEFINED

#include "lsdefs.h"


enum lsktab								/* Kinds of tabs */
{
	lsktLeft,
	lsktCenter,
	lsktRight,
	lsktDecimal,
	lsktChar
};

typedef enum lsktab LSKTAB;


#endif  /* !LSKTAB_DEFINED     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lspairac.h ===
#ifndef LSPAIRAC_DEFINED
#define LSPAIRAC_DEFINED

#include "lsdefs.h"
#include "lsact.h"


typedef struct lspairact				/* Mod width pair unit				*/
{
	LSACT lsactFirst;					/* Action on first char				*/
	LSACT lsactSecond;					/* Action on second char			*/
} LSPAIRACT;									


#endif /* !LSPAIRAC_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsqin.h ===
#ifndef LSQIN_DEFINED
#define LSQIN_DEFINED

#include "lsdefs.h"
#include "heights.h"
#include "lstflow.h"
#include "plsrun.h"
#include "plsqin.h"

typedef struct lsqin			
{
	LSTFLOW	lstflowSubline;
	PLSRUN plsrun;					/* PLSRUN this cp belongs to */
	LSCP cpFirstRun;
	LSDCP dcpRun;
	HEIGHTS	heightsPresRun;			/* In direction lstflowSubline */
	long dupRun;					/* In direction lstflowSubline			*/
	long dvpPosRun;					/* in direction of lstflowSubline	*/

} LSQIN;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsqline.h ===
#ifndef LSQLINE_DEFINED
#define LSQLINE_DEFINED

#include "lsdefs.h"
#include "plsline.h"
#include "plsqsinf.h"
#include "plscell.h"
#include "pcelldet.h"
#include "gprop.h"

LSERR WINAPI  LsQueryLineCpPpoint(
							PLSLINE,	/* IN: pointer to line info -- opaque to client	*/
							LSCP,		/* IN: cpQuery									*/
							DWORD,      /* IN: nDepthQueryMax							*/
							PLSQSUBINFO,/* OUT: array[nDepthQueryMax] of LSQSUBINFO		*/
							DWORD*,		 /* OUT: nActualDepth							*/
							PLSTEXTCELL);/* OUT: Text cell info							*/


LSERR WINAPI LsQueryLinePointPcp(
							PLSLINE,	/* IN: pointer to line -- opaque to client			*/
						 	PCPOINTUV,	/* IN: query point (uQuery,vQuery) (line text flow)	*/
							DWORD,      /* IN: nDepthQueryMax								*/
							PLSQSUBINFO,/* OUT: array[nDepthQueryMax] of LSQSUBINFO			*/
							DWORD*,      /* OUT: nActualDepth	*/
							PLSTEXTCELL);/* OUT: Text cell info */

LSERR WINAPI LsQueryTextCellDetails(
							PLSLINE,	/* IN: pointer to line -- opaque to client				*/
						 	PCELLDETAILS,/* IN: query point (uQuery,vQuery) (line text flow)	*/
							LSCP,		/* IN: cpStartCell										*/
							DWORD,		/* IN: nCharsInContext									*/
							DWORD,		/* IN: nGlyphsInContext									*/
							WCHAR*,		/* OUT: pointer array[nCharsInContext] of char codes	*/
							PGINDEX,	/* OUT: pointer array[nGlyphsInContext] of glyph indices*/
							long*,		/* OUT: pointer array[nGlyphsInContext] of glyph widths	*/
							PGOFFSET,	/* OUT: pointer array[nGlyphsInContext] of glyph offsets*/
							PGPROP);	/* OUT: pointer array[nGlyphsInContext] of glyph handles*/

/*
 *	Query point and output point are in the coordinate system of the line.
 *	Text flow is the text flow of the line, zero point is at the starting point of the line. 
 */


LSERR WINAPI LsQueryLineDup(PLSLINE,	/* IN: pointer to line -- opaque to client	*/
							long*,		/* OUT: upStartAutonumberingText			*/
							long*,		/* OUT: upLimAutonumberingText				*/
							long*,		/* OUT: upStartMainText						*/
							long*,		/* OUT: upStartTrailing						*/
							long*);		/* OUT: upLimLine							*/

LSERR WINAPI LsQueryFLineEmpty(
							PLSLINE,	/* IN: pointer to line -- opaque to client 	*/
							BOOL*);		/* OUT: Is line empty? 						*/

#endif /* !LSQLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lspract.h ===
#ifndef LSPRACT_DEFINED
#define LSPRACT_DEFINED

#include "lsdefs.h"
#include "lsact.h"

#define prior0					0		/* means priority is not defined	*/
#define prior1					1
#define prior2					2
#define prior3					3
#define prior4					4
#define prior5					5

typedef struct lspract					/* prioritized action 				*/
{
	BYTE prior;							/* priority							*/
	LSACT lsact;						/* action							*/
} LSPRACT;									


#endif /* !LSPRACTION_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsqout.h ===
#ifndef LSQOUT_DEFINED
#define LSQOUT_DEFINED

#include "lsdefs.h"
#include "heights.h"
#include "lscell.h"
#include "plssubl.h"
#include "plsqout.h"


typedef struct lsqout			
{
 	POINTUV pointUvStartObj;		/* In coordinate system of parent subline
										relative to the beginning of dnode	*/
	HEIGHTS	heightsPresObj;			/* In direction of parent subline */
	long dupObj;					/* In direction lstflowSubline			*/

	LSTEXTCELL lstextcell;			/* in coordinate system of parent subline,
										relative to the beginning of dnode	*/

	PLSSUBL plssubl;
 	POINTUV pointUvStartSubline;	/* In coordinate system of parent subline
										relative to the beginning of dnode	*/

} LSQOUT;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsqsubl.h ===
#ifndef LSQSUBL_DEFINED
#define LSQSUBL_DEFINED

/* Line services formatter fetch/dispatcher interface (to LsCreateLine())
 */

#include "lsdefs.h"
#include "plssubl.h"
#include "plsqsinf.h"
#include "plscell.h"

LSERR WINAPI LsQueryCpPpointSubline(
							PLSSUBL,		/* IN: subline context			*/
							LSCP, 			/* IN: cpQuery 					*/
							DWORD,      	/* IN: nDepthQueryMax			*/
							PLSQSUBINFO,	/* OUT: array[nDepthQueryMax] of LSQSUBINFO	*/
							DWORD*,			/* OUT: nActualDepth			*/
							PLSTEXTCELL);	/* OUT: Text cell info			*/
							
LSERR WINAPI LsQueryPointPcpSubline(
							PLSSUBL,		/* IN: subline context			*/
						 	PCPOINTUV,		/* IN: query point from the subline beginning */
							DWORD,      	/* IN: nDepthQueryMax			*/
							PLSQSUBINFO,	/* OUT: array[nDepthQueryMax] of LSQSUBINFO */
							DWORD*,		 	/* OUT: nActualDepth			*/
							PLSTEXTCELL);	/* OUT: Text cell info			*/


#endif /* !LSQSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lspap.h ===
#ifndef LSPAP_DEFINED
#define LSPAP_DEFINED

#include "lsdefs.h"
#include "plspap.h"
#include "lskjust.h"
#include "lskalign.h"
#include "lsbrjust.h"
#include "lskeop.h"
#include "lstflow.h"

/* ---------------------------------------------------------------------- */

struct lspap
{
	LSCP cpFirst;						/* 1st cp for this paragraph */
	LSCP cpFirstContent;				/* 1st cp of "content" in the para */

	DWORD grpf;							/* line services format flags (lsffi.h)*/

	long uaLeft;						/* left boundary for line				*/
	long uaRightBreak;					/* right boundary for break */
	long uaRightJustify;					/* right boundary for justification */
	long duaIndent;
	long duaHyphenationZone;

	LSBREAKJUST lsbrj;					/* Break/Justification behavior	*/
	LSKJUST lskj;						/* Justification type */
	LSKALIGN lskal;						/* Alignment type */

	long duaAutoDecimalTab;

	LSKEOP lskeop;						/* kind of paragraph ending */
	
	LSTFLOW lstflow;					/* Main text flow direction */

};

typedef struct lspap LSPAP;

#endif /* !LSPAP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsqsinfo.h ===
#ifndef LSQSINFO_DEFINED
#define LSQSINFO_DEFINED

#include "lsdefs.h"
#include "heights.h"
#include "lstflow.h"
#include "plsrun.h"
#include "plsqsinf.h"


typedef struct lsqsubinfo			
{
	LSTFLOW	lstflowSubline;
	LSCP cpFirstSubline;
	LSDCP dcpSubline;
 	POINTUV pointUvStartSubline;	/* In coordinate system of main line/subline */
	HEIGHTS	heightsPresSubline;		/* In direction lstflowSubline */
	long dupSubline;				/* In direction lstflowSubline			*/


	DWORD idobj;
	PLSRUN plsrun;
	LSCP cpFirstRun;
	LSDCP dcpRun;
 	POINTUV pointUvStartRun;		/* In coordinate system of main line/subline */
	HEIGHTS	heightsPresRun;			/* In direction lstflowSubline */
	long dupRun;					/* In direction lstflowSubline			*/
	long dvpPosRun;					/* in direction of lstflowSubline	*/

	long dupBorderBefore;			/* in direction of lstflowSubline	*/
	long dupBorderAfter;			/* in direction of lstflowSubline	*/

 	POINTUV pointUvStartObj;		/* Set by Object, translated to coord system of main line/subline */
	HEIGHTS	heightsPresObj;			/* Set by Object, in direction lstflowSubline */
	long dupObj;					/* Set by Object, in direction lstflowSubline			*/


} LSQSUBINFO;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsstinfo.h ===
#ifndef LSSTINFO_DEFINED
#define LSSTINFO_DEFINED

#include "lsdefs.h"
#include "plsstinf.h"

/* 
 * all strikethrough offsets are relative to the baseline and positive upwards (filled page direction),
 * so normally dvpLowerStrikethroughOffset > 0 and if cNumberOfLines == 2
 * dvpLowerStrikethroughOffset < dvpUpperStrikethroughOffset
 */

struct lsstinfo
{
    UINT  kstbase;						/* base kind of strikethrough  */
    DWORD cNumberOfLines;				/* number of lines: possible values 1,2*/

	long dvpLowerStrikethroughOffset ;	/* if NumberOfLines != 2 only data for 
											lower line should be filled in */
	long dvpLowerStrikethroughSize;
	long dvpUpperStrikethroughOffset;	
	long dvpUpperStrikethroughSize;

};
typedef struct lsstinfo LSSTINFO;


#endif /* !LSSTINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lstabs.h ===
#ifndef LSTABS_DEFINED
#define LSTABS_DEFINED

#include "lsdefs.h"
#include "lsktab.h"

/* ---------------------------------------------------------------------- */


/* ---------------------------------------------------------------------- */

typedef struct
{
	enum lsktab lskt;					/* Kind of tab */
	long ua;							/* tab position */
	WCHAR wchTabLeader;					/* character for tab leader */
										/*   if 0, no leader is used*/
	WCHAR wchCharTab;					/* Character for CharTab	*/
} LSTBD;

/* ---------------------------------------------------------------------- */

typedef struct lstabs
{
	long duaIncrementalTab;				/* "Default" tab behavior */
	DWORD iTabUserDefMac;
	LSTBD* pTab;				
} LSTABS;


#endif /* !LSTABS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lssubset.h ===
#ifndef LSSUBSET_DEFINED
#define LSSUBSET_DEFINED

/* Access routines for contents of DNODES */

#include "lsdefs.h"
#include "plsrun.h"
#include "plssubl.h"
#include "pobjdim.h"
#include "lstflow.h"

			
LSERR WINAPI LssbGetObjDimSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							LSTFLOW*,			/* OUT: subline's lstflow		*/
					 	    POBJDIM);			/* OUT: dimensions of subline	*/
							
LSERR WINAPI LssbGetDupSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							LSTFLOW*,			/* OUT: subline's lstflow		*/
					 	    long*);				/* OUT: dup of subline			*/

LSERR WINAPI LssbFDonePresSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							BOOL*);				/* OUT: Is it CalcPres'd		*/

LSERR WINAPI LssbFDoneDisplay(
							PLSSUBL,			/* IN: Subline Context			*/
							BOOL*);				/* OUT: Is it displayed			*/

LSERR WINAPI LssbGetPlsrunsFromSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							DWORD,				/* IN: N of DNODES in subline	*/
							PLSRUN*);			/* OUT: array of PLSRUN's		*/

LSERR WINAPI LssbGetNumberDnodesInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							DWORD*);			/* OUT: N of DNODES in subline	*/

LSERR WINAPI LssbGetVisibleDcpInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							LSDCP*);			/* OUT: N of characters			*/

LSERR WINAPI LssbGetDurTrailInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							long*);				/* OUT: width of trailing area	*/
	
LSERR WINAPI LssbGetDurTrailWithPensInSubline(
							PLSSUBL,			/* IN: Subline Context			*/
							long*);				/* OUT: width of trailing area
													including pens in subline	*/
LSERR WINAPI LssbFIsSublineEmpty(
							PLSSUBL plssubl,	/* IN: subline					*/
							BOOL*  pfEmpty);	/* OUT:is this subline empty	*/


#endif /* !LSSUBSET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lstfset.h ===
#ifndef LSTFSET_DEFINED
#define LSTFSET_DEFINED

/* Service routines for some standard text flow change tasks */

#include "lsdefs.h"
#include "lstflow.h"

/* 
 * LsPointXYFromPointUV calculates pointxyOut given (x,y) pointxyIn and (u,v) vector 
 *  
 *  (pointxyOut = pointxyIn + vectoruv)
 */

LSERR WINAPI LsPointXYFromPointUV(const POINT*, 	/* IN: input point (x,y) */
									LSTFLOW,	 	/* IN: text flow for */
									PCPOINTUV,		/* IN: vector in (u,v) */
									POINT*);		/* OUT: (x,y) point */


/* 
 * LsPointUV1FromPointUV2 calculates vector in uv2 coordinates given begin and end of it in uv1.
 *  
 *  (vectorUV22 = pointUV1b - pointUV1a)
 *
 *	Usually pointUV1a is the starting point of uv2 coordinate system and it is easier to think 
 *		about output vector as a point in it.
 */

LSERR WINAPI LsPointUV2FromPointUV1(LSTFLOW,	 	/* IN: text flow 1 (TF1) */
									PCPOINTUV,	 	/* IN: starting point (TF1) */
									PCPOINTUV,		/* IN: ending point (TF1) */
									LSTFLOW,	 	/* IN: text flow 2 (TF2) */
									PPOINTUV);		/* OUT: vector in TF2 */


#endif /* !LSTFSET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lssetdoc.h ===
#ifndef LSSETDOC_DEFINED
#define LSSETDOC_DEFINED

#include "lsdefs.h"
#include "lsdevres.h"
#include "lspract.h"
#include "lspairac.h"
#include "lsexpan.h"
#include "lsbrk.h"

LSERR WINAPI LsSetDoc(PLSC,				/* IN: ptr to line services context */
					  BOOL,				/* IN: Intend to display? 			*/
					  BOOL,				/* IN: Ref & Pres Devices are equal?*/
					  const LSDEVRES*); /* IN: device resolutions 			*/

LSERR WINAPI LsSetModWidthPairs(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of mod pairs info units*/ 
					  const LSPAIRACT*,	/* IN: Mod pairs info units array  */
					  DWORD,			/* IN: Number of Mod Width classes	*/
					  const BYTE*);		/* IN: Mod width information(square):
											  indexes in the LSPAIRACT array */
LSERR WINAPI LsSetCompression(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of compression priorities*/
					  DWORD,			/* IN: Number of compression info units*/
					  const LSPRACT*,	/* IN: Compession info units array 	*/
					  DWORD,			/* IN: Number of Mod Width classes	*/
					  const BYTE*);		/* IN: Compression information:
											  indexes in the LSPRACT array  */
LSERR WINAPI LsSetExpansion(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of expansion info units*/
					  const LSEXPAN*,	/* IN: Expansion info units array	*/
					  DWORD,			/* IN: Number of Mod Width classes	*/
					  const BYTE*);		/* IN: Expansion information(square):
											  indexes in the LSEXPAN array  */
LSERR WINAPI LsSetBreaking(
					  PLSC,				/* IN: ptr to line services context */
					  DWORD,			/* IN: Number of breaking info units*/
					  const LSBRK*,		/* IN: Breaking info units array	*/
					  DWORD,			/* IN: Number of breaking classes	*/
					  const BYTE*);		/* IN: Breaking information(square):
											  indexes in the LSBRK array  */


#endif /* !LSSETDOC_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lstxm.h ===
#ifndef LSTXM_DEFINED
#define LSTXM_DEFINED

#include "lsdefs.h"
#include "plstxm.h"
/*igorzv** good explanation according text flow issue is needed here /
/* A few words about the v-vector and the sign bit: 
 *
 * dvDescent is positive downwards.		
 * v is positive upwards during formatting.
 */

struct lstxm
{
	long dvAscent;
	long dvDescent;

	long dvMultiLineHeight;
	BOOL fMonospaced;
};
typedef struct lstxm LSTXM;


#endif /* !LSTXM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lstxtcfg.h ===
#ifndef LSTXTCFG_DEFINED
#define LSTXTCFG_DEFINED

#include "lsdefs.h"
#include "plstxtcf.h"

typedef struct lstxtcfg
{
	long cEstimatedCharsPerLine;

	WCHAR wchUndef;
	WCHAR wchNull;
	WCHAR wchSpace;
	WCHAR wchHyphen;
	WCHAR wchTab;
	WCHAR wchEndPara1;
	WCHAR wchEndPara2;
	WCHAR wchAltEndPara;
	WCHAR wchEndLineInPara;				/* Word "CCRJ", */
	WCHAR wchColumnBreak;
	WCHAR wchSectionBreak;
	WCHAR wchPageBreak;
	WCHAR wchNonBreakSpace;				/* char code of non-breaking space */
	WCHAR wchNonBreakHyphen;
	WCHAR wchNonReqHyphen;				/* discretionary hyphen */
	WCHAR wchEmDash;
	WCHAR wchEnDash;
	WCHAR wchEmSpace;
	WCHAR wchEnSpace;
	WCHAR wchNarrowSpace;
	WCHAR wchOptBreak;
	WCHAR wchNoBreak;
	WCHAR wchFESpace;
	WCHAR wchJoiner;
	WCHAR wchNonJoiner;
	WCHAR wchToReplace;					/* backslash in FE Word				*/
	WCHAR wchReplace;					/* Yen in FE Word				*/


	WCHAR wchVisiNull;					/* visi char for wch==wchNull		*/
	WCHAR wchVisiAltEndPara;			/* visi char for end "table cell"	*/
	WCHAR wchVisiEndLineInPara;			/* visi char for wchEndLineInPara	*/
	WCHAR wchVisiEndPara;				/* visi char for "end para"			*/
	WCHAR wchVisiSpace;					/* visi char for "space"			*/
	WCHAR wchVisiNonBreakSpace;			/* visi char for wchNonBreakSpace	*/
	WCHAR wchVisiNonBreakHyphen;		/* visi char for wchNonBreakHyphen	*/
	WCHAR wchVisiNonReqHyphen;			/* visi char for wchNonReqHyphen	*/
	WCHAR wchVisiTab;					/* visi char for "tab"				*/
	WCHAR wchVisiEmSpace;				/* visi char for wchEmSpace			*/
	WCHAR wchVisiEnSpace;				/* visi char for wchEnSpace			*/
	WCHAR wchVisiNarrowSpace;			/* visi char for wchNarrowSpace		*/
	WCHAR wchVisiOptBreak;              /* visi char for wchOptBreak		*/
	WCHAR wchVisiNoBreak;				/* visi char for wchNoBreak			*/
	WCHAR wchVisiFESpace;				/* visi char for wchOptBreak		*/

	WCHAR wchEscAnmRun;

	WCHAR wchPad;
} LSTXTCFG;

#endif /* !LSTXTCFG_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lstflow.h ===
#ifndef LSTFLOW_DEFINED
#define LSTFLOW_DEFINED

#include "lsdefs.h"

typedef DWORD  LSTFLOW;

#define lstflowDefault	0  

#define lstflowES		0  
#define lstflowEN		1  
#define lstflowSE		2  
#define lstflowSW		3  
#define lstflowWS		4  
#define lstflowWN		5  
#define lstflowNE		6  
#define lstflowNW		7  

/*
 *	The eight possible text flows are listed clockwise starting with default (Latin) one.
 *
 *	lstflowES is the coordinate system used when line grows to East and text grows to South.
 *	(Next letter is to the right (east) of previous, next line is created below (south) the previous.) 
 *
 *	For lstflowES positive u moves to the right, positive v moves up. (V axis is always in the direction
 *	of ascender, opposite to text growing direction.
 *
 *	Notice it is not the way axes are pointing in the default Windows mapping mode MM_TEXT. 
 *	In MM_TEXT vertical (y) axis increase from top to bottom, 
 *	in lstflowES vertical (v) axis increase from bottom to top.
 */
 
#define fUDirection			0x00000004L
#define fVDirection			0x00000001L
#define fUVertical			0x00000002L

/*
 *	The three bits that constitute lstflow happens to have well defined meanings.
 *
 *	Middle bit: on for vertical writing, off for horizontal.
 *	First (low value) bit: "on" means v-axis points right or down (positive).
 *	Third bit: "off" means u-axis points right or down (positive).
 *
 * See examples of usage in lstfset.c
 *
 */


#endif /* !LSTFLOW_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\mwcls.h ===
#ifndef MWCLS_DEFINED
#define MWCLS_DEFINED

#include "lsdefs.h"

typedef BYTE MWCLS;

#endif /* !MWCLS_DEFINED                         */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\objdim.h ===
#ifndef OBJDIM_DEFINED
#define OBJDIM_DEFINED

#include "lsdefs.h"
#include "pobjdim.h"
#include "heights.h"

typedef struct objdim							/* Object dimensions */
{
	HEIGHTS heightsRef;	
	HEIGHTS heightsPres;	
	long dur;
} OBJDIM;

#endif /* !OBJDIM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\lsulinfo.h ===
#ifndef LSULINFO_DEFINED
#define LSULINFO_DEFINED

#include "lsdefs.h"
#include "plsulinf.h"

/* 
 * Both Offsets are relative to the local baseline and positive "down" (towards blank page), 
 * so in horizontal Latin case dvpFirstUnderlineOffset usually is bigger than zero. 
 *
 * dvpUnderlineOrigin points to UnderlineOrigin - the place where (main part of the) letter ends and 
 * area for underlining begins. For Latin letters it is the Latin baseline. UnderlineOrigin shows if
 * one run of two runs is higher; runs with the same UnderlineOrigin can have their underlines averaged.
 *
 * dvpFirstUnderlineOffset points to the beginning of the closest to the UnderlineOrigin underline.
 * You have "underlining from above" case if dvpUnderlineOrigin > dvpFirstUnderlineOffset.
 *
 * Everything else should be positive. Instead of dvpSecondUnderlineOffset of the previous version dvpGap 
 * is used. Second underline is further away from the UnderlineOrigin than first underline, so
 * dvpSecondUnderlineOffset = dvpFirstUnderlineOffset + dvpFirstUnderlineSize + dvpGap in normal case.
 * In "underlining from above" case there will be minuses instead of pluses.
 *
 * Main merging rules: 
 *
 * LS will not merge runs with different kulbase or different cNumberOfLines.
 * LS will not merge runs with different negative dvpPos (subscripts)
 * LS will not merge subscripts with superscripts or baseline runs
 * LS will not merge "underlined above" run with "underlined below" run.
 *
 * If merging is possible: 
 * Runs with the same UnderlineOrigin are averaged.
 * If UnderlineOrigins are different, the run with higher UnderlineOrigin takes metrics from neighbor.
 */

struct lsulinfo
{
    UINT  kulbase;						/* base kind of underline */
    DWORD cNumberOfLines;				/* number of lines: possible values 1,2*/

	long dvpUnderlineOriginOffset;		/* UnderlineOrigin decides which run is higher */
	long dvpFirstUnderlineOffset;		/* offset for start of the (first) underline */
	long dvpFirstUnderlineSize;			/* width of the (first) underline */
	
	long dvpGapBetweenLines;			/* If NumberOfLines != 2, dvpGapBetweenLines */
	long dvpSecondUnderlineSize;		/* 	and dvpSecondUnderlineSize are ignored. */
	
};
typedef struct lsulinfo LSULINFO;


#endif /* !LSULINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\pcelldet.h ===
#ifndef PCELLDET_DEFINED
#define PCELLDET_DEFINED

struct celldetails;
typedef struct celldetails* PCELLDETAILS;

#endif /* !PCELLDET_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\pbrko.h ===
#ifndef PBRKO_DEFINED
#define PBRKO_DEFINED

struct brkout;
typedef struct brkout* PBRKOUT;

#endif /* !PBRKO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\pdispi.h ===
#ifndef PDISPI_DEFINED
#define PDISPI_DEFINED

struct dispin;
typedef const struct dispin *PCDISPIN;

#endif /* !PDISPI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\pfmti.h ===
#ifndef PFMTI_DEFINED
#define PFMTI_DEFINED

struct fmtin;
typedef const struct fmtin *PCFMTIN;

#endif /* !PFMTI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\pdobj.h ===
#ifndef PDOBJ_DEFINED
#define PDOBJ_DEFINED

struct dobj;
typedef struct dobj* PDOBJ;

#endif /* PDOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\pilsobj.h ===
#ifndef PILSOBJ_DEFINED
#define PILSOBJ_DEFINED

struct ilsobj;

typedef struct ilsobj* PILSOBJ;
typedef const PILSOBJ PCILSOBJ;

#endif /* PILSOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\pheights.h ===
#ifndef PHEIGHTS_DEFINED
#define PHEIGHTS_DEFINED

struct heights;
typedef struct heights* PHEIGHTS;
typedef const struct heights* PCHEIGHTS;

#endif /* !POBJDIME_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plsdnode.h ===
#ifndef PLSDNODE_DEFINED
#define PLSDNODE_DEFINED

struct lsdnode;
typedef struct lsdnode* PLSDNODE;

#endif /* PLSDNODE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plscell.h ===
#ifndef PLSCELL_DEFINED
#define PLSCELL_DEFINED

struct lstextcell;
typedef struct lstextcell* PLSTEXTCELL;
typedef const struct lstextcell* PCLSTEXTCELL;

#endif /* !PLSCELL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plscbk.h ===
#ifndef PLSCBK_DEFINED
#define PLSCBK_DEFINED

struct lscbk;
typedef struct lscbk* PLSCBK;
typedef const struct lscbk* PCLSCBK;

#endif /* !PLSCBK_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plocchnk.h ===
#ifndef PLOCCHNK_DEFINED
#define PLOCCHNK_DEFINED

struct locchnk;
typedef const struct locchnk* PCLOCCHNK;
typedef struct locchnk* PLOCCHNK;

#endif /* !PLSLOCCH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plschp.h ===
#ifndef PLSCHP_DEFINED
#define PLSCHP_DEFINED

struct lschp;
typedef struct lschp* PLSCHP;
typedef const struct lschp* PCLSCHP;

#endif /* !PLSCHP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plnobj.h ===
#ifndef PLNOBJ_DEFINED
#define PLNOBJ_DEFINED

struct lnobj;
typedef struct lnobj* PLNOBJ;

#endif /* PLNOBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plsems.h ===
#ifndef PLSEMS_DEFINED
#define PLSEMS_DEFINED

struct lsems;

typedef struct lsems* PLSEMS;

#endif /* !PLSEMS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plsdocin.h ===
#ifndef PLSDOCINF_DEFINED
#define PLSDOCINF_DEFINED

struct lsdocinf;
typedef const struct lsdocinf* PCLSDOCINF;
#endif /* !PLSDOCINF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plsfrun.h ===
#ifndef PLSFRUN_DEFINED
#define PLSFRUN_DEFINED

struct lsfrun;
typedef struct lsfrun* PLSFRUN;
typedef const struct lsfrun* PCLSFRUN;

#endif /* PLSRUN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plsfgi.h ===
#ifndef PLSFGI_DEFINED
#define PLSFGI_DEFINED

struct lsfgi;
typedef struct lsfgi* PLSFGI;

#endif /* !PLSFGI_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plsline.h ===
#ifndef PLSLINE_DEFINED
#define PLSLINE_DEFINED

struct lsline;
typedef struct lsline* PLSLINE;

#endif /* PLSLINE_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plspap.h ===
#ifndef PLSPAP_DEFINED
#define PLSPAP_DEFINED

struct lspap;
typedef struct lspap* PLSPAP;

#endif /* !PLSPAP_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plshyph.h ===
#ifndef PLSHYPH_DEFINED
#define PLSHYPH_DEFINED

struct lshyph;
typedef struct lshyph* PLSHYPH;
typedef const struct lshyph* PCLSHYPH;

#endif /* !PLSHYPH_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plsqin.h ===
#ifndef PLSQIN_DEFINED
#define PLSQIN_DEFINED

struct lsqin;
typedef struct lsqin* PLSQIN;
typedef const struct lsqin* PCLSQIN;

#endif /* !PLSQIN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plsqsinf.h ===
#ifndef PLSQSINF_DEFINED
#define PLSQSINF_DEFINED

struct lsqsubinfo;
typedef struct lsqsubinfo* PLSQSUBINFO;
typedef const struct lsqsubinfo* PCLSQSUBINFO;

#endif /* !PLSQSINF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plsqout.h ===
#ifndef PLSQOUT_DEFINED
#define PLSQOUT_DEFINED

struct lsqout;
typedef struct lsqout* PLSQOUT;

#endif /* !PLSQOUT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plssubl.h ===
#ifndef PLSSUBL_DEFINED
#define PLSSUBL_DEFINED

struct lssubl;
typedef struct lssubl* PLSSUBL;

#endif /* PLSSUBL_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plsstinf.h ===
#ifndef PLSSTINFO_DEFINED
#define PLSSTINFO_DEFINED

struct lsstinfo;
typedef struct lsstinfo* PLSSTINFO;

#endif /* !PLSSTINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plsrun.h ===
#ifndef PLSRUN_DEFINED
#define PLSRUN_DEFINED

struct lsrun;
typedef struct lsrun* PLSRUN;

#endif /* PLSRUN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plstxm.h ===
#ifndef PLSTXM_DEFINED
#define PLSTXM_DEFINED

struct lstxm;
typedef struct lstxm* PLSTXM;

#endif /* !PLSTXM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plstxtcf.h ===
#ifndef PLSTXTCF_DEFINED
#define PLSTXTCF_DEFINED

struct lstxtcfg;
typedef struct lstxtcfg *PLSTXTCFG;
typedef const struct lstxtcfg *PCLSTXTCFG;

#endif /* PLSTXTCF_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plstabs.h ===
#ifndef PLSTABS_DEFINED
#define PLSTABS_DEFINED

struct lstabs;
typedef struct lstabs* PLSTABS;
typedef const struct lstabs* PCLSTABS;

#endif /* PLSTABS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\plsulinf.h ===
#ifndef PLSULINFO_DEFINED
#define PLSULINFO_DEFINED

struct lsulinfo;
typedef struct lsulinfo* PLSULINFO;

#endif /* !PLSULINFO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\pposichn.h ===
#ifndef PPOSICHN_DEFINED
#define PPOSICHN_DEFINED

struct posichnk;
typedef const struct posichnk* PCPOSICHNK;
typedef struct posichnk* PPOSICHNK;

#endif /* !PPOSICHN_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\posichnk.h ===
#ifndef POSICHNK_DEFINED
#define POSICHNK_DEFINED

#include "lsdefs.h"
#include "pposichn.h"

#define ichnkOutside 0xFFFFFFFF

typedef struct posichnk					/* position in chunk		*/
{
	long ichnk;							/* index in the chunk array	*/
	LSDCP dcp;							/* from beginning of dobj	*/
} POSICHNK;



#endif /* !POSICHNK_DEFINED                    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\pobjdim.h ===
#ifndef POBJDIM_DEFINED
#define POBJDIM_DEFINED

struct objdim;
typedef struct objdim* POBJDIM;
typedef const struct objdim* PCOBJDIM;

#endif /* !POBJDIM_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\vruby.h ===
/* Vertical ruby interfaces */
/* Contact: antons */

#ifndef VRUBY_DEFINED
#define VRUBY_DEFINED

#include "lsimeth.h"

/* Only valid version number for Ruby initialization */

#define VRUBY_VERSION 0x300

/* Used for intialization to tell Ruby object which line comes first */

typedef enum vrubysyntax { VRubyPronunciationLineFirst, VRubyMainLineFirst } VRUBYSYNTAX;

/*
 *
 *	Vertical Ruby Object callbacks to client application
 *
 */

typedef struct VRUBYCBK
{
	LSERR (WINAPI *pfnFetchVRubyPosition)
	(
		/* in */

		POLS			pols,
		LSCP			cp,
		LSTFLOW			lstflow,
		PLSRUN			plsrun,
		PCHEIGHTS		pcheightsRefMain,
		PCHEIGHTS		pcheightsPresMain,
		long			dvrRuby,

		/* out */

		PHEIGHTS		pheightsPresRubyT,
		PHEIGHTS		pheightsRefRubyT,
		LONG*			 pdurAdjust
	);

	LSERR (WINAPI* pfnVRubyEnum)
	(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,		
		const POINT *ptMain,	
		PCHEIGHTS pcheightsMain,
		long dupMain,		
		const POINT *ptRuby,	
		PCHEIGHTS pcheightsRuby,
		long dupRuby,	
		PLSSUBL plssublMain,	
		PLSSUBL plssublRuby
	);

} VRUBYCBK;

/*
 *
 *	Ruby Object initialization data that the client application must return
 *	when the Ruby object handler calls the GetObjectHandlerInfo callback.
 *
 */
typedef struct VRUBYINIT
{
	DWORD				dwVersion;		/* Version of the structure (must be VRUBY_VERSION) */
	VRUBYSYNTAX			vrubysyntax;	/* Used to determine order of lines during format */
	WCHAR				wchEscRuby;		/* Escape char for end of Ruby pronunciation line */
	WCHAR				wchEscMain;		/* Escape char for end of main text */
	VRUBYCBK			vrcbk;			/* Ruby callbacks */

} VRUBYINIT;


LSERR WINAPI LsGetVRubyLsimethods ( LSIMETHODS *plsim );

/* GetRubyLsimethods
 *
 *	plsim (OUT): Ruby object methods for Line Services.
 *
 */


#endif /* VRUBY_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\robj.h ===
#ifndef ROBJ_DEFINED
#define ROBJ_DEFINED

#include "lsimeth.h"

#define REVERSE_VERSION 0x300

/* Prototype for Reverse Object enumeration callback */
typedef LSERR (WINAPI * PFNREVERSEENUM)(
	POLS pols,				/*(IN): client context */
	PLSRUN plsrun,			/*(IN): from DNODE */
	PCLSCHP plschp,			/*(IN): from DNODE */
	LSCP cp,				/*(IN): from DNODE */
	LSDCP dcp,				/*(IN): from DNODE */
	LSTFLOW lstflow,		/*(IN): text flow */
	BOOL fReverse,			/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,	/*(IN): */
	const POINT* pt,		/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,	/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun,			/*(IN): from DNODE, relevant iff fGeometryNeeded */
	LSTFLOW lstflowSubline,	/*(IN): lstflow of subline in reverse object */
	PLSSUBL plssubl);		/*(IN): subline in reverse object. */

/*
 *
 *	Reverse Object initialization data that the client application must return
 *	when the Reverse Object handler calls the GetObjectHandlerInfo callback.
 *
 */


/* Prototype for Reverse Object get info */

typedef LSERR (WINAPI * PFNREVERSEGETINFO)
(
	POLS	pols,
	LSCP	cp,
	PLSRUN	plsrun,

	BOOL	* pfDoNotBreakAround,
	BOOL	* pfSuppressTrailingSpaces
);

typedef struct REVERSEINIT
{
        DWORD					dwVersion;		/* Version. Must be REVERSE_VERSION */
        WCHAR					wchEndReverse;	/* Escape char for end of Reverse Object */

		WCHAR					wchUnused1;		/* Unused for alignment */
		PFNREVERSEGETINFO		pfnGetRobjInfo;	/* Callback GetInfo */
		PFNREVERSEENUM			pfnEnum;		/* Enumeration callback */

} REVERSEINIT;

LSERR WINAPI LsGetReverseLsimethods(
        LSIMETHODS *plsim);

/* GetReverseLsimethods
 *
 *	plsim (OUT): Reverse Object Handler methods for Line Services.
 *
 */

#endif /* ROBJ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\ruby.h ===
#ifndef RUBY_DEFINED
#define RUBY_DEFINED

#include	"lsimeth.h"

/* Only valid version number for Ruby initialization */
#define RUBY_VERSION 0x300

/* Used for intialization to tell Ruby object which line comes first */
typedef enum rubysyntax { RubyPronunciationLineFirst, RubyMainLineFirst } RUBYSYNTAX;


/* Type of Adjustment for Ruby text returned by FetchRubyPosition callback */
enum rubycharjust { 
	rcjCenter, 		/* Centering occurs on longer text line */

	rcj010, 		/* Difference in space between longer text
					 * and shorter is distributed in the shorter
					 * string evenly between each character 
					 */

	rcj121,			/* Difference in space between longer string
					 * and shorter is distributed in the shorter
					 * using a ratio of 1:2:1 which corresponds
					 * to lead : inter-character : end.
					 */

	rcjLeft,		/* Align ruby with the left of the main line.
					 */

	rcjRight		/* Align ruby with the right of the main line.
					 */
};

/* Location of character input to FetchRubyWidthAdjust callback */
enum rubycharloc {
	rubyBefore,		/* Character preceeds Ruby object */
	rubyAfter		/* Character follows Ruby object */
};

/*
 *
 *	Ruby Object callbacks to client application
 *
 */
typedef struct RUBYCBK
{
	LSERR (WINAPI *pfnFetchRubyPosition)(
		POLS pols,
		LSCP cp,
		LSTFLOW lstflow,
		DWORD cdwMainRuns,
		const PLSRUN *pplsrunMain,
		PCHEIGHTS pcheightsRefMain,
		PCHEIGHTS pcheightsPresMain,
		DWORD cdwRubyRuns,
		const PLSRUN *pplsrunRuby,
		PCHEIGHTS pcheightsRefRuby,
		PCHEIGHTS pcheightsPresRuby,
		PHEIGHTS pheightsRefRubyObj,
		PHEIGHTS pheightsPresRubyObj,
		long *pdvpOffsetMainBaseline,
		long *pdvrOffsetRubyBaseline,
		long *pdvpOffsetRubyBaseline,
		enum rubycharjust *prubycharjust,
		BOOL *pfSpecialLineStartEnd);

	/* FetchRubyPosition
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Ruby object.
	 *
	 *  lstflow (IN): the lstflow of Ruby parent subline
	 *
	 *	pplsrunMain	(IN): array of PLSRUNs created by the client application 
	 *			for each of the runs in the main text for the Ruby object.
	 *
	 *	pcheightsRefMain (IN): height of the line of the main text in reference 
	 *			device units.
	 *
	 *	pcheightsPresMain (IN): height of the line of the main text in presentation
	 *			device units.
	 *
	 *	cdwRubyRuns	(IN): count of pronunciation runs supplied in the following 
	 *			parameter.
	 *
	 *	pplsrunRuby	(IN): array of PLSRUNS created by the client application for 
	 *			each of the runs in the pronunciation text for the Ruby object.
	 *
	 *	pcheightsRefRuby (IN): height of the line of the Ruby pronunciation text in 
	 *			reference device units.
	 *
	 *	pcheightsPresRuby (IN): height of the line of the Ruby pronunciation text in 
	 *			presentation device units.
	 *
	 *	pheightsRefRubyObj	(OUT): returned height values in reference device units
	 *			that ruby object will report back to line services.
	 *
	 *	pheightsPresRubyObj	(OUT): returned height values in presentation device units
	 *			that ruby object will report back to line services.
	 *
	 *	pdvpOffsetMainBaseline (OUT): offset of baseline of main line of Ruby
	 *			text from base line of Ruby object in presentation units. Note
	 *			a negative value puts the baseline of the main line below the 
	 *			base line of the Ruby object.
	 *
	 *	pdvrOffsetRubyBaseline (OUT): offset of baseline of pronunciation line
	 *			of Ruby text from base line of Ruby object in reference units. 
	 *			Note a negative value puts the baseline of the pronunciation line 
	 *			below the base line of the Ruby object.
	 *
	 *	pdvpOffsetRubyBaseline (OUT): offset of baseline of pronunciation line
	 *			of Ruby text from base line of Ruby object in presentation units. 
	 *			Note a negative value puts the baseline of the pronunciation line 
	 *			below the base line of the Ruby object.
	 *
	 *	prubycharjust (OUT): type of justification to use for Ruby Object.
	 *
	 *	pfSpecialLineStartEnd (OUT): specifies that the optional alignment that 
	 *			overrides the usual centering algorithm when the Ruby is the 
	 *			first or last character of the line.
	 *
	 */

	LSERR (WINAPI *pfnFetchRubyWidthAdjust)(
		POLS pols,
		LSCP cp,
		PLSRUN plsrunForChar,
		WCHAR wch,
		MWCLS mwclsForChar,
		PLSRUN plsrunForRuby,
		enum rubycharloc rcl,
		long durMaxOverhang,
		long *pdurAdjustChar,
		long *pdurAdjustRuby);

	/* FetchRubyWidthAdjust
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Ruby object.
	 *
	 *	plsrunForChar (IN): the run that is either previous or following the 
	 *			Ruby object.
	 *
	 *	wch (IN): character that is either before or after the Ruby object.
	 *
	 *	mwcls (IN): mod width class for the character.
	 *
	 *	plsrunForRuby (IN): plsrun for entire ruby object.
	 *
	 *	rcl	(IN): tells the location of the character.
	 *
	 *	durMaxOverhang (IN): designates the maximum amount of overhang that is 
	 *			possible following the JIS spec with respect to overhang. 
	 *			Adjusting the Ruby object by a negative value whose absolute 
	 *			value is greater than durMaxOverhang will cause part of the 
	 *			main text to be clipped. If the value of this parameter is 0, 
	 *			this indicates that there is no possible overhang.
	 *
	 *	pdurAdjustChar (OUT): designates the amount to adjust the width of the 
	 *			character prior to or following the Ruby object. Returing a negative 
	 *			value will decrease the size of the character preceeding or following 
	 *			the Ruby while returning a positive value will increase the size 
	 *			of that character.
	 *
	 *	pdurAdjustRuby (OUT): designates the amount adjust the width of the Ruby 
	 *			object. Returing a negative value will decrease the size of the 
	 *			Ruby object and potentially cause the Ruby pronunciation text to 
	 *			overhang the preceeding or following character while returning a 
	 *			positive value will increase the size of the Ruby object.
	 */

	LSERR (WINAPI* pfnRubyEnum)(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,		
		const POINT *ptMain,	
		PCHEIGHTS pcheightsMain,
		long dupMain,		
		const POINT *ptRuby,	
		PCHEIGHTS pcheightsRuby,
		long dupRuby,	
		PLSSUBL plssublMain,	
		PLSSUBL plssublRuby);	

	/* RubyEnum
	 * 
	 *	pols (IN): client context.
	 *
	 *  plsrun (IN): plsrun for the entire Ruby Object.
	 *
	 *	plschp (IN): is lschp for lead character of Ruby Object.
	 *
	 *	cp (IN): is cp of first character of Ruby Object.
	 *
	 *	dcp (IN): is number of characters in Ruby Object
	 *
	 *	lstflow (IN): is text flow at Ruby Object.
	 *
	 *	fReverse (IN): is whether text should be reversed for visual order.
	 *
	 *	fGeometryNeeded (IN): is whether Geometry should be returned.
	 *
	 *	pt (IN): is starting position , iff fGeometryNeeded .
	 *
	 *	pcheights (IN):	is height of Ruby object, iff fGeometryNeeded.
	 *
	 *	dupRun (IN): is length of Ruby Object, iff fGeometryNeeded.
	 *
	 *	ptMain (IN): is starting point for main line iff fGeometryNeeded
	 *
	 *	pcheightsMain (IN): is height of main line iff fGeometryNeeded
	 *
	 *	dupMain (IN): is length of main line iff fGeometryNeeded
	 *
	 *	ptRuby (IN): is point for Ruby pronunciation line iff fGeometryNeeded
	 *
	 *	pcheightsRuby (IN): is height for ruby line iff fGeometryNeeded
	 *
	 *	dupRuby (IN): is length of Ruby line iff fGeometryNeeded
	 *
	 *	plssublMain (IN): is main subline.
	 *
	 *	plssublRuby (IN): is Ruby subline.
	 *
	 */

} RUBYCBK;

/*
 *
 *	Ruby Object initialization data that the client application must return
 *	when the Ruby object handler calls the GetObjectHandlerInfo callback.
 *
 */
typedef struct RUBYINIT
{
	DWORD				dwVersion;		/* Version of the structure */
	RUBYSYNTAX			rubysyntax;		/* Used to determine order of lines during format */
	WCHAR				wchEscRuby;		/* Escape char for end of Ruby pronunciation line */
	WCHAR				wchEscMain;		/* Escape char for end of main text */
	WCHAR				wchUnused1;		/* For aligment */
	WCHAR				wchUnused2;		/* For aligment */
	RUBYCBK				rcbk;			/* Ruby callbacks */
} RUBYINIT;

LSERR WINAPI LsGetRubyLsimethods(
	LSIMETHODS *plsim);

/* GetRubyLsimethods
 *
 *	plsim (OUT): Ruby object methods for Line Services.
 *
 */

#endif /* RUBY_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\tatenak.h ===
#ifndef TATENAKYOKO_DEFINED
#define TATENAKYOKO_DEFINED

#include "lsimeth.h"

/*
 *
 *	Tatenakayoko object callbacks to client application
 *
 */
typedef struct TATENAKYOKOCBK
{
	LSERR (WINAPI *pfnGetTatenakayokoLinePosition)(
		POLS pols,
		LSCP cp,
		LSTFLOW lstflow,
		PLSRUN plsrun,
		long dvr,
		PHEIGHTS pheightsRef,
		PHEIGHTS pheightsPres,
		long *pdvpDescentReservedForClient);

	/* GetTatenakayokoLinePosition
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Tatenakayoko object.
	 *
	 *  lstflow (IN): the lstflow of Tatenakayoko parent subline
	 *
	 *	plsrun (IN): the plsrun of the Tatenakayoko object.
	 *
	 *	dvr	(IN): the total height of the tatenakayoko object with respect to 
	 *			the current flow of the line in reference units.
	 *
	 *	pheightsRef	(OUT): specifies heights of Tatenakayoko object in reference
	 *			device units. 
	 *
	 *	pdvrDescentReservedForClient (OUT): specifies the part of the descent area 
	 *			that the client is reserving for its own use (usually for the purpose 
	 *			of underlining) in reference device units. The object will begin its 
	 *			display area below the baseline at the difference between *pdvrDescent 
	 *			and *pdvrDescentReservedForClient. 
	 *
	 *	pheightsPres (OUT): specifies heights of Tatenakayoko object in presenatation
	 *			device units. 
	 *
	 *	pdvpDescentReservedForClient (OUT): specifies the part of the descent area 
	 *			that the client is reserving for its own use (usually for the purpose 
	 *			of underlining) in presentation device units. The object will begin its 
	 *			display area below the baseline at the difference between *pdvpDescent 
	 *			and pheightsPres.dvDescent. 
	 *
	 */

	LSERR (WINAPI* pfnTatenakayokoEnum)(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,
		LSTFLOW lstflowT,
		PLSSUBL plssubl);

	/* TatenakayokoEnum
	 * 
	 *	pols (IN): client context.
	 *
	 *  plsrun (IN): plsrun for the entire Tatenakayoko Object.
	 *
	 *	plschp (IN): is lschp for lead character of Tatenakayoko Object.
	 *
	 *	cp (IN): is cp of first character of Tatenakayoko Object.
	 *
	 *	dcp (IN): is number of characters in Tatenakayoko Object
	 *
	 *	lstflow (IN): is text flow at Tatenakayoko Object.
	 *
	 *	fReverse (IN): is whether text should be reversed for visual order.
	 *
	 *	fGeometryNeeded (IN): is whether Geometry should be returned.
	 *
	 *	pt (IN): is starting position , iff fGeometryNeeded .
	 *
	 *	pcheights (IN):	is height of Tatenakayoko object, iff fGeometryNeeded.
	 *
	 *	dupRun (IN): is length of Tatenakayoko Object, iff fGeometryNeeded.
	 *
	 *	lstflowT (IN): is text flow for Tatenakayoko object.
	 *
	 *	plssubl (IN): is subline for Tatenakayoko object.
	 */

} TATENAKAYOKOCBK;

/*
 *
 *	Tatenakayoko object initialization data that the client application must return
 *	when the Tatenakayoko object handler calls the GetObjectHandlerInfo callback.
 */

#define TATENAKAYOKO_VERSION 0x300

typedef struct TATENAKAYOKOINIT
{
	DWORD				dwVersion;			/* Version. Only TATENAKAYOKO_VERSION is valid. */
	WCHAR				wchEndTatenakayoko;	/* Character marking end of Tatenakayoko object */
	WCHAR				wchUnused1;			/* For alignment */
	WCHAR				wchUnused2;			/* For alignment */
	WCHAR				wchUnused3;			/* For alignment */
	TATENAKAYOKOCBK		tatenakayokocbk;	/* Client application callbacks */
} TATENAKAYOKOINIT, *PTATENAKAYOKOINIT;

LSERR WINAPI LsGetTatenakayokoLsimethods(
	LSIMETHODS *plsim);

/* GetTatenakayokoLsimethods
 *	
 *	plsim (OUT): Tatenakayoko object methods for Line Services
 *
 */

#endif /* TATENAKYOKO_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\warichu.h ===
#ifndef WARICHU_DEFINED
#define WARICHU_DEFINED

#include	"lsimeth.h"

/* Character location for pfnFetchWarichuWidthAdjust callback */
enum warichucharloc {
	warichuBegin,				/* Character preceeds Warichu object */
	warichuEnd					/* Character follows Warichu object */
};

/*
 *
 * Warichu Object Callbacks to Client
 *
 */
typedef struct WARICHUCBK
{
	LSERR (WINAPI* pfnGetWarichuInfo)(
		POLS pols,
		LSCP cp,
		LSTFLOW lstflow,
		PCOBJDIM pcobjdimFirst,
		PCOBJDIM pcobjdimSecond,
		PHEIGHTS pheightsRef,
		PHEIGHTS pheightsPres,
		long *pdvpDescentReservedForClient);

	/* GetWarichuInfo
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Warichu object.
	 *
     *  lstflow (IN): the lstflow of Warichu parent subline
	 *
	 *	pcobjdimFirst (IN): dimensions of first line of Warichu.
	 *
	 *	pcobjdimSecond (IN): dimensions of second line of Warichu.
	 *
	 *	pheightsRef (OUT): specifies heights for Warichu object in reference
	 *			device units.
	 *
	 *	pheightsPres (OUT): specifies heights for Warichu object in presentation
	 *			device units.
	 *
	 *	pdvpDescentReservedForClient (OUT): specifies the part of the descent area 
	 *			that the client is reserving for its own use (usually for the purpose 
	 *			of underlining) in presentation device units. The object will begin its 
	 *			display area below the baseline at the difference between 
	 *			pheightsRef->dvDescent and *pdvpDescentReservedForClient. 
	 *
	 */

	LSERR (WINAPI* pfnFetchWarichuWidthAdjust)(
		POLS pols,
		LSCP cp,
		enum warichucharloc wcl,
		PLSRUN plsrunForChar,
		WCHAR wch,
		MWCLS mwclsForChar,
		PLSRUN plsrunWarichuBracket,
		long *pdurAdjustChar,
		long *pdurAdjustBracket);

	/* FetchWarichuWidthAdjust
	 *  pols (IN): The client context for the request.
	 *
	 *  cp (IN): the cp of the Warichu object.
	 *
	 *  wcl (IN): specifies the location of the character and bracket.
	 *
	 *  plsrunForChar (IN): the run of the character that is either previous or 
	 *		following the Warichu object. Whether preceeding or following is 
	 *		determined by value of the wcl parameter above.
	 *
	 *	wch (IN): character that is either preceeding or following the Warichu 
	 *		object.
	 *
	 *	mwclsForChar (IN): mod width class for the wch parameter.
	 *
	 *	plsrunWarichuBracket (IN): plsrun for leading or following bracket of 
	 *		the Warichu.
	 *
	 *	pdurAdjustChar (OUT): the amount that the width of the input character 
	 *		should be adjusted. A negative value means the width of the input 
	 *		character should be made smaller.
	 *
	 *	pdurAdjustBracket (OUT): the amount that the width of the Warichu bracket
	 *		should be adjusted.  A negative value means the width of the Warichu 
	 *		bracket should be made smaller.
	 */

	LSERR (WINAPI* pfnWarichuEnum)(
		POLS pols,
		PLSRUN plsrun,		
		PCLSCHP plschp,	
		LSCP cp,		
		LSDCP dcp,		
		LSTFLOW lstflow,	
		BOOL fReverse,		
		BOOL fGeometryNeeded,	
		const POINT* pt,		
		PCHEIGHTS pcheights,	
		long dupRun,		
		const POINT *ptLeadBracket,	
		PCHEIGHTS pcheightsLeadBracket,
		long dupLeadBracket,		
		const POINT *ptTrailBracket,	
		PCHEIGHTS pcheightsTrailBracket,
		long dupTrailBracket,
		const POINT *ptFirst,	
		PCHEIGHTS pcheightsFirst,
		long dupFirst,		
		const POINT *ptSecond,	
		PCHEIGHTS pcheightsSecond,
		long dupSecond,
		PLSSUBL plssublLeadBracket,
		PLSSUBL plssublTrailBracket,
		PLSSUBL plssublFirst,	
		PLSSUBL plssublSecond);	

	/* WarichuEnum
	 * 
	 *	pols (IN): client context.
	 *
	 *  plsrun (IN): plsrun for the entire Warichu Object.
	 *
	 *	plschp (IN): is lschp for lead character of Warichu Object.
	 *
	 *	cp (IN): is cp of first character of Warichu Object.
	 *
	 *	dcp (IN): is number of characters in Warichu Object
	 *
	 *	lstflow (IN): is text flow at Warichu Object.
	 *
	 *	fReverse (IN): is whether text should be reversed for visual order.
	 *
	 *	fGeometryNeeded (IN): is whether Geometry should be returned.
	 *
	 *	pt (IN): is starting position , iff fGeometryNeeded .
	 *
	 *	pcheights (IN):	is height of Warichu object, iff fGeometryNeeded.
	 *
	 *	dupRun (IN): is length of Warichu Object, iff fGeometryNeeded.
	 *
	 *	ptLeadBracket (IN):	is point for second line iff fGeometryNeeded and 
	 *		plssublLeadBracket not NULL.
	 *
	 *	pcheightsLeadBracket (IN): is height for Warichu line iff fGeometryNeeded 
	 *		and plssublLeadBracket not NULL.
	 *
	 *	dupLeadBracket (IN): is length of Warichu line iff fGeometryNeeded and 
	 *		plssublLeadBracket not NULL.
	 *
	 *	ptTrailBracket (IN): is point for second line iff fGeometryNeeded and 
	 *		plssublLeadBracket not NULL.
	 *
	 *	pcheightsTrailBracket (IN):	is  height for Warichu  line iff fGeometryNeeded 
	 *		and plssublTrailBracket not NULL.
	 *
	 *	dupTrailBracket (IN): is length of Warichu line iff fGeometryNeeded and 
	 *		plssublTrailBracket not NULL.
	 *
	 *	ptFirst (IN): is starting point for main line iff fGeometryNeeded
	 *
	 *	pcheightsFirst (IN): is height of main line iff fGeometryNeeded
	 *
	 *	dupFirst (IN): is length of main line iff fGeometryNeeded
	 *
	 *	ptSecond (IN): is point for second line iff fGeometryNeeded and 
	 *		plssublSecond not NULL.
	 *
	 *	pcheightsSecond (IN): is height for Warichu line iff fGeometryNeeded 
	 *		and plssublSecond not NULL.
	 *
	 *	dupSecond (IN):	is length of Warichu line iff fGeometryNeeded and 
	 *		plssublSecond not NULL.
	 *
	 *	plssublLeadBracket (IN): is subline for lead bracket.
	 *
	 *	plssublTrailBracket (IN): is subline for trail bracket.
	 *
	 *	plssublFirst (IN): is first subline in Warichu object.
	 *
	 *	plssublSecond (IN):	is second subline in Warichu object.
	 *
	 */

} WARICHUCBK;

#define WARICHU_VERSION 0x300

/*
 * 
 *	Warichi object initialization data that the client application must return
 *	when the Warichu object handler calls the GetObjectHandlerInfo callback.
 */
typedef struct WARICHUINIT
{
	DWORD				dwVersion;			/* Version must be WARICHU_VERSION */
	WCHAR				wchEndFirstBracket;	/* Escape char to end first bracket */
	WCHAR				wchEndText;			/* Escape char to end text */
	WCHAR				wchEndWarichu;		/* Escape char to end object */
	WCHAR				wchUnused;			/* For alignment */
	WARICHUCBK			warichcbk;			/* Callbacks */
	BOOL				fContiguousFetch;	/* Always refetch whole subline & closing brace
											   after reformatting inside warichu */
} WARICHUINIT;

LSERR WINAPI LsGetWarichuLsimethods(
	LSIMETHODS *plsim);

/* GetWarichuLsimethods
 *
 *	plsim (OUT): Warichu object callbacks.
 */

#endif /* WARICHU_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lsinc\zqfromza.h ===
#ifndef ZQFROMZQ_DEFINED
#define ZQFROMZQ_DEFINED

#include "lsdefs.h"

#define zqLim	1491309L				/* higher resolution will overflow */

long ZqFromZa_C (long, long);

#ifdef _X86_

long ZqFromZa_Asm (long, long);
__int64 Div64_Asm (__int64, __int64);
__int64 Mul64_Asm (__int64, __int64);

#define ZqFromZa(dzqInch,za) ZqFromZa_Asm ((dzqInch),(za))

#define Div64(DVND,DVSR) Div64_Asm ((DVND),(DVSR))
#define Mul64(A,B) Mul64_Asm ((A),(B))

#else

#define ZqFromZa(dzqInch,za) ZqFromZa_C ((dzqInch),(za))

#define Div64(DVND,DVSR) ((__int64) (DVND) / (__int64) (DVSR))
#define Mul64(A,B) ((__int64) (A) * (__int64) (B))

#endif

long ZaFromZq(long, long);
long LsLwMultDivR(long, long, long);

#define I_UpFromUa(pdevres,ua)	(ZqFromZa((pdevres)->dxpInch, (ua)))
#define I_UrFromUa(pdevres,ua)	(ZqFromZa((pdevres)->dxrInch, (ua)))
#define I_VpFromVa(pdevres,va)	(ZqFromZa((pdevres)->dypInch, (va)))
#define I_VrFromVa(pdevres,va)	(ZqFromZa((pdevres)->dyrInch, (va)))
#define I_UaFromUp(pdevres,up)	(ZaFromZq((pdevres)->dxpInch, (up)))
#define I_VaFromVp(pdevres,vp)	(ZaFromZq((pdevres)->dypInch, (vp)))
#define I_UaFromUr(pdevres,ur)	(ZaFromZq((pdevres)->dxrInch, (ur)))
#define I_VaFromVr(pdevres,vr)	(ZaFromZq((pdevres)->dyrInch, (vr)))



#define UpFromUa(tfl,pdevres,ua) (((tfl) & fUVertical) ? \
		I_VpFromVa(pdevres,ua) :\
		I_UpFromUa(pdevres,ua) \
)

#define UrFromUa(tfl,pdevres,ua) (((tfl) & fUVertical) ? \
		I_VrFromVa(pdevres,ua) :\
		I_UrFromUa(pdevres,ua) \
)

#define VpFromVa(tfl,pdevres,va) ((tfl) & fUVertical) ? \
		I_UpFromUa(pdevres,va) :\
		I_VpFromVa(pdevres,va) \
)

#define VrFromVa(tfl,pdevres,va) (((tfl) & fUVertical) ? \
		I_UrFromUa(pdevres,va) :\
		I_VrFromVa(pdevres,va) \
)

#define UaFromUp(tfl,pdevres,up) (((tfl) & fUVertical) ? \
		I_VaFromVp(pdevres,up) :\
		I_UaFromUp(pdevres,up) \
)

#define VaFromVp(tfl,pdevres,vp)	(((tfl) & fUVertical) ? \
		I_UaFromUp(pdevres,vp) :\
		I_VaFromVp(pdevres,vp) \
)

#define UaFromUr(tfl,pdevres,ur)	(((tfl) & fUVertical) ?	\
		I_VaFromVr(pdevres,ur) :\
		I_UaFromUr(pdevres,ur) \
)

#define VaFromVr(tfl,pdevres,vr)	(((tfl) & fUVertical) ?	\
		I_UaFromUr(pdevres,vr) :\
		I_VaFromVr(pdevres,vr) \
)

/*
#define UpFromUr(pdevres,ur)	UpFromUa(pdevres, UaFromUr(pdevres, ur))
#define VpFromVr(pdevres,vr)	VpFromVa(pdevres, VaFromVr(pdevres, vr))
*/
#define UpFromUr(tfl,pdevres,ur)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(ur, (pdevres)->dypInch, (pdevres)->dyrInch): \
								LsLwMultDivR(ur, (pdevres)->dxpInch, (pdevres)->dxrInch) \
									)
#define VpFromVr(tfl,pdevres,vr)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(vr, (pdevres)->dxpInch, (pdevres)->dxrInch): \
								LsLwMultDivR(vr, (pdevres)->dypInch, (pdevres)->dyrInch) \
									)
#define UrFromUp(tfl,pdevres,up)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(up, (pdevres)->dyrInch, (pdevres)->dypInch): \
								LsLwMultDivR(up, (pdevres)->dxrInch, (pdevres)->dxpInch) \
									)
#define VrFromVp(tfl,pdevres,vp)	(((tfl) & fUVertical) ? \
								LsLwMultDivR(vp, (pdevres)->dxrInch, (pdevres)->dxpInch): \
								LsLwMultDivR(vp, (pdevres)->dyrInch, (pdevres)->dypInch) \
									)

#endif /* ZQFROMZQ_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\break.c ===
#include "lsidefs.h"
#include "break.h"
#include "brko.h"
#include "chnutils.h"
#include "dninfo.h"
#include "dnutils.h"
#include "getfmtst.h"
#include "iobj.h"
#include "iobjln.h"
#include "locchnk.h"
#include "lsc.h"
#include "lsdnode.h"
#include "lsline.h"
#include "lstext.h"
#include "plocchnk.h"
#include "posichnk.h"
#include "setfmtst.h"
#include "posinln.h"
#include "lscfmtfl.h"

#include "lsmem.h"						/* memset() */
#include "limits.h"





static LSERR TruncateCore(  	
					PLSSUBL,				/* IN: subline where to find truncation point */
				  	long,					/* IN: urColumnMax				*/   
					POSINLINE*,				/* OUT:position of truncation point */
					BOOL*);					/* OUT:fAllLineAfterRightMargin */

 
static LSERR FindNextBreakCore(
						 long,				/* IN: urColumnMax				*/   
						 POSINLINE*,		/* IN: start break search       */
						 BOOL, 				/* IN: to apply rules for first character to 
											the first character of this subline */
						 BOOL,				/* IN: fStopped					*/
						 BRKOUT*,			/* OUT: breaking information 	*/
						 POSINLINE*,		/* OUT: position of break		*/
						 BRKKIND*);			/* OUT: how dnode was broken	*/

static LSERR FindPrevBreakCore(
						 long,				/* IN: urColumnMax				*/   
						 POSINLINE*,		/* IN: start break search       */
						 BOOL, 				/* IN: to apply rules for first character to 
											the first character of this subline */
						 BRKOUT*,			/* OUT: breaking information 	*/
						 POSINLINE*,		/* OUT: position of break		*/
						 BRKKIND*);			/* OUT: how dnode was broken	*/

static LSERR ForceBreakCore(
						 long,				/* IN: urColumnMax				*/   
						 POSINLINE*,		/* IN: where to do force break  */
						 BOOL,				/* IN: fStopped */
						 BOOL, 				/* IN: to apply rules for first character to 
											the first character of this subline */
						 BOOL,				/* IN: fAllLineAfterRightMargin	*/
						 BRKOUT*,			/* OUT: breaking information 	*/
						 POSINLINE*,		/* OUT: position of break		*/
						 BRKKIND*);			/* OUT: how dnode was broken	*/

static LSERR SetBreakCore(
						 POSINLINE*,		/* IN: where to do  break		*/
						 OBJDIM*,			/* IN: objdim of break dnode	*/
						 BRKKIND,			/* IN: how break was found */
						 BOOL,				/* IN fHardStop				*/
						 BOOL,			    /* IN: fGlueEop */
						 DWORD,				/* IN: size of the output array			*/
						 BREAKREC*,			/* OUT: output array of break records	*/
						 DWORD*,			/* OUT:actual number of records in array*/
						 LSCP*,				/* OUT: cpLim					*/
						 LSDCP*,			/* OUT dcpDepend				*/
						 ENDRES*,			/* OUT: endr					*/
						 BOOL*);			/* OUT fSuccessful: false means insufficient fetch */
				

static void 	GetPosInLineTruncateFromCp(
							PLSSUBL,		/* IN: subline						*/
							LSCP,			/* IN: cp of a position */
							BOOL,			/* direction of snaping */
							POSINLINE*	);	/* OUT: position in a subline */


static LSERR BreakTabPenSplat(
						 PLOCCHNK,	/* IN: chunk contains tab or pen */
						 BOOL,		/* IN: we are searching next break*/
						 BOOL,		/* IN: breakthrough tab	*/
						 BOOL,		/* IN: splat */
						 BRKCOND,	/* IN: condition of boundary break */
						 OBJDIM*,	/* IN: to fill in objdim of break */
						 BRKOUT*);	/* OUT: breaking information */

static LSERR ForceBreakTabPenSplat(
							  PLOCCHNK,	 /* IN: chunk contains tab or pen */
							  OBJDIM*,	 /* IN: to fill in objdim of break  */
							  BRKOUT*);	 /* OUT: breaking information */


static void FindFirstDnodeContainsRightMargin(
					long urColumnMax,				/* IN: position of right margin */
					POSINLINE* pposinlineTruncate); /* OUT: first dnode contains right margin */

static void ApplyBordersForTruncation(POSINLINE* pposinlineTruncate, /* IN, OUT: position of truncation point */
									  long* purColumnMaxTruncate, /* IN, OUT: position of right margin */
									  BOOL* pfTruncationFound); /* OUT: this procedure can find truncation itself */

static LSERR MoveClosingBorderAfterBreak(PLSSUBL plssubl,		/* IN subline */
										BOOL fChangeList, /* IN: do we need to change dnode list
										and change pplsdnBreak, or only to recalculate durBreak */
										PLSDNODE* pplsdnBreak, /* IN, OUT: break dnode */
										long* purBreak); /* IN, OUT: position after break */


static void	RemoveBorderDnodeFromList(PLSDNODE plsdnBorder); /*IN: border dnode */

static LSERR MoveBreakAfterPreviousDnode(
									PLSCHUNKCONTEXT plschunkcontext, /* chunk context */
									BRKOUT* pbrkout, /* IN,OUT brkout which can be changed */
									OBJDIM* pobjdimPrev, /* suggested objdim for the dnode in previous chunk 
														if NULL take objdim of dnode */
									BRKKIND*);			/* OUT: how dnode was broken	*/


#define FCompressionFlagsAreOn(plsc) \
			((plsc)->lsadjustcontext.lsbrj == lsbrjBreakWithCompJustify)

#define FCompressionPossible(plsc, fAllLineAfterRightMargin) \
			(FCompressionFlagsAreOn(plsc) && \
			 !FBreakthroughLine(plsc)  && \
			 !fAllLineAfterRightMargin)

#define GoPrevPosInLine(pposinline, fEndOfContent)  \
		if (((pposinline)->plsdn->plsdnPrev != NULL ) \
			&& !FIsNotInContent((pposinline)->plsdn->plsdnPrev)) \
			{\
			(pposinline)->plsdn = (pposinline)->plsdn->plsdnPrev; \
			Assert(FIsLSDNODE((pposinline)->plsdn)); \
			(pposinline)->dcp = (pposinline)->plsdn->dcp;\
			(pposinline)->pointStart.u -= DurFromDnode((pposinline)->plsdn); \
			(pposinline)->pointStart.v -= DvrFromDnode((pposinline)->plsdn); \
			(fEndOfContent) = fFalse; \
			}\
		else\
			{\
			(fEndOfContent) = fTrue; \
			}

#define GoNextPosInLine(pposinline)  \
		(pposinline)->pointStart.u += DurFromDnode((pposinline)->plsdn);\
		(pposinline)->pointStart.v += DvrFromDnode((pposinline)->plsdn);\
		(pposinline)->plsdn = (pposinline)->plsdn->plsdnNext;\
		Assert(FIsLSDNODE((pposinline)->plsdn));\
		(pposinline)->dcp = 0;\


#define GetCpLimFromPosInLine(posinline) \
			(((posinline).plsdn->dcp == (posinline).dcp) ? \
				((posinline).plsdn->cpLimOriginal) : \
				((posinline).plsdn->cpFirst + (posinline).dcp ))

#define		IsItTextDnode(plsdn, plsc) \
			((plsdn) == NULL) ? fFalse : \
			(IdObjFromDnode(plsdn) == IobjTextFromLsc(&plsc->lsiobjcontext))
			
#define	ResolvePosInChunk(plschunkcontext, posichnk, pposinline) \
					(pposinline)->dcp = (posichnk).dcp; \
					LocDnodeFromChunk((plschunkcontext), (posichnk).ichnk, \
							&((pposinline)->plsdn),&((pposinline)->pointStart)); 

#define GetCpFromPosInChunk(plschunkcontext, posichnk) \
		((DnodeFromChunk(plschunkcontext, (posichnk).ichnk))->cpFirst + (posichnk).dcp)

/* last two lines turn off check for lines ended with hard break and sublines ended
   by esc character */

#define GetBrkpos(plsdn, dcpBreak) \
((FIsFirstOnLine(plsdn)) && ((dcpBreak) == 0) ?  brkposBeforeFirstDnode :\
	((((plsdn)->plsdnNext == NULL) \
	  || (FIsDnodeCloseBorder((plsdn)->plsdnNext) && (plsdn)->plsdnNext->plsdnNext == NULL) \
	 ) \
	 && ((dcpBreak) == (plsdn)->dcp) \
    ) ? brkposAfterLastDnode : \
			brkposInside\
)

		 
#define EndrFromBreakDnode(plsdnBreak)\
	(plsdnBreak == NULL) ? endrStopped : \
		(plsdnBreak->fEndOfPara) ? endrEndPara : \
			(plsdnBreak->fAltEndOfPara) ? endrAltEndPara : \
				(plsdnBreak->fSoftCR) ? endrSoftCR : \
					(plsdnBreak->fEndOfColumn) ? endrEndColumn : \
						(plsdnBreak->fEndOfSection) ? endrEndSection : \
							(plsdnBreak->fEndOfPage) ? endrEndPage : \
								endrStopped

/* ---------------------------------------------------------------------- */

/* B R E A K  G E N E R A L  C A S E */
/*----------------------------------------------------------------------------
    %%Function: BreakGeneralCase
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	fHardStop		-	(IN) is formatting sopped because of hard break or special situation	
	breakrecMaxCurrent-	(IN) size of the array of current line's break records
	pbreakrecCurrent-	(OUT) current line's break records
	pbreakrecMacCurrent-(OUT) actual number of current line's break records 
	pdcpDepend		-	(OUT) dcpDepend		
	pCpLimLine 		-	(OUT) cpLimLine	
	pendr			-	(OUT) how the line ended
	pfSuccessful	-	(OUT) fSuccessful: false means insufficient fetch

    Main procedure of breaking
	Breaking can be unsuccessful if we didn't fetch enough
----------------------------------------------------------------------------*/
LSERR BreakGeneralCase(PLSC plsc, BOOL fHardStop, DWORD breakrecMaxCurrent,
					  BREAKREC* pbreakrecCurrent, DWORD* pbreakrecMacCurrent,
					  LSDCP* pdcpDepend, LSCP* pcpLimLine, ENDRES* pendr,
					  BOOL* pfSuccessful)		
{
	LSERR lserr;
	POSINLINE posinlineTruncate; /* position of truncation point */
	POSINLINE posinlineBreak; /* position of break point */
	BRKOUT brkout;
	GRCHUNKEXT grchnkextCompression;
	BOOL fCanCompress;
	long durToCompress;
	BOOL fLineCompressed;
	long durExtra;
	BOOL fEndOfContent;
	BOOL fAllLineAfterRightMargin;
	BRKKIND brkkindDnodeBreak;
	LSDCP dcpOld;
	PLSDNODE plsdnLastNotBorder;

	
	Assert(FBreakingAllowed(plsc));

	*pfSuccessful = fTrue;

	/* set flag how line was ended */   /*REVIEW*/
	if (!fHardStop)
		GetCurrentSubline(plsc)->fRightMarginExceeded = fTrue;
	
	if 	(GetCurrentDnode(plsc) == NULL) /* it  can happend with fmtrStopped */
		{
		*pdcpDepend = 0;
		*pcpLimLine = GetCurrentCpLim(plsc);
		*pendr = endrStopped;
		return lserrNone;
		}
	
	if (fHardStop && (GetCurrentUr(plsc) <= plsc->urRightMarginBreak))
	/* we have hard break before right margin or there is no content in a line, 
	so break is found */
		{
		posinlineBreak.plssubl = GetCurrentSubline(plsc);
		GetCurrentPoint(plsc, posinlineBreak.pointStart);
		posinlineBreak.plsdn = GetCurrentDnode(plsc);
		GetPointBeforeDnodeFromPointAfter(posinlineBreak.plsdn, &(posinlineBreak.pointStart));
		posinlineBreak.dcp = posinlineBreak.plsdn->dcp;
		/* skip back closing border after hard break */
		while (FIsDnodeBorder(posinlineBreak.plsdn))
			{
			GoPrevPosInLine(&posinlineBreak, fEndOfContent);
			Assert(!fEndOfContent);
			}

		brkout.objdim = posinlineBreak.plsdn->u.real.objdim;

		return SetBreakCore(&posinlineBreak, &brkout.objdim, brkkindImposedAfter, 
							 fHardStop, fTrue, breakrecMaxCurrent, pbreakrecCurrent, 
							 pbreakrecMacCurrent, pcpLimLine, 
							 pdcpDepend, pendr, pfSuccessful);	
		}

	Assert(GetCurrentDnode(plsc) != NULL); /* case of empty list - end of section in the begining
											  of a line should be handled in previous if */

	lserr = TruncateCore(GetCurrentSubline(plsc), plsc->urRightMarginBreak,
						 &posinlineTruncate, &fAllLineAfterRightMargin);		
	if (lserr != lserrNone)
		{
		return lserr;
		}
	
	Assert(!FIsNotInContent(posinlineTruncate.plsdn));
      	
	if (FCompressionPossible(plsc, fAllLineAfterRightMargin))
   		{
		 
        lserr = FindNextBreakCore(plsc->urRightMarginBreak, &posinlineTruncate,	fTrue,
					  fHardStop, &brkout, &posinlineBreak, &brkkindDnodeBreak);	
		if (lserr != lserrNone)
			{
			return lserr;
			}
		
		InitGroupChunkExt(PlschunkcontextFromSubline(GetCurrentSubline(plsc)),
						IobjTextFromLsc(&plsc->lsiobjcontext), &grchnkextCompression);


		if (!brkout.fSuccessful)     
			{
		/* we can't find break and if we still can compress the amount that is over right
		   margin we should fetch more  */
			plsdnLastNotBorder = LastDnodeFromChunk(PlschunkcontextFromSubline(GetCurrentSubline(plsc)));
			Assert(!FIsDnodeBorder(plsdnLastNotBorder));
			/* last dnode from chunk which was collected in FindNextBreak will give us last not border dnode,
			we should store it before we change chunk context */

			lserr = CollectPreviousTextGroupChunk(GetCurrentDnode(plsc), CollectSublinesForCompression,
										  FAllSimpleText(plsc),
										  &grchnkextCompression);
			if (lserr != lserrNone)
				return lserr;

			durToCompress = GetCurrentUr(plsc) - plsc->urRightMarginBreak
								- grchnkextCompression.durTrailing;

			if ((brkout.brkcond == brkcondPlease || brkout.brkcond == brkcondCan)
				&& FIsDnodeReal(plsdnLastNotBorder)
			   )
				{
				/* In such case if we fetch more break may be possible after last dnode with also
				possible dur. So in our optimization check we are taking min from two durs */
				if (brkout.objdim.dur < DurFromDnode(plsdnLastNotBorder))
					{
					durToCompress -= (DurFromDnode(plsdnLastNotBorder) - brkout.objdim.dur);
					}
				}

			if (FDnodeHasBorder(grchnkextCompression.plsdnStartTrailing)
				&& !grchnkextCompression.fClosingBorderStartsTrailing)
				{
				/* we should reserve room for closing border */
				/* if border is not exactly before trailing area it was counted as a part of durTrailing
				   so we should add it again */
				durToCompress += DurBorderFromDnodeInside(grchnkextCompression.plsdnStartTrailing);
				}

			lserr = CanCompressText(&(grchnkextCompression.lsgrchnk), 
							&(grchnkextCompression.posichnkBeforeTrailing),
							LstflowFromSubline(GetCurrentSubline(plsc)),
							durToCompress,	&fCanCompress,
							&fLineCompressed, &durExtra);
			if (lserr != lserrNone)
				return lserr;
		
			
			if (fCanCompress)
				{
				/* increase right margin and fetch more */
				*pfSuccessful = fFalse;
				return lserrNone;
				}
			}
		else
			{

			/* temporary change dcp in break dnode */
			dcpOld = posinlineBreak.plsdn->dcp;
			posinlineBreak.plsdn->dcp = posinlineBreak.dcp;

			lserr = CollectPreviousTextGroupChunk(posinlineBreak.plsdn, CollectSublinesForCompression,
										FAllSimpleText(plsc),
										&grchnkextCompression);
			if (lserr != lserrNone)
				return lserr;

			durToCompress = posinlineBreak.pointStart.u + brkout.objdim.dur 
								- plsc->urRightMarginBreak
								- grchnkextCompression.durTrailing;

			if (posinlineBreak.plsdn->plsdnNext != NULL && 
				FIsDnodeCloseBorder(posinlineBreak.plsdn->plsdnNext))
				{
				/* closing border after dnode is a part of collected group chunk
				 so can participate in durTrailing see also calculation below */
				 durToCompress += DurFromDnode(posinlineBreak.plsdn->plsdnNext);
				}

			if (FDnodeHasBorder(grchnkextCompression.plsdnStartTrailing) 
				&& !grchnkextCompression.fClosingBorderStartsTrailing)
				{
				/* we should reserve room for closing border */
				/* if closing border is right after non trailing area we already counted it */
				durToCompress += DurBorderFromDnodeInside(grchnkextCompression.plsdnStartTrailing);
				}

			/* restore dcp in break dnode */
			posinlineBreak.plsdn->dcp = dcpOld;

			lserr = CanCompressText(&(grchnkextCompression.lsgrchnk), 
							&(grchnkextCompression.posichnkBeforeTrailing),
							LstflowFromSubline(GetCurrentSubline(plsc)),
 							durToCompress, &fCanCompress, &fLineCompressed, &durExtra);
			if (lserr != lserrNone)
				return lserr;
		
	        
			if (fCanCompress) 
				{
				SetLineCompressed(plsc, fLineCompressed);
				return SetBreakCore(&posinlineBreak, &brkout.objdim, brkkindDnodeBreak,
							 fHardStop, fTrue, breakrecMaxCurrent, pbreakrecCurrent, 
							 pbreakrecMacCurrent, pcpLimLine,
							 pdcpDepend, pendr, pfSuccessful);	
				}
			}
		}  /* FCompressionPossible */


	if (!fAllLineAfterRightMargin) 
	/* opposite is possible if we have left indent or auto number bigger then right margin */
	/* then we go to the force break */
		{
	
    	lserr = FindPrevBreakCore(plsc->urRightMarginBreak, &posinlineTruncate,	fTrue,
					  &brkout, &posinlineBreak, &brkkindDnodeBreak);	

		if (lserr != lserrNone)
			{
			return lserr;
			}
	
		if (brkout.fSuccessful) 
			{
			return SetBreakCore(&posinlineBreak, &brkout.objdim, brkkindDnodeBreak,
							 fHardStop, fTrue, breakrecMaxCurrent, pbreakrecCurrent, 
							 pbreakrecMacCurrent, pcpLimLine, 
							 pdcpDepend, pendr, pfSuccessful);	
			}

      	}


	/*   handling line without break opportunity   ( force break )   */
	plsc->plslineCur->lslinfo.fForcedBreak = fTrue;

	lserr = ForceBreakCore (plsc->urRightMarginBreak, &posinlineTruncate,
						fHardStop, fTrue, fAllLineAfterRightMargin,
						&brkout, &posinlineBreak, &brkkindDnodeBreak);	

	if (lserr != lserrNone)
		{
		return lserr;
		}

	/* not successful return means insufficient fetch */
	if (!brkout.fSuccessful)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}


	return SetBreakCore(&posinlineBreak, &brkout.objdim, brkkindDnodeBreak, 
							 fHardStop, fTrue, breakrecMaxCurrent, pbreakrecCurrent, 
							 pbreakrecMacCurrent, pcpLimLine,
							 pdcpDepend, pendr, pfSuccessful);
}



/* ---------------------------------------------------------------------- */

/* T R U N C A T E  C O R E */
/*----------------------------------------------------------------------------
    %%Function: TruncateCore
    %%Contact: igorzv
Parameters:
	plssubl				-	(IN) subline where to find truncation point
	urColumnMax			-	(IN) position of right margin
	pposinlineTruncate	-	(OUT) position of truncation point
	pfAllLineAfterRightMargin(OUT) because of left indent or autonumber all line is
								  after right margin

Find dnode that exceeds right margin and then asked it's handler to find 
truncation point
----------------------------------------------------------------------------*/
LSERR TruncateCore(PLSSUBL plssubl, long urColumnMax,  
					POSINLINE* pposinlineTruncate, BOOL* pfAllLineAfterRightMargin)				

{
	LSERR lserr;
	DWORD idObj;
	POINTUV point;
	POSICHNK posichnk;
	PLSCHUNKCONTEXT plschunkcontext;
	LOCCHNK* plocchnk;
	PLSC plsc = plssubl->plsc;
	PLSSUBL plssublOld;
	long urColumnMaxTruncate;
	BOOL fEndOfContent;
	BOOL fTruncationFound = fFalse;
	
	Assert(FBreakingAllowed(plsc));
	Assert((pposinlineTruncate != NULL) ); 

	plschunkcontext = PlschunkcontextFromSubline(plssubl);
	plocchnk = &(plschunkcontext->locchnkCurrent);
	
	GetCurrentPointSubl(plssubl, point);
	/* length of the subline should be larger then lenght of the column */
	Assert(point.u >= urColumnMax);

	pposinlineTruncate->plssubl = plssubl;
	pposinlineTruncate->pointStart = point;
	pposinlineTruncate->plsdn = GetCurrentDnodeSubl(plssubl);
	GetPointBeforeDnodeFromPointAfter(pposinlineTruncate->plsdn, &(pposinlineTruncate->pointStart));
	pposinlineTruncate->dcp = 0;


	/* find dnode contains right margin */
	if (!plsc->fAdvanceBack)
		{
		fEndOfContent = fFalse;
		while ((pposinlineTruncate->pointStart.u > urColumnMax)
			&& !fEndOfContent)
			{
			GoPrevPosInLine(pposinlineTruncate, fEndOfContent);
			}
		}
	else
		{
		/* in this case there is possible to have more then one dnode that contains right margin*/
		/* so we call more comprehensive procedure to find exactly the first one */
		FindFirstDnodeContainsRightMargin(urColumnMax, pposinlineTruncate);
		}

	*pfAllLineAfterRightMargin = fFalse;
	if (pposinlineTruncate->pointStart.u > urColumnMax) 
		{
		*pfAllLineAfterRightMargin = fTrue;
		}

		
	urColumnMaxTruncate = urColumnMax;
	if (FDnodeHasBorder(pposinlineTruncate->plsdn))
		{
		ApplyBordersForTruncation(pposinlineTruncate, &urColumnMaxTruncate, 
								  &fTruncationFound);
		}

	if (!fTruncationFound)
		{
		/* if pen or tab or we don't find dnode that starts before right margin return immediately */
		/* last case possible if we have left indent or auto number bigger then right margin */
		if (FIsDnodePen(pposinlineTruncate->plsdn) || pposinlineTruncate->plsdn->fTab || 
			FIsDnodeSplat(pposinlineTruncate->plsdn) ||
			pposinlineTruncate->pointStart.u > urColumnMaxTruncate)
			{
			return lserrNone;
			}
		
		SetUrColumnMaxForChunks(plschunkcontext, urColumnMaxTruncate);  
		
		lserr = CollectChunkAround(plschunkcontext, pposinlineTruncate->plsdn,
			pposinlineTruncate->plssubl->lstflow, 
			&pposinlineTruncate->pointStart);
		if (lserr != lserrNone)
			return lserr;
		
		idObj = IdObjFromChnk(plocchnk);
		
		/* we allow object handler to formate subline,
		so we restore current subline after calling him */
		plssublOld = GetCurrentSubline(plsc);
		SetCurrentSubline(plsc, NULL);
		
		lserr = PLsimFromLsc(&plsc->lsiobjcontext, idObj)->pfnTruncateChunk(
			plocchnk, &posichnk);
		if (lserr != lserrNone)
			return lserr;
		
		SetCurrentSubline(plsc, plssublOld);
		
		ResolvePosInChunk(plschunkcontext, posichnk, pposinlineTruncate); 
		
		
		/* if text sets truncation point before him, then move it after previous dnode */
		if (pposinlineTruncate->dcp == 0)
			{
			/* we allow this only for text */
			if (idObj == IobjTextFromLsc(&plsc->lsiobjcontext))
				{
				do
					{
					GoPrevPosInLine(pposinlineTruncate, fEndOfContent);
					Assert(!fEndOfContent); 
					/* such situation cann't occurs on the boundary of chunck */
					}
					while (FIsDnodeBorder(pposinlineTruncate->plsdn));
				}
			else
				{
				return lserrWrongTruncationPoint;
				}
			}
		}
	
	return lserrNone;
}

/* ---------------------------------------------------------------------- */

/* A P P L Y  B O R D E R S  F O R  T R U N C A T I O N */
/*----------------------------------------------------------------------------
    %%Function: ApplyBordersForTruncation
    %%Contact: igorzv
Parameters:
	pposinlineTruncate		-	(IN, OUT) position of truncation point
	purColumnMax			-	(IN, OUT) position of right margin
	pfTruncationFound		-	(OUT) this procedure can find truncation itself 

Change right margin because of border and find dnode to call truncation method.
----------------------------------------------------------------------------*/
static void ApplyBordersForTruncation(POSINLINE* pposinlineTruncate, 
									  long* purColumnMaxTruncate, BOOL* pfTruncationFound)
	{
	long durBorder;
	BOOL fEndOfContent = fFalse;
	PLSDNODE plsdn;

	*pfTruncationFound = fFalse;
	
	/* go back until open border or autonumber */ 
	if (FIsDnodeOpenBorder(pposinlineTruncate->plsdn))
		{
		/* move after border */
		durBorder = pposinlineTruncate->plsdn->u.pen.dur;
		GoNextPosInLine(pposinlineTruncate);
		Assert(!FIsDnodeBorder(pposinlineTruncate->plsdn)); 
		/* we should not have empty list between borders */
		}
	else
		{
		while (!FIsDnodeOpenBorder(pposinlineTruncate->plsdn->plsdnPrev) && !fEndOfContent)
			{
			GoPrevPosInLine(pposinlineTruncate, fEndOfContent);
			}
		if (!fEndOfContent)  /* we stopped on opening border */
			{
			Assert(pposinlineTruncate->plsdn->plsdnPrev);
			durBorder = pposinlineTruncate->plsdn->plsdnPrev->u.pen.dur;
			}
		else
			{
			/* we stopped because of autonumber */
			/* now we only need to take width of border from border dnode which located before 
			autonumber */
			plsdn = pposinlineTruncate->plsdn->plsdnPrev;
			while (!FIsDnodeOpenBorder(plsdn))
				{
				plsdn = plsdn->plsdnPrev;
				Assert(FIsLSDNODE(plsdn));
				}
			durBorder = plsdn->u.pen.dur;
			}
		}
	
	/* do we have enough room to put both opening and closing border */
	if (pposinlineTruncate->pointStart.u + durBorder <= *purColumnMaxTruncate)
		{
		/* if yes decrease margin and find new truncation dnode */
		*purColumnMaxTruncate -= durBorder;
		while (pposinlineTruncate->pointStart.u + DurFromDnode(pposinlineTruncate->plsdn)
			<= *purColumnMaxTruncate)
			{
			GoNextPosInLine(pposinlineTruncate);
			Assert(!FIsDnodeBorder(pposinlineTruncate->plsdn));
			/* this assert can be proved using the fact that end of closing border is beyond 
			original right margin */
			}
		}
	else
		{
		/* set truncation as the first character of this dnode */
		*pfTruncationFound = fTrue;
		pposinlineTruncate->dcp = 1;
		}
	}


/* ---------------------------------------------------------------------- */

/*  F I N D  P R E V  B R E A K  C O R E */
/*----------------------------------------------------------------------------
    %%Function: FindPrevBreakCore
    %%Contact: igorzv
Parameters:
	urColumnMax		-		(IN) width of column
	pposinlineTruncate -	(IN) position of truncation point
	fFirstSubline	-		(IN) to apply rules for first character to the first character of
							 this subline 
	pbrkout			-		(OUT)breaking information
	pposinlineBreak	-		(OUT)position of breaking point
	pbrkkindDnodeBreak	-	(OUT) how break was found

Going backword try to find first break opportunity before truncation point
----------------------------------------------------------------------------*/


LSERR FindPrevBreakCore( long urColumnMax,
						 POSINLINE* pposinlineTruncate, BOOL fFirstSubline,
						 BRKOUT* pbrkout, POSINLINE* pposinlineBreak,
						 BRKKIND* pbrkkindDnodeBreak)	
	{
	
	LSERR lserr;
	DWORD idObj;
	POSICHNK posichnk;
	BOOL fFound;
	PLSDNODE plsdn;
	PLSCHUNKCONTEXT plschunkcontext;
	LOCCHNK* plocchnk;
	BRKCOND brkcond;
	PLSC plsc = pposinlineTruncate->plssubl->plsc;
	POINTUV pointChunkStart;
	PLSSUBL plssublOld;
	
	
	Assert(FBreakingAllowed(plsc));
	Assert(FIsLSDNODE(pposinlineTruncate->plsdn));
	Assert(pposinlineBreak != NULL);

	*pbrkkindDnodeBreak = brkkindPrev;
	
	plschunkcontext = PlschunkcontextFromSubline(pposinlineTruncate->plssubl);
	plocchnk = &(plschunkcontext->locchnkCurrent);
	
	SetUrColumnMaxForChunks(plschunkcontext, urColumnMax);  

	Assert(!FIsDnodeBorder(pposinlineTruncate->plsdn));
	
	lserr = CollectChunkAround(plschunkcontext, pposinlineTruncate->plsdn,
		pposinlineTruncate->plssubl->lstflow, 
		&pposinlineTruncate->pointStart);
	if (lserr != lserrNone)
		return lserr;

	/* set fFirstOnLine */
	ApplyFFirstSublineToChunk(plschunkcontext, fFirstSubline);
	
	SetPosInChunk(plschunkcontext, pposinlineTruncate->plsdn, pposinlineTruncate->dcp, &posichnk);
	
	fFound = fTrue;
	
	/* for the chunk around truncation point we allow to make break after if it's text and
	   don't allow otherwise.
	   REVIEW:Such decision simplifyes code but produces some problems 
	   (with objects known so far more theoretical then practical).
	   There are two bad cases: non-text after text which (non-text) prohibites to break before
	and text which allowes to break*/
	
	idObj = IdObjFromChnk(plocchnk);
	
	if (idObj == IobjTextFromLsc(&plsc->lsiobjcontext))
		brkcond = brkcondCan;
	else
		brkcond = brkcondNever;
	
	while (fFound)
		{ 
		Assert(NumberOfDnodesInChunk(plocchnk) != 0);
		plsdn = plschunkcontext->pplsdnChunk[0];
		GetPointChunkStart(plocchnk, pointChunkStart);
		
		
		if (FIsDnodePen(plsdn) || plsdn->fTab || FIsDnodeSplat(plsdn))
			{
			Assert(NumberOfDnodesInChunk(plocchnk) == 1);
			/* only advance pen is allowed here */
			Assert(!FIsDnodePen(plsdn) || plsdn->fAdvancedPen);
			/* for the case of a pen we are passing garbage as an objdim 
			here assuming that it never be used */
			lserr = BreakTabPenSplat(plocchnk, fFalse, FBreakthroughLine(plsc),
									FIsDnodeSplat(plsdn), brkcond, 
									&(plsdn->u.real.objdim), pbrkout);
			if (lserr != lserrNone)
				return lserr;
			}
		else
			{
			
			idObj = IdObjFromDnode(plsdn);
			
			
			/* we allow object handler to formate subline,
			so we restore current subline after calling him */
			plssublOld = GetCurrentSubline(plsc);
			SetCurrentSubline(plsc, NULL);
			
			lserr = PLsimFromLsc(&plsc->lsiobjcontext, idObj)->pfnFindPrevBreakChunk(plocchnk,  
								&posichnk, brkcond, pbrkout);
			if (lserr != lserrNone)
				return lserr;
			
			SetCurrentSubline(plsc, plssublOld);

			
			} /* non tab */
		
		if (pbrkout->fSuccessful)  break;
		
		/* prepare next iteration */
		lserr = CollectPreviousChunk(plschunkcontext, &fFound);
		if (lserr != lserrNone)
			return lserr;
		
		if (fFound) 
			{
			posichnk.ichnk = ichnkOutside;
			/* posichnk.dcp is invalid */
			/* prepare brkcond for next iteration */
			brkcond = pbrkout->brkcond;
			}
		
		}  /* while */
	
	
	if (pbrkout->fSuccessful)
		{
		pposinlineBreak->plssubl = pposinlineTruncate->plssubl;


		if (pbrkout->posichnk.dcp == 0 && FIsDnodeReal(plschunkcontext->pplsdnChunk[0]))
			/* break before dnode */
			{
			lserr = MoveBreakAfterPreviousDnode(plschunkcontext, pbrkout, NULL, pbrkkindDnodeBreak); 
			/* this procedure can change chunkcontext */
			if (lserr != lserrNone)
				return lserr;

			}

		ResolvePosInChunk(plschunkcontext, (pbrkout->posichnk), pposinlineBreak);

		}
	
	
	return lserrNone;
	
}

/* ---------------------------------------------------------------------- */

/*  F I N D  N E X T  B R E A K  C O R E */
/*----------------------------------------------------------------------------
    %%Function: FindNextBreakCore
    %%Contact: igorzv
Parameters:
	urColumnMax		-		(IN) width of column
	pposinlineTruncate -	(IN) position of truncation point
	fFirstSubline	-		(IN) to apply rules for first character to the first character of
							 this subline 
	fStopped		-		(IN) formatting has been stopped by client
	pbrkout			-		(OUT) breaking information
	pposinlineBreak	-		(OUT) position of breaking point
	pbrkkindDnodeBreak	-	(OUT) how break was found

Going forward try to find first break opportunity after truncation point

----------------------------------------------------------------------------*/


LSERR FindNextBreakCore( long urColumnMax,  
						 POSINLINE* pposinlineTruncate, BOOL fFirstSubline, BOOL fStopped,
						 BRKOUT* pbrkout, POSINLINE* pposinlineBreak, BRKKIND* pbrkkindDnodeBreak)	

{

	LSERR lserr;
	DWORD idObj;
	POSICHNK posichnk;
	BOOL fFound;
	PLSDNODE plsdn;
	PLSCHUNKCONTEXT plschunkcontext;
	LOCCHNK* plocchnk;
	BRKCOND brkcond;
	PLSC plsc = pposinlineTruncate->plssubl->plsc;
	POINTUV pointChunkStart;
	PLSSUBL plssublOld;
	OBJDIM objdimPrevious;

	Assert(FBreakingAllowed(plsc));
	Assert(FIsLSDNODE(pposinlineTruncate->plsdn));
	Assert(pposinlineBreak != NULL);

	*pbrkkindDnodeBreak = brkkindNext;

	plschunkcontext = PlschunkcontextFromSubline(pposinlineTruncate->plssubl);
	plocchnk = &(plschunkcontext->locchnkCurrent);
	
	SetUrColumnMaxForChunks(plschunkcontext, urColumnMax); /* will be used by LsdnCheckAvailableSpace */ 

	Assert(!FIsDnodeBorder(pposinlineTruncate->plsdn));

	lserr = CollectChunkAround(plschunkcontext, pposinlineTruncate->plsdn,
							  pposinlineTruncate->plssubl->lstflow, 
							  &pposinlineTruncate->pointStart);
	if (lserr != lserrNone)
		return lserr;

	/* set fFirstOnLine */
	ApplyFFirstSublineToChunk(plschunkcontext, fFirstSubline);

	SetPosInChunk(plschunkcontext, pposinlineTruncate->plsdn,
				  pposinlineTruncate->dcp, &posichnk);

	fFound = fTrue;

	/* for the chunk around truncation point we prohibite to make break before */
	brkcond = brkcondNever;

	while (fFound)
		{ 
		Assert(NumberOfDnodesInChunk(plocchnk) != 0);
		plsdn = plschunkcontext->pplsdnChunk[0];

		GetPointChunkStart(plocchnk, pointChunkStart);
			
		if (FIsDnodePen(plsdn) || plsdn->fTab || FIsDnodeSplat(plsdn))
			{
			Assert(NumberOfDnodesInChunk(plocchnk) == 1);
			/* only advance pen is allowed here */
			Assert(!FIsDnodePen(plsdn) || plsdn->fAdvancedPen);
			/* for the case of a pen we are passing garbage as an objdim 
			here assuming that it never be used */
			lserr = BreakTabPenSplat(plocchnk, fTrue, FBreakthroughLine(plsc),
									FIsDnodeSplat(plsdn), brkcond, 
									&(plsdn->u.real.objdim), pbrkout);
			if (lserr != lserrNone)
				return lserr;
			}
		else
			{
			idObj = IdObjFromChnk(plocchnk);


			/* we allow object handler to formate subline,
			so we restore current subline after calling him */
			plssublOld = GetCurrentSubline(plsc);
			SetCurrentSubline(plsc, NULL);

			lserr = PLsimFromLsc(&plsc->lsiobjcontext, idObj)->pfnFindNextBreakChunk(plocchnk, 
				&posichnk, brkcond, pbrkout);
			if (lserr != lserrNone)
				return lserr;


			SetCurrentSubline(plsc, plssublOld);
			
			/* We ignore returned objdim in a case of brkcondNever. We don't expect 
			object to set correct one */
			if (!pbrkout->fSuccessful && pbrkout->brkcond == brkcondNever)
				pbrkout->objdim = (LastDnodeFromChunk(plschunkcontext))->u.real.objdim; 

				
			}  /* non tab */

		if (pbrkout->fSuccessful)  break;

		
		lserr = CollectNextChunk(plschunkcontext, &fFound);
		if (lserr != lserrNone)
			return lserr;

		if (fFound) 
			{
			posichnk.ichnk = ichnkOutside;
			/* posichnk.dcp is invalid */
			/* prepare brkcond for next iteration */
			brkcond = pbrkout->brkcond;
			/* we save objdim and trailing info for the case when next object 
			returns break before and we actually will set break in current object. */
			objdimPrevious = pbrkout->objdim;
			}

		}

	/* we cannot find break but formatting has been stopped by client */
	if (fStopped && !pbrkout->fSuccessful)
		{
		/* set break after last dnode */
		PosInChunkAfterChunk(plocchnk, pbrkout->posichnk);
		pbrkout->objdim = 
			(LastDnodeFromChunk(plschunkcontext))->u.real.objdim; 
		 /* We should use last dnode in chunk here to be sure not to get closing border.
		In the case of pen it's garbage, we assume that will not be used */
		pbrkout->fSuccessful = fTrue;
		}

	if (pbrkout->fSuccessful)
		{

		pposinlineBreak->plssubl = pposinlineTruncate->plssubl;
		if (pbrkout->posichnk.dcp == 0 && FIsDnodeReal(plschunkcontext->pplsdnChunk[0]))
			/* break before dnode */
			{
			lserr = MoveBreakAfterPreviousDnode(plschunkcontext, pbrkout, &objdimPrevious, pbrkkindDnodeBreak); 
			/* this procedure can change chunkcontext */
			if (lserr != lserrNone)
				return lserr;
			/* REVIEW: Is it possible to have garbage in objdimPrevious (somebody break brkcond */
			
			}
		
		ResolvePosInChunk(plschunkcontext, (pbrkout->posichnk), pposinlineBreak); 
		

		}
	else
		{
		}

	return lserrNone;
}


/* ---------------------------------------------------------------------- */

/*  F O R C E  B R E A K  C O R E */
/*----------------------------------------------------------------------------
    %%Function: ForceBreakCore
    %%Contact: igorzv
Parameters:
	urColumnMax		-		(IN) width of column
	pposinlineTruncate -	(IN) position of truncation point
	fStopped			-	(IN) formatting ended with hard break
	fFirstSubline	-		(IN) to apply rules for first character to the first character of
							 this subline 
	fAllLineAfterRightMargin(IN) lead to pass chunk otside in force break methods.
	pbrkout			-		(OUT)breaking information
	pposinlineBreak	-		(OUT)position of breaking point
	pbrkkindDnodeBreak	-	(OUT) how break was found

Invokes force break of chunk around truncation point
----------------------------------------------------------------------------*/



LSERR ForceBreakCore(
					 long urColumnMax,	
					 POSINLINE* pposinlineTruncate, 
					 BOOL fStopped, BOOL fFirstSubline,
					 BOOL fAllLineAfterRightMargin,
					 BRKOUT* pbrkout,
					 POSINLINE* pposinlineBreak, BRKKIND* pbrkkindDnodeBreak)
	{
	
	LSERR lserr;
	DWORD idObj;
	POSICHNK posichnk;
	LSCHUNKCONTEXT* plschunkcontext;
	LOCCHNK* plocchnk;
	PLSC plsc = pposinlineTruncate->plssubl->plsc;
	PLSSUBL plssublOld;
	
	
	Assert(FBreakingAllowed(plsc));
	Assert(FIsLSDNODE(pposinlineTruncate->plsdn));
	Assert(pposinlineBreak != NULL);
	
	*pbrkkindDnodeBreak = brkkindForce;
	
	plschunkcontext = PlschunkcontextFromSubline(pposinlineTruncate->plssubl);
	plocchnk = &(plschunkcontext->locchnkCurrent);
	
	if (plsc->grpfManager & fFmiForceBreakAsNext &&
		FIsSubLineMain(pposinlineTruncate->plssubl))
		/* find next break opportunity, client will scroll */
		{
		lserr = FindNextBreakCore(urColumnMax, pposinlineTruncate, fFirstSubline,
			fStopped, pbrkout, pposinlineBreak, pbrkkindDnodeBreak);
		if (lserr != lserrNone)
			return lserr;
		
		if (!pbrkout->fSuccessful)
			{
			/* increase right margin and fetch more */
			return lserrNone;
			}
		
		}
	else
		/* use force break method */
		{
		SetUrColumnMaxForChunks(plschunkcontext, urColumnMax);  
		
		Assert(!FIsDnodeBorder(pposinlineTruncate->plsdn));

		lserr = CollectChunkAround(plschunkcontext, pposinlineTruncate->plsdn,
			pposinlineTruncate->plssubl->lstflow, 
			&pposinlineTruncate->pointStart);
		if (lserr != lserrNone)
			{
			return lserr;
			}
		
		/* set fFirstOnLine */
		ApplyFFirstSublineToChunk(plschunkcontext, fFirstSubline);

		if (!fAllLineAfterRightMargin)
			{
			SetPosInChunk(plschunkcontext, pposinlineTruncate->plsdn,
				pposinlineTruncate->dcp, &posichnk);
			}
		else /* all chunk already behind right margin */
			{
			posichnk.ichnk = ichnkOutside;
			/* posichnk.dcp is invalid */
			}
		
		if (FIsDnodePen(pposinlineTruncate->plsdn) ||
			pposinlineTruncate->plsdn->fTab || FIsDnodeSplat(pposinlineTruncate->plsdn))
			{
			Assert(NumberOfDnodesInChunk(plocchnk) == 1);
			/* only advance pen is allowed here */
			Assert(!FIsDnodePen(pposinlineTruncate->plsdn) ||
				pposinlineTruncate->plsdn->fAdvancedPen);
			
			/* for the case of a pen we are passing garbage as an objdim 
			here assuming that it never be used */

			lserr = ForceBreakTabPenSplat(plocchnk, 
										  &(pposinlineTruncate->plsdn->u.real.objdim), 
										  pbrkout);
			if (lserr != lserrNone)
				return lserr;
			}
		else
			{
			
			idObj = IdObjFromChnk(plocchnk);
			
			/* we allow object handler to formate subline,
			so we restore current subline after calling him */
			plssublOld = GetCurrentSubline(plsc);
			SetCurrentSubline(plsc, NULL);
			
			lserr = PLsimFromLsc(&plsc->lsiobjcontext, idObj)->pfnForceBreakChunk(plocchnk, &posichnk, pbrkout);
			if (lserr != lserrNone)
				{
				return lserr;
				}
			

			SetCurrentSubline(plsc, plssublOld);
			}
		
		Assert(pbrkout->fSuccessful);
		

		pposinlineBreak->plssubl = pposinlineTruncate->plssubl;
		if (pbrkout->posichnk.dcp == 0 && FIsDnodeReal(plschunkcontext->pplsdnChunk[0]))
			/* break before dnode */
			{
			lserr = MoveBreakAfterPreviousDnode(plschunkcontext, pbrkout, NULL, pbrkkindDnodeBreak); 
			/* this procedure can change chunkcontext */
			if (lserr != lserrNone)
				return lserr;

			}

		ResolvePosInChunk(plschunkcontext, (pbrkout->posichnk), pposinlineBreak); 
		

		}
	return lserrNone;
}

/* ---------------------------------------------------------------------- */

/*  M O V E  B R E A K  A F T E R  P R E V I O U S  D N O D E */
/*----------------------------------------------------------------------------
    %%Function: MoveBreakAfterPreviousDnode
    %%Contact: igorzv
Parameters:
	plschunkcontext			-	(IN) chunk context
	pbrkout					-	(IN,OUT) brkout which can be changed 
	pobjdimPrev				-	(IN) suggested objdim for the dnode in previous chunk,
									 if NULL take objdim of dnode
	pbrkkind				-	(IN, OUT) how dnode was broken
----------------------------------------------------------------------------*/
static LSERR MoveBreakAfterPreviousDnode(
										 PLSCHUNKCONTEXT plschunkcontext,
										 BRKOUT* pbrkout, 
										 OBJDIM* pobjdimPrev,
										 BRKKIND* pbrkkind )	



	{
	LOCCHNK* plocchnk;
	LSERR lserr;
	BOOL fFound;
	
	Assert(pbrkout->posichnk.dcp == 0);
	Assert(FIsDnodeReal(plschunkcontext->pplsdnChunk[0]));
	
	/* because we do all operations on chunks we skip borders */
	
	plocchnk = &(plschunkcontext->locchnkCurrent);
	/* if break was set before chunk reset it after previous chunk */
	if (pbrkout->posichnk.ichnk == 0)
		{
		lserr = CollectPreviousChunk(plschunkcontext, &fFound);
		if (lserr != lserrNone)
			return lserr;
		
		if (fFound)
			{
			pbrkout->posichnk.ichnk = plocchnk->clschnk - 1;
			pbrkout->posichnk.dcp = plschunkcontext->pplsdnChunk[plocchnk->clschnk - 1]->dcp;
			if (pobjdimPrev != NULL)
				{
				pbrkout->objdim = *pobjdimPrev;
				}
			else
				{
				pbrkout->objdim = plschunkcontext->pplsdnChunk[plocchnk->clschnk - 1]
				->u.real.objdim; /* if it's pen then objdim is garbage which doesn't matter */
				*pbrkkind = brkkindImposedAfter; /* geometry has not prepared by object */
				}
			}

		}
	else
		{	/* just break after previous chunk element */
			pbrkout->posichnk.ichnk --;
			pbrkout->posichnk.dcp = plschunkcontext->pplsdnChunk[pbrkout->posichnk.ichnk]->dcp;
			pbrkout->objdim = plschunkcontext->pplsdnChunk[pbrkout->posichnk.ichnk]
												->u.real.objdim;
			*pbrkkind = brkkindImposedAfter; /* geometry has not prepared by object */
		}

	return lserrNone;
	}
	
/* ---------------------------------------------------------------------- */

/*  B R E A K  T A B  P E N  S P L A T*/
/*----------------------------------------------------------------------------
    %%Function: BreakTabPenSplat
    %%Contact: igorzv
Parameters:
	plocchnk			-	(IN) chunk contains tab or pen 
	fFindNext			-	(IN) is this functions used for next break
	fBreakThroughTab	-	(IN) there is a situation of breakthrough tab
	fSplat				-	(IN) we are breaking splat
	brkcond				-	(IN) condition of boundary break	
	pobjdim					(IN) to fill in objdim of break
	pbrkout				-	(OUT)breaking information

	
----------------------------------------------------------------------------*/


static LSERR BreakTabPenSplat(PLOCCHNK plocchnk, BOOL fFindNext, BOOL fBreakThroughTab, 
						 BOOL fSplat, BRKCOND brkcond, OBJDIM* pobjdim, BRKOUT* pbrkout)
	{
	Assert(NumberOfDnodesInChunk(plocchnk) == 1);

	if (fSplat)
		{
		pbrkout->fSuccessful = fTrue;
		PosInChunkAfterChunk(plocchnk, pbrkout->posichnk);
		pbrkout->objdim = *pobjdim;
		return lserrNone;
		}

	if (GetFFirstOnLineChunk(plocchnk) ||
		(fFindNext && brkcond == brkcondNever) ||
		fBreakThroughTab)
		{
		pbrkout->fSuccessful = fFalse;
		pbrkout->brkcond = brkcondCan;
		pbrkout->objdim = *pobjdim;
		return lserrNone;
		}
	else
		{
		pbrkout->fSuccessful = fTrue;
		pbrkout->posichnk.ichnk = 0;
		pbrkout->posichnk.dcp = 0;
		memset(&(pbrkout->objdim), 0, sizeof(pbrkout->objdim));
		return lserrNone;
		}
	}


/* ---------------------------------------------------------------------- */

/*  F O R C E  B R E A K  T A B  P E N  S P L A T*/
/*----------------------------------------------------------------------------
    %%Function: ForceBreakTabPenSplat
    %%Contact: igorzv
Parameters:
	plocchnk			-	(IN) chunk contains tab or pen 
	pobjdim					(IN) to fill in objdim of break
	pbrkout			-		(OUT)breaking information

	Returns break after chunk
----------------------------------------------------------------------------*/


static LSERR ForceBreakTabPenSplat(PLOCCHNK plocchnk, 
					 OBJDIM* pobjdim, BRKOUT* pbrkout)
	{
	Assert(NumberOfDnodesInChunk(plocchnk) == 1);
	
	pbrkout->fSuccessful = fTrue;
	PosInChunkAfterChunk(plocchnk, pbrkout->posichnk);
	pbrkout->objdim = *pobjdim;
	return lserrNone;
	
	}

/* ---------------------------------------------------------------------- */

/*  S E T  B R E A K  C O R E */
/*----------------------------------------------------------------------------
    %%Function: SetBreakCore
    %%Contact: igorzv
Parameters:
	pposinlineBreak	-		(IN) position of breaking point
	pobjdim			-		(IN) objdim of a breaking dnode
	brkkind			-		(IN) how break was found
	fStopped		-		(IN) formatting ends with hard break
	fGlueEop			-	(IN) if break after dnode check EOP after it
	breakrecMaxCurrent	-	(IN) size of the array of current line's break records
	pbreakrecCurrent	-	(OUT) current line's break records
	pbreakrecMacCurrent	-	(OUT) actual number of current line's break records 
	pcpLimLine		-		(OUT) cpLim of line to fill in
	pdcpDepend		-		(OUT) amount of characters after break that was formated to
								  make breaking decision
	pendr			-		(OUT) how line ends
	pfSuccessful	-		(OUT) fSuccessful: false means insufficient fetch 
	
Fill in break info
Change pfmtres in the case when hard break that we have because of excedeed margin 
	doesn't fit
If dcpBreak == 0  set break after previous dnode 
Call handler of break dnode to notice him about break
Set current context after break point
----------------------------------------------------------------------------*/

static LSERR SetBreakCore(
						  POSINLINE* pposinlineBreak, OBJDIM* pobjdim, BRKKIND brkkind,
						  BOOL fHardStop, BOOL fGlueEop, DWORD breakrecMaxCurrent,
						  BREAKREC* pbreakrecCurrent, DWORD* pbreakrecMacCurrent,
					      LSCP* pcpLimLine, LSDCP* pdcpDepend, ENDRES* pendr, 
						  BOOL* pfSuccessful)
	{
	
	DWORD idObj;
	PLSDNODE plsdnToChange;
	LSERR lserr;
	LSDCP dcpBreak;
	POINTUV pointBeforeDnode;
	long urBreak;
	long vrBreak;
	PLSSUBL plssubl = pposinlineBreak->plssubl;
	PLSC plsc = plssubl->plsc;
	PLSDNODE plsdnBreak;
	PLSSUBL plssublOld;
	BOOL fCrackDnode = fFalse;
	PLSDNODE plsdn;
	long urAdd;
	
	
	plsdnBreak = pposinlineBreak->plsdn;
	dcpBreak = pposinlineBreak->dcp;
	pointBeforeDnode = pposinlineBreak->pointStart;

	Assert(!FIsDnodeBorder(plsdnBreak));  /* border will be added later */
	AssertImplies(FIsFirstOnLine(plsdnBreak), dcpBreak != 0); /*to avoid infinitive loop */
	
	plsdnToChange = plsdnBreak;
	if (plsdnToChange->dcp != dcpBreak)
		/* if break is not after dnode than change cpLimOriginal */
		{
		plsdnToChange->cpLimOriginal = plsdnToChange->cpFirst + dcpBreak;
		plsdnToChange->dcp = dcpBreak;	
		fCrackDnode = fTrue;
		}
	
	if (FIsDnodeReal(plsdnToChange))
		SetDnodeObjdimFmt(plsdnToChange, *pobjdim);
	
	
	/* set state after break point  */
	urBreak = pointBeforeDnode.u + DurFromDnode(plsdnBreak);
	vrBreak = pointBeforeDnode.v + DvrFromDnode(plsdnBreak);
	
	if (FIsDnodeReal(plsdnBreak) && !plsdnBreak->fTab && !FIsDnodeSplat(plsdnBreak)) /* call set break of break dnode */
		{

		idObj = IdObjFromDnode(plsdnBreak);
		/* we allow object handler to formate subline,
		so we restore current subline after calling him */
		plssublOld = GetCurrentSubline(plsc);
		SetCurrentSubline(plsc, NULL);
		
		
		lserr = PLsimFromLsc(&plsc->lsiobjcontext, idObj)->pfnSetBreak(
					plsdnBreak->u.real.pdobj, brkkind, breakrecMaxCurrent, pbreakrecCurrent, 
					pbreakrecMacCurrent);
		if (lserr != lserrNone)
			return lserr;
		

		SetCurrentSubline(plsc, plssublOld);
		}

		/* if break after dnode and after it we have end of paragraph or spalt then we 
		should set break after end of paragraph  */
		if (fGlueEop && !fCrackDnode)
			{
			plsdn = plsdnBreak->plsdnNext;
			urAdd = 0;
			/* skip borders */
			while(plsdn != NULL && FIsDnodeBorder(plsdn))
				{
				urAdd += DurFromDnode(plsdn);
				plsdn = plsdn->plsdnNext;
				}
			
			if (plsdn == NULL && !fHardStop)
				{
				/* nothing has been fetched after break dnode which is not hard break */
				/* increase right margin and fetch more */
				*pfSuccessful = fFalse;
				return lserrNone;
				}
			
			AssertImplies(plsdn == NULL, fHardStop);
			/* next dnode EOP */
			if (plsdn != NULL && (FIsDnodeEndPara(plsdn) || FIsDnodeAltEndPara(plsdn)
								  || FIsDnodeSplat(plsdn)))
				{
				plsdnBreak = plsdn;
				urBreak += urAdd;
				urBreak += DurFromDnode(plsdn);
				}
			}

	/* move closing border */
	if (FBorderEncounted(plsc))
		{
		lserr = MoveClosingBorderAfterBreak(plssubl, fTrue, &plsdnBreak, &urBreak);
		if (lserr != lserrNone)
			return lserr;
		}


	/* below we handle situation of hard break that has stopped formatting */
	/* and if such dnode actually doesn't fit
	   we need to change final fmtres (can happened because of exceeded margin for formatting) */
	/* it's important to execute this check after moving border, because afterward border will
		never be next to hard break dnode */
	if (plsdnBreak != GetCurrentDnodeSubl(plssubl) || fCrackDnode)
		{
		fHardStop = fFalse;
		}

	/* prepare output */
	if (fHardStop)
		{
		/* in such case we should include hidden text after last dnode to a line */
		*pcpLimLine = GetCurrentCpLimSubl(plssubl);
		*pendr = EndrFromBreakDnode(plsdnBreak);
		}
	else
		{
		*pcpLimLine = (plsdnBreak)->cpLimOriginal;
		*pendr = endrNormal;
		}
	if (plsc->fHyphenated)  /* REVIEW why in context */
		{
		Assert(*pendr == endrNormal);
		*pendr = endrHyphenated;
		}

	*pdcpDepend = GetCurrentCpLimSubl(plssubl) - *pcpLimLine;
	

	/* set position of break in a subline */
	SetCurrentCpLimSubl(plssubl, *pcpLimLine);
	SetCurrentDnodeSubl(plssubl, plsdnBreak);
	SetCurrentUrSubl(plssubl, urBreak); 
	SetCurrentVrSubl(plssubl, vrBreak); 

	/* set boundaries for display */
	if (FIsDnodeSplat(plsdnBreak))
		{
		SetCpLimDisplaySubl(plssubl, GetCurrentCpLimSubl(plssubl) - 1);
		SetLastDnodeDisplaySubl(plssubl, GetCurrentDnodeSubl(plssubl)->plsdnPrev);
		}
	else
		{
		SetCpLimDisplaySubl(plssubl, GetCurrentCpLimSubl(plssubl));
		SetLastDnodeDisplaySubl(plssubl, GetCurrentDnodeSubl(plssubl));
		}
	
	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  M O V E  C L O S I N G  B O R D E R  A F T E R  B R E A K */
/*----------------------------------------------------------------------------
    %%Function: MoveClosingBorderAfterBreak
    %%Contact: igorzv
Parameters:
	plsc				-	(IN) subline
	fChangeList			-	(IN) do we need to change dnode list
								and change pplsdnBreak, or only to recalculate durBreak 
	pplsdnBreak			-	(IN,OUT) break dnode
	purBreak			-	(IN, OUT) position after break

  This procedure puts closing border into correct place, 
  takes into account trailing space logic.
----------------------------------------------------------------------------*/
LSERR MoveClosingBorderAfterBreak(PLSSUBL plssubl, BOOL fChangeList, PLSDNODE* pplsdnBreak,
								  long* purBreak) 
	{
	PLSDNODE plsdnBorder, plsdnBeforeBorder;
	long durBorder;
	PLSDNODE plsdnLastClosingBorder = NULL;
	LSERR lserr;
	PLSDNODE plsdnNext, plsdnPrev;
	PLSC plsc = plssubl->plsc;
	BOOL fBreakReached;
	BOOL fClosingBorderInsideBreak = fFalse;
	
	Assert(!FIsDnodePen(*pplsdnBreak));
	
	/* find dnode to insert border after, plus delete all borders which starts 
	inside trailing area*/
	plsdnBeforeBorder = GetCurrentDnodeSubl(plssubl);
	fBreakReached = (plsdnBeforeBorder == *pplsdnBreak);

	while (!fBreakReached 
		   ||
		   (plsdnBeforeBorder != NULL 
			&& (!FIsDnodeReal(plsdnBeforeBorder) 
			    || (FSpacesOnly(plsdnBeforeBorder, IobjTextFromLsc(&plsc->lsiobjcontext)))
			   )
		   )
		  )
		{
		/* pens can be only advanced so there is an object before REVIEW*/
		/* we skip borders in trailing area */
		plsdnPrev = plsdnBeforeBorder->plsdnPrev;
		if (FIsDnodeBorder(plsdnBeforeBorder))
			{
			if (FIsDnodeOpenBorder(plsdnBeforeBorder))
				{
				/* delete such dnode and correspondent closing border */
				/* decrease position of break */
				if (fBreakReached)
					*purBreak -= DurFromDnode(plsdnBeforeBorder);
				if (fChangeList)
					{
					RemoveBorderDnodeFromList(plsdnBeforeBorder);
					lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext,
						  plsdnBeforeBorder, plsc->fDontReleaseRuns);
					if (lserr != lserrNone)
						return lserr;
					}

				if (plsdnLastClosingBorder != NULL)
					{
					/* decrease position of break */
					if (fClosingBorderInsideBreak)
						*purBreak -= DurFromDnode(plsdnLastClosingBorder);
					if (fChangeList)
						{
						RemoveBorderDnodeFromList(plsdnLastClosingBorder);
						lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext,
							plsdnLastClosingBorder, plsc->fDontReleaseRuns);
						if (lserr != lserrNone)
							return lserr;
						}
					plsdnLastClosingBorder = NULL;
					}
				
				}
			else  /* closing border */
				{
				plsdnLastClosingBorder = plsdnBeforeBorder;
				fClosingBorderInsideBreak = fBreakReached;
				}
			}

		plsdnBeforeBorder = plsdnPrev;
		if (plsdnBeforeBorder == *pplsdnBreak)
			fBreakReached = fTrue;
		}
	
	if (plsdnBeforeBorder != NULL && FDnodeHasBorder(plsdnBeforeBorder))
		/* otherwise we don't need to move border */
		{
		
		/* set closing border */
		plsdnBorder = plsdnLastClosingBorder;
		Assert(FIsLSDNODE(plsdnBorder));
		Assert(FIsDnodeBorder(plsdnBorder));
		Assert(!plsdnBorder->fOpenBorder);
		
		if (fChangeList)
			{
			if (plsdnBeforeBorder->plsdnNext != plsdnBorder) /* otherwise nothing to move */
				{
				/* break link with closing border in the old place */
				RemoveBorderDnodeFromList(plsdnBorder);
				
				/* insert closing border into it new place */
				plsdnNext = plsdnBeforeBorder->plsdnNext;
				plsdnBeforeBorder->plsdnNext = plsdnBorder;
				plsdnBorder->plsdnPrev = plsdnBeforeBorder;
				plsdnBorder->plsdnNext = plsdnNext;
				if (plsdnNext != NULL)
					plsdnNext->plsdnPrev = plsdnBorder;
				plsdnBorder->fBorderMovedFromTrailingArea = fTrue;
				}
			
			/* change cp in border dnode */
			plsdnBorder->cpFirst = plsdnBeforeBorder->cpLimOriginal;
			plsdnBorder->cpLimOriginal = plsdnBorder->cpFirst;
			}
		
		/* increase widths of the line */
		if (!fClosingBorderInsideBreak)
			{
			durBorder = plsdnBorder->u.pen.dur;
			*purBreak += durBorder;
			}
		
		/* if we add closing border right after breaking dnode than consider border 
		as new breaking dnode */
		if (plsdnBeforeBorder == *pplsdnBreak && fChangeList)
			{
			*pplsdnBreak = plsdnBorder;
			}
		}
	return lserrNone;
	}


/* ---------------------------------------------------------------------- */

/*  R E M O V E  B O R D E R  D N O D E  F R O M  L I S T */
/*----------------------------------------------------------------------------
    %%Function: RemoveBorderDnodeFromList
    %%Contact: igorzv
Parameters:
	plsdnBorder			-	(IN) border dnode to remove

  This procedure removes border dnode from the list of dnodes.
----------------------------------------------------------------------------*/
static void	RemoveBorderDnodeFromList(PLSDNODE plsdnBorder)
	{
	PLSDNODE plsdnPrev;
	PLSDNODE plsdnNext;

	plsdnPrev = plsdnBorder->plsdnPrev;
	plsdnNext = plsdnBorder->plsdnNext;

	if (plsdnPrev != NULL)
		{
		plsdnPrev->plsdnNext = plsdnNext;
		}
	else
		{
		/* border was the first so change first dnode of subline */
		(SublineFromDnode(plsdnBorder))->plsdnFirst = plsdnNext;
		}

	if (plsdnNext != NULL)
		{
		plsdnNext->plsdnPrev = plsdnPrev;
		}
	else
		/* if border was the last then set new last dnode of subline */
		{
		SetCurrentDnodeSubl(SublineFromDnode(plsdnBorder), plsdnPrev);
		}
	
	plsdnBorder->plsdnNext = NULL;
	plsdnBorder->plsdnPrev = NULL;

	InvalidateChunk(PlschunkcontextFromSubline(SublineFromDnode(plsdnBorder)));
	}
/* ---------------------------------------------------------------------- */

/*  B R E A K  Q U I C K  C A S E */
/*----------------------------------------------------------------------------
    %%Function: BreakQuickCase
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) LineServices context
	fHardStop		-	(IN) formatting ended with hard break				
	pdcpDepend		-	(OUT) amount of characters after cpLim that was formated to find break
	pcpLim			-	(OUT) cpLim of line
	pfSuccessful	-	(OUT) can we find break through quick break
	pendr			-	(OUT) how line ended

  This quick procedure works if we have only text in a line.
  We try to find break just in the last dnode
----------------------------------------------------------------------------*/

LSERR BreakQuickCase(PLSC plsc, BOOL fHardStop, LSDCP* pdcpDepend,		
					 LSCP* pcpLim,	BOOL*  pfSuccessful, ENDRES* pendr)
					 
					 
	{
	LSDCP dcpBreak; 
	PLSDNODE plsdnBreak = GetCurrentDnode(plsc);
	LSERR lserr;
	
	*pfSuccessful = fFalse; 
	
	if (!fHardStop)
		{
		
		OBJDIM objdimBreak;
		
		lserr = QuickBreakText(plsdnBreak->u.real.pdobj, pfSuccessful, &dcpBreak, &objdimBreak );
		if (lserr != lserrNone)
			return lserr;
		
		if (*pfSuccessful)
			{  /* we found break */
			AdvanceCurrentUr(plsc, objdimBreak.dur - plsdnBreak->u.real.objdim.dur); 
			SetDnodeObjdimFmt(plsdnBreak, objdimBreak);
			plsdnBreak->dcp = dcpBreak;
			Assert(dcpBreak > 0); /* we don't allow Quickbreak to break before him */
			
								  /* in the case of QuickBreak cpLim is always equal to cpFirst + dcp,
			because otherwise is possible only with glyphs */
			plsdnBreak->cpLimOriginal = plsdnBreak->cpFirst + dcpBreak;
			*pcpLim = plsdnBreak->cpLimOriginal;
			*pdcpDepend = GetCurrentCpLim(plsc) - *pcpLim;
			*pendr = endrNormal;
			SetCurrentCpLim(plsc, *pcpLim);
			/* set boundaries for display */
			SetCpLimDisplay(plsc, *pcpLim);
			SetLastDnodeDisplay(plsc, plsdnBreak);
			}
		}   
	else   /* hard break */
		{
		*pfSuccessful = fTrue;
		*pcpLim = GetCurrentCpLim(plsc);
		*pdcpDepend = 0;
		/* plsdnBreak can be NULL because of deleting splat */
		*pendr = EndrFromBreakDnode(plsdnBreak);
		/* set boundaries for display */
		if (plsdnBreak != NULL && FIsDnodeSplat(plsdnBreak)) 
			{
			SetCpLimDisplay(plsc, *pcpLim - 1);
			SetLastDnodeDisplay(plsc, plsdnBreak->plsdnPrev);
			}
		else
			{
			SetCpLimDisplay(plsc, *pcpLim);
			SetLastDnodeDisplay(plsc, plsdnBreak);
			}
		}
	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  T R U N C A T E  S U B L I N E   C O R E */
/*----------------------------------------------------------------------------
    %%Function: TruncateSublineCore
    %%Contact: igorzv
Parameters:
	plssubl		-	(IN) subline context		
	urColumnMax	-	(IN) urColumnMax				
	pcpTruncate	-	(OUT) cpTruncate 				

----------------------------------------------------------------------------*/
LSERR TruncateSublineCore(PLSSUBL plssubl, long urColumnMax, LSCP* pcpTruncate)		
	{
	LSERR lserr;
	POSINLINE posinlineTruncate;
	BOOL fAllLineAfterRightMargin;

	Assert(FIsLSSUBL(plssubl));

	lserr = TruncateCore(plssubl, urColumnMax, &posinlineTruncate, &fAllLineAfterRightMargin);
	Assert(!fAllLineAfterRightMargin);
	if (lserr != lserrNone)
		return lserr;

	*pcpTruncate = GetCpLimFromPosInLine(posinlineTruncate) - 1;
	return lserrNone;
	}


/* ---------------------------------------------------------------------- */

/*  F I N D  P R E V  B R E A K  S U B L I N E   C O R E */
/*----------------------------------------------------------------------------
    %%Function: FindPrevBreakSublineCore
    %%Contact: igorzv
Parameters:
	plssubl			-		(IN) subline context	
	fFirstSubline	-		(IN) to apply rules for first character to the first character of
							 this subline 
	cpTruncate		-		(IN) truncation cp
	urColumnMax		-		(IN) urColumnMax				
	pfSuccessful	-		(OUT) do we find break?
	pcpBreak		-		(OUT) cp of break
	pobdimBreakSubline	-	(OUT) objdimSub up to break
	pbrkpos			-	(OUT) Before/Inside/After			

----------------------------------------------------------------------------*/

LSERR FindPrevBreakSublineCore(PLSSUBL plssubl, BOOL fFirstSubline, LSCP cpTruncate,
							long urColumnMax, BOOL* pfSuccessful, 
							LSCP* pcpBreak, POBJDIM pobdimBreakSubline, BRKPOS* pbrkpos)				
	{
	LSERR lserr;
	POSINLINE posinlineTruncate;
	BRKOUT brkout;
	PLSDNODE plsdnBreak;
	LSDCP dcpDnodeOld;
	OBJDIM objdimDnodeOld;
	PLSDNODE plsdnToChange;

	Assert(FIsLSSUBL(plssubl));

	if (plssubl->plsdnFirst == NULL)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}

	if (cpTruncate < plssubl->plsdnFirst->cpFirst)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}

	GetPosInLineTruncateFromCp(plssubl, cpTruncate, fTrue, &posinlineTruncate);

	lserr = FindPrevBreakCore(urColumnMax, &posinlineTruncate, fFirstSubline, 
							  &brkout, &(plssubl->pbrkcontext->posinlineBreakPrev),
							  &(plssubl->pbrkcontext->brkkindForPrev));
	if (lserr != lserrNone)
		return lserr;

	*pfSuccessful = brkout.fSuccessful;

	if (*pfSuccessful)
		{
		*pcpBreak = GetCpLimFromPosInLine(plssubl->pbrkcontext->posinlineBreakPrev);
		plssubl->pbrkcontext->objdimBreakPrev = brkout.objdim;
		plssubl->pbrkcontext->fBreakPrevValid = fTrue;
		plsdnBreak = plssubl->pbrkcontext->posinlineBreakPrev.plsdn;
		*pbrkpos = GetBrkpos(plsdnBreak,
						   plssubl->pbrkcontext->posinlineBreakPrev.dcp);
		
		/* we temporary change dnode to calculate objdim from the begining of subline */
		plsdnToChange = plsdnBreak; /* later plsdnBreak can be changed because of borders */
		dcpDnodeOld = plsdnToChange->dcp;
		objdimDnodeOld = plsdnToChange->u.real.objdim;
		plsdnToChange->dcp = plssubl->pbrkcontext->posinlineBreakPrev.dcp;
		SetDnodeObjdimFmt(plsdnToChange, brkout.objdim);


		lserr = FindListDims(plssubl->plsdnFirst, plsdnBreak, pobdimBreakSubline);
		if (lserr != lserrNone)
			return lserr;

		/* recalculate durBreak taking into account possible changes because of borders */
		if (FBorderEncounted(plssubl->plsc))
			{
			lserr = MoveClosingBorderAfterBreak(plssubl, fFalse, &plsdnBreak, 
												&(pobdimBreakSubline->dur));
			if (lserr != lserrNone)
				return lserr;
		}


		/*restore dnode */
		plsdnToChange->dcp = dcpDnodeOld ;
		SetDnodeObjdimFmt(plsdnToChange, objdimDnodeOld);
		}

	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  F I N D  N E X T  B R E A K  S U B L I N E   C O R E */
/*----------------------------------------------------------------------------
    %%Function: FindNextBreakSublineCore
    %%Contact: igorzv
Parameters:
	plssubl			-		(IN) subline context	
	fFirstSubline	-		(IN) to apply rules for first character to the first character of
							 this subline 
	cpTruncate		-		(IN) truncation cp
	urColumnMax		-		(IN) urColumnMax				
	pfSuccessful	-		(OUT) do we find break?
	pcpBreak		-		(OUT) cp of break
	pobdimBreakSubline	-	(OUT) objdimSub up to break
	pbrkpos			-	(OUT) Before/Inside/After			

----------------------------------------------------------------------------*/

LSERR FindNextBreakSublineCore(PLSSUBL plssubl, BOOL fFirstSubline, LSCP cpTruncate,
							long urColumnMax, BOOL* pfSuccessful,		
							LSCP* pcpBreak, POBJDIM pobdimBreakSubline, BRKPOS* pbrkpos)			
	{
	LSERR lserr;
	POSINLINE posinlineTruncate;
	BRKOUT brkout;
	PLSDNODE plsdnBreak;
	LSDCP dcpDnodeOld;
	OBJDIM objdimDnodeOld;
	PLSDNODE plsdnToChange;

	Assert(FIsLSSUBL(plssubl));

	if (plssubl->plsdnFirst == NULL)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}

	if (cpTruncate >= plssubl->plsdnLast->cpLimOriginal)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}

	GetPosInLineTruncateFromCp(plssubl, cpTruncate, fFalse, &posinlineTruncate);

	lserr = FindNextBreakCore(urColumnMax, &posinlineTruncate, fFirstSubline, fFalse, 
							  &brkout, &(plssubl->pbrkcontext->posinlineBreakNext), 
							  &(plssubl->pbrkcontext->brkkindForNext));
	if (lserr != lserrNone)
		return lserr;

	*pfSuccessful = brkout.fSuccessful;

	if (*pfSuccessful)
		{

		*pcpBreak = GetCpLimFromPosInLine(plssubl->pbrkcontext->posinlineBreakNext);
		plssubl->pbrkcontext->objdimBreakNext = brkout.objdim;
		plssubl->pbrkcontext->fBreakNextValid = fTrue;
		plsdnBreak = plssubl->pbrkcontext->posinlineBreakNext.plsdn;
		*pbrkpos = GetBrkpos(plsdnBreak,
						   plssubl->pbrkcontext->posinlineBreakNext.dcp);

		/* we temporary change dnode to calculate objdim from the begining of subline */
		plsdnToChange = plsdnBreak; /* later plsdnBreak can be changed because of borders */
		dcpDnodeOld = plsdnToChange->dcp;
		objdimDnodeOld = plsdnToChange->u.real.objdim;
		plsdnToChange->dcp = plssubl->pbrkcontext->posinlineBreakNext.dcp;
		SetDnodeObjdimFmt(plsdnToChange, brkout.objdim);

		lserr = FindListDims(plssubl->plsdnFirst, plsdnBreak, pobdimBreakSubline);
		if (lserr != lserrNone)
			return lserr;

		/* recalculate durBreak taking into account possible changes because of borders */
		if (FBorderEncounted(plssubl->plsc))
			{
			lserr = MoveClosingBorderAfterBreak(plssubl, fFalse, 
							&plsdnBreak, &(pobdimBreakSubline->dur));
			if (lserr != lserrNone)
				return lserr;
			}
	
		/*restore dnode */
		plsdnToChange->dcp = dcpDnodeOld ;
		SetDnodeObjdimFmt(plsdnToChange, objdimDnodeOld);
		}

	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  F O R C E  B R E A K  S U B L I N E   C O R E */
/*----------------------------------------------------------------------------
    %%Function: ForceBreakSublineCore
    %%Contact: igorzv
Parameters:
	plssubl			-		(IN) subline context	
	fFirstSubline	-		(IN) to apply rules for first character to the first character of
							 this subline 
	cpTruncate		-		(IN) truncation cp
	urColumnMax		-		(IN) urColumnMax				
	pcpBreak		-		(OUT) cp of break
	pobdimBreakSubline	-	(OUT) objdimSub up to break
	pbkrpos			-	(OUT) Before/Inside/After			

----------------------------------------------------------------------------*/

LSERR ForceBreakSublineCore(PLSSUBL plssubl, BOOL fFirstSubline, LSCP cpTruncate, 
							long urColumnMax, LSCP* pcpBreak,
							POBJDIM pobdimBreakSubline, BRKPOS* pbrkpos)	
	{
	LSERR lserr;
	BRKOUT brkout;
	LSDCP dcpDnodeOld;
	PLSDNODE plsdnBreak;
	OBJDIM objdimDnodeOld;
	POSINLINE posinlineTruncate;
	PLSDNODE plsdnToChange;

	Assert(FIsLSSUBL(plssubl));

	if (plssubl->plsdnFirst == NULL)
		return lserrCpOutsideSubline;

	if (cpTruncate < plssubl->plsdnFirst->cpFirst)
		cpTruncate = plssubl->plsdnFirst->cpFirst;

	GetPosInLineTruncateFromCp(plssubl, cpTruncate, fTrue, &posinlineTruncate);

	lserr = ForceBreakCore(urColumnMax, &posinlineTruncate,
							fFalse, fFirstSubline, fFalse, &brkout, 
							&(plssubl->pbrkcontext->posinlineBreakForce),
							  &(plssubl->pbrkcontext->brkkindForForce));
	if (lserr != lserrNone)
		return lserr;
	
	Assert(brkout.fSuccessful); /* force break should be successful for not a main line */
	
	*pcpBreak = GetCpLimFromPosInLine(plssubl->pbrkcontext->posinlineBreakForce);
	plssubl->pbrkcontext->objdimBreakForce = brkout.objdim;
	plssubl->pbrkcontext->fBreakForceValid = fTrue;
	plsdnBreak = plssubl->pbrkcontext->posinlineBreakForce.plsdn;
	*pbrkpos = GetBrkpos(plsdnBreak,
					   plssubl->pbrkcontext->posinlineBreakForce.dcp);
	
	/* we temporary change dnode to calculate objdim from the begining of subline */
	plsdnToChange = plsdnBreak; /* later plsdnBreak can be changed because of borders */
	dcpDnodeOld = plsdnToChange->dcp;
	objdimDnodeOld = plsdnToChange->u.real.objdim;
	plsdnToChange->dcp = plssubl->pbrkcontext->posinlineBreakForce.dcp;
	SetDnodeObjdimFmt(plsdnToChange, brkout.objdim);
	
	lserr = FindListDims(plssubl->plsdnFirst, plsdnBreak, pobdimBreakSubline);
	if (lserr != lserrNone)
		return lserr;
	
	/* recalculate durBreak taking into account possible changes because of borders */
	if (FBorderEncounted(plssubl->plsc))
		{
		lserr = MoveClosingBorderAfterBreak(plssubl, fFalse, 
					&plsdnBreak, &(pobdimBreakSubline->dur));
		if (lserr != lserrNone)
			return lserr;
		}

	/*restore dnode */
	plsdnToChange->dcp = dcpDnodeOld ;
	SetDnodeObjdimFmt(plsdnToChange, objdimDnodeOld);
	
	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  S E T  B R E A K  S U B L I N E   C O R E */
/*----------------------------------------------------------------------------
    %%Function: SetBreakSublineCore
    %%Contact: igorzv
Parameters:
	plssubl				-	(IN) subline context	
	brkkind,			-	(IN) Prev/Next/Force/Imposed						
	breakrecMaxCurrent	-	(IN) size of the array of current line's break records
	pbreakrecCurrent	-	(OUT) current line's break records
	pbreakrecMacCurrent	-	(OUT) actual number of current line's break records 
----------------------------------------------------------------------------*/

LSERR SetBreakSublineCore(PLSSUBL plssubl, BRKKIND brkkind, DWORD breakrecMaxCurrent,
							BREAKREC* pbreakrecCurrent, DWORD* pbreakrecMacCurrent)		

	{
	POSINLINE* pposinline;
	LSCP cpLim;
	LSDCP dcpDepend;
	OBJDIM* pobjdim;
	POSINLINE posinlineImposedAfter;
	BRKKIND brkkindDnode;
	BOOL fEndOfContent;
	ENDRES endr;
	BOOL fSuccessful;


	Assert(FIsLSSUBL(plssubl));


	/* invalidate chunkcontext, otherwise we will have wrong result of optimization there */
	InvalidateChunk(plssubl->plschunkcontext);

	switch (brkkind)
		{
		case brkkindPrev:
			if (!plssubl->pbrkcontext->fBreakPrevValid)
				return lserrWrongBreak;
			pposinline = &(plssubl->pbrkcontext->posinlineBreakPrev);
			pobjdim = &(plssubl->pbrkcontext->objdimBreakPrev);
			brkkindDnode = plssubl->pbrkcontext->brkkindForPrev;
			break;
		case brkkindNext:
			if (!plssubl->pbrkcontext->fBreakNextValid)
				return lserrWrongBreak;
			pposinline = &(plssubl->pbrkcontext->posinlineBreakNext);
			pobjdim = &(plssubl->pbrkcontext->objdimBreakNext);
			brkkindDnode = plssubl->pbrkcontext->brkkindForNext;
			break;
		case brkkindForce:
			if (!plssubl->pbrkcontext->fBreakForceValid)
				return lserrWrongBreak;
			pposinline = &(plssubl->pbrkcontext->posinlineBreakForce);
			pobjdim = &(plssubl->pbrkcontext->objdimBreakForce);
			brkkindDnode = plssubl->pbrkcontext->brkkindForForce;
			break;
		case brkkindImposedAfter:
			/* subline is empty: nothing to do */
			if (plssubl->plsdnFirst == NULL)
				return lserrNone;
			posinlineImposedAfter.plssubl =  plssubl;
			posinlineImposedAfter.plsdn = GetCurrentDnodeSubl(plssubl);
			GetCurrentPointSubl(plssubl, posinlineImposedAfter.pointStart);
			GetPointBeforeDnodeFromPointAfter(posinlineImposedAfter.plsdn,
							&(posinlineImposedAfter.pointStart));
			posinlineImposedAfter.dcp = GetCurrentDnodeSubl(plssubl)->dcp;
			while (FIsDnodeBorder(posinlineImposedAfter.plsdn))
				{
				GoPrevPosInLine(&posinlineImposedAfter, fEndOfContent);
				Assert(!fEndOfContent);
				}

			pposinline = &posinlineImposedAfter;
			/* for the case of a pen  we are passing garbage as an objdim, 
			 assuming that it will never be used */
			pobjdim = &(posinlineImposedAfter.plsdn->u.real.objdim);
			brkkindDnode = brkkindImposedAfter;
			break;
		default:
			return lserrWrongBreak;
		}




	return SetBreakCore(pposinline,	pobjdim, brkkindDnode, fFalse, fFalse, breakrecMaxCurrent,
						pbreakrecCurrent, pbreakrecMacCurrent, 
						&cpLim, &dcpDepend, &endr, &fSuccessful);
	}


/* ---------------------------------------------------------------------- */

/*  S Q U E E Z E  S U B L I N E   C O R E */
/*----------------------------------------------------------------------------
    %%Function: SqueezeSublineCore
    %%Contact: igorzv
Parameters:
	plssubl		-	(IN) subline context	
	durTarget	-	(IN) desirable width
	pfSuceessful-	(OUT) do we achieve the goal
	pdurExtra	-	(OUT) if nof successful, how much we fail
----------------------------------------------------------------------------*/
LSERR WINAPI SqueezeSublineCore(PLSSUBL plssubl, long durTarget, 
								BOOL* pfSuccessful, long* pdurExtra)														
	{
	
	GRCHUNKEXT grchnkextCompression;
	PLSC plsc;
	long durToCompress;
	BOOL fLineCompressed;
	LSERR lserr;
	
	Assert(FIsLSSUBL(plssubl));
	
	plsc = plssubl->plsc;
	durToCompress = GetCurrentUrSubl(plssubl) - durTarget; 

	InitGroupChunkExt(PlschunkcontextFromSubline(plssubl),
						IobjTextFromLsc(&plsc->lsiobjcontext), &grchnkextCompression);
	
	if (durToCompress > 0)
		{
		
		lserr = CollectPreviousTextGroupChunk(GetCurrentDnodeSubl(plssubl), CollectSublinesForCompression,
										  fFalse, /* simple text */
										  &grchnkextCompression);
		if (lserr != lserrNone)
			return lserr;
		
		durToCompress -= grchnkextCompression.durTrailing;

		if (FDnodeHasBorder(grchnkextCompression.plsdnStartTrailing))
			{
			/* we should reserve room for closing border */
			durToCompress += DurBorderFromDnodeInside(grchnkextCompression.plsdnStartTrailing);
			}

		lserr = CanCompressText(&(grchnkextCompression.lsgrchnk), 
								&(grchnkextCompression.posichnkBeforeTrailing),
								LstflowFromSubline(plssubl),
								durToCompress,	pfSuccessful,
								&fLineCompressed, pdurExtra);

		if (lserr != lserrNone)
			return lserr;
		
		
		}
	else 
		{
		*pdurExtra = 0; 
		*pfSuccessful = fTrue;
		}
	return lserrNone;
	
	}

/* ---------------------------------------------------------------------- */

/*  G E T  P O S  I N  L I N E  T R U N C A T E  F R O M  C P   */
/*----------------------------------------------------------------------------
    %%Function: GetPosInLineTruncateFromCp
    %%Contact: igorzv
Parameters:
	plssubl		-	(IN) subline context	
	cp			-	(IN) cp of position
	pposinline	-	(OUT) position in a subline
----------------------------------------------------------------------------*/
void GetPosInLineTruncateFromCp(
							PLSSUBL plssubl,	/* IN: subline						*/
							LSCP cp,			/* IN: cp of a position */
							BOOL fSnapPrev,		/* IN: direction of snapping hidden cp */
							POSINLINE* pposinline)	/* OUT: position in a subline */
	{
	PLSDNODE plsdn;
	BOOL fSuccessful = fFalse;
	BOOL fLastReached = fFalse;
	BOOL fPassed = fFalse;
	LSDCP dcp;

	Assert(FIsLSSUBL(plssubl));

	pposinline->plssubl = plssubl;
	pposinline->pointStart.u = 0;
	pposinline->pointStart.v = 0;

	plsdn = plssubl->plsdnFirst;
	while(!fSuccessful && !fLastReached &&!fPassed)
		{
		Assert(plsdn != NULL);
		Assert(FIsLSDNODE(plsdn));

		if (plsdn == plssubl->plsdnLast)
			fLastReached = fTrue;

		if (plsdn->cpFirst > cp) /* our cp is not inside any dnode */
			{
			fPassed = fTrue;
			}
		else
			{
			if (cp < plsdn->cpLimOriginal)
				{
				fSuccessful = fTrue;
				pposinline->plsdn = plsdn;
				dcp = cp - plsdn->cpFirst + 1;
				if (dcp <= plsdn->dcp)		/* such calculations are because of a case of ligature */
					pposinline->dcp = dcp;  /* across hiden text, in such case cpLimOriginal */
				else						/* is not equal to cpFirst + dcp	*/
					pposinline->dcp = plsdn->dcp;	/* such calculation doesn't guarantee exact cp, */
				}							/* but at least in the same ligature */
			else
				{
				if (!fLastReached)
					{
					pposinline->pointStart.u += DurFromDnode(plsdn);
					pposinline->pointStart.v += DvrFromDnode(plsdn);
					plsdn = plsdn->plsdnNext;
					}
				}
			}
		}

	if (!fSuccessful)
		{
		if (fSnapPrev)
			{
			/* snap to previous dnode */
			if (fPassed)
				{
				Assert(plsdn != NULL); /* we don't allow caller to pass cp before first dnode */
				plsdn = plsdn->plsdnPrev;
				/* skip borders */
				while(FIsDnodeBorder(plsdn))
					{
					plsdn = plsdn->plsdnPrev;
					}
				Assert(plsdn != NULL); 
				pposinline->plsdn = plsdn;
				pposinline->dcp = plsdn->dcp;
				pposinline->pointStart.u -= DurFromDnode(plsdn);
				pposinline->pointStart.v -= DvrFromDnode(plsdn);
				}
			else
				{
				Assert(fLastReached);
				/* skip borders */
				while(FIsDnodeBorder(plsdn))
					{
					plsdn = plsdn->plsdnPrev;
					}
				Assert(plsdn != NULL); 
				pposinline->plsdn = plsdn;
				pposinline->dcp = plsdn->dcp;
				}
			}
		else
			{
			/* snap to current dnode */
			if (fPassed)
				{
				/* skip borders */
				while(FIsDnodeBorder(plsdn))
					{
					plsdn = plsdn->plsdnNext;
					}
				Assert(plsdn != NULL); 
				pposinline->plsdn = plsdn;
				pposinline->dcp = 1;
				}
			else
				{
				Assert(fLastReached);
				/* we don't allow caller to pass cp after last dnode */
				NotReached();
				}
			}

		}

	}
/* ---------------------------------------------------------------------- */

/*  F I N D  F I R S T  D N O D E  C O N T A I N S  R I G H T  M A R G I N */
/*----------------------------------------------------------------------------
    %%Function: FindFirstDnodeContainsRightMargin
    %%Contact: igorzv
Parameters:
	urColumnMax	-	(IN) right margin
	pposinline	-	(IN,OUT) position in a subline: before position in the end,
							 after first position contains right margin
----------------------------------------------------------------------------*/

static void FindFirstDnodeContainsRightMargin(long urColumnMax, POSINLINE* pposinlineTruncate)
	{
	POSINLINE posinline;
	BOOL fOutside;
	BOOL fFound = fFalse;
	BOOL fEndOfContent;
	
	posinline = *pposinlineTruncate;

	// we know that last done ends after right margin
	Assert(posinline.pointStart.u + DurFromDnode(posinline.plsdn) > urColumnMax);
	fOutside = fTrue;
	
	fEndOfContent = fFalse;
	do 
		{
		if (posinline.pointStart.u <= urColumnMax)
			{
			if (fOutside)
				{
				fFound = fTrue;
				*pposinlineTruncate = posinline;
				}
			fOutside = fFalse;
			}
		else
			{
			fOutside = fTrue;
			}
		GoPrevPosInLine(&posinline, fEndOfContent);	
		}	while (!fEndOfContent);

	if (!fFound)
		{
		*pposinlineTruncate = posinline;  // we cann't right dnode and return fisrt dnode to report situation
		}
	}


/* ---------------------------------------------------------------------- */

/*  G E T  L I N E  D U R  C O R E */
/*----------------------------------------------------------------------------
    %%Function: GetLineDurCore
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) LS context
	pdurInclTrail	-	(OUT) dur of line incl. trailing area
	pdurExclTrail	-	(OUT)  dur of line excl. trailing area

----------------------------------------------------------------------------*/

LSERR  GetLineDurCore	(PLSC plsc,	long* pdurInclTrail, long* pdurExclTrail)
	{
	PLSDNODE plsdn;
	LSERR lserr;
	long durTrail;
	LSDCP dcpTrail;
	PLSDNODE plsdnStartTrail;
	LSDCP dcpStartTrailingText;
	int cDnodesTrailing;
	PLSDNODE plsdnTrailingObject;
	LSDCP dcpTrailingObject;
	BOOL fClosingBorderStartsTrailing;

	plsdn = GetCurrentDnode(plsc); 
	*pdurInclTrail = GetCurrentUr(plsc);
	*pdurExclTrail = *pdurInclTrail;

	
	if (plsdn != NULL && !FIsNotInContent(plsdn))
		{
		
		lserr = GetTrailingInfoForTextGroupChunk(plsdn, plsdn->dcp, 
			IobjTextFromLsc(&plsc->lsiobjcontext),
			&durTrail, &dcpTrail, &plsdnStartTrail,
			&dcpStartTrailingText, &cDnodesTrailing, &plsdnTrailingObject,
			&dcpTrailingObject, &fClosingBorderStartsTrailing);
		
		if (lserr != lserrNone) 
			return lserr;
		
		*pdurExclTrail = *pdurInclTrail - durTrail;
		}
	
	return lserrNone;
	
	}


/* ---------------------------------------------------------------------- */

/*  G E T  M I N  D U R  B R E A K S  C O R E */
/*----------------------------------------------------------------------------
    %%Function: GetMinDurBreaksCore
    %%Contact: igorzv
Parameters:
	plsc				-	(IN) LS context
	pdurMinInclTrail	-	(OUT) min dur between breaks including trailing area
	pdurMinExclTrail	-	(OUT) min dur between breaks excluding trailing area

----------------------------------------------------------------------------*/

LSERR  GetMinDurBreaksCore	(PLSC plsc,	long* pdurMinInclTrail, long* pdurMinExclTrail)
	{
	LSERR lserr;
	PLSCHUNKCONTEXT plschunkcontext;
	LOCCHNK* plocchnk;
	POINTUV point;
	long durTrail;
	DWORD cchTrail;
	POSINLINE posinline;
	POSINLINE posinlineBreak;
	BRKOUT brkout;
	long urBreakInclTrail = 0;
	long urBreakExclTrail = 0;
	long urBreakInclTrailPrev;
	long urBreakExclTrailPrev;
	BOOL fEndOfContent = fFalse;
	BRKKIND brkkind;
	PLSDNODE plsdnStartTrail;
	LSDCP dcpStartTrailingText;
	int cDnodesTrailing;
	PLSDNODE plsdnTrailingObject;
	LSDCP dcpTrailingObject;
	BOOL fClosingBorderStartsTrailing;
	
	
	plschunkcontext = PlschunkcontextFromSubline(GetCurrentSubline(plsc));
	plocchnk = &(plschunkcontext->locchnkCurrent);
	
	*pdurMinInclTrail = 0;
	*pdurMinExclTrail = 0;
	GetCurrentPoint(plsc, point);
	posinline.plssubl = GetCurrentSubline(plsc);
	posinline.pointStart = point;
	posinline.plsdn = GetCurrentDnode(plsc); 
	
	urBreakInclTrail = GetCurrentUr(plsc);
	urBreakExclTrail = urBreakInclTrail;

	/* REVIEW rewrite without code duplication and some probably superflous lines */
	/* don't forget about problem of dnode which submitted subline for trailing and skiping trailing
	area( tailing area in subline and dcp in parent dnode */


	if (posinline.plsdn != NULL && !FIsNotInContent(posinline.plsdn))
		{
		GetPointBeforeDnodeFromPointAfter(posinline.plsdn, &(posinline.pointStart));
		posinline.dcp = posinline.plsdn->dcp;
		
		lserr = GetTrailingInfoForTextGroupChunk(posinline.plsdn, posinline.dcp, 
			IobjTextFromLsc(&plsc->lsiobjcontext),
			&durTrail, &cchTrail, &plsdnStartTrail,
			&dcpStartTrailingText, &cDnodesTrailing,
			&plsdnTrailingObject, &dcpTrailingObject, &fClosingBorderStartsTrailing);
		
		if (lserr != lserrNone) 
			return lserr;
		
		urBreakExclTrail = urBreakInclTrail - durTrail;
		
		/* move before trailing area */
		while (posinline.plsdn != plsdnTrailingObject)
			{
			Assert(!fEndOfContent);
			GoPrevPosInLine(&posinline, fEndOfContent);
			}
		posinline.dcp = dcpTrailingObject;
		if (posinline.dcp == 0) /* move break before previous dnode */
			{
			do
				{
				GoPrevPosInLine(&posinline, fEndOfContent);
				/* we allow to put break before the first dnode but stop loop here */
				}
				while (!fEndOfContent && FIsDnodeBorder(posinline.plsdn) );
			}
		}
	else
		{
		fEndOfContent = fTrue;
		}

	if (fEndOfContent)
		{
		*pdurMinInclTrail = urBreakInclTrail;
		*pdurMinExclTrail = urBreakExclTrail;
		}


	while(!fEndOfContent)
		{
		/* find previous break */
		lserr = FindPrevBreakCore(urBreakInclTrail, &posinline,	fTrue,
			&brkout, &posinlineBreak, &brkkind);	
		if (lserr != lserrNone)
			return lserr;
		
		if (brkout.fSuccessful)
			{
			urBreakInclTrailPrev = posinlineBreak.pointStart.u + brkout.objdim.dur;
			lserr = GetTrailingInfoForTextGroupChunk(posinlineBreak.plsdn, 
				posinlineBreak.dcp, 
				IobjTextFromLsc(&plsc->lsiobjcontext),
				&durTrail, &cchTrail, &plsdnStartTrail,
				&dcpStartTrailingText, &cDnodesTrailing,
				&plsdnTrailingObject, &dcpTrailingObject, &fClosingBorderStartsTrailing);
			
			if (lserr != lserrNone) 
				return lserr;
			
			urBreakExclTrailPrev = urBreakInclTrailPrev - durTrail;
			
			/* commands bellow prepare posinline for the next iteration */
			if (posinlineBreak.plsdn->cpFirst > posinline.plsdn->cpFirst 
				|| (posinlineBreak.plsdn == posinline.plsdn && 
				    posinlineBreak.dcp >= posinline.dcp
					)
			   )
				{
				/* we are trying to avoid an infinite loop */
				if (posinline.dcp != 0) posinline.dcp--; 
				/* posinline.dcp can be equal to 0 here in the case pen, 
				code bellow under if (posinline.dcp == 0) will help us to avoid infinite loop in such case*/ 
				}
			else
				{
				posinline = posinlineBreak;
				/* move before trailing area */
				while (posinline.plsdn != plsdnTrailingObject)
					{
					Assert(!fEndOfContent);
					GoPrevPosInLine(&posinline, fEndOfContent);
					}
				posinline.dcp = dcpTrailingObject;

				}
			
			if (posinline.dcp == 0) /* move break before previous dnode */
				{
				do
					{
					GoPrevPosInLine(&posinline, fEndOfContent);
					/* we allow to put break before the first dnode but stop loop here */
					}
				while (!fEndOfContent && FIsDnodeBorder(posinline.plsdn) );
				}
			}
		else
			{
			urBreakInclTrailPrev = 0;
			urBreakExclTrailPrev = 0;
			fEndOfContent = fTrue;
			}
		
		/* calculate current value of the maximum distance between two break opportunites */
		if (urBreakInclTrail - urBreakInclTrailPrev > *pdurMinInclTrail)
			*pdurMinInclTrail = urBreakInclTrail - urBreakInclTrailPrev;
		
		if (urBreakExclTrail - urBreakInclTrailPrev > *pdurMinExclTrail)
			*pdurMinExclTrail = urBreakExclTrail - urBreakInclTrailPrev;
		
		/* prepare next iteration */
		urBreakInclTrail = urBreakInclTrailPrev;
		urBreakExclTrail = urBreakExclTrailPrev;
		
		}
	return lserrNone;
	
	}
	

/* F  C A N  B E F O R E  N E X T  C H U N K  C O R E */
/*----------------------------------------------------------------------------
    %%Function: FCanBreakBeforeNextChunkCore
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Last DNODE of the current chunk 
	pfCanBreakBeforeNextChun-(OUT) Can break before next chunk ? 

Called by text during find previous break when it's going to set break after last text dnode.
Procedure forwards this question to the next after text object
----------------------------------------------------------------------------*/

LSERR FCanBreakBeforeNextChunkCore(PLSC  plsc, PLSDNODE plsdn,	BOOL* pfCanBreakBeforeNextChunk)
	{
	LSERR lserr;
	PLSCHUNKCONTEXT plschunkcontextOld;
	PLSCHUNKCONTEXT plschunkcontextNew;
	BOOL fFound;
	PLSDNODE plsdnInChunk;
	DWORD idObj;
	POSICHNK posichnk;
	BRKCOND brkcond;
	PLSSUBL plssublOld;
	BRKOUT brkout;
	
	
	plschunkcontextOld = PlschunkcontextFromSubline(SublineFromDnode(plsdn));
	/* plsdnode should be the last dnode of the current chunk */
	Assert(plsdn == LastDnodeFromChunk(plschunkcontextOld));
	
	lserr = DuplicateChunkContext(plschunkcontextOld, &plschunkcontextNew);
	if (lserr != lserrNone)
		return lserr;
	
	lserr = CollectNextChunk(plschunkcontextNew, &fFound);
	if (lserr != lserrNone)
		return lserr;
	
	if (fFound)
		{
		plsdnInChunk = plschunkcontextNew->pplsdnChunk[0];
		
		if (FIsDnodePen(plsdnInChunk) || plsdnInChunk->fTab || FIsDnodeSplat(plsdnInChunk))
			{
			*pfCanBreakBeforeNextChunk = fTrue;
			}
		else
			{
			idObj = IdObjFromDnode(plsdnInChunk);
			
			
			/* we allow object handler to formate subline,
			so we restore current subline after calling him */
			plssublOld = GetCurrentSubline(plsc);
			SetCurrentSubline(plsc, NULL);
			
			
			/* we set truncation point to the first cp in chunk */
			posichnk.ichnk = 0;
			posichnk.dcp = 1;
			brkcond = brkcondCan;
			
			lserr = PLsimFromLsc(
				&plsc->lsiobjcontext, idObj)->pfnFindPrevBreakChunk(&(plschunkcontextNew->locchnkCurrent),  
				&posichnk, brkcond, &brkout);
			if (lserr != lserrNone)
				return lserr;
			
			SetCurrentSubline(plsc, plssublOld);
			
			if (!brkout.fSuccessful && brkout.brkcond == brkcondNever)
				*pfCanBreakBeforeNextChunk = fFalse;
			else
				*pfCanBreakBeforeNextChunk = fTrue;
			
			}
		}
	
	else
		{
		/* it cann't happen on a main subline */
		Assert(!FIsSubLineMain(SublineFromDnode(plsdn)));
		*pfCanBreakBeforeNextChunk = fTrue;
		}
	
	
	DestroyChunkContext(plschunkcontextNew);
	return lserrNone;
	
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\autonum.c ===
#include	"lsidefs.h"
#include	"autonum.h"
#include	"lscbk.h"
#include	<limits.h>
#include	"lsmem.h"						/* memset() */
#include	"lsesc.h"
#include	"fmti.h"
#include	"objdim.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnfin.h"
#include	"lsdssubl.h"
#include	"dispi.h"
#include	"lsdnode.h"
#include	"tabutils.h"
#include	"lscaltbd.h"
#include	"lstbcon.h"
#include	"lsdnset.h"
#include	"lsensubl.h"
#include	"dninfo.h"


struct ilsobj
{
    POLS				pols;
	LSCBK				lscbk;
	PLSC				plsc;
	DWORD				idObj;
	LSESC				lsescautonum;
};



struct dobj
{
	PILSOBJ				pilsobj;			/* ILS object */
	PLSSUBL				plssubl;			/* Handle to subline for autonumbering text */
};

		
#define ZeroMemory(a, b) memset(a, 0, b);

/* M A X */
/*----------------------------------------------------------------------------
    %%Macro: Max
    %%Contact: igorzv

	Returns the maximum of two values a and b.
----------------------------------------------------------------------------*/
#define Max(a,b)			((a) < (b) ? (b) : (a))


/* A U T O N U M  C R E A T E  I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: autonumCreateILSObj
	%%Contact: igorzv
	Parameters
	pols	-	(IN) client application context	
	plsc	-	(IN) ls context
	pclscbk	-	(IN) callbacks to client application
	idObj	-	(IN) id of the object
	ppilsobj-	(OUT)object ilsobj


	Create the ILS object for all autonumbering objects.
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumCreateILSObj(POLS pols,	PLSC plsc, 
				PCLSCBK pclscbk, DWORD idObj, PILSOBJ *ppilsobj)
{
    PILSOBJ pilsobj;


    pilsobj = pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (NULL == pilsobj)
	{
		return lserrOutOfMemory;
	}

    pilsobj->pols = pols;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = plsc;
	pilsobj->idObj = idObj;

	*ppilsobj = pilsobj;
	return lserrNone;
}

/* S E T  A U T O N U M  C O N F I G */
/*----------------------------------------------------------------------------
	%%Function: SetAutonumConfig
	%%Contact: igorzv
	Parameters
	pilsobj			-	(IN) object ilsobj
	plstxtconfig	-	(IN) definition of special characters 

	Set ecs character for autonumbering sequence
----------------------------------------------------------------------------*/
LSERR  SetAutonumConfig(PILSOBJ pilsobj, const LSTXTCFG* plstxtconfig)
	{

	pilsobj->lsescautonum.wchFirst = plstxtconfig->wchEscAnmRun;
	pilsobj->lsescautonum.wchLast = plstxtconfig->wchEscAnmRun;

	return lserrNone;
	}

/* A U T O N U M   D E S T R O Y  I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: AutonumDestroyILSObj
	%%Contact: igorzv
	Parameters
	pilsobj			-	(IN) object ilsobj

	Free all resources assocaiated with autonum ILS object.
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumDestroyILSObj(PILSOBJ pilsobj)	
{
	pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pilsobj);
	return lserrNone;
}

/* A U T O N U M   S E T  D O C */
/*----------------------------------------------------------------------------
	%%Function: AutonumSetDoc
	%%Contact: igorzv
	Parameters
	pilsobj			-	(IN) object ilsobj
	pclsdocinf		-	(IN) initialization data of the document level

	Empty function
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumSetDoc(PILSOBJ pilsobj,	PCLSDOCINF pclsdocinf)		
{
	Unreferenced(pilsobj);
	Unreferenced(pclsdocinf);

	return lserrNone;
}


/* A U T O N U M   C R E A T E   L N O B J */
/*----------------------------------------------------------------------------
	%%Function: AutonumCreateLNObj
	%%Contact: igorzv
	Parameters
	pilsobj			-	(IN) object ilsobj
	pplnobj			-	(OUT)object lnobj

	Create the Line Object for the autonum. No real need for a line
	object so don't allocated it.
	
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumCreateLNObj(	PCILSOBJ pcilsobj, PLNOBJ *pplnobj)	
{
	*pplnobj = (PLNOBJ) pcilsobj;
	return lserrNone;
}

/* A U T O N U M  D E S T R O Y  L N O B J */
/*----------------------------------------------------------------------------
	%%Function: AautonumDestroyLNObj
	%%Contact: igorzv
	Parameters
	pplnobj			-	(IN) object lnobj


	Frees resources associated with the autonum line object. Since
	there isn't any this is a no-op.
	
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumDestroyLNObj(PLNOBJ plnobj)				

{
	Unreferenced(plnobj);
	return lserrNone;
}

/* A U T O N U M   F M T */
/*----------------------------------------------------------------------------
	%%Function: AutonumFmt
	%%Contact: igorzv
	Parameters
	pplnobj		-	(IN) object lnobj
	pcfmtin		-	(IN) formatting input
	pfmtres		-	(OUT)formatting result

	Format the autonum object. 
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumFmt(PLNOBJ plnobj, PCFMTIN pcfmtin,	FMTRES *pfmtres)	
{
	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	LSCP cpStartMain = pcfmtin->lsfgi.cpFirst;
	LSCP cpOut;
	LSTFLOW lstflow = pcfmtin->lsfgi.lstflow;
	FMTRES fmtres;
	OBJDIM objdimAll;
	LSDCP dcp;
	PLSDNODE plsdnFirst;
	PLSDNODE plsdnLast;
	BOOL fSuccessful;

    /*
     * Allocate the DOBJ
     */
    pdobj = pilsobj->lscbk.pfnNewPtr(pilsobj->pols, sizeof(*pdobj));

    if (NULL == pdobj)
		{
		return lserrOutOfMemory;
		}

	ZeroMemory(pdobj, sizeof(*pdobj));
	pdobj->pilsobj = pilsobj;

	/*
	 * Build main line of text
	 */

	lserr = LsCreateSubline(pilsobj->plsc, cpStartMain,	uLsInfiniteRM,
							lstflow, fFalse);	/*  because fContiguous is false 
												all tabs will be skipped*/ 
	if (lserr != lserrNone)
		{
		AutonumDestroyDobj(pdobj);
		return lserr;
		}

	lserr = LsFetchAppendToCurrentSubline(pilsobj->plsc, 0,	&(pilsobj->lsescautonum),
						    1, &fSuccessful, &fmtres,	&cpOut,	&plsdnFirst, &plsdnLast);

	/* because we formatting with uLsInfiniteRM margin result should be successful */

	if (lserr != lserrNone)
		{
		AutonumDestroyDobj(pdobj);
		return lserr;
		}

	if (fmtres != fmtrCompletedRun)
		{
		AutonumDestroyDobj(pdobj);
		return lserrInvalidAutonumRun;
		}

	lserr = LsFinishCurrentSubline(pilsobj->plsc, &(pdobj->plssubl));	

	if (lserr != lserrNone)
		{
		AutonumDestroyDobj(pdobj);
		return lserr;
		}

	// submit subline for display
	lserr = LsdnSubmitSublines(pilsobj->plsc, pcfmtin->plsdnTop,	
							1, &(pdobj->plssubl),
							fFalse, fFalse, fTrue, fFalse, fFalse);	
	if (lserr != lserrNone)
		{
		AutonumDestroyDobj(pdobj);
		return lserr;
		}

	/* 
	 *	Calculate the object dimensions.
	 */

	lserr = LssbGetObjDimSubline(pdobj->plssubl, &lstflow, &objdimAll);
	if (lserr != lserrNone)
		{
		AutonumDestroyDobj(pdobj);
		return lserr;
		}

	/* for multiline heights use ascent  */
	objdimAll.heightsRef.dvMultiLineHeight = objdimAll.heightsRef.dvAscent;
	objdimAll.heightsPres.dvMultiLineHeight = objdimAll.heightsPres.dvAscent;
	
	dcp = cpOut - cpStartMain + 1;  /* additional is esc character */
	
	lserr = LsdnFinishRegular(pilsobj->plsc, dcp, 
		pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, pdobj, 
			&objdimAll);

	if (lserr != lserrNone)
		{
		AutonumDestroyDobj(pdobj);
		return lserr;
		}
	

	*pfmtres = fmtrCompletedRun;

	return lserrNone;
}



/* A U T O N U M   G E T  S P E C I A L  E F F E C T S  I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: AutonumGetSpecialEffectsInside
	%%Contact: igorzv
	Parameters
	pdobj			-	(IN) structure describes object
	*pEffectsFlags	-	(OUT)Special effects for this object
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumGetSpecialEffectsInside(PDOBJ pdobj, UINT *pEffectsFlags)	
{
	return LsGetSpecialEffectsSubline(pdobj->plssubl, pEffectsFlags);
}

/* A U T O N U M  C A L C  P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: AutonumCalcPresentation
	%%Contact: igorzv
	Parameters
	pdobj			-	(IN) structure describes object
	dup				-	(IN) is not used
	lskj			-	(IN) current justification mode

	This just makes the line match the calculated presentation of the line.
	
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumCalcPresentation(PDOBJ pdobj, long dup, LSKJUST lskjust, BOOL fLastOnLine)	
{
	Unreferenced(dup);
	Unreferenced(lskjust);
	Unreferenced(fLastOnLine);

	return LsMatchPresSubline(pdobj->plssubl);

}

/* A U T O N U M  Q U E R Y  P O I N T  P C P */
/*----------------------------------------------------------------------------
	%%Function: AutonumQueryPointPcp
	%%Contact: igorzv

	Should never be called
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumQueryPointPcp(PDOBJ pdobj, PCPOINTUV ppointuvQuery,	
								  PCLSQIN plsqin, PLSQOUT plsqout)	
{
	Unreferenced(pdobj);
	Unreferenced(ppointuvQuery);
	Unreferenced(plsqin);
	Unreferenced(plsqout);

	NotReached();

	return lserrInvalidParameter;

}
	
/* A U T O N U M   Q U E R Y  C P  P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: AutonumQueryCpPpoint
	%%Contact: igorzv

  Should never be called

----------------------------------------------------------------------------*/
LSERR WINAPI AutonumQueryCpPpoint(PDOBJ pdobj, LSDCP dcp,	
								  PCLSQIN plsqin, PLSQOUT plsqout)
{
	Unreferenced(pdobj);
	Unreferenced(dcp);
	Unreferenced(plsqin);
	Unreferenced(plsqout);

	NotReached();

	return lserrInvalidParameter;
}

/* A U T O N U M   T R U N C A T E  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: AutonumTruncateChunk
	%%Contact: igorzv

  Should never be called

----------------------------------------------------------------------------*/
LSERR WINAPI AutonumTruncateChunk(PCLOCCHNK pclocchnk, PPOSICHNK pposichnk)
{
	Unreferenced(pclocchnk);
	Unreferenced(pposichnk);
	NotReached();

	return lserrInvalidParameter;
}	

/* A U T O N U M   F I N D  P R E V   B R E A K  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: AutonumFindPrevBreakChunk
	%%Contact: igorzv

  Should never be called

----------------------------------------------------------------------------*/
LSERR WINAPI AutonumFindPrevBreakChunk(PCLOCCHNK pclocchnk, PCPOSICHNK pposichnk,
									   BRKCOND brkcond, PBRKOUT pbrkout)
{
	Unreferenced(pclocchnk);
	Unreferenced(pposichnk);
	Unreferenced(brkcond);
	Unreferenced(pbrkout);
	NotReached();

	return lserrInvalidParameter;
}	

/* A U T O N U M   F I N D  N E X T   B R E A K  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: AutonumFindNextBreakChunk
	%%Contact: igorzv

  Should never be called

----------------------------------------------------------------------------*/
LSERR WINAPI AutonumFindNextBreakChunk(PCLOCCHNK pclocchnk, PCPOSICHNK pposichnk,
									   BRKCOND brkcond, PBRKOUT pbrkout)
{
	Unreferenced(pclocchnk);
	Unreferenced(pposichnk);
	Unreferenced(brkcond);
	Unreferenced(pbrkout);
	NotReached();

	return lserrInvalidParameter;
}	

/* A U T O N U M   F O R C E   B R E A K  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: AutonumForceBreakChunk
	%%Contact: igorzv

  Should never be called

----------------------------------------------------------------------------*/
LSERR WINAPI AutonumForceBreakChunk(PCLOCCHNK pclocchnk, PCPOSICHNK pposichnk,
									   PBRKOUT pbrkout)
{
	Unreferenced(pclocchnk);
	Unreferenced(pposichnk);
	Unreferenced(pbrkout);
	NotReached();

	return lserrInvalidParameter;
}	

/* A U T O N U M   S E T   B R E A K   */
/*----------------------------------------------------------------------------
	%%Function: AutonumSetBreak
	%%Contact: igorzv

  Should never be called

----------------------------------------------------------------------------*/
LSERR WINAPI AutonumSetBreak(PDOBJ pdobj, BRKKIND brkkind, DWORD nbreakrecord,
							 BREAKREC* rgbreakrec, DWORD* pnactualbreakrecord)
{
	Unreferenced(pdobj);
	Unreferenced(brkkind);
	Unreferenced(rgbreakrec);
	Unreferenced(nbreakrecord);
	Unreferenced(pnactualbreakrecord);
	NotReached();

	return lserrInvalidParameter;
}	


/* A U T O N U M  D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: AutonumDisplay
	%%Contact: igorzv
	Parameters
	pdobj		-	(IN) structure describes object
	pcdispin	-	(IN) info for display


	Displays subline	
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumDisplay(PDOBJ pdobj, PCDISPIN pcdispin)
{
	BOOL fDisplayed;

	LSERR lserr = LssbFDoneDisplay(pdobj->plssubl, &fDisplayed);

	if (lserr != lserrNone)
		{
		return lserr;
		}

	if (fDisplayed)
		{
		return lserrNone;
		}
	else
		{
		/* display the autonum line */
		return LsDisplaySubline(pdobj->plssubl, &(pcdispin->ptPen), pcdispin->kDispMode, 
			pcdispin->prcClip);
		}

}

/* A U T O N U M  D E S T R O Y  D O B J */
/*----------------------------------------------------------------------------
	%%Function: AutonumDestroyDobj
	%%Contact: igorzv
	Parameters
	pdobj		-	(IN) structure describes object

	Free all resources connected with the input dobj.
----------------------------------------------------------------------------*/
LSERR WINAPI AutonumDestroyDobj(PDOBJ pdobj)
{
	LSERR lserr = lserrNone;
	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pdobj->plssubl != NULL)
		{
		lserr = LsDestroySubline(pdobj->plssubl);
		}

    pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pdobj);
	return lserr;
}

/* A L L I G N  A U T O N U M  95 */
/*----------------------------------------------------------------------------
	%%Function: AllignAutonum95
	%%Contact: igorzv
	Parameters
	durSpaceAnm		-	(IN) space after autonumber
	durWidthAnm		-	(IN) distance from indent to main text
	lskalignAnM			-	(IN) allignment for autonumber
	plsdnAnmAfter	-	(IN) tab dnode to put durAfter
	durUsed			-	(IN)  width of autonumbering text
	pdurBefore		-	(OUT)calculated distance from indent to autonumber 
	pdurAfter		-	(OUT)calculated distance from autonumber to main text

	Calculates space before and after autonumber for the case Word95 model.
----------------------------------------------------------------------------*/
	
void AllignAutonum95(long durSpaceAnm, long durWidthAnm, LSKALIGN lskalignAnm,
					   long durUsed, PLSDNODE plsdnAnmAfter, long* pdurBefore, long* pdurAfter)
	{
	long durExtra;
	long durJust;
	long durRemain;
	
	durExtra = Max(0, durWidthAnm - durUsed);
	durRemain = Max(0, durExtra - durSpaceAnm);
	
	*pdurBefore = 0;
	
	switch (lskalignAnm)
		{
		case lskalLeft:
			*pdurAfter = Max(durSpaceAnm,durExtra);
			break;
			
		case lskalCentered:
			durJust = ((DWORD)durExtra) / 2;
			if (durJust >= durSpaceAnm)
				{
				*pdurBefore = durJust;
				*pdurAfter = durJust;			
				}
			else
				{
				/* Justified will not fit -- treat as flushleft */
				*pdurBefore = durRemain;
				*pdurAfter = durSpac