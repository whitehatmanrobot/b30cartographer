   hFaxHandle,
    IN DWORD        dwDeviceID,
    IN LPCWSTR     lpctstrNameGUID,
    IN CONST PVOID  pData,
    IN CONST DWORD  dwDataSize
);
#ifdef UNICODE
#define FaxSetExtensionData  FaxSetExtensionDataW
#else
#define FaxSetExtensionData  FaxSetExtensionDataA
#endif // !UNICODE

//********************************************
//*                   FSP
//********************************************

typedef enum
{
    FAX_PROVIDER_STATUS_SUCCESS,     // Provider was successfully loaded
    FAX_PROVIDER_STATUS_SERVER_ERROR,// An error occured on the server while loading provider.
    FAX_PROVIDER_STATUS_BAD_GUID,    // Provider's GUID is invalid
    FAX_PROVIDER_STATUS_BAD_VERSION, // Provider's API version is invalid
    FAX_PROVIDER_STATUS_CANT_LOAD,   // Can't load provider's DLL
    FAX_PROVIDER_STATUS_CANT_LINK,   // Can't find required exported function(s) in provider's DLL
    FAX_PROVIDER_STATUS_CANT_INIT    // Failed while initializing provider
} FAX_ENUM_PROVIDER_STATUS;

typedef struct _FAX_DEVICE_PROVIDER_INFOA
{
    DWORD                           dwSizeOfStruct;
    LPCSTR                          lpctstrFriendlyName;
    LPCSTR                          lpctstrImageName;
    LPCSTR                          lpctstrProviderName;
    LPCSTR                          lpctstrGUID;
    DWORD                           dwCapabilities;
    FAX_VERSION                     Version;
    FAX_ENUM_PROVIDER_STATUS        Status;
    DWORD                           dwLastError;
} FAX_DEVICE_PROVIDER_INFOA, *PFAX_DEVICE_PROVIDER_INFOA;
typedef struct _FAX_DEVICE_PROVIDER_INFOW
{
    DWORD                           dwSizeOfStruct;
    LPCWSTR                         lpctstrFriendlyName;
    LPCWSTR                         lpctstrImageName;
    LPCWSTR                         lpctstrProviderName;
    LPCWSTR                         lpctstrGUID;
    DWORD                           dwCapabilities;
    FAX_VERSION                     Version;
    FAX_ENUM_PROVIDER_STATUS        Status;
    DWORD                           dwLastError;
} FAX_DEVICE_PROVIDER_INFOW, *PFAX_DEVICE_PROVIDER_INFOW;
#ifdef UNICODE
typedef FAX_DEVICE_PROVIDER_INFOW FAX_DEVICE_PROVIDER_INFO;
typedef PFAX_DEVICE_PROVIDER_INFOW PFAX_DEVICE_PROVIDER_INFO;
#else
typedef FAX_DEVICE_PROVIDER_INFOA FAX_DEVICE_PROVIDER_INFO;
typedef PFAX_DEVICE_PROVIDER_INFOA PFAX_DEVICE_PROVIDER_INFO;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumerateProvidersA (
    IN  HANDLE                      hFaxHandle,
    OUT PFAX_DEVICE_PROVIDER_INFOA *ppProviders,
    OUT LPDWORD                     lpdwNumProviders
);
WINFAXAPI
BOOL
WINAPI
FaxEnumerateProvidersW (
    IN  HANDLE                      hFaxHandle,
    OUT PFAX_DEVICE_PROVIDER_INFOW *ppProviders,
    OUT LPDWORD                     lpdwNumProviders
);
#ifdef UNICODE
#define FaxEnumerateProviders  FaxEnumerateProvidersW
#else
#define FaxEnumerateProviders  FaxEnumerateProvidersA
#endif // !UNICODE

//********************************************
//*            Routing extensions
//********************************************

typedef struct _FAX_ROUTING_EXTENSION_INFOA
{
        DWORD                                           dwSizeOfStruct;
        LPCSTR                                          lpctstrFriendlyName;
        LPCSTR                                          lpctstrImageName;
        LPCSTR                                          lpctstrExtensionName;
        FAX_VERSION                                     Version;
        FAX_ENUM_PROVIDER_STATUS        Status;
        DWORD                                           dwLastError;
} FAX_ROUTING_EXTENSION_INFOA, *PFAX_ROUTING_EXTENSION_INFOA;
typedef struct _FAX_ROUTING_EXTENSION_INFOW
{
        DWORD                                           dwSizeOfStruct;
        LPCWSTR                                         lpctstrFriendlyName;
        LPCWSTR                                         lpctstrImageName;
        LPCWSTR                                         lpctstrExtensionName;
        FAX_VERSION                                     Version;
        FAX_ENUM_PROVIDER_STATUS        Status;
        DWORD                                           dwLastError;
} FAX_ROUTING_EXTENSION_INFOW, *PFAX_ROUTING_EXTENSION_INFOW;
#ifdef UNICODE
typedef FAX_ROUTING_EXTENSION_INFOW FAX_ROUTING_EXTENSION_INFO;
typedef PFAX_ROUTING_EXTENSION_INFOW PFAX_ROUTING_EXTENSION_INFO;
#else
typedef FAX_ROUTING_EXTENSION_INFOA FAX_ROUTING_EXTENSION_INFO;
typedef PFAX_ROUTING_EXTENSION_INFOA PFAX_ROUTING_EXTENSION_INFO;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingExtensionsA (
    IN  HANDLE                           hFaxHandle,
    OUT PFAX_ROUTING_EXTENSION_INFOA    *ppRoutingExtensions,
    OUT LPDWORD                          lpdwNumExtensions
);
WINFAXAPI
BOOL
WINAPI
FaxEnumRoutingExtensionsW (
    IN  HANDLE                           hFaxHandle,
    OUT PFAX_ROUTING_EXTENSION_INFOW    *ppRoutingExtensions,
    OUT LPDWORD                          lpdwNumExtensions
);
#ifdef UNICODE
#define FaxEnumRoutingExtensions  FaxEnumRoutingExtensionsW
#else
#define FaxEnumRoutingExtensions  FaxEnumRoutingExtensionsA
#endif // !UNICODE


//********************************************
//*                     Ports
//********************************************

typedef enum
{
    FAX_DEVICE_STATUS_POWERED_OFF       = 0x0001,
    FAX_DEVICE_STATUS_SENDING           = 0x0002,
    FAX_DEVICE_STATUS_RECEIVING         = 0x0004,
    FAX_DEVICE_STATUS_RINGING           = 0x0008
} FAX_ENUM_DEVICE_STATUS;

typedef enum
{
    FAX_DEVICE_RECEIVE_MODE_OFF         = 0,            // Do not answer to incoming calls
    FAX_DEVICE_RECEIVE_MODE_AUTO        = 1,            // Automatically answer to incoming calls after dwRings rings
    FAX_DEVICE_RECEIVE_MODE_MANUAL      = 2             // Manually answer to incoming calls - only FaxAnswerCall answers the call
} FAX_ENUM_DEVICE_RECEIVE_MODE;

typedef struct _FAX_PORT_INFO_EXA
{
    DWORD                           dwSizeOfStruct;            // For versioning
    DWORD                           dwDeviceID;                // Fax id
    LPCSTR                          lpctstrDeviceName;         // Name of the device
    LPSTR                           lptstrDescription;         // Descriptive string
    LPCSTR                          lpctstrProviderName;       // FSP's name
    LPCSTR                          lpctstrProviderGUID;       // FSP's GUID
    BOOL                            bSend;                     // Is the device send-enabled?
    FAX_ENUM_DEVICE_RECEIVE_MODE    ReceiveMode;               // The device receive mode. See FAX_ENUM_DEVICE_RECEIVE_MODE for details.
    DWORD                           dwStatus;                  // Device status - a combination of values from FAX_ENUM_DEVICE_STATUS
    DWORD                           dwRings;                   // Number of rings before answering an incoming call
    LPSTR                           lptstrCsid;                // Called Station Id
    LPSTR                           lptstrTsid;                // Transmitting Station Id
} FAX_PORT_INFO_EXA, *PFAX_PORT_INFO_EXA;
typedef struct _FAX_PORT_INFO_EXW
{
    DWORD                           dwSizeOfStruct;            // For versioning
    DWORD                           dwDeviceID;                // Fax id
    LPCWSTR                         lpctstrDeviceName;         // Name of the device
    LPWSTR                          lptstrDescription;         // Descriptive string
    LPCWSTR                         lpctstrProviderName;       // FSP's name
    LPCWSTR                         lpctstrProviderGUID;       // FSP's GUID
    BOOL                            bSend;                     // Is the device send-enabled?
    FAX_ENUM_DEVICE_RECEIVE_MODE    ReceiveMode;               // The device receive mode. See FAX_ENUM_DEVICE_RECEIVE_MODE for details.
    DWORD                           dwStatus;                  // Device status - a combination of values from FAX_ENUM_DEVICE_STATUS
    DWORD                           dwRings;                   // Number of rings before answering an incoming call
    LPWSTR                          lptstrCsid;                // Called Station Id
    LPWSTR                          lptstrTsid;                // Transmitting Station Id
} FAX_PORT_INFO_EXW, *PFAX_PORT_INFO_EXW;
#ifdef UNICODE
typedef FAX_PORT_INFO_EXW FAX_PORT_INFO_EX;
typedef PFAX_PORT_INFO_EXW PFAX_PORT_INFO_EX;
#else
typedef FAX_PORT_INFO_EXA FAX_PORT_INFO_EX;
typedef PFAX_PORT_INFO_EXA PFAX_PORT_INFO_EX;
#endif // UNICODE

WINFAXAPI
DWORD
WINAPI
IsDeviceVirtual (
    IN  HANDLE hFaxHandle,
    IN  DWORD  dwDeviceId,
    OUT LPBOOL lpbVirtual
);


WINFAXAPI
BOOL
WINAPI
FaxGetPortExA (
    IN  HANDLE               hFaxHandle,
    IN  DWORD                dwDeviceId,
    OUT PFAX_PORT_INFO_EXA  *ppPortInfo
);
WINFAXAPI
BOOL
WINAPI
FaxGetPortExW (
    IN  HANDLE               hFaxHandle,
    IN  DWORD                dwDeviceId,
    OUT PFAX_PORT_INFO_EXW  *ppPortInfo
);
#ifdef UNICODE
#define FaxGetPortEx  FaxGetPortExW
#else
#define FaxGetPortEx  FaxGetPortExA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetPortExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwDeviceId,
    IN  PFAX_PORT_INFO_EXA  pPortInfo
);
WINFAXAPI
BOOL
WINAPI
FaxSetPortExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwDeviceId,
    IN  PFAX_PORT_INFO_EXW  pPortInfo
);
#ifdef UNICODE
#define FaxSetPortEx  FaxSetPortExW
#else
#define FaxSetPortEx  FaxSetPortExA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumPortsExA (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_PORT_INFO_EXA *ppPorts,
    OUT LPDWORD             lpdwNumPorts
);
WINFAXAPI
BOOL
WINAPI
FaxEnumPortsExW (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_PORT_INFO_EXW *ppPorts,
    OUT LPDWORD             lpdwNumPorts
);
#ifdef UNICODE
#define FaxEnumPortsEx  FaxEnumPortsExW
#else
#define FaxEnumPortsEx  FaxEnumPortsExA
#endif // !UNICODE


//********************************************
//*    Recipient and sender information
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxGetRecipientInfoA (
    IN  HANDLE                   hFaxHandle,
    IN  DWORDLONG                dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_PERSONAL_PROFILEA  *lpPersonalProfile
);
WINFAXAPI
BOOL
WINAPI
FaxGetRecipientInfoW (
    IN  HANDLE                   hFaxHandle,
    IN  DWORDLONG                dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_PERSONAL_PROFILEW  *lpPersonalProfile
);
#ifdef UNICODE
#define FaxGetRecipientInfo  FaxGetRecipientInfoW
#else
#define FaxGetRecipientInfo  FaxGetRecipientInfoA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetSenderInfoA (
    IN  HANDLE                   hFaxHandle,
    IN  DWORDLONG                dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_PERSONAL_PROFILEA  *lpPersonalProfile
);
WINFAXAPI
BOOL
WINAPI
FaxGetSenderInfoW (
    IN  HANDLE                   hFaxHandle,
    IN  DWORDLONG                dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_PERSONAL_PROFILEW  *lpPersonalProfile
);
#ifdef UNICODE
#define FaxGetSenderInfo  FaxGetSenderInfoW
#else
#define FaxGetSenderInfo  FaxGetSenderInfoA
#endif // !UNICODE

//********************************************
//*    Outbound routing groups
//********************************************

typedef enum
{
    FAX_GROUP_STATUS_ALL_DEV_VALID,
    FAX_GROUP_STATUS_EMPTY,
    FAX_GROUP_STATUS_ALL_DEV_NOT_VALID,
    FAX_GROUP_STATUS_SOME_DEV_NOT_VALID,
} FAX_ENUM_GROUP_STATUS;


typedef struct _FAX_OUTBOUND_ROUTING_GROUPA
{
    DWORD                       dwSizeOfStruct;
    LPCSTR                      lpctstrGroupName;
    DWORD                       dwNumDevices;
    LPDWORD                     lpdwDevices;
    FAX_ENUM_GROUP_STATUS       Status;
} FAX_OUTBOUND_ROUTING_GROUPA, *PFAX_OUTBOUND_ROUTING_GROUPA;
typedef struct _FAX_OUTBOUND_ROUTING_GROUPW
{
    DWORD                       dwSizeOfStruct;
    LPCWSTR                     lpctstrGroupName;
    DWORD                       dwNumDevices;
    LPDWORD                     lpdwDevices;
    FAX_ENUM_GROUP_STATUS       Status;
} FAX_OUTBOUND_ROUTING_GROUPW, *PFAX_OUTBOUND_ROUTING_GROUPW;
#ifdef UNICODE
typedef FAX_OUTBOUND_ROUTING_GROUPW FAX_OUTBOUND_ROUTING_GROUP;
typedef PFAX_OUTBOUND_ROUTING_GROUPW PFAX_OUTBOUND_ROUTING_GROUP;
#else
typedef FAX_OUTBOUND_ROUTING_GROUPA FAX_OUTBOUND_ROUTING_GROUP;
typedef PFAX_OUTBOUND_ROUTING_GROUPA PFAX_OUTBOUND_ROUTING_GROUP;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundGroupsA (
    IN  HANDLE                          hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_GROUPA   *ppGroups,
    OUT LPDWORD                         lpdwNumGroups
);
WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundGroupsW (
    IN  HANDLE                          hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_GROUPW   *ppGroups,
    OUT LPDWORD                         lpdwNumGroups
);
#ifdef UNICODE
#define FaxEnumOutboundGroups  FaxEnumOutboundGroupsW
#else
#define FaxEnumOutboundGroups  FaxEnumOutboundGroupsA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetOutboundGroupA (
    IN  HANDLE                       hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_GROUPA pGroup
);
WINFAXAPI
BOOL
WINAPI
FaxSetOutboundGroupW (
    IN  HANDLE                       hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_GROUPW pGroup
);
#ifdef UNICODE
#define FaxSetOutboundGroup  FaxSetOutboundGroupW
#else
#define FaxSetOutboundGroup  FaxSetOutboundGroupA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxAddOutboundGroupA (
    IN  HANDLE   hFaxHandle,
    IN  LPCSTR lpctstrGroupName
);
WINFAXAPI
BOOL
WINAPI
FaxAddOutboundGroupW (
    IN  HANDLE   hFaxHandle,
    IN  LPCWSTR lpctstrGroupName
);
#ifdef UNICODE
#define FaxAddOutboundGroup  FaxAddOutboundGroupW
#else
#define FaxAddOutboundGroup  FaxAddOutboundGroupA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxRemoveOutboundGroupA (
    IN  HANDLE   hFaxHandle,
    IN  LPCSTR lpctstrGroupName
);
WINFAXAPI
BOOL
WINAPI
FaxRemoveOutboundGroupW (
    IN  HANDLE   hFaxHandle,
    IN  LPCWSTR lpctstrGroupName
);
#ifdef UNICODE
#define FaxRemoveOutboundGroup  FaxRemoveOutboundGroupW
#else
#define FaxRemoveOutboundGroup  FaxRemoveOutboundGroupA
#endif // !UNICODE

BOOL
WINAPI
FaxSetDeviceOrderInGroupA (
        IN      HANDLE          hFaxHandle,
        IN      LPCSTR        lpctstrGroupName,
        IN      DWORD           dwDeviceId,
        IN      DWORD           dwNewOrder
);
BOOL
WINAPI
FaxSetDeviceOrderInGroupW (
        IN      HANDLE          hFaxHandle,
        IN      LPCWSTR        lpctstrGroupName,
        IN      DWORD           dwDeviceId,
        IN      DWORD           dwNewOrder
);
#ifdef UNICODE
#define FaxSetDeviceOrderInGroup  FaxSetDeviceOrderInGroupW
#else
#define FaxSetDeviceOrderInGroup  FaxSetDeviceOrderInGroupA
#endif // !UNICODE


//********************************************
//*    Outbound routing rules
//********************************************

typedef enum
{
    FAX_RULE_STATUS_VALID,
    FAX_RULE_STATUS_EMPTY_GROUP,                   // The rule's destination group  has no devices
    FAX_RULE_STATUS_ALL_GROUP_DEV_NOT_VALID,       // The rule's destination group  has valid devices
    FAX_RULE_STATUS_SOME_GROUP_DEV_NOT_VALID,      // The rule's destination group  has some invalid devices
    FAX_RULE_STATUS_BAD_DEVICE                     // The rule's destination device is not valid
} FAX_ENUM_RULE_STATUS;


typedef struct _FAX_OUTBOUND_ROUTING_RULEA
{
    DWORD                   dwSizeOfStruct;
    DWORD                   dwAreaCode;
    DWORD                   dwCountryCode;
    LPCSTR                  lpctstrCountryName;
    union
    {
        DWORD                   dwDeviceId;
        LPCSTR                  lpcstrGroupName;
    } Destination;
    BOOL                    bUseGroup;
    FAX_ENUM_RULE_STATUS    Status;
} FAX_OUTBOUND_ROUTING_RULEA, *PFAX_OUTBOUND_ROUTING_RULEA;
typedef struct _FAX_OUTBOUND_ROUTING_RULEW
{
    DWORD                   dwSizeOfStruct;
    DWORD                   dwAreaCode;
    DWORD                   dwCountryCode;
    LPCWSTR                 lpctstrCountryName;
    union
    {
        DWORD                   dwDeviceId;
        LPCWSTR                 lpcstrGroupName;
    } Destination;
    BOOL                    bUseGroup;
    FAX_ENUM_RULE_STATUS    Status;
} FAX_OUTBOUND_ROUTING_RULEW, *PFAX_OUTBOUND_ROUTING_RULEW;
#ifdef UNICODE
typedef FAX_OUTBOUND_ROUTING_RULEW FAX_OUTBOUND_ROUTING_RULE;
typedef PFAX_OUTBOUND_ROUTING_RULEW PFAX_OUTBOUND_ROUTING_RULE;
#else
typedef FAX_OUTBOUND_ROUTING_RULEA FAX_OUTBOUND_ROUTING_RULE;
typedef PFAX_OUTBOUND_ROUTING_RULEA PFAX_OUTBOUND_ROUTING_RULE;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundRulesA (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_RULEA *ppRules,
    OUT LPDWORD                      lpdwNumRules
);
WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundRulesW (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_RULEW *ppRules,
    OUT LPDWORD                      lpdwNumRules
);
#ifdef UNICODE
#define FaxEnumOutboundRules  FaxEnumOutboundRulesW
#else
#define FaxEnumOutboundRules  FaxEnumOutboundRulesA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxSetOutboundRuleA (
    IN  HANDLE                      hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_RULEA pRule
);
WINFAXAPI
BOOL
WINAPI
FaxSetOutboundRuleW (
    IN  HANDLE                      hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_RULEW pRule
);
#ifdef UNICODE
#define FaxSetOutboundRule  FaxSetOutboundRuleW
#else
#define FaxSetOutboundRule  FaxSetOutboundRuleA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxAddOutboundRuleA (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode,
    IN  DWORD       dwDeviceID,
    IN  LPCSTR    lpctstrGroupName,
    IN  BOOL        bUseGroup
);
WINFAXAPI
BOOL
WINAPI
FaxAddOutboundRuleW (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode,
    IN  DWORD       dwDeviceID,
    IN  LPCWSTR    lpctstrGroupName,
    IN  BOOL        bUseGroup
);
#ifdef UNICODE
#define FaxAddOutboundRule  FaxAddOutboundRuleW
#else
#define FaxAddOutboundRule  FaxAddOutboundRuleA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxRemoveOutboundRule (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode
);

//********************************************
//*         TAPI countries support
//********************************************

typedef struct _FAX_TAPI_LINECOUNTRY_ENTRYA
{
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    LPCSTR      lpctstrCountryName;
    LPCSTR      lpctstrLongDistanceRule;
} FAX_TAPI_LINECOUNTRY_ENTRYA, *PFAX_TAPI_LINECOUNTRY_ENTRYA;
typedef struct _FAX_TAPI_LINECOUNTRY_ENTRYW
{
    DWORD       dwCountryID;
    DWORD       dwCountryCode;
    LPCWSTR     lpctstrCountryName;
    LPCWSTR     lpctstrLongDistanceRule;
} FAX_TAPI_LINECOUNTRY_ENTRYW, *PFAX_TAPI_LINECOUNTRY_ENTRYW;
#ifdef UNICODE
typedef FAX_TAPI_LINECOUNTRY_ENTRYW FAX_TAPI_LINECOUNTRY_ENTRY;
typedef PFAX_TAPI_LINECOUNTRY_ENTRYW PFAX_TAPI_LINECOUNTRY_ENTRY;
#else
typedef FAX_TAPI_LINECOUNTRY_ENTRYA FAX_TAPI_LINECOUNTRY_ENTRY;
typedef PFAX_TAPI_LINECOUNTRY_ENTRYA PFAX_TAPI_LINECOUNTRY_ENTRY;
#endif // UNICODE

typedef struct _FAX_TAPI_LINECOUNTRY_LISTA
{
    DWORD                        dwNumCountries;
    PFAX_TAPI_LINECOUNTRY_ENTRYA LineCountryEntries;
} FAX_TAPI_LINECOUNTRY_LISTA, *PFAX_TAPI_LINECOUNTRY_LISTA;
typedef struct _FAX_TAPI_LINECOUNTRY_LISTW
{
    DWORD                        dwNumCountries;
    PFAX_TAPI_LINECOUNTRY_ENTRYW LineCountryEntries;
} FAX_TAPI_LINECOUNTRY_LISTW, *PFAX_TAPI_LINECOUNTRY_LISTW;
#ifdef UNICODE
typedef FAX_TAPI_LINECOUNTRY_LISTW FAX_TAPI_LINECOUNTRY_LIST;
typedef PFAX_TAPI_LINECOUNTRY_LISTW PFAX_TAPI_LINECOUNTRY_LIST;
#else
typedef FAX_TAPI_LINECOUNTRY_LISTA FAX_TAPI_LINECOUNTRY_LIST;
typedef PFAX_TAPI_LINECOUNTRY_LISTA PFAX_TAPI_LINECOUNTRY_LIST;
#endif // UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetCountryListA (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_TAPI_LINECOUNTRY_LISTA *ppCountryListBuffer
);
WINFAXAPI
BOOL
WINAPI
FaxGetCountryListW (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_TAPI_LINECOUNTRY_LISTW *ppCountryListBuffer
);
#ifdef UNICODE
#define FaxGetCountryList  FaxGetCountryListW
#else
#define FaxGetCountryList  FaxGetCountryListA
#endif // !UNICODE

//********************************************
//*            EFSP registration
//********************************************

//
// FSPI versions
//
typedef enum
{
    FSPI_API_VERSION_1 = 0x00010000,    // Used by FSPs
    FSPI_API_VERSION_2 = 0x00020000     // Used by EFSPs
} FSPI_API_VERSIONS;    // Used in FaxRegisterServiceProviderEx

WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderExA(
    IN HANDLE           hFaxHandle,
    IN LPCSTR         lpctstrGUID,
    IN LPCSTR         lpctstrFriendlyName,
    IN LPCSTR         lpctstrImageName,
    IN LPCSTR         lpctstrTspName,
    IN DWORD            dwFSPIVersion,
    IN DWORD            dwCapabilities
);
WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderExW(
    IN HANDLE           hFaxHandle,
    IN LPCWSTR         lpctstrGUID,
    IN LPCWSTR         lpctstrFriendlyName,
    IN LPCWSTR         lpctstrImageName,
    IN LPCWSTR         lpctstrTspName,
    IN DWORD            dwFSPIVersion,
    IN DWORD            dwCapabilities
);
#ifdef UNICODE
#define FaxRegisterServiceProviderEx  FaxRegisterServiceProviderExW
#else
#define FaxRegisterServiceProviderEx  FaxRegisterServiceProviderExA
#endif // !UNICODE

WINFAXAPI
BOOL
WINAPI
FaxUnregisterServiceProviderExA(
    IN HANDLE           hFaxHandle,
    IN LPCSTR         lpctstrGUID
);
WINFAXAPI
BOOL
WINAPI
FaxUnregisterServiceProviderExW(
    IN HANDLE           hFaxHandle,
    IN LPCWSTR         lpctstrGUID
);
#ifdef UNICODE
#define FaxUnregisterServiceProviderEx  FaxUnregisterServiceProviderExW
#else
#define FaxUnregisterServiceProviderEx  FaxUnregisterServiceProviderExA
#endif // !UNICODE


//********************************************
//*            Server events
//********************************************

typedef enum
{
        FAX_EVENT_TYPE_IN_QUEUE         = 0x00000001,
        FAX_EVENT_TYPE_OUT_QUEUE        = 0x00000002,
        FAX_EVENT_TYPE_CONFIG           = 0x00000004,
        FAX_EVENT_TYPE_ACTIVITY         = 0x00000008,
        FAX_EVENT_TYPE_QUEUE_STATE      = 0x00000010,
        FAX_EVENT_TYPE_IN_ARCHIVE       = 0x00000020,
        FAX_EVENT_TYPE_OUT_ARCHIVE      = 0x00000040,
        FAX_EVENT_TYPE_FXSSVC_ENDED     = 0x00000080,
        FAX_EVENT_TYPE_DEVICE_STATUS    = 0x00000100,
        FAX_EVENT_TYPE_NEW_CALL         = 0x00000200
} FAX_ENUM_EVENT_TYPE;

typedef enum
{
        FAX_JOB_EVENT_TYPE_ADDED,
        FAX_JOB_EVENT_TYPE_REMOVED,
        FAX_JOB_EVENT_TYPE_STATUS
} FAX_ENUM_JOB_EVENT_TYPE;

typedef enum
{
        FAX_CONFIG_TYPE_RECEIPTS,
        FAX_CONFIG_TYPE_ACTIVITY_LOGGING,
        FAX_CONFIG_TYPE_OUTBOX,
        FAX_CONFIG_TYPE_SENTITEMS,
        FAX_CONFIG_TYPE_INBOX,
        FAX_CONFIG_TYPE_SECURITY,
        FAX_CONFIG_TYPE_EVENTLOGS,
        FAX_CONFIG_TYPE_DEVICES,
        FAX_CONFIG_TYPE_OUT_GROUPS,
        FAX_CONFIG_TYPE_OUT_RULES
} FAX_ENUM_CONFIG_TYPE;


typedef struct _FAX_EVENT_JOBA
{
        DWORDLONG                       dwlMessageId;
        FAX_ENUM_JOB_EVENT_TYPE         Type;
        PFAX_JOB_STATUSA                pJobData;
} FAX_EVENT_JOBA, *PFAX_EVENT_JOBA;
typedef struct _FAX_EVENT_JOBW
{
        DWORDLONG                       dwlMessageId;
        FAX_ENUM_JOB_EVENT_TYPE         Type;
        PFAX_JOB_STATUSW                pJobData;
} FAX_EVENT_JOBW, *PFAX_EVENT_JOBW;
#ifdef UNICODE
typedef FAX_EVENT_JOBW FAX_EVENT_JOB;
typedef PFAX_EVENT_JOBW PFAX_EVENT_JOB;
#else
typedef FAX_EVENT_JOBA FAX_EVENT_JOB;
typedef PFAX_EVENT_JOBA PFAX_EVENT_JOB;
#endif // UNICODE

typedef struct _FAX_EVENT_DEVICE_STATUS
{
    DWORD       dwDeviceId;     // Id of the device whose status has just changed
    DWORD       dwNewStatus;    // The new status - a combination of values from FAX_ENUM_DEVICE_STATUS
} FAX_EVENT_DEVICE_STATUS, *PFAX_EVENT_DEVICE_STATUS;


typedef struct _FAX_EVENT_NEW_CALLA
{
        HCALL                   hCall;
        DWORD                   dwDeviceId;
        LPTSTR                  lptstrCallerId;
} FAX_EVENT_NEW_CALLA, *PFAX_EVENT_NEW_CALLA;
typedef struct _FAX_EVENT_NEW_CALLW
{
        HCALL                   hCall;
        DWORD                   dwDeviceId;
        LPTSTR                  lptstrCallerId;
} FAX_EVENT_NEW_CALLW, *PFAX_EVENT_NEW_CALLW;
#ifdef UNICODE
typedef FAX_EVENT_NEW_CALLW FAX_EVENT_NEW_CALL;
typedef PFAX_EVENT_NEW_CALLW PFAX_EVENT_NEW_CALL;
#else
typedef FAX_EVENT_NEW_CALLA FAX_EVENT_NEW_CALL;
typedef PFAX_EVENT_NEW_CALLA PFAX_EVENT_NEW_CALL;
#endif // UNICODE


typedef struct _FAX_EVENT_EXA
{
        DWORD                   dwSizeOfStruct;
        FILETIME                TimeStamp;
        FAX_ENUM_EVENT_TYPE     EventType;
        union
        {
                FAX_EVENT_JOBA          JobInfo;
                FAX_ENUM_CONFIG_TYPE    ConfigType;
                FAX_SERVER_ACTIVITY     ActivityInfo;
                FAX_EVENT_NEW_CALL      NewCall;
                DWORD                   dwQueueStates;
                FAX_EVENT_DEVICE_STATUS DeviceStatus;
        } EventInfo;
} FAX_EVENT_EXA, *PFAX_EVENT_EXA;
typedef struct _FAX_EVENT_EXW
{
        DWORD                   dwSizeOfStruct;
        FILETIME                TimeStamp;
        FAX_ENUM_EVENT_TYPE     EventType;
        union
        {
                FAX_EVENT_JOBW          JobInfo;
                FAX_ENUM_CONFIG_TYPE    ConfigType;
                FAX_SERVER_ACTIVITY     ActivityInfo;
                FAX_EVENT_NEW_CALL      NewCall;
                DWORD                   dwQueueStates;
                FAX_EVENT_DEVICE_STATUS DeviceStatus;
        } EventInfo;
} FAX_EVENT_EXW, *PFAX_EVENT_EXW;
#ifdef UNICODE
typedef FAX_EVENT_EXW FAX_EVENT_EX;
typedef PFAX_EVENT_EXW PFAX_EVENT_EX;
#else
typedef FAX_EVENT_EXA FAX_EVENT_EX;
typedef PFAX_EVENT_EXA PFAX_EVENT_EX;
#endif // UNICODE



//-------------------------------------------------------------------------------
//      Printers Info
//-------------------------------------------------------------------------------

typedef struct _FAX_PRINTER_INFOA
{
        LPSTR       lptstrPrinterName;
        LPSTR       lptstrServerName;
        LPSTR       lptstrDriverName;
} FAX_PRINTER_INFOA, *PFAX_PRINTER_INFOA;
typedef struct _FAX_PRINTER_INFOW
{
        LPWSTR      lptstrPrinterName;
        LPWSTR      lptstrServerName;
        LPWSTR      lptstrDriverName;
} FAX_PRINTER_INFOW, *PFAX_PRINTER_INFOW;
#ifdef UNICODE
typedef FAX_PRINTER_INFOW FAX_PRINTER_INFO;
typedef PFAX_PRINTER_INFOW PFAX_PRINTER_INFO;
#else
typedef FAX_PRINTER_INFOA FAX_PRINTER_INFO;
typedef PFAX_PRINTER_INFOA PFAX_PRINTER_INFO;
#endif // UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetServicePrintersA(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOA  *ppPrinterInfo,
    OUT LPDWORD lpdwPrintersReturned
    );
WINFAXAPI
BOOL
WINAPI
FaxGetServicePrintersW(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOW  *ppPrinterInfo,
    OUT LPDWORD lpdwPrintersReturned
    );
#ifdef UNICODE
#define FaxGetServicePrinters  FaxGetServicePrintersW
#else
#define FaxGetServicePrinters  FaxGetServicePrintersA
#endif // !UNICODE

typedef BOOL
(WINAPI *PFAXGETSERVICEPRINTERSA)(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOA  *ppPrinterInfo,
    OUT LPDWORD lpdwPrintersReturned
    );
typedef BOOL
(WINAPI *PFAXGETSERVICEPRINTERSW)(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOW  *ppPrinterInfo,
    OUT LPDWORD lpdwPrintersReturned
    );
#ifdef UNICODE
#define PFAXGETSERVICEPRINTERS  PFAXGETSERVICEPRINTERSW
#else
#define PFAXGETSERVICEPRINTERS  PFAXGETSERVICEPRINTERSA
#endif // !UNICODE


WINFAXAPI
BOOL
WINAPI
FaxRegisterForServerEvents (
        IN  HANDLE      hFaxHandle,
        IN  DWORD       dwEventTypes,
        IN  HANDLE      hCompletionPort,
        IN  DWORD_PTR   dwCompletionKey,
        IN  HWND        hWnd,
        IN  DWORD       dwMessage,
        OUT LPHANDLE    lphEvent
);


WINFAXAPI
BOOL
WINAPI
FaxUnregisterForServerEvents (
        IN  HANDLE      hEvent
);


//********************************************
//*   Manual answer support functions
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxAnswerCall(
        IN  HANDLE      hFaxHandle,
        IN  CONST DWORD dwDeviceId
);

//********************************************
//*   Configuration Wizard support functions
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxGetConfigWizardUsed (
    OUT LPBOOL  lpbConfigWizardUsed
);

WINFAXAPI
BOOL
WINAPI
FaxSetConfigWizardUsed (
    IN  HANDLE  hFaxHandle,
    OUT BOOL    bConfigWizardUsed
);

//********************************************
//*   Ivalidate archive folder
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxRefreshArchive (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder
);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\winsrv\import.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)     07-May-1991

Revision History:

    Adina Trufinescu (adinatru) 12-Dec-1999
    Define LPDEVMODEW and PSECURITY_DESCRIPTOR as pointers in order to
    let RPC do the conversion from a 32bit to a 64bit quantity. Make sure 
    these pointers are set on NULL all over the place where use PRINTER_CONTAINER,
    otherwise RPC will get confused when try to marshall.
--*/

#ifdef MIDL_PASS
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPDEVMODEW   ULONG_PTR
#define PSECURITY_DESCRIPTOR ULONG_PTR
#define HANDLE      ULONG_PTR
#define BOOL        DWORD
#endif

#include <winspool.h>
#include <winsplp.h>
#include <..\..\..\..\public\internal\printscan\inc\splapip.h>
#include <..\..\..\..\public\internal\windows\inc\winsprlp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\printui.h ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    printui.h

Abstract:

    Plug and Play interface printui.dll and ntprint.dll.

Author:

    Steve Kiraly (SteveKi) 30-Oct-1996

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PRINTUI_H
#define _PRINTUI_H

typedef enum {
    kAdvInf_ColorPrinter  = 1 << 0,   // The PnpInterface installed a color printer
} EAdvInfReturnFlags;

typedef enum {
    kPnPInterface_WebPointAndPrint      = 1 << 0,   // Web point and print install
    kPnPInterface_PromptForCD           = 1 << 1,   // Prompt for cd
    kPnPInterface_Quiet                 = 1 << 2,   // No error messages
    kPnPInterface_NoShare               = 1 << 3,   // Do not share printer
    kPnpInterface_UseExisting           = 1 << 4,   // Use driver if installed (Hydra)
    kPnpInterface_PromptIfUnknownDriver = 1 << 5,   // Prompt user if the printer driver is not known
    kPnPInterface_PromptIfFileNeeded    = 1 << 6,   // Prompt if files are needed
    kPnpInterface_HydraSpecific         = 1 << 7,   // Hydra specific flag
    kPnPInterface_Share                 = 1 << 8,   // Caller wants the printer shared
    kPnPInterface_WindowsUpdate         = 1 << 9,   // Windows Update case
    kPnPInterface_DontAutoGenerateName  = 1 << 10,  // Don't auto generate mangled printer name
    kPnPInterface_UseNonLocalizedStrings= 1 << 11,  // Use non localized Environment and Version
    kPnPInterface_SupressSetupUI        = 1 << 12,  // Supress setup warnings UI (super quiet mode)
    kPnPInterface_InstallColorProfiles  = 1 << 13   // Install ICM for color printer drivers
} EPnPInterfaceFlags;

typedef enum {
    kPrinterInstall,                        // Do printer quite install
    kInstallWizard,                         // Do install wizard
    kDestroyWizardData,                     // Do destroy wizard data
    kInfInstall,                            // Do inf installation
    kInfDriverInstall,                      // Do inf driver installation
    kDriverRemoval,                         // Do driver removal
    kAdvInfInstall                          // Do Inf Install with extras.
} EPnPFunctionCode;

typedef struct _TPrinterInstall {
    UINT        cbSize;                     // Size of this structure for validation purposes
    LPCTSTR     pszServerName;              // Machine name NULL equals local machine
    LPCTSTR     pszDriverName;              // Pointer to printer driver name.
    LPCTSTR     pszPortName;                // Name of port to install
    LPTSTR      pszPrinterNameBuffer;       // Buffer where to return fully qualified printer name.
    UINT        cchPrinterName;             // Size of printer name buffer in characters
} TPrinterInstall;

typedef struct _TInstallWizard {
    UINT                    cbSize;         // Size of this structure for validation
    LPCTSTR                 pszServerName;  // Machine name NULL equals local machine
    PSP_INSTALLWIZARD_DATA  pData;          // Pointer to install wizard data
    PVOID                   pReferenceData; // Class installer instance data
} TInstallWizard;

typedef struct _TDestroyWizard {
    UINT                    cbSize;         // Size of this structure for validation purposes
    LPCTSTR                 pszServerName;  // Machine name NULL equals local machine
    PSP_INSTALLWIZARD_DATA  pData;          // Pointer to install wizard data
    PVOID                   pReferenceData; // Class installer instance data
} TDestroyWizard;

typedef struct _TInfInstall {
    UINT        cbSize;                     // Size of this structure for validation purposes
    LPCTSTR     pszServerName;              // Machine name NULL equals local machine
    LPCTSTR     pszInfName;                 // Name of INF file including full path
    LPCTSTR     pszModelName;               // Model name of printer in inf to install
    LPCTSTR     pszPortName;                // Port name where to install printer
    LPTSTR      pszPrinterNameBuffer;       // Base printer name, Note if a printer exists
                                            // with this name a unique name will be
                                            // generated ie. "printer (Copy 1)".  This parameter
                                            // may contain the null string in which case the printer
                                            // name will be auto generated using the model name
                                            // as the base name.  This parameter can be null,
                                            // and the new name will not be copied back
    UINT        cchPrinterName;             // Size of printer name buffer in characters
    LPCTSTR     pszSourcePath;              // Printer driver sources path
    DWORD       dwFlags;                    // Install flags
} TInfInstall;

typedef struct _TAdvInfInstall {
    UINT        cbSize;                     // Size of this structure for validation purposes
    LPCTSTR     pszServerName;              // Machine name NULL equals local machine
    LPCTSTR     pszInfName;                 // Name of INF file including full path
    LPCTSTR     pszModelName;               // Model name of printer in inf to install
    LPCTSTR     pszPortName;                // Port name where to install printer
    LPTSTR      pszPrinterNameBuffer;       // Base printer name, Note if a printer exists
                                            // with this name a unique name will be
                                            // generated ie. "printer (Copy 1)".  This parameter
                                            // may contain the null string in which case the printer
                                            // name will be auto generated using the model name
                                            // as the base name.  This parameter can be null,
                                            // and the new name will not be copied back
    UINT        cchPrinterName;             // Size of printer name buffer in characters
    LPCTSTR     pszSourcePath;              // Printer driver sources path
    DWORD       dwFlags;                    // Install flags
    DWORD       dwAttributes;               // Printer install attributes
    PSECURITY_DESCRIPTOR pSecurityDescriptor; // Security Descriptor to set.
    DWORD       dwOutFlags;                 // A set of flags to be returned back to our caller.
} TAdvInfInstall;


typedef struct _TInfDriverInstall {
    UINT        cbSize;                     // Size of this structure for validation purposes
    LPCTSTR     pszServerName;              // Machine name NULL equals local machine
    LPCTSTR     pszInfName;                 // Name of INF file including full path
    LPCTSTR     pszModelName;               // Model name of printer in inf to install
    LPCTSTR     pszSourcePath;              // Printer driver sources path
    LPCTSTR     pszArchitecture;            // Architecture string
    LPCTSTR     pszVersion;                 // Driver version string
    DWORD       dwFlags;                    // Install flags
} TInfDriverInstall;

typedef struct _TDriverRemoval {
    UINT        cbSize;                     // Size of this structure for validation purposes
    LPCTSTR     pszServerName;              // Machine name NULL equals local machine
    LPCTSTR     pszModelName;               // Model name of printer in inf to install
    LPCTSTR     pszArchitecture;            // Architecture string
    LPCTSTR     pszVersion;                 // Driver version string
    DWORD       dwFlags;                    // Removal flags
} TDriverRemoval;

typedef union _TParameterBlock {
    TPrinterInstall     *pPrinterInstall;   // Pointer to printer install wizard
    TInstallWizard      *pInstallWizard;    // Pointer to install wizard data
    TDestroyWizard      *pDestroyWizard;    // Pointer to destroy wizard data
    TInfInstall         *pInfInstall;       // Pointer to inf install data
    TAdvInfInstall      *pAdvInfInstall;    // Pointer to advanced inf install data
    TInfDriverInstall   *pInfDriverInstall; // Pointer to inf driver install data
    TDriverRemoval      *pDriverRemoval;    // Pointer to driver removal data
} TParameterBlock;

DWORD
PnPInterface(
    IN EPnPFunctionCode    Function,        // Function code
    IN TParameterBlock    *pParameterBlock  // Pointer to parameter block
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\splsetup.h ===
/*++

Copyright (c) 1995-97  Microsoft Corporation
All rights reserved.

Module Name:

    splsetup.h

Abstract:

    Holds spooler install headers.

Author:

    Muhunthan Sivapragasam (MuhuntS)  20-Oct-1995

Revision History:

--*/

#ifndef _SPLSETUP_H
#define _SPLSETUP_H

#ifdef __cplusplus
extern "C"  {
#endif

//
// Type definitions
//
typedef enum {

    PlatformAlpha,
    PlatformX86,
    PlatformMIPS,
    PlatformPPC,
    PlatformWin95,
    PlatformIA64,
    PlatformAlpha64
} PLATFORM;

typedef enum {

    DRIVER_NAME,
    INF_NAME,
    DRV_INFO_4,
    PRINT_PROCESSOR_NAME,
    ICM_FILES,
    DRV_INFO_6
} FIELD_INDEX;

typedef struct _DRIVER_FIELD {

    FIELD_INDEX Index;
    union {

        LPTSTR          pszDriverName;
        LPTSTR          pszInfName;
        LPDRIVER_INFO_4 pDriverInfo4;
        LPTSTR          pszPrintProc;
        LPTSTR          pszzICMFiles;
        LPDRIVER_INFO_6 pDriverInfo6;
    };
} DRIVER_FIELD, *PDRIVER_FIELD;

typedef struct  _PSETUP_LOCAL_DATA  * PPSETUP_LOCAL_DATA;
typedef struct  _SELECTED_DRV_INFO  * PSELECTED_DRV_INFO;

#define     SELECT_DEVICE_HAVEDISK     0x00000001
#define     SELECT_DEVICE_FROMWEB      0x00000002

//

// Function prototypes
//
HDEVINFO
PSetupCreatePrinterDeviceInfoList(
    IN  HWND    hwnd
    );

BOOL
PSetupDestroyPrinterDeviceInfoList(
    IN  HDEVINFO    hPrinterDevInfo
    );

HPROPSHEETPAGE
PSetupCreateDrvSetupPage(
    IN  HDEVINFO    hDevInfo,
    IN  HWND        hwnd
    );

BOOL
PSetupBuildDriversFromPath(
    IN  HDEVINFO    hDevInfo,
    IN  LPCTSTR     pszDriverPath,
    IN  BOOL        bEnumSingleInf
    );

BOOL
PSetupSelectDriver(
    IN  HDEVINFO    hPrinterDevInfo
    );

BOOL
PSetupPreSelectDriver(
    IN  HDEVINFO    hDevInfo,
    IN  LPCTSTR     pszManufacturer,    OPTIONAL
    IN  LPCTSTR     pszModel            OPTIONAL
    );

PPSETUP_LOCAL_DATA
PSetupGetSelectedDriverInfo(
    IN  HDEVINFO    hDevInfo
    );

PPSETUP_LOCAL_DATA
PSetupDriverInfoFromName(
    IN  HDEVINFO    hDevInfo,
    IN  LPCTSTR     pszModel
    );

BOOL
PSetupDestroySelectedDriverInfo(
    IN  PPSETUP_LOCAL_DATA  pLocalData
    );

//
// Driver install flags
//
#define     DRVINST_FLATSHARE               0x00000001
#define     DRVINST_DONOTCOPY_INF           0x00000002
#define     DRVINST_DRIVERFILES_ONLY        0x00000004
#define     DRVINST_PROMPTLESS              0x00000008
#define     DRVINST_PROGRESSLESS            0x00000010
#define     DRVINST_WEBPNP                  0x00000020

/*
DRVINST_WINDOWS_UPDATE - Flag for PrintUI to set to ensure that SPOST_URL gets set.
                         Setting the SPOST_URL is for setup to ignore the inf of this
                         driver during all setup calls except for a Web Point and Print.
                         This flag makes sure that the driver is install with all the
                         spoolers hosted by the local machines (including cluster spoolers)
*/
#define     DRVINST_WINDOWS_UPDATE          0x00000040
/*
DRVINST_PRIVATE_DIRECTORY - Flag to tell that we want to use a private directory for the copying.
                            This is specifically to fix TS where we can get into a AddPrinterDriver
                                                        race condition where the drivers can get deleted before APD is called when
                                                        adding multiple drivers.
                                                        Note - using this flag means that NTPrint must do the file deletion.
*/
#define     DRVINST_PRIVATE_DIRECTORY       0x00000080

//
// Set if we install drivers for a non-native platform
//
#define     DRVINST_ALT_PLATFORM_INSTALL    0x00000100

//
// Set if we want PSetupInstallPrinterDriver not advertise warned or blocked 
// drivers through the UI. Note that if DRVINST_PROMPTLESS is specified, this
// is implied.
// 
#define     DRVINST_NO_WARNING_PROMPT       0x00000200

//
// Set if we want PSetupInstallPrinterDriver to install the printer driver 
// without asking the user if they would rather have an inbox printer driver
// be installed. This is because the print UI can't necessarily take advantage
// of the new driver at all points.
// 
#define     DRVINST_DONT_OFFER_REPLACEMENT  0x00000400

//
// return values for pdwBlockingStatusFlags
// 
#define BSP_PRINTER_DRIVER_OK                 0
#define BSP_PRINTER_DRIVER_BLOCKED   0x00000001
#define BSP_PRINTER_DRIVER_WARNED    0x00000002
#define BSP_BLOCKING_LEVEL_MASK      0x000000ff

#define BSP_INBOX_DRIVER_AVAILABLE   0x00000100

#define BSP_PRINTER_DRIVER_CANCELLED 0x80000000
#define BSP_PRINTER_DRIVER_PROCEEDED 0x40000000
#define BSP_PRINTER_DRIVER_REPLACED  0x20000000
#define BSP_USER_RESPONSE_MASK       0xff000000

DWORD
PSetupInstallPrinterDriver(
    IN HDEVINFO             hDevInfo,
    IN PPSETUP_LOCAL_DATA   pLocalData,
    IN LPCTSTR              pszDriverName,
    IN PLATFORM             platform,
    IN DWORD                dwVersion,
    IN LPCTSTR              pszServerName,
    IN HWND                 hwnd,
    IN LPCTSTR              pszDiskName,
    IN LPCTSTR              pszSource,
    IN DWORD                dwInstallFlags,
    IN DWORD                dwAddDrvFlags,
    OUT LPTSTR             *ppszNewDriverName
    );

BOOL
PSetupIsCompatibleDriver(
    IN     LPCTSTR      pszServer,                OPTIONAL
    IN     LPCTSTR      pszDriverModel,
    IN     LPCTSTR      pszDriverPath,                     // main rendering driver dll
    IN     LPCTSTR      pszEnvironment,
    IN     DWORD        dwVersion,
    IN     FILETIME     *pFileTimeDriver,        
       OUT DWORD        *pdwBlockingStatus,                  // returns BSP_DRIVER_OK, BSP_PRINTER_DRIVER_BLOCKED or BSP_PRINTER_DRIVER_WARNED
       OUT LPTSTR       *ppszReplacementDriver     OPTIONAL // caller must free it.
    );

//
// returns BSP_PRINTER_DRIVER_CANCELLED, BSP_PRINTER_DRIVER_PROCEEDED or BSP_PRINTER_DRIVER_REPLACED
//
DWORD
PSetupShowBlockedDriverUI(
    HWND        hParentWnd, 
    DWORD       BlockingStatus      // can be BSP_DRIVER_OK, BSP_PRINTER_DRIVER_BLOCKED or BSP_PRINTER_DRIVER_WARNED  OR'd with BSP_INBOX_REPLACEMENT_AVAILABLE
);


#define     DRIVER_MODEL_NOT_INSTALLED                  0
#define     DRIVER_MODEL_INSTALLED_AND_IDENTICAL        1
#define     DRIVER_MODEL_INSTALLED_BUT_DIFFERENT       -1

#define     KERNEL_MODE_DRIVER_VERSION                 -1

BOOL
PSetupIsDriverInstalled(
    IN LPCTSTR      pszServerName,
    IN LPCTSTR      pszDriverName,
    IN PLATFORM     platform,
    IN DWORD        dwMajorVersion
    );

INT
PSetupIsTheDriverFoundInInfInstalled(
    IN  LPCTSTR             pszServerName,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  DWORD               dwMajorVersion
    );

BOOL
PSetupRefreshDriverList(
    IN HDEVINFO hDevInfo
    );

BOOL
PSetupIsOemDriver(
    IN HDEVINFO             hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN PBOOL                pbIsOemDriver
    );

PLATFORM
PSetupThisPlatform(
    VOID
    );

BOOL
PSetupGetPathToSearch(
    IN      HWND        hwnd,
    IN      LPCTSTR     pszTitle,
    IN      LPCTSTR     pszDiskName,
    IN      LPCTSTR     pszFileName,
    IN      BOOL        bPromptForInf,
    IN OUT  TCHAR       szPath[MAX_PATH]
    );

BOOL
PSetupProcessPrinterAdded(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  LPCTSTR             pszPrinterName,
    IN  HWND                hwnd
    );

BOOL
PSetupSetSelectDevTitleAndInstructions(
    IN  HDEVINFO    hDevInfo,
    IN  LPCTSTR     pszTitle,
    IN  LPCTSTR     pszSubTitle,
    IN  LPCTSTR     pszInstn
    );

BOOL
PSetupSelectDeviceButtons(
   IN HDEVINFO      hDevInfo,
   IN DWORD         dwFlagsSet,
   IN DWORD         dwFlagsClear
   );

BOOL
PSetupGetLocalDataField(
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN OUT  PDRIVER_FIELD       pDrvField
    );

VOID
PSetupFreeDrvField(
    IN      PDRIVER_FIELD   pDrvField
    );

//
// Internet printing support
//
BOOL
PSetupGetDriverInfForPrinter(
    IN      HDEVINFO    hDevInfo,
    IN      LPCTSTR     pszPrinterName,
    IN OUT  LPTSTR      pszInfName,
    IN OUT  LPDWORD     pcbInfNameSize
    );

DWORD
PSetupInstallPrinterDriverFromTheWeb(
    IN  HDEVINFO            hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN  PLATFORM            platform,
    IN  LPCTSTR             pszServerName,
    IN  LPOSVERSIONINFO     pOsVersionInfo,
    IN  HWND                hwnd,
    IN  LPCTSTR             pszSource
    );

//
// Monitor Installation Functions
//
HANDLE
PSetupCreateMonitorInfo(
    IN  HWND        hwnd,
    IN  LPCTSTR     pszServerName
    );

VOID
PSetupDestroyMonitorInfo(
    IN OUT HANDLE  h
    );

BOOL
PSetupEnumMonitor(
    IN     HANDLE   h,
    IN     DWORD    dwIndex,
    OUT    LPTSTR   pMonitorName,
    IN OUT LPDWORD  pdwSize
    );


BOOL
PSetupInstallMonitor(
    IN  HWND        hwnd
    );


//
// Following exported for test team's use
//
LPDRIVER_INFO_3
PSetupGetDriverInfo3(
    IN  PSELECTED_DRV_INFO  pDrvInfo
    );

VOID
PSetupDestroyDriverInfo3(
    IN LPDRIVER_INFO_3 pDriverInfo3
    );

BOOL
PSetupFindMappedDriver(
    IN      BOOL        bWinNT,
    IN      LPCTSTR     pszDriverName,
        OUT LPTSTR      *ppszRemappedDriverName,
        OUT BOOL        *pbDriverFound
    );

//
// For Win9x upgrade
//
BOOL
PSetupAssociateICMProfiles(
    IN  LPCTSTR             pszzICMFiles,
    IN  LPCTSTR             pszPrinterName
    );

BOOL
PSetupInstallICMProfiles(
    IN  LPCTSTR     pszServerName,
    IN  LPCTSTR     pszzICMFiles
    );

//
// For spooler
//
VOID
PSetupFreeMem(
    PVOID p
    );


//
// Following are the typdefs for calling GetProcAddress()
//
typedef
HDEVINFO
(*pfPSetupCreatePrinterDeviceInfoList)(
    IN      HWND        hwnd
    );

typedef
VOID
(*pfPSetupDestroyPrinterDeviceInfoList)(
    IN      HDEVINFO    h
    );

typedef
BOOL
(*pfPSetupSelectDriver)(
    IN      HDEVINFO    h
    );

typedef
HPROPSHEETPAGE
(*pfPSetupCreateDrvSetupPage)(
    IN      HDEVINFO    h,
    IN      HWND        hwnd
    );

typedef
PPSETUP_LOCAL_DATA
(*pfPSetupGetSelectedDriverInfo)(
    IN      HDEVINFO    h
    );

typedef
VOID
(*pfPSetupDestroySelectedDriverInfo)(
    IN      PPSETUP_LOCAL_DATA  pSelectedDrvInfo
    );

typedef
DWORD
(*pfPSetupInstallPrinterDriver)(
    IN      HDEVINFO            h,
    IN      PPSETUP_LOCAL_DATA  pSelectedDrvInfo,
    IN      LPCTSTR             pszDriverName,
    IN      PLATFORM            platform,
    IN      DWORD               dwVersion,
    IN      LPCTSTR             pszServerName,
    IN      HWND                hwnd,
    IN      LPCTSTR             pszPlatformName,
    IN      LPCTSTR             pszSourcePath,
    IN      DWORD               dwInstallFlags,
    IN      DWORD               dwAddDrvFlags,
    OUT     LPTSTR             *ppszNewDriverName
    );

typedef
BOOL
(*pfPSetupIsDriverInstalled)(
    IN      LPCTSTR     pszServerName,
    IN      LPCTSTR     pszDriverName,
    IN      PLATFORM    platform,
    IN      DWORD       dwMajorVersion
    );

typedef
INT
(*pfPSetupIsTheDriverFoundInInfInstalled)(
    IN      LPCTSTR             pszServerName,
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN      DWORD               dwMajorVersion
    );

typedef
BOOL
(*pfPSetupRefreshDriverList)(
    IN      HDEVINFO    h
    );

typedef
PLATFORM
(*pfPSetupThisPlatform)(
    VOID
    );

typedef
BOOL
(*pfPSetupGetPathToSearch)(
    IN  HWND        hwnd,
    IN  LPCTSTR     pszTitle,
    IN  LPCTSTR     pszDiskName,
    IN  LPCTSTR     pszFileName,
    IN  BOOL        bPromptForInf,
    OUT TCHAR       szPath[MAX_PATH]
    );

typedef
PPSETUP_LOCAL_DATA
(*pfPSetupDriverInfoFromName)(
    IN      HDEVINFO    h,
    IN      LPCTSTR     pszModel
    );

typedef
BOOL
(*pfPSetupPreSelectDriver)(
    IN      HDEVINFO    h,
    IN      LPCTSTR     pszManufacturer,    OPTIONAL
    IN      LPCTSTR     pszModel            OPTIONAL
    );

typedef
HANDLE
(*pfPSetupCreateMonitorInfo)(
    IN      HWND        hwnd,
    IN      LPCTSTR     pszServerName
    );

typedef
VOID
(*pfPSetupDestroyMonitorInfo)(
    IN      HANDLE      h
    );

typedef
BOOL
(*pfPSetupEnumMonitor)(
    IN      HANDLE      h,
    IN      DWORD       dwIndex,
       OUT  LPTSTR      pMonitorName,
    IN OUT  LPDWORD     pdwSize
    );

typedef
BOOL
(*pfPSetupInstallMonitor)(
    IN      HWND        hwnd
    );


typedef
BOOL
(*pfPSetupProcessPrinterAdded)(
    IN      HDEVINFO            hDevInfo,
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      LPCTSTR             pszPrinterName,
    IN      HWND                hwnd
    );

typedef
BOOL
(*pfPSetupBuildDriversFromPath)(
    IN      HANDLE      h,
    IN      LPCTSTR     pszDriverPath,
    IN      BOOL        bEnumSingleInf
    );

typedef
BOOL
(*pfPSetupSetSelectDevTitleAndInstructions)(
    IN      HDEVINFO    hDevInfo,
    IN      LPCTSTR     pszTitle,
    IN      LPCTSTR     pszSubTitle,
    IN      LPCTSTR     pszInstn
    );

typedef
BOOL
(*pfPSetupSelectDeviceButtons)(
   IN HDEVINFO      hDevInfo,
   IN DWORD         dwFlagsSet,
   IN DWORD         dwFlagsClear
   );

typedef
DWORD
(*pfPSetupInstallPrinterDriverFromTheWeb)(
    IN      HDEVINFO            hDevInfo,
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN      LPCTSTR             pszServerName,
    IN      LPOSVERSIONINFO     pOsVersionInfo,
    IN      HWND                hwnd,
    IN      LPCTSTR             pszSource
    );

typedef
BOOL
(*pfPSetupIsOemDriver)(
    IN      HDEVINFO    hDevInfo,
    IN  PPSETUP_LOCAL_DATA  pLocalData,
    IN OUT  PBOOL       pbIsOemDriver
    );

typedef
BOOL
(*pfPSetupGetLocalDataField)(
    IN      PPSETUP_LOCAL_DATA  pLocalData,
    IN      PLATFORM            platform,
    IN OUT  PDRIVER_FIELD       pDrvField
    );

typedef
VOID
(*pfPSetupFreeDrvField)(
    IN      PDRIVER_FIELD   pDrvField
    );

typedef
BOOL
(*pfPSetupAssociateICMProfiles)(
    IN  LPCTSTR             pszzICMFiles,
    IN  LPCTSTR             pszPrinterName
    );

typedef
BOOL
(*pfPSetupInstallICMProfiles)(
    IN  LPCTSTR     pszServerName,
    IN  LPCTSTR     pszzICMFiles
    );

typedef
BOOL
(*pfPSetupIsCompatibleDriver)(
    IN     LPCTSTR      pszServer,                OPTIONAL
    IN     LPCTSTR      pszDriverModel,
    IN     LPCTSTR      pszDriverPath,                     // main rendering driver dll
    IN     LPCTSTR      pszEnvironment,
    IN     DWORD        dwVersion,
    IN     FILETIME     *pFileTimeDriver,        
       OUT DWORD        *pdwBlockingStatus,
       OUT LPTSTR       *ppszReplacementDriver     OPTIONAL // caller must free it.
    );

typedef 
DWORD
(*pfPSetupShowBlockedDriverUI)(
    HWND        hParentWnd, 
    DWORD       BlockingStatus      // can be BSP_PRINTER_DRIVER_BLOCKED or BSP_PRINTER_DRIVER_WARNED, OR'd with BSP_INBOX_REPLACEMENT_AVAILABLE
);

typedef
BOOL
(*pfPSetupFindMappedDriver)(
    IN      BOOL        bWinNT,
    IN      LPCTSTR     pszDriverName,
        OUT LPTSTR      *ppszRemappedDriverName,
        OUT BOOL        *pbDriverFound
    );

typedef
DWORD
(*pfPSetupInstallInboxDriverSilently)(
    IN      LPCTSTR     pszDriverName
    );

typedef
VOID
(*pfPSetupFreeMem)(
    PVOID p
    );



#ifdef __cplusplus

}
#endif

#endif  // #ifndef _SPLSETUP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\wiaview.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for wiaview.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wiaview_h__
#define __wiaview_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IVideoPreview_FWD_DEFINED__
#define __IVideoPreview_FWD_DEFINED__
typedef interface IVideoPreview IVideoPreview;
#endif 	/* __IVideoPreview_FWD_DEFINED__ */


#ifndef __VideoPreview_FWD_DEFINED__
#define __VideoPreview_FWD_DEFINED__

#ifdef __cplusplus
typedef class VideoPreview VideoPreview;
#else
typedef struct VideoPreview VideoPreview;
#endif /* __cplusplus */

#endif 	/* __VideoPreview_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IVideoPreview_INTERFACE_DEFINED__
#define __IVideoPreview_INTERFACE_DEFINED__

/* interface IVideoPreview */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IVideoPreview;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d82237ec-5be9-4760-b950-b7afa51b0ba9")
    IVideoPreview : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Device( 
            /* [in] */ IUnknown *pDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVideoPreviewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVideoPreview * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVideoPreview * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVideoPreview * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IVideoPreview * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IVideoPreview * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IVideoPreview * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IVideoPreview * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Device )( 
            IVideoPreview * This,
            /* [in] */ IUnknown *pDevice);
        
        END_INTERFACE
    } IVideoPreviewVtbl;

    interface IVideoPreview
    {
        CONST_VTBL struct IVideoPreviewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVideoPreview_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVideoPreview_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVideoPreview_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVideoPreview_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVideoPreview_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVideoPreview_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVideoPreview_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVideoPreview_Device(This,pDevice)	\
    (This)->lpVtbl -> Device(This,pDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IVideoPreview_Device_Proxy( 
    IVideoPreview * This,
    /* [in] */ IUnknown *pDevice);


void __RPC_STUB IVideoPreview_Device_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVideoPreview_INTERFACE_DEFINED__ */



#ifndef __WIAVIEWLib_LIBRARY_DEFINED__
#define __WIAVIEWLib_LIBRARY_DEFINED__

/* library WIAVIEWLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WIAVIEWLib;

EXTERN_C const CLSID CLSID_VideoPreview;

#ifdef __cplusplus

class DECLSPEC_UUID("457A23DF-6F2A-4684-91D0-317FB768D87C")
VideoPreview;
#endif
#endif /* __WIAVIEWLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\winsrv\client.h ===
/*++

Copyright (c) 1990-1994  Microsoft Corporation
All rights reserved

Module Name:

    Client.h

Abstract:

    Holds Client Spooler types and prototypes

Author:


Environment:

    User Mode -Win32

Revision History:

    Steve Wilson (NT) (swilson) 1-Jun-95    Ported from spoolss\client\client.h

--*/

typedef int (FAR WINAPI *INT_FARPROC)();

typedef struct _GENERIC_CONTAINER {
    DWORD       Level;
    LPBYTE      pData;
} GENERIC_CONTAINER, *PGENERIC_CONTAINER, *LPGENERIC_CONTAINER ;


typedef struct _SPOOL *PSPOOL;
typedef struct _NOTIFY *PNOTIFY;

typedef struct _NOTIFY {
    PNOTIFY  pNext;
    HANDLE   hEvent;      // event to trigger on notification
    DWORD    fdwFlags;    // flags to watch for
    DWORD    fdwOptions;  // PRINTER_NOTIFY_*
    DWORD    dwReturn;    // used by WPC when simulating FFPCN
    PSPOOL   pSpool;
} NOTIFY;

typedef struct _SPOOL {
    DWORD       signature;
    HANDLE      hPrinter;
    DWORD       Status;
    LONG            cThreads;   // InterlockedDecrement/Increment variable for thread synch
    HANDLE      hModule;        // Driver UM DLL Module Handle
    DWORD       (*pfnWrite)();
    HANDLE      (*pfnStartDoc)();
    VOID        (*pfnEndDoc)();
    VOID        (*pfnClose)();
    BOOL        (*pfnStartPage)();
    BOOL        (*pfnEndPage)();
    VOID        (*pfnAbort)();
    HANDLE      hDriver;        // supplied to us by driver UI dll
    DWORD       JobId;
} SPOOL;

//
// Change the RPC buffer size to 64K
//
#define BUFFER_SIZE 0x10000
#define SP_SIGNATURE    0x6767

#define SPOOL_STATUS_STARTDOC   0x00000001
#define SPOOL_STATUS_ADDJOB     0x00000002
#define SPOOL_STATUS_ANSI       0x00000004


#define SPOOL_FLAG_FFPCN_FAILED     0x1
#define SPOOL_FLAG_LAZY_CLOSE       0x2


DWORD
TranslateExceptionCode(
    DWORD   ExceptionCode
);


PNOTIFY
WPCWaitFind(
    HANDLE hFind);

BOOL
ValidatePrinterHandle(
    HANDLE hPrinter
    );

VOID
FreeSpool(
    PSPOOL pSpool);

LPVOID
DllAllocSplMem(
    DWORD cb
);


BOOL
DllFreeSplMem(
   LPVOID pMem
);

BOOL
FlushBuffer(
    PSPOOL  pSpool
);

PSECURITY_DESCRIPTOR
BuildInputSD(
    PSECURITY_DESCRIPTOR pPrinterSD,
    PDWORD pSizeSD
);


typedef struct _KEYDATA {
    DWORD   cb;
    DWORD   cTokens;
    LPWSTR  pTokens[1];
} KEYDATA, *PKEYDATA;


PKEYDATA
CreateTokenList(
   LPWSTR   pKeyData
);


LPWSTR
GetPrinterPortList(
    HANDLE hPrinter
    );

LPWSTR
FreeUnicodeString(
    LPWSTR  pUnicodeString
);

LPWSTR
AllocateUnicodeString(
    LPSTR  pPrinterName
);

LPWSTR
StartDocDlgW(
        HANDLE hPrinter,
        DOCINFO *pDocInfo
        );

LPSTR
StartDocDlgA(
        HANDLE hPrinter,
        DOCINFOA *pDocInfo
        );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\winsrv\data.h ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    data.h

Abstract:

    Common definitions for structure offsets for pointer based data.

Author:

Environment:

    User Mode - Win32

Revision History:

Notes: 

    FOR ADDING OR UPDATING Offset structures.

All the offsets should appear in ascending order in the struct. This is critical
for converting 32 bit structures into the corresponding 64 bit structures. Custom 
marshalling will break if this is not adhered to.

See spllib\marshall.cxx for additional information

--*/

#ifndef _DATA_H
#define _DATA_H

#include <offsets.h>
#include <winsprlp.h>

#ifdef PRINTER_OFFSETS
DWORD PrinterInfoStressOffsets[]={offsetof(PRINTER_INFO_STRESSA, pPrinterName),
                             offsetof(PRINTER_INFO_STRESSA, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo1Offsets[]={offsetof(PRINTER_INFO_1A, pDescription),
                             offsetof(PRINTER_INFO_1A, pName),
                             offsetof(PRINTER_INFO_1A, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2Offsets[]={offsetof(PRINTER_INFO_2A, pServerName),
                             offsetof(PRINTER_INFO_2A, pPrinterName),
                             offsetof(PRINTER_INFO_2A, pShareName),
                             offsetof(PRINTER_INFO_2A, pPortName),
                             offsetof(PRINTER_INFO_2A, pDriverName),
                             offsetof(PRINTER_INFO_2A, pComment),
                             offsetof(PRINTER_INFO_2A, pLocation),
                             offsetof(PRINTER_INFO_2A, pDevMode),
                             offsetof(PRINTER_INFO_2A, pSepFile),
                             offsetof(PRINTER_INFO_2A, pPrintProcessor),
                             offsetof(PRINTER_INFO_2A, pDatatype),
                             offsetof(PRINTER_INFO_2A, pParameters),
                             offsetof(PRINTER_INFO_2A, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo3Offsets[]={offsetof(PRINTER_INFO_3, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo4Offsets[]={offsetof(PRINTER_INFO_4A, pPrinterName),
                             offsetof(PRINTER_INFO_4A, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5Offsets[]={offsetof(PRINTER_INFO_5A, pPrinterName),
                             offsetof(PRINTER_INFO_5A, pPortName),
                             0xFFFFFFFF};

DWORD PrinterInfo6Offsets[]={0xFFFFFFFF};

DWORD PrinterInfo7Offsets[]={offsetof(PRINTER_INFO_7A, pszObjectGUID),
                             0xFFFFFFFF};

DWORD PrinterInfo8Offsets[]={offsetof(PRINTER_INFO_8A, pDevMode),
                             0xFFFFFFFF};

DWORD PrinterInfo9Offsets[]={offsetof(PRINTER_INFO_9A, pDevMode),
                             0xFFFFFFFF};
#endif

#ifdef PRINTER_STRINGS
DWORD PrinterInfoStressStrings[]={offsetof(PRINTER_INFO_STRESSA, pPrinterName),
                             offsetof(PRINTER_INFO_STRESSA, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo1Strings[]={offsetof(PRINTER_INFO_1A, pDescription),
                             offsetof(PRINTER_INFO_1A, pName),
                             offsetof(PRINTER_INFO_1A, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2Strings[]={offsetof(PRINTER_INFO_2A, pServerName),
                             offsetof(PRINTER_INFO_2A, pPrinterName),
                             offsetof(PRINTER_INFO_2A, pShareName),
                             offsetof(PRINTER_INFO_2A, pPortName),
                             offsetof(PRINTER_INFO_2A, pDriverName),
                             offsetof(PRINTER_INFO_2A, pComment),
                             offsetof(PRINTER_INFO_2A, pLocation),
                             offsetof(PRINTER_INFO_2A, pSepFile),
                             offsetof(PRINTER_INFO_2A, pPrintProcessor),
                             offsetof(PRINTER_INFO_2A, pDatatype),
                             offsetof(PRINTER_INFO_2A, pParameters),
                             0xFFFFFFFF};

DWORD PrinterInfo3Strings[]={0xFFFFFFFF};

DWORD PrinterInfo4Strings[]={offsetof(PRINTER_INFO_4A, pPrinterName),
                             offsetof(PRINTER_INFO_4A, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5Strings[]={offsetof(PRINTER_INFO_5A, pPrinterName),
                             offsetof(PRINTER_INFO_5A, pPortName),
                             0xFFFFFFFF};

DWORD PrinterInfo6Strings[]={0xFFFFFFFF};

DWORD PrinterInfo7Strings[]={offsetof(PRINTER_INFO_7A, pszObjectGUID),
                             0xFFFFFFFF};

DWORD PrinterInfo8Strings[]={0xFFFFFFFF};

DWORD PrinterInfo9Strings[]={0xFFFFFFFF};

#endif


#ifdef JOB_OFFSETS
DWORD JobInfo1Offsets[]={offsetof(JOB_INFO_1A, pPrinterName),
                         offsetof(JOB_INFO_1A, pMachineName),
                         offsetof(JOB_INFO_1A, pUserName),
                         offsetof(JOB_INFO_1A, pDocument),
                         offsetof(JOB_INFO_1A, pDatatype),
                         offsetof(JOB_INFO_1A, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo2Offsets[]={offsetof(JOB_INFO_2, pPrinterName),
                         offsetof(JOB_INFO_2, pMachineName),
                         offsetof(JOB_INFO_2, pUserName),
                         offsetof(JOB_INFO_2, pDocument),
                         offsetof(JOB_INFO_2, pNotifyName),
                         offsetof(JOB_INFO_2, pDatatype),
                         offsetof(JOB_INFO_2, pPrintProcessor),
                         offsetof(JOB_INFO_2, pParameters),
                         offsetof(JOB_INFO_2, pDriverName),
                         offsetof(JOB_INFO_2, pDevMode),
                         offsetof(JOB_INFO_2, pStatus),
                         offsetof(JOB_INFO_2, pSecurityDescriptor),
                         0xFFFFFFFF};

DWORD JobInfo3Offsets[]={0xFFFFFFFF};
#endif

#ifdef JOB_STRINGS
DWORD JobInfo1Strings[]={offsetof(JOB_INFO_1A, pPrinterName),
                         offsetof(JOB_INFO_1A, pMachineName),
                         offsetof(JOB_INFO_1A, pUserName),
                         offsetof(JOB_INFO_1A, pDocument),
                         offsetof(JOB_INFO_1A, pDatatype),
                         offsetof(JOB_INFO_1A, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo2Strings[]={offsetof(JOB_INFO_2, pPrinterName),
                         offsetof(JOB_INFO_2, pMachineName),
                         offsetof(JOB_INFO_2, pUserName),
                         offsetof(JOB_INFO_2, pDocument),
                         offsetof(JOB_INFO_2, pNotifyName),
                         offsetof(JOB_INFO_2, pDatatype),
                         offsetof(JOB_INFO_2, pPrintProcessor),
                         offsetof(JOB_INFO_2, pParameters),
                         offsetof(JOB_INFO_2, pDriverName),
                         offsetof(JOB_INFO_2, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo3Strings[]={0xFFFFFFFF};
#endif


#ifdef DRIVER_OFFSETS
DWORD DriverInfo1Offsets[]={offsetof(DRIVER_INFO_1A, pName),
                            0xFFFFFFFF};

DWORD DriverInfo2Offsets[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo3Offsets[]={offsetof(DRIVER_INFO_3A, pName),
                            offsetof(DRIVER_INFO_3A, pEnvironment),
                            offsetof(DRIVER_INFO_3A, pDriverPath),
                            offsetof(DRIVER_INFO_3A, pDataFile),
                            offsetof(DRIVER_INFO_3A, pConfigFile),
                            offsetof(DRIVER_INFO_3A, pHelpFile),
                            offsetof(DRIVER_INFO_3A, pDependentFiles),
                            offsetof(DRIVER_INFO_3A, pMonitorName),
                            offsetof(DRIVER_INFO_3A, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo4Offsets[]={offsetof(DRIVER_INFO_4A, pName),
                            offsetof(DRIVER_INFO_4A, pEnvironment),
                            offsetof(DRIVER_INFO_4A, pDriverPath),
                            offsetof(DRIVER_INFO_4A, pDataFile),
                            offsetof(DRIVER_INFO_4A, pConfigFile),
                            offsetof(DRIVER_INFO_4A, pHelpFile),
                            offsetof(DRIVER_INFO_4A, pDependentFiles),
                            offsetof(DRIVER_INFO_4A, pMonitorName),
                            offsetof(DRIVER_INFO_4A, pDefaultDataType),
                            offsetof(DRIVER_INFO_4A, pszzPreviousNames),
                            0xFFFFFFFF};

DWORD DriverInfo5Offsets[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo6Offsets[]={offsetof(DRIVER_INFO_6A, pName),
                            offsetof(DRIVER_INFO_6A, pEnvironment),
                            offsetof(DRIVER_INFO_6A, pDriverPath),
                            offsetof(DRIVER_INFO_6A, pDataFile),
                            offsetof(DRIVER_INFO_6A, pConfigFile),
                            offsetof(DRIVER_INFO_6A, pHelpFile),
                            offsetof(DRIVER_INFO_6A, pDependentFiles),
                            offsetof(DRIVER_INFO_6A, pMonitorName),
                            offsetof(DRIVER_INFO_6A, pDefaultDataType),
                            offsetof(DRIVER_INFO_6A, pszzPreviousNames),
                            offsetof(DRIVER_INFO_6A, pszMfgName),
                            offsetof(DRIVER_INFO_6A, pszOEMUrl),
                            offsetof(DRIVER_INFO_6A, pszHardwareID),
                            offsetof(DRIVER_INFO_6A, pszProvider),
                            0xFFFFFFFF};


#endif

#ifdef DRIVER_STRINGS
DWORD DriverInfo1Strings[]={offsetof(DRIVER_INFO_1A, pName),
                            0xFFFFFFFF};

DWORD DriverInfo2Strings[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo3Strings[]={offsetof(DRIVER_INFO_3A, pName),
                            offsetof(DRIVER_INFO_3A, pEnvironment),
                            offsetof(DRIVER_INFO_3A, pDriverPath),
                            offsetof(DRIVER_INFO_3A, pDataFile),
                            offsetof(DRIVER_INFO_3A, pConfigFile),
                            offsetof(DRIVER_INFO_3A, pHelpFile),
                            offsetof(DRIVER_INFO_3A, pMonitorName),
                            offsetof(DRIVER_INFO_3A, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo4Strings[]={offsetof(DRIVER_INFO_4A, pName),
                            offsetof(DRIVER_INFO_4A, pEnvironment),
                            offsetof(DRIVER_INFO_4A, pDriverPath),
                            offsetof(DRIVER_INFO_4A, pDataFile),
                            offsetof(DRIVER_INFO_4A, pConfigFile),
                            offsetof(DRIVER_INFO_4A, pHelpFile),
                            offsetof(DRIVER_INFO_4A, pMonitorName),
                            offsetof(DRIVER_INFO_4A, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo5Strings[]={offsetof(DRIVER_INFO_2A, pName),
                            offsetof(DRIVER_INFO_2A, pEnvironment),
                            offsetof(DRIVER_INFO_2A, pDriverPath),
                            offsetof(DRIVER_INFO_2A, pDataFile),
                            offsetof(DRIVER_INFO_2A, pConfigFile),
                            0xFFFFFFFF};

DWORD DriverInfo6Strings[]={offsetof(DRIVER_INFO_6A, pName),
                            offsetof(DRIVER_INFO_6A, pEnvironment),
                            offsetof(DRIVER_INFO_6A, pDriverPath),
                            offsetof(DRIVER_INFO_6A, pDataFile),
                            offsetof(DRIVER_INFO_6A, pConfigFile),
                            offsetof(DRIVER_INFO_6A, pHelpFile),
                            offsetof(DRIVER_INFO_6A, pMonitorName),
                            offsetof(DRIVER_INFO_6A, pDefaultDataType),
                            offsetof(DRIVER_INFO_6A, pszMfgName),
                            offsetof(DRIVER_INFO_6A, pszOEMUrl),
                            offsetof(DRIVER_INFO_6A, pszHardwareID),
                            offsetof(DRIVER_INFO_6A, pszProvider),
                            0xFFFFFFFF};

DWORD DriverInfoVersionStrings[]={offsetof(DRIVER_INFO_VERSION, pName),
                                  offsetof(DRIVER_INFO_VERSION, pEnvironment),
                                  offsetof(DRIVER_INFO_VERSION, pMonitorName),
                                  offsetof(DRIVER_INFO_VERSION, pDefaultDataType),
                                  offsetof(DRIVER_INFO_VERSION, pszMfgName),
                                  offsetof(DRIVER_INFO_VERSION, pszOEMUrl),
                                  offsetof(DRIVER_INFO_VERSION, pszHardwareID),
                                  offsetof(DRIVER_INFO_VERSION, pszProvider),
                                  0xFFFFFFFF};



#endif


#ifdef ADDJOB_OFFSETS
DWORD AddJobOffsets[]={offsetof(ADDJOB_INFO_1A, Path),
                       0xFFFFFFFF};
DWORD AddJob2Offsets[]={offsetof(ADDJOB_INFO_2W, pData),
                       0xFFFFFFFF};
#endif

#ifdef ADDJOB_STRINGS
DWORD AddJobStrings[]={offsetof(ADDJOB_INFO_1A, Path),
                       0xFFFFFFFF};
DWORD AddJob2Strings[]={offsetof(ADDJOB_INFO_2W, pData),
                        0xFFFFFFFF};

#endif


#ifdef FORM_OFFSETS
DWORD FormInfo1Offsets[]={offsetof(FORM_INFO_1A, pName),
                          0xFFFFFFFF};
#endif

#ifdef FORM_STRINGS
DWORD FormInfo1Strings[]={offsetof(FORM_INFO_1A, pName),
                          0xFFFFFFFF};
#endif


#ifdef PORT_OFFSETS
DWORD PortInfo1Offsets[]={offsetof(PORT_INFO_1A, pName),
                          0xFFFFFFFF};
DWORD PortInfo2Offsets[]={offsetof(PORT_INFO_2A, pPortName),
                          offsetof(PORT_INFO_2A, pMonitorName),
                          offsetof(PORT_INFO_2A, pDescription),
                          0xFFFFFFFF};
DWORD PortInfo3Offsets[]={offsetof(PORT_INFO_3A, pszStatus),
                          0xFFFFFFFF};
#endif

#ifdef PORT_STRINGS
DWORD PortInfo1Strings[]={offsetof(PORT_INFO_1A, pName),
                          0xFFFFFFFF};
DWORD PortInfo2Strings[]={offsetof(PORT_INFO_2A, pPortName),
                          offsetof(PORT_INFO_2A, pMonitorName),
                          offsetof(PORT_INFO_2A, pDescription),
                          0xFFFFFFFF};
#endif


#ifdef PRINTPROCESSOR_OFFSETS
DWORD PrintProcessorInfo1Offsets[]={offsetof(PRINTPROCESSOR_INFO_1A, pName),
                                    0xFFFFFFFF};
#endif

#ifdef PRINTPROCESSOR_STRINGS
DWORD PrintProcessorInfo1Strings[]={offsetof(PRINTPROCESSOR_INFO_1A, pName),
                                    0xFFFFFFFF};
#endif


#ifdef MONITOR_OFFSETS
DWORD MonitorInfo1Offsets[]={offsetof(MONITOR_INFO_1A, pName),
                             0xFFFFFFFF};
DWORD MonitorInfo2Offsets[]={offsetof(MONITOR_INFO_2A, pName),
                             offsetof(MONITOR_INFO_2A, pEnvironment),
                             offsetof(MONITOR_INFO_2A, pDLLName),
                             0xFFFFFFFF};
#endif

#ifdef MONITOR_STRINGS
DWORD MonitorInfo1Strings[]={offsetof(MONITOR_INFO_1A, pName),
                             0xFFFFFFFF};

DWORD MonitorInfo2Strings[]={offsetof(MONITOR_INFO_2A, pName),
                             offsetof(MONITOR_INFO_2A, pEnvironment),
                             offsetof(MONITOR_INFO_2A, pDLLName),
                             0xFFFFFFFF};
#endif


#ifdef DOCINFO_OFFSETS
DWORD DocInfo1Offsets[]={offsetof(DOC_INFO_1A, pDocName),
                         offsetof(DOC_INFO_1A, pOutputFile),
                         offsetof(DOC_INFO_1A, pDatatype),
                         0xFFFFFFFF};
#endif

#ifdef DOCINFO_STRINGS
DWORD DocInfo1Strings[]={offsetof(DOC_INFO_1A, pDocName),
                         offsetof(DOC_INFO_1A, pOutputFile),
                         offsetof(DOC_INFO_1A, pDatatype),
                         0xFFFFFFFF};
#endif


#ifdef DATATYPE_OFFSETS
DWORD DatatypeInfo1Offsets[]={offsetof(DATATYPES_INFO_1A, pName),
                               0xFFFFFFFF};
#endif

#ifdef DATATYPE_STRINGS

DWORD DatatypeInfo1Strings[]={offsetof(DATATYPES_INFO_1A, pName),
                               0xFFFFFFFF};
#endif


#ifdef PRINTER_ENUM_VALUES_OFFSETS

DWORD PrinterEnumValuesOffsets[] = {offsetof(PRINTER_ENUM_VALUESA, pValueName),
                                    offsetof(PRINTER_ENUM_VALUESA, pData),
                                    0xFFFFFFFF};
#endif

#ifdef PROVIDOR_STRINGS
DWORD ProvidorInfo1Strings[]={offsetof(PROVIDOR_INFO_1A, pName),
                              offsetof(PROVIDOR_INFO_1A, pEnvironment),
                              offsetof(PROVIDOR_INFO_1A, pDLLName),
                              0xFFFFFFFF};

DWORD ProvidorInfo2Strings[]={0xFFFFFFFF};
#endif



#ifdef PRINTER_OFFSETS
FieldInfo PrinterInfoStressFields[]={
                             {offsetof(PRINTER_INFO_STRESSA, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },                                 
                             {offsetof(PRINTER_INFO_STRESSA, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cTotalJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cTotalBytes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, stUpTime), sizeof(SYSTEMTIME), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, MaxcRef), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cTotalPagesPrinted), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwGetVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, fFreeBuild), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cSpooling), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cRef), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cSpooling), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cErrorOutOfPaper), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cErrorNotReady), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cJobError), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwNumberOfProcessors), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwProcessorType), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwHighPartTotalBytes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cChangeID), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwLastError), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cEnumerateNetworkPrinters), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cAddNetPrinters), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, wProcessorArchitecture), sizeof(WORD), sizeof(WORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, wProcessorLevel), sizeof(WORD), sizeof(WORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, cRefIC), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwReserved2), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(PRINTER_INFO_STRESSA, dwReserved3), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };
                             

FieldInfo PrinterInfo1Fields[]={
                                {offsetof(PRINTER_INFO_1A, Flags), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_1A, pDescription), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_1A, pComment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };
FieldInfo PrinterInfo2Fields[]={
                                {offsetof(PRINTER_INFO_2A, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pShareName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pDriverName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pComment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pLocation), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pSepFile), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pPrintProcessor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pParameters), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_2A, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, DefaultPriority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, StartTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, UntilTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, cJobs), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_2A, AveragePPM), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo3Fields[]={
                                {offsetof(PRINTER_INFO_3, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo4Fields[]={
                                {offsetof(PRINTER_INFO_4A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_4A, pServerName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_4A, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo5Fields[]={
                                {offsetof(PRINTER_INFO_5A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_5A, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_5A, Attributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_5A, TransmissionRetryTimeout), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(PRINTER_INFO_5A, TransmissionRetryTimeout), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo6Fields[]={
                                {offsetof(PRINTER_INFO_6, dwStatus), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo7Fields[]={
                                {offsetof(PRINTER_INFO_7A, pszObjectGUID), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(PRINTER_INFO_7A, dwAction), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo8Fields[]={
                                {offsetof(PRINTER_INFO_8A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo PrinterInfo9Fields[]={
                                {offsetof(PRINTER_INFO_9A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

#endif


#ifdef JOB_OFFSETS

FieldInfo JobInfo1Fields[]= {
                             {offsetof(JOB_INFO_1A, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pMachineName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pUserName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pDocument), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, pStatus), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_1A, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, Position), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, TotalPages), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, PagesPrinted), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_1A, Submitted), sizeof(SYSTEMTIME), sizeof(DWORD), DATA_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };


FieldInfo JobInfo2Fields[]= {
                             {offsetof(JOB_INFO_2A, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, pPrinterName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pMachineName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pUserName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDocument), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pNotifyName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pPrintProcessor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pParameters), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDriverName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pDevMode), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pStatus), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, pSecurityDescriptor), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(JOB_INFO_2A, Status), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Priority), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Position), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, StartTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, UntilTime), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, TotalPages), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Size), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Submitted), sizeof(SYSTEMTIME), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, Time), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {offsetof(JOB_INFO_2A, PagesPrinted), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };

FieldInfo JobInfo3Fields[]= {
                            {offsetof(JOB_INFO_3, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                            {offsetof(JOB_INFO_3, NextJobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                            {offsetof(JOB_INFO_3, Reserved), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                            {0xFFFFFFFF, 0, 0, DATA_TYPE}
                            };
#endif


#ifdef DRIVER_OFFSETS

FieldInfo DriverInfo1Fields[]= {
                                {offsetof(DRIVER_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo2Fields[]= {
                                {offsetof(DRIVER_INFO_2A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_2A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_2A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_2A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_2A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_2A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo3Fields[]= {
                                {offsetof(DRIVER_INFO_3A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_3A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_3A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_3A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {offsetof(DRIVER_INFO_3A, pHelpFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pDependentFiles), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_3A, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo4Fields[]= {
                                {offsetof(DRIVER_INFO_4A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_4A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_4A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_4A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {offsetof(DRIVER_INFO_4A, pHelpFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pDependentFiles), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_4A, pszzPreviousNames), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };


FieldInfo DriverInfo5Fields[]= {
                                {offsetof(DRIVER_INFO_5A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_5A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_5A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_5A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_5A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_5A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE }, 
                                {offsetof(DRIVER_INFO_5A, dwDriverAttributes), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_5A, dwConfigVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_5A, dwDriverVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo DriverInfo6Fields[]= {
                                {offsetof(DRIVER_INFO_6A, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_6A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_6A, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_6A, pDriverPath), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pDataFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pConfigFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pHelpFile), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pDependentFiles), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszzPreviousNames), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, ftDriverDate), sizeof(FILETIME), sizeof(DWORD), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_6A, dwlDriverVersion), sizeof(DWORDLONG), sizeof(DWORDLONG), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszMfgName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszOEMUrl), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszHardwareID), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_6A, pszProvider), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

FieldInfo DriverInfoVersionFields[]= {
                                {offsetof(DRIVER_INFO_VERSION, cVersion), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pEnvironment), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pFileInfo), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, dwFileCount), sizeof(DWORD),sizeof(DWORD), DATA_TYPE },
                                {offsetof(DRIVER_INFO_VERSION, pMonitorName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pDefaultDataType), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszzPreviousNames), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, ftDriverDate), sizeof(FILETIME), sizeof(DWORD), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, dwlDriverVersion), sizeof(DWORDLONG), sizeof(DWORDLONG), DATA_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszMfgName), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszOEMUrl), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszHardwareID), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },  
                                {offsetof(DRIVER_INFO_VERSION, pszProvider), sizeof(ULONG_PTR), sizeof(DWORD), PTR_TYPE },
                                {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                };

#endif

#ifdef ADDJOB_OFFSETS
FieldInfo AddJobFields[]= {
                           {offsetof(ADDJOB_INFO_1A, Path), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                           {offsetof(ADDJOB_INFO_1A, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                           {0xFFFFFFFF, 0, 0, DATA_TYPE}
                           };
FieldInfo AddJob2Fields[]= {
                           {offsetof(ADDJOB_INFO_2W, pData), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                           {offsetof(ADDJOB_INFO_2W, JobId), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                           {0xFFFFFFFF, 0, 0, DATA_TYPE}
                           };

#endif


#ifdef FORM_OFFSETS
FieldInfo FormInfo1Fields[]= {
                              {offsetof(FORM_INFO_1A, Flags), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {offsetof(FORM_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(FORM_INFO_1A, Size), sizeof(SIZEL), sizeof(DWORD), DATA_TYPE },
                              {offsetof(FORM_INFO_1A, ImageableArea), sizeof(RECTL), sizeof(DWORD), DATA_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };
#endif

#ifdef PORT_OFFSETS
FieldInfo PortInfo1Fields[]= {
                              {offsetof(PORT_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };

FieldInfo PortInfo2Fields[]= {
                              {offsetof(PORT_INFO_2A, pPortName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_2A, pMonitorName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_2A, pDescription), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_2A, fPortType), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {offsetof(PORT_INFO_2A, Reserved), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };
                              
FieldInfo PortInfo3Fields[]= {
                              {offsetof(PORT_INFO_3A, dwStatus), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {offsetof(PORT_INFO_3A, pszStatus), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                              {offsetof(PORT_INFO_3A, dwSeverity), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                              {0xFFFFFFFF, 0, 0, DATA_TYPE}
                              };
#endif


#ifdef PRINTPROCESSOR_OFFSETS
FieldInfo PrintProcessorInfo1Fields[]= {
                                        {offsetof(PRINTPROCESSOR_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                        {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                        };
                              
#endif


#ifdef MONITOR_OFFSETS
FieldInfo MonitorInfo1Fields[]= {
                                 {offsetof(MONITOR_INFO_2A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                 };
FieldInfo MonitorInfo2Fields[]= {
                                 {offsetof(MONITOR_INFO_2A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {offsetof(MONITOR_INFO_2A, pEnvironment), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {offsetof(MONITOR_INFO_2A, pDLLName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                 };
#endif


#ifdef DOCINFO_OFFSETS
FieldInfo DocInfo1Fields[]= {
                             {offsetof(DOC_INFO_1A, pDocName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(DOC_INFO_1A, pOutputFile), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {offsetof(DOC_INFO_1A, pDatatype), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                             {0xFFFFFFFF, 0, 0, DATA_TYPE}
                             };
#endif


#ifdef DATATYPE_OFFSETS
FieldInfo DatatypeInfo1Fields[]={
                                 {offsetof(DATATYPES_INFO_1A, pName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                 {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                 };
#endif

#ifdef PRINTER_ENUM_VALUES_OFFSETS
FieldInfo PrinterEnumValuesFields[]= {
                                      {offsetof(PRINTER_ENUM_VALUESA, pValueName), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, cbValueName), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, dwType), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, pData), sizeof(ULONG_PTR),sizeof(DWORD), PTR_TYPE },
                                      {offsetof(PRINTER_ENUM_VALUESA, cbData), sizeof(DWORD), sizeof(DWORD), DATA_TYPE },
                                      {0xFFFFFFFF, 0, 0, DATA_TYPE}
                                      };

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\winprtp.h ===
/*++

Copyright (c) 1994-1998 Microsoft Corporation
All rights reserved.

Module Name:

    WinPrtP.h

Abstract:

    Private PrintUI library public header.

Author:

    Albert Ting (AlbertT)  27-Jun-95

Revision History:

--*/

DEFINE_GUID(CLSID_PrintUIShellExtension, 0x77597368, 0x7b15, 0x11d0, 0xa0, 0xc2, 0x08, 0x00, 0x36, 0xaf, 0x3f, 0x03 );
DEFINE_GUID(IID_IFindPrinter, 0xb4cd8efc, 0xd70b, 0x11d1, 0x99, 0xb1, 0x8, 0x0, 0x36, 0xaf, 0x3f, 0x3);
DEFINE_GUID(IID_IPrinterFolder,  0xef99abd4, 0x5b8d, 0x11d1, 0xa9, 0xc8, 0x8, 0x0, 0x36, 0xaf, 0x3f, 0x3);
DEFINE_GUID(IID_IFolderNotify,  0xff22d71, 0x5172, 0x11d1, 0xa9, 0xc6, 0x8, 0x0, 0x36, 0xaf, 0x3f, 0x3);
DEFINE_GUID(IID_IDsPrinterProperties,0x8a58bc16, 0x410e, 0x11d1, 0xa9, 0xc2, 0x8, 0x0, 0x36, 0xaf, 0x3f, 0x3);
DEFINE_GUID(IID_IPhysicalLocation, 0xdfe8c7eb, 0x651b, 0x11d2, 0x92, 0xce, 0x08, 0x00, 0x36, 0xaf, 0x3f, 0x03);
DEFINE_GUID(IID_IPrnStream, 0xa24c1d62, 0x75f5, 0x11d2, 0xb8, 0x99, 0x0, 0xc0, 0x4f, 0x86, 0xae, 0x55);

// {2E4599E1-BE2C-436a-B0AD-3D0E347F34B3}
DEFINE_GUID(IID_IPrintUIServices, 0x2e4599e1, 0xbe2c, 0x436a, 0xb0, 0xad, 0x3d, 0xe, 0x34, 0x7f, 0x34, 0xb3);


#ifndef _PRTLIB_H
#define _PRTLIB_H

#ifdef __cplusplus
extern "C" {
#endif

/********************************************************************

    Prototypes

********************************************************************/

//
// Initialize the library.
//
BOOL
bPrintLibInit(
    VOID
    );

//
// Create a new print queue.
//
VOID
vQueueCreate(
    HWND    hwndOwner,
    LPCTSTR pszPrinter,
    INT     nCmdShow,
    LPARAM  lParam
    );

//
// Display document defaults for a print queue.
//
VOID
vDocumentDefaults(
    HWND    hwndOwner,
    LPCTSTR pszPrinterName,
    INT     nCmdShow,
    LPARAM  lParam
    );

#define PRINTER_SHARING_PAGE 1

//
// Display properties for a print queue.
//
VOID
vPrinterPropPages(
    HWND    hwndOwner,
    LPCTSTR pszPrinterName,
    INT     nCmdShow,
    LPARAM  lParam
    );

VOID
vServerPropPages(
    HWND    hwndOwner,
    LPCTSTR pszServerName,
    INT     nCmdShow,
    LPARAM  lParam
    );

//
// Run printer and drivers setup.
//
BOOL
bPrinterSetup(
    HWND    hwnd,
    UINT    uAction,
    UINT    cchPrinterName,
    LPTSTR  pszPrinterName,
    UINT*   pcchPrinterName,
    LPCTSTR pszServerName
    );

/********************************************************************

    Print folder interfaces.

********************************************************************/

/********************************************************************

    Printers Folder Extenstion Interface.  This interface extends
    the printers IShellFolder implementation.

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IPrinterFolder

DECLARE_INTERFACE_(IPrinterFolder, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IPrintersFolder methods ***
    STDMETHOD_(BOOL, IsPrinter)( THIS_ LPCITEMIDLIST pidl ) PURE;
};

/********************************************************************

    Folder Notification interface.

********************************************************************/

//
// Folder notify type
//

typedef enum IFolderNotifyType
{
    kFolderNone,                            // No item changed do not generate notification
    kFolderUpdate,                          // Item changed
    kFolderAttributes,                      // Item attribute changed
    kFolderCreate,                          // Item created
    kFolderDelete,                          // Item deleted
    kFolderRename,                          // Item renamed
    kFolderUpdateAll,                       // Update all items == 'F5'
} FOLDER_NOTIFY_TYPE, *PFOLDER_NOTIFY_TYPE;

//
// Folder notification callback interface definition.
//

#undef  INTERFACE
#define INTERFACE   IFolderNotify

DECLARE_INTERFACE_(IFolderNotify, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IFolderNotify methods ***
    STDMETHOD_(BOOL, ProcessNotify)( THIS_ FOLDER_NOTIFY_TYPE NotifyType, LPCWSTR pszName, LPCWSTR pszNewName ) PURE;
};

typedef struct _FOLDER_PRINTER_DATA {
    LPCTSTR pName;
    LPCTSTR pComment;
    DWORD   Status;
    DWORD   Attributes;
    DWORD   cJobs;
    DWORD   cbSize;
    LPCTSTR pLocation;
    LPCTSTR pDriverName;
    LPCTSTR pStatus;            // Connection status i.e. <opening...>
    LPCTSTR pPortName;
} FOLDER_PRINTER_DATA, *PFOLDER_PRINTER_DATA;

//
// Register folder watch.  Currently this only works for print
// servers; connections aren't maintained.
//
HRESULT
RegisterPrintNotify(
    IN   LPCTSTR                 pszDataSource,
    IN   IFolderNotify           *pClientNotify,
    OUT  LPHANDLE                phFolder,
    OUT  PBOOL                   pbAdministrator OPTIONAL
    );

//
// Unregister folder watch.  Currently this only works for print
// servers; connections aren't maintained.
//
HRESULT
UnregisterPrintNotify(
    IN   LPCTSTR                 pszDataSource,
    IN   IFolderNotify           *pClientNotify,
    OUT  LPHANDLE                phFolder
    );

BOOL
bFolderEnumPrinters(
    IN   HANDLE                  hFolder,
    OUT  PFOLDER_PRINTER_DATA    pData,
    IN   DWORD                   cbData,
    OUT  PDWORD                  pcbNeeded,
    OUT  PDWORD                  pcbReturned
    );

BOOL
bFolderRefresh(
    IN   HANDLE                  hFolder,
    OUT  PBOOL                   pbAdministrator
    );

BOOL
bFolderGetPrinter(
    IN   HANDLE                  hFolder,
    IN   LPCTSTR                 pszPrinter,
    OUT  PFOLDER_PRINTER_DATA    pData,
    IN   DWORD                   cbData,
    OUT  PDWORD                  pcbNeeded
    );

/********************************************************************

    PrintUI error support (exposed to shell)

********************************************************************/

HRESULT
ShowErrorMessageSC(
    OUT INT                 *piResult,
    IN  HINSTANCE            hModule,
    IN  HWND                 hwnd,
    IN  LPCTSTR              pszTitle,
    IN  LPCTSTR              pszMessage,
    IN  UINT                 uType,
    IN  DWORD                dwCode
    );

HRESULT
ShowErrorMessageHR(
    OUT INT                 *piResult,
    IN  HINSTANCE            hModule,
    IN  HWND                 hwnd,
    IN  LPCTSTR              pszTitle,
    IN  LPCTSTR              pszMessage,
    IN  UINT                 uType,
    IN  HRESULT              hr
    );

/********************************************************************

    IPhysicalLocation

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IPhysicalLocation

DECLARE_INTERFACE_(IPhysicalLocation, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IPhysicalLocation methods
    STDMETHOD(DiscoverPhysicalLocation)(THIS) PURE;
    STDMETHOD(GetExactPhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(GetSearchPhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;

    // IPhysicalLocation methods for fetching individual physical locations
    STDMETHOD(GetUserPhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(GetMachinePhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(GetSubnetPhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(GetSitePhysicalLocation)(THIS_ BSTR *pbsLocation) PURE;
    STDMETHOD(BrowseForLocation)(THIS_ HWND hParent, BSTR bsDefault, BSTR *pbsLocation) PURE;
    STDMETHOD(ShowPhysicalLocationUI)(THIS) PURE;
};

/********************************************************************

    IDsPrinterProperties

    This is a private interface used to launch printer properties
    from the DS MMC snapin.

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IDsPrinterProperties

DECLARE_INTERFACE_(IDsPrinterProperties, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IDsFolder methods
    STDMETHOD(ShowProperties)(THIS_ HWND hwndParent, LPCWSTR pszObjectPath, PBOOL pbDisplayed) PURE;
};

/********************************************************************

    Find Printer Interface.  This inferface allows a user to find
    a printer either on the network or in the DS if one is
    available.

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IFindPrinter

DECLARE_INTERFACE_(IFindPrinter, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IFindPrinter methods
    STDMETHOD(FindPrinter)(THIS_ HWND hwnd, LPWSTR pszBuffer, UINT *puSize) PURE;
};

/********************************************************************

    IPageSwitch - Interface used as a connection point for
    the connect to printer dialog when integrated in a wizard.

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IPageSwitch

DECLARE_INTERFACE(IPageSwitch)
{
    // *** INotifyReflect methods ***

    //
    // This functions provide opportunity to the client to change
    // the next/prev page ID and/or allow/deny advancing to the
    // next/prev page.
    //
    // S_OK:        means you can advance to the next/prev page
    // S_FALSE:     means you cant advance to the next/prev page
    //
    STDMETHOD(GetPrevPageID)( THIS_ UINT *puPageID ) PURE;
    STDMETHOD(GetNextPageID)( THIS_ UINT *puPageID ) PURE;

    //
    // The property page calls this method when the printer connection is
    // successfully created and we are about to advance to the
    // next/prev page
    //
    STDMETHOD(SetPrinterInfo)( THIS_ LPCWSTR pszPrinterName, LPCWSTR pszComment, LPCWSTR pszLocation, LPCWSTR pszShareName ) PURE;

    //
    // This method provide notification to the client that
    // the user clicked "Cancel" button on the wizard - which
    // normaly leads to closing the wizard.
    //
    // S_OK     - Prevent cancel operation
    // S_FALSE  - Allow cancel operation
    //
    STDMETHOD(QueryCancel)( THIS ) PURE;
};

//
// The API function for creating the ConnectToPrinterDlg style
// property page
//
HRESULT
ConnectToPrinterPropertyPage(
    OUT HPROPSHEETPAGE   *phPsp,
    OUT UINT             *puPageID,
    IN  IPageSwitch      *pPageSwitchController
    );

/********************************************************************

    IPrnStream flags

********************************************************************/

typedef enum _PrinterPersistentFlags
{
    PRST_PRINTER_DATA       = 1<<0,
    PRST_PRINTER_INFO_2     = 1<<1,
    PRST_PRINTER_INFO_7     = 1<<2,
    PRST_PRINTER_SEC        = 1<<3,
    PRST_USER_DEVMODE       = 1<<4,
    PRST_PRINTER_DEVMODE    = 1<<5,
    PRST_COLOR_PROF         = 1<<6,
    PRST_FORCE_NAME         = 1<<7,
    PRST_RESOLVE_NAME       = 1<<8,
    PRST_RESOLVE_PORT       = 1<<9,
    PRST_RESOLVE_SHARE      = 1<<10,
    PRST_DONT_GENERATE_SHARE = 1<<11,
    PRST_MINIMUM_SETTINGS   = PRST_PRINTER_DATA | PRST_PRINTER_INFO_2 | PRST_PRINTER_DEVMODE,
    PRST_ALL_SETTINGS       = PRST_MINIMUM_SETTINGS | 
                              PRST_PRINTER_INFO_7   | 
                              PRST_PRINTER_SEC      | 
                              PRST_USER_DEVMODE     | 
                              PRST_COLOR_PROF,
} PrinterPersistentFlags;

/********************************************************************

    IPrnStream query flags.

********************************************************************/

typedef enum _PrinterPersistentQueryFlag
{
    kPrinterPersistentPrinterInfo2,
    kPrinterPersistentPrinterInfo7,
    kPrinterPersistentUserDevMode,
    kPrinterPersistentPrinterDevMode,
    kPrinterPersistentSecurity,
    kPrinterPersistentColorProfile,
} PrinterPersistentQueryFlag;

typedef union _PersistentInfo
{
    PRINTER_INFO_2      *pi2;
    PRINTER_INFO_7      *pi7;
    DEVMODE             *pDevMode;
    SECURITY_DESCRIPTOR *pszSecurity;
    LPWSTR              pMultiSzColor;
} PersistentInfo;

/********************************************************************

    IPrnStream interface definition

********************************************************************/

#undef  INTERFACE
#define INTERFACE   IPrnStream

DECLARE_INTERFACE_(IPrnStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IPrnStream methods
    STDMETHOD(BindPrinterAndFile)(THIS_ LPCWSTR pszPrinter, LPCWSTR pszFile) PURE;
    STDMETHOD(StorePrinterInfo)(THIS_ DWORD dwFlag) PURE;
    STDMETHOD(RestorePrinterInfo)(THIS_ DWORD dwFlag) PURE;
    STDMETHOD(QueryPrinterInfo)(THIS_ PrinterPersistentQueryFlag Flag, PersistentInfo *pPrstInfo) PURE;
};

/********************************************************************

    Error codes returned by IPrnStream methods

********************************************************************/

typedef enum _PrnPrstError
{
    //
    //  When storing/ restoring opereations called and
    //  BindPrinterAndFile wasn't called or failed
    //
    PRN_PERSIST_ERROR_INVALID_OBJ       = 0x1,
    //
    //  Failed to write Printer data because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_PRNDATA     = 0x2,
    //
    //  Failed to restore Printer data because SetPrinterData failed
    //
    PRN_PERSIST_ERROR_RESTORE_PRNDATA   = 0x3,
    //
    //  Failed to restore Printer data because because reading failure
    //
    PRN_PERSIST_ERROR_READ_PRNDATA      = 0x4,
    //
    //  Failed to store Printer Info 2 because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_PI2         = 0x5,
    //
    //  Failed to store Printer Info 2 because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_PI2           = 0x6,
    //
    //  Failed to restore Printer Info 2 because reading failure
    //
    PRN_PERSIST_ERROR_READ_PI2          = 0x7,
    //
    //  Failed to restore Printer Info 2 because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_PI2       = 0x8,
    //
    //  Failed to store Printer Info 7 because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_PI7         = 0x9,
    //
    //  Failed to store Printer Info 7 because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_PI7           = 0xa,
    //
    //  Failed to restore Printer Info 7 because reading failure
    //
    PRN_PERSIST_ERROR_READ_PI7          = 0xb,
    //
    //  Failed to restore Printer Info 7 because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_PI7       = 0xc,
    //
    //  Failed to store Printer Security Descriptor because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_SEC         = 0xd,
    //
    //  Failed to store Printer Security Descriptor because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_SEC           = 0xe,
    //
    //  Failed to restore Printer Security Descriptor because reading failure
    //
    PRN_PERSIST_ERROR_READ_SEC          = 0xf,
    //
    //  Failed to restore Printer Security Descriptor because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_SEC       = 0x10,
    //
    //  Failed to store Printer Color Profiles because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_COLOR_PRF   = 0x11,
    //
    //  Failed to store Printer Color Profiles because EnumcolorProfiles failure
    //
    PRN_PERSIST_ERROR_GET_COLOR_PRF     = 0x12,
    //
    //  Failed to restore Printer Color Profiles because reading failure
    //
    PRN_PERSIST_ERROR_READ_COLOR_PRF    = 0x13,
    //
    //  Failed to restore Printer Color Profiles because AddColorProfile failure
    //
    PRN_PERSIST_ERROR_RESTORE_COLOR_PRF = 0x14,
    //
    //  Failed to store User DevMode because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_USR_DEVMODE = 0x15,
    //
    //  Failed to store User DevMode because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_USR_DEVMODE   = 0x16,
    //
    //  Failed to restore User DevMode because reading failure
    //
    PRN_PERSIST_ERROR_READ_USR_DEVMODE  = 0x17,
    //
    //  Failed to restore User DevMode because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_USR_DEVMODE   = 0x18,
    //
    //  Failed to store Printer DevMode because writing failure
    //
    PRN_PERSIST_ERROR_WRITE_PRN_DEVMODE     = 0x19,
    //
    //  Failed to store Printer DevMode because GetPrinter failure
    //
    PRN_PERSIST_ERROR_GET_PRN_DEVMODE       = 0x1a,
    //
    //  Failed to restore Printer DevMode because reading failure
    //
    PRN_PERSIST_ERROR_READ_PRN_DEVMODE      = 0x1b,
    //
    //  Failed to restore Printer DevMode because SetPrinter failure
    //
    PRN_PERSIST_ERROR_RESTORE_PRN_DEVMODE   = 0x1c,
    //
    //  Failed because of unresolved printer name conflict
    //
    PRN_PERSIST_ERROR_PRN_NAME_CONFLICT     = 0x1d,
    //
    //  Failed because of printer name conflict
    //
    PRN_PERSIST_ERROR_UNBOUND               = 0x1e,
    //
    //  Restoring failure because failure at building backup info
    //
    PRN_PERSIST_ERROR_BACKUP                = 0x1f,
    //
    //  Restoring failure and Backup Failure too ; printer settings in undefined status
    //
    PRN_PERSIST_ERROR_FATAL                 = 0xffff
} PrnPrstError;

/********************************************************************

    IID_IPrintUIServices interface definition

********************************************************************/

#undef  INTERFACE
#define INTERFACE  IPrintUIServices

DECLARE_INTERFACE_(IPrintUIServices, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IID_IPrintUIServices methods ***
    STDMETHOD(GenerateShareName)(THIS_ LPCTSTR lpszServer, LPCTSTR lpszBaseName, LPTSTR lpszOut, int cchMaxChars) PURE;
};

#ifdef __cplusplus
}
#endif
#endif // ndef _PRTLIB_HXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\sdktools\inc\kdbg1394.h ===
/*++
Copyright (c) 1998-2001  Microsoft Corporation

Module Name:

    ntkd1394.h

Abstract:

    Header file for 1394 Debugging

Author:

    George Chrysanthakopoulos (georgioc) 31-October-1999

Revision   History:
Date       Who       What
---------- --------- ------------------------------------------------------------
06/19/2001 pbinder   cleanup
--*/

// {66f250d6-7801-4a64-b139-eea80a450b24}
DEFINE_GUID(GUID_1394DBG, 0x66f250d6, 0x7801, 0x4a64, 0xb1, 0x39, 0xee, 0xa8, 0x0a, 0x45, 0x0b, 0x24);

#define DEBUG_1394_MAJOR_VERSION            0x1
#define DEBUG_1394_MINOR_VERSION            0x0

#define DEBUG_1394_CONFIG_TAG               0xBABABABA

#define INSTANCE_DEVICE_SYMLINK_NAME        L"\\DosDevices\\DBG1394_INSTANCE"
#define INSTANCE_DEVICE_NAME                L"\\Device\\Dbg1394_Instance"

#define DEBUG_BUS1394_MAX_PACKET_SIZE       4000

typedef struct _DEBUG_1394_SEND_PACKET {

    ULONG               TransferStatus;
    ULONG               PacketHeader[4];
    ULONG               Length;
    UCHAR               Packet[DEBUG_BUS1394_MAX_PACKET_SIZE];

} DEBUG_1394_SEND_PACKET, *PDEBUG_1394_SEND_PACKET;

typedef struct _DEBUG_1394_RECEIVE_PACKET {

    ULONG               TransferStatus;
    ULONG               Length;
    UCHAR               Packet[DEBUG_BUS1394_MAX_PACKET_SIZE];

} DEBUG_1394_RECEIVE_PACKET, *PDEBUG_1394_RECEIVE_PACKET;

// exists on target. client uses to match for id.
typedef struct _DEBUG_1394_CONFIG {

    ULONG               Tag;
    USHORT              MajorVersion;
    USHORT              MinorVersion;
    ULONG               Id;
    ULONG               BusPresent;    
    PHYSICAL_ADDRESS    SendPacket;
    PHYSICAL_ADDRESS    ReceivePacket;

} DEBUG_1394_CONFIG, *PDEBUG_1394_CONFIG;

//
// Various definitions
//
#define IOCTL_V1394DBG_API_REQUEST          CTL_CODE( FILE_DEVICE_UNKNOWN, \
                                                      0x200,               \
                                                      METHOD_BUFFERED,     \
                                                      FILE_ANY_ACCESS)


//
// Debug 1394 Request Packets
//
typedef struct _VDBG1394_API_CONFIGURATION {

    ULONG           OperationMode;
    ULONG           fulFlags;
    ULARGE_INTEGER  HostControllerInstanceId;
    ULONG           PhySpeed;

} VDBG1394_API_CONFIGURATION, *PVDBG1394_API_CONFIGURATION;

typedef struct _VDBG1394_API_IO_PARAMETERS {

    ULONG               fulFlags;
    PHYSICAL_ADDRESS    StartingMemoryOffset;

} VDBG1394_API_IO_PARAMETERS, *PVDBG1394_IO_PARAMETERS;

#ifndef _1394_H_

//
// 1394 Node Address format
//
typedef struct _NODE_ADDRESS {
    USHORT              NA_Node_Number:6;       // Bits 10-15
    USHORT              NA_Bus_Number:10;       // Bits 0-9
} NODE_ADDRESS, *PNODE_ADDRESS;

//
// 1394 Address Offset format (48 bit addressing)
//
typedef struct _ADDRESS_OFFSET {
    USHORT              Off_High;
    ULONG               Off_Low;
} ADDRESS_OFFSET, *PADDRESS_OFFSET;

//
// 1394 I/O Address format
//
typedef struct _IO_ADDRESS {
    NODE_ADDRESS        IA_Destination_ID;
    ADDRESS_OFFSET      IA_Destination_Offset;
} IO_ADDRESS, *PIO_ADDRESS;

#endif

typedef struct _V1394DBG_API_ASYNC_READ {

    IO_ADDRESS      DestinationAddress;
    ULONG           DataLength;
    UCHAR           Data[1];

} VDBG1394_API_ASYNC_READ, *PVDBG1394_API_ASYNC_READ;

typedef struct _V1394DBG_API_REQUEST {

    //
    // Holds the zero based Function number that corresponds to the request
    // that device drivers are asking the sbp2 port driver to carry out.
    //

    ULONG RequestNumber;

    //
    // Holds Flags that may be unique to this particular operation
    //

    ULONG Flags;

    //
    // Holds the structures used in performing the various 1394 APIs
    //

    union {

        VDBG1394_API_CONFIGURATION SetConfiguration;
        VDBG1394_API_CONFIGURATION GetConfiguration;
        VDBG1394_API_IO_PARAMETERS SetIoParameters;
        VDBG1394_API_IO_PARAMETERS GetIoParameters;

        VDBG1394_API_ASYNC_READ    AsyncRead;
    } u;

} V1394DBG_API_REQUEST, *PV1394DBG_API_REQUEST;

//
// Request Number
//
#define V1394DBG_API_SET_CONFIGURATION                      0x00000001
#define V1394DBG_API_GET_CONFIGURATION                      0x00000002
#define V1394DBG_API_SET_IO_PARAMETERS                      0x00000003
#define V1394DBG_API_GET_IO_PARAMETERS                      0x00000004
#define V1394DBG_API_SET_DEBUG_MODE                         0x00000005
#define V1394DBG_API_ASYNC_READ                             0x00000006

#define V1394DBG_API_CONFIGURATION_MODE_DEBUG               0x00000000
#define V1394DBG_API_CONFIGURATION_MODE_RAW_MEMORY_ACCESS   0x00000001

#define V1394DBG_API_FLAG_WRITE_IO                          0x00000001
#define V1394DBG_API_FLAG_READ_IO                           0x00000002

// 3 different debug modes flags
#define V1394DBG_API_MODE_KD_CLIENT                         0x00000001
#define V1394DBG_API_MODE_USER_CLIENT                       0x00000002
#define V1394DBG_API_MODE_USER_SERVER                       0x00000003
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\winsrv\offsets.h ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation
All rights reserved

Module Name:

    offsets.h

Abstract:

    Global structure declarations used by marshalling and string packing code.

Author:

Environment:

    User Mode - Spoolss

Revision History:

Notes: 

--*/

#ifndef _OFFSETS_H
#define _OFFSETS_H

#include "mType.h"

extern DWORD PrinterInfoStressOffsets[];
extern DWORD PrinterInfoStressStrings[];
extern DWORD PrinterInfo4Offsets[];
extern DWORD PrinterInfo4Strings[];
extern DWORD PrinterInfo1Offsets[];
extern DWORD PrinterInfo1Strings[];
extern DWORD PrinterInfo2Offsets[];
extern DWORD PrinterInfo2Strings[];
extern DWORD PrinterInfo3Offsets[];
extern DWORD PrinterInfo3Strings[];
extern DWORD PrinterInfo5Offsets[];
extern DWORD PrinterInfo5Strings[];
extern DWORD PrinterInfo6Offsets[];
extern DWORD PrinterInfo6Strings[];
extern DWORD PrinterInfo7Offsets[];
extern DWORD PrinterInfo7Strings[];
extern DWORD PrinterInfo8Offsets[];
extern DWORD PrinterInfo8Strings[];
extern DWORD PrinterInfo9Offsets[];
extern DWORD PrinterInfo9Strings[];
extern DWORD JobInfo1Offsets[];
extern DWORD JobInfo1Strings[];
extern DWORD JobInfo2Offsets[];
extern DWORD JobInfo2Strings[];
extern DWORD JobInfo3Offsets[];
extern DWORD JobInfo3Strings[];
extern DWORD DriverInfo1Offsets[];
extern DWORD DriverInfo1Strings[];
extern DWORD DriverInfo2Offsets[];
extern DWORD DriverInfo2Strings[];
extern DWORD DriverInfo3Offsets[];
extern DWORD DriverInfo3Strings[];
extern DWORD DriverInfo4Offsets[];
extern DWORD DriverInfo4Strings[];
extern DWORD DriverInfo5Offsets[];
extern DWORD DriverInfo5Strings[];
extern DWORD DriverInfo6Offsets[];
extern DWORD DriverInfoVersionStrings[];


extern DWORD DriverInfo6Strings[];
extern DWORD AddJobOffsets[];
extern DWORD AddJob2Offsets[];
extern DWORD AddJobStrings[];
extern DWORD AddJob2Strings[];
extern DWORD FormInfo1Offsets[];
extern DWORD FormInfo1Strings[];
extern DWORD PortInfo1Offsets[];
extern DWORD PortInfo1Strings[];
extern DWORD PortInfo2Offsets[];
extern DWORD PortInfo2Strings[];
extern DWORD PortInfo3Offsets[];
extern DWORD PrintProcessorInfo1Offsets[];
extern DWORD PrintProcessorInfo1Strings[];
extern DWORD MonitorInfo1Offsets[];
extern DWORD MonitorInfo2Offsets[];
extern DWORD MonitorInfo1Strings[];
extern DWORD MonitorInfo2Strings[];
extern DWORD DocInfo1Offsets[];
extern DWORD DocInfo1Strings[];
extern DWORD ProvidorInfo1Strings[];
extern DWORD ProvidorInfo2Strings[];
extern DWORD DatatypeInfo1Offsets[];
extern DWORD DatatypeInfo1Strings[];
extern DWORD PrinterEnumValuesOffsets[];


extern FieldInfo PrinterInfoStressFields[];
extern FieldInfo PrinterInfo4Fields[];
extern FieldInfo PrinterInfo1Fields[];
extern FieldInfo PrinterInfo2Fields[];
extern FieldInfo PrinterInfo3Fields[];
extern FieldInfo PrinterInfo5Fields[];
extern FieldInfo PrinterInfo6Fields[];
extern FieldInfo PrinterInfo7Fields[];
extern FieldInfo PrinterInfo8Fields[];
extern FieldInfo PrinterInfo9Fields[];
extern FieldInfo JobInfo1Fields[];
extern FieldInfo JobInfo2Fields[];
extern FieldInfo JobInfo3Fields[];
extern FieldInfo DriverInfo1Fields[];
extern FieldInfo DriverInfo2Fields[];
extern FieldInfo DriverInfo3Fields[];
extern FieldInfo DriverInfo4Fields[];
extern FieldInfo DriverInfo5Fields[];
extern FieldInfo DriverInfo6Fields[];
extern FieldInfo DriverInfoVersionFields[];

extern FieldInfo AddJobFields[];
extern FieldInfo AddJob2Fields[];
extern FieldInfo FormInfo1Fields[];
extern FieldInfo PortInfo1Fields[];
extern FieldInfo PortInfo2Fields[];
extern FieldInfo PortInfo3Fields[];
extern FieldInfo PrintProcessorInfo1Fields[];
extern FieldInfo MonitorInfo1Fields[];
extern FieldInfo MonitorInfo2Fields[];
extern FieldInfo DocInfo1Fields[];
extern FieldInfo DatatypeInfo1Fields[];
extern FieldInfo PrinterEnumValuesFields[];


extern FieldInfo PrinterInfoStressFields32[];
extern FieldInfo PrinterInfo4Fields32[];
extern FieldInfo PrinterInfo1Fields32[];
extern FieldInfo PrinterInfo2Fields32[];
extern FieldInfo PrinterInfo3Fields32[];
extern FieldInfo PrinterInfo5Fields32[];
extern FieldInfo PrinterInfo6Fields32[];
extern FieldInfo PrinterInfo7Fields32[];
extern FieldInfo PrinterInfo8Fields32[];
extern FieldInfo PrinterInfo9Fields32[];
extern FieldInfo JobInfo1Fields32[];
extern FieldInfo JobInfo2Fields32[];
extern FieldInfo JobInfo3Fields32[];
extern FieldInfo DriverInfo1Fields32[];
extern FieldInfo DriverInfo2Fields32[];
extern FieldInfo DriverInfo3Fields32[];
extern FieldInfo DriverInfo4Fields32[];
extern FieldInfo DriverInfo5Fields32[];
extern FieldInfo DriverInfo6Fields32[];
extern FieldInfo AddJobFields32[];
extern FieldInfo FormInfo1Fields32[];
extern FieldInfo PortInfo1Fields32[];
extern FieldInfo PortInfo2Fields32[];
extern FieldInfo PortInfo3Fields32[];
extern FieldInfo PrintProcessorInfo1Fields32[];
extern FieldInfo MonitorInfo1Fields32[];
extern FieldInfo MonitorInfo2Fields32[];
extern FieldInfo DocInfo1Fields32[];
extern FieldInfo DatatypeInfo1Fields32[];
extern FieldInfo PrinterEnumValuesFields32[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\winsrv\kmspool.h ===
BOOL KMOpenPrinterW(LPWSTR   pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTS pDefault);

BOOL
KMGetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   Level,
    LPBYTE  pDriverInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

DWORD
KMGetPrinterDataW(
   HANDLE   hPrinter,
   LPWSTR   pValueName,
   LPDWORD  pType,
   LPBYTE   pData,
   DWORD    nSize,
   LPDWORD  pcbNeeded
);


DWORD
KMSetPrinterDataW(
    HANDLE  hPrinter,
    LPWSTR  pValueName,
    DWORD   Type,
    LPBYTE  pData,
    DWORD   cbData
);


BOOL
KMWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
);
DWORD
KMStartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pDocInfo
);


BOOL
KMGetFormW(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);

BOOL
KMEnumFormsW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
);

BOOL
KMGetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
);


BOOL
KMEndDocPrinter(
    HANDLE  hPrinter
);

BOOL
KMStartPagePrinter(
    HANDLE hPrinter
);

BOOL
KMEndPagePrinter(
    HANDLE  hPrinter
);

BOOL
KMClosePrinter(
    HANDLE  hPrinter);

BOOL
KMAbortPrinter(
    HANDLE  hPrinter);

VOID
FreeSpool(
    PSPOOL pSpool);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\winsrv\mtype.h ===
/*++

Copyright (c) 1990 - 2000  Microsoft Corporation
All rights reserved.

Module Name:

    mtype.h

Abstract:

    Marshalling code needs this information about each field in _INFO_ structures. 
    Data.h define arrays of FieldInfo structures for each _INFO_ structure
    
Author:

    AdinaTru 18 Jan 2000

Revision History:


--*/

#ifndef _MTYPE
#define _MTYPE

typedef enum _EFIELDTYPE 
{
    DATA_TYPE = 0,
    PTR_TYPE  = 1,

} EFIELDTYPE;


typedef enum Call_Route
{
    NATIVE_CALL  = 0,   // either KM call or Spooler in-proc call
    RPC_CALL     = 1,   // RPC call
   
} CALL_ROUTE;

//
// Holds information about a field in public spooler structures _INFO_
//
typedef struct _FieldInfo 
{
    DWORD32 Offset;           // Field's offset inside structure
    ULONG_PTR Size;           // Field's size in bytes
    ULONG_PTR Alignment;      // Field's alignment; Not always the same as the size!!!
    EFIELDTYPE  Type;         // Field's type;  PTR_TYPE if pointer, DATA_TYPE otherwise

} FieldInfo;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\sdktools\inc\cmdhelp.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cmdhelp.h

Abstract:

    Command line helper library

Environment:

    User mode only

Revision History:
    
    04/04/2001 - created

--*/

#ifndef __CMDHELP_H__
#define __CMDHELP_H__

#pragma warning(push)
#pragma warning(disable:4200) // array[0] is not a warning for this file

#include <windows.h>  // sdk

/*++

Routine Description:

    Validates a string contains only valid octal characters (and spaces)

Arguments:

    String - string to be verified

Return Value:

    TRUE if the string is valid

--*/
BOOL
CmdHelpValidateStringOctal(
    IN PCHAR String
    );

/*++

Routine Description:

    Validates a string contains only valid decimal characters (and spaces)

Arguments:

    String - string to be verified

Return Value:

    TRUE if the string is valid

--*/
BOOL
CmdHelpValidateStringDecimal(
    IN PCHAR String
    );

/*++

Routine Description:

    Validates a string contains only valid hex characters (and spaces)

Arguments:

    String - string to be verified

Return Value:

    TRUE if the string is valid

--*/
BOOL
CmdHelpValidateStringHex(
    IN PCHAR String
    );

/*++

Routine Description:

    Validates a string is formatted properly for use in
    SptUtilScanQuotedHexString().  The required format is as follows:
    
        x <= { 0..9, A..F, a..f }
        "(xx )*(xx)"
        
    i.e. the following strings are valid:
        "00 01 02 03"
        "00"
        "ff Fa Bc Ed 08 8f"
        
    i.e. the following strings are invalid:
        ""              // zero-length string
        " 00 01 02 03"  // space at beginning
        "00 01 02 03 "  // space at end

Arguments:

    String - string to be verified

Return Value:

    TRUE if the string is valid

--*/
BOOL
CmdHelpValidateStringHexQuoted(
    IN PCHAR String
    );

/*++

Routine Description:

    Scans in a quoted hex string of the form "xx xx xx" into
    a pre-allocated buffer.
    Also can be used to determine the required buffer size.
    
Arguments:

Return Value:

    TRUE && *DataSize != 0 if everything was successful.
    (*DataSize contains the size of the data scanned)
    
    FALSE && *DataSize == 0 if failed to validate string
    
    FALSE && *DataSize != 0 if buffer too small

--*/
BOOLEAN
CmdHelpScanQuotedHexString(
    IN  PUCHAR QuotedHexString,
    OUT PUCHAR Data,
    OUT PDWORD DataSize
    );

/*++

Routine Description:

    Prints out the buffer specified in HEX format.
    Simplistic, but very useful, esp. for debugging.
    
Arguments:

    Buffer - the data to print
    Size - how many bytes are to be printed

Return Value:

--*/
VOID
CmdHelpPrintBuffer(
    IN PUCHAR Buffer,
    IN SIZE_T Size
    );


#pragma warning(pop)
#endif // __CMDHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\printscan\inc\winsrv\winspl.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0286 */
/* Compiler settings for winspl.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __winspl_h__
#define __winspl_h__

/* Forward Declarations */ 

/* header files for imported files */
#include "import.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __winspool_INTERFACE_DEFINED__
#define __winspool_INTERFACE_DEFINED__

/* interface winspool */
/* [implicit_handle][unique][endpoint][ms_union][version][uuid] */ 

typedef WORD TABLE;

typedef struct _NOTIFY_ATTRIB_TABLE
    {
    WORD Attrib;
    TABLE Table;
    }	NOTIFY_ATTRIB_TABLE;

typedef struct _NOTIFY_ATTRIB_TABLE __RPC_FAR *PNOTIFY_ATTRIB_TABLE;

typedef /* [context_handle] */ void __RPC_FAR *PRINTER_HANDLE;

typedef /* [context_handle] */ void __RPC_FAR *GDI_HANDLE;

typedef /* [handle] */ wchar_t __RPC_FAR *STRING_HANDLE;

typedef /* [string] */ wchar_t __RPC_FAR *SPL_STRING;

typedef struct _PORT_VAR_CONTAINER
    {
    DWORD cbMonitorData;
    /* [unique][size_is] */ LPBYTE pMonitorData;
    }	PORT_VAR_CONTAINER;

typedef struct _PORT_VAR_CONTAINER __RPC_FAR *PPORT_VAR_CONTAINER;

typedef struct _PORT_VAR_CONTAINER __RPC_FAR *LPPORT_VAR_CONTAINER;

typedef struct _PORT_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPPORT_INFO_1W pPortInfo1;
        /* [case()] */ LPPORT_INFO_2W pPortInfo2;
        /* [case()] */ LPPORT_INFO_3W pPortInfo3;
        /* [case()] */ LPPORT_INFO_FFW pPortInfoFF;
        }	PortInfo;
    }	PORT_CONTAINER;

typedef struct _PORT_CONTAINER __RPC_FAR *PPORT_CONTAINER;

typedef struct _PORT_CONTAINER __RPC_FAR *LPPORT_CONTAINER;

typedef struct _DEVMODE_CONTAINER
    {
    DWORD cbBuf;
    /* [unique][size_is] */ LPBYTE pDevMode;
    }	DEVMODE_CONTAINER;

typedef struct _DEVMODE_CONTAINER __RPC_FAR *PDEVMODE_CONTAINER;

typedef struct _DEVMODE_CONTAINER __RPC_FAR *LPDEVMODE_CONTAINER;

typedef struct _SECURITY_CONTAINER
    {
    DWORD cbBuf;
    /* [unique][size_is] */ LPBYTE pSecurity;
    }	SECURITY_CONTAINER;

typedef struct _SECURITY_CONTAINER __RPC_FAR *PSECURITY_CONTAINER;

typedef struct _SECURITY_CONTAINER __RPC_FAR *LPSECURITY_CONTAINER;

typedef struct _PRINTER_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPPRINTER_INFO_STRESSW pPrinterInfoStress;
        /* [case()] */ LPPRINTER_INFO_1W pPrinterInfo1;
        /* [case()] */ LPPRINTER_INFO_2W pPrinterInfo2;
        /* [case()] */ LPPRINTER_INFO_3 pPrinterInfo3;
        /* [case()] */ LPPRINTER_INFO_4W pPrinterInfo0;
        /* [case()] */ LPPRINTER_INFO_5W pPrinterInfo5;
        /* [case()] */ LPPRINTER_INFO_6 pPrinterInfo6;
        /* [case()] */ LPPRINTER_INFO_7W pPrinterInfo7;
        /* [case()] */ LPPRINTER_INFO_8W pPrinterInfo8;
        /* [case()] */ LPPRINTER_INFO_9W pPrinterInfo9;
        }	PrinterInfo;
    }	PRINTER_CONTAINER;

typedef struct _PRINTER_CONTAINER __RPC_FAR *PPRINTER_CONTAINER;

typedef struct _PRINTER_CONTAINER __RPC_FAR *LPPRINTER_CONTAINER;

typedef struct _JOB_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ JOB_INFO_1W __RPC_FAR *Level1;
        /* [case()] */ JOB_INFO_2W __RPC_FAR *Level2;
        /* [case()] */ JOB_INFO_3 __RPC_FAR *Level3;
        }	JobInfo;
    }	JOB_CONTAINER;

typedef struct _JOB_CONTAINER __RPC_FAR *PJOB_CONTAINER;

typedef struct _JOB_CONTAINER __RPC_FAR *LPJOB_CONTAINER;

typedef struct _RPC_DRIVER_INFO_3W
    {
    DWORD cVersion;
    SPL_STRING pName;
    SPL_STRING pEnvironment;
    SPL_STRING pDriverPath;
    SPL_STRING pDataFile;
    SPL_STRING pConfigFile;
    SPL_STRING pHelpFile;
    SPL_STRING pMonitorName;
    SPL_STRING pDefaultDataType;
    DWORD cchDependentFiles;
    /* [unique][size_is] */ WCHAR __RPC_FAR *pDependentFiles;
    }	RPC_DRIVER_INFO_3W;

typedef struct _RPC_DRIVER_INFO_3W __RPC_FAR *PRPC_DRIVER_INFO_3W;

typedef struct _RPC_DRIVER_INFO_3W __RPC_FAR *LPRPC_DRIVER_INFO_3W;

typedef struct _RPC_DRIVER_INFO_4W
    {
    DWORD cVersion;
    SPL_STRING pName;
    SPL_STRING pEnvironment;
    SPL_STRING pDriverPath;
    SPL_STRING pDataFile;
    SPL_STRING pConfigFile;
    SPL_STRING pHelpFile;
    SPL_STRING pMonitorName;
    SPL_STRING pDefaultDataType;
    DWORD cchDependentFiles;
    /* [unique][size_is] */ WCHAR __RPC_FAR *pDependentFiles;
    DWORD cchPreviousNames;
    /* [unique][size_is] */ WCHAR __RPC_FAR *pszzPreviousNames;
    }	RPC_DRIVER_INFO_4W;

typedef struct _RPC_DRIVER_INFO_4W __RPC_FAR *PRPC_DRIVER_INFO_4W;

typedef struct _RPC_DRIVER_INFO_4W __RPC_FAR *LPRPC_DRIVER_INFO_4W;

typedef struct _RPC_DRIVER_INFO_6W
    {
    DWORD cVersion;
    SPL_STRING pName;
    SPL_STRING pEnvironment;
    SPL_STRING pDriverPath;
    SPL_STRING pDataFile;
    SPL_STRING pConfigFile;
    SPL_STRING pHelpFile;
    SPL_STRING pMonitorName;
    SPL_STRING pDefaultDataType;
    DWORD cchDependentFiles;
    /* [unique][size_is] */ WCHAR __RPC_FAR *pDependentFiles;
    DWORD cchPreviousNames;
    /* [unique][size_is] */ WCHAR __RPC_FAR *pszzPreviousNames;
    FILETIME ftDriverDate;
    DWORDLONG dwlDriverVersion;
    SPL_STRING pMfgName;
    SPL_STRING pOEMUrl;
    SPL_STRING pHardwareID;
    SPL_STRING pProvider;
    }	RPC_DRIVER_INFO_6W;

typedef struct _RPC_DRIVER_INFO_6W __RPC_FAR *PRPC_DRIVER_INFO_6W;

typedef struct _RPC_DRIVER_INFO_6W __RPC_FAR *LPRPC_DRIVER_INFO_6W;

typedef struct _DRIVER_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPDRIVER_INFO_1W Level1;
        /* [case()] */ LPDRIVER_INFO_2W Level2;
        /* [case()] */ LPRPC_DRIVER_INFO_3W Level3;
        /* [case()] */ LPRPC_DRIVER_INFO_4W Level4;
        /* [case()] */ LPRPC_DRIVER_INFO_6W Level6;
        }	DriverInfo;
    }	DRIVER_CONTAINER;

typedef struct _DRIVER_CONTAINER __RPC_FAR *PDRIVER_CONTAINER;

typedef struct _DRIVER_CONTAINER __RPC_FAR *LPDRIVER_CONTAINER;

typedef struct _DOC_INFO_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPDOC_INFO_1W pDocInfo1;
        }	DocInfo;
    }	DOC_INFO_CONTAINER;

typedef struct _DOC_INFO_CONTAINER __RPC_FAR *PDOC_INFO_CONTAINER;

typedef struct _DOC_INFO_CONTAINER __RPC_FAR *LPDOC_INFO_CONTAINER;

typedef struct _FORM_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPFORM_INFO_1W pFormInfo1;
        }	FormInfo;
    }	FORM_CONTAINER;

typedef struct _FORM_CONTAINER __RPC_FAR *PFORM_CONTAINER;

typedef struct _FORM_CONTAINER __RPC_FAR *LPFORM_CONTAINER;

typedef struct _MONITOR_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPMONITOR_INFO_1W pMonitorInfo1;
        /* [case()] */ LPMONITOR_INFO_2W pMonitorInfo2;
        }	MonitorInfo;
    }	MONITOR_CONTAINER;

typedef struct _MONITOR_CONTAINER __RPC_FAR *PMONITOR_CONTAINER;

typedef struct _MONITOR_CONTAINER __RPC_FAR *LPMONITOR_CONTAINER;

typedef struct _RPC_PROVIDOR_INFO_2W
    {
    DWORD cchOrder;
    /* [unique][size_is] */ WCHAR __RPC_FAR *pOrder;
    }	RPC_PROVIDOR_INFO_2W;

typedef struct _RPC_PROVIDOR_INFO_2W __RPC_FAR *PRPC_PROVIDOR_INFO_2W;

typedef struct _RPC_PROVIDOR_INFO_2W __RPC_FAR *LPRPC_PROVIDOR_INFO_2W;

typedef struct _PROVIDOR_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPPROVIDOR_INFO_1W pProvidorInfo1;
        /* [case()] */ LPRPC_PROVIDOR_INFO_2W pRpcProvidorInfo2;
        }	ProvidorInfo;
    }	PROVIDOR_CONTAINER;

typedef struct _PROVIDOR_CONTAINER __RPC_FAR *PPROVIDOR_CONTAINER;

typedef struct _PROVIDOR_CONTAINER __RPC_FAR *LPPROVIDOR_CONTAINER;

typedef struct _SPLCLIENT_CONTAINER
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()] */ LPSPLCLIENT_INFO_1 pClientInfo1;
        /* [case()] */ LPSPLCLIENT_INFO_2 pClientInfo2;
        }	ClientInfo;
    }	SPLCLIENT_CONTAINER;

typedef struct _SPLCLIENT_CONTAINER __RPC_FAR *PSPLCLIENT_CONTAINER;

typedef struct _SPLCLIENT_CONTAINER __RPC_FAR *LPSPLCLIENT_CONTAINER;

typedef struct _STRING_CONTAINER
    {
    DWORD cbBuf;
    /* [unique][size_is] */ LPWSTR pszString;
    }	STRING_CONTAINER;

typedef struct _STRING_CONTAINER __RPC_FAR *PSTRING_CONTAINER;

typedef struct _SYSTEMTIME_CONTAINER
    {
    DWORD cbBuf;
    PSYSTEMTIME pSystemTime;
    }	SYSTEMTIME_CONTAINER;

typedef struct _SYSTEMTIME_CONTAINER __RPC_FAR *PSYSTEMTIME_CONTAINER;

typedef struct _RPC_V2_NOTIFY_OPTIONS_TYPE
    {
    WORD Type;
    WORD Reserved0;
    DWORD Reserved1;
    DWORD Reserved2;
    DWORD Count;
    /* [unique][size_is] */ PWORD pFields;
    }	RPC_V2_NOTIFY_OPTIONS_TYPE;

typedef struct _RPC_V2_NOTIFY_OPTIONS_TYPE __RPC_FAR *PRPC_V2_NOTIFY_OPTIONS_TYPE;

typedef struct _RPC_V2_NOTIFY_OPTIONS
    {
    DWORD Version;
    DWORD Reserved;
    DWORD Count;
    /* [unique][size_is] */ PRPC_V2_NOTIFY_OPTIONS_TYPE pTypes;
    }	RPC_V2_NOTIFY_OPTIONS;

typedef struct _RPC_V2_NOTIFY_OPTIONS __RPC_FAR *PRPC_V2_NOTIFY_OPTIONS;

typedef /* [switch_type] */ union _RPC_V2_NOTIFY_INFO_DATA_DATA
    {
    /* [case()] */ STRING_CONTAINER String;
    /* [case()] */ DWORD dwData[ 2 ];
    /* [case()] */ SYSTEMTIME_CONTAINER SystemTime;
    /* [case()] */ DEVMODE_CONTAINER DevMode;
    /* [case()] */ SECURITY_CONTAINER SecurityDescriptor;
    }	RPC_V2_NOTIFY_INFO_DATA_DATA;

typedef /* [switch_type] */ union _RPC_V2_NOTIFY_INFO_DATA_DATA __RPC_FAR *PRPC_V2_NOTIFY_INFO_DATA_DATA;

typedef struct _RPC_V2_NOTIFY_INFO_DATA
    {
    WORD Type;
    WORD Field;
    DWORD Reserved;
    DWORD Id;
    /* [switch_is] */ RPC_V2_NOTIFY_INFO_DATA_DATA Data;
    }	RPC_V2_NOTIFY_INFO_DATA;

typedef struct _RPC_V2_NOTIFY_INFO_DATA __RPC_FAR *PRPC_V2_NOTIFY_INFO_DATA;

typedef struct _RPC_V2_NOTIFY_INFO
    {
    DWORD Version;
    DWORD Flags;
    DWORD Count;
    /* [unique][size_is] */ RPC_V2_NOTIFY_INFO_DATA aData[ 1 ];
    }	RPC_V2_NOTIFY_INFO;

typedef struct _RPC_V2_NOTIFY_INFO __RPC_FAR *PRPC_V2_NOTIFY_INFO;

typedef /* [switch_type] */ union _RPC_V2_UREPLY_PRINTER
    {
    /* [case()] */ PRPC_V2_NOTIFY_INFO pInfo;
    }	RPC_V2_UREPLY_PRINTER;

typedef /* [switch_type] */ union _RPC_V2_UREPLY_PRINTER __RPC_FAR *PRPC_V2_UREPLY_PRINTER;

DWORD RpcEnumPrinters( 
    /* [in] */ DWORD Flags,
    /* [unique][string][in] */ STRING_HANDLE Name,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pPrinterEnum,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcOpenPrinter( 
    /* [unique][string][in] */ STRING_HANDLE pPrinterName,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *pHandle,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pDatatype,
    /* [in] */ LPDEVMODE_CONTAINER pDevMode,
    /* [in] */ DWORD AccessRequired);

DWORD RpcSetJob( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD JobId,
    /* [unique][in] */ LPJOB_CONTAINER pJobContainer,
    /* [in] */ DWORD Command);

DWORD RpcGetJob( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD JobId,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pJob,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcEnumJobs( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD FirstJob,
    /* [in] */ DWORD NoJobs,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pJob,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcAddPrinter( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ PPRINTER_CONTAINER pPrinterContainer,
    /* [in] */ PDEVMODE_CONTAINER pDevModeContainer,
    /* [in] */ PSECURITY_CONTAINER pSecurityContainer,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *pHandle);

DWORD RpcDeletePrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcSetPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ PPRINTER_CONTAINER pPrinterContainer,
    /* [in] */ PDEVMODE_CONTAINER pDevModeContainer,
    /* [in] */ PSECURITY_CONTAINER pSecurityContainer,
    /* [in] */ DWORD Command);

DWORD RpcGetPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pPrinter,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcAddPrinterDriver( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ PDRIVER_CONTAINER pDriverContainer);

DWORD RpcEnumPrinterDrivers( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pDrivers,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcGetPrinterDriver( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pDriver,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcGetPrinterDriverDirectory( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pDriverDirectory,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcDeletePrinterDriver( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [string][in] */ wchar_t __RPC_FAR *pDriverName);

DWORD RpcAddPrintProcessor( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [string][in] */ wchar_t __RPC_FAR *pPathName,
    /* [string][in] */ wchar_t __RPC_FAR *pPrintProcessorName);

DWORD RpcEnumPrintProcessors( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pPrintProcessorInfo,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcGetPrintProcessorDirectory( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pPrintProcessorDirectory,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcStartDocPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ PDOC_INFO_CONTAINER pDocInfoContainer,
    /* [out] */ LPDWORD pJobId);

DWORD RpcStartPagePrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcWritePrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [size_is][in] */ LPBYTE pBuf,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcWritten);

DWORD RpcEndPagePrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcAbortPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcReadPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [size_is][out] */ LPBYTE pBuf,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcNoBytesRead);

DWORD RpcEndDocPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcAddJob( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pAddJob,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcScheduleJob( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD JobId);

DWORD RpcGetPrinterData( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ wchar_t __RPC_FAR *pValueName,
    /* [out] */ LPDWORD pType,
    /* [size_is][out] */ LPBYTE pData,
    /* [in] */ DWORD nSize,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcSetPrinterData( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ wchar_t __RPC_FAR *pValueName,
    /* [in] */ DWORD Type,
    /* [size_is][in] */ LPBYTE pData,
    /* [in] */ DWORD cbData);

DWORD RpcWaitForPrinterChange( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD Flags,
    /* [out] */ LPDWORD pFlags);

DWORD RpcClosePrinter( 
    /* [out][in] */ PRINTER_HANDLE __RPC_FAR *phPrinter);

DWORD RpcAddForm( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ PFORM_CONTAINER pFormInfoContainer);

DWORD RpcDeleteForm( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ wchar_t __RPC_FAR *pFormName);

DWORD RpcGetForm( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ wchar_t __RPC_FAR *pFormName,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pForm,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcSetForm( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ wchar_t __RPC_FAR *pFormName,
    /* [in] */ PFORM_CONTAINER pFormInfoContainer);

DWORD RpcEnumForms( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pForm,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcEnumPorts( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pPort,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcEnumMonitors( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pMonitor,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcAddPort( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ DWORD hWnd,
    /* [string][in] */ wchar_t __RPC_FAR *pMonitorName);

DWORD RpcConfigurePort( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ DWORD hWnd,
    /* [string][in] */ wchar_t __RPC_FAR *pPortName);

DWORD RpcDeletePort( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ DWORD hWnd,
    /* [string][in] */ wchar_t __RPC_FAR *pPortName);

DWORD RpcCreatePrinterIC( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [out] */ GDI_HANDLE __RPC_FAR *pHandle,
    /* [in] */ LPDEVMODE_CONTAINER pDevModeContainer);

DWORD RpcPlayGdiScriptOnPrinterIC( 
    /* [in] */ GDI_HANDLE hPrinterIC,
    /* [size_is][in] */ LPBYTE pIn,
    /* [in] */ DWORD cIn,
    /* [size_is][out] */ LPBYTE pOut,
    /* [in] */ DWORD cOut,
    /* [in] */ DWORD ul);

DWORD RpcDeletePrinterIC( 
    /* [out][in] */ GDI_HANDLE __RPC_FAR *phPrinterIC);

DWORD RpcAddPrinterConnection( 
    /* [string][in] */ STRING_HANDLE pName);

DWORD RpcDeletePrinterConnection( 
    /* [string][in] */ STRING_HANDLE pName);

DWORD RpcPrinterMessageBox( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD Error,
    /* [in] */ DWORD hWnd,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pText,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pCaption,
    /* [in] */ DWORD dwType);

DWORD RpcAddMonitor( 
    /* [unique][string][in] */ STRING_HANDLE Name,
    /* [in] */ PMONITOR_CONTAINER pMonitorContainer);

DWORD RpcDeleteMonitor( 
    /* [unique][string][in] */ STRING_HANDLE Name,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [string][in] */ wchar_t __RPC_FAR *pMonitorName);

DWORD RpcDeletePrintProcessor( 
    /* [unique][string][in] */ STRING_HANDLE Name,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [string][in] */ wchar_t __RPC_FAR *pPrintProcessorName);

DWORD RpcAddPrintProvidor( 
    /* [unique][string][in] */ STRING_HANDLE Name,
    /* [in] */ PPROVIDOR_CONTAINER pProvidorContainer);

DWORD RpcDeletePrintProvidor( 
    /* [unique][string][in] */ STRING_HANDLE Name,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [string][in] */ wchar_t __RPC_FAR *pPrintProvidorName);

DWORD RpcEnumPrintProcessorDatatypes( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pPrintProcessorName,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pDatatypes,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcResetPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pDatatype,
    /* [in] */ LPDEVMODE_CONTAINER pDevMode);

DWORD RpcGetPrinterDriver2( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][unique][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [in] */ DWORD Level,
    /* [size_is][unique][out][in] */ LPBYTE pDriver,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [in] */ DWORD dwClientMajorVersion,
    /* [in] */ DWORD dwClientMinorVersion,
    /* [out] */ LPDWORD pdwServerMaxVersion,
    /* [out] */ LPDWORD pdwServerMinVersion);

DWORD RpcClientFindFirstPrinterChangeNotification( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD fdwFlags,
    /* [in] */ DWORD fdwOptions,
    /* [in] */ DWORD dwPID,
    /* [unique][in] */ PRPC_V2_NOTIFY_OPTIONS pOptions,
    /* [out] */ LPDWORD pdwEvent);

DWORD RpcFindNextPrinterChangeNotification( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD fdwFlags,
    /* [out] */ LPDWORD pdwChange,
    /* [unique][in] */ PRPC_V2_NOTIFY_OPTIONS pOptions,
    /* [out] */ PRPC_V2_NOTIFY_INFO __RPC_FAR *ppInfo);

DWORD RpcFindClosePrinterChangeNotification( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcRouterFindFirstPrinterChangeNotificationOld( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD fdwFlags,
    /* [in] */ DWORD fdwOptions,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pszLocalMachine,
    /* [in] */ DWORD dwPrinterLocal);

DWORD RpcReplyOpenPrinter( 
    /* [string][in] */ STRING_HANDLE pMachine,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *phPrinterNotify,
    /* [in] */ DWORD dwPrinterRemote,
    /* [in] */ DWORD dwType,
    /* [in] */ DWORD cbBuffer,
    /* [size_is][unique][in] */ LPBYTE pBuffer);

DWORD RpcRouterReplyPrinter( 
    /* [in] */ PRINTER_HANDLE hNotify,
    /* [in] */ DWORD fdwFlags,
    /* [in] */ DWORD cbBuffer,
    /* [size_is][unique][in] */ LPBYTE pBuffer);

DWORD RpcReplyClosePrinter( 
    /* [out][in] */ PRINTER_HANDLE __RPC_FAR *phNotify);

DWORD RpcAddPortEx( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ LPPORT_CONTAINER pPortContainer,
    /* [in] */ LPPORT_VAR_CONTAINER pPortVarContainer,
    /* [string][in] */ wchar_t __RPC_FAR *pMonitorName);

DWORD RpcRemoteFindFirstPrinterChangeNotification( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD fdwFlags,
    /* [in] */ DWORD fdwOptions,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pszLocalMachine,
    /* [in] */ DWORD dwPrinterLocal,
    /* [in] */ DWORD cbBuffer,
    /* [size_is][unique][out][in] */ LPBYTE pBuffer);

DWORD RpcSpoolerInit( 
    /* [in] */ STRING_HANDLE pName);

DWORD RpcResetPrinterEx( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pDatatype,
    /* [in] */ LPDEVMODE_CONTAINER pDevMode,
    /* [in] */ DWORD dwFlags);

DWORD RpcRemoteFindFirstPrinterChangeNotificationEx( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD fdwFlags,
    /* [in] */ DWORD fdwOptions,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pszLocalMachine,
    /* [in] */ DWORD dwPrinterLocal,
    /* [unique][in] */ PRPC_V2_NOTIFY_OPTIONS pOptions);

DWORD RpcRouterReplyPrinterEx( 
    /* [in] */ PRINTER_HANDLE hNotify,
    /* [in] */ DWORD dwColor,
    /* [in] */ DWORD fdwFlags,
    /* [out] */ PDWORD pdwResult,
    /* [in] */ DWORD dwReplyType,
    /* [switch_is][in] */ RPC_V2_UREPLY_PRINTER Reply);

DWORD RpcRouterRefreshPrinterChangeNotification( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD dwColor,
    /* [unique][in] */ PRPC_V2_NOTIFY_OPTIONS pOptions,
    /* [out] */ PRPC_V2_NOTIFY_INFO __RPC_FAR *ppInfo);

DWORD RpcSetAllocFailCount( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD dwFailCount,
    /* [out] */ LPDWORD lpdwAllocCount,
    /* [out] */ LPDWORD lpdwFreeCount,
    /* [out] */ LPDWORD lpdwFailCountHit);

DWORD RpcOpenPrinterEx( 
    /* [unique][string][in] */ STRING_HANDLE pPrinterName,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *pHandle,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pDatatype,
    /* [in] */ LPDEVMODE_CONTAINER pDevMode,
    /* [in] */ DWORD AccessRequired,
    /* [in] */ PSPLCLIENT_CONTAINER pClientInfo);

DWORD RpcAddPrinterEx( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ PPRINTER_CONTAINER pPrinterContainer,
    /* [in] */ PDEVMODE_CONTAINER pDevModeContainer,
    /* [in] */ PSECURITY_CONTAINER pSecurityContainer,
    /* [in] */ PSPLCLIENT_CONTAINER pClientInfo,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *pHandle);

DWORD RpcSetPort( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pPortName,
    /* [in] */ LPPORT_CONTAINER pPortContainer);

DWORD RpcEnumPrinterData( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD dwIndex,
    /* [size_is][out] */ wchar_t __RPC_FAR *pValueName,
    /* [in] */ DWORD cbValueName,
    /* [out] */ LPDWORD pcbValueName,
    /* [out] */ LPDWORD pType,
    /* [size_is][out] */ LPBYTE pData,
    /* [in] */ DWORD cbData,
    /* [out] */ LPDWORD pcbData);

DWORD RpcDeletePrinterData( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ wchar_t __RPC_FAR *pValueName);

DWORD RpcClusterSplOpen( 
    /* [unique][string][in] */ STRING_HANDLE pServerName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pResource,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *pHandle,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pAddress);

DWORD RpcClusterSplClose( 
    /* [out][in] */ PRINTER_HANDLE __RPC_FAR *phPrinter);

DWORD RpcClusterSplIsAlive( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcSetPrinterDataEx( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ const wchar_t __RPC_FAR *pKeyName,
    /* [string][in] */ const wchar_t __RPC_FAR *pValueName,
    /* [in] */ DWORD Type,
    /* [size_is][in] */ LPBYTE pData,
    /* [in] */ DWORD cbData);

DWORD RpcGetPrinterDataEx( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ const wchar_t __RPC_FAR *pKeyName,
    /* [string][in] */ const wchar_t __RPC_FAR *pValueName,
    /* [out] */ LPDWORD pType,
    /* [size_is][out] */ LPBYTE pData,
    /* [in] */ DWORD nSize,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcEnumPrinterDataEx( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ const wchar_t __RPC_FAR *pKeyName,
    /* [size_is][out] */ LPBYTE pEnumValues,
    /* [in] */ DWORD cbEnumValues,
    /* [out] */ LPDWORD pcbEnumValues,
    /* [out] */ LPDWORD pnEnumValues);

DWORD RpcEnumPrinterKey( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ const wchar_t __RPC_FAR *pKeyName,
    /* [size_is][out] */ wchar_t __RPC_FAR *pSubkey,
    /* [in] */ DWORD cbSubkey,
    /* [out] */ LPDWORD pcbSubkey);

DWORD RpcDeletePrinterDataEx( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ const wchar_t __RPC_FAR *pKeyName,
    /* [string][in] */ const wchar_t __RPC_FAR *pValueName);

DWORD RpcDeletePrinterKey( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [string][in] */ const wchar_t __RPC_FAR *pKeyName);

DWORD RpcSeekPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ LARGE_INTEGER liDistanceToMove,
    /* [out] */ PLARGE_INTEGER pliNewPointer,
    /* [in] */ DWORD dwMoveMethod,
    /* [in] */ BOOL bWrite);

DWORD RpcDeletePrinterDriverEx( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [string][in] */ wchar_t __RPC_FAR *pEnvironment,
    /* [string][in] */ wchar_t __RPC_FAR *pDriverName,
    /* [in] */ DWORD dwDeleteFlag,
    /* [in] */ DWORD dwVersionNum);

DWORD RpcAddPerMachineConnection( 
    /* [unique][string][in] */ STRING_HANDLE pServer,
    /* [string][in] */ const wchar_t __RPC_FAR *pPrinterName,
    /* [string][in] */ const wchar_t __RPC_FAR *pPrintServer,
    /* [string][in] */ const wchar_t __RPC_FAR *pProvider);

DWORD RpcDeletePerMachineConnection( 
    /* [unique][string][in] */ STRING_HANDLE pServer,
    /* [string][in] */ const wchar_t __RPC_FAR *pPrinterName);

DWORD RpcEnumPerMachineConnections( 
    /* [unique][string][in] */ STRING_HANDLE pServer,
    /* [size_is][unique][out][in] */ LPBYTE pPrinterEnum,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded,
    /* [out] */ LPDWORD pcReturned);

DWORD RpcXcvData( 
    /* [in] */ PRINTER_HANDLE hXcv,
    /* [string][in] */ const wchar_t __RPC_FAR *pszDataName,
    /* [size_is][in] */ PBYTE pInputData,
    /* [in] */ DWORD cbInputData,
    /* [size_is][out] */ PBYTE pOutputData,
    /* [in] */ DWORD cbOutputData,
    /* [out] */ PDWORD pcbOutputNeeded,
    /* [out][in] */ PDWORD pdwStatus);

DWORD RpcAddPrinterDriverEx( 
    /* [unique][string][in] */ STRING_HANDLE pName,
    /* [in] */ PDRIVER_CONTAINER pDriverContainer,
    /* [in] */ DWORD dwFileCopyFlags);

DWORD RpcSplOpenPrinter( 
    /* [unique][string][in] */ STRING_HANDLE pPrinterName,
    /* [out] */ PRINTER_HANDLE __RPC_FAR *pHandle,
    /* [unique][string][in] */ wchar_t __RPC_FAR *pDatatype,
    /* [in] */ LPDEVMODE_CONTAINER pDevMode,
    /* [in] */ DWORD AccessRequired,
    /* [out][in] */ PSPLCLIENT_CONTAINER pSplClientContainer);

DWORD RpcGetSpoolFileInfo( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD dwAppProcessId,
    /* [in] */ DWORD dwLevel,
    /* [size_is][out] */ LPBYTE pSpoolFileInfo,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcCommitSpoolData( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [in] */ DWORD dwAppProcessId,
    /* [in] */ DWORD cbCommit,
    /* [in] */ DWORD dwLevel,
    /* [size_is][out] */ LPBYTE pSpoolFileInfo,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcbNeeded);

DWORD RpcCloseSpoolFileHandle( 
    /* [in] */ PRINTER_HANDLE hPrinter);

DWORD RpcFlushPrinter( 
    /* [in] */ PRINTER_HANDLE hPrinter,
    /* [size_is][in] */ LPBYTE pBuf,
    /* [in] */ DWORD cbBuf,
    /* [out] */ LPDWORD pcWritten,
    /* [in] */ DWORD cSleep);


extern handle_t winspool_bhandle;


extern RPC_IF_HANDLE winspool_ClientIfHandle;
extern RPC_IF_HANDLE winspool_ServerIfHandle;
#endif /* __winspool_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

handle_t __RPC_USER STRING_HANDLE_bind  ( STRING_HANDLE );
void     __RPC_USER STRING_HANDLE_unbind( STRING_HANDLE, handle_t );

void __RPC_USER PRINTER_HANDLE_rundown( PRINTER_HANDLE );
void __RPC_USER GDI_HANDLE_rundown( GDI_HANDLE );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\qfe\inc\xpsp1res.h ===
/*

Copyright (c) 2002  Microsoft Corporation

Module Name:

    xpsp1res.h

Abstract:

    Definitions for Service Pack Resources

Notes:

    1 ) XPSP1 resource DLL will be shared by multiple components, thus component owners have to 
    do their best practices to avoid resource id and name conflicts. 

    To avoid id conflicts, owners should use RESOURCE_ID_BLOCK_SiZE as the base resource id 
    range unit, and define component resource base ID and block numbers for each resource 
    type as appropriate. Before adding resources, owners have to make sure newly defined IDs 
    are not overlapping other components' id ranges

    For resource id name defines, owner should include the component name in name define to
    avoid conflicts. 

    See below for an example of defining string IDs for foo.dll

    #define IDS_BASE_FOO_DLL        1000
    #define IDS_BLOCK_NUM_FOO_DLL   2

    //
    // Foo.dll occupies resource string id range 1000 - 1199 
    //

    #define IDS_XXX_FOO_DLL     1000
    ... 
    #define IDS_YYY_FOO_DLL     1101

    2) Resource IDs only need to be unique within the same resource type, although components 
    usually use unique id for every resource entry, in XPSP1 resource case, we need to maximize 
    the usage efficiency of resource id, so we give each resource type a different header file
    and a full ID range (0 - 65535).


    3) Files under language subfolders are used by MUI and LOC team only.

    4) Localized token files could be out of sync with US tokens and this could cause warnings during the build, 
       component owners can ignore token related warnings.



Revision History:



*/


#ifndef __XPSP1RES_H_
#define __XPSP1RES_H_

#define RESOURCE_ID_BLOCK_SiZE     100



/*

Copyright (c) 2002  Microsoft Corporation

Module Name:

    xpsp1str.h

Abstract:

    Definitions for Service Pack STRING Resources

    Use xpsp1str.h for string resource definitions.
    Use xpsp1dlg.h for dialog resource definitions.
    Use xpsp1ico.h for icon resource definitions.
    Use xpsp1bmp.h for bitmap resource definitions.
    Use xpsp1dta.h for RCDATA definitions.

Revision History:

Notes:


*/

//
// Slayerxp.dll resource strings
//

#define IDD_LAYER_PROPPAGE                                   101
#define IDC_TEXT_INSTRUCTIONS                               1013
#define IDC_USE_LAYER                                       5000
#define IDC_LAYER_NAME                                      1005
#define IDC_256COLORS                                       5001
#define IDC_640X480                                         5002
#define IDC_ENABLE_THEMES                                   5003
#define IDC_LEARN                                           1009
#define IDS_INPUT_SETTINGS_GROUP                            6001
#define IDC_DISABLECICERO                                   1014



//
//  Shell32 resource string ID (2048-2559)
//

#define IDS_SHELL32_PROMFU32_0                              2048
#define IDS_SHELL32_PROMFU32_1                              2049
#define IDS_SHELL32_PROMFU32_2                              2050
#define IDS_SHELL32_PROMFU32_3                              2051
#define IDS_SHELL32_PROMFU32_4                              2052
#define IDS_SHELL32_PROMFU32_5                              2053
#define IDS_SHELL32_PROMFU32_6                              2054
#define IDS_SHELL32_PROMFU32_7                              2055
#define IDS_SHELL32_PROMFU32_8                              2056
#define IDS_SHELL32_PROMFU32_9                              2057
#define IDS_SHELL32_PROMFU32_10                             2058
#define IDS_SHELL32_PROMFU32_11                             2059
#define IDS_SHELL32_PROMFU32_12                             2060
#define IDS_SHELL32_PROMFU32_13                             2061
#define IDS_SHELL32_PROMFU32_14                             2062
#define IDS_SHELL32_PROMFU32_15                             2063

#define IDS_SHELL32_PROMFU64_0                              2064
#define IDS_SHELL32_PROMFU64_1                              2065
#define IDS_SHELL32_PROMFU64_2                              2066
#define IDS_SHELL32_PROMFU64_3                              2067
#define IDS_SHELL32_PROMFU64_4                              2068
#define IDS_SHELL32_PROMFU64_5                              2069
#define IDS_SHELL32_PROMFU64_6                              2070
#define IDS_SHELL32_PROMFU64_7                              2071
#define IDS_SHELL32_PROMFU64_8                              2072
#define IDS_SHELL32_PROMFU64_9                              2073
#define IDS_SHELL32_PROMFU64_10                             2074
#define IDS_SHELL32_PROMFU64_11                             2075
#define IDS_SHELL32_PROMFU64_12                             2076
#define IDS_SHELL32_PROMFU64_13                             2077
#define IDS_SHELL32_PROMFU64_14                             2078
#define IDS_SHELL32_PROMFU64_15                             2079

//
//  INPUT.DLL resource string ID
//
#define IDS_BASE_INPUTDLL                                   10000
#define IDS_BLOCK_NUM_INPUTDLL                                  2

#define IDS_INPUTDLL_ADVANCED_CUAS_TEXT                     10000
#define IDS_INPUTDLL_ADVANCED_CTFMON_TEXT                   10001

//
//  SPTIP.DLL resource string ID
//
#define IDS_BASE_SPTIP                                      10010
#define IDS_BLOCK_NUM_SPTIP                                    13

#define IDS_SPTIP_SHARDCMD_FILE                             10010
#define IDS_SPTIP_GO_TO_SLEEP                               10011
#define IDS_SPTIP_WAKE_UP                                   10012
#define IDS_SPTIP_PROPERTYPAGE_TITLE                        10013
#define IDS_SPTIP_SPCMD_SELECT_ALL                          10014
#define IDS_SPTIP_SPCMD_SELECT_THAT                         10015
#define IDS_SPTIP_REPLAY                                    10016
#define IDS_SPTIP_DELETE                                    10017
#define IDS_SPTIP_REDO                                      10018
#define IDS_SPTIP_ADDTODICTIONARYPREFIX                     10020
#define IDS_SPTIP_ADDTODICTIONARYPOSTFIX                    10021
#define IDS_SPTIP_DELETESELECTION                           10022

//
// Msctfime resource string ID
//
#define IDS_BASE_MSCTFIME                                   10030
#define IDS_BLOCK_NUM_MSCTFIME                                  3

#define IDS_MSCTFIME_ENTER_BTN_TEXT                         10030
#define IDS_MSCTFIME_ENTER_BTN_TOOLTIP                      10031
#define IDS_MSCTFIME_FUNCPRV_CONVERSION                     10032

//
//  APPWIZ.CPL resource string ID
//
#define IDS_BASE_APPWIZ_CPL                                 10040
#define IDS_BLOCK_NUM_APPWIZ_CPL                                4

#define IDS_APPWIZ_PICKAPPS                                 10040
#define IDS_APPWIZ_SHORTCUTPICKAPPS                         10041
#define IDS_APPWIZ_PICKINTRO                                10042
#define IDS_APPWIZ_PICKOK                                   10043
#define IDS_APPWIZ_PICKCANCEL                               10044
#define IDS_APPWIZ_APPLYINGCLIENT                           10045
#define IDS_APPWIZ_SHOWINGICONS                             10046
#define IDS_APPWIZ_HIDINGICONS                              10047
#define IDS_APPWIZ_SETTINGDEFAULT                           10048
#define IDS_APPWIZ_GROUPOEM                                 10049
#define IDS_APPWIZ_GROUPOEMBLURB                            10050
#define IDS_APPWIZ_GROUPMS                                  10051
#define IDS_APPWIZ_GROUPMSBLURB                             10052
#define IDS_APPWIZ_GROUPNONMS                               10053
#define IDS_APPWIZ_GROUPNONMSBLURB                          10054
#define IDS_APPWIZ_GROUPCUSTOM                              10055
#define IDS_APPWIZ_GROUPCUSTOMBLURB                         10056
#define IDS_APPWIZ_CLIENTWEB                                10057
#define IDS_APPWIZ_KEEPWEB                                  10058
#define IDS_APPWIZ_PICKWEB                                  10059
#define IDS_APPWIZ_CLIENTMAIL                               10060
#define IDS_APPWIZ_KEEPMAIL                                 10061
#define IDS_APPWIZ_PICKMAIL                                 10062
#define IDS_APPWIZ_CLIENTMEDIA                              10063
#define IDS_APPWIZ_KEEPMEDIA                                10064
#define IDS_APPWIZ_PICKMEDIA                                10065
#define IDS_APPWIZ_CLIENTIM                                 10066
#define IDS_APPWIZ_KEEPIM                                   10067
#define IDS_APPWIZ_PICKIM                                   10068
#define IDS_APPWIZ_CLIENTJAVAVM                             10069
#define IDS_APPWIZ_KEEPJAVAVM                               10070
#define IDS_APPWIZ_PICKJAVAVM                               10071
#define IDS_APPWIZ_SHOWAPP                                  10072
#define IDS_APPWIZ_ALSOSHOW                                 10073
#define IDS_APPWIZ_HIDE                                     10074
#define IDS_APPWIZ_ADDITIONALCLIENTFORMAT                   10075
#define IDS_APPWIZ_NOTADMIN                                 10076
#define IDS_APPWIZ_CONFIGUREPROGRAMS                        10077
#define IDS_APPWIZ_CONFIGUREPROGRAMSTIP                     10078
#define IDS_APPWIZ_CUSTOMWEB                                10079
#define IDS_APPWIZ_CUSTOMMAIL                               10080
#define IDS_APPWIZ_CUSTOMMEDIA                              10081
#define IDS_APPWIZ_CUSTOMIM                                 10082
#define IDS_APPWIZ_CUSTOMJAVAVM                             10083
#define IDS_APPWIZ_KEEPMSMAIL                               10084

#define IDS_OC_QLAUNCHAPPDATAPATH                           11000
#define IDS_OC_IESHORTCUTNAME_SM                            11001
#define IDS_OC_IEDESCRIPTION                                11002
#define IDS_OC_IESHORTCUTNAME_QL                            11003
#define IDS_OC_OESHORTCUTNAME_SM                            11004
#define IDS_OC_OEDESCRIPTION                                11005
#define IDS_OC_OESHORTCUTNAME_QL                            11006
#define IDS_OC_IESHORTCUTNAME_SM64                          11007

// string IDs for the Wireless UI
#define SID_AcquiringIdentity       6
#define SID_ContactingServer        7
#define SID_UserResponse            8
#define SID_NoSmartCardReaderFound  9
#define IDS_WZCERR_INVALID_WEPK         5002
#define IDS_WZCERR_MISMATCHED_WEPK      5003
#define IDS_CANTACCESSNET_INFRA         5004
#define IDS_CANTACCESSNET_ADHOC         5005
#define IDS_LANUI_ERROR_CAPTION         16008
#define IDS_WZC_DLG_CAPTION             16117
#define IDS_WZC_DLG_CAP_SUFFIX          16118
#define IDS_WZC_KERR_MAT                16119
#define IDS_WZC_KERR_IDX                16121
#define IDS_WZC_PARTIAL_APPLY           16130
#define IDS_EAPOL_PARTIAL_APPLY         16131
#define IDS_EAPOL_PAGE_LABEL            16133



//
// STRING RESOURCES FOR RASCHAP.DLL DCR: 570832
//

#define IDS_BASE_RASCHAP                                    15050
#define IDS_BLOCK_NUM_RASCHAP                                   5


#define IDS_NO_ROUTER_CONFIG                                15051
#define IDS_MESSAGE_HEADER                                  15052
#define IDS_PASSWORD_REQUIRED                               15054
#define IDS_PASSWORD_MISMATCH                               15055


//
// STRING RESOURCES FOR RASTLS.DLL DCR: 570832
//

#define IDS_BASE_RASTLS                                     15600
#define IDS_BLOCK_NUM_RASTLS                                    8


#define IDS_VALIDATE_SERVER_TEXT                            15600
#define IDS_VALIDATE_NAME_TEXT                              15601
#define IDS_VALIDATE_SERVER_WITH_NAME_TEXT                  15602
#define IDS_NO_SERVER_NAME                                  15603
#define IDS_NO_ROOT_CERT                                    15604
#define IDS_NO_CERT_DETAILS                                 15605
#define IDS_PEAP_NO_EAP_TYPE                                15606
#define IDS_PEAP_WIRELESS                                   15607

//
// STRING RESOURCES FOR PRINTUI.DLL DCR: 565316
//
#define IDS_BASE_PRINTUI_DLL                                16400
#define IDS_BLOCK_NUM_PRINTUI_DLL                           1

#define IDS_TEXT_POINTANDPRINT_WARNING_PRINTUI_DLL          (IDS_BASE_PRINTUI_DLL + 0)
#define IDS_TEXT_POINTANDPRINT_POLICY_PRINTUI_DLL           (IDS_BASE_PRINTUI_DLL + 1)

//
// string id for storprop.dll
//
#define IDS_BASE_STORPROP_DLL                                3000
#define IDS_BLOCK_NUM_STORPROP_DLL                              1

#define IDS_UDMA_MODE6_STRING                                3011
//
// STRING RESOURCES FOR TELNET
//
#define IDS_BASE_TELNET		20000
#define IDS_BLOCK_NUM_TELNET	50

#define IDR_NEW_TELNET_USAGE	20001

//
//String Resouces for Rshx32
//
#define IDS_BASE_RSHX32		20100
#define IDS_RSHX32_SET_PERMS_ON_NETWORK_DRIVE 	(IDS_BASE_RSHX32 + 0)
#define IDS_RSHX32_SET_SACLS_ON_NETWORK_DRIVE 	(IDS_BASE_RSHX32 + 1) 
#define IDS_RSHX32_PROP_PAGE_TITLE 	        (IDS_BASE_RSHX32 + 2) 

//
// String Resources for SAVEDUMP
//

#define IDS_SAVEDUMP_BASE	    20200
#define IDS_SAVEDUMP_HEADER_MSG     (IDS_SAVEDUMP_BASE + 0)

////////////////////////////////////////////
//
// SCHTASKS.EXE related RC Messages
//
////////////////////////////////////////////
#define IDS_UPPER_YES                  300001
#define IDS_UPPER_NO                   300002



/*

Copyright (c) 2002  Microsoft Corporation

Module Name:

    xpsp1dlg.h

Abstract:

    Definitions for Service Pack DIALOG Resources
    
    Use xpsp1str.h for string resource definitions.
    Use xpsp1dlg.h for dialog resource definitions.
    Use xpsp1ico.h for icon resource definitions.
    Use xpsp1bmp.h for bitmap resource definitions.
    Use xpsp1dta.h for RCDATA definitions.

Revision History:

Notes:


*/

#ifndef IDC_STATIC
#define IDC_STATIC                      (-1)
#endif

//
//  SHDOCLC.DLL - SafeOpen Dialog
//
#define DLG_SAFEOPEN_SHDOCLC            0x1140
#define IDC_SAFEOPEN_ICON_SHDOCLC       0x1141
#define IDC_SAFEOPEN_FILENAME_SHDOCLC   0x1142
#define IDC_SAFEOPEN_AUTOOPEN_SHDOCLC   0x1143
#define IDC_SAFEOPEN_AUTOSAVE_SHDOCLC   0x1144
#define IDC_SAFEOPEN_ALWAYS_SHDOCLC     0x1145
#define IDC_SAFEOPEN_FILETYPE_SHDOCLC   0x1146
#define IDC_SAFEOPEN_FILEFROM_SHDOCLC   0x1147
#define IDC_SAFEOPEN_WARNICON_SHDOCLC   0x1148
#define IDC_SAFEOPEN_WARNTEXT_SHDOCLC   0x1149
#define IDM_MOREINFO_SHDOCLC            30

#define IDD_OPS_CONSENT_SHDOCLC         0x3200
#define IDC_OPS_LIST_SHDOCLC            0x3210
#define IDC_VIEW_CERT_SHDOCLC           0x3211
#define IDC_USAGE_STRING_SHDOCLC        0x3212
#define IDC_SITE_IDENTITY_SHDOCLC       0x3213
#define IDC_SECURITY_ICON_SHDOCLC       0x3214
#define IDC_SECURE_CONNECTION_SHDOCLC   0x3216
#define IDC_UNSECURE_CONNECTION_SHDOCLC 0x3217
#define IDC_EDIT_PROFILE_SHDOCLC        0x3219
#define IDC_OPS_INFO_REQUESTED_SHDOCLC  0x321B
#define IDC_OPS_PRIVACY_SHDOCLC         0x321C


//
// SHELL32.dLL - About Dialog
//
// NOTE: for app compat these should match exactly the resids in shell32.dll
//
#define DLG_ABOUT_SHELL32_DLL           0x3810
#define IDD_ICON_SHELL32_DLL            0x3009
#define IDD_APPNAME_SHELL32_DLL         0x3500
#define IDD_VERSION_SHELL32_DLL         0x350b
#define IDD_COPYRIGHTSTRING_SHELL32_DLL 0x350a
#define IDD_OTHERSTUFF_SHELL32_DLL      0x350d
#define IDD_EULA_SHELL32_DLL            0x3512
#define IDD_USERNAME_SHELL32_DLL        0x3507
#define IDD_COMPANYNAME_SHELL32_DLL     0x3508
#define IDD_LINE_1_SHELL32_DLL          0x3327
#define IDD_CONVTITLE_SHELL32_DLL       0x3502
#define IDD_CONVENTIONAL_SHELL32_DLL    0x3503

//
//  INPUT.DLL - Advanced PropertyPage, Toolbar Settings
//
#define DLG_BASE_INPUTDLL                                   10100
#define DLG_BLOCK_NUM_INPUTDLL                                 13

#define DLG_INPUTDLL_INPUT_ADVANCED                         10100
#define DLG_INPUTDLL_TOOLBAR_SETTING                        10101
#define IDC_INPUTDLL_TB_STATIC                              10102
#define IDC_INPUTDLL_TB_SHOWLANGBAR                         10103
#define IDC_INPUTDLL_TB_HIGHTRANS                           10104
#define IDC_INPUTDLL_TB_EXTRAICON                           10105
#define IDC_INPUTDLL_TB_TEXTLABELS                          10106
#define IDC_INPUTDLL_ADVANCED_CUAS_ENABLE                   10107
#define IDC_INPUTDLL_ADVANCED_CUAS_TEXT                     10108
#define IDC_INPUTDLL_ADVANCED_CTFMON_DISABLE                10109
#define IDC_INPUTDLL_ADVANCED_CTFMON_TEXT                   10110
#define IDC_INPUTDLL_GROUPBOX1                              10111
#define IDC_INPUTDLL_GROUPBOX2                              10112

//
//  SPTIP.DLL - Speech PropertyPage
//
#define DLG_BASE_SPTIP                                      10120
#define DLG_BLOCK_NUM_SPTIP                                    31

#define IDD_SPTIP_PROPERTY_PAGE                             10120
#define IDD_SPTIP_PP_DIALOG_ADVANCE                         10121
#define IDD_SPTIP_PP_DIALOG_BUTTON_SET                      10122
#define IDC_SPTIP_PP_SHOW_BALLOON                           10123
#define IDC_SPTIP_PP_LMA                                    10124
#define IDC_SPTIP_PP_HIGH_CONFIDENCE                        10125
#define IDC_SPTIP_PP_SAVE_SPDATA                            10126
#define IDC_SPTIP_PP_REMOVE_SPACE                           10127
#define IDC_SPTIP_PP_DIS_DICT_TYPING                        10128
#define IDC_SPTIP_PP_PLAYBACK                               10129
#define IDC_SPTIP_PP_DICT_CANDUI_OPEN                       10130
#define IDC_SPTIP_PP_DICTCMDS                               10131
#define IDC_SPTIP_PP_ASSIGN_BUTTON                          10132
#define IDC_SPTIP_PP_BUTTON_MB_SETTING                      10133
#define IDC_SPTIP_PP_BUTTON_ADVANCE                         10134
#define IDC_SPTIP_PP_BUTTON_LANGBAR                         10135
#define IDC_SPTIP_PP_BUTTON_SPCPL                           10136
#define IDC_SPTIP_PP_SELECTION_CMD                          10137
#define IDC_SPTIP_PP_NAVIGATION_CMD                         10138
#define IDC_SPTIP_PP_CASING_CMD                             10139
#define IDC_SPTIP_PP_EDITING_CMD                            10140
#define IDC_SPTIP_PP_KEYBOARD_CMD                           10141
#define IDC_SPTIP_PP_LANGBAR_CMD                            10142
#define IDC_SPTIP_PP_DICTATION_CMB                          10143
#define IDC_SPTIP_PP_COMMAND_CMB                            10144
#define IDC_SPTIP_GP_VOICE_COMMANDS                         10145
#define IDC_SPTIP_GP_MODE_BUTTONS                           10146
#define IDC_SPTIP_GP_ADVANCE_SET                            10147
#define IDC_SPTIP_DESCRIPT_TEXT                             10148
#define IDC_SPTIP_DESCRIPT_TEXT2                            10149
#define IDC_SPTIP_DESCRIPT_TEXT3                            10150

//
// MSOERES.DLL - read options dlg ids
//
#define DLG_MSOERES_Opt_Read                        50
#define IDC_MSOERES_Static1                         3500
#define IDC_MSOERES_Static2                         3501
#define IDC_MSOERES_Static3                         3502
#define IDC_MSOERES_Static4                         3503
#define IDC_MSOERES_Static5                         3504
#define IDC_MSOERES_Static6                         3506
#define IDC_MSOERES_Static7                         3507
#define IDC_MSOERES_Static8                         3508
#define IDC_MSOERES_Static9                         3509
#define IDC_MSOERES_READ_ICON                       2157
#define IDC_MSOERES_READ_NEWS_ICON                  2158
#define IDC_MSOERES_PREVIEW_CHECK                   1001
#define IDC_MSOERES_MARKASREAD_EDIT                 1030
#define IDC_MSOERES_MARKASREAD_SPIN                 1031
#define IDC_MSOERES_AutoExpand                      2008
#define IDC_MSOERES_AutoFillPreview                 2051
#define IDC_MSOERES_READ_IN_TEXT_ONLY               2222
#define IDC_MSOERES_Tooltips                        2135
#define IDC_MSOERES_WATCHED_COLOR                   2202
#define IDC_MSOERES_DownloadChunks                  2030
#define IDC_MSOERES_NumSubj                         2005
#define IDC_MSOERES_SpinNumSubj                     2006
#define IDC_MSOERES_MarkAllRead                     2009
#define IDC_MSOERES_FONTS_ICON                      2159
#define IDC_MSOERES_FONTSETTINGS                    1060
#define IDC_MSOERES_IntlButton                      2099

// dialog IDs for the Wireless UI
#define IDD_WZCQCFG                     2001
#define IDC_WZCQCFG_LBL_INFO            2002
#define IDC_WZCQCFG_LBL_NETWORKS        2003
#define IDC_WZCQCFG_NETWORKS            2004
#define IDC_WZCQCFG_LBL_WKINFO          2005
#define IDC_WZCQCFG_LBL_WEPK            2006
#define IDC_WZCQCFG_WEPK                2007
#define IDC_WZCQCFG_LBL_NOTWORKING      2008
#define IDC_WZCQCFG_ADVANCED            2009
#define IDC_WZCQCFG_CONNECT             2010
#define IDC_WZCQCFG_LBL_WEPK2           2011
#define IDC_WZCQCFG_WEPK2               2012
#define IDC_WZCQCFG_LBL_NOWKINFO        2013
#define IDC_WZCQCFG_CHK_NOWK            2014
#define IDC_WZCQCFG_ICO_WARN            2015
#define IDC_WZCQCFG_CHK_ONEX            2016
#define IDC_ADHOC                       1005
#define IDC_USEPW                       1008
#define IDC_USEHARDWAREPW               1009
#define IDC_SHAREDMODE                  1010
#define IDC_TXT_EAP_TYPE                15033
#define CID_CA_RB_MachineAuth           15034
#define CID_CA_RB_GuestAuth             15035
#define CID_CA_RB_Eap                   15036
#define CID_CA_LB_EapPackages           15037
#define CID_CA_PB_Properties            15038
#define IDC_WZC_DLG_PROPS               15039
#define IDC_WZC_EDIT_SSID               15041
#define IDC_WZC_LBL_KMat                15051
#define IDC_WZC_EDIT_KMat               15052
#define IDC_WZC_LBL_KMat2               15049
#define IDC_WZC_EDIT_KMat2              15050
#define IDC_WZC_LBL_KIdx                15053
#define IDC_WZC_EDIT_KIdx               15054
#define IDC_WZC_GRP_Wep                 15057
#define IDC_EAP_ICO_WARN                15070
#define IDC_TXT_EAP_LABEL               15071
#define IDC_EAP_LBL_WARN                15072
#define IDD_LAN_SECURITY                16007


//
// DIALOG RESOURCES FOR RASCHAP.DLL DCR: 570832
//

#define DLG_BASE_RASCHAP                                    15000
#define DLG_BLOCK_NUM_RASCHAP                                  32

#define IDD_DIALOG_LOGON                                    15000
#define IDD_DIALOG_CLEINT_CONFIG                            15001
#define IDD_DIALOG_CLIENT_CONFIG                            15002
#define IDD_DIALOG_SERVER_CONFIG                            15003
#define IDD_DIALOG_CHANGE_PASSWORD                          15004
#define IDD_DIALOG_RETRY_LOGON                              15005
#define IDC_EDIT_USERNAME                                   15006
#define IDC_EDIT_PASSWORD                                   15007
#define IDC_EDIT_DOMAIN                                     15008
#define IDC_CHK_USE_WINLOGON                                15009
#define IDC_EDIT_RETRIES                                    15010
#define IDC_CHECK_ALLOW_CHANGEPWD                           15012
#define IDC_CHECK2                                          15013
#define IDC_CHECK_PROMPT_IF_INVALID_PASSWORD                15014
#define CID_CP_EB_ConfirmPassword                           15015
#define IDC_CONFIRM_NEW_PASSWORD                            15016
#define CID_CP_EB_OldPassword                               15017
#define CID_CP_EB_Password                                  15018
#define IDC_NEW_PASSWORD                                    15019
#define CID_CP_ST_ConfirmPassword                           15020
#define CID_CP_ST_Explain                                   15021
#define CID_CP_ST_OldPassword                               15022
#define CID_CP_ST_Password                                  15023
#define IDC_CHECK_SAVE_UID_PWD                              15024
#define IDC_RETRY_DOMAIN                                    15025
#define IDC_RETRY_PASSWORD                                  15026
#define IDC_RETRY_USERNAME                                  15027
#define CID_UA_ST_Domain                                    15028
#define CID_UA_ST_Explain                                   15029
#define CID_UA_ST_Password                                  15030
#define CID_UA_ST_Separator                                 15031
#define CID_UA_ST_UserName                                  15032



//
// DIALOG RESOURCES FOR RASTLS.DLL DCR: 570832
//

#define DLG_BASE_RASTLS                                     15500
#define DLG_BLOCK_NUM_RASTLS                                   45


#define IDD_DIALOG_DEFAULT_CREDENTIALS                      15500
#define IDD_VALIDATE_SERVER                                 15501
#define IDD_SCARD_STATUS                                    15502
#define IDD_CONFIG_UI                                       15503
#define IDD_IDENTITY_UI                                     15504
#define IDD_PEAP_CONFIG_UI                                  15505
#define IDC_EDIT_DIFF_USER                                  1409
#define IDC_LIST_ROOT_CA_NAME                               15507
#define IDC_MESSAGE                                         15510
#define IDC_BTN_VIEW_CERTIFICATE                            15511
#define IDC_STATUS_SCARD                                    15512
#define IDC_BITMAP_SCARD                                    15513
#define IDC_STATUS_CERT                                     15514
#define IDC_LIST_CERTIFICATES                               15515
#define IDC_BUTTON_VIEW_CERTIFICATE                         15516
#define IDC_COMBO_PEAP_TYPE                                 15517
#define IDC_BUTTON_CONFIGURE                                15518
#define IDC_COMBO1                                          15519
#define IDC_COMBO_PEAP_TYPE2                                15520
#define IDC_CHECK_USE_SIMPLE_CERT_SEL                       15521
#define IDC_CHECK_DISABLE_FAST_RECONNECT                    15523
#define IDC_CHECK_ENABLE_FAST_RECONNECT                     15524
#define IDC_RADIO_USE_CARD                                  15525
#define IDC_RADIO_USE_REGISTRY                              15526
#define IDC_CHECK_VALIDATE_CERT                             15527
#define IDC_CHECK_VALIDATE_NAME                             15528
#define IDC_EDIT_SERVER_NAME                                15529
#define IDC_STATIC_ROOT_CA_NAME                             15530
#define IDC_COMBO_ROOT_CA_NAME                              15531
#define IDC_CHECK_DIFF_USER                                 15532
#define IDC_STATIC_USER_NAME                                15533
#define IDC_COMBO_USER_NAME                                 15534
#define IDC_STATIC_FRIENDLY_NAME                            15535
#define IDC_EDIT_FRIENDLY_NAME                              15536
#define IDC_STATIC_ISSUER                                   15537
#define IDC_EDIT_ISSUER                                     15538
#define IDC_STATIC_EXPIRATION                               15539
#define IDC_EDIT_EXPIRATION                                 15540
#define IDC_STATIC_DIFF_USER                                15541
#define IDC_STATIC_PIN                                      1500
#define IDC_COMBO_SERVER_NAME                               15543
#define IDC_STATIC_SERVER_NAME                              15544



/*

Copyright (c) 2002  Microsoft Corporation

Module Name:

    xpsp1ico.h

Abstract:

    Definitions for Service Pack ICON Resources
    
    Use xpsp1str.h for string resource definitions.
    Use xpsp1dlg.h for dialog resource definitions.
    Use xpsp1ico.h for icon resource definitions.
    Use xpsp1bmp.h for bitmap resource definitions.
    Use xpsp1dta.h for RCDATA definitions.

Revision History:

Notes:


*/


//
//  APPWIZ.CPL resource icon ID
//
#define IDI_BASE_APPWIZ_CPL                                   100
#define IDI_BLOCK_NUM_APPWIZ_CPL                                1

#define IDI_APPWIZ_CONFIGUREPROGRAMS                          100

//
// ICON RESOURCES FOR RASTLS.DLL DCR: 570832
//
#define IDI_SCARD                       108

#define IDI_UNLOCK_SHDOCLC              0x31E1



/*

Copyright (c) 2002  Microsoft Corporation

Module Name:

    xpsp1bmp.h

Abstract:

    Definitions for Service Pack BITMAP Resources
    
    Use xpsp1str.h for string resource definitions.
    Use xpsp1dlg.h for dialog resource definitions.
    Use xpsp1ico.h for icon resource definitions.
    Use xpsp1bmp.h for bitmap resource definitions.
    Use xpsp1dta.h for RCDATA definitions.

Revision History:

Notes:


*/

//
// APPWIZ.CPL occupies resource bitmap ID range 100-109
//
#define IDB_BASE_APPWIZ_CPL                                   100
#define IDB_BLOCK_NUM_APPWIZ_CPL                                1

#define IDB_APPWIZ_ARP4                                       100

#define IDB_IEACCESS                                          200
#define IDB_OEACCESS                                          201

//
// RASTLS.DLL/ RASCHAP.DLL resources for 
// For DCR: 570832
//

#define IDB_DIALER_1                    1678



/*

Copyright (c) 2002  Microsoft Corporation

Module Name:

    xpsp1dta.h

Abstract:

    Definitions for Service Pack RCDATA Resources

    Use xpsp1str.h for string resource definitions.
    Use xpsp1dlg.h for dialog resource definitions.
    Use xpsp1ico.h for icon resource definitions.
    Use xpsp1bmp.h for bitmap resource definitions.
    Use xpsp1dta.h for RCDATA definitions.

Revision History:

Notes:


*/

//
//  APPWIZ.CPL resource data ID
//
#define IDR_BASE_APPWIZ_CPL                                   100
#define IDR_BLOCK_NUM_APPWIZ_CPL                                1

#define IDR_APPWIZ_ARP                                        100
#define IDR_APPWIZ_ARPSTYLESTD                                101
#define IDR_APPWIZ_ARPSTYLETHEME                              102




/*

Copyright (c) 2002  Microsoft Corporation

Module Name:

    xpsp1msg.mc

Abstract:

    Definitions for Service Pack Events

Revision History:

Notes:

    The xpsp1msg.h file is generated by the MC tool from the xpsp1msg.mc file.

*/


//
// Net error file for basename ZCDB_LOG_BASE = 3000
//
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: WZCSVC_SERVICE_STARTED
//
// MessageText:
//
//  Wireless Configuration service was started successfully
//
#define WZCSVC_SERVICE_STARTED           0x00000BB9L

//
// MessageId: WZCSVC_SERVICE_FAILED
//
// MessageText:
//
//  Wireless Configuration service failed to start.
//
#define WZCSVC_SERVICE_FAILED            0x00000BBAL

//
// MessageId: WZCSVC_SM_STATE_INIT
//
// MessageText:
//
//  Adding interface %1.
//
#define WZCSVC_SM_STATE_INIT             0x00000BBBL

//
// MessageId: WZCSVC_SM_STATE_HARDRESET
//
// MessageText:
//
//  Hard resetting interface.
//
#define WZCSVC_SM_STATE_HARDRESET        0x00000BBCL

//
// MessageId: WZCSVC_SM_STATE_SOFTRESET
//
// MessageText:
//
//  Initiating scanning for wireless networks.
//
#define WZCSVC_SM_STATE_SOFTRESET        0x00000BBDL

//
// MessageId: WZCSVC_SM_STATE_DELAY_SR
//
// MessageText:
//
//  Driver failed scanning, rescheduling another scan in 5sec.
//
#define WZCSVC_SM_STATE_DELAY_SR         0x00000BBEL

//
// MessageId: WZCSVC_SM_STATE_QUERY
//
// MessageText:
//
//  Scan completed.
//
#define WZCSVC_SM_STATE_QUERY            0x00000BBFL

//
// MessageId: WZCSVC_SM_STATE_QUERY_NOCHANGE
//
// MessageText:
//
//  No configuration change. Still associated to %1.
//
#define WZCSVC_SM_STATE_QUERY_NOCHANGE   0x00000BC0L

//
// MessageId: WZCSVC_SM_STATE_ITERATE
//
// MessageText:
//
//  Plumbing configuration SSID: %1, Network Type: %2!d!.
//
#define WZCSVC_SM_STATE_ITERATE          0x00000BC1L

//
// MessageId: WZCSVC_SM_STATE_ITERATE_NONET
//
// MessageText:
//
//  No configurations left in the selection list.
//
#define WZCSVC_SM_STATE_ITERATE_NONET    0x00000BC2L

//
// MessageId: WZCSVC_SM_STATE_FAILED
//
// MessageText:
//
//  Failed to associated to any wireless network.
//
#define WZCSVC_SM_STATE_FAILED           0x00000BC3L

//
// MessageId: WZCSVC_SM_STATE_CFGREMOVE
//
// MessageText:
//
//  Deleting configuration %1 and moving on.
//
#define WZCSVC_SM_STATE_CFGREMOVE        0x00000BC4L

//
// MessageId: WZCSVC_SM_STATE_CFGPRESERVE
//
// MessageText:
//
//  Skipping configuration %1 for now, attempt authentication later.
//
#define WZCSVC_SM_STATE_CFGPRESERVE      0x00000BC5L

//
// MessageId: WZCSVC_SM_STATE_NOTIFY
//
// MessageText:
//
//  Wireless interface successfully associated to %1 [MAC %2].
//
#define WZCSVC_SM_STATE_NOTIFY           0x00000BC6L

//
// MessageId: WZCSVC_SM_STATE_CFGHDKEY
//
// MessageText:
//
//  Configuration %1 has a default random WEP key. Authentication is disabled. Assuming invalid configuration.
//
#define WZCSVC_SM_STATE_CFGHDKEY         0x00000BC7L

//
// MessageId: WZCSVC_EVENT_ADD
//
// MessageText:
//
//  Received Device Arrival notification for %1.
//
#define WZCSVC_EVENT_ADD                 0x00000BC8L

//
// MessageId: WZCSVC_EVENT_REMOVE
//
// MessageText:
//
//  Received Device Removal notification for %1.
//
#define WZCSVC_EVENT_REMOVE              0x00000BC9L

//
// MessageId: WZCSVC_EVENT_CONNECT
//
// MessageText:
//
//  Received Media Connect notification.
//
#define WZCSVC_EVENT_CONNECT             0x00000BCAL

//
// MessageId: WZCSVC_EVENT_DISCONNECT
//
// MessageText:
//
//  Received Media Disconnect notification.
//
#define WZCSVC_EVENT_DISCONNECT          0x00000BCBL

//
// MessageId: WZCSVC_EVENT_TIMEOUT
//
// MessageText:
//
//  Received Timeout notification.
//
#define WZCSVC_EVENT_TIMEOUT             0x00000BCCL

//
// MessageId: WZCSVC_EVENT_CMDREFRESH
//
// MessageText:
//
//  Processing user command Refresh.
//
#define WZCSVC_EVENT_CMDREFRESH          0x00000BCDL

//
// MessageId: WZCSVC_EVENT_CMDRESET
//
// MessageText:
//
//  Processing user command Reset.
//
#define WZCSVC_EVENT_CMDRESET            0x00000BCEL

//
// MessageId: WZCSVC_EVENT_CMDCFGNEXT
//
// MessageText:
//
//  Processing command Next Configuration.
//
#define WZCSVC_EVENT_CMDCFGNEXT          0x00000BCFL

//
// MessageId: WZCSVC_EVENT_CMDCFGDELETE
//
// MessageText:
//
//  Processing command Remove Configuration.
//
#define WZCSVC_EVENT_CMDCFGDELETE        0x00000BD0L

//
// MessageId: WZCSVC_EVENT_CMDCFGNOOP
//
// MessageText:
//
//  Processing command Update data.
//
#define WZCSVC_EVENT_CMDCFGNOOP          0x00000BD1L

//
// MessageId: WZCSVC_SM_STATE_CFGSKIP
//
// MessageText:
//
//  Deleting configuration %1 and moving on. If no better match is found, the configuration will be revived.
//
#define WZCSVC_SM_STATE_CFGSKIP          0x00000BD2L

//
// MessageId: WZCSVC_USR_CFGCHANGE
//
// MessageText:
//
//  Wireless configuration has been changed via an administrative call.
//
#define WZCSVC_USR_CFGCHANGE             0x00000BD3L

//
// MessageId: WZCSVC_DETAILS_FLAGS
//
// MessageText:
//
//  [Enabled=%1; Fallback=%2; Mode=%3; Volatile=%4; Policy=%5%]%n
//
#define WZCSVC_DETAILS_FLAGS             0x00000BD4L

//
// MessageId: WZCSVC_DETAILS_WCONFIG
//
// MessageText:
//
//  {Ssid=%1; Infrastructure=%2; Privacy=%3; [Volatile=%4%; Policy=%5%]}.%n
//
#define WZCSVC_DETAILS_WCONFIG           0x00000BD5L

//
// MessageId: WZCSVC_ERR_QUERRY_BSSID
//
// MessageText:
//
//  Failed to get the MAC address of the remote endpoint. Error code is %1!d!.
//
#define WZCSVC_ERR_QUERRY_BSSID          0x00000BD6L

//
// MessageId: WZCSVC_ERR_GEN_SESSION_KEYS
//
// MessageText:
//
//  Failed to generate the initial session keys. Error code is %1!d!.
//
#define WZCSVC_ERR_GEN_SESSION_KEYS      0x00000BD7L

//
// MessageId: WZCSVC_BLIST_CHANGED
//
// MessageText:
//
//  The list of blocked networks has changed. It contains now %1!d! network(s).
//
#define WZCSVC_BLIST_CHANGED             0x00000BD8L

//
// MessageId: WZCSVC_ERR_CFG_PLUMB
//
// MessageText:
//
//  Failed to plumb the configuration %1. Error code is %2!d!.
//
#define WZCSVC_ERR_CFG_PLUMB             0x00000BD9L

//
// MessageId: EAPOL_STATE_TRANSITION
//
// MessageText:
//
//  EAPOL State Transition: [%1!ws!] to [%2!ws!]
//
#define EAPOL_STATE_TRANSITION           0x00000BDAL

//
// MessageId: EAPOL_STATE_TIMEOUT
//
// MessageText:
//
//  EAPOL State Timeout: [%1!ws!]
//
#define EAPOL_STATE_TIMEOUT              0x00000BDBL

//
// MessageId: EAPOL_MEDIA_CONNECT
//
// MessageText:
//
//  Processing media connect event for [%1!ws!]
//
#define EAPOL_MEDIA_CONNECT              0x00000BDCL

//
// MessageId: EAPOL_MEDIA_DISCONNECT
//
// MessageText:
//
//  Processing media disconnect event for [%1!ws!]
//
#define EAPOL_MEDIA_DISCONNECT           0x00000BDDL

//
// MessageId: EAPOL_INTERFACE_ADDITION
//
// MessageText:
//
//  Processing interface addition event for [%1!ws!]
//
#define EAPOL_INTERFACE_ADDITION         0x00000BDEL

//
// MessageId: EAPOL_INTERFACE_REMOVAL
//
// MessageText:
//
//  Processing interface removal event for [%1!ws!]
//
#define EAPOL_INTERFACE_REMOVAL          0x00000BDFL

//
// MessageId: EAPOL_NDISUIO_BIND
//
// MessageText:
//
//  Processing adapter bind event for [%1!ws!]
//
#define EAPOL_NDISUIO_BIND               0x00000BE0L

//
// MessageId: EAPOL_NDISUIO_UNBIND
//
// MessageText:
//
//  Processing adapter unbind event for [%1!ws!]
//
#define EAPOL_NDISUIO_UNBIND             0x00000BE1L

//
// MessageId: EAPOL_USER_LOGON
//
// MessageText:
//
//  Processing user logon event for interface [%1!ws!]
//
#define EAPOL_USER_LOGON                 0x00000BE2L

//
// MessageId: EAPOL_USER_LOGOFF
//
// MessageText:
//
//  Processing user logoff event for interface [%1!ws!]
//
#define EAPOL_USER_LOGOFF                0x00000BE3L

//
// MessageId: EAPOL_PARAMS_CHANGE
//
// MessageText:
//
//  Processing 802.1X configuration parameters change event for [%1!ws!]
//
#define EAPOL_PARAMS_CHANGE              0x00000BE4L

//
// MessageId: EAPOL_USER_NO_CERTIFICATE
//
// MessageText:
//
//  Unable to find a valid certificate for 802.1X authentication
//
#define EAPOL_USER_NO_CERTIFICATE        0x00000BE5L

//
// MessageId: EAPOL_ERROR_GET_IDENTITY
//
// MessageText:
//
//  Error in fetching %1!ws! identity 0x%2!0x!
//
#define EAPOL_ERROR_GET_IDENTITY         0x00000BE6L

//
// MessageId: EAPOL_ERROR_AUTH_PROCESSING
//
// MessageText:
//
//  Error in authentication protocol processing 0x%1!0x!
//
#define EAPOL_ERROR_AUTH_PROCESSING      0x00000BE7L

//
// MessageId: EAPOL_PROCESS_PACKET_EAPOL
//
// MessageText:
//
//  Packet %1!ws!: Dest:[%2!ws!] Src:[%3!ws!] EAPOL-Pkt-type:[%4!ws!]
//
#define EAPOL_PROCESS_PACKET_EAPOL       0x00000BE8L

//
// MessageId: EAPOL_PROCESS_PACKET_EAPOL_EAP
//
// MessageText:
//
//  Packet %1!ws!:%n Dest:[%2!ws!]%n Src:[%3!ws!]%n EAPOL-Pkt-type:[%4!ws!]%n Data-length:[%5!ld!]%n EAP-Pkt-type:[%6!ws!]%n EAP-Id:[%7!ld!]%n EAP-Data-Length:[%8!ld!]%n %9!ws!%n
//
#define EAPOL_PROCESS_PACKET_EAPOL_EAP   0x00000BE9L

//
// MessageId: EAPOL_DESKTOP_REQUIRED_IDENTITY
//
// MessageText:
//
//  Interactive desktop required for user credentials selection
//
#define EAPOL_DESKTOP_REQUIRED_IDENTITY  0x00000BEAL

//
// MessageId: EAPOL_DESKTOP_REQUIRED_LOGON
//
// MessageText:
//
//  Interactive desktop required to process logon information
//
#define EAPOL_DESKTOP_REQUIRED_LOGON     0x00000BEBL

//
// MessageId: EAPOL_CANNOT_DESKTOP_MACHINE_AUTH
//
// MessageText:
//
//  Cannot interact with desktop during machine authentication
//
#define EAPOL_CANNOT_DESKTOP_MACHINE_AUTH 0x00000BECL

//
// MessageId: EAPOL_WAITING_FOR_DESKTOP_LOAD
//
// MessageText:
//
//  Waiting for user interactive desktop to be loaded
//
#define EAPOL_WAITING_FOR_DESKTOP_LOAD   0x00000BEDL

//
// MessageId: EAPOL_WAITING_FOR_DESKTOP_IDENTITY
//
// MessageText:
//
//  Waiting for 802.1X user module to fetch user credentials
//
#define EAPOL_WAITING_FOR_DESKTOP_IDENTITY 0x00000BEEL

//
// MessageId: EAPOL_WAITING_FOR_DESKTOP_LOGON
//
// MessageText:
//
//  Waiting for 802.1X user module to process logon information
//
#define EAPOL_WAITING_FOR_DESKTOP_LOGON  0x00000BEFL

//
// MessageId: EAPOL_ERROR_DESKTOP_IDENTITY
//
// MessageText:
//
//  Error in 802.1X user module while fetching user credentials 0x%1!0x!
//
#define EAPOL_ERROR_DESKTOP_IDENTITY     0x00000BF0L

//
// MessageId: EAPOL_ERROR_DESKTOP_LOGON
//
// MessageText:
//
//  Error in 802.1X user module while process logon information 0x%1!0x!
//
#define EAPOL_ERROR_DESKTOP_LOGON        0x00000BF1L

//
// MessageId: EAPOL_PROCESSING_DESKTOP_RESPONSE
//
// MessageText:
//
//  Processing response received from 802.1X user module
//
#define EAPOL_PROCESSING_DESKTOP_RESPONSE 0x00000BF2L

//
// MessageId: EAPOL_STATE_DETAILS
//
// MessageText:
//
//  EAP-Identity:[%1!S!]%n State:[%2!ws!]%n Authentication type:[%3!ws!]%n Authentication mode:[%4!ld!]%n EAP-Type:[%5!ld!]%n Fail count:[%6!ld!]%n
//
#define EAPOL_STATE_DETAILS              0x00000BF3L

//
// MessageId: EAPOL_INVALID_EAPOL_KEY
//
// MessageText:
//
//  Invalid EAPOL-Key message
//
#define EAPOL_INVALID_EAPOL_KEY          0x00000BF4L

//
// MessageId: EAPOL_ERROR_PROCESSING_EAPOL_KEY
//
// MessageText:
//
//  Error processing EAPOL-Key message %1!ld!
//
#define EAPOL_ERROR_PROCESSING_EAPOL_KEY 0x00000BF5L

//
// MessageId: EAPOL_INVALID_EAP_TYPE
//
// MessageText:
//
//  Invalid EAP-type=%1!ld! packet received. Expected EAP-type=%2!ld!
//
#define EAPOL_INVALID_EAP_TYPE           0x00000BF6L

//
// MessageId: EAPOL_NO_CERTIFICATE_USER
//
// MessageText:
//
//  Unable to find a valid user certificate for 802.1X authentication
//
#define EAPOL_NO_CERTIFICATE_USER        0x00000BF7L

//
// MessageId: EAPOL_NO_CERTIFICATE_MACHINE
//
// MessageText:
//
//  Unable to find a valid machine certificate for 802.1X authentication
//
#define EAPOL_NO_CERTIFICATE_MACHINE     0x00000BF8L

//
// MessageId: EAPOL_EAP_AUTHENTICATION_SUCCEEDED
//
// MessageText:
//
//  802.1X client authentication completed successfully with server
//
#define EAPOL_EAP_AUTHENTICATION_SUCCEEDED 0x00000BF9L

//
// MessageId: EAPOL_EAP_AUTHENTICATION_DEFAULT
//
// MessageText:
//
//  No 802.1X authentication performed since there was no response from server for 802.1X packets. Entering AUTHENTICATED state.
//
#define EAPOL_EAP_AUTHENTICATION_DEFAULT 0x00000BFAL

//
// MessageId: EAPOL_EAP_AUTHENTICATION_FAILED
//
// MessageText:
//
//  802.1X client authentication failed. The error code is 0x%1!0x!
//
#define EAPOL_EAP_AUTHENTICATION_FAILED  0x00000BFBL

//
// MessageId: EAPOL_EAP_AUTHENTICATION_FAILED_DEFAULT
//
// MessageText:
//
//  802.1X client authentication failed. Network connectivity issues with authentication server were experienced.
//
#define EAPOL_EAP_AUTHENTICATION_FAILED_DEFAULT 0x00000BFCL

//
// MessageId: EAPOL_CERTIFICATE_DETAILS
//
// MessageText:
//
//  A %1!ws! certificate was used for 802.1X authentication%n
//  
//  Version: %2!ws!%n
//  Serial Number: %3!ws!%n
//  Issuer: %4!ws!%n
//  Friendly Name: %5!ws!%n
//  UPN: %6!ws!%n
//  Enhanced Key Usage: %7!ws!%n
//  Valid From: %8!ws!%n
//  Valid To: %9!ws!%n
//  Thumbprint: %10!ws!
//
#define EAPOL_CERTIFICATE_DETAILS        0x00000BFDL

//
// MessageId: EAPOL_POLICY_CHANGE_NOTIFICATION
//
// MessageText:
//
//  Received policy change notification from Policy Engine
//
#define EAPOL_POLICY_CHANGE_NOTIFICATION 0x00000BFEL

//
// MessageId: EAPOL_POLICY_UPDATED
//
// MessageText:
//
//  Updated local policy settings with changed settings provided by Policy Engine
//
#define EAPOL_POLICY_UPDATED             0x00000BFFL

//
// MessageId: EAPOL_NOT_ENABLED_PACKET_REJECTED
//
// MessageText:
//
//  802.1X is not enabled for the current network setting. Packet received has been rejected.
//
#define EAPOL_NOT_ENABLED_PACKET_REJECTED 0x00000C00L

//
// MessageId: EAPOL_EAP_AUTHENTICATION_FAILED_ACQUIRED
//
// MessageText:
//
//  802.1X client authentication failed. Possible errors are:
//  1. Invalid username was entered
//  2. Invalid certificate was chosen
//  3. User account does not have privileges to authenticate
//  
//  Contact system administrator for more details
//
#define EAPOL_EAP_AUTHENTICATION_FAILED_ACQUIRED 0x00000C01L

//
// MessageId: EAPOL_NOT_CONFIGURED_KEYS
//
// MessageText:
//
//  No keys have been configured for the Wireless connection. Re-keying functionality will not work.
//
#define EAPOL_NOT_CONFIGURED_KEYS        0x00000C02L

//
// MessageId: EAPOL_NOT_RECEIVED_XMIT_KEY
//
// MessageText:
//
//  No transmit WEP key was received for the Wireless connection after 802.1x authentication. The current setting has been marked as failed and the Wireless connection will be disconnected.
//
#define EAPOL_NOT_RECEIVED_XMIT_KEY      0x00000C03L

//
// MessageId: ZCDB_LOG_BASE_END
//
// MessageText:
//
//  end.
//  
//
#define ZCDB_LOG_BASE_END                0x00000F9FL

//
// WPA error from WPA_MSG_BASE 4000 to WPA_MSG_END = 4500
//
//
// MessageId: WPA_ADMIN_SAFEMODE_HWIDOOT_MSG
//
// MessageText:
//
//  Since Windows was first activated on this computer, the hardware on the computer has changed significantly. Due to these changes, Windows must be reactivated within %u days. You cannot reactivate Windows in safe mode. Please restart your computer in normal mode to reactivate Windows.\nDo you want to restart your computer now?
//
#define WPA_ADMIN_SAFEMODE_HWIDOOT_MSG   0x00000FA0L

//
// MessageId: WPA_ADMIN_ACTIVATIONREMINDER_HWIDOOT_MSG
//
// MessageText:
//
//  Since Windows was first activated on this computer, the hardware on the computer has changed significantly. Due to these changes, Windows must be reactivated within %u days.\nDo you want to reactivate Windows now?
//
#define WPA_ADMIN_ACTIVATIONREMINDER_HWIDOOT_MSG 0x00000FA1L

//
// MessageId: WPA_USER_ACTIVATIONREMINDER_HWIDOOT_MSG
//
// MessageText:
//
//  Since Windows was first activated on this computer, the hardware on the computer has changed significantly. Due to these changes, Windows must be reactivated within %u days. To avoid being denied access, please ask your computer administrator to reactivate Windows on this computer.
//
#define WPA_USER_ACTIVATIONREMINDER_HWIDOOT_MSG 0x00000FA3L

//
// MessageId: WPA_BLPID_MSG
//
// MessageText:
//
//  The Product Key used to install Windows is invalid. Please contact your system administrator or retailer immediately to obtain a valid Product Key. You may also contact Microsoft Corporations Anti-Piracy Team by emailing piracy@microsoft.com if you think you have purchased pirated Microsoft software. Please be assured that any personal information you send to the Microsoft Anti-Piracy Team will be kept in strict confidence.
//
#define WPA_BLPID_MSG                    0x00000FA4L

//
// MessageId: WPA_MSG_END
//
// MessageText:
//
//  end.
//
#define WPA_MSG_END                      0x00001194L

//
// New error for userenv.dll
//
//
// MessageId: EVENT_LOGON_RUP_NOT_SECURE
//
// MessageText:
//
//  Windows did not load your roaming profile and is attempting to log you on with your local profile. Changes to the profile will not be copied to the server when you logoff. Windows did not load your profile because a server copy of the profile folder already exists that does not have the correct security. Either the current user or the Administrator's group must be the owner of the folder. Contact your network administrator. %n%n
//
#define EVENT_LOGON_RUP_NOT_SECURE       0xC00005F6L

//Eventlog messages for telnet.
//TELNET_BASE = 6000
//TELNET_BLOCK_NUMID = 10
//
// MessageId: TELNET_MSG_ERROR_CREATE_DESKTOP_FAILURE
//
// MessageText:
//
//  Telnet Server failed to initialize a Telnet Session due to lack of system resources. Please free up memory by closing any idle telnet connections or some other applications and try again. System error : %1
//  
//
#define TELNET_MSG_ERROR_CREATE_DESKTOP_FAILURE 0xC0001771L

//
// MessageId: TELNET_MSG_REVERTSELFFAIL
//
// MessageText:
//
//  Telnet session will be terminated due to an internal error while calling RevertToSelf() . System Error: %1
//  
//
#define TELNET_MSG_REVERTSELFFAIL        0xC0001772L

#endif //__XPSP1RES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\sdktools\inc\ntiodump.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntiodump.h

Abstract:

    This is the include file that defines all constants and types for
    accessing memory dump files.

Revision History:


--*/

#ifndef _NTIODUMP_
#define _NTIODUMP_

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef MIDL_PASS
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning( disable : 4200 ) // nonstandard extension used : zero-sized array in struct/union
#endif // MIDL_PASS

#ifdef __cplusplus
extern "C" {
#endif


#define USERMODE_CRASHDUMP_SIGNATURE    'RESU'
#define USERMODE_CRASHDUMP_VALID_DUMP32 'PMUD'
#define USERMODE_CRASHDUMP_VALID_DUMP64 '46UD'

typedef struct _USERMODE_CRASHDUMP_HEADER {
    ULONG       Signature;
    ULONG       ValidDump;
    ULONG       MajorVersion;
    ULONG       MinorVersion;
    ULONG       MachineImageType;
    ULONG       ThreadCount;
    ULONG       ModuleCount;
    ULONG       MemoryRegionCount;
    ULONG_PTR   ThreadOffset;
    ULONG_PTR   ModuleOffset;
    ULONG_PTR   DataOffset;
    ULONG_PTR   MemoryRegionOffset;
    ULONG_PTR   DebugEventOffset;
    ULONG_PTR   ThreadStateOffset;
    ULONG_PTR   VersionInfoOffset;
    ULONG_PTR   Spare1;
} USERMODE_CRASHDUMP_HEADER, *PUSERMODE_CRASHDUMP_HEADER;

typedef struct _USERMODE_CRASHDUMP_HEADER32 {
    ULONG       Signature;
    ULONG       ValidDump;
    ULONG       MajorVersion;
    ULONG       MinorVersion;
    ULONG       MachineImageType;
    ULONG       ThreadCount;
    ULONG       ModuleCount;
    ULONG       MemoryRegionCount;
    ULONG       ThreadOffset;
    ULONG       ModuleOffset;
    ULONG       DataOffset;
    ULONG       MemoryRegionOffset;
    ULONG       DebugEventOffset;
    ULONG       ThreadStateOffset;
    ULONG       VersionInfoOffset;
    ULONG       Spare1;
} USERMODE_CRASHDUMP_HEADER32, *PUSERMODE_CRASHDUMP_HEADER32;

typedef struct _USERMODE_CRASHDUMP_HEADER64 {
    ULONG       Signature;
    ULONG       ValidDump;
    ULONG       MajorVersion;
    ULONG       MinorVersion;
    ULONG       MachineImageType;
    ULONG       ThreadCount;
    ULONG       ModuleCount;
    ULONG       MemoryRegionCount;
    ULONGLONG   ThreadOffset;
    ULONGLONG   ModuleOffset;
    ULONGLONG   DataOffset;
    ULONGLONG   MemoryRegionOffset;
    ULONGLONG   DebugEventOffset;
    ULONGLONG   ThreadStateOffset;
    ULONGLONG   VersionInfoOffset;
    ULONGLONG   Spare1;
} USERMODE_CRASHDUMP_HEADER64, *PUSERMODE_CRASHDUMP_HEADER64;

typedef struct _CRASH_MODULE {
    ULONG_PTR   BaseOfImage;
    ULONG       SizeOfImage;
    ULONG       ImageNameLength;
    CHAR        ImageName[0];
} CRASH_MODULE, *PCRASH_MODULE;

typedef struct _CRASH_MODULE32 {
    ULONG       BaseOfImage;
    ULONG       SizeOfImage;
    ULONG       ImageNameLength;
    CHAR        ImageName[0];
} CRASH_MODULE32, *PCRASH_MODULE32;

typedef struct _CRASH_MODULE64 {
    ULONGLONG   BaseOfImage;
    ULONG       SizeOfImage;
    ULONG       ImageNameLength;
    CHAR        ImageName[0];
} CRASH_MODULE64, *PCRASH_MODULE64;

typedef struct _CRASH_THREAD {
    ULONG       ThreadId;
    ULONG       SuspendCount;
    ULONG       PriorityClass;
    ULONG       Priority;
    ULONG_PTR   Teb;
    ULONG_PTR   Spare0;
    ULONG_PTR   Spare1;
    ULONG_PTR   Spare2;
    ULONG_PTR   Spare3;
    ULONG_PTR   Spare4;
    ULONG_PTR   Spare5;
    ULONG_PTR   Spare6;
} CRASH_THREAD, *PCRASH_THREAD;

typedef struct _CRASH_THREAD32 {
    ULONG       ThreadId;
    ULONG       SuspendCount;
    ULONG       PriorityClass;
    ULONG       Priority;
    ULONG       Teb;
    ULONG       Spare0;
    ULONG       Spare1;
    ULONG       Spare2;
    ULONG       Spare3;
    ULONG       Spare4;
    ULONG       Spare5;
    ULONG       Spare6;
} CRASH_THREAD32, *PCRASH_THREAD32;

typedef struct _CRASH_THREAD64 {
    ULONG       ThreadId;
    ULONG       SuspendCount;
    ULONG       PriorityClass;
    ULONG       Priority;
    ULONGLONG   Teb;
    ULONGLONG   Spare0;
    ULONGLONG   Spare1;
    ULONGLONG   Spare2;
    ULONGLONG   Spare3;
    ULONGLONG   Spare4;
    ULONGLONG   Spare5;
    ULONGLONG   Spare6;
} CRASH_THREAD64, *PCRASH_THREAD64;


typedef struct _CRASHDUMP_VERSION_INFO {
    int     IgnoreGuardPages;       // Whether we should ignore GuardPages or not
    ULONG   PointerSize;            // 32, 64 bit pointers
} CRASHDUMP_VERSION_INFO, *PCRASHDUMP_VERSION_INFO;

//
// usermode crash dump data types
//
#define DMP_EXCEPTION                 1 // obsolete
#define DMP_MEMORY_BASIC_INFORMATION  2
#define DMP_THREAD_CONTEXT            3
#define DMP_MODULE                    4
#define DMP_MEMORY_DATA               5
#define DMP_DEBUG_EVENT               6
#define DMP_THREAD_STATE              7
#define DMP_DUMP_FILE_HANDLE          8

//
// usermode crashdump callback function
//
typedef int (__stdcall *PDMP_CREATE_DUMP_CALLBACK)(
    ULONG       DataType,
    PVOID*      DumpData,
    PULONG      DumpDataLength,
    PVOID       UserData
    );


//
// Define the information required to process memory dumps.
//


typedef enum _DUMP_TYPES {
    DUMP_TYPE_INVALID           = -1,
    DUMP_TYPE_UNKNOWN           = 0,
    DUMP_TYPE_FULL              = 1,
    DUMP_TYPE_SUMMARY           = 2,
    DUMP_TYPE_HEADER            = 3,
    DUMP_TYPE_TRIAGE            = 4,
} DUMP_TYPE;


//
// Signature and Valid fields.
//

#define DUMP_SIGNATURE32   ('EGAP')
#define DUMP_VALID_DUMP32  ('PMUD')

#define DUMP_SIGNATURE64   ('EGAP')
#define DUMP_VALID_DUMP64  ('46UD')

#define DUMP_SUMMARY_SIGNATURE  ('PMDS')
#define DUMP_SUMMARY_VALID      ('PMUD')

#define DUMP_SUMMARY_VALID_KERNEL_VA                     (1)
#define DUMP_SUMMARY_VALID_CURRENT_USER_VA               (2)

//
//
// NOTE: The definition of PHYISCAL_MEMORY_RUN and PHYSICAL_MEMORY_DESCRIPTOR
// MUST be the same as in mm.h. The kernel portion of crashdump will
// verify that these structs are the same.
//

typedef struct _PHYSICAL_MEMORY_RUN32 {
    ULONG BasePage;
    ULONG PageCount;
} PHYSICAL_MEMORY_RUN32, *PPHYSICAL_MEMORY_RUN32;

typedef struct _PHYSICAL_MEMORY_DESCRIPTOR32 {
    ULONG NumberOfRuns;
    ULONG NumberOfPages;
    PHYSICAL_MEMORY_RUN32 Run[1];
} PHYSICAL_MEMORY_DESCRIPTOR32, *PPHYSICAL_MEMORY_DESCRIPTOR32;

typedef struct _PHYSICAL_MEMORY_RUN64 {
    ULONG64 BasePage;
    ULONG64 PageCount;
} PHYSICAL_MEMORY_RUN64, *PPHYSICAL_MEMORY_RUN64;

typedef struct _PHYSICAL_MEMORY_DESCRIPTOR64 {
    ULONG NumberOfRuns;
    ULONG64 NumberOfPages;
    PHYSICAL_MEMORY_RUN64 Run[1];
} PHYSICAL_MEMORY_DESCRIPTOR64, *PPHYSICAL_MEMORY_DESCRIPTOR64;


typedef struct _UNLOADED_DRIVERS32 {
    UNICODE_STRING32 Name;
    ULONG StartAddress;
    ULONG EndAddress;
    LARGE_INTEGER CurrentTime;
} UNLOADED_DRIVERS32, *PUNLOADED_DRIVERS32;

typedef struct _UNLOADED_DRIVERS64 {
    UNICODE_STRING64 Name;
    ULONG64 StartAddress;
    ULONG64 EndAddress;
    LARGE_INTEGER CurrentTime;
} UNLOADED_DRIVERS64, *PUNLOADED_DRIVERS64;

#define MAX_UNLOADED_NAME_LENGTH 24

typedef struct _DUMP_UNLOADED_DRIVERS32
{
    UNICODE_STRING32 Name;
    WCHAR DriverName[MAX_UNLOADED_NAME_LENGTH / sizeof (WCHAR)];
    ULONG StartAddress;
    ULONG EndAddress;
} DUMP_UNLOADED_DRIVERS32, *PDUMP_UNLOADED_DRIVERS32;

typedef struct _DUMP_UNLOADED_DRIVERS64
{
    UNICODE_STRING64 Name;
    WCHAR DriverName[MAX_UNLOADED_NAME_LENGTH / sizeof (WCHAR)];
    ULONG64 StartAddress;
    ULONG64 EndAddress;
} DUMP_UNLOADED_DRIVERS64, *PDUMP_UNLOADED_DRIVERS64;

typedef struct _DUMP_MM_STORAGE32
{
    ULONG Version;
    ULONG Size;
    ULONG MmSpecialPoolTag;
    ULONG MiTriageActionTaken;

    ULONG MmVerifyDriverLevel;
    ULONG KernelVerifier;
    ULONG MmMaximumNonPagedPool;
    ULONG MmAllocatedNonPagedPool;

    ULONG PagedPoolMaximum;
    ULONG PagedPoolAllocated;

    ULONG CommittedPages;
    ULONG CommittedPagesPeak;
    ULONG CommitLimitMaximum;
} DUMP_MM_STORAGE32, *PDUMP_MM_STORAGE32;

typedef struct _DUMP_MM_STORAGE64
{
    ULONG Version;
    ULONG Size;
    ULONG MmSpecialPoolTag;
    ULONG MiTriageActionTaken;

    ULONG MmVerifyDriverLevel;
    ULONG KernelVerifier;
    ULONG64 MmMaximumNonPagedPool;
    ULONG64 MmAllocatedNonPagedPool;

    ULONG64 PagedPoolMaximum;
    ULONG64 PagedPoolAllocated;

    ULONG64 CommittedPages;
    ULONG64 CommittedPagesPeak;
    ULONG64 CommitLimitMaximum;
} DUMP_MM_STORAGE64, *PDUMP_MM_STORAGE64;


//
// Define the dump header structure. You cannot change these
// defines without breaking the debuggers, so don't.
//

#define DMP_PHYSICAL_MEMORY_BLOCK_SIZE_32   (700)
#define DMP_CONTEXT_RECORD_SIZE_32          (1200)
#define DMP_RESERVED_0_SIZE_32              (1768)
#define DMP_RESERVED_1_SIZE_32              (4)
#define DMP_RESERVED_2_SIZE_32              (16)
#define DMP_RESERVED_3_SIZE_32              (56)

#define DMP_PHYSICAL_MEMORY_BLOCK_SIZE_64   (700)
#define DMP_CONTEXT_RECORD_SIZE_64          (3000)
#define DMP_RESERVED_0_SIZE_64              (4024)

#define DMP_HEADER_COMMENT_SIZE             (128)

//
// The 32-bit memory dump structure requires 4-byte alignment.
//

#include <pshpack4.h>

typedef struct _DUMP_HEADER32 {
    ULONG Signature;
    ULONG ValidDump;
    ULONG MajorVersion;
    ULONG MinorVersion;
    ULONG DirectoryTableBase;
    ULONG PfnDataBase;
    ULONG PsLoadedModuleList;
    ULONG PsActiveProcessHead;
    ULONG MachineImageType;
    ULONG NumberProcessors;
    ULONG BugCheckCode;
    ULONG BugCheckParameter1;
    ULONG BugCheckParameter2;
    ULONG BugCheckParameter3;
    ULONG BugCheckParameter4;
    CHAR VersionUser[32];
    UCHAR PaeEnabled;               // Present only for Win2k and better
    UCHAR Spare3[3];
    ULONG KdDebuggerDataBlock;      // Present only for Win2k SP1 and better.

    union {
        PHYSICAL_MEMORY_DESCRIPTOR32 PhysicalMemoryBlock;
        UCHAR PhysicalMemoryBlockBuffer [ DMP_PHYSICAL_MEMORY_BLOCK_SIZE_32 ];
    };
    UCHAR ContextRecord [ DMP_CONTEXT_RECORD_SIZE_32 ];
    EXCEPTION_RECORD32 Exception;
    CHAR Comment [ DMP_HEADER_COMMENT_SIZE ];   // May not be present.
    UCHAR _reserved0 [ DMP_RESERVED_0_SIZE_32 ];
    ULONG DumpType;                             // Present for Win2k and better.
    ULONG MiniDumpFields;
    ULONG SecondaryDataState;
    ULONG ProductType;
    ULONG SuiteMask;
    UCHAR _reserved1 [ DMP_RESERVED_1_SIZE_32 ];
    LARGE_INTEGER RequiredDumpSpace;            // Present for Win2k and better.
    UCHAR _reserved2 [ DMP_RESERVED_2_SIZE_32 ];
    LARGE_INTEGER SystemUpTime;                 // Present only for Whistler and better.
    LARGE_INTEGER SystemTime;                   // Present only for Win2k and better.
    UCHAR _reserved3 [ DMP_RESERVED_3_SIZE_32 ];
} DUMP_HEADER32, *PDUMP_HEADER32;


typedef struct _FULL_DUMP32 {
    CHAR Memory [1];                // Variable length to the end of the dump file.
} FULL_DUMP32, *PFULL_DUMP32;

typedef struct _SUMMARY_DUMP32 {
    ULONG Signature;
    ULONG ValidDump;
    ULONG DumpOptions;  // Summary Dump Options
    ULONG HeaderSize;   // Offset to the start of actual memory dump
    ULONG BitmapSize;   // Total bitmap size (i.e., maximum #bits)
    ULONG Pages;        // Total bits set in bitmap (i.e., total pages in sdump)

    //
    // These next three fields essentially form an on-disk RTL_BITMAP structure.
    // The RESERVED field is stupidness introduced by the way the data is
    // serialized to disk.
    //

    struct {
        ULONG SizeOfBitMap;
        ULONG _reserved0;
        ULONG Buffer[];
    } Bitmap;
    
} SUMMARY_DUMP32, * PSUMMARY_DUMP32;


typedef struct _TRIAGE_DUMP32 {
    ULONG ServicePackBuild;             // What service pack of NT was this ?
    ULONG SizeOfDump;                   // Size in bytes of the dump
    ULONG ValidOffset;                  // Offset valid ULONG
    ULONG ContextOffset;                // Offset of CONTEXT record
    ULONG ExceptionOffset;              // Offset of EXCEPTION record
    ULONG MmOffset;                     // Offset of Mm information
    ULONG UnloadedDriversOffset;        // Offset of Unloaded Drivers
    ULONG PrcbOffset;                   // Offset of KPRCB
    ULONG ProcessOffset;                // Offset of EPROCESS
    ULONG ThreadOffset;                 // Offset of ETHREAD
    ULONG CallStackOffset;              // Offset of CallStack Pages
    ULONG SizeOfCallStack;              // Size in bytes of CallStack
    ULONG DriverListOffset;             // Offset of Driver List
    ULONG DriverCount;                  // Number of Drivers in list
    ULONG StringPoolOffset;             // Offset to the string pool
    ULONG StringPoolSize;               // Size of the string pool
    ULONG BrokenDriverOffset;           // Offset into the driver of the driver that crashed
    ULONG TriageOptions;                // Triage options in effect at crashtime
    ULONG TopOfStack;                   // The top (highest address) of the call stack

    ULONG DataPageAddress;
    ULONG DataPageOffset;
    ULONG DataPageSize;

    ULONG DebuggerDataOffset;
    ULONG DebuggerDataSize;

    ULONG DataBlocksOffset;
    ULONG DataBlocksCount;
    
} TRIAGE_DUMP32, * PTRIAGE_DUMP32;


typedef struct _MEMORY_DUMP32 {
    DUMP_HEADER32 Header;

    union {
        FULL_DUMP32 Full;               // DumpType == DUMP_TYPE_FULL
        SUMMARY_DUMP32 Summary;         // DumpType == DUMP_TYPE_SUMMARY
        TRIAGE_DUMP32 Triage;           // DumpType == DUMP_TYPE_TRIAGE
    };
    
} MEMORY_DUMP32, *PMEMORY_DUMP32;


#include <poppack.h>

typedef struct _DUMP_HEADER64 {
    ULONG Signature;
    ULONG ValidDump;
    ULONG MajorVersion;
    ULONG MinorVersion;
    ULONG64 DirectoryTableBase;
    ULONG64 PfnDataBase;
    ULONG64 PsLoadedModuleList;
    ULONG64 PsActiveProcessHead;
    ULONG MachineImageType;
    ULONG NumberProcessors;
    ULONG BugCheckCode;
    ULONG64 BugCheckParameter1;
    ULONG64 BugCheckParameter2;
    ULONG64 BugCheckParameter3;
    ULONG64 BugCheckParameter4;
    CHAR VersionUser[32];
    ULONG64 KdDebuggerDataBlock;

    union {
        PHYSICAL_MEMORY_DESCRIPTOR64 PhysicalMemoryBlock;
        UCHAR PhysicalMemoryBlockBuffer [ DMP_PHYSICAL_MEMORY_BLOCK_SIZE_64 ];
    };
    UCHAR ContextRecord [ DMP_CONTEXT_RECORD_SIZE_64 ];
    EXCEPTION_RECORD64 Exception;
    ULONG DumpType;
    LARGE_INTEGER RequiredDumpSpace;
    LARGE_INTEGER SystemTime;
    CHAR Comment [ DMP_HEADER_COMMENT_SIZE ];   // May not be present.
    LARGE_INTEGER SystemUpTime;
    ULONG MiniDumpFields;
    ULONG SecondaryDataState;
    ULONG ProductType;
    ULONG SuiteMask;
    UCHAR _reserved0[ DMP_RESERVED_0_SIZE_64 ];
} DUMP_HEADER64, *PDUMP_HEADER64;

typedef struct _FULL_DUMP64 {
    CHAR Memory[1];             // Variable length to the end of the dump file.
} FULL_DUMP64, *PFULL_DUMP64;

//
// ISSUE - 2000/02/17 - math: NT64 Summary dump.
//
// This is broken. The 64 bit summary dump should have a ULONG64 for
// the BitmapSize to match the size of the PFN_NUMBER.
//

typedef struct _SUMMARY_DUMP64 {
    ULONG Signature;
    ULONG ValidDump;
    ULONG DumpOptions;  // Summary Dump Options
    ULONG HeaderSize;   // Offset to the start of actual memory dump
    ULONG BitmapSize;   // Total bitmap size (i.e., maximum #bits)
    ULONG Pages;        // Total bits set in bitmap (i.e., total pages in sdump)

    //
    // ISSUE - 2000/02/17 - math: Win64
    //
    // With a 64-bit PFN, we should not have a 32-bit bitmap.
    //
    
    //
    // These next three fields essentially form an on-disk RTL_BITMAP structure.
    // The RESERVED field is stupidness introduced by the way the data is
    // serialized to disk.
    //

    struct {
        ULONG SizeOfBitMap;
        ULONG64 _reserved0;
        ULONG Buffer[];
    } Bitmap;

} SUMMARY_DUMP64, * PSUMMARY_DUMP64;


typedef struct _TRIAGE_DUMP64 {
    ULONG ServicePackBuild;             // What service pack of NT was this ?
    ULONG SizeOfDump;                   // Size in bytes of the dump
    ULONG ValidOffset;                  // Offset valid ULONG
    ULONG ContextOffset;                // Offset of CONTEXT record
    ULONG ExceptionOffset;              // Offset of EXCEPTION record
    ULONG MmOffset;                     // Offset of Mm information
    ULONG UnloadedDriversOffset;        // Offset of Unloaded Drivers
    ULONG PrcbOffset;                   // Offset of KPRCB
    ULONG ProcessOffset;                // Offset of EPROCESS
    ULONG ThreadOffset;                 // Offset of ETHREAD
    ULONG CallStackOffset;              // Offset of CallStack Pages
    ULONG SizeOfCallStack;              // Size in bytes of CallStack
    ULONG DriverListOffset;             // Offset of Driver List
    ULONG DriverCount;                  // Number of Drivers in list
    ULONG StringPoolOffset;             // Offset to the string pool
    ULONG StringPoolSize;               // Size of the string pool
    ULONG BrokenDriverOffset;           // Offset into the driver of the driver that crashed
    ULONG TriageOptions;                // Triage options in effect at crashtime
    ULONG64 TopOfStack;                 // The top (highest address) of the callstack

    //
    // Architecture Specific fields.
    //
    
    union {

        //
        // For IA64 we need to store the BStore as well.
        //
        
        struct {
            ULONG BStoreOffset;         // Offset of BStore region.
            ULONG SizeOfBStore;         // The size of the BStore region.
            ULONG64 LimitOfBStore;      // The limit (highest memory address)
        } Ia64;                         //  of the BStore region.
        
    } ArchitectureSpecific;

    ULONG64 DataPageAddress;
    ULONG   DataPageOffset;
    ULONG   DataPageSize;

    ULONG   DebuggerDataOffset;
    ULONG   DebuggerDataSize;

    ULONG   DataBlocksOffset;
    ULONG   DataBlocksCount;
    
} TRIAGE_DUMP64, * PTRIAGE_DUMP64;


typedef struct _MEMORY_DUMP64 {
    DUMP_HEADER64 Header;

    union {
        FULL_DUMP64 Full;               // DumpType == DUMP_TYPE_FULL
        SUMMARY_DUMP64 Summary;         // DumpType == DUMP_TYPE_SUMMARY
        TRIAGE_DUMP64 Triage;           // DumpType == DUMP_TYPE_TRIAGE
    };
    
} MEMORY_DUMP64, *PMEMORY_DUMP64;


typedef struct _TRIAGE_DATA_BLOCK {
    ULONG64 Address;
    ULONG Offset;
    ULONG Size;
} TRIAGE_DATA_BLOCK, *PTRIAGE_DATA_BLOCK;

//
// In the triage dump ValidFields field what portions of the triage-dump have
// been turned on.
//

#define TRIAGE_DUMP_CONTEXT          (0x0001)
#define TRIAGE_DUMP_EXCEPTION        (0x0002)
#define TRIAGE_DUMP_PRCB             (0x0004)
#define TRIAGE_DUMP_PROCESS          (0x0008)
#define TRIAGE_DUMP_THREAD           (0x0010)
#define TRIAGE_DUMP_STACK            (0x0020)
#define TRIAGE_DUMP_DRIVER_LIST      (0x0040)
#define TRIAGE_DUMP_BROKEN_DRIVER    (0x0080)
#define TRIAGE_DUMP_BASIC_INFO       (0x00FF)
#define TRIAGE_DUMP_MMINFO           (0x0100)
#define TRIAGE_DUMP_DATAPAGE         (0x0200)
#define TRIAGE_DUMP_DEBUGGER_DATA    (0x0400)
#define TRIAGE_DUMP_DATA_BLOCKS      (0x0800)

#define TRIAGE_OPTION_OVERFLOWED     (0x0100)

#define TRIAGE_DUMP_VALID       ( 'DGRT' )
#define TRIAGE_DUMP_SIZE32      ( 0x1000 * 16 )
#define TRIAGE_DUMP_SIZE64      ( 0x2000 * 16 )

#ifdef _NTLDRAPI_

typedef struct _DUMP_DRIVER_ENTRY32 {
    ULONG DriverNameOffset;
    KLDR_DATA_TABLE_ENTRY32 LdrEntry;
} DUMP_DRIVER_ENTRY32, * PDUMP_DRIVER_ENTRY32;

typedef struct _DUMP_DRIVER_ENTRY64 {
    ULONG DriverNameOffset;
    ULONG __alignment;
    KLDR_DATA_TABLE_ENTRY64 LdrEntry;
} DUMP_DRIVER_ENTRY64, * PDUMP_DRIVER_ENTRY64;

#endif // _NTLDRAPI

//
// The DUMP_STRING is guaranteed to be both NULL terminated and length prefixed
// (prefix does not include the NULL).
//

typedef struct _DUMP_STRING {
    ULONG Length;                   // Length IN BYTES of the string.
    WCHAR Buffer [0];               // Buffer.
} DUMP_STRING, * PDUMP_STRING;


//
// Secondary dumps can be generated at bugcheck time after
// the primary dump has been generated.  The data in these
// dumps is arbitrary and not interpretable, so the file
// format is just a sequence of tagged blobs.
//
// Each blob header is aligned on an eight-byte boundary
// and the data immediately follows it.  Padding
// may precede and/or follow the data for alignment purposes.
//
// Blobs are streamed into the file so there is no overall count.
//

#define DUMP_BLOB_SIGNATURE1 'pmuD'
#define DUMP_BLOB_SIGNATURE2 'bolB'

typedef struct _DUMP_BLOB_FILE_HEADER {
    ULONG Signature1;
    ULONG Signature2;
    ULONG HeaderSize;
    ULONG BuildNumber;
} DUMP_BLOB_FILE_HEADER, *PDUMP_BLOB_FILE_HEADER;

typedef struct _DUMP_BLOB_HEADER {
    ULONG HeaderSize;
    GUID Tag;
    ULONG DataSize;
    ULONG PrePad;
    ULONG PostPad;
} DUMP_BLOB_HEADER, *PDUMP_BLOB_HEADER;

#ifdef __cplusplus
}
#endif

//
// These defines should be used only by components
// that know the architecture of the dump matches
// the architecture of the machine they are on; i.e.,
// the kernel and savedump. In particular, the debugger
// should always explicitly use either the 32 or
// 64 bit versions of the headers.
//

#ifndef __NTSDP_HPP__
#if defined (_WIN64)

typedef DUMP_HEADER64 DUMP_HEADER;
typedef PDUMP_HEADER64 PDUMP_HEADER;
typedef MEMORY_DUMP64 MEMORY_DUMP;
typedef PMEMORY_DUMP64 PMEMORY_DUMP;
typedef SUMMARY_DUMP64 SUMMARY_DUMP;
typedef PSUMMARY_DUMP64 PSUMMARY_DUMP;
typedef TRIAGE_DUMP64 TRIAGE_DUMP;
typedef PTRIAGE_DUMP64 PTRIAGE_DUMP;
#ifdef _NTLDRAPI_
typedef DUMP_DRIVER_ENTRY64 DUMP_DRIVER_ENTRY;
typedef PDUMP_DRIVER_ENTRY64 PDUMP_DRIVER_ENTRY;
#endif
#define DUMP_SIGNATURE DUMP_SIGNATURE64
#define DUMP_VALID_DUMP DUMP_VALID_DUMP64
#define TRIAGE_DUMP_SIZE TRIAGE_DUMP_SIZE64
typedef PPHYSICAL_MEMORY_RUN64 PPHYSICAL_MEMORYRUN;
typedef PPHYSICAL_MEMORY_DESCRIPTOR64 PPHYSICAL_MEMORYDESCRIPTOR;

#else

typedef DUMP_HEADER32 DUMP_HEADER;
typedef PDUMP_HEADER32 PDUMP_HEADER;
typedef MEMORY_DUMP32 MEMORY_DUMP;
typedef PMEMORY_DUMP32 PMEMORY_DUMP;
typedef SUMMARY_DUMP32 SUMMARY_DUMP;
typedef PSUMMARY_DUMP32 PSUMMARY_DUMP;
typedef TRIAGE_DUMP32 TRIAGE_DUMP;
typedef PTRIAGE_DUMP32 PTRIAGE_DUMP;
#ifdef _NTLDRAPI_
typedef DUMP_DRIVER_ENTRY32 DUMP_DRIVER_ENTRY;
typedef PDUMP_DRIVER_ENTRY32 PDUMP_DRIVER_ENTRY;
#endif
#define DUMP_SIGNATURE DUMP_SIGNATURE32
#define DUMP_VALID_DUMP DUMP_VALID_DUMP32
#define TRIAGE_DUMP_SIZE TRIAGE_DUMP_SIZE32
typedef PPHYSICAL_MEMORY_RUN32 PPHYSICAL_MEMORYRUN;
typedef PPHYSICAL_MEMORY_DESCRIPTOR32 PPHYSICAL_MEMORYDESCRIPTOR;

#endif
#endif

#ifndef MIDL_PASS
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning( default : 4200 ) // nonstandard extension used : zero-sized array in struct/union
#endif
#endif // MIDL_PASS

#endif // _NTIODUMP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\sdktools\inc\ehdata.h ===
/***
*ehdata.h -
*
*	Copyright (c) 1993-1995, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	Declare misc. types, macros, etc. for implementation
*	of C++ Exception Handling for the run-time and the compiler.
*	Hardware independent, assumes Windows NT.
*
* Portions of this header file can be disabled by defining the following
* macros:
*	_EHDATA_NOHEADERS - suppresses inclusion of standard header files
*		If this is specified, then appropriate typedefs or macros must
*		be provided by some other means.
*	_EHDATA_NOTHROW - suppresses definitions used only to describe a throw
*	_EHDATA_NOFUNCINFO - suppresses definitions for the frame descriptor
*	_EHDATA_NONT - suppresses definitions of our version of NT's stuff
*
* Other conditional compilation macros:
*    CC_EXPLICITFRAME - if true, representation of registration node includes
*	the value of the frame-pointer for that frame, making the location
*	of the registration node on the frame flexible.  This is intended
*	primarily for early testing.
*
*       [Internal]
*
*Revision History:
*       05-20-93  BS	Module Created.
*	03-01-94  CFW	Remove CONTEXT def for x86 for TiborL.
*	03-03-94  TL	Mips (_M_MRX000 >= 4000) changes
*	09-02-94  SKS	This header file added.
*	09-12-94  GJF	Merged in changes from/for DEC (Al Doser, dated 6/20,
*			and Bill Baxter, dated 6/28).
*	11-06-94  GJF	Changed pack pragma to 8 byte alignment.
*       02-14-95  CFW   Clean up Mac merge.
*       03-22-95  PML   Add const for read-only structs
*       03-29-95  CFW   Add error message to internal headers.
*	04-14-95  JWM	Added EH_ABORT_FRAME_UNWIND_PART for EH/SEH exception handling.
*	04-20-95  TGL	Added iFrameNestLevel field to MIPS FuncInfo
*	04-27-95  JWM	EH_ABORT_FRAME_UNWIND_PART now #ifdef ALLOW_UNWIND_ABORT.
*	06-08-95  JWM	Merged CRT version of ehdata.h into langapi source.
*
****/

#ifndef _INC_EHDATA
#define _INC_EHDATA

#if _M_IX86 >= 300 /*IFSTRIP=IGN*/
# ifndef CC_EXPLICITFRAME
#  define CC_EXPLICITFRAME	0	// If non-zero, we're using a hack version of the
								// registration node.
# endif
#endif

#ifndef _EHDATA_NOHEADERS
#include <stddef.h>
#include <excpt.h>
#if defined(_WIN32)
#include <windows.h>
#else
#include <nowin.h>
#endif
#endif /* _EHDATA_NOHEADERS */

#pragma pack(push, ehdata, 4)

#define EH_EXCEPTION_NUMBER	('msc' | 0xE0000000)	// The NT Exception # that we use
#define EH_MAGIC_NUMBER1	0x19930520		// The magic # identifying this version
							// As magic numbers increase, we have to keep track of
							// the versions that we are backwards compatible with.
#define EH_EXCEPTION_PARAMETERS 3			// Number of parameters in exception record

#ifdef ALLOW_UNWIND_ABORT
#define EH_ABORT_FRAME_UNWIND_PART EH_EXCEPTION_NUMBER+1
#endif

//
// PMD - Pointer to Member Data: generalized pointer-to-member descriptor
//

typedef struct PMD
{
	ptrdiff_t	mdisp;		// Offset of intended data within base
	ptrdiff_t	pdisp;		// Displacement to virtual base pointer
	ptrdiff_t	vdisp;		// Index within vbTable to offset of base
	} PMD;

//
// PMFN - Pointer to Member Function
//			M00REVIEW: we may need something more than this, but this will do for now.
//

typedef void (*PMFN)(void);


//
// TypeDescriptor - per-type record which uniquely identifies the type.
//
// Each type has a decorated name which uniquely identifies it, and a hash
// value which is computed by the compiler.  The hash function used is not
// important; the only thing which is essential is that it be the same for
// all time.
//
// The special type '...' (ellipsis) is represented by a null name.
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning

typedef struct TypeDescriptor
{
#if _RTTI
	const void *	pVFTable;	// Field overloaded by RTTI
#else
	DWORD	hash;			// Hash value computed from type's decorated name
#endif
	void *	spare;			// reserved, possible for RTTI
	char	name[];			// The decorated name of the type; 0 terminated.
	} TypeDescriptor;
#pragma warning(default:4200)

#define TD_HASH(td)		((td).hash)
#define TD_NAME(td)		((td).name)

#define TD_IS_TYPE_ELLIPSIS(td) ((td == NULL) || (TD_NAME(*td)[0] == '\0'))


#ifndef _EHDATA_NOTHROW

/////////////////////////////////////////////////////////////////////////////
//
// Description of the thrown object.  (M00REVIEW: not final)
//
// This information is broken down into three levels, to allow for maximum
// comdat folding (at the cost of some extra pointers).
//
// ThrowInfo is the head of the description, and contains information about
// 				the particular variant thrown.
// CatchableTypeArray is an array of pointers to type descriptors.  It will
//				be shared between objects thrown by reference but with varying
//				qualifiers.
// CatchableType is the description of an individual type, and how to effect
//				the conversion from a given type.
//
//---------------------------------------------------------------------------


//
// CatchableType - description of a type that can be caught.
//
// Note:  although isSimpleType can be part of ThrowInfo, it is more
//		  convenient for the run-time to have it here.
//

typedef const struct _s_CatchableType {
	unsigned int	properties;				// Catchable Type properties (Bit field)
	TypeDescriptor *pType;					// Pointer to the type descriptor for this type
	PMD 			thisDisplacement;		// Pointer to instance of catch type within
											//		thrown object.
	int				sizeOrOffset;			// Size of simple-type object or offset into
											//  buffer of 'this' pointer for catch object
	PMFN			copyFunction;			// Copy constructor or CC-closure
} CatchableType;

#define CT_IsSimpleType			0x00000001		// type is a simple type
#define CT_ByReferenceOnly		0x00000002		// type must be caught by reference
#define CT_HasVirtualBase		0x00000004		// type is a class with virtual bases

#define CT_PROPERTIES(ct)	((ct).properties)
#define CT_PTD(ct)			((ct).pType)
#define CT_THISDISP(ct)		((ct).thisDisplacement)
#define CT_SIZE(ct)			((ct).sizeOrOffset)
#define CT_COPYFUNC(ct)		((ct).copyFunction)
#define CT_OFFSET(ct)		((ct).sizeOrOffset)
#define CT_HASH(ct)			(TD_HASH(*CT_PTD(ct)))
#define CT_NAME(ct)			(TD_NAME(*CT_PTD(ct)))

#define SET_CT_ISSIMPLETYPE(ct)		(CT_PROPERTIES(ct) |= CT_IsSimpleType)
#define SET_CT_BYREFONLY(ct)		(CT_PROPERTIES(ct) |= CT_ByReferenceOnly)
#define SET_CT_HASVB(ct)			(CT_PROPERTIES(ct) |= CT_HasVirtualBase)

#define CT_ISSIMPLETYPE(ct)			(CT_PROPERTIES(ct) & CT_IsSimpleType)		// Is it a simple type?
#define CT_BYREFONLY(ct)			(CT_PROPERTIES(ct) & CT_ByReferenceOnly)	// Must it be caught by reference?
#define CT_HASVB(ct)				(CT_PROPERTIES(ct) & CT_HasVirtualBase)		// Is this type a class with virtual bases?

//
// CatchableTypeArray - array of pointers to catchable types, with length
//
#pragma warning(disable:4200)		// get rid of obnoxious nonstandard extension warning
typedef const struct _s_CatchableTypeArray {
	int	nCatchableTypes;
	CatchableType	*arrayOfCatchableTypes[];
	} CatchableTypeArray;
#pragma warning(default:4200)

//
// ThrowInfo - information describing the thrown object, staticly built
// at the throw site.
//
// pExceptionObject (the dynamic part of the throw; see below) is always a
// reference, whether or not it is logically one.  If 'isSimpleType' is true,
// it is a reference to the simple type, which is 'size' bytes long.  If
// 'isReference' and 'isSimpleType' are both false, then it's a UDT or
// a pointer to any type (ie pExceptionObject points to a pointer).  If it's
// a pointer, copyFunction is NULL, otherwise it is a pointer to a copy
// constructor or copy constructor closure.
//
// The pForwardCompat function pointer is intended to be filled in by future
// versions, so that if say a DLL built with a newer version (say C10) throws,
// and a C9 frame attempts a catch, the frame handler attempting the catch (C9)
// can let the version that knows all the latest stuff do the work.
//

typedef const struct _s_ThrowInfo {
	unsigned int	attributes;			// Throw Info attributes (Bit field)
	PMFN			pmfnUnwind;			// Destructor to call when exception
										// has been handled or aborted.

	int	(__cdecl*pForwardCompat)(...);	// Forward compatibility frame handler

	CatchableTypeArray	*pCatchableTypeArray;	// Pointer to list of pointers to types.
} ThrowInfo;

#define TI_IsConst			0x00000001		// thrown object has const qualifier
#define TI_IsVolatile		0x00000002		// thrown object has volatile qualifier
#define TI_IsUnaligned		0x00000004		// thrown object has unaligned qualifier

#define THROW_ATTRS(t)			((t).attributes)
#define THROW_UNWINDFUNC(t)		((t).pmfnUnwind)
#define THROW_FORWARDCOMPAT(t)	((t).pForwardCompat)
#define THROW_COUNT(t)			((t).pCatchableTypeArray->nCatchableTypes)
#define THROW_CTLIST(t)			((t).pCatchableTypeArray->arrayOfCatchableTypes)
#define THROW_PCTLIST(t)		(&THROW_CTLIST(t))
#define THROW_CT(t, n)			(*THROW_CTLIST(t)[n])
#define THROW_PCT(t, n)			(THROW_CTLIST(t)[n])

#define SET_TI_ISCONST(t)		(THROW_ATTRS(t) |= TI_IsConst)		// Is the object thrown 'const' qualified
#define SET_TI_ISVOLATILE(t)	(THROW_ATTRS(t) |= TI_IsVolatile)	// Is the object thrown 'volatile' qualified
#define SET_TI_ISUNALIGNED(t)	(THROW_ATTRS(t) |= TI_IsUnaligned)	// Is the object thrown 'unaligned' qualified

#define THROW_ISCONST(t)		(THROW_ATTRS(t) & TI_IsConst)
#define THROW_ISVOLATILE(t)		(THROW_ATTRS(t) & TI_IsVolatile)
#define THROW_ISUNALIGNED(t)	(THROW_ATTRS(t) & TI_IsUnaligned)

//
// Here's how to throw:
// M00HACK: _ThrowInfo is the name of the type that is 'pre-injected' into the
// compiler; since this prototype is known to the FE along with the pre-injected
// types, it has to match exactly.
//
#if _MSC_VER >= 900 /*IFSTRIP=IGN*/
extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, _ThrowInfo* pThrowInfo);
#else
// If we're not self-building, we need to use the name that we defined above.
extern "C" void __stdcall _CxxThrowException(void* pExceptionObject, ThrowInfo* pThrowInfo);
#endif

#endif /* _EHDATA_NOTHROW */


#ifndef _EHDATA_NOFUNCINFO

/////////////////////////////////////////////////////////////////////////////
//
// Describing 'try/catch' blocks:
//
//---------------------------------------------------------------------------

//
// Current state of a function.
// -1 is the 'blank' state, ie there is nothing to unwind, no try blocks active.
//

typedef int __ehstate_t;		// The type of a state index

#define EH_EMPTY_STATE	-1


//
// HandlerType - description of a single 'catch'
//

typedef const struct _s_HandlerType {
	unsigned int	adjectives;			// Handler Type adjectives (bitfield)
	TypeDescriptor	*pType;				// Pointer to the corresponding type descriptor
	ptrdiff_t		dispCatchObj;		// Displacement of catch object from base
										//		of current stack frame.
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	ULONG			frameNestLevel;		// The static nesting level of parent function
#endif
	void *			addressOfHandler;	// Address of 'catch' code
} HandlerType;

#define HT_IsConst			0x00000001		// type referenced is 'const' qualified
#define HT_IsVolatile		0x00000002		// type referenced is 'volatile' qualified
#define HT_IsUnaligned		0x00000004		// type referenced is 'unaligned' qualified
#define HT_IsReference		0x00000008		// catch type is by reference
#define HT_IsResumable		0x00000010		// the catch may choose to resume (Reserved)

#define HT_ADJECTIVES(ht)		((ht).adjectives)
#define HT_PTD(ht)				((ht).pType)
#define HT_DISPCATCH(ht)		((ht).dispCatchObj)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
#define HT_FRAMENEST(ht)		((ht).frameNestLevel)
#endif
#define HT_HANDLER(ht)			((ht).addressOfHandler)
#define HT_NAME(ht)				(TD_NAME(*HT_PTD(ht)))
#define HT_HASH(ht)				(TD_HASH(*HT_PTD(ht)))
#define HT_IS_TYPE_ELLIPSIS(ht)	TD_IS_TYPE_ELLIPSIS(HT_PTD(ht))

#define SET_HT_ISCONST(ht)		(HT_ADJECTIVES(ht) |= HT_IsConst)
#define SET_HT_ISVOLATILE(ht)	(HT_ADJECTIVES(ht) |= HT_IsVolatile)
#define SET_HT_ISUNALIGNED(ht)	(HT_ADJECTIVES(ht) |= HT_IsUnaligned)
#define SET_HT_ISREFERENCE(ht)	(HT_ADJECTIVES(ht) |= HT_IsReference)
#define SET_HT_ISRESUMABLE(ht)	(HT_ADJECTIVES(ht) |= HT_IsResumable)

#define HT_ISCONST(ht)			(HT_ADJECTIVES(ht) & HT_IsConst)		// Is the type referenced 'const' qualified
#define HT_ISVOLATILE(ht)		(HT_ADJECTIVES(ht) & HT_IsVolatile)		// Is the type referenced 'volatile' qualified
#define HT_ISUNALIGNED(ht)		(HT_ADJECTIVES(ht) & HT_IsUnaligned)	// Is the type referenced 'unaligned' qualified
#define HT_ISREFERENCE(ht)		(HT_ADJECTIVES(ht) & HT_IsReference)	// Is the catch type by reference
#define HT_ISRESUMABLE(ht)		(HT_ADJECTIVES(ht) & HT_IsResumable)	// Might the catch choose to resume (Reserved)

//
// HandlerMapEntry - associates a handler list (sequence of catches) with a
//	range of eh-states.
//

typedef const struct _s_TryBlockMapEntry {
	__ehstate_t	tryLow;				// Lowest state index of try
	__ehstate_t	tryHigh;			// Highest state index of try
#if !defined(_M_ALPHA) && !defined(_M_IA64)
	__ehstate_t	catchHigh;			// Highest state index of any associated catch
#endif
	int			nCatches;			// Number of entries in array
	HandlerType *pHandlerArray;		// List of handlers for this try
} TryBlockMapEntry;

#define TBME_LOW(hm)		((hm).tryLow)
#define TBME_HIGH(hm)		((hm).tryHigh)
#if  !defined(_M_IA64)
#define TBME_CATCHHIGH(hm)	((hm).catchHigh)
#endif // !defined(_M_IA64)
#define TBME_NCATCHES(hm)	((hm).nCatches)
#define TBME_PLIST(hm)		((hm).pHandlerArray)
#define TBME_CATCH(hm, n)	(TBME_PLIST(hm)[n])
#define TBME_PCATCH(hm, n)	(&(TBME_PLIST(hm)[n]))


/////////////////////////////////////////////////////////////////////////////
//
// Description of the function:
//
//---------------------------------------------------------------------------

//
// UnwindMapEntry - Description of each state transition for unwinding
//	the stack (ie destructing objects).
//
// The unwind map is an array, indexed by current state.  Each entry specifies
// the state to go to during unwind, and the action required to get there.
// Note that states are represented by a signed integer, and that the 'blank'
// state is -1 so that the array remains 0-based (because by definition there
// is never any unwind action to be performed from state -1).  It is also
// assumed that state indices will be dense, ie that there will be no gaps of
// unused state indices in a function.
//

typedef const struct _s_UnwindMapEntry {
	__ehstate_t		toState;			// State this action takes us to
	void			(*action)(void);	// Funclet to call to effect state change
} UnwindMapEntry;

#define UWE_TOSTATE(uwe)	((uwe).toState)
#define UWE_ACTION(uwe)		((uwe).action)

#if _M_MRX000 >= 4000 || defined(_M_MPPC) || defined(_M_PPC)	 /*IFSTRIP=IGN*/
typedef struct IptoStateMapEntry {
	ULONG		Ip;
	__ehstate_t	State;
} IptoStateMapEntry;
#endif

//
// FuncInfo - all the information that describes a function with exception
//	handling information.
//

typedef const struct _s_FuncInfo
{
	unsigned int		magicNumber;		// Identifies version of compiler
	__ehstate_t			maxState;			// Highest state number plus one (thus
											// number of entries in unwind map)
	UnwindMapEntry		*pUnwindMap;		// Where the unwind map is
	unsigned int		nTryBlocks;			// Number of 'try' blocks in this function
	TryBlockMapEntry	*pTryBlockMap;		// Where the handler map is
#if defined(_M_ALPHA)
    signed int          EHContextDelta;     // Frame offset of EHContext record
#endif
	unsigned int		nIPMapEntries;		// # entries in the IP-to-state map. NYI (reserved)
#if _M_MRX000 >= 4000	 /*IFSTRIP=IGN*/
	IptoStateMapEntry	*pIPtoStateMap;     // An IP to state map..
	ptrdiff_t			dispUnwindHelp;		// Displacement of unwind helpers from base
	int					iTryBlockIndex;		// Used by catch functions only
	int					iFrameNestLevel;	// The static nesting level of parent function
#elif defined(_M_MPPC) || defined(_M_PPC)
	IptoStateMapEntry	*pIPtoStateMap;     // An IP to state map..
#else
	void				*pIPtoStateMap;		// An IP to state map.  NYI (reserved).
#endif
} FuncInfo;

#define FUNC_MAGICNUM(fi)			((fi).magicNumber)
#define FUNC_MAXSTATE(fi)		((fi).maxState)
#define FUNC_NTRYBLOCKS(fi)		((fi).nTryBlocks)
#define FUNC_NIPMAPENT(fi)		((fi).nIPMapEntries)
#define FUNC_PUNWINDMAP(fi)		((fi).pUnwindMap)
#define FUNC_PHANDLERMAP(fi)	((fi).pTryBlockMap)
#if defined(_M_ALPHA)
#define FUNC_EHCONTEXTDELTA(fi) ((fi).EHContextDelta)
#endif
#define FUNC_IPMAP(fi)			((fi).pIPtoStateMap)
#define FUNC_UNWIND(fi, st)		((fi).pUnwindMap[st])
#define FUNC_PUNWIND(fi, st)	(&FUNC_UNWIND(fi, st))
#define FUNC_TRYBLOCK(fi,n)		((fi).pTryBlockMap[n])
#define FUNC_PTRYBLOCK(fi,n)	(&FUNC_TRYBLOCK(fi, n))
#if _M_MRX000 >= 4000		 /*IFSTRIP=IGN*/
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#define FUNC_DISPUNWINDHELP(fi)	((fi).dispUnwindHelp)
#define FUNC_TRYBLOCKINDEX(fi)	((fi).iTryBlockIndex)
#define FUNC_FRAMENEST(fi)		((fi).iFrameNestLevel)
#elif defined(_M_MPPC) || defined(_M_PPC)
#define FUNC_IPTOSTATE(fi,n)	((fi).pIPtoStateMap[n])
#define FUNC_PIPTOSTATE(fi,n)	(&FUNC_IPTOSTATE(fi,n))
#elif defined(_M_IA64)
#define FUNC_UNWIND(fi, st)		((fi).pUnwindMap[st])
#define FUNC_PUNWIND(fi, st)	(&FUNC_UNWIND(fi, st))
#define FUNC_TRYBLOCK(fi,n)		((fi).pTryBlockMap[n])
#define FUNC_PTRYBLOCK(fi,n)	(&FUNC_TRYBLOCK(fi, n))
#else
#define FUNC_IPTOSTATE(fi,n) 	__ERROR_NYI__
#endif

#endif /* _EHDATA_NOFUNCINFO */

#ifndef _EHDATA_NONT

/////////////////////////////////////////////////////////////////////////////
//
// Data types that are variants of data used by NT (and Chicago) to manage
// exception handling.
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////////
//
// A stack registration node (i386 only)
//

#if _M_IX86 >= 300 /*IFSTRIP=IGN*/
struct EHRegistrationNode {
	/* void *			stackPtr */		// Stack ptr at entry to try (below address point)
	EHRegistrationNode	*pNext;			// Next node in the chain
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
#if CC_EXPLICITFRAME
	void *				frame;			// Value of ebp for this frame
#endif
};

#if !CC_EXPLICITFRAME
				// Cannonical offset
# define FRAME_OFFSET	sizeof(EHRegistrationNode)
#endif

#define PRN_NEXT(prn)		((prn)->pNext)
#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)
#define PRN_STACK(prn)		(((void**)(prn))[-1])
#if CC_EXPLICITFRAME
# define PRN_FRAME(prn)		((prn)->frame)
#else
# define PRN_FRAME(prn)		((void*)(((char*)prn) + FRAME_OFFSET))
#endif

typedef void DispatcherContext;		// Meaningless on Intel

#elif _M_MRX000 >= 4000 /*IFSTRIP=IGN*/
//
// On MIPS we don't have a registration node, just a pointer to the stack frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;					// changed the case of the name to conform to EH conventions

#elif defined(_M_ALPHA)
//
// On Alpha we don't have a registration node,
//     just a pointer to the stack frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)           __ERROR__
#define PRN_HANDLER(prn)        __ERROR__
#define PRN_STATE(prn)          __ERROR__
#define PRN_STACK(prn)          __ERROR__
#define PRN_FRAME(prn)          __ERROR__

#define FRAME_OFFSET            0
#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)();
    PVOID HandlerData;    // ptr to FuncInfo record
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;  // Virtual Frame Pointer
    PCONTEXT ContextRecord;
} DispatcherContext;            // changed the case of the name to conform to EH conventions

//
// _EHCONTEXT is a struct built in the frame by the compiler.
// On entry to a function, compiler generated code stores the
// address of the base of the fixed frame area (the so-called
// Real Frame Pointer) into the Rfp. On every state transition,
// compiler generated code stores the current state index into
// the State field.
//
// The FuncInfo record for the function contains the offset of
// the _EHCONTEXT record from the Virtual Frame Pointer - a
// pointer to the highest address of the frame so this offset
// is negative (frames grow down in the address space).
//
typedef struct _EHCONTEXT {
    ULONG State;
    PVOID Rfp;
} EHContext;

#define VIRTUAL_FP(pDC) (pDC->EstablisherFrame)

#define REAL_FP(VirtualFP, pFuncInfo)           \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> Rfp)

#define EH_STATE(VirtualFP, pFuncInfo)          \
    (((EHContext *)((char *)VirtualFP           \
     + pFuncInfo->EHContextDelta)) -> State)

#elif defined(_M_M68K)
struct EHRegistrationNode {
/*	void * 				_sp;			// The stack pointer for the entry of try/catch	*/
	void *				frameHandler;	// The handler function for this frame
	__ehstate_t			state;			// The current state of this function
};

#define PRN_HANDLER(prn)	((prn)->frameHandler)
#define PRN_STATE(prn)		((prn)->state)

typedef void DispatcherContext;		// Meaningless on Mac


#elif defined(_M_PPC) || defined(_M_MPPC)
//
// On PowerPC we don't have a registration node, just a pointer to the stack
// frame base
//
typedef ULONG EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

#define FRAME_OFFSET		0

#if !defined(_NTSUBSET_)
typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    EXCEPTION_DISPOSITION (*ExceptionHandler)(...);
    PVOID HandlerData;
    ULONG PrologEndAddress;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
#endif

typedef struct _xDISPATCHER_CONTEXT {
    ULONG ControlPc;
    PRUNTIME_FUNCTION FunctionEntry;
    ULONG EstablisherFrame;
    PCONTEXT ContextRecord;
} DispatcherContext;
    // changed the case of the name to conform to EH conventions

#if defined(_M_MPPC)
typedef struct _ftinfo {
    ULONG dwMagicNumber;                // magic number
    void *pFrameInfo;			// pointer to runtime frame info
    PRUNTIME_FUNCTION rgFuncTable;	// function table
    ULONG cFuncTable;			// number of function entry
    ULONG dwEntryCF;			// address of starting of the code fragment
    ULONG dwSizeCF;			// size of the code fragment
} FTINFO, *PFTINFO;

#define offsFTINFO              64
#endif

#elif defined(_M_IA64)

#if !defined(_NTSUBSET_)

struct _CONTEXT;
struct _EXCEPTION_RECORD;
typedef __int64 ULONGLONG;

typedef
EXCEPTION_DISPOSITION
(*PEXCEPTION_ROUTINE) (
    IN struct _EXCEPTION_RECORD *ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT struct _CONTEXT *ContextRecord,
    IN OUT PVOID DispatcherContext
    );

typedef struct _UNWIND_INFO {
    USHORT Version;                            // Version Number
    USHORT Flags;                              // Flags
    ULONG DataLength;                          // Length of Descriptor Data
    PVOID Descriptors;                         // Unwind Descriptors
} UNWIND_INFO, *PUNWIND_INFO;

typedef union _FRAME_POINTERS {
    struct {
        ULONG MemoryStackFp;
        ULONG BackingStoreFp;
    };
    ULONGLONG FramePointers;           // used to force 8-byte alignment
} FRAME_POINTERS, *PFRAME_POINTERS;

typedef struct _RUNTIME_FUNCTION {
    ULONG BeginAddress;
    ULONG EndAddress;
    PEXCEPTION_ROUTINE ExceptionHandler;
    PVOID HandlerData;
    PUNWIND_INFO UnwindData;
} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;

#endif

//
// On IA64 we don't have a registration node, just a pointer to the stack
// frame base and backing store base.
//
typedef FRAME_POINTERS EHRegistrationNode;

#define PRN_NEXT(prn)		__ERROR__
#define PRN_HANDLER(prn)	__ERROR__
#define PRN_STATE(prn)		__ERROR__
#define PRN_STACK(prn)		__ERROR__
#define PRN_FRAME(prn)		__ERROR__

typedef struct _xDISPATCHER_CONTEXT {
    FRAME_POINTERS EstablisherFrame;
    ULONG ControlPc;
    struct _RUNTIME_FUNCTION *FunctionEntry;
    PCONTEXT ContextRecord;
} DispatcherContext, *pDispatcherContext;

typedef struct _EHContext {
    PVOID Psp;
    LONG  State;
} EHContext;

#define EH_STATE_OFFSET -12

#define EH_STATE(pRN) \
    (*(int*)(pRN->MemoryStackFp + EH_STATE_OFFSET))

#else
#error "Machine not supported"
#endif


/////////////////////////////////////////////////////////////////////////////
//
// The NT Exception record that we use to pass information from the throw to
// the possible catches.
//
// The constants in the comments are the values we expect.
// This is based on the definition of EXCEPTION_RECORD in winnt.h.
//

typedef struct EHExceptionRecord {
	DWORD		ExceptionCode;			// The code of this exception. (= EH_EXCEPTION_NUMBER)
	DWORD		ExceptionFlags;			// Flags determined by NT
    struct _EXCEPTION_RECORD *ExceptionRecord;	// An extra exception record (not used)
    void * 		ExceptionAddress;		// Address at which exception occurred
    DWORD 		NumberParameters;		// Number of extended parameters. (= EH_EXCEPTION_PARAMETERS)
	struct EHParameters {
		DWORD		magicNumber;		// = EH_MAGIC_NUMBER1
		void *		pExceptionObject;	// Pointer to the actual object thrown
		ThrowInfo	*pThrowInfo;		// Description of thrown object
		} params;
} EHExceptionRecord;

#define PER_CODE(per)		((per)->ExceptionCode)
#define PER_FLAGS(per)		((per)->ExceptionFlags)
#define PER_NEXT(per)		((per)->ExceptionRecord)
#define PER_ADDRESS(per)	((per)->ExceptionAddress)
#define PER_NPARAMS(per)	((per)->NumberParameters)
#define PER_MAGICNUM(per)	((per)->params.magicNumber)
#define PER_PEXCEPTOBJ(per)	((per)->params.pExceptionObject)
#define PER_PTHROW(per)		((per)->params.pThrowInfo)
#define PER_THROW(per)		(*PER_PTHROW(per))

#define PER_ISSIMPLETYPE(t)	(PER_THROW(t).isSimpleType)
#define PER_ISREFERENCE(t)	(PER_THROW(t).isReference)
#define PER_ISCONST(t)		(PER_THROW(t).isConst)
#define PER_ISVOLATILE(t)	(PER_THROW(t).isVolatile)
#define PER_ISUNALIGNED(t)	(PER_THROW(t).isUnaligned)
#define PER_UNWINDFUNC(t)	(PER_THROW(t).pmfnUnwind)
#define PER_PCTLIST(t)		(PER_THROW(t).pCatchable)
#define PER_CTLIST(t)		(*PER_PCTLIST(t))

#define PER_IS_MSVC_EH(per)	((PER_CODE(per) == EH_EXCEPTION_NUMBER) && 			\
		 					 (PER_NPARAMS(per) == EH_EXCEPTION_PARAMETERS) &&	\
		 					 (PER_MAGICNUM(per) == EH_MAGIC_NUMBER1))



/////////////////////////////////////////////////////////////////////////////
//
// NT kernel routines and definitions required to implement exception handling:
//
// (from ntxcapi.h, which is not a public header file)
//
//---------------------------------------------------------------------------

#ifndef _NTXCAPI_

// begin_ntddk
//
// Exception flag definitions.
//

// begin_winnt
#define EXCEPTION_NONCONTINUABLE 0x1    // Noncontinuable exception
// end_winnt

// end_ntddk
#define EXCEPTION_UNWINDING 0x2         // Unwind is in progress
#define EXCEPTION_EXIT_UNWIND 0x4       // Exit unwind is in progress
#define EXCEPTION_STACK_INVALID 0x8     // Stack out of limits or unaligned
#define EXCEPTION_NESTED_CALL 0x10      // Nested exception handler call
#define EXCEPTION_TARGET_UNWIND 0x20    // Target unwind in progress
#define EXCEPTION_COLLIDED_UNWIND 0x40  // Collided exception handler call

#define EXCEPTION_UNWIND (EXCEPTION_UNWINDING | EXCEPTION_EXIT_UNWIND | \
                          EXCEPTION_TARGET_UNWIND | EXCEPTION_COLLIDED_UNWIND)

#define IS_UNWINDING(Flag) ((Flag & EXCEPTION_UNWIND) != 0)
#define IS_DISPATCHING(Flag) ((Flag & EXCEPTION_UNWIND) == 0)
#define IS_TARGET_UNWIND(Flag) (Flag & EXCEPTION_TARGET_UNWIND)
#define IS_EXIT_UNWIND(Flag) (Flag & EXCEPTION_EXIT_UNWIND)

#if !defined(_M_M68K)
#ifdef __cplusplus
extern "C" {
#endif

void WINAPI
RtlUnwind (
    IN void * TargetFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );

#if defined(_M_ALPHA)
#define STATUS_UNWIND 0xc0000027

void WINAPI
RtlUnwindRfp (
    IN void * TargetRealFrame OPTIONAL,
    IN void * TargetIp OPTIONAL,
    IN PEXCEPTION_RECORD ExceptionRecord OPTIONAL,
    IN void * ReturnValue
    );
#endif

#if defined(_M_PPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN ULONG ControlPc
    );
#endif

#if defined(_M_MPPC)
ULONG WINAPI
RtlVirtualUnwind (
    IN ULONG ControlPc,
    IN PRUNTIME_FUNCTION FunctionEntry,
    IN OUT PCONTEXT ContextRecord,
    OUT PBOOLEAN InFunction,
    OUT PULONG EstablisherFrame,
    IN OUT PVOID ContextPointers OPTIONAL,
    IN ULONG LowStackLimit,
    IN ULONG HighStackLimit
    );

PRUNTIME_FUNCTION
RtlLookupFunctionEntry (
    IN PRUNTIME_FUNCTION RuntimeFunction,
    IN ULONG ControlPc,
    IN ULONG Rtoc
    );

VOID
RtlRaiseException (
    IN PEXCEPTION_RECORD ExceptionRecord
    );
#endif

#ifdef __cplusplus
}
#endif
#endif

#endif /* _NTXCAPI_ */

#endif /* _EHDATA_NONT */

#pragma pack(pop, ehdata)

#endif /* _INC_EHDATA */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\sdktools\inc\ntdbg.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntdbg.h

Abstract:

    This module contains the public data structures, data types,
    and procedures exported by the NT Dbg subsystem.

Revision History:

--*/

#ifndef _NTDBG_
#define _NTDBG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif



//
// The following are explicitly sized versions of common system
// structures which appear in the kernel debugger API.
//
// All of the debugger structures which are exposed to both
// sides of the KD API are declared below in explicitly sized
// versions as well, with inline converter functions.
//

//
// Macro for sign extending 32 bit addresses into 64 bits
//

#define COPYSE(p64,p32,f) p64->f = (ULONG64)(LONG64)(LONG)p32->f

__inline
void
ExceptionRecord32To64(
    IN PEXCEPTION_RECORD32 Ex32,
    OUT PEXCEPTION_RECORD64 Ex64
    )
{
    ULONG i;
    Ex64->ExceptionCode = Ex32->ExceptionCode;
    Ex64->ExceptionFlags = Ex32->ExceptionFlags;
    Ex64->ExceptionRecord = Ex32->ExceptionRecord;
    COPYSE(Ex64,Ex32,ExceptionAddress);
    Ex64->NumberParameters = Ex32->NumberParameters;
    for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++) {
        COPYSE(Ex64,Ex32,ExceptionInformation[i]);
    }
}

__inline
void
ExceptionRecord64To32(
    IN PEXCEPTION_RECORD64 Ex64,
    OUT PEXCEPTION_RECORD32 Ex32
    )
{
    ULONG i;
    Ex32->ExceptionCode = Ex64->ExceptionCode;
    Ex32->ExceptionFlags = Ex64->ExceptionFlags;
    Ex32->ExceptionRecord = (ULONG) Ex64->ExceptionRecord;
    Ex32->ExceptionAddress = (ULONG) Ex64->ExceptionAddress;
    Ex32->NumberParameters = Ex64->NumberParameters;
    for (i = 0; i < EXCEPTION_MAXIMUM_PARAMETERS; i++) {
        Ex32->ExceptionInformation[i] = (ULONG) Ex64->ExceptionInformation[i];
    }
}


//
// DbgKm Apis are from the kernel component (Dbgk) through a process
// debug port.
//

#define DBGKM_MSG_OVERHEAD \
    (FIELD_OFFSET(DBGKM_APIMSG, u.Exception) - sizeof(PORT_MESSAGE))

#define DBGKM_API_MSG_LENGTH(TypeSize) \
    ((sizeof(DBGKM_APIMSG) << 16) | (DBGKM_MSG_OVERHEAD + (TypeSize)))

#define DBGKM_FORMAT_API_MSG(m,Number,TypeSize)             \
    (m).h.u1.Length = DBGKM_API_MSG_LENGTH((TypeSize));     \
    (m).h.u2.ZeroInit = LPC_DEBUG_EVENT;                    \
    (m).ApiNumber = (Number)

typedef enum _DBGKM_APINUMBER {
    DbgKmExceptionApi,
    DbgKmCreateThreadApi,
    DbgKmCreateProcessApi,
    DbgKmExitThreadApi,
    DbgKmExitProcessApi,
    DbgKmLoadDllApi,
    DbgKmUnloadDllApi,
    DbgKmMaxApiNumber
} DBGKM_APINUMBER;


#if !DBG_NO_PORTABLE_TYPES
typedef struct _DBGKM_EXCEPTION {
    EXCEPTION_RECORD ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION, *PDBGKM_EXCEPTION;
#endif

typedef struct _DBGKM_EXCEPTION32 {
    EXCEPTION_RECORD32 ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION32, *PDBGKM_EXCEPTION32;

typedef struct _DBGKM_EXCEPTION64 {
    EXCEPTION_RECORD64 ExceptionRecord;
    ULONG FirstChance;
} DBGKM_EXCEPTION64, *PDBGKM_EXCEPTION64;

__inline
void
DbgkmException32To64(
    IN PDBGKM_EXCEPTION32 E32,
    OUT PDBGKM_EXCEPTION64 E64
    )
{
    ExceptionRecord32To64(&E32->ExceptionRecord, &E64->ExceptionRecord);
    E64->FirstChance = E32->FirstChance;
}

__inline
void
DbgkmException64To32(
    IN PDBGKM_EXCEPTION64 E64,
    OUT PDBGKM_EXCEPTION32 E32
    )
{
    ExceptionRecord64To32(&E64->ExceptionRecord, &E32->ExceptionRecord);
    E32->FirstChance = E64->FirstChance;
}


//
// The DbgSS, DbgKm and DbgSs stuff is not needed in the portable debugger,
// and some of the following types and prototypes use portable types, so just
// turn them all off when building the debugger.
//

#if !DBG_NO_PORTABLE_TYPES
typedef struct _DBGKM_CREATE_THREAD {
    ULONG SubSystemKey;
    PVOID StartAddress;
} DBGKM_CREATE_THREAD, *PDBGKM_CREATE_THREAD;

typedef struct _DBGKM_CREATE_PROCESS {
    ULONG SubSystemKey;
    HANDLE FileHandle;
    PVOID BaseOfImage;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
    DBGKM_CREATE_THREAD InitialThread;
} DBGKM_CREATE_PROCESS, *PDBGKM_CREATE_PROCESS;

typedef struct _DBGKM_EXIT_THREAD {
    NTSTATUS ExitStatus;
} DBGKM_EXIT_THREAD, *PDBGKM_EXIT_THREAD;

typedef struct _DBGKM_EXIT_PROCESS {
    NTSTATUS ExitStatus;
} DBGKM_EXIT_PROCESS, *PDBGKM_EXIT_PROCESS;

typedef struct _DBGKM_LOAD_DLL {
    HANDLE FileHandle;
    PVOID BaseOfDll;
    ULONG DebugInfoFileOffset;
    ULONG DebugInfoSize;
} DBGKM_LOAD_DLL, *PDBGKM_LOAD_DLL;

typedef struct _DBGKM_UNLOAD_DLL {
    PVOID BaseAddress;
} DBGKM_UNLOAD_DLL, *PDBGKM_UNLOAD_DLL;

typedef struct _DBGKM_APIMSG {
    PORT_MESSAGE h;
    DBGKM_APINUMBER ApiNumber;
    NTSTATUS ReturnedStatus;
    union {
        DBGKM_EXCEPTION Exception;
        DBGKM_CREATE_THREAD CreateThread;
        DBGKM_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } u;
} DBGKM_APIMSG, *PDBGKM_APIMSG;

//
// DbgSrv Messages are from Dbg subsystem to emulation subsystem.
// The only defined message at this time is continue
//

#define DBGSRV_MSG_OVERHEAD \
    (sizeof(DBGSRV_APIMSG) - sizeof(PORT_MESSAGE))

#define DBGSRV_API_MSG_LENGTH(TypeSize) \
    ((sizeof(DBGSRV_APIMSG) << 16) | (DBGSRV_MSG_OVERHEAD))

#define DBGSRV_FORMAT_API_MSG(m,Number,TypeSize,CKey)     \
    (m).h.u1.Length = DBGSRV_API_MSG_LENGTH((TypeSize));  \
    (m).h.u2.ZeroInit = 0L;                               \
    (m).ApiNumber = (Number);                             \
    (m).ContinueKey = (PVOID)(CKey)

typedef enum _DBGSRV_APINUMBER {
    DbgSrvContinueApi,
    DbgSrvMaxApiNumber
} DBGSRV_APINUMBER;

typedef struct _DBGSRV_APIMSG {
    PORT_MESSAGE h;
    DBGSRV_APINUMBER ApiNumber;
    NTSTATUS ReturnedStatus;
    PVOID ContinueKey;
} DBGSRV_APIMSG, *PDBGSRV_APIMSG;

//
//
// DbgSs Apis are from the system service emulation subsystems to the Dbg
// subsystem
//

typedef enum _DBG_STATE {
    DbgIdle,
    DbgReplyPending,
    DbgCreateThreadStateChange,
    DbgCreateProcessStateChange,
    DbgExitThreadStateChange,
    DbgExitProcessStateChange,
    DbgExceptionStateChange,
    DbgBreakpointStateChange,
    DbgSingleStepStateChange,
    DbgLoadDllStateChange,
    DbgUnloadDllStateChange
} DBG_STATE, *PDBG_STATE;

#define DBGSS_MSG_OVERHEAD \
    (FIELD_OFFSET(DBGSS_APIMSG, u.Exception) - sizeof(PORT_MESSAGE))

#define DBGSS_API_MSG_LENGTH(TypeSize) \
    ((sizeof(DBGSS_APIMSG) << 16) | (DBGSS_MSG_OVERHEAD + (TypeSize)))

#define DBGSS_FORMAT_API_MSG(m,Number,TypeSize,pApp,CKey)  \
    (m).h.u1.Length = DBGSS_API_MSG_LENGTH((TypeSize));   \
    (m).h.u2.ZeroInit = 0L;                               \
    (m).ApiNumber = (Number);                             \
    (m).AppClientId = *(pApp);                            \
    (m).ContinueKey = (PVOID)(CKey)

typedef enum _DBGSS_APINUMBER {
    DbgSsExceptionApi,
    DbgSsCreateThreadApi,
    DbgSsCreateProcessApi,
    DbgSsExitThreadApi,
    DbgSsExitProcessApi,
    DbgSsLoadDllApi,
    DbgSsUnloadDllApi,
    DbgSsMaxApiNumber
} DBGSS_APINUMBER;

typedef struct _DBGSS_CREATE_PROCESS {
    CLIENT_ID DebugUiClientId;
    DBGKM_CREATE_PROCESS NewProcess;
} DBGSS_CREATE_PROCESS, *PDBGSS_CREATE_PROCESS;

typedef struct _DBGSS_APIMSG {
    PORT_MESSAGE h;
    DBGKM_APINUMBER ApiNumber;
    NTSTATUS ReturnedStatus;
    CLIENT_ID AppClientId;
    PVOID ContinueKey;
    union {
        DBGKM_EXCEPTION Exception;
        DBGKM_CREATE_THREAD CreateThread;
        DBGSS_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } u;
} DBGSS_APIMSG, *PDBGSS_APIMSG;

#define DBGUI_MSG_OVERHEAD \
    (FIELD_OFFSET(DBGUI_APIMSG, u.Continue) - sizeof(PORT_MESSAGE))

#define DBGUI_API_MSG_LENGTH(TypeSize) \
    ((sizeof(DBGUI_APIMSG) << 16) | (DBGUI_MSG_OVERHEAD + (TypeSize)))

#define DBGUI_FORMAT_API_MSG(m,Number,TypeSize)            \
    (m).h.u1.Length = DBGUI_API_MSG_LENGTH((TypeSize));     \
    (m).h.u2.ZeroInit = 0L;                               \
    (m).ApiNumber = (Number)

typedef enum _DBGUI_APINUMBER {
    DbgUiWaitStateChangeApi,
    DbgUiContinueApi,
    DbgUiStopDebugApi,
    DbgUiMaxApiNumber
} DBGUI_APINUMBER;

typedef struct _DBGUI_CREATE_THREAD {
    HANDLE HandleToThread;
    DBGKM_CREATE_THREAD NewThread;
} DBGUI_CREATE_THREAD, *PDBGUI_CREATE_THREAD;

typedef struct _DBGUI_CREATE_PROCESS {
    HANDLE HandleToProcess;
    HANDLE HandleToThread;
    DBGKM_CREATE_PROCESS NewProcess;
} DBGUI_CREATE_PROCESS, *PDBGUI_CREATE_PROCESS;

typedef struct _DBGUI_WAIT_STATE_CHANGE {
    DBG_STATE NewState;
    CLIENT_ID AppClientId;
    union {
        DBGKM_EXCEPTION Exception;
        DBGUI_CREATE_THREAD CreateThread;
        DBGUI_CREATE_PROCESS CreateProcessInfo;
        DBGKM_EXIT_THREAD ExitThread;
        DBGKM_EXIT_PROCESS ExitProcess;
        DBGKM_LOAD_DLL LoadDll;
        DBGKM_UNLOAD_DLL UnloadDll;
    } StateInfo;
} DBGUI_WAIT_STATE_CHANGE, *PDBGUI_WAIT_STATE_CHANGE;

typedef struct _DBGUI_CONTINUE {
    CLIENT_ID AppClientId;
    NTSTATUS ContinueStatus;
} DBGUI_CONTINUE, *PDBGUI_CONTINUE;

typedef struct _DBGUI_STOPDEBUG {
    ULONG ProcessId;
} DBGUI_STOPDEBUG, *PDBGUI_STOPDEBUG;

typedef struct _DBGUI_APIMSG {
    PORT_MESSAGE h;
    union {
        HANDLE DbgStateChangeSemaphore;
        struct {
            DBGKM_APINUMBER ApiNumber;
            NTSTATUS ReturnedStatus;
            union {
                DBGUI_CONTINUE Continue;
                DBGUI_WAIT_STATE_CHANGE WaitStateChange;
                DBGUI_STOPDEBUG StopDebug;
            } u;
        };
    };
} DBGUI_APIMSG, *PDBGUI_APIMSG;

typedef
NTSTATUS
(*PDBGSS_UI_LOOKUP) (
    IN PCLIENT_ID AppClientId,
    OUT PCLIENT_ID DebugUiClientId
    );

typedef
NTSTATUS
(*PDBGSS_DBGKM_APIMSG_FILTER) (
    IN OUT PDBGKM_APIMSG ApiMsg
    );

typedef
NTSTATUS
(*PDBGSS_SUBSYSTEMKEY_LOOKUP) (
    IN PCLIENT_ID AppClientId,
    OUT PULONG SubsystemKey,
    IN BOOLEAN ProcessKey
    );
//
// DbgSs APIs
//

NTSTATUS
NTAPI
DbgSsInitialize(
    IN HANDLE KmReplyPort,
    IN PDBGSS_UI_LOOKUP UiLookUpRoutine,
    IN PDBGSS_SUBSYSTEMKEY_LOOKUP SubsystemKeyLookupRoutine OPTIONAL,
    IN PDBGSS_DBGKM_APIMSG_FILTER KmApiMsgFilter OPTIONAL
    );

VOID
NTAPI
DbgSsHandleKmApiMsg(
    IN PDBGKM_APIMSG ApiMsg,
    IN HANDLE ReplyEvent OPTIONAL
    );

typedef
NTSTATUS
(*PDBGSS_INITIALIZE_ROUTINE)(
    IN HANDLE KmReplyPort,
    IN PDBGSS_UI_LOOKUP UiLookUpRoutine,
    IN PDBGSS_SUBSYSTEMKEY_LOOKUP SubsystemKeyLookupRoutine OPTIONAL,
    IN PDBGSS_DBGKM_APIMSG_FILTER KmApiMsgFilter OPTIONAL
    );

typedef
VOID
(*PDBGSS_HANDLE_MSG_ROUTINE)(
    IN PDBGKM_APIMSG ApiMsg,
    IN HANDLE ReplyEvent OPTIONAL
    );

//
// DbgUi APIs
//

NTSTATUS
NTAPI
DbgUiConnectToDbg( VOID );

HANDLE
NTAPI
DbgUiGetThreadDebugObject (
    );

VOID
NTAPI
DbgUiSetThreadDebugObject (
    IN HANDLE DebugObject
    );

NTSTATUS
NTAPI
DbgUiWaitStateChange (
    OUT PDBGUI_WAIT_STATE_CHANGE StateChange,
    IN PLARGE_INTEGER Timeout OPTIONAL
    );

NTSTATUS
NTAPI
DbgUiContinue (
    IN PCLIENT_ID AppClientId,
    IN NTSTATUS ContinueStatus
    );

NTSTATUS
NTAPI
DbgUiStopDebugging (
    IN HANDLE Process
    );

NTSTATUS
DbgUiDebugActiveProcess (
     IN HANDLE Process
     );

VOID
DbgUiRemoteBreakin (
    IN PVOID Context
    );

NTSTATUS
DbgUiIssueRemoteBreakin (
    IN HANDLE Process
    );

struct _DEBUG_EVENT;

NTSTATUS
DbgUiConvertStateChangeStructure (
    IN PDBGUI_WAIT_STATE_CHANGE StateChange,
    OUT struct _DEBUG_EVENT *DebugEvent);

#endif // DBG_NO_PORTABLE_TYPES





typedef struct _KAPC_STATE32 {
    LIST_ENTRY32 ApcListHead[2];
    ULONG Process;
    BOOLEAN KernelApcInProgress;
    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
} KAPC_STATE32;

typedef struct _KAPC_STATE64 {
    LIST_ENTRY64 ApcListHead[2];
    ULONG64 Process;
    BOOLEAN KernelApcInProgress;
    BOOLEAN KernelApcPending;
    BOOLEAN UserApcPending;
} KAPC_STATE64;

typedef struct _DISPATCHER_HEADER32 {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY32 WaitListHead;
} DISPATCHER_HEADER32;

typedef struct _DISPATCHER_HEADER64 {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY64 WaitListHead;
} DISPATCHER_HEADER64;

typedef struct _KSPIN_LOCK_QUEUE32 {
    ULONG Next;
    ULONG Lock;
} KSPIN_LOCK_QUEUE32, *PKSPIN_LOCK_QUEUE32;

typedef struct _KSPIN_LOCK_QUEUE64 {
    ULONG64 Next;
    ULONG64 Lock;
} KSPIN_LOCK_QUEUE64, *PKSPIN_LOCK_QUEUE64;

typedef struct _PP_LOOKASIDE_LIST32 {
    ULONG P;
    ULONG L;
} PP_LOOKASIDE_LIST32, *PPP_LOOKASIDE_LIST32;

typedef struct _PP_LOOKASIDE_LIST64 {
    ULONG P;
    ULONG L;
} PP_LOOKASIDE_LIST64, *PPP_LOOKASIDE_LIST64;

#define NT51_POOL_SMALL_LISTS 32


typedef struct _X86_THREAD {

    //
    // The dispatcher header and mutant listhead are fairly infrequently
    // referenced, but pad the thread to a 32-byte boundary (assumption
    // that pool allocation is in units of 32-bytes).
    //

    DISPATCHER_HEADER32 Header;
    LIST_ENTRY32 MutantListHead;

    //
    // The following fields are referenced during trap, interrupts, or
    // context switches.
    //
    // N.B. The Teb address and TlsArray are loaded as a quadword quantity
    //      on MIPS and therefore must be on a quadword boundary.
    //

    ULONG InitialStack;
    ULONG StackLimit;
    ULONG Teb;
    ULONG TlsArray;
    ULONG KernelStack;
    BOOLEAN DebugActive;
    UCHAR State;
    BOOLEAN Alerted[2];
    UCHAR Iopl;
    UCHAR NpxState;
    CHAR Saturation;
    SCHAR Priority;
    KAPC_STATE32 ApcState;
} X86_THREAD;


typedef struct _ALPHA_THREAD {

    //
    // The dispatcher header and mutant listhead are fairly infrequently
    // referenced, but pad the thread to a 32-byte boundary (assumption
    // that pool allocation is in units of 32-bytes).
    //

    DISPATCHER_HEADER32 Header;
    LIST_ENTRY32 MutantListHead;

    //
    // The following fields are referenced during trap, interrupts, or
    // context switches.
    //
    // N.B. The Teb address and TlsArray are loaded as a quadword quantity
    //      on MIPS and therefore must be on a quadword boundary.
    //

    ULONG InitialStack;
    ULONG StackLimit;
    ULONG Teb;
    ULONG TlsArray;
    ULONG KernelStack;
    BOOLEAN DebugActive;
    UCHAR State;
    BOOLEAN Alerted[2];
    UCHAR Iopl;
    UCHAR NpxState;
    CHAR Saturation;
    SCHAR Priority;
    KAPC_STATE32 ApcState;
} ALPHA_THREAD, *PALPHA_THREAD;


typedef struct _AXP64_THREAD {

    //
    // The dispatcher header and mutant listhead are fairly infrequently
    // referenced, but pad the thread to a 32-byte boundary (assumption
    // that pool allocation is in units of 32-bytes).
    //

    DISPATCHER_HEADER64 Header;
    LIST_ENTRY64 MutantListHead;

    //
    // The following fields are referenced during trap, interrupts, or
    // context switches.
    //
    // N.B. The Teb address and TlsArray are loaded as a quadword quantity
    //      on MIPS and therefore must be on a quadword boundary.
    //

    ULONG64 InitialStack;
    ULONG64 StackLimit;
    ULONG64 Teb;
    ULONG64 TlsArray;
    ULONG64 KernelStack;
    BOOLEAN DebugActive;
    UCHAR State;
    BOOLEAN Alerted[2];
    UCHAR Iopl;
    UCHAR NpxState;
    CHAR Saturation;
    SCHAR Priority;
    KAPC_STATE64 ApcState;
} AXP64_THREAD;


typedef struct _IA64_THREAD {

    //
    // The dispatcher header and mutant listhead are fairly infrequently
    // referenced, but pad the thread to a 32-byte boundary (assumption
    // that pool allocation is in units of 32-bytes).
    //

    DISPATCHER_HEADER64 Header;
    LIST_ENTRY64 MutantListHead;

    //
    // The following fields are referenced during trap, interrupts, or
    // context switches.
    //
    // N.B. The Teb address and TlsArray are loaded as a quadword quantity
    //      on MIPS and therefore must be on a quadword boundary.
    //

    ULONG64 InitialStack;
    ULONG64 StackLimit;
    ULONG64 InitialBStore;
    ULONG64 BStoreLimit;
    CCHAR Number;
    ULONG64 Teb;
    ULONG64 TlsArray;
    ULONG64 KernelStack;
    ULONG64 KernelBStore;
    BOOLEAN DebugActive;
    UCHAR State;
    BOOLEAN Alerted[2];
    UCHAR Iopl;
    UCHAR NpxState;
    CHAR Saturation;
    SCHAR Priority;
    KAPC_STATE64 ApcState;
} IA64_THREAD;

typedef struct _AMD64_THREAD {

    //
    // The dispatcher header and mutant listhead are fairly infrequently
    // referenced, but pad the thread to a 32-byte boundary (assumption
    // that pool allocation is in units of 32-bytes).
    //

    DISPATCHER_HEADER64 Header;
    LIST_ENTRY64 MutantListHead;

    //
    // The following fields are referenced during trap, interrupts, or
    // context switches.
    //
    // N.B. The Teb address and TlsArray are loaded as a quadword quantity
    //      on MIPS and therefore must be on a quadword boundary.
    //

    ULONG64 InitialStack;
    ULONG64 StackLimit;
    ULONG64 Teb;
    ULONG64 TlsArray;
    ULONG64 KernelStack;
    BOOLEAN DebugActive;
    UCHAR State;
    BOOLEAN Alerted[2];
    UCHAR Iopl;
    UCHAR NpxState;
    CHAR Saturation;
    SCHAR Priority;
    KAPC_STATE64 ApcState;
} AMD64_THREAD;


typedef struct _CROSS_PLATFORM_THREAD {

    union {
        X86_THREAD   X86Thread;
        ALPHA_THREAD AlphaThread;
        AXP64_THREAD Axp64Thread;
        IA64_THREAD  IA64Thread;
        AMD64_THREAD Amd64Thread;
    };

} CROSS_PLATFORM_THREAD, *PCROSS_PLATFORM_THREAD;


//
// X86 KSWITCHFRAME
//
typedef struct _X86_KSWITCHFRAME {
    ULONG   ExceptionList;
    ULONG   Eflags;
    ULONG   RetAddr;
} X86_KSWITCHFRAME, *PX86_KSWITCHFRAME;


//
// Special Registers for i386
//

typedef struct _X86_DESCRIPTOR {
    USHORT  Pad;
    USHORT  Limit;
    ULONG   Base;
} X86_DESCRIPTOR, *PX86_DESCRIPTOR;

typedef struct _X86_KSPECIAL_REGISTERS {
    ULONG Cr0;
    ULONG Cr2;
    ULONG Cr3;
    ULONG Cr4;
    ULONG KernelDr0;
    ULONG KernelDr1;
    ULONG KernelDr2;
    ULONG KernelDr3;
    ULONG KernelDr6;
    ULONG KernelDr7;
    X86_DESCRIPTOR Gdtr;
    X86_DESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG Reserved[6];
} X86_KSPECIAL_REGISTERS, *PX86_KSPECIAL_REGISTERS;


//
//  Define the size of the 80387 save area, which is in the context frame.
//

#define X86_SIZE_OF_80387_REGISTERS      80

typedef struct _X86_FLOATING_SAVE_AREA {
    ULONG   ControlWord;
    ULONG   StatusWord;
    ULONG   TagWord;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    UCHAR   RegisterArea[X86_SIZE_OF_80387_REGISTERS];
    ULONG   Cr0NpxState;
} X86_FLOATING_SAVE_AREA;

//
// Simulated context structure for the 16-bit environment
//

typedef struct _X86_CONTEXT {

    ULONG ContextFlags;
    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;
    X86_FLOATING_SAVE_AREA FloatSave;
    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;
    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;
    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;

} X86_CONTEXT, *PX86_CONTEXT;

#define MAXIMUM_SUPPORTED_EXTENSION     512

//
// Define the size of FP registers in the FXSAVE format
//
#define X86_SIZE_OF_FX_REGISTERS        128

typedef struct _X86_FXSAVE_FORMAT {
    USHORT  ControlWord;
    USHORT  StatusWord;
    USHORT  TagWord;
    USHORT  ErrorOpcode;
    ULONG   ErrorOffset;
    ULONG   ErrorSelector;
    ULONG   DataOffset;
    ULONG   DataSelector;
    ULONG   MXCsr;
    ULONG   Reserved2;
    UCHAR   RegisterArea[X86_SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved3[X86_SIZE_OF_FX_REGISTERS];
    UCHAR   Reserved4[224];
} X86_FXSAVE_FORMAT, *PX86_FXSAVE_FORMAT;

typedef struct _X86_NT5_CONTEXT {

    ULONG ContextFlags;
    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;
    X86_FLOATING_SAVE_AREA FloatSave;
    ULONG   SegGs;
    ULONG   SegFs;
    ULONG   SegEs;
    ULONG   SegDs;
    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;
    ULONG   Ebp;
    ULONG   Eip;
    ULONG   SegCs;              // MUST BE SANITIZED
    ULONG   EFlags;             // MUST BE SANITIZED
    ULONG   Esp;
    ULONG   SegSs;
    union {
        UCHAR   ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];
        X86_FXSAVE_FORMAT FxSave;
    };

} X86_NT5_CONTEXT, *PX86_NT5_CONTEXT;

typedef struct _ALPHA_CONTEXT {

    ULONG FltF0;
    ULONG FltF1;
    ULONG FltF2;
    ULONG FltF3;
    ULONG FltF4;
    ULONG FltF5;
    ULONG FltF6;
    ULONG FltF7;
    ULONG FltF8;
    ULONG FltF9;
    ULONG FltF10;
    ULONG FltF11;
    ULONG FltF12;
    ULONG FltF13;
    ULONG FltF14;
    ULONG FltF15;
    ULONG FltF16;
    ULONG FltF17;
    ULONG FltF18;
    ULONG FltF19;
    ULONG FltF20;
    ULONG FltF21;
    ULONG FltF22;
    ULONG FltF23;
    ULONG FltF24;
    ULONG FltF25;
    ULONG FltF26;
    ULONG FltF27;
    ULONG FltF28;
    ULONG FltF29;
    ULONG FltF30;
    ULONG FltF31;

    ULONG IntV0;        //  $0: return value register, v0
    ULONG IntT0;        //  $1: temporary registers, t0 - t7
    ULONG IntT1;        //  $2:
    ULONG IntT2;        //  $3:
    ULONG IntT3;        //  $4:
    ULONG IntT4;        //  $5:
    ULONG IntT5;        //  $6:
    ULONG IntT6;        //  $7:
    ULONG IntT7;        //  $8:
    ULONG IntS0;        //  $9: nonvolatile registers, s0 - s5
    ULONG IntS1;        // $10:
    ULONG IntS2;        // $11:
    ULONG IntS3;        // $12:
    ULONG IntS4;        // $13:
    ULONG IntS5;        // $14:
    ULONG IntFp;        // $15: frame pointer register, fp/s6
    ULONG IntA0;        // $16: argument registers, a0 - a5
    ULONG IntA1;        // $17:
    ULONG IntA2;        // $18:
    ULONG IntA3;        // $19:
    ULONG IntA4;        // $20:
    ULONG IntA5;        // $21:
    ULONG IntT8;        // $22: temporary registers, t8 - t11
    ULONG IntT9;        // $23:
    ULONG IntT10;       // $24:
    ULONG IntT11;       // $25:
    ULONG IntRa;        // $26: return address register, ra
    ULONG IntT12;       // $27: temporary register, t12
    ULONG IntAt;        // $28: assembler temp register, at
    ULONG IntGp;        // $29: global pointer register, gp
    ULONG IntSp;        // $30: stack pointer register, sp
    ULONG IntZero;      // $31: zero register, zero

    ULONG Fpcr;         // floating point control register
    ULONG SoftFpcr;     // software extension to FPCR

    ULONG Fir;          // (fault instruction) continuation address

    ULONG Psr;          // processor status
    ULONG ContextFlags;

    //
    // Beginning of the "second half".
    // The name "High" parallels the HighPart of a LargeInteger.
    //

    ULONG HighFltF0;
    ULONG HighFltF1;
    ULONG HighFltF2;
    ULONG HighFltF3;
    ULONG HighFltF4;
    ULONG HighFltF5;
    ULONG HighFltF6;
    ULONG HighFltF7;
    ULONG HighFltF8;
    ULONG HighFltF9;
    ULONG HighFltF10;
    ULONG HighFltF11;
    ULONG HighFltF12;
    ULONG HighFltF13;
    ULONG HighFltF14;
    ULONG HighFltF15;
    ULONG HighFltF16;
    ULONG HighFltF17;
    ULONG HighFltF18;
    ULONG HighFltF19;
    ULONG HighFltF20;
    ULONG HighFltF21;
    ULONG HighFltF22;
    ULONG HighFltF23;
    ULONG HighFltF24;
    ULONG HighFltF25;
    ULONG HighFltF26;
    ULONG HighFltF27;
    ULONG HighFltF28;
    ULONG HighFltF29;
    ULONG HighFltF30;
    ULONG HighFltF31;

    ULONG HighIntV0;        //  $0: return value register, v0
    ULONG HighIntT0;        //  $1: temporary registers, t0 - t7
    ULONG HighIntT1;        //  $2:
    ULONG HighIntT2;        //  $3:
    ULONG HighIntT3;        //  $4:
    ULONG HighIntT4;        //  $5:
    ULONG HighIntT5;        //  $6:
    ULONG HighIntT6;        //  $7:
    ULONG HighIntT7;        //  $8:
    ULONG HighIntS0;        //  $9: nonvolatile registers, s0 - s5
    ULONG HighIntS1;        // $10:
    ULONG HighIntS2;        // $11:
    ULONG HighIntS3;        // $12:
    ULONG HighIntS4;        // $13:
    ULONG HighIntS5;        // $14:
    ULONG HighIntFp;        // $15: frame pointer register, fp/s6
    ULONG HighIntA0;        // $16: argument registers, a0 - a5
    ULONG HighIntA1;        // $17:
    ULONG HighIntA2;        // $18:
    ULONG HighIntA3;        // $19:
    ULONG HighIntA4;        // $20:
    ULONG HighIntA5;        // $21:
    ULONG HighIntT8;        // $22: temporary registers, t8 - t11
    ULONG HighIntT9;        // $23:
    ULONG HighIntT10;       // $24:
    ULONG HighIntT11;       // $25:
    ULONG HighIntRa;        // $26: return address register, ra
    ULONG HighIntT12;       // $27: temporary register, t12
    ULONG HighIntAt;        // $28: assembler temp register, at
    ULONG HighIntGp;        // $29: global pointer register, gp
    ULONG HighIntSp;        // $30: stack pointer register, sp
    ULONG HighIntZero;      // $31: zero register, zero

    ULONG HighFpcr;         // floating point control register
    ULONG HighSoftFpcr;     // software extension to FPCR
    ULONG HighFir;          // processor status

    double DoNotUseThisField; // to force quadword structure alignment
    ULONG HighFill[2];      // padding for 16-byte stack frame alignment


} ALPHA_CONTEXT, *PALPHA_CONTEXT;


typedef struct _ALPHA_NT5_CONTEXT {

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    ULONGLONG FltF0;
    ULONGLONG FltF1;
    ULONGLONG FltF2;
    ULONGLONG FltF3;
    ULONGLONG FltF4;
    ULONGLONG FltF5;
    ULONGLONG FltF6;
    ULONGLONG FltF7;
    ULONGLONG FltF8;
    ULONGLONG FltF9;
    ULONGLONG FltF10;
    ULONGLONG FltF11;
    ULONGLONG FltF12;
    ULONGLONG FltF13;
    ULONGLONG FltF14;
    ULONGLONG FltF15;
    ULONGLONG FltF16;
    ULONGLONG FltF17;
    ULONGLONG FltF18;
    ULONGLONG FltF19;
    ULONGLONG FltF20;
    ULONGLONG FltF21;
    ULONGLONG FltF22;
    ULONGLONG FltF23;
    ULONGLONG FltF24;
    ULONGLONG FltF25;
    ULONGLONG FltF26;
    ULONGLONG FltF27;
    ULONGLONG FltF28;
    ULONGLONG FltF29;
    ULONGLONG FltF30;
    ULONGLONG FltF31;

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    // N.B. The registers gp, sp, and ra are defined in this section, but are
    //  considered part of the control context rather than part of the integer
    //  context.
    //

    ULONGLONG IntV0;    //  $0: return value register, v0
    ULONGLONG IntT0;    //  $1: temporary registers, t0 - t7
    ULONGLONG IntT1;    //  $2:
    ULONGLONG IntT2;    //  $3:
    ULONGLONG IntT3;    //  $4:
    ULONGLONG IntT4;    //  $5:
    ULONGLONG IntT5;    //  $6:
    ULONGLONG IntT6;    //  $7:
    ULONGLONG IntT7;    //  $8:
    ULONGLONG IntS0;    //  $9: nonvolatile registers, s0 - s5
    ULONGLONG IntS1;    // $10:
    ULONGLONG IntS2;    // $11:
    ULONGLONG IntS3;    // $12:
    ULONGLONG IntS4;    // $13:
    ULONGLONG IntS5;    // $14:
    ULONGLONG IntFp;    // $15: frame pointer register, fp/s6
    ULONGLONG IntA0;    // $16: argument registers, a0 - a5
    ULONGLONG IntA1;    // $17:
    ULONGLONG IntA2;    // $18:
    ULONGLONG IntA3;    // $19:
    ULONGLONG IntA4;    // $20:
    ULONGLONG IntA5;    // $21:
    ULONGLONG IntT8;    // $22: temporary registers, t8 - t11
    ULONGLONG IntT9;    // $23:
    ULONGLONG IntT10;   // $24:
    ULONGLONG IntT11;   // $25:
    ULONGLONG IntRa;    // $26: return address register, ra
    ULONGLONG IntT12;   // $27: temporary register, t12
    ULONGLONG IntAt;    // $28: assembler temp register, at
    ULONGLONG IntGp;    // $29: global pointer register, gp
    ULONGLONG IntSp;    // $30: stack pointer register, sp
    ULONGLONG IntZero;  // $31: zero register, zero

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_FLOATING_POINT.
    //

    ULONGLONG Fpcr;     // floating point control register
    ULONGLONG SoftFpcr; // software extension to FPCR

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //
    // N.B. The registers gp, sp, and ra are defined in the integer section,
    //   but are considered part of the control context rather than part of
    //   the integer context.
    //

    ULONGLONG Fir;      // (fault instruction) continuation address
    ULONG Psr;          // processor status

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;
    ULONG Fill[4];      // padding for 16-byte stack frame alignment

} ALPHA_NT5_CONTEXT, *PALPHA_NT5_CONTEXT;


typedef struct _IA64_KSPECIAL_REGISTERS {  // Intel-IA64-Filler

    // Kernel debug breakpoint registers       // Intel-IA64-Filler

    ULONGLONG KernelDbI0;         // Instruction debug registers       // Intel-IA64-Filler
    ULONGLONG KernelDbI1;       // Intel-IA64-Filler
    ULONGLONG KernelDbI2;       // Intel-IA64-Filler
    ULONGLONG KernelDbI3;       // Intel-IA64-Filler
    ULONGLONG KernelDbI4;       // Intel-IA64-Filler
    ULONGLONG KernelDbI5;       // Intel-IA64-Filler
    ULONGLONG KernelDbI6;       // Intel-IA64-Filler
    ULONGLONG KernelDbI7;       // Intel-IA64-Filler

    ULONGLONG KernelDbD0;         // Data debug registers       // Intel-IA64-Filler
    ULONGLONG KernelDbD1;       // Intel-IA64-Filler
    ULONGLONG KernelDbD2;       // Intel-IA64-Filler
    ULONGLONG KernelDbD3;       // Intel-IA64-Filler
    ULONGLONG KernelDbD4;       // Intel-IA64-Filler
    ULONGLONG KernelDbD5;       // Intel-IA64-Filler
    ULONGLONG KernelDbD6;       // Intel-IA64-Filler
    ULONGLONG KernelDbD7;       // Intel-IA64-Filler

    // Kernel performance monitor registers       // Intel-IA64-Filler

    ULONGLONG KernelPfC0;         // Performance configuration registers       // Intel-IA64-Filler
    ULONGLONG KernelPfC1;       // Intel-IA64-Filler
    ULONGLONG KernelPfC2;       // Intel-IA64-Filler
    ULONGLONG KernelPfC3;       // Intel-IA64-Filler
    ULONGLONG KernelPfC4;       // Intel-IA64-Filler
    ULONGLONG KernelPfC5;       // Intel-IA64-Filler
    ULONGLONG KernelPfC6;       // Intel-IA64-Filler
    ULONGLONG KernelPfC7;       // Intel-IA64-Filler

    ULONGLONG KernelPfD0;         // Performance data registers       // Intel-IA64-Filler
    ULONGLONG KernelPfD1;       // Intel-IA64-Filler
    ULONGLONG KernelPfD2;       // Intel-IA64-Filler
    ULONGLONG KernelPfD3;       // Intel-IA64-Filler
    ULONGLONG KernelPfD4;       // Intel-IA64-Filler
    ULONGLONG KernelPfD5;       // Intel-IA64-Filler
    ULONGLONG KernelPfD6;       // Intel-IA64-Filler
    ULONGLONG KernelPfD7;       // Intel-IA64-Filler

    // kernel bank shadow (hidden) registers       // Intel-IA64-Filler

    ULONGLONG IntH16;       // Intel-IA64-Filler
    ULONGLONG IntH17;       // Intel-IA64-Filler
    ULONGLONG IntH18;       // Intel-IA64-Filler
    ULONGLONG IntH19;       // Intel-IA64-Filler
    ULONGLONG IntH20;       // Intel-IA64-Filler
    ULONGLONG IntH21;       // Intel-IA64-Filler
    ULONGLONG IntH22;       // Intel-IA64-Filler
    ULONGLONG IntH23;       // Intel-IA64-Filler
    ULONGLONG IntH24;       // Intel-IA64-Filler
    ULONGLONG IntH25;       // Intel-IA64-Filler
    ULONGLONG IntH26;       // Intel-IA64-Filler
    ULONGLONG IntH27;       // Intel-IA64-Filler
    ULONGLONG IntH28;       // Intel-IA64-Filler
    ULONGLONG IntH29;       // Intel-IA64-Filler
    ULONGLONG IntH30;       // Intel-IA64-Filler
    ULONGLONG IntH31;       // Intel-IA64-Filler

    // Application Registers       // Intel-IA64-Filler

    //       - CPUID Registers - AR       // Intel-IA64-Filler
    ULONGLONG ApCPUID0; // Cpuid Register 0       // Intel-IA64-Filler
    ULONGLONG ApCPUID1; // Cpuid Register 1       // Intel-IA64-Filler
    ULONGLONG ApCPUID2; // Cpuid Register 2       // Intel-IA64-Filler
    ULONGLONG ApCPUID3; // Cpuid Register 3       // Intel-IA64-Filler
    ULONGLONG ApCPUID4; // Cpuid Register 4       // Intel-IA64-Filler
    ULONGLONG ApCPUID5; // Cpuid Register 5       // Intel-IA64-Filler
    ULONGLONG ApCPUID6; // Cpuid Register 6       // Intel-IA64-Filler
    ULONGLONG ApCPUID7; // Cpuid Register 7       // Intel-IA64-Filler

    //       - Kernel Registers - AR       // Intel-IA64-Filler
    ULONGLONG ApKR0;    // Kernel Register 0 (User RO)       // Intel-IA64-Filler
    ULONGLONG ApKR1;    // Kernel Register 1 (User RO)       // Intel-IA64-Filler
    ULONGLONG ApKR2;    // Kernel Register 2 (User RO)       // Intel-IA64-Filler
    ULONGLONG ApKR3;    // Kernel Register 3 (User RO)       // Intel-IA64-Filler
    ULONGLONG ApKR4;    // Kernel Register 4       // Intel-IA64-Filler
    ULONGLONG ApKR5;    // Kernel Register 5       // Intel-IA64-Filler
    ULONGLONG ApKR6;    // Kernel Register 6       // Intel-IA64-Filler
    ULONGLONG ApKR7;    // Kernel Register 7       // Intel-IA64-Filler

    ULONGLONG ApITC;    // Interval Timer Counter       // Intel-IA64-Filler

    // Global control registers       // Intel-IA64-Filler

    ULONGLONG ApITM;    // Interval Timer Match register       // Intel-IA64-Filler
    ULONGLONG ApIVA;    // Interrupt Vector Address       // Intel-IA64-Filler
    ULONGLONG ApPTA;    // Page Table Address       // Intel-IA64-Filler
    ULONGLONG ApGPTA;   // ia32 Page Table Address       // Intel-IA64-Filler

    ULONGLONG StISR;    // Interrupt status       // Intel-IA64-Filler
    ULONGLONG StIFA;    // Interruption Faulting Address       // Intel-IA64-Filler
    ULONGLONG StITIR;   // Interruption TLB Insertion Register       // Intel-IA64-Filler
    ULONGLONG StIIPA;   // Interruption Instruction Previous Address (RO)       // Intel-IA64-Filler
    ULONGLONG StIIM;    // Interruption Immediate register (RO)       // Intel-IA64-Filler
    ULONGLONG StIHA;    // Interruption Hash Address (RO)       // Intel-IA64-Filler

    //       - External Interrupt control registers (SAPIC)       // Intel-IA64-Filler
    ULONGLONG SaLID;    // Local SAPIC ID       // Intel-IA64-Filler
    ULONGLONG SaIVR;    // Interrupt Vector Register (RO)       // Intel-IA64-Filler
    ULONGLONG SaTPR;    // Task Priority Register       // Intel-IA64-Filler
    ULONGLONG SaEOI;    // End Of Interrupt       // Intel-IA64-Filler
    ULONGLONG SaIRR0;   // Interrupt Request Register 0 (RO)       // Intel-IA64-Filler
    ULONGLONG SaIRR1;   // Interrupt Request Register 1 (RO)       // Intel-IA64-Filler
    ULONGLONG SaIRR2;   // Interrupt Request Register 2 (RO)       // Intel-IA64-Filler
    ULONGLONG SaIRR3;   // Interrupt Request Register 3 (RO)       // Intel-IA64-Filler
    ULONGLONG SaITV;    // Interrupt Timer Vector       // Intel-IA64-Filler
    ULONGLONG SaPMV;    // Performance Monitor Vector       // Intel-IA64-Filler
    ULONGLONG SaCMCV;   // Corrected Machine Check Vector       // Intel-IA64-Filler
    ULONGLONG SaLRR0;   // Local Interrupt Redirection Vector 0       // Intel-IA64-Filler
    ULONGLONG SaLRR1;   // Local Interrupt Redirection Vector 1       // Intel-IA64-Filler

    // System Registers       // Intel-IA64-Filler
    //       - Region registers       // Intel-IA64-Filler
    ULONGLONG Rr0;  // Region register 0       // Intel-IA64-Filler
    ULONGLONG Rr1;  // Region register 1       // Intel-IA64-Filler
    ULONGLONG Rr2;  // Region register 2       // Intel-IA64-Filler
    ULONGLONG Rr3;  // Region register 3       // Intel-IA64-Filler
    ULONGLONG Rr4;  // Region register 4       // Intel-IA64-Filler
    ULONGLONG Rr5;  // Region register 5       // Intel-IA64-Filler
    ULONGLONG Rr6;  // Region register 6       // Intel-IA64-Filler
    ULONGLONG Rr7;  // Region register 7       // Intel-IA64-Filler

    //      - Protection Key registers  // Intel-IA64-Filler
    ULONGLONG Pkr0;     // Protection Key register 0  // Intel-IA64-Filler
    ULONGLONG Pkr1;     // Protection Key register 1  // Intel-IA64-Filler
    ULONGLONG Pkr2;     // Protection Key register 2  // Intel-IA64-Filler
    ULONGLONG Pkr3;     // Protection Key register 3  // Intel-IA64-Filler
    ULONGLONG Pkr4;     // Protection Key register 4  // Intel-IA64-Filler
    ULONGLONG Pkr5;     // Protection Key register 5  // Intel-IA64-Filler
    ULONGLONG Pkr6;     // Protection Key register 6  // Intel-IA64-Filler
    ULONGLONG Pkr7;     // Protection Key register 7  // Intel-IA64-Filler
    ULONGLONG Pkr8;     // Protection Key register 8  // Intel-IA64-Filler
    ULONGLONG Pkr9;     // Protection Key register 9  // Intel-IA64-Filler
    ULONGLONG Pkr10;    // Protection Key register 10  // Intel-IA64-Filler
    ULONGLONG Pkr11;    // Protection Key register 11  // Intel-IA64-Filler
    ULONGLONG Pkr12;    // Protection Key register 12  // Intel-IA64-Filler
    ULONGLONG Pkr13;    // Protection Key register 13  // Intel-IA64-Filler
    ULONGLONG Pkr14;    // Protection Key register 14  // Intel-IA64-Filler
    ULONGLONG Pkr15;    // Protection Key register 15  // Intel-IA64-Filler

    //      -  Translation Lookaside buffers  // Intel-IA64-Filler
    ULONGLONG TrI0;     // Instruction Translation Register 0  // Intel-IA64-Filler
    ULONGLONG TrI1;     // Instruction Translation Register 1  // Intel-IA64-Filler
    ULONGLONG TrI2;     // Instruction Translation Register 2  // Intel-IA64-Filler
    ULONGLONG TrI3;     // Instruction Translation Register 3  // Intel-IA64-Filler
    ULONGLONG TrI4;     // Instruction Translation Register 4  // Intel-IA64-Filler
    ULONGLONG TrI5;     // Instruction Translation Register 5  // Intel-IA64-Filler
    ULONGLONG TrI6;     // Instruction Translation Register 6  // Intel-IA64-Filler
    ULONGLONG TrI7;     // Instruction Translation Register 7  // Intel-IA64-Filler

    ULONGLONG TrD0;     // Data Translation Register 0  // Intel-IA64-Filler
    ULONGLONG TrD1;     // Data Translation Register 1  // Intel-IA64-Filler
    ULONGLONG TrD2;     // Data Translation Register 2  // Intel-IA64-Filler
    ULONGLONG TrD3;     // Data Translation Register 3  // Intel-IA64-Filler
    ULONGLONG TrD4;     // Data Translation Register 4  // Intel-IA64-Filler
    ULONGLONG TrD5;     // Data Translation Register 5  // Intel-IA64-Filler
    ULONGLONG TrD6;     // Data Translation Register 6  // Intel-IA64-Filler
    ULONGLONG TrD7;     // Data Translation Register 7  // Intel-IA64-Filler

    //      -  Machine Specific Registers  // Intel-IA64-Filler
    ULONGLONG SrMSR0;   // Machine Specific Register 0  // Intel-IA64-Filler
    ULONGLONG SrMSR1;   // Machine Specific Register 1  // Intel-IA64-Filler
    ULONGLONG SrMSR2;   // Machine Specific Register 2  // Intel-IA64-Filler
    ULONGLONG SrMSR3;   // Machine Specific Register 3  // Intel-IA64-Filler
    ULONGLONG SrMSR4;   // Machine Specific Register 4  // Intel-IA64-Filler
    ULONGLONG SrMSR5;   // Machine Specific Register 5  // Intel-IA64-Filler
    ULONGLONG SrMSR6;   // Machine Specific Register 6  // Intel-IA64-Filler
    ULONGLONG SrMSR7;   // Machine Specific Register 7  // Intel-IA64-Filler

} IA64_KSPECIAL_REGISTERS, *PIA64_KSPECIAL_REGISTERS;  // Intel-IA64-Filler


typedef struct _IA64_CONTEXT {

    //
    // The flags values within this flag control the contents of
    // a CONTEXT record.
    //
    // If the context record is used as an input parameter, then
    // for each portion of the context record controlled by a flag
    // whose value is set, it is assumed that that portion of the
    // context record contains valid context. If the context record
    // is being used to modify a thread's context, then only that
    // portion of the threads context will be modified.
    //
    // If the context record is used as an IN OUT parameter to capture
    // the context of a thread, then only those portions of the thread's
    // context corresponding to set flags will be returned.
    //
    // The context record is never used as an OUT only parameter.
    //

    ULONG ContextFlags;
    ULONG Fill1[3];         // for alignment of following on 16-byte boundary

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_DEBUG.
    //
    // N.B. CONTEXT_DEBUG is *not* part of CONTEXT_FULL.
    //

    ULONGLONG DbI0;         // Intel-IA64-Filler
    ULONGLONG DbI1;         // Intel-IA64-Filler
    ULONGLONG DbI2;         // Intel-IA64-Filler
    ULONGLONG DbI3;         // Intel-IA64-Filler
    ULONGLONG DbI4;         // Intel-IA64-Filler
    ULONGLONG DbI5;         // Intel-IA64-Filler
    ULONGLONG DbI6;         // Intel-IA64-Filler
    ULONGLONG DbI7;         // Intel-IA64-Filler

    ULONGLONG DbD0;         // Intel-IA64-Filler
    ULONGLONG DbD1;         // Intel-IA64-Filler
    ULONGLONG DbD2;         // Intel-IA64-Filler
    ULONGLONG DbD3;         // Intel-IA64-Filler
    ULONGLONG DbD4;         // Intel-IA64-Filler
    ULONGLONG DbD5;         // Intel-IA64-Filler
    ULONGLONG DbD6;         // Intel-IA64-Filler
    ULONGLONG DbD7;         // Intel-IA64-Filler

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_LOWER_FLOATING_POINT.
    //

    FLOAT128 FltS0;         // Intel-IA64-Filler
    FLOAT128 FltS1;         // Intel-IA64-Filler
    FLOAT128 FltS2;         // Intel-IA64-Filler
    FLOAT128 FltS3;         // Intel-IA64-Filler
    FLOAT128 FltT0;         // Intel-IA64-Filler
    FLOAT128 FltT1;         // Intel-IA64-Filler
    FLOAT128 FltT2;         // Intel-IA64-Filler
    FLOAT128 FltT3;         // Intel-IA64-Filler
    FLOAT128 FltT4;         // Intel-IA64-Filler
    FLOAT128 FltT5;         // Intel-IA64-Filler
    FLOAT128 FltT6;         // Intel-IA64-Filler
    FLOAT128 FltT7;         // Intel-IA64-Filler
    FLOAT128 FltT8;         // Intel-IA64-Filler
    FLOAT128 FltT9;         // Intel-IA64-Filler

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_HIGHER_FLOATING_POINT.
    //

    FLOAT128 FltS4;         // Intel-IA64-Filler
    FLOAT128 FltS5;         // Intel-IA64-Filler
    FLOAT128 FltS6;         // Intel-IA64-Filler
    FLOAT128 FltS7;         // Intel-IA64-Filler
    FLOAT128 FltS8;         // Intel-IA64-Filler
    FLOAT128 FltS9;         // Intel-IA64-Filler
    FLOAT128 FltS10;        // Intel-IA64-Filler
    FLOAT128 FltS11;        // Intel-IA64-Filler
    FLOAT128 FltS12;        // Intel-IA64-Filler
    FLOAT128 FltS13;        // Intel-IA64-Filler
    FLOAT128 FltS14;        // Intel-IA64-Filler
    FLOAT128 FltS15;        // Intel-IA64-Filler
    FLOAT128 FltS16;        // Intel-IA64-Filler
    FLOAT128 FltS17;        // Intel-IA64-Filler
    FLOAT128 FltS18;        // Intel-IA64-Filler
    FLOAT128 FltS19;        // Intel-IA64-Filler

    FLOAT128 FltF32;        // Intel-IA64-Filler
    FLOAT128 FltF33;        // Intel-IA64-Filler
    FLOAT128 FltF34;        // Intel-IA64-Filler
    FLOAT128 FltF35;        // Intel-IA64-Filler
    FLOAT128 FltF36;        // Intel-IA64-Filler
    FLOAT128 FltF37;        // Intel-IA64-Filler
    FLOAT128 FltF38;        // Intel-IA64-Filler
    FLOAT128 FltF39;        // Intel-IA64-Filler

    FLOAT128 FltF40;        // Intel-IA64-Filler
    FLOAT128 FltF41;        // Intel-IA64-Filler
    FLOAT128 FltF42;        // Intel-IA64-Filler
    FLOAT128 FltF43;        // Intel-IA64-Filler
    FLOAT128 FltF44;        // Intel-IA64-Filler
    FLOAT128 FltF45;        // Intel-IA64-Filler
    FLOAT128 FltF46;        // Intel-IA64-Filler
    FLOAT128 FltF47;        // Intel-IA64-Filler
    FLOAT128 FltF48;        // Intel-IA64-Filler
    FLOAT128 FltF49;        // Intel-IA64-Filler

    FLOAT128 FltF50;        // Intel-IA64-Filler
    FLOAT128 FltF51;        // Intel-IA64-Filler
    FLOAT128 FltF52;        // Intel-IA64-Filler
    FLOAT128 FltF53;        // Intel-IA64-Filler
    FLOAT128 FltF54;        // Intel-IA64-Filler
    FLOAT128 FltF55;        // Intel-IA64-Filler
    FLOAT128 FltF56;        // Intel-IA64-Filler
    FLOAT128 FltF57;        // Intel-IA64-Filler
    FLOAT128 FltF58;        // Intel-IA64-Filler
    FLOAT128 FltF59;        // Intel-IA64-Filler

    FLOAT128 FltF60;        // Intel-IA64-Filler
    FLOAT128 FltF61;        // Intel-IA64-Filler
    FLOAT128 FltF62;        // Intel-IA64-Filler
    FLOAT128 FltF63;        // Intel-IA64-Filler
    FLOAT128 FltF64;        // Intel-IA64-Filler
    FLOAT128 FltF65;        // Intel-IA64-Filler
    FLOAT128 FltF66;        // Intel-IA64-Filler
    FLOAT128 FltF67;        // Intel-IA64-Filler
    FLOAT128 FltF68;        // Intel-IA64-Filler
    FLOAT128 FltF69;        // Intel-IA64-Filler

    FLOAT128 FltF70;        // Intel-IA64-Filler
    FLOAT128 FltF71;        // Intel-IA64-Filler
    FLOAT128 FltF72;        // Intel-IA64-Filler
    FLOAT128 FltF73;        // Intel-IA64-Filler
    FLOAT128 FltF74;        // Intel-IA64-Filler
    FLOAT128 FltF75;        // Intel-IA64-Filler
    FLOAT128 FltF76;        // Intel-IA64-Filler
    FLOAT128 FltF77;        // Intel-IA64-Filler
    FLOAT128 FltF78;        // Intel-IA64-Filler
    FLOAT128 FltF79;        // Intel-IA64-Filler

    FLOAT128 FltF80;        // Intel-IA64-Filler
    FLOAT128 FltF81;        // Intel-IA64-Filler
    FLOAT128 FltF82;        // Intel-IA64-Filler
    FLOAT128 FltF83;        // Intel-IA64-Filler
    FLOAT128 FltF84;        // Intel-IA64-Filler
    FLOAT128 FltF85;        // Intel-IA64-Filler
    FLOAT128 FltF86;        // Intel-IA64-Filler
    FLOAT128 FltF87;        // Intel-IA64-Filler
    FLOAT128 FltF88;        // Intel-IA64-Filler
    FLOAT128 FltF89;        // Intel-IA64-Filler

    FLOAT128 FltF90;        // Intel-IA64-Filler
    FLOAT128 FltF91;        // Intel-IA64-Filler
    FLOAT128 FltF92;        // Intel-IA64-Filler
    FLOAT128 FltF93;        // Intel-IA64-Filler
    FLOAT128 FltF94;        // Intel-IA64-Filler
    FLOAT128 FltF95;        // Intel-IA64-Filler
    FLOAT128 FltF96;        // Intel-IA64-Filler
    FLOAT128 FltF97;        // Intel-IA64-Filler
    FLOAT128 FltF98;        // Intel-IA64-Filler
    FLOAT128 FltF99;        // Intel-IA64-Filler

    FLOAT128 FltF100;       // Intel-IA64-Filler
    FLOAT128 FltF101;       // Intel-IA64-Filler
    FLOAT128 FltF102;       // Intel-IA64-Filler
    FLOAT128 FltF103;       // Intel-IA64-Filler
    FLOAT128 FltF104;       // Intel-IA64-Filler
    FLOAT128 FltF105;       // Intel-IA64-Filler
    FLOAT128 FltF106;       // Intel-IA64-Filler
    FLOAT128 FltF107;       // Intel-IA64-Filler
    FLOAT128 FltF108;       // Intel-IA64-Filler
    FLOAT128 FltF109;       // Intel-IA64-Filler

    FLOAT128 FltF110;       // Intel-IA64-Filler
    FLOAT128 FltF111;       // Intel-IA64-Filler
    FLOAT128 FltF112;       // Intel-IA64-Filler
    FLOAT128 FltF113;       // Intel-IA64-Filler
    FLOAT128 FltF114;       // Intel-IA64-Filler
    FLOAT128 FltF115;       // Intel-IA64-Filler
    FLOAT128 FltF116;       // Intel-IA64-Filler
    FLOAT128 FltF117;       // Intel-IA64-Filler
    FLOAT128 FltF118;       // Intel-IA64-Filler
    FLOAT128 FltF119;       // Intel-IA64-Filler

    FLOAT128 FltF120;       // Intel-IA64-Filler
    FLOAT128 FltF121;       // Intel-IA64-Filler
    FLOAT128 FltF122;       // Intel-IA64-Filler
    FLOAT128 FltF123;       // Intel-IA64-Filler
    FLOAT128 FltF124;       // Intel-IA64-Filler
    FLOAT128 FltF125;       // Intel-IA64-Filler
    FLOAT128 FltF126;       // Intel-IA64-Filler
    FLOAT128 FltF127;       // Intel-IA64-Filler

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_LOWER_FLOATING_POINT | CONTEXT_HIGHER_FLOATING_POINT | CONTEXT_CONTROL.
    //

    ULONGLONG StFPSR;       // Intel-IA64-Filler ; FP status

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_INTEGER.
    //
    // N.B. The registers gp, sp, rp are part of the control context
    //

    ULONGLONG IntGp;        // Intel-IA64-Filler ; r1, volatile
    ULONGLONG IntT0;        // Intel-IA64-Filler ; r2-r3, volatile
    ULONGLONG IntT1;        // Intel-IA64-Filler ;
    ULONGLONG IntS0;        // Intel-IA64-Filler ; r4-r7, preserved
    ULONGLONG IntS1;        // Intel-IA64-Filler
    ULONGLONG IntS2;        // Intel-IA64-Filler
    ULONGLONG IntS3;        // Intel-IA64-Filler
    ULONGLONG IntV0;        // Intel-IA64-Filler ; r8, volatile
    ULONGLONG IntT2;        // Intel-IA64-Filler ; r9-r11, volatile
    ULONGLONG IntT3;        // Intel-IA64-Filler
    ULONGLONG IntT4;        // Intel-IA64-Filler
    ULONGLONG IntSp;        // Intel-IA64-Filler ; stack pointer (r12), special
    ULONGLONG IntTeb;       // Intel-IA64-Filler ; teb (r13), special
    ULONGLONG IntT5;        // Intel-IA64-Filler ; r14-r31, volatile
    ULONGLONG IntT6;        // Intel-IA64-Filler
    ULONGLONG IntT7;        // Intel-IA64-Filler
    ULONGLONG IntT8;        // Intel-IA64-Filler
    ULONGLONG IntT9;        // Intel-IA64-Filler
    ULONGLONG IntT10;       // Intel-IA64-Filler
    ULONGLONG IntT11;       // Intel-IA64-Filler
    ULONGLONG IntT12;       // Intel-IA64-Filler
    ULONGLONG IntT13;       // Intel-IA64-Filler
    ULONGLONG IntT14;       // Intel-IA64-Filler
    ULONGLONG IntT15;       // Intel-IA64-Filler
    ULONGLONG IntT16;       // Intel-IA64-Filler
    ULONGLONG IntT17;       // Intel-IA64-Filler
    ULONGLONG IntT18;       // Intel-IA64-Filler
    ULONGLONG IntT19;       // Intel-IA64-Filler
    ULONGLONG IntT20;       // Intel-IA64-Filler
    ULONGLONG IntT21;       // Intel-IA64-Filler
    ULONGLONG IntT22;       // Intel-IA64-Filler

    ULONGLONG IntNats;      // Intel-IA64-Filler ; Nat bits for r1-r31
                            // Intel-IA64-Filler ; r1-r31 in bits 1 thru 31.
    ULONGLONG Preds;        // Intel-IA64-Filler ; predicates, preserved

    ULONGLONG BrRp;         // Intel-IA64-Filler ; return pointer, b0, preserved
    ULONGLONG BrS0;         // Intel-IA64-Filler ; b1-b5, preserved
    ULONGLONG BrS1;         // Intel-IA64-Filler
    ULONGLONG BrS2;         // Intel-IA64-Filler
    ULONGLONG BrS3;         // Intel-IA64-Filler
    ULONGLONG BrS4;         // Intel-IA64-Filler
    ULONGLONG BrT0;         // Intel-IA64-Filler ; b6-b7, volatile
    ULONGLONG BrT1;         // Intel-IA64-Filler

    //
    // This section is specified/returned if the ContextFlags word contains
    // the flag CONTEXT_CONTROL.
    //

    // Other application registers
    ULONGLONG ApUNAT;       // Intel-IA64-Filler ; User Nat collection register, preserved
    ULONGLONG ApLC;         // Intel-IA64-Filler ; Loop counter register, preserved
    ULONGLONG ApEC;         // Intel-IA64-Filler ; Epilog counter register, preserved
    ULONGLONG ApCCV;        // Intel-IA64-Filler ; CMPXCHG value register, volatile
    ULONGLONG ApDCR;        // Intel-IA64-Filler ; Default control register (TBD)

    // Register stack info
    ULONGLONG RsPFS;        // Intel-IA64-Filler ; Previous function state, preserved
    ULONGLONG RsBSP;        // Intel-IA64-Filler ; Backing store pointer, preserved
    ULONGLONG RsBSPSTORE;   // Intel-IA64-Filler
    ULONGLONG RsRSC;        // Intel-IA64-Filler ; RSE configuration, volatile
    ULONGLONG RsRNAT;       // Intel-IA64-Filler ; RSE Nat collection register, preserved

    // Trap Status Information
    ULONGLONG StIPSR;       // Intel-IA64-Filler ; Interruption Processor Status
    ULONGLONG StIIP;        // Intel-IA64-Filler ; Interruption IP
    ULONGLONG StIFS;        // Intel-IA64-Filler ; Interruption Function State

    // iA32 related control registers
    ULONGLONG StFCR;        // Intel-IA64-Filler ; copy of Ar21
    ULONGLONG Eflag;        // Intel-IA64-Filler ; Eflag copy of Ar24
    ULONGLONG SegCSD;       // Intel-IA64-Filler ; iA32 CSDescriptor (Ar25)
    ULONGLONG SegSSD;       // Intel-IA64-Filler ; iA32 SSDescriptor (Ar26)
    ULONGLONG Cflag;        // Intel-IA64-Filler ; Cr0+Cr4 copy of Ar27
    ULONGLONG StFSR;        // Intel-IA64-Filler ; x86 FP status (copy of AR28)
    ULONGLONG StFIR;        // Intel-IA64-Filler ; x86 FP status (copy of AR29)
    ULONGLONG StFDR;        // Intel-IA64-Filler ; x86 FP status (copy of AR30)

      ULONGLONG UNUSEDPACK;   // Intel-IA64-Filler ; added to pack StFDR to 16-bytes

} IA64_CONTEXT, *PIA64_CONTEXT;

//
// Special Registers for AMD64.
//

typedef struct _AMD64_DESCRIPTOR {
    USHORT  Pad[3];
    USHORT  Limit;
    ULONG64 Base;
} AMD64_DESCRIPTOR, *PAMD64_DESCRIPTOR;

typedef struct _AMD64_KSPECIAL_REGISTERS {
    ULONG64 Cr0;
    ULONG64 Cr2;
    ULONG64 Cr3;
    ULONG64 Cr4;
    ULONG64 KernelDr0;
    ULONG64 KernelDr1;
    ULONG64 KernelDr2;
    ULONG64 KernelDr3;
    ULONG64 KernelDr6;
    ULONG64 KernelDr7;
    AMD64_DESCRIPTOR Gdtr;
    AMD64_DESCRIPTOR Idtr;
    USHORT Tr;
    USHORT Ldtr;
    ULONG MxCsr;
} AMD64_KSPECIAL_REGISTERS, *PAMD64_KSPECIAL_REGISTERS;

typedef struct _AMD64_KSWITCH_FRAME {
    ULONG64 Fill0;
    ULONG MxCsr;
    KIRQL ApcBypass;
    BOOLEAN NpxSave;
    UCHAR Fill1[2];
    ULONG64 Rbp;
    ULONG64 Return;
} AMD64_KSWITCH_FRAME, *PAMD64_KSWITCH_FRAME;

//
// Format of data for fnsave/frstor instructions.
//
// This structure is used to store the legacy floating point state.
//

typedef struct _AMD64_LEGACY_SAVE_AREA {
    USHORT ControlWord;
    USHORT Reserved0;
    USHORT StatusWord;
    USHORT Reserved1;
    USHORT TagWord;
    USHORT Reserved2;
    ULONG ErrorOffset;
    USHORT ErrorSelector;
    USHORT ErrorOpcode;
    ULONG DataOffset;
    USHORT DataSelector;
    USHORT Reserved3;
    UCHAR FloatRegisters[8 * 10];
} AMD64_LEGACY_SAVE_AREA, *PAMD64_LEGACY_SAVE_AREA;

typedef struct _AMD64_M128 {
    ULONGLONG Low;
    LONGLONG High;
} AMD64_M128, *PAMD64_M128;

// Must be 16-byte aligned.
typedef struct _AMD64_CONTEXT {

    //
    // Register parameter home addresses.
    //

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5Home;
    ULONG64 P6Home;

    //
    // Control flags.
    //

    ULONG ContextFlags;
    ULONG MxCsr;

    //
    // Segment Registers and processor flags.
    //

    USHORT SegCs;
    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
    USHORT SegGs;
    USHORT SegSs;
    ULONG EFlags;

    //
    // Debug registers
    //

    ULONG64 Dr0;
    ULONG64 Dr1;
    ULONG64 Dr2;
    ULONG64 Dr3;
    ULONG64 Dr6;
    ULONG64 Dr7;

    //
    // Integer registers.
    //

    ULONG64 Rax;
    ULONG64 Rcx;
    ULONG64 Rdx;
    ULONG64 Rbx;
    ULONG64 Rsp;
    ULONG64 Rbp;
    ULONG64 Rsi;
    ULONG64 Rdi;
    ULONG64 R8;
    ULONG64 R9;
    ULONG64 R10;
    ULONG64 R11;
    ULONG64 R12;
    ULONG64 R13;
    ULONG64 R14;
    ULONG64 R15;

    //
    // Program counter.
    //

    ULONG64 Rip;

    //
    // MMX/floating point state.
    //

    AMD64_M128 Xmm0;
    AMD64_M128 Xmm1;
    AMD64_M128 Xmm2;
    AMD64_M128 Xmm3;
    AMD64_M128 Xmm4;
    AMD64_M128 Xmm5;
    AMD64_M128 Xmm6;
    AMD64_M128 Xmm7;
    AMD64_M128 Xmm8;
    AMD64_M128 Xmm9;
    AMD64_M128 Xmm10;
    AMD64_M128 Xmm11;
    AMD64_M128 Xmm12;
    AMD64_M128 Xmm13;
    AMD64_M128 Xmm14;
    AMD64_M128 Xmm15;

    //
    // Legacy floating point state.
    //

    AMD64_LEGACY_SAVE_AREA FltSave;
    ULONG Fill;
} AMD64_CONTEXT, *PAMD64_CONTEXT;


typedef struct _CROSS_PLATFORM_CONTEXT {

    union {
        X86_CONTEXT       X86Context;
        X86_NT5_CONTEXT   X86Nt5Context;
        ALPHA_CONTEXT     AlphaContext;
        ALPHA_NT5_CONTEXT AlphaNt5Context;
        IA64_CONTEXT      IA64Context;
        AMD64_CONTEXT     Amd64Context;
    };

} CROSS_PLATFORM_CONTEXT, *PCROSS_PLATFORM_CONTEXT;


typedef struct _CROSS_PLATFORM_KSPECIAL_REGISTERS {

    union {
        X86_KSPECIAL_REGISTERS   X86Special;
        IA64_KSPECIAL_REGISTERS  IA64Special;
        AMD64_KSPECIAL_REGISTERS Amd64Special;
    };

} CROSS_PLATFORM_KSPECIAL_REGISTERS, *PCROSS_PLATFORM_KSPECIAL_REGISTERS;


typedef struct _X86_KPROCESSOR_STATE {
    struct _X86_CONTEXT ContextFrame;
    struct _X86_KSPECIAL_REGISTERS SpecialRegisters;
} X86_KPROCESSOR_STATE, *PX86_KPROCESSOR_STATE;

typedef struct _X86_NT5_KPROCESSOR_STATE {
    struct _X86_NT5_CONTEXT ContextFrame;
    struct _X86_KSPECIAL_REGISTERS SpecialRegisters;
} X86_NT5_KPROCESSOR_STATE, *PX86_NT5_KPROCESSOR_STATE;

typedef struct _ALPHA_NT5_KPROCESSOR_STATE {
    struct _ALPHA_NT5_CONTEXT ContextFrame;
} ALPHA_NT5_KPROCESSOR_STATE, *PALPHA_NT5_KPROCESSOR_STATE;

typedef struct _IA64_KPROCESSOR_STATE {
    struct _IA64_CONTEXT ContextFrame;
    struct _IA64_KSPECIAL_REGISTERS SpecialRegisters;
} IA64_KPROCESSOR_STATE, *PIA64_KPROCESSOR_STATE;

typedef struct _AMD64_KPROCESSOR_STATE {
    struct _AMD64_KSPECIAL_REGISTERS SpecialRegisters;
    ULONG64 Fill;
    struct _AMD64_CONTEXT ContextFrame;
} AMD64_KPROCESSOR_STATE, *PAMD64_KPROCESSOR_STATE;


#define DBGKD_MAXSTREAM 16

typedef struct _X86_DBGKD_CONTROL_REPORT {
    ULONG   Dr6;
    ULONG   Dr7;
    USHORT  InstructionCount;
    USHORT  ReportFlags;
    UCHAR   InstructionStream[DBGKD_MAXSTREAM];
    USHORT  SegCs;
    USHORT  SegDs;
    USHORT  SegEs;
    USHORT  SegFs;
    ULONG   EFlags;
} X86_DBGKD_CONTROL_REPORT, *PX86_DBGKD_CONTROL_REPORT;

#define X86_REPORT_INCLUDES_SEGS    0x0001
// Indicates the current CS is a standard 32-bit flat segment.
// This allows the debugger to avoid retrieving the
// CS descriptor to see if it's 16-bit code or not.
// Note that the V86 flag in EFlags must also be checked
// when determining the code type.
#define X86_REPORT_STANDARD_CS      0x0002

typedef struct _ALPHA_DBGKD_CONTROL_REPORT {
    ULONG InstructionCount;
    UCHAR InstructionStream[DBGKD_MAXSTREAM];
} ALPHA_DBGKD_CONTROL_REPORT, *PALPHA_DBGKD_CONTROL_REPORT;

typedef struct _IA64_DBGKD_CONTROL_REPORT {
    ULONG InstructionCount;
    UCHAR InstructionStream[DBGKD_MAXSTREAM];
} IA64_DBGKD_CONTROL_REPORT, *PIA64_DBGKD_CONTROL_REPORT;

typedef struct _AMD64_DBGKD_CONTROL_REPORT {
    ULONG64 Dr6;
    ULONG64 Dr7;
    ULONG EFlags;
    USHORT InstructionCount;
    USHORT ReportFlags;
    UCHAR InstructionStream[DBGKD_MAXSTREAM];
    USHORT SegCs;
    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
} AMD64_DBGKD_CONTROL_REPORT, *PAMD64_DBGKD_CONTROL_REPORT;

#define AMD64_REPORT_INCLUDES_SEGS    0x0001
// Indicates the current CS is a standard 64-bit flat segment.
// This allows the debugger to avoid retrieving the
// CS descriptor to see if it's 16- or 32-bit code or not.
// Note that the V86 flag in EFlags must also be checked
// when determining the code type.
#define AMD64_REPORT_STANDARD_CS      0x0002

typedef struct _DBGKD_ANY_CONTROL_REPORT
{
    union
    {
        X86_DBGKD_CONTROL_REPORT X86ControlReport;
        ALPHA_DBGKD_CONTROL_REPORT AlphaControlReport;
        IA64_DBGKD_CONTROL_REPORT IA64ControlReport;
        AMD64_DBGKD_CONTROL_REPORT Amd64ControlReport;
    };
} DBGKD_ANY_CONTROL_REPORT, *PDBGKD_ANY_CONTROL_REPORT;

// DBGKD_ANY_CONTROL_SET is 32-bit packed with an NTSTATUS in
// DBGKD_CONTINUE2 so start with a 32-bit value to get the 64-bit
// values aligned.

#include <pshpack4.h>

typedef struct _X86_DBGKD_CONTROL_SET {
    ULONG   TraceFlag;
    ULONG   Dr7;
    ULONG   CurrentSymbolStart;
    ULONG   CurrentSymbolEnd;
} X86_DBGKD_CONTROL_SET, *PX86_DBGKD_CONTROL_SET;

typedef ULONG ALPHA_DBGKD_CONTROL_SET, *PALPHA_DBGKD_CONTROL_SET;

#define IA64_DBGKD_CONTROL_SET_CONTINUE_NONE                0x0000
#define IA64_DBGKD_CONTROL_SET_CONTINUE_TRACE_INSTRUCTION   0x0001
#define IA64_DBGKD_CONTROL_SET_CONTINUE_TRACE_TAKEN_BRANCH  0x0002

typedef struct _IA64_DBGKD_CONTROL_SET {
    ULONG   Continue;
    ULONG64 CurrentSymbolStart;
    ULONG64 CurrentSymbolEnd;
} IA64_DBGKD_CONTROL_SET, *PIA64_DBGKD_CONTROL_SET;

typedef struct _AMD64_DBGKD_CONTROL_SET {
    ULONG   TraceFlag;
    ULONG64 Dr7;
    ULONG64 CurrentSymbolStart;
    ULONG64 CurrentSymbolEnd;
} AMD64_DBGKD_CONTROL_SET, *PAMD64_DBGKD_CONTROL_SET;

typedef struct _DBGKD_ANY_CONTROL_SET
{
    union
    {
        X86_DBGKD_CONTROL_SET X86ControlSet;
        ALPHA_DBGKD_CONTROL_SET AlphaControlSet;
        IA64_DBGKD_CONTROL_SET IA64ControlSet;
        AMD64_DBGKD_CONTROL_SET Amd64ControlSet;
    };
} DBGKD_ANY_CONTROL_SET, *PDBGKD_ANY_CONTROL_SET;

#include <poppack.h>

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC32 {
    CSHORT Type;
    UCHAR Number;
    UCHAR Importance;
    LIST_ENTRY32 DpcListEntry;
    ULONG DeferredRoutine;
    ULONG DeferredContext;
    ULONG SystemArgument1;
    ULONG SystemArgument2;
    ULONG Lock;
} KDPC32;

typedef struct _KDPC64 {
    CSHORT Type;
    UCHAR Number;
    UCHAR Importance;
    LIST_ENTRY64 DpcListEntry;
    ULONG64 DeferredRoutine;
    ULONG64 DeferredContext;
    ULONG64 SystemArgument1;
    ULONG64 SystemArgument2;
    ULONG64 Lock;
} KDPC64;

//
//  LDT descriptor entry
//

typedef struct _X86_LDT_ENTRY {
    USHORT  LimitLow;
    USHORT  BaseLow;
    union {
        struct {
            UCHAR   BaseMid;
            UCHAR   Flags1;     // Declare as bytes to avoid alignment
            UCHAR   Flags2;     // Problems.
            UCHAR   BaseHi;
        } Bytes;
        struct {
            ULONG   BaseMid : 8;
            ULONG   Type : 5;
            ULONG   Dpl : 2;
            ULONG   Pres : 1;
            ULONG   LimitHi : 4;
            ULONG   Sys : 1;
            ULONG   Reserved_0 : 1;
            ULONG   Default_Big : 1;
            ULONG   Granularity : 1;
            ULONG   BaseHi : 8;
        } Bits;
    } HighWord;
} X86_LDT_ENTRY, *PX86_LDT_ENTRY;

typedef struct _X86_DESCRIPTOR_TABLE_ENTRY {
    ULONG Selector;
    X86_LDT_ENTRY Descriptor;
} X86_DESCRIPTOR_TABLE_ENTRY, *PX86_DESCRIPTOR_TABLE_ENTRY;

typedef struct _X86_KTRAP_FRAME {


//
//  Following 4 values are only used and defined for DBG systems,
//  but are always allocated to make switching from DBG to non-DBG
//  and back quicker.  They are not DEVL because they have a non-0
//  performance impact.
//

    ULONG   DbgEbp;         // Copy of User EBP set up so KB will work.
    ULONG   DbgEip;         // EIP of caller to system call, again, for KB.
    ULONG   DbgArgMark;     // Marker to show no args here.
    ULONG   DbgArgPointer;  // Pointer to the actual args

//
//  Temporary values used when frames are edited.
//
//
//  NOTE:   Any code that want's ESP must materialize it, since it
//          is not stored in the frame for kernel mode callers.
//
//          And code that sets ESP in a KERNEL mode frame, must put
//          the new value in TempEsp, make sure that TempSegCs holds
//          the real SegCs value, and put a special marker value into SegCs.
//

    ULONG   TempSegCs;
    ULONG   TempEsp;

//
//  Debug registers.
//

    ULONG   Dr0;
    ULONG   Dr1;
    ULONG   Dr2;
    ULONG   Dr3;
    ULONG   Dr6;
    ULONG   Dr7;

//
//  Segment registers
//

    ULONG   SegGs;
    ULONG   SegEs;
    ULONG   SegDs;

//
//  Volatile registers
//

    ULONG   Edx;
    ULONG   Ecx;
    ULONG   Eax;

//
//  Nesting state, not part of context record
//

    ULONG   PreviousPreviousMode;

    ULONG   ExceptionList;
                                            // Trash if caller was user mode.
                                            // Saved exception list if caller
                                            // was kernel mode or we're in
                                            // an interrupt.

//
//  FS is TIB/PCR pointer, is here to make save sequence easy
//

    ULONG   SegFs;

//
//  Non-volatile registers
//

    ULONG   Edi;
    ULONG   Esi;
    ULONG   Ebx;
    ULONG   Ebp;

//
//  Control registers
//

    ULONG   ErrCode;
    ULONG   Eip;
    ULONG   SegCs;
    ULONG   EFlags;

    ULONG   HardwareEsp;    // WARNING - segSS:esp are only here for stacks
    ULONG   HardwareSegSs;  // that involve a ring transition.

    ULONG   V86Es;          // these will be present for all transitions from
    ULONG   V86Ds;          // V86 mode
    ULONG   V86Fs;
    ULONG   V86Gs;
} X86_KTRAP_FRAME, *PX86_KTRAP_FRAME;


typedef struct _ALPHA_KTRAP_FRAME {

    //
    // Fields saved in the PALcode.
    //

    ULONGLONG IntSp;    // $30: stack pointer register, sp
    ULONGLONG Fir;      // (fault instruction) continuation address
    ULONG Psr;          // processor status
    ULONG Fill1[1];     // unused
    ULONGLONG IntFp;    // $15: frame pointer register, fp/s6

    ULONGLONG IntA0;    // $16: argument registers, a0 - a3
    ULONGLONG IntA1;    // $17:
    ULONGLONG IntA2;    // $18:
    ULONGLONG IntA3;    // $19:

    ULONGLONG IntRa;    // $26: return address register, ra
    ULONGLONG IntGp;    // $29: global pointer register, gp
    UCHAR ExceptionRecord[(sizeof(EXCEPTION_RECORD32) + 15) & (~15)];

    //
    // Volatile integer registers, s0 - s5 are nonvolatile.
    //

    ULONGLONG IntV0;    //  $0: return value register, v0
    ULONGLONG IntT0;    //  $1: temporary registers, t0 - t7
    ULONGLONG IntT1;    //  $2:
    ULONGLONG IntT2;    //  $3:
    ULONGLONG IntT3;    //  $4:
    ULONGLONG IntT4;    //  $5:
    ULONGLONG IntT5;    //  $6:
    ULONGLONG IntT6;    //  $7:
    ULONGLONG IntT7;    //  $8:

    ULONGLONG IntT8;    // $22: temporary registers, t8 - t11
    ULONGLONG IntT9;    // $23:
    ULONGLONG IntT10;   // $24:
    ULONGLONG IntT11;   // $25:

    ULONGLONG IntT12;   // $27: temporary register, t12
    ULONGLONG IntAt;    // $28: assembler temporary register, at

    ULONGLONG IntA4;    // $20: remaining argument registers a4 - a5
    ULONGLONG IntA5;    // $21:

    //
    // Volatile floating point registers, f2 - f9 are nonvolatile.
    //

    ULONGLONG FltF0;    // $f0:
    ULONGLONG Fpcr;     // floating point control register
    ULONGLONG FltF1;    // $f1:

    ULONGLONG FltF10;   // $f10: temporary registers, $f10 - $f30
    ULONGLONG FltF11;   // $f11:
    ULONGLONG FltF12;   // $f12:
    ULONGLONG FltF13;   // $f13:
    ULONGLONG FltF14;   // $f14:
    ULONGLONG FltF15;   // $f15:
    ULONGLONG FltF16;   // $f16:
    ULONGLONG FltF17;   // $f17:
    ULONGLONG FltF18;   // $f18:
    ULONGLONG FltF19;   // $f19:
    ULONGLONG FltF20;   // $f20:
    ULONGLONG FltF21;   // $f21:
    ULONGLONG FltF22;   // $f22:
    ULONGLONG FltF23;   // $f23:
    ULONGLONG FltF24;   // $f24:
    ULONGLONG FltF25;   // $f25:
    ULONGLONG FltF26;   // $f26:
    ULONGLONG FltF27;   // $f27:
    ULONGLONG FltF28;   // $f28:
    ULONGLONG FltF29;   // $f29:
    ULONGLONG FltF30;   // $f30:

    ULONG OldIrql;      // Previous Irql.
    ULONG PreviousMode; // Previous Mode.
    ULONGLONG TrapFrame; //
    ULONG Fill2[3];     // padding for 32-byte stack frame alignment

} ALPHA_KTRAP_FRAME, *PALPHA_KTRAP_FRAME;

typedef struct _AXP64_KTRAP_FRAME {

    //
    // Fields saved in the PALcode.
    //

    ULONGLONG IntSp;    // $30: stack pointer register, sp
    ULONGLONG Fir;      // (fault instruction) continuation address
    ULONG Psr;          // processor status
    ULONG Fill1[1];     // unused
    ULONGLONG IntFp;    // $15: frame pointer register, fp/s6

    ULONGLONG IntA0;    // $16: argument registers, a0 - a3
    ULONGLONG IntA1;    // $17:
    ULONGLONG IntA2;    // $18:
    ULONGLONG IntA3;    // $19:

    ULONGLONG IntRa;    // $26: return address register, ra
    ULONGLONG IntGp;    // $29: global pointer register, gp
    UCHAR ExceptionRecord[(sizeof(EXCEPTION_RECORD64) + 15) & (~15)];

    //
    // Volatile integer registers, s0 - s5 are nonvolatile.
    //

    ULONGLONG IntV0;    //  $0: return value register, v0
    ULONGLONG IntT0;    //  $1: temporary registers, t0 - t7
    ULONGLONG IntT1;    //  $2:
    ULONGLONG IntT2;    //  $3:
    ULONGLONG IntT3;    //  $4:
    ULONGLONG IntT4;    //  $5:
    ULONGLONG IntT5;    //  $6:
    ULONGLONG IntT6;    //  $7:
    ULONGLONG IntT7;    //  $8:

    ULONGLONG IntT8;    // $22: temporary registers, t8 - t11
    ULONGLONG IntT9;    // $23:
    ULONGLONG IntT10;   // $24:
    ULONGLONG IntT11;   // $25:

    ULONGLONG IntT12;   // $27: temporary register, t12
    ULONGLONG IntAt;    // $28: assembler temporary register, at

    ULONGLONG IntA4;    // $20: remaining argument registers a4 - a5
    ULONGLONG IntA5;    // $21:

    //
    // Volatile floating point registers, f2 - f9 are nonvolatile.
    //

    ULONGLONG FltF0;    // $f0:
    ULONGLONG Fpcr;     // floating point control register
    ULONGLONG FltF1;    // $f1:

    ULONGLONG FltF10;   // $f10: temporary registers, $f10 - $f30
    ULONGLONG FltF11;   // $f11:
    ULONGLONG FltF12;   // $f12:
    ULONGLONG FltF13;   // $f13:
    ULONGLONG FltF14;   // $f14:
    ULONGLONG FltF15;   // $f15:
    ULONGLONG FltF16;   // $f16:
    ULONGLONG FltF17;   // $f17:
    ULONGLONG FltF18;   // $f18:
    ULONGLONG FltF19;   // $f19:
    ULONGLONG FltF20;   // $f20:
    ULONGLONG FltF21;   // $f21:
    ULONGLONG FltF22;   // $f22:
    ULONGLONG FltF23;   // $f23:
    ULONGLONG FltF24;   // $f24:
    ULONGLONG FltF25;   // $f25:
    ULONGLONG FltF26;   // $f26:
    ULONGLONG FltF27;   // $f27:
    ULONGLONG FltF28;   // $f28:
    ULONGLONG FltF29;   // $f29:
    ULONGLONG FltF30;   // $f30:

    ULONG OldIrql;      // Previous Irql.
    ULONG PreviousMode; // Previous Mode.
    ULONGLONG TrapFrame; //
    ULONG Fill2[3];     // padding for 32-byte stack frame alignment

} AXP64_KTRAP_FRAME, *PAXP64_KTRAP_FRAME;

typedef struct _AMD64_KTRAP_FRAME {

//
// Home address for the parameter registers.
//

    ULONG64 P1Home;
    ULONG64 P2Home;
    ULONG64 P3Home;
    ULONG64 P4Home;
    ULONG64 P5;

//
// Previous processor mode (system services only) and previous IRQL
// (interrupts only).
//

    CCHAR PreviousMode;
    KIRQL PreviousIrql;
    UCHAR Fill0[2];

//
// Floating point state.
//

    ULONG MxCsr;

//
//  Volatile registers.
//
// N.B. These registers are only saved on exceptions and interrupts. They
//      are not saved for system calls.
//

    ULONG64 Rax;
    ULONG64 Rcx;
    ULONG64 Rdx;
    ULONG64 R8;
    ULONG64 R9;
    ULONG64 R10;
    ULONG64 R11;
    ULONG64 Spare0;

//
// Volatile floating registers.
//
// N.B. These registers are only saved on exceptions and interrupts. They
//      are not saved for system calls.
//

    AMD64_M128 Xmm0;
    AMD64_M128 Xmm1;
    AMD64_M128 Xmm2;
    AMD64_M128 Xmm3;
    AMD64_M128 Xmm4;
    AMD64_M128 Xmm5;

//
//  Debug registers.
//

    ULONG64 Dr0;
    ULONG64 Dr1;
    ULONG64 Dr2;
    ULONG64 Dr3;
    ULONG64 Dr6;
    ULONG64 Dr7;

//
//  Segment registers
//

    USHORT SegDs;
    USHORT SegEs;
    USHORT SegFs;
    USHORT SegGs;

//
// Previous trap frame address.
//

    ULONG64 TrapFrame;

//
// Exception record for exceptions.
//

    UCHAR ExceptionRecord[(sizeof(EXCEPTION_RECORD64) + 15) & (~15)];

//
// Saved nonvolatile registers RBX, RDI and RSI. These registers are only
// saved in system service trap frames.
//

    ULONG64 Rbx;
    ULONG64 Rdi;
    ULONG64 Rsi;

//
// Saved nonvolatile register RBP. This register is used as a frame
// pointer during trap processing and is saved in all trap frames.
//

    ULONG64 Rbp;

//
// Information pushed by hardware.
//
// N.B. The error code is not always pushed by hardware. For those cases
//      where it is not pushed by hardware a dummy error code is allocated
//      on the stack.
//

    ULONG64 ErrorCode;
    ULONG64 Rip;
    USHORT SegCs;
    USHORT Fill1[3];
    ULONG EFlags;
    ULONG Fill2;
    ULONG64 Rsp;
    USHORT SegSs;
    USHORT Fill3[3];
} AMD64_KTRAP_FRAME, *PAMD64_KTRAP_FRAME;


typedef struct _X86_PARTIAL_KPRCB {

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
    USHORT MinorVersion;
    USHORT MajorVersion;

    ULONG CurrentThread;
    ULONG NextThread;
    ULONG IdleThread;

    CCHAR  Number;
    CCHAR  Reserved;
    USHORT BuildType;
    ULONG SetMember;

    CCHAR   CpuType;
    CCHAR   CpuID;
    USHORT  CpuStep;

    X86_NT5_KPROCESSOR_STATE ProcessorState;


} X86_PARTIAL_KPRCB, *PX86_PARTIAL_KPRCB;


typedef struct _X86_KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    NT_TIB32  NtTib;
    ULONG SelfPcr;              // flat address of this PCR
    ULONG Prcb;                // pointer to Prcb

} X86_KPCR, *PX86_KPCR;


typedef struct _ALPHA_PARTIAL_KPRCB {

//
// Major and minor version numbers of the PCR.
//

    USHORT MinorVersion;
    USHORT MajorVersion;

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    ULONG  CurrentThread;
    ULONG  NextThread;
    ULONG  IdleThread;

    CCHAR  Number;
    CCHAR  Reserved;
    USHORT BuildType;
    ULONG SetMember;
    ULONG RestartBlock;

//
// End of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    ULONG InterruptCount;
    ULONG DpcTime;
    ULONG InterruptTime;
    ULONG KernelTime;
    ULONG UserTime;
    KDPC32 QuantumEndDpc;

//
// Address of PCR.
//

    ULONG Pcr;

//
// MP Information.
//

    ULONG Spare2;
    ULONG Spare3;
    volatile ULONG IpiFrozen;
    ALPHA_NT5_KPROCESSOR_STATE ProcessorState;

} ALPHA_PARTIAL_KPRCB, *PALPHA_PARTIAL_KPRCB;

typedef struct _ALPHA_PARTIAL_KPCR {

//
// Major and minor version numbers of the PCR.
//

    ULONG MinorVersion;
    ULONG MajorVersion;

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific PAL/HAL code and will
// not change from version to version of NT.

//
// PALcode information.
//

    ULONGLONG PalBaseAddress;
    ULONG PalMajorVersion;
    ULONG PalMinorVersion;
    ULONG PalSequenceVersion;
    ULONG PalMajorSpecification;
    ULONG PalMinorSpecification;

//
// Firmware restart information.
//

    ULONGLONG FirmwareRestartAddress;
    ULONG RestartBlock;

//
// Reserved per-processor region for the PAL (3K-8 bytes).
//

    ULONGLONG PalReserved[383];

//
// Alignment fixup count updated by PAL and read by kernel.
//

    ULONGLONG PalAlignmentFixupCount;

//
// Panic Stack Address.
//

    ULONG PanicStack;

//
// Processor parameters.
//

    ULONG ProcessorType;
    ULONG ProcessorRevision;
    ULONG PhysicalAddressBits;
    ULONG MaximumAddressSpaceNumber;
    ULONG PageSize;
    ULONG FirstLevelDcacheSize;
    ULONG FirstLevelDcacheFillSize;
    ULONG FirstLevelIcacheSize;
    ULONG FirstLevelIcacheFillSize;

} ALPHA_PARTIAL_KPCR, *PALPHA_PARTIAL_KPCR;


typedef struct _AXP64_PARTIAL_KPRCB {

//
// Major and minor version numbers of the PCR.
//

    USHORT MinorVersion;
    USHORT MajorVersion;

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    ULONG64 CurrentThread;
    ULONG64 NextThread;
    ULONG64 IdleThread;
    CCHAR Number;
    CCHAR Reserved;
    USHORT BuildType;
    ULONG64 SetMember;
    ULONG64 RestartBlock;

//
// End of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    ULONG InterruptCount;
    ULONG DpcTime;
    ULONG InterruptTime;
    ULONG KernelTime;
    ULONG UserTime;
    KDPC64 QuantumEndDpc;

//
// Address of PCR.
//

    ULONG64 Pcr;

//
// MP Information.
//

    ULONG64 Spare2;
    ULONG64 Spare3;
    volatile ULONG IpiFrozen;
    ALPHA_NT5_KPROCESSOR_STATE ProcessorState;

} AXP64_PARTIAL_KPRCB, *PAXP64_PARTIAL_KPRCB;

typedef struct _AXP64_PARTIAL_KPCR {

//
// Major and minor version numbers of the PCR.
//

    ULONG MinorVersion;
    ULONG MajorVersion;

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific PAL/HAL code and will
// not change from version to version of NT.

//
// PALcode information.
//

    ULONGLONG PalBaseAddress;
    ULONG PalMajorVersion;
    ULONG PalMinorVersion;
    ULONG PalSequenceVersion;
    ULONG PalMajorSpecification;
    ULONG PalMinorSpecification;

//
// Firmware restart information.
//

    ULONGLONG FirmwareRestartAddress;
    ULONG64 RestartBlock;

//
// Reserved per-processor region for the PAL (3K-8 bytes).
//

    ULONGLONG PalReserved[383];

//
// Alignment fixup count updated by PAL and read by kernel.
//

    ULONGLONG PalAlignmentFixupCount;

//
// Panic Stack Address.
//

    ULONG64 PanicStack;

//
// Processor parameters.
//

    ULONG ProcessorType;
    ULONG ProcessorRevision;
    ULONG PhysicalAddressBits;
    ULONG MaximumAddressSpaceNumber;
    ULONG PageSize;
    ULONG FirstLevelDcacheSize;
    ULONG FirstLevelDcacheFillSize;
    ULONG FirstLevelIcacheSize;
    ULONG FirstLevelIcacheFillSize;

} AXP64_PARTIAL_KPCR, *PAXP64_PARTIAL_KPCR;


typedef struct _IA64_PARTIAL_KPRCB {

//
// Major and minor version numbers of the PCR.
//

    USHORT MinorVersion;
    USHORT MajorVersion;
    ULONG64  CurrentThread;
    ULONG64 NextThread;
    ULONG64 IdleThread;
    CCHAR Number;
    CCHAR Reserved;
    USHORT BuildType;
    ULONG64 SetMember;
    ULONG64 RestartBlock;
    ULONG64 PcrPage;
    ULONG Spares1[4];

//
// Processor Idendification Registers.
//

    ULONG     ProcessorModel;
    ULONG     ProcessorRevision;
    ULONG     ProcessorFamily;
    ULONG     ProcessorArchRev;
    ULONGLONG ProcessorSerialNumber;
    ULONGLONG ProcessorFeatureBits;
    UCHAR     ProcessorVendorString[16];

//
// Space reserved for the system.
//

    ULONGLONG SystemReserved[8];

//
// Space reserved for the HAL.
//

    ULONGLONG HalReserved[16];

//
// End of the architecturally defined section of the PRCB.
// end_nthal end_ntddk
//

    ULONG DpcTime;
    ULONG InterruptTime;
    ULONG KernelTime;
    ULONG UserTime;
    ULONG InterruptCount;
    ULONG DispatchInterruptCount;
    ULONG ApcBypassCount;
    ULONG DpcBypassCount;
    ULONG Spare0[4];

//
// MP information.
//

    ULONG64 Spare1;
    ULONG64 Spare2;
    ULONG64 Spare3;
    volatile ULONG IpiFrozen;
    struct _IA64_KPROCESSOR_STATE ProcessorState;

} IA64_PARTIAL_KPRCB, *PIA64_PARTIAL_KPRCB;


typedef struct _AMD64_PARTIAL_KPRCB {

//
// Start of the architecturally defined section of the PRCB. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//
    USHORT MinorVersion;
    USHORT MajorVersion;
    CCHAR Number;
    CCHAR Reserved;
    USHORT BuildType;
    ULONG64 CurrentThread;
    ULONG64 NextThread;
    ULONG64 IdleThread;
    ULONG64 SetMember;
    ULONG64 NotSetMember;
    AMD64_KPROCESSOR_STATE ProcessorState;
    CCHAR CpuType;
    CCHAR CpuID;
    USHORT CpuStep;
    ULONG KernelReserved[16];
    ULONG HalReserved[16];
    ULONG PrcbAlign1[22];

//
// End of the architecturally defined section of the PRCB.
//
// end_nthal end_ntosp
//
// Numbered queued spin locks - 128-byte aligned.
//

    KSPIN_LOCK_QUEUE64 LockQueue[16];

//
// Nonpaged per processor lookaside lists - 128-byte aligned.
//

    PP_LOOKASIDE_LIST64 PPLookasideList[16];

//
// Nonpaged per processor small pool lookaside lists - 128-byte aligned.
//

    PP_LOOKASIDE_LIST64 PPNPagedLookasideList[NT51_POOL_SMALL_LISTS];

//
// Paged per processor small pool lookaside lists.
//

    PP_LOOKASIDE_LIST64 PPPagedLookasideList[NT51_POOL_SMALL_LISTS];

//
// MP interprocessor request packet barrier - 128-byte aligned.
//

    ULONG PacketBarrier;
    ULONG PrcbAlign2[31];

//
// MP interprocessor request packet and summary - 128-byte aligned.
//

    ULONG64 CurrentPacket[3];
    ULONG64 TargetSet;
    ULONG64 WorkerRoutine;
    ULONG IpiFrozen;
    ULONG PrcbAlign3[21];

//
// MP interprocessor request summary and packet address - 128-byte aligned.
//

    ULONG64 PacketRequest;
    ULONG RequestSummary;
    ULONG PrcbAlign4[29];

//
// DPC listhead, counts, and batching parameters - 128-byte aligned.
//

    LIST_ENTRY64 DpcListHead;
    ULONG64 DpcStack;
    ULONG64 SavedRsp;
    ULONG DpcCount;
    ULONG DpcQueueDepth;
    LOGICAL DpcRoutineActive;
    LOGICAL DpcInterruptRequested;
    ULONG DpcLastCount;
    ULONG DpcRequestRate;
    ULONG MaximumDpcQueueDepth;
    ULONG MinimumDpcRate;
    ULONG PrcbAlign5[16];

//
// DPC list lock - 128-byte aligned.
//

    ULONG64 DpcLock;
    ULONG PrcbAlign6[30];

//
// Miscellaneous counters - 128-byte aligned.
//

    ULONG InterruptCount;
    ULONG KernelTime;
    ULONG UserTime;
    ULONG DpcTime;
    ULONG InterruptTime;
    ULONG AdjustDpcThreshold;
    ULONG PageColor;
    ULONG TimerHand;
    ULONG64 ParentNode;
    ULONG64 MultiThreadProcessorSet;
    ULONG ThreadStartCount[2];

//
// Per processor data for various hot code which resides in the kernel image.
// Each processor has it's own copy of the data to lessen the caching impact
// of sharing the data between multiple processors.
//
// Cache manager performance counters.
//

    ULONG CcFastReadNoWait;
    ULONG CcFastReadWait;
    ULONG CcFastReadNotPossible;
    ULONG CcCopyReadNoWait;
    ULONG CcCopyReadWait;
    ULONG CcCopyReadNoWaitMiss;

//
// Kernel performance counters.
//

    ULONG KeAlignmentFixupCount;
    ULONG KeContextSwitches;
    ULONG KeDcacheFlushCount;
    ULONG KeExceptionDispatchCount;
    ULONG KeFirstLevelTbFills;
    ULONG KeFloatingEmulationCount;
    ULONG KeIcacheFlushCount;
    ULONG KeSecondLevelTbFills;
    ULONG KeSystemCalls;

//
// I/O system per processor single entry lookaside lists.
//

    ULONG64 SmallIrpFreeEntry;
    ULONG64 LargeIrpFreeEntry;
    ULONG64 MdlFreeEntry;

//
// Object manager per processor single entry lookaside lists.
//

    ULONG64 CreateInfoFreeEntry;
    ULONG64 NameBufferFreeEntry;

//
// Cache manager per processor single entry lookaside lists.
//

    ULONG64 SharedCacheMapEntry;

//
// Debug & processor information
//

    UCHAR VendorString[13];
    UCHAR InitialApicId;
    UCHAR LogicalProcessorsPerPhysicalProcessor;
    BOOLEAN SkipTick;
    ULONG MHz;
    ULONG FeatureBits;
    LARGE_INTEGER UpdateSignature;

} AMD64_PARTIAL_KPRCB, *PAMD64_PARTIAL_KPRCB;


typedef struct _AMD64_KPCR {

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

    NT_TIB64 NtTib;
    ULONG64 CurrentPrcb;
    ULONG64 SavedRcx;
    ULONG64 SavedR11;
    KIRQL Irql;
    UCHAR SecondLevelCacheAssociativity;
    UCHAR Number;
    UCHAR Fill0;
    ULONG Irr;
    ULONG IrrActive;
    ULONG Idr;
    USHORT MajorVersion;
    USHORT MinorVersion;
    ULONG StallScaleFactor;
    ULONG64 IdtBase;
    ULONG64 GdtBase;
    ULONG64 TssBase;

    ULONG KernelReserved[15];         // For use by the kernel
    ULONG SecondLevelCacheSize;
    ULONG HalReserved[16];            // For use by Hal

//
// End of the architecturally defined section of the PCR.
//
// end_nthal
//

    ULONG PcrAlign0;

    ULONG64 KdVersionBlock;

    ULONG PcrAlign1[26];
    ULONG Align16Fill[2];
    AMD64_PARTIAL_KPRCB Prcb;
} AMD64_KPCR, *PAMD64_KPCR;


typedef struct _ALPHA_KEXCEPTION_FRAME {

    ULONGLONG IntRa;    // return address register, ra

    ULONGLONG FltF2;    // nonvolatile floating registers, f2 - f9
    ULONGLONG FltF3;
    ULONGLONG FltF4;
    ULONGLONG FltF5;
    ULONGLONG FltF6;
    ULONGLONG FltF7;
    ULONGLONG FltF8;
    ULONGLONG FltF9;

    ULONGLONG IntS0;    //  nonvolatile integer registers, s0 - s5
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;
    ULONGLONG IntS4;
    ULONGLONG IntS5;
    ULONGLONG IntFp;    // frame pointer register, fp/s6

    ULONGLONG SwapReturn;
    ULONG Psr;          // processor status
    ULONG Fill[5];      // padding for 32-byte stack frame alignment
                        // N.B. - Ulongs from the filler section are used
                        //        in ctxsw.s - do not delete

} ALPHA_KEXCEPTION_FRAME, *PALPHA_KEXCEPTION_FRAME;


typedef struct _IA64_KNONVOLATILE_CONTEXT_POINTERS {
    PFLOAT128  FltS0;                       // Intel-IA64-Filler
    PFLOAT128  FltS1;                       // Intel-IA64-Filler
    PFLOAT128  FltS2;                       // Intel-IA64-Filler
    PFLOAT128  FltS3;                       // Intel-IA64-Filler
    PFLOAT128  HighFloatingContext[10];     // Intel-IA64-Filler
    PFLOAT128  FltS4;                       // Intel-IA64-Filler
    PFLOAT128  FltS5;                       // Intel-IA64-Filler
    PFLOAT128  FltS6;                       // Intel-IA64-Filler
    PFLOAT128  FltS7;                       // Intel-IA64-Filler
    PFLOAT128  FltS8;                       // Intel-IA64-Filler
    PFLOAT128  FltS9;                       // Intel-IA64-Filler
    PFLOAT128  FltS10;                      // Intel-IA64-Filler
    PFLOAT128  FltS11;                      // Intel-IA64-Filler
    PFLOAT128  FltS12;                      // Intel-IA64-Filler
    PFLOAT128  FltS13;                      // Intel-IA64-Filler
    PFLOAT128  FltS14;                      // Intel-IA64-Filler
    PFLOAT128  FltS15;                      // Intel-IA64-Filler
    PFLOAT128  FltS16;                      // Intel-IA64-Filler
    PFLOAT128  FltS17;                      // Intel-IA64-Filler
    PFLOAT128  FltS18;                      // Intel-IA64-Filler
    PFLOAT128  FltS19;                      // Intel-IA64-Filler

    PULONGLONG IntS0;                       // Intel-IA64-Filler
    PULONGLONG IntS1;                       // Intel-IA64-Filler
    PULONGLONG IntS2;                       // Intel-IA64-Filler
    PULONGLONG IntS3;                       // Intel-IA64-Filler
    PULONGLONG IntSp;                       // Intel-IA64-Filler
    PULONGLONG IntS0Nat;                    // Intel-IA64-Filler
    PULONGLONG IntS1Nat;                    // Intel-IA64-Filler
    PULONGLONG IntS2Nat;                    // Intel-IA64-Filler
    PULONGLONG IntS3Nat;                    // Intel-IA64-Filler
    PULONGLONG IntSpNat;                    // Intel-IA64-Filler

    PULONGLONG Preds;                       // Intel-IA64-Filler

    PULONGLONG BrRp;                        // Intel-IA64-Filler
    PULONGLONG BrS0;                        // Intel-IA64-Filler
    PULONGLONG BrS1;                        // Intel-IA64-Filler
    PULONGLONG BrS2;                        // Intel-IA64-Filler
    PULONGLONG BrS3;                        // Intel-IA64-Filler
    PULONGLONG BrS4;                        // Intel-IA64-Filler

    PULONGLONG ApUNAT;                      // Intel-IA64-Filler
    PULONGLONG ApLC;                        // Intel-IA64-Filler
    PULONGLONG ApEC;                        // Intel-IA64-Filler
    PULONGLONG RsPFS;                       // Intel-IA64-Filler

    PULONGLONG StFSR;                       // Intel-IA64-Filler
    PULONGLONG StFIR;                       // Intel-IA64-Filler
    PULONGLONG StFDR;                       // Intel-IA64-Filler
    PULONGLONG Cflag;                       // Intel-IA64-Filler

} IA64_KNONVOLATILE_CONTEXT_POINTERS, *PIA64_KNONVOLATILE_CONTEXT_POINTERS;

typedef struct _IA64_KEXCEPTION_FRAME {

    // Preserved application registers // Intel-IA64-Filler
    ULONGLONG ApEC;       // epilogue count // Intel-IA64-Filler
    ULONGLONG ApLC;       // loop count // Intel-IA64-Filler
    ULONGLONG IntNats;    // Nats for S0-S3; i.e. ar.UNAT after spill // Intel-IA64-Filler

    // Preserved (saved) interger registers, s0-s3 // Intel-IA64-Filler
    ULONGLONG IntS0; // Intel-IA64-Filler
    ULONGLONG IntS1; // Intel-IA64-Filler
    ULONGLONG IntS2; // Intel-IA64-Filler
    ULONGLONG IntS3; // Intel-IA64-Filler

    // Preserved (saved) branch registers, bs0-bs4 // Intel-IA64-Filler
    ULONGLONG BrS0; // Intel-IA64-Filler
    ULONGLONG BrS1; // Intel-IA64-Filler
    ULONGLONG BrS2; // Intel-IA64-Filler
    ULONGLONG BrS3; // Intel-IA64-Filler
    ULONGLONG BrS4; // Intel-IA64-Filler

    // Preserved (saved) floating point registers, f2 - f5, f16 - f31 // Intel-IA64-Filler
    FLOAT128 FltS0; // Intel-IA64-Filler
    FLOAT128 FltS1; // Intel-IA64-Filler
    FLOAT128 FltS2; // Intel-IA64-Filler
    FLOAT128 FltS3; // Intel-IA64-Filler
    FLOAT128 FltS4; // Intel-IA64-Filler
    FLOAT128 FltS5; // Intel-IA64-Filler
    FLOAT128 FltS6; // Intel-IA64-Filler
    FLOAT128 FltS7; // Intel-IA64-Filler
    FLOAT128 FltS8; // Intel-IA64-Filler
    FLOAT128 FltS9; // Intel-IA64-Filler
    FLOAT128 FltS10; // Intel-IA64-Filler
    FLOAT128 FltS11; // Intel-IA64-Filler
    FLOAT128 FltS12; // Intel-IA64-Filler
    FLOAT128 FltS13; // Intel-IA64-Filler
    FLOAT128 FltS14; // Intel-IA64-Filler
    FLOAT128 FltS15; // Intel-IA64-Filler
    FLOAT128 FltS16; // Intel-IA64-Filler
    FLOAT128 FltS17; // Intel-IA64-Filler
    FLOAT128 FltS18; // Intel-IA64-Filler
    FLOAT128 FltS19; // Intel-IA64-Filler

} IA64_KEXCEPTION_FRAME, *PIA64_KEXCEPTION_FRAME;

typedef struct _IA64_KSWITCH_FRAME { // Intel-IA64-Filler

    ULONGLONG SwitchPredicates; // Predicates for Switch // Intel-IA64-Filler
    ULONGLONG SwitchRp;         // return pointer for Switch // Intel-IA64-Filler
    ULONGLONG SwitchPFS;        // PFS for Switch // Intel-IA64-Filler
    ULONGLONG SwitchFPSR;   // ProcessorFP status at thread switch // Intel-IA64-Filler
    ULONGLONG SwitchBsp;                     // Intel-IA64-Filler
    ULONGLONG SwitchRnat;                     // Intel-IA64-Filler
    // ULONGLONG Pad;

    IA64_KEXCEPTION_FRAME SwitchExceptionFrame; // Intel-IA64-Filler

} IA64_KSWITCH_FRAME, *PIA64_KSWITCH_FRAME; // Intel-IA64-Filler

#define IA64_KTRAP_FRAME_ARGUMENTS (8 * 8)       // up to 8 in-memory syscall args // Intel-IA64-Filler

typedef struct _IA64_KTRAP_FRAME {

    //
    // Reserved for additional memory arguments and stack scratch area
    // The size of Reserved[] must be a multiple of 16 bytes.
    //

    ULONGLONG Reserved[(IA64_KTRAP_FRAME_ARGUMENTS+16)/8]; // Intel-IA64-Filler

    // Temporary (volatile) FP registers - f6-f15 (don't use f32+ in kernel) // Intel-IA64-Filler
    FLOAT128 FltT0; // Intel-IA64-Filler
    FLOAT128 FltT1; // Intel-IA64-Filler
    FLOAT128 FltT2; // Intel-IA64-Filler
    FLOAT128 FltT3; // Intel-IA64-Filler
    FLOAT128 FltT4; // Intel-IA64-Filler
    FLOAT128 FltT5; // Intel-IA64-Filler
    FLOAT128 FltT6; // Intel-IA64-Filler
    FLOAT128 FltT7; // Intel-IA64-Filler
    FLOAT128 FltT8; // Intel-IA64-Filler
    FLOAT128 FltT9; // Intel-IA64-Filler

    // Temporary (volatile) interger registers
    ULONGLONG IntGp;    // global pointer (r1) // Intel-IA64-Filler
    ULONGLONG IntT0; // Intel-IA64-Filler
    ULONGLONG IntT1; // Intel-IA64-Filler
                        // The following 4 registers fill in space of preserved  (S0-S3) to align Nats // Intel-IA64-Filler
    ULONGLONG ApUNAT;   // ar.UNAT on kernel entry // Intel-IA64-Filler
    ULONGLONG ApCCV;    // ar.CCV // Intel-IA64-Filler
    ULONGLONG ApDCR;    // DCR register on kernel entry // Intel-IA64-Filler
    ULONGLONG Preds;    // Predicates // Intel-IA64-Filler

    ULONGLONG IntV0;    // return value (r8) // Intel-IA64-Filler
    ULONGLONG IntT2; // Intel-IA64-Filler
    ULONGLONG IntT3; // Intel-IA64-Filler
    ULONGLONG IntT4; // Intel-IA64-Filler
    ULONGLONG IntSp;    // stack pointer (r12) // Intel-IA64-Filler
    ULONGLONG IntTeb;   // teb (r13) // Intel-IA64-Filler
    ULONGLONG IntT5; // Intel-IA64-Filler
    ULONGLONG IntT6; // Intel-IA64-Filler
    ULONGLONG IntT7; // Intel-IA64-Filler
    ULONGLONG IntT8; // Intel-IA64-Filler
    ULONGLONG IntT9; // Intel-IA64-Filler
    ULONGLONG IntT10; // Intel-IA64-Filler
    ULONGLONG IntT11; // Intel-IA64-Filler
    ULONGLONG IntT12; // Intel-IA64-Filler
    ULONGLONG IntT13; // Intel-IA64-Filler
    ULONGLONG IntT14; // Intel-IA64-Filler
    ULONGLONG IntT15; // Intel-IA64-Filler
    ULONGLONG IntT16; // Intel-IA64-Filler
    ULONGLONG IntT17; // Intel-IA64-Filler
    ULONGLONG IntT18; // Intel-IA64-Filler
    ULONGLONG IntT19; // Intel-IA64-Filler
    ULONGLONG IntT20; // Intel-IA64-Filler
    ULONGLONG IntT21; // Intel-IA64-Filler
    ULONGLONG IntT22; // Intel-IA64-Filler

    ULONGLONG IntNats;  // Temporary (volatile) registers' Nats directly from ar.UNAT at point of spill // Intel-IA64-Filler

    ULONGLONG BrRp;     // Return pointer on kernel entry // Intel-IA64-Filler

    ULONGLONG BrT0;     // Temporary (volatile) branch registers (b6-b7) // Intel-IA64-Filler
    ULONGLONG BrT1; // Intel-IA64-Filler

    // Register stack info // Intel-IA64-Filler
    ULONGLONG RsRSC;    // RSC on kernel entry // Intel-IA64-Filler
    ULONGLONG RsBSP;    // BSP on kernel entry // Intel-IA64-Filler
    ULONGLONG RsBSPSTORE; // User BSP Store at point of switch to kernel backing store // Intel-IA64-Filler
    ULONGLONG RsRNAT;   // old RNAT at point of switch to kernel backing store // Intel-IA64-Filler
    ULONGLONG RsPFS;    // PFS on kernel entry // Intel-IA64-Filler

    // Trap Status Information // Intel-IA64-Filler
    ULONGLONG StIPSR;   // Interruption Processor Status Register // Intel-IA64-Filler
    ULONGLONG StIIP;    // Interruption IP // Intel-IA64-Filler
    ULONGLONG StIFS;    // Interruption Function State // Intel-IA64-Filler
    ULONGLONG StFPSR;   // FP status // Intel-IA64-Filler
    ULONGLONG StISR;    // Interruption Status Register // Intel-IA64-Filler
    ULONGLONG StIFA;    // Interruption Data Address // Intel-IA64-Filler
    ULONGLONG StIIPA;   // Last executed bundle address // Intel-IA64-Filler
    ULONGLONG StIIM;    // Interruption Immediate // Intel-IA64-Filler
    ULONGLONG StIHA;    // Interruption Hash Address // Intel-IA64-Filler

    ULONG OldIrql;      // Previous Irql. // Intel-IA64-Filler
    ULONG PreviousMode; // Previous Mode. // Intel-IA64-Filler
    ULONGLONG TrapFrame;// Previous Trap Frame // Intel-IA64-Filler

    // Exception record
    UCHAR ExceptionRecord[(sizeof(EXCEPTION_RECORD64) + 15) & (~15)];

    // End of frame marker (for debugging)
    ULONGLONG Handler;  // Handler for this trap
    ULONGLONG EOFMarker;
} IA64_KTRAP_FRAME, *PIA64_KTRAP_FRAME;

typedef struct _IA64_UNWIND_INFO {     // Intel-IA64-Filler
    USHORT Version;               // Intel-IA64-Filler ; Version Number
    USHORT Flags;                 // Intel-IA64-Filler ; Flags
    ULONG DataLength;             // Intel-IA64-Filler ; Length of Descriptor Data
} IA64_UNWIND_INFO, *PIA64_UNWIND_INFO;     // Intel-IA64-Filler

//
// Define unwind operation codes.
//

typedef enum _AMD64_UNWIND_OP_CODES {
    AMD64_UWOP_PUSH_NONVOL = 0,
    AMD64_UWOP_ALLOC_LARGE,
    AMD64_UWOP_ALLOC_SMALL,
    AMD64_UWOP_SET_FPREG,
    AMD64_UWOP_SAVE_NONVOL,
    AMD64_UWOP_SAVE_NONVOL_FAR,
    AMD64_UWOP_SAVE_XMM,
    AMD64_UWOP_SAVE_XMM_FAR,
    AMD64_UWOP_SAVE_XMM128,
    AMD64_UWOP_SAVE_XMM128_FAR,
    AMD64_UWOP_PUSH_MACHFRAME
} AMD64_UNWIND_OP_CODES, *PAMD64_UNWIND_OP_CODES;

//
// Define unwind code structure.
//

typedef union _AMD64_UNWIND_CODE {
    struct {
        UCHAR CodeOffset;
        UCHAR UnwindOp : 4;
        UCHAR OpInfo : 4;
    };

    USHORT FrameOffset;
} AMD64_UNWIND_CODE, *PAMD64_UNWIND_CODE;

//
// Define unwind information flags.
//

#define AMD64_UNW_FLAG_NHANDLER 0x0
#define AMD64_UNW_FLAG_EHANDLER 0x1
#define AMD64_UNW_FLAG_UHANDLER 0x2
#define AMD64_UNW_FLAG_CHAININFO 0x4

//
// Define unwind information structure.
//

typedef struct _AMD64_UNWIND_INFO {
    UCHAR Version : 3;
    UCHAR Flags : 5;
    UCHAR SizeOfProlog;
    UCHAR CountOfCodes;
    UCHAR FrameRegister : 4;
    UCHAR FrameOffset : 4;
    AMD64_UNWIND_CODE UnwindCode[1];

//
// The unwind codes are followed by an optional DWORD aligned field that
// contains the exception handler address or the address of chained unwind
// information. If an exception handler address is specified, then it is
// followed by the language specified exception handler data.
//
//  union {
//      ULONG ExceptionHandler;
//      ULONG FunctionEntry;
//  };
//
//  ULONG ExceptionData[];
//

} AMD64_UNWIND_INFO, *PAMD64_UNWIND_INFO;

#define IA64_IP_SLOT 2                         // Intel-IA64-Filler
#define Ia64InsertIPSlotNumber(IP, SlotNumber) /* Intel-IA64-Filler */  \
                ((IP) | (SlotNumber << IA64_IP_SLOT))  // Intel-IA64-Filler

#define IA64_MM_EPC_VA          0xe0000000ffa00000
#define IA64_STACK_SCRATCH_AREA 16
#define IA64_SYSCALL_FRAME      0
#define IA64_INTERRUPT_FRAME    1
#define IA64_EXCEPTION_FRAME    2
#define IA64_CONTEXT_FRAME      10

#define IA64_IFS_IFM        0
#define IA64_IFS_IFM_LEN    38
#define IA64_IFS_MBZ0       38
#define IA64_IFS_MBZ0_V     0x1ffffffi64
#define IA64_IFS_V          63
#define IA64_IFS_V_LEN      1
#define IA64_PFS_EC_SHIFT             52
#define IA64_PFS_EC_SIZE              6
#define IA64_PFS_EC_MASK              0x3F
#define IA64_PFS_SIZE_SHIFT           7
#define IA64_PFS_SIZE_MASK            0x7F
#define IA64_NAT_BITS_PER_RNAT_REG    63
#define IA64_RNAT_ALIGNMENT           (IA64_NAT_BITS_PER_RNAT_REG << 3)

#define IA64_BREAK_DEBUG_BASE    0x080000
#define IA64_BREAK_SYSCALL_BASE  0x180000
#define IA64_BREAK_FASTSYS_BASE  0x1C0000
#define IA64_DEBUG_STOP_BREAKPOINT (IA64_BREAK_DEBUG_BASE+22)


#define ALPHA_PSR_USER_MODE 0x1
#define ALPHA_PSR_MODE 0x0              // Mode bit in PSR (bit 0)
#define ALPHA_PSR_MODE_MASK 0x1         // Mask (1 bit) for mode in PSR
#define ALPHA_PSR_IE 0x1                // Interrupt Enable bit in PSR (bit 1)
#define ALPHA_PSR_IE_MASK 0x1           // Mask (1 bit) for IE in PSR
#define ALPHA_PSR_IRQL 0x2              // IRQL in PSR (bit 2)
#define ALPHA_PSR_IRQL_MASK 0x7         // Mask (2 bits) for IRQL in PSR


#define X86_CONTEXT_X86               0x00010000

#define ALPHA_CONTEXT_ALPHA           0x00020000
#define ALPHA_CONTEXT_CONTROL         (ALPHA_CONTEXT_ALPHA | 0x00000001L)
#define ALPHA_CONTEXT_FLOATING_POINT  (ALPHA_CONTEXT_ALPHA | 0x00000002L)
#define ALPHA_CONTEXT_INTEGER         (ALPHA_CONTEXT_ALPHA | 0x00000004L)
#define ALPHA_CONTEXT_FULL \
    (ALPHA_CONTEXT_CONTROL | ALPHA_CONTEXT_FLOATING_POINT | \
     ALPHA_CONTEXT_INTEGER)

#define IA64_CONTEXT_IA64                  0x00080000
#define IA64_CONTEXT_CONTROL               (IA64_CONTEXT_IA64 | 0x00000001L)
#define IA64_CONTEXT_LOWER_FLOATING_POINT  (IA64_CONTEXT_IA64 | 0x00000002L)
#define IA64_CONTEXT_HIGHER_FLOATING_POINT (IA64_CONTEXT_IA64 | 0x00000004L)
#define IA64_CONTEXT_INTEGER               (IA64_CONTEXT_IA64 | 0x00000008L)
#define IA64_CONTEXT_DEBUG                 (IA64_CONTEXT_IA64 | 0x00000010L)
#define IA64_CONTEXT_IA32_CONTROL          (IA64_CONTEXT_IA64 | 0x00000020L)
#define IA64_CONTEXT_FLOATING_POINT \
    (IA64_CONTEXT_LOWER_FLOATING_POINT | IA64_CONTEXT_HIGHER_FLOATING_POINT)
#define IA64_CONTEXT_FULL \
    (IA64_CONTEXT_CONTROL | IA64_CONTEXT_FLOATING_POINT | IA64_CONTEXT_INTEGER | IA64_CONTEXT_IA32_CONTROL)

#define AMD64_CONTEXT_AMD64             0x00100000
#define AMD64_CONTEXT_CONTROL           (AMD64_CONTEXT_AMD64 | 0x1L)
#define AMD64_CONTEXT_INTEGER           (AMD64_CONTEXT_AMD64 | 0x2L)
#define AMD64_CONTEXT_SEGMENTS          (AMD64_CONTEXT_AMD64 | 0x4L)
#define AMD64_CONTEXT_FLOATING_POINT    (AMD64_CONTEXT_AMD64 | 0x8L)
#define AMD64_CONTEXT_DEBUG_REGISTERS   (AMD64_CONTEXT_AMD64 | 0x10L)
#define AMD64_CONTEXT_FULL \
    (AMD64_CONTEXT_CONTROL | AMD64_CONTEXT_INTEGER | AMD64_CONTEXT_FLOATING_POINT)


#define X86_NT4_KPRCB_SIZE       0x9F0
#define X86_NT5_KPRCB_SIZE       0x9F0
#define X86_NT51_KPRCB_SIZE      0xC50
#define ALPHA_KPRCB_SIZE         0xA00
#define AXP64_KPRCB_SIZE         0xC00
#define IA64_KPRCB_SIZE         0x1A40
#define AMD64_KPRCB_SIZE         0xC00

#define KPRCB_CURRENT_THREAD_OFFSET_32 4
#define KPRCB_CURRENT_THREAD_OFFSET_64 8

#define X86_1387_KPRCB_VENDOR_STRING  0x52D
#define X86_2087_KPRCB_VENDOR_STRING  0x72D
#define X86_2251_KPRCB_VENDOR_STRING  0x8AD
#define X86_2474_KPRCB_VENDOR_STRING  0x900
#define X86_VENDOR_STRING_SIZE           13

#define X86_NT5_EPROCESS_SIZE    0x288
#define X86_NT51_EPROCESS_SIZE   0x258
#define ALPHA_NT5_EPROCESS_SIZE  0x288
#define ALPHA_NT51_EPROCESS_SIZE 0x290
#define AXP64_EPROCESS_SIZE      0x418
#define IA64_EPROCESS_SIZE       0x3D0
#define AMD64_EPROCESS_SIZE      0x3D0

#define  ALPHA_NT5_PEB_IN_EPROCESS 0x1A8
#define ALPHA_NT51_PEB_IN_EPROCESS 0x1B0
#define        X86_PEB_IN_EPROCESS 0x1B0
#define    X86_NT4_PEB_IN_EPROCESS 0x18C
#define      AXP64_PEB_IN_EPROCESS 0x2B8
#define       IA64_PEB_IN_EPROCESS 0x2D0
#define  IA64_2259_PEB_IN_EPROCESS 0x300
#define      AMD64_PEB_IN_EPROCESS 0x2c0

#define ALPHA_DIRECTORY_TABLE_BASE_IN_EPROCESS 24
#define AXP64_DIRECTORY_TABLE_BASE_IN_EPROCESS 40
#define IA64_DIRECTORY_TABLE_BASE_IN_EPROCESS  40
#define X86_DIRECTORY_TABLE_BASE_IN_EPROCESS   24
#define AMD64_DIRECTORY_TABLE_BASE_IN_EPROCESS 40

#define X86_ETHREAD_SIZE         0x258
#define X86_NT51_ETHREAD_SIZE    0x260
#define ALPHA_ETHREAD_SIZE       0x258
#define AXP64_ETHREAD_SIZE       0x420
#define IA64_ETHREAD_SIZE        0x458
#define AMD64_ETHREAD_SIZE       0x458

#define X86_KTHREAD_NEXTPROCESSOR_OFFSET       0x11f
#define X86_2230_KTHREAD_NEXTPROCESSOR_OFFSET  0x123
#define X86_NT51_KTHREAD_NEXTPROCESSOR_OFFSET  0x12b
#define IA64_KTHREAD_NEXTPROCESSOR_OFFSET      0x23b
#define AMD64_KTHREAD_NEXTPROCESSOR_OFFSET     0x21b

#define PEB_FROM_TEB32    48
#define PEB_FROM_TEB64    96

#define STACK_BASE_FROM_TEB32 4
#define STACK_BASE_FROM_TEB64 8

#define PEBLDR_FROM_PEB32 12
#define PEBLDR_FROM_PEB64 24

#define MODULE_LIST_FROM_PEBLDR32 12
#define MODULE_LIST_FROM_PEBLDR64 16

#define IA64_TEB_BSTORE_BASE 0x1788

#define X86_SHARED_SYSCALL_BASE_LT2412  0x7ffe02e0
#define X86_SHARED_SYSCALL_BASE_GTE2412 0x7ffe02f8
#define X86_SHARED_SYSCALL_SIZE         0xf

#define X86_KI_USER_SHARED_DATA   0xffdf0000U
#define IA64_KI_USER_SHARED_DATA  0xe0000000fffe0000UI64
#define ALPHA_KI_USER_SHARED_DATA 0xff000000U
#define AXP64_KI_USER_SHARED_DATA 0xffffffffff000000UI64
#define AMD64_KI_USER_SHARED_DATA 0xfffff78000000000UI64

// Triage dumps contain a KPRCB and the debugger
// needs a safe address to map it into virtual space
// so that it's accessible in a way consistent with
// other dumps and live debugs.  The debugger uses
// an address in the user-shared-memory area on the
// theory that nothing in that area should be present
// in a kernel triage dump so it's a safe place to map in.
#define X86_TRIAGE_PRCB_ADDRESS   0xffdff120U
#define IA64_TRIAGE_PRCB_ADDRESS  0xe0000000ffff0000UI64
#define ALPHA_TRIAGE_PRCB_ADDRESS 0xffff0000U
#define AXP64_TRIAGE_PRCB_ADDRESS 0xffffffffffff0000UI64
#define AMD64_TRIAGE_PRCB_ADDRESS 0xfffff780ffff0000UI64

#define X86_KGDT_NULL       0
#define X86_KGDT_R0_CODE    8
#define X86_KGDT_R0_DATA    16
#define X86_KGDT_R3_CODE    24
#define X86_KGDT_R3_DATA    32
#define X86_KGDT_TSS        40
#define X86_KGDT_R0_PCR     48
#define X86_KGDT_R3_TEB     56
#define X86_KGDT_VDM_TILE   64
#define X86_KGDT_LDT        72
#define X86_KGDT_DF_TSS     80
#define X86_KGDT_NMI_TSS    88

#define X86_FRAME_EDITED            0xfff8
#define X86_MODE_MASK               1
#define X86_EFLAGS_V86_MASK         0x00020000

//
// Memory management info
//

#define X86_BASE_VIRT                0xc0300000
#define X86_BASE_VIRT_PAE            0xc0600000
#define X86_PAGE_SIZE                0x1000
#define X86_PAGE_SHIFT               12L
#define X86_MM_PTE_TRANSITION_MASK   0x800
#define X86_MM_PTE_PROTOTYPE_MASK    0x400
#define X86_VALID_PFN_MASK           0xFFFFF000
#define X86_VALID_PFN_MASK_PAE       0x0000000FFFFFF000UI64
#define X86_VALID_PFN_SHIFT          12
#define X86_PDPE_SHIFT               30
#define X86_PDE_SHIFT                22
#define X86_PDE_SHIFT_PAE            21
#define X86_PDE_MASK_PAE             0x1ff
#define X86_PTE_SHIFT                12
#define X86_PTE_MASK                 0x3ff
#define X86_PTE_MASK_PAE             0x1ff
#define X86_LARGE_PAGE_MASK          0x80
#define X86_LARGE_PAGE_SIZE          (4 * 1024 * 1024)
#define X86_LARGE_PAGE_SIZE_PAE      (2 * 1024 * 1024)
#define X86_PDBR_MASK                0xFFFFFFE0

#define IA64_PAGE_SIZE               0x2000
#define IA64_PAGE_SHIFT              13L
#define IA64_MM_PTE_TRANSITION_MASK  0x80
#define IA64_MM_PTE_PROTOTYPE_MASK   0x02
#define IA64_VALID_PFN_MASK          0x0007FFFFFFFFE000UI64
#define IA64_VALID_PFN_SHIFT         13
#define IA64_PDE1_SHIFT              33
#define IA64_PDE2_SHIFT              23
#define IA64_PDE_MASK                0x3ff
#define IA64_PTE_SHIFT               13
#define IA64_PTE_MASK                0x3ff
#define IA64_PHYSICAL1_START         0x8000000000000000UI64
#define IA64_PHYSICAL1_END           0x80000FFFFFFFFFFFUI64
#define IA64_PHYSICAL2_START         0xE000000080000000UI64
#define IA64_PHYSICAL2_END           0xE0000000BFFFFFFFUI64
#define IA64_PTA_BASE_MASK           0x1FFFFFFFFFFF8000UI64
#define IA64_REGION_MASK             0xE000000000000000UI64
#define IA64_REGION_SHIFT            61
#define IA64_REGION_COUNT            8
#define IA64_REGION_USER             0
#define IA64_REGION_SESSION          1
#define IA64_REGION_KERNEL           7
#define IA64_VHPT_MASK               0x000000FFFFFF8000UI64

#define AXP64_BASE_VIRT              0xFFFFFFFFC0180000UI64
#define AXP64_PAGE_SIZE              0x2000
#define AXP64_PAGE_SHIFT             13L
#define AXP64_MM_PTE_TRANSITION_MASK 0x4
#define AXP64_MM_PTE_PROTOTYPE_MASK  0x2
#define AXP64_VALID_PFN_MASK         0xFFFFFFFF00000000UI64
#define AXP64_VALID_PFN_SHIFT        32
#define AXP64_PDE1_SHIFT             33
#define AXP64_PDE2_SHIFT             23
#define AXP64_PDE_MASK               0x3ff
#define AXP64_PTE_SHIFT              13
#define AXP64_PTE_MASK               0x3ff
#define AXP64_PHYSICAL1_START        0xFFFFFC0000000000UI64
#define AXP64_PHYSICAL1_END          0xFFFFFDFFFFFFFFFFUI64
#define AXP64_PHYSICAL2_START        0xFFFFFFFF80000000UI64
#define AXP64_PHYSICAL2_END          0xFFFFFFFFBFFFFFFFUI64

#define ALPHA_BASE_VIRT              0xFFFFFFFFC0180000UI64
#define ALPHA_PAGE_SIZE              0x2000
#define ALPHA_PAGE_SHIFT             13L
#define ALPHA_MM_PTE_TRANSITION_MASK 0x4
#define ALPHA_MM_PTE_PROTOTYPE_MASK  0x2
#define ALPHA_VALID_PFN_MASK         0xFFFFFE00
#define ALPHA_VALID_PFN_SHIFT        9
#define ALPHA_PDE_SHIFT              24
#define ALPHA_PTE_SHIFT              13
#define ALPHA_PTE_MASK               0x7ff
#define ALPHA_PHYSICAL_START         0x80000000
#define ALPHA_PHYSICAL_END           0xBFFFFFFF

//
// Memory management info
//

#define AMD64_BASE_VIRT                0xFFFFF6FB7DBED000UI64
#define AMD64_PAGE_SIZE                0x1000
#define AMD64_PAGE_SHIFT               12L
#define AMD64_MM_PTE_TRANSITION_MASK   0x800
#define AMD64_MM_PTE_PROTOTYPE_MASK    0x400
#define AMD64_VALID_PFN_MASK           0x000000FFFFFFF000UI64
#define AMD64_VALID_PFN_SHIFT          12
#define AMD64_PML4E_SHIFT              39
#define AMD64_PML4E_MASK               0x1ff
#define AMD64_PDPE_SHIFT               30
#define AMD64_PDPE_MASK                0x1ff
#define AMD64_PDE_SHIFT                21
#define AMD64_PDE_MASK                 0x1ff
#define AMD64_PTE_SHIFT                12
#define AMD64_PTE_MASK                 0x1ff
#define AMD64_LARGE_PAGE_MASK          0x80
#define AMD64_LARGE_PAGE_SIZE          (2 * 1024 * 1024)
#define AMD64_PDBR_MASK                AMD64_VALID_PFN_MASK
#define AMD64_PHYSICAL_START           0xFFFFF80000000000UI64
#define AMD64_PHYSICAL_END             0xFFFFF8FFFFFFFFFFUI64


#define IA64_DEBUG_CONTROL_SPACE_PCR       1
#define IA64_DEBUG_CONTROL_SPACE_PRCB      2
#define IA64_DEBUG_CONTROL_SPACE_KSPECIAL  3
#define IA64_DEBUG_CONTROL_SPACE_THREAD    4

#define ALPHA_DEBUG_CONTROL_SPACE_PCR      1
#define ALPHA_DEBUG_CONTROL_SPACE_THREAD   2
#define ALPHA_DEBUG_CONTROL_SPACE_PRCB     3
#define ALPHA_DEBUG_CONTROL_SPACE_TEB      6

#define AMD64_DEBUG_CONTROL_SPACE_PCR      0
#define AMD64_DEBUG_CONTROL_SPACE_PRCB     1
#define AMD64_DEBUG_CONTROL_SPACE_KSPECIAL 2
#define AMD64_DEBUG_CONTROL_SPACE_THREAD   3

typedef struct _ALPHA_DYNAMIC_FUNCTION_TABLE {
    LIST_ENTRY32        Links;
    ULONG               FunctionTable;
    ULONG               EntryCount;
    LARGE_INTEGER       TimeStamp;
    ULONG               MinimumAddress;
    ULONG               MaximumAddress;
    BOOLEAN             Sorted;
} ALPHA_DYNAMIC_FUNCTION_TABLE, *PALPHA_DYNAMIC_FUNCTION_TABLE;

typedef struct _AXP64_DYNAMIC_FUNCTION_TABLE {
    LIST_ENTRY64        Links;
    ULONG64             FunctionTable;
    ULONG               EntryCount;
    LARGE_INTEGER       TimeStamp;
    ULONG64             MinimumAddress;
    ULONG64             MaximumAddress;
    BOOLEAN             Sorted;
} AXP64_DYNAMIC_FUNCTION_TABLE, *PAXP64_DYNAMIC_FUNCTION_TABLE;

#define ALPHA_RF_NOT_CONTIGUOUS    0
#define ALPHA_RF_ALT_ENT_PROLOG    1
#define ALPHA_RF_NULL_CONTEXT      2

#define ALPHA_RF_BEGIN_ADDRESS(RF)      ((RF)->BeginAddress & (~3))
#define ALPHA_RF_END_ADDRESS(RF)        ((RF)->EndAddress & (~3))
#define ALPHA_RF_EXCEPTION_HANDLER(RF)  (PEXCEPTION_ROUTINE)((ULONG_PTR)((RF)->ExceptionHandler) & (~3))
#define ALPHA_RF_ENTRY_TYPE(RF)         (ULONG)((ULONG_PTR)((RF)->HandlerData) & 3)
#define ALPHA_RF_PROLOG_END_ADDRESS(RF) ((RF)->PrologEndAddress & (~3))
#define ALPHA_RF_IS_FIXED_RETURN(RF)    (BOOLEAN)(((ULONG_PTR)((RF)->ExceptionHandler) & 2) >> 1)
#define ALPHA_RF_NULL_CONTEXT_COUNT(RF) (ULONG)((ULONG_PTR)((RF)->EndAddress) & 3)
#define ALPHA_RF_FIXED_RETURN(RF)       ((ULONG_PTR)((RF)->ExceptionHandler) & (~3))
#define ALPHA_RF_ALT_PROLOG(RF)         ((ULONG_PTR)((RF)->ExceptionHandler) & (~3))
#define ALPHA_RF_STACK_ADJUST(RF)       (ULONG)((ULONG_PTR)((RF)->ExceptionHandler) & (~3))


typedef enum _IA64_FUNCTION_TABLE_TYPE {
    IA64_RF_SORTED,
    IA64_RF_UNSORTED,
    IA64_RF_CALLBACK
} IA64_FUNCTION_TABLE_TYPE;

typedef struct _IA64_DYNAMIC_FUNCTION_TABLE
{
    LIST_ENTRY64        Links;
    ULONG64             FunctionTable;
    LARGE_INTEGER       TimeStamp;
    ULONG64             MinimumAddress;
    ULONG64             MaximumAddress;
    ULONG64             BaseAddress;
    ULONG64             TargetGp;
    ULONG64             Callback;
    ULONG64             Context;
    ULONG64             OutOfProcessCallbackDll;
    IA64_FUNCTION_TABLE_TYPE Type;
    ULONG               EntryCount;
} IA64_DYNAMIC_FUNCTION_TABLE, *PIA64_DYNAMIC_FUNCTION_TABLE;

#define IA64_RF_BEGIN_ADDRESS(Base,RF)      (( (ULONG64) Base + (RF)->BeginAddress) & (0xFFFFFFFFFFFFFFF0)) // Instruction Size 16 bytes
#define IA64_RF_END_ADDRESS(Base, RF)        (((ULONG64) Base + (RF)->EndAddress+15) & (0xFFFFFFFFFFFFFFF0))   // Instruction Size 16 bytes


typedef enum _AMD64_FUNCTION_TABLE_TYPE {
    AMD64_RF_SORTED,
    AMD64_RF_UNSORTED,
    AMD64_RF_CALLBACK
} AMD64_FUNCTION_TABLE_TYPE;

typedef struct _AMD64_DYNAMIC_FUNCTION_TABLE
{
    LIST_ENTRY64        ListEntry;
    ULONG64             FunctionTable;
    LARGE_INTEGER       TimeStamp;
    ULONG64             MinimumAddress;
    ULONG64             MaximumAddress;
    ULONG64             BaseAddress;
    ULONG64             Callback;
    ULONG64             Context;
    ULONG64             OutOfProcessCallbackDll;
    AMD64_FUNCTION_TABLE_TYPE Type;
    ULONG               EntryCount;
} AMD64_DYNAMIC_FUNCTION_TABLE, *PAMD64_DYNAMIC_FUNCTION_TABLE;

typedef struct _CROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE {

    union {
        ALPHA_DYNAMIC_FUNCTION_TABLE AlphaTable;
        AXP64_DYNAMIC_FUNCTION_TABLE Axp64Table;
        IA64_DYNAMIC_FUNCTION_TABLE  IA64Table;
        AMD64_DYNAMIC_FUNCTION_TABLE Amd64Table;
    };

} CROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE, *PCROSS_PLATFORM_DYNAMIC_FUNCTION_TABLE;


// More stuff currently used by crashdump


typedef struct _PAE_ADDRESS {
    union {
        struct {
            ULONG Offset : 12;                  // 0  .. 11
            ULONG Table : 9;                    // 12 .. 20
            ULONG Directory : 9;                // 21 .. 29
            ULONG DirectoryPointer : 2;         // 30 .. 31
        };
        struct {
            ULONG Offset : 21 ;
            ULONG Directory : 9 ;
            ULONG DirectoryPointer : 2;
        } LargeAddress;

        ULONG DwordPart;
    };
} PAE_ADDRESS, * PPAE_ADDRESS;

typedef struct _X86PAE_HARDWARE_PTE {
    union {
        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1; // software field
            ULONGLONG Prototype : 1;   // software field
            ULONGLONG reserved0 : 1;  // software field
            ULONGLONG PageFrameNumber : 24;
            ULONGLONG reserved1 : 28;  // software field
        };
        struct {
            ULONG LowPart;
            ULONG HighPart;
        };
    };
} X86PAE_HARDWARE_PTE, *PX86PAE_HARDWARE_PTE;

typedef X86PAE_HARDWARE_PTE X86PAE_HARDWARE_PDPTE;


typedef struct _X86PAE_HARDWARE_PDE {
    union {
        struct _X86PAE_HARDWARE_PTE Pte;

        struct {
            ULONGLONG Valid : 1;
            ULONGLONG Write : 1;
            ULONGLONG Owner : 1;
            ULONGLONG WriteThrough : 1;
            ULONGLONG CacheDisable : 1;
            ULONGLONG Accessed : 1;
            ULONGLONG Dirty : 1;
            ULONGLONG LargePage : 1;
            ULONGLONG Global : 1;
            ULONGLONG CopyOnWrite : 1;
            ULONGLONG Prototype : 1;
            ULONGLONG reserved0 : 1;
            ULONGLONG reserved2 : 9;
            ULONGLONG PageFrameNumber : 15;
            ULONGLONG reserved1 : 28;
        } Large;

        ULONGLONG QuadPart;
    };
} X86PAE_HARDWARE_PDE;

#if defined(_X86_)
typedef X86_DBGKD_CONTROL_REPORT   DBGKD_CONTROL_REPORT;
typedef X86_DBGKD_CONTROL_SET      DBGKD_CONTROL_SET;
#elif defined(_ALPHA_)
typedef ALPHA_DBGKD_CONTROL_REPORT DBGKD_CONTROL_REPORT;
typedef ALPHA_DBGKD_CONTROL_SET    DBGKD_CONTROL_SET;
#elif defined(_IA64_)
typedef IA64_DBGKD_CONTROL_REPORT  DBGKD_CONTROL_REPORT;
typedef IA64_DBGKD_CONTROL_SET     DBGKD_CONTROL_SET;
#elif defined(_AMD64_)
typedef AMD64_DBGKD_CONTROL_REPORT DBGKD_CONTROL_REPORT;
typedef AMD64_DBGKD_CONTROL_SET    DBGKD_CONTROL_SET;
#endif



//
// DbgKd APIs are for the portable kernel debugger
//

//
// KD_PACKETS are the low level data format used in KD. All packets
// begin with a packet leader, byte count, packet type. The sequence
// for accepting a packet is:
//
//  - read 4 bytes to get packet leader.  If read times out (10 seconds)
//    with a short read, or if packet leader is incorrect, then retry
//    the read.
//
//  - next read 2 byte packet type.  If read times out (10 seconds) with
//    a short read, or if packet type is bad, then start again looking
//    for a packet leader.
//
//  - next read 4 byte packet Id.  If read times out (10 seconds)
//    with a short read, or if packet Id is not what we expect, then
//    ask for resend and restart again looking for a packet leader.
//
//  - next read 2 byte count.  If read times out (10 seconds) with
//    a short read, or if byte count is greater than PACKET_MAX_SIZE,
//    then start again looking for a packet leader.
//
//  - next read 4 byte packet data checksum.
//
//  - The packet data immediately follows the packet.  There should be
//    ByteCount bytes following the packet header.  Read the packet
//    data, if read times out (10 seconds) then start again looking for
//    a packet leader.
//


typedef struct _KD_PACKET {
    ULONG PacketLeader;
    USHORT PacketType;
    USHORT ByteCount;
    ULONG PacketId;
    ULONG Checksum;
} KD_PACKET, *PKD_PACKET;


#define PACKET_MAX_SIZE 4000
#define INITIAL_PACKET_ID 0x80800000    // Don't use 0
#define SYNC_PACKET_ID    0x00000800    // Or in with INITIAL_PACKET_ID
                                        // to force a packet ID reset.

//
// BreakIn packet
//

#define BREAKIN_PACKET                  0x62626262
#define BREAKIN_PACKET_BYTE             0x62

//
// Packet lead in sequence
//

#define PACKET_LEADER                   0x30303030 //0x77000077
#define PACKET_LEADER_BYTE              0x30

#define CONTROL_PACKET_LEADER           0x69696969
#define CONTROL_PACKET_LEADER_BYTE      0x69

//
// Packet Trailing Byte
//

#define PACKET_TRAILING_BYTE            0xAA

//
// Packet Types
//

#define PACKET_TYPE_UNUSED              0
#define PACKET_TYPE_KD_STATE_CHANGE32   1
#define PACKET_TYPE_KD_STATE_MANIPULATE 2
#define PACKET_TYPE_KD_DEBUG_IO         3
#define PACKET_TYPE_KD_ACKNOWLEDGE      4       // Packet-control type
#define PACKET_TYPE_KD_RESEND           5       // Packet-control type
#define PACKET_TYPE_KD_RESET            6       // Packet-control type
#define PACKET_TYPE_KD_STATE_CHANGE64   7
#define PACKET_TYPE_KD_POLL_BREAKIN     8
#define PACKET_TYPE_KD_TRACE_IO         9
#define PACKET_TYPE_KD_CONTROL_REQUEST  10
#define PACKET_TYPE_KD_FILE_IO          11
#define PACKET_TYPE_MAX                 12

//
// If the packet type is PACKET_TYPE_KD_STATE_CHANGE, then
// the format of the packet data is as follows:
//

#define DbgKdMinimumStateChange       0x00003030L

#define DbgKdExceptionStateChange     0x00003030L
#define DbgKdLoadSymbolsStateChange   0x00003031L
#define DbgKdCommandStringStateChange 0x00003032L

#define DbgKdMaximumStateChange       0x00003033L

#define KD_REBOOT    (-1)
#define KD_HIBERNATE (-2)
//
// Pathname Data follows directly
//

typedef struct _DBGKD_LOAD_SYMBOLS32 {
    ULONG PathNameLength;
    ULONG BaseOfDll;
    ULONG ProcessId;
    ULONG CheckSum;
    ULONG SizeOfImage;
    BOOLEAN UnloadSymbols;
} DBGKD_LOAD_SYMBOLS32, *PDBGKD_LOAD_SYMBOLS32;

typedef struct _DBGKD_LOAD_SYMBOLS64 {
    ULONG PathNameLength;
    ULONG64 BaseOfDll;
    ULONG64 ProcessId;
    ULONG CheckSum;
    ULONG SizeOfImage;
    BOOLEAN UnloadSymbols;
} DBGKD_LOAD_SYMBOLS64, *PDBGKD_LOAD_SYMBOLS64;

__inline
void
DbgkdLoadSymbols32To64(
    IN PDBGKD_LOAD_SYMBOLS32 Ls32,
    OUT PDBGKD_LOAD_SYMBOLS64 Ls64
    )
{
    Ls64->PathNameLength = Ls32->PathNameLength;
    Ls64->ProcessId = Ls32->ProcessId;
    COPYSE(Ls64,Ls32,BaseOfDll);
    Ls64->CheckSum = Ls32->CheckSum;
    Ls64->SizeOfImage = Ls32->SizeOfImage;
    Ls64->UnloadSymbols = Ls32->UnloadSymbols;
}

__inline
void
LoadSymbols64To32(
    IN PDBGKD_LOAD_SYMBOLS64 Ls64,
    OUT PDBGKD_LOAD_SYMBOLS32 Ls32
    )
{
    Ls32->PathNameLength = Ls64->PathNameLength;
    Ls32->ProcessId = (ULONG)Ls64->ProcessId;
    Ls32->BaseOfDll = (ULONG)Ls64->BaseOfDll;
    Ls32->CheckSum = Ls64->CheckSum;
    Ls32->SizeOfImage = Ls64->SizeOfImage;
    Ls32->UnloadSymbols = Ls64->UnloadSymbols;
}

//
// This structure is currently all zeroes.
// It just reserves a structure name for future use.
//

typedef struct _DBGKD_COMMAND_STRING {
    ULONG Flags;
    ULONG Reserved1;
    ULONG64 Reserved2[7];
} DBGKD_COMMAND_STRING, *PDBGKD_COMMAND_STRING;

#ifdef _IA64_
#include <pshpck16.h>
#endif

typedef struct _DBGKD_WAIT_STATE_CHANGE32 {
    ULONG NewState;
    USHORT ProcessorLevel;
    USHORT Processor;
    ULONG NumberProcessors;
    ULONG Thread;
    ULONG ProgramCounter;
    union {
        DBGKM_EXCEPTION32 Exception;
        DBGKD_LOAD_SYMBOLS32 LoadSymbols;
    } u;
    // A processor-specific control report and context follows.
} DBGKD_WAIT_STATE_CHANGE32, *PDBGKD_WAIT_STATE_CHANGE32;

// Protocol version 5 64-bit state change.
typedef struct _DBGKD_WAIT_STATE_CHANGE64 {
    ULONG NewState;
    USHORT ProcessorLevel;
    USHORT Processor;
    ULONG NumberProcessors;
    ULONG64 Thread;
    ULONG64 ProgramCounter;
    union {
        DBGKM_EXCEPTION64 Exception;
        DBGKD_LOAD_SYMBOLS64 LoadSymbols;
    } u;
    // A processor-specific control report and context follows.
} DBGKD_WAIT_STATE_CHANGE64, *PDBGKD_WAIT_STATE_CHANGE64;

// Protocol version 6 state change.
typedef struct _DBGKD_ANY_WAIT_STATE_CHANGE {
    ULONG NewState;
    USHORT ProcessorLevel;
    USHORT Processor;
    ULONG NumberProcessors;
    ULONG64 Thread;
    ULONG64 ProgramCounter;
    union {
        DBGKM_EXCEPTION64 Exception;
        DBGKD_LOAD_SYMBOLS64 LoadSymbols;
        DBGKD_COMMAND_STRING CommandString;
    } u;
    // The ANY control report is unioned here to
    // ensure that this structure is always large
    // enough to hold any possible state change.
    union {
        DBGKD_CONTROL_REPORT ControlReport;
        DBGKD_ANY_CONTROL_REPORT AnyControlReport;
    };
} DBGKD_ANY_WAIT_STATE_CHANGE, *PDBGKD_ANY_WAIT_STATE_CHANGE;

#ifdef _IA64_
#include <poppack.h>
#endif

//
// If the packet type is PACKET_TYPE_KD_STATE_MANIPULATE, then
// the format of the packet data is as follows:
//
// Api Numbers for state manipulation
//

#define DbgKdMinimumManipulate              0x00003130L

#define DbgKdReadVirtualMemoryApi           0x00003130L
#define DbgKdWriteVirtualMemoryApi          0x00003131L
#define DbgKdGetContextApi                  0x00003132L
#define DbgKdSetContextApi                  0x00003133L
#define DbgKdWriteBreakPointApi             0x00003134L
#define DbgKdRestoreBreakPointApi           0x00003135L
#define DbgKdContinueApi                    0x00003136L
#define DbgKdReadControlSpaceApi            0x00003137L
#define DbgKdWriteControlSpaceApi           0x00003138L
#define DbgKdReadIoSpaceApi                 0x00003139L
#define DbgKdWriteIoSpaceApi                0x0000313AL
#define DbgKdRebootApi                      0x0000313BL
#define DbgKdContinueApi2                   0x0000313CL
#define DbgKdReadPhysicalMemoryApi          0x0000313DL
#define DbgKdWritePhysicalMemoryApi         0x0000313EL
//#define DbgKdQuerySpecialCallsApi           0x0000313FL
#define DbgKdSetSpecialCallApi              0x00003140L
#define DbgKdClearSpecialCallsApi           0x00003141L
#define DbgKdSetInternalBreakPointApi       0x00003142L
#define DbgKdGetInternalBreakPointApi       0x00003143L
#define DbgKdReadIoSpaceExtendedApi         0x00003144L
#define DbgKdWriteIoSpaceExtendedApi        0x00003145L
#define DbgKdGetVersionApi                  0x00003146L
#define DbgKdWriteBreakPointExApi           0x00003147L
#define DbgKdRestoreBreakPointExApi         0x00003148L
#define DbgKdCauseBugCheckApi               0x00003149L
#define DbgKdSwitchProcessor                0x00003150L
#define DbgKdPageInApi                      0x00003151L // obsolete
#define DbgKdReadMachineSpecificRegister    0x00003152L
#define DbgKdWriteMachineSpecificRegister   0x00003153L
#define OldVlm1                             0x00003154L
#define OldVlm2                             0x00003155L
#define DbgKdSearchMemoryApi                0x00003156L
#define DbgKdGetBusDataApi                  0x00003157L
#define DbgKdSetBusDataApi                  0x00003158L
#define DbgKdCheckLowMemoryApi              0x00003159L
#define DbgKdClearAllInternalBreakpointsApi 0x0000315AL
#define DbgKdFillMemoryApi                  0x0000315BL
#define DbgKdQueryMemoryApi                 0x0000315CL

#define DbgKdMaximumManipulate              0x0000315DL

//
// Physical memory caching flags.
// These flags can be passed in on physical memory
// access requests in the ActualBytes field.
//

#define DBGKD_CACHING_UNKNOWN        0
#define DBGKD_CACHING_CACHED         1
#define DBGKD_CACHING_UNCACHED       2
#define DBGKD_CACHING_WRITE_COMBINED 3

//
// Response is a read memory message with data following
//

typedef struct _DBGKD_READ_MEMORY32 {
    ULONG TargetBaseAddress;
    ULONG TransferCount;
    ULONG ActualBytesRead;
} DBGKD_READ_MEMORY32, *PDBGKD_READ_MEMORY32;

typedef struct _DBGKD_READ_MEMORY64 {
    ULONG64 TargetBaseAddress;
    ULONG TransferCount;
    ULONG ActualBytesRead;
} DBGKD_READ_MEMORY64, *PDBGKD_READ_MEMORY64;

__inline
void
DbgkdReadMemory32To64(
    IN PDBGKD_READ_MEMORY32 r32,
    OUT PDBGKD_READ_MEMORY64 r64
    )
{
    COPYSE(r64,r32,TargetBaseAddress);
    r64->TransferCount = r32->TransferCount;
    r64->ActualBytesRead = r32->ActualBytesRead;
}

__inline
void
DbgkdReadMemory64To32(
    IN PDBGKD_READ_MEMORY64 r64,
    OUT PDBGKD_READ_MEMORY32 r32
    )
{
    r32->TargetBaseAddress = (ULONG)r64->TargetBaseAddress;
    r32->TransferCount = r64->TransferCount;
    r32->ActualBytesRead = r64->ActualBytesRead;
}

//
// Data follows directly
//

typedef struct _DBGKD_WRITE_MEMORY32 {
    ULONG TargetBaseAddress;
    ULONG TransferCount;
    ULONG ActualBytesWritten;
} DBGKD_WRITE_MEMORY32, *PDBGKD_WRITE_MEMORY32;

typedef struct _DBGKD_WRITE_MEMORY64 {
    ULONG64 TargetBaseAddress;
    ULONG TransferCount;
    ULONG ActualBytesWritten;
} DBGKD_WRITE_MEMORY64, *PDBGKD_WRITE_MEMORY64;


__inline
void
DbgkdWriteMemory32To64(
    IN PDBGKD_WRITE_MEMORY32 r32,
    OUT PDBGKD_WRITE_MEMORY64 r64
    )
{
    COPYSE(r64,r32,TargetBaseAddress);
    r64->TransferCount = r32->TransferCount;
    r64->ActualBytesWritten = r32->ActualBytesWritten;
}

__inline
void
DbgkdWriteMemory64To32(
    IN PDBGKD_WRITE_MEMORY64 r64,
    OUT PDBGKD_WRITE_MEMORY32 r32
    )
{
    r32->TargetBaseAddress = (ULONG)r64->TargetBaseAddress;
    r32->TransferCount = r64->TransferCount;
    r32->ActualBytesWritten = r64->ActualBytesWritten;
}
//
// Response is a get context message with a full context record following
//

typedef struct _DBGKD_GET_CONTEXT {
    ULONG Unused;
} DBGKD_GET_CONTEXT, *PDBGKD_GET_CONTEXT;

//
// Full Context record follows
//

typedef struct _DBGKD_SET_CONTEXT {
    ULONG ContextFlags;
} DBGKD_SET_CONTEXT, *PDBGKD_SET_CONTEXT;

#define BREAKPOINT_TABLE_SIZE   32      // max number supported by kernel

typedef struct _DBGKD_WRITE_BREAKPOINT32 {
    ULONG BreakPointAddress;
    ULONG BreakPointHandle;
} DBGKD_WRITE_BREAKPOINT32, *PDBGKD_WRITE_BREAKPOINT32;

typedef struct _DBGKD_WRITE_BREAKPOINT64 {
    ULONG64 BreakPointAddress;
    ULONG BreakPointHandle;
} DBGKD_WRITE_BREAKPOINT64, *PDBGKD_WRITE_BREAKPOINT64;


__inline
void
DbgkdWriteBreakpoint32To64(
    IN PDBGKD_WRITE_BREAKPOINT32 r32,
    OUT PDBGKD_WRITE_BREAKPOINT64 r64
    )
{
    COPYSE(r64,r32,BreakPointAddress);
    r64->BreakPointHandle = r32->BreakPointHandle;
}

__inline
void
DbgkdWriteBreakpoint64To32(
    IN PDBGKD_WRITE_BREAKPOINT64 r64,
    OUT PDBGKD_WRITE_BREAKPOINT32 r32
    )
{
    r32->BreakPointAddress = (ULONG)r64->BreakPointAddress;
    r32->BreakPointHandle = r64->BreakPointHandle;
}

typedef struct _DBGKD_RESTORE_BREAKPOINT {
    ULONG BreakPointHandle;
} DBGKD_RESTORE_BREAKPOINT, *PDBGKD_RESTORE_BREAKPOINT;

typedef struct _DBGKD_BREAKPOINTEX {
    ULONG     BreakPointCount;
    NTSTATUS  ContinueStatus;
} DBGKD_BREAKPOINTEX, *PDBGKD_BREAKPOINTEX;

typedef struct _DBGKD_CONTINUE {
    NTSTATUS ContinueStatus;
} DBGKD_CONTINUE, *PDBGKD_CONTINUE;

// This structure must be 32-bit packed for
// for compatibility with older, processor-specific
// versions of this structure.
#include <pshpack4.h>

typedef struct _DBGKD_CONTINUE2 {
    NTSTATUS ContinueStatus;
    // The ANY control set is unioned here to
    // ensure that this structure is always large
    // enough to hold any possible continue.
    union {
        DBGKD_CONTROL_SET ControlSet;
        DBGKD_ANY_CONTROL_SET AnyControlSet;
    };
} DBGKD_CONTINUE2, *PDBGKD_CONTINUE2;

#include <poppack.h>

typedef struct _DBGKD_READ_WRITE_IO32 {
    ULONG DataSize;                     // 1, 2, 4
    ULONG IoAddress;
    ULONG DataValue;
} DBGKD_READ_WRITE_IO32, *PDBGKD_READ_WRITE_IO32;

typedef struct _DBGKD_READ_WRITE_IO64 {
    ULONG64 IoAddress;
    ULONG DataSize;                     // 1, 2, 4
    ULONG DataValue;
} DBGKD_READ_WRITE_IO64, *PDBGKD_READ_WRITE_IO64;

__inline
void
DbgkdReadWriteIo32To64(
    IN PDBGKD_READ_WRITE_IO32 r32,
    OUT PDBGKD_READ_WRITE_IO64 r64
    )
{
    COPYSE(r64,r32,IoAddress);
    r64->DataSize = r32->DataSize;
    r64->DataValue = r32->DataValue;
}

__inline
void
DbgkdReadWriteIo64To32(
    IN PDBGKD_READ_WRITE_IO64 r64,
    OUT PDBGKD_READ_WRITE_IO32 r32
    )
{
    r32->IoAddress = (ULONG)r64->IoAddress;
    r32->DataSize = r64->DataSize;
    r32->DataValue = r64->DataValue;
}

typedef struct _DBGKD_READ_WRITE_IO_EXTENDED32 {
    ULONG DataSize;                     // 1, 2, 4
    ULONG InterfaceType;
    ULONG BusNumber;
    ULONG AddressSpace;
    ULONG IoAddress;
    ULONG DataValue;
} DBGKD_READ_WRITE_IO_EXTENDED32, *PDBGKD_READ_WRITE_IO_EXTENDED32;

typedef struct _DBGKD_READ_WRITE_IO_EXTENDED64 {
    ULONG DataSize;                     // 1, 2, 4
    ULONG InterfaceType;
    ULONG BusNumber;
    ULONG AddressSpace;
    ULONG64 IoAddress;
    ULONG DataValue;
} DBGKD_READ_WRITE_IO_EXTENDED64, *PDBGKD_READ_WRITE_IO_EXTENDED64;

__inline
void
DbgkdReadWriteIoExtended32To64(
    IN PDBGKD_READ_WRITE_IO_EXTENDED32 r32,
    OUT PDBGKD_READ_WRITE_IO_EXTENDED64 r64
    )
{
    r64->DataSize = r32->DataSize;
    r64->InterfaceType = r32->InterfaceType;
    r64->BusNumber = r32->BusNumber;
    r64->AddressSpace = r32->AddressSpace;
    COPYSE(r64,r32,IoAddress);
    r64->DataValue = r32->DataValue;
}

__inline
void
DbgkdReadWriteIoExtended64To32(
    IN PDBGKD_READ_WRITE_IO_EXTENDED64 r64,
    OUT PDBGKD_READ_WRITE_IO_EXTENDED32 r32
    )
{
    r32->DataSize = r64->DataSize;
    r32->InterfaceType = r64->InterfaceType;
    r32->BusNumber = r64->BusNumber;
    r32->AddressSpace = r64->AddressSpace;
    r32->IoAddress = (ULONG)r64-> IoAddress;
    r32->DataValue = r64->DataValue;
}

typedef struct _DBGKD_READ_WRITE_MSR {
    ULONG Msr;
    ULONG DataValueLow;
    ULONG DataValueHigh;
} DBGKD_READ_WRITE_MSR, *PDBGKD_READ_WRITE_MSR;


typedef struct _DBGKD_QUERY_SPECIAL_CALLS {
    ULONG NumberOfSpecialCalls;
    // ULONG64 SpecialCalls[];
} DBGKD_QUERY_SPECIAL_CALLS, *PDBGKD_QUERY_SPECIAL_CALLS;

typedef struct _DBGKD_SET_SPECIAL_CALL32 {
    ULONG SpecialCall;
} DBGKD_SET_SPECIAL_CALL32, *PDBGKD_SET_SPECIAL_CALL32;

typedef struct _DBGKD_SET_SPECIAL_CALL64 {
    ULONG64 SpecialCall;
} DBGKD_SET_SPECIAL_CALL64, *PDBGKD_SET_SPECIAL_CALL64;

__inline
void
DbgkdSetSpecialCall64To32(
    IN PDBGKD_SET_SPECIAL_CALL64 r64,
    OUT PDBGKD_SET_SPECIAL_CALL32 r32
    )
{
    r32->SpecialCall = (ULONG)r64->SpecialCall;
}

#define DBGKD_MAX_INTERNAL_BREAKPOINTS 20

typedef struct _DBGKD_SET_INTERNAL_BREAKPOINT32 {
    ULONG BreakpointAddress;
    ULONG Flags;
} DBGKD_SET_INTERNAL_BREAKPOINT32, *PDBGKD_SET_INTERNAL_BREAKPOINT32;

typedef struct _DBGKD_SET_INTERNAL_BREAKPOINT64 {
    ULONG64 BreakpointAddress;
    ULONG Flags;
} DBGKD_SET_INTERNAL_BREAKPOINT64, *PDBGKD_SET_INTERNAL_BREAKPOINT64;

__inline
void
DbgkdSetInternalBreakpoint64To32(
    IN PDBGKD_SET_INTERNAL_BREAKPOINT64 r64,
    OUT PDBGKD_SET_INTERNAL_BREAKPOINT32 r32
    )
{
    r32->BreakpointAddress = (ULONG)r64->BreakpointAddress;
    r32->Flags = r64->Flags;
}

typedef struct _DBGKD_GET_INTERNAL_BREAKPOINT32 {
    ULONG BreakpointAddress;
    ULONG Flags;
    ULONG Calls;
    ULONG MaxCallsPerPeriod;
    ULONG MinInstructions;
    ULONG MaxInstructions;
    ULONG TotalInstructions;
} DBGKD_GET_INTERNAL_BREAKPOINT32, *PDBGKD_GET_INTERNAL_BREAKPOINT32;

typedef struct _DBGKD_GET_INTERNAL_BREAKPOINT64 {
    ULONG64 BreakpointAddress;
    ULONG Flags;
    ULONG Calls;
    ULONG MaxCallsPerPeriod;
    ULONG MinInstructions;
    ULONG MaxInstructions;
    ULONG TotalInstructions;
} DBGKD_GET_INTERNAL_BREAKPOINT64, *PDBGKD_GET_INTERNAL_BREAKPOINT64;

__inline
void
DbgkdGetInternalBreakpoint32To64(
    IN PDBGKD_GET_INTERNAL_BREAKPOINT32 r32,
    OUT PDBGKD_GET_INTERNAL_BREAKPOINT64 r64
    )
{
    COPYSE(r64,r32,BreakpointAddress);
    r64->Flags = r32->Flags;
    r64->Calls = r32->Calls;
    r64->MaxCallsPerPeriod = r32->MaxCallsPerPeriod;
    r64->MinInstructions = r32->MinInstructions;
    r64->MaxInstructions = r32->MaxInstructions;
    r64->TotalInstructions = r32->TotalInstructions;
}

__inline
void
DbgkdGetInternalBreakpoint64To32(
    IN PDBGKD_GET_INTERNAL_BREAKPOINT64 r64,
    OUT PDBGKD_GET_INTERNAL_BREAKPOINT32 r32
    )
{
    r32->BreakpointAddress = (ULONG)r64->BreakpointAddress;
    r32->Flags = r64->Flags;
    r32->Calls = r64->Calls;
    r32->MaxCallsPerPeriod = r64->MaxCallsPerPeriod;
    r32->MinInstructions = r64->MinInstructions;
    r32->MaxInstructions = r64->MaxInstructions;
    r32->TotalInstructions = r64->TotalInstructions;
}

#define DBGKD_INTERNAL_BP_FLAG_COUNTONLY 0x00000001 // don't count instructions
#define DBGKD_INTERNAL_BP_FLAG_INVALID   0x00000002 // disabled BP
#define DBGKD_INTERNAL_BP_FLAG_SUSPENDED 0x00000004 // temporarily suspended
#define DBGKD_INTERNAL_BP_FLAG_DYING     0x00000008 // kill on exit


//
// The packet protocol was widened to 64 bits in version 5.
// The PTR64 flag allows the debugger to read the right
// size of pointer when neccessary.
//
// The version packet was changed in the same revision, to remove the
// data that are now available in KDDEBUGGER_DATA.
//
// Version 6 adjusted the structures to use
// cross-platform versions all the time.
//
#define DBGKD_64BIT_PROTOCOL_VERSION1 5
#define DBGKD_64BIT_PROTOCOL_VERSION2 6


typedef struct _DBGKD_SEARCH_MEMORY {
    union {
        ULONG64 SearchAddress;
        ULONG64 FoundAddress;
    };
    ULONG64 SearchLength;
    ULONG PatternLength;
} DBGKD_SEARCH_MEMORY, *PDBGKD_SEARCH_MEMORY;


typedef struct _DBGKD_GET_SET_BUS_DATA {
    ULONG BusDataType;
    ULONG BusNumber;
    ULONG SlotNumber;
    ULONG Offset;
    ULONG Length;
} DBGKD_GET_SET_BUS_DATA, *PDBGKD_GET_SET_BUS_DATA;


#define DBGKD_FILL_MEMORY_VIRTUAL  0x00000001
#define DBGKD_FILL_MEMORY_PHYSICAL 0x00000002

typedef struct _DBGKD_FILL_MEMORY {
    ULONG64 Address;
    ULONG Length;
    USHORT Flags;
    USHORT PatternLength;
} DBGKD_FILL_MEMORY, *PDBGKD_FILL_MEMORY;

// Input AddressSpace values.
#define DBGKD_QUERY_MEMORY_VIRTUAL 0x00000000

// Output AddressSpace values.
#define DBGKD_QUERY_MEMORY_PROCESS 0x00000000
#define DBGKD_QUERY_MEMORY_SESSION 0x00000001
#define DBGKD_QUERY_MEMORY_KERNEL  0x00000002

// Output Flags.
// Currently the kernel always returns rwx.
#define DBGKD_QUERY_MEMORY_READ    0x00000001
#define DBGKD_QUERY_MEMORY_WRITE   0x00000002
#define DBGKD_QUERY_MEMORY_EXECUTE 0x00000004
#define DBGKD_QUERY_MEMORY_FIXED   0x00000008

typedef struct _DBGKD_QUERY_MEMORY {
    ULONG64 Address;
    ULONG64 Reserved;
    ULONG AddressSpace;
    ULONG Flags;
} DBGKD_QUERY_MEMORY, *PDBGKD_QUERY_MEMORY;


#include <pshpack4.h>

typedef struct _DBGKD_MANIPULATE_STATE32 {
    ULONG ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    NTSTATUS ReturnStatus;
    union {
        DBGKD_READ_MEMORY32 ReadMemory;
        DBGKD_WRITE_MEMORY32 WriteMemory;
        DBGKD_READ_MEMORY64 ReadMemory64;
        DBGKD_WRITE_MEMORY64 WriteMemory64;
        DBGKD_GET_CONTEXT GetContext;
        DBGKD_SET_CONTEXT SetContext;
        DBGKD_WRITE_BREAKPOINT32 WriteBreakPoint;
        DBGKD_RESTORE_BREAKPOINT RestoreBreakPoint;
        DBGKD_CONTINUE Continue;
        DBGKD_CONTINUE2 Continue2;
        DBGKD_READ_WRITE_IO32 ReadWriteIo;
        DBGKD_READ_WRITE_IO_EXTENDED32 ReadWriteIoExtended;
        DBGKD_QUERY_SPECIAL_CALLS QuerySpecialCalls;
        DBGKD_SET_SPECIAL_CALL32 SetSpecialCall;
        DBGKD_SET_INTERNAL_BREAKPOINT32 SetInternalBreakpoint;
        DBGKD_GET_INTERNAL_BREAKPOINT32 GetInternalBreakpoint;
        DBGKD_GET_VERSION32 GetVersion32;
        DBGKD_BREAKPOINTEX BreakPointEx;
        DBGKD_READ_WRITE_MSR ReadWriteMsr;
        DBGKD_SEARCH_MEMORY SearchMemory;
    } u;
} DBGKD_MANIPULATE_STATE32, *PDBGKD_MANIPULATE_STATE32;

#include <poppack.h>


typedef struct _DBGKD_MANIPULATE_STATE64 {
    ULONG ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    NTSTATUS ReturnStatus;
    union {
        DBGKD_READ_MEMORY64 ReadMemory;
        DBGKD_WRITE_MEMORY64 WriteMemory;
        DBGKD_GET_CONTEXT GetContext;
        DBGKD_SET_CONTEXT SetContext;
        DBGKD_WRITE_BREAKPOINT64 WriteBreakPoint;
        DBGKD_RESTORE_BREAKPOINT RestoreBreakPoint;
        DBGKD_CONTINUE Continue;
        DBGKD_CONTINUE2 Continue2;
        DBGKD_READ_WRITE_IO64 ReadWriteIo;
        DBGKD_READ_WRITE_IO_EXTENDED64 ReadWriteIoExtended;
        DBGKD_QUERY_SPECIAL_CALLS QuerySpecialCalls;
        DBGKD_SET_SPECIAL_CALL64 SetSpecialCall;
        DBGKD_SET_INTERNAL_BREAKPOINT64 SetInternalBreakpoint;
        DBGKD_GET_INTERNAL_BREAKPOINT64 GetInternalBreakpoint;
        DBGKD_GET_VERSION64 GetVersion64;
        DBGKD_BREAKPOINTEX BreakPointEx;
        DBGKD_READ_WRITE_MSR ReadWriteMsr;
        DBGKD_SEARCH_MEMORY SearchMemory;
        DBGKD_GET_SET_BUS_DATA GetSetBusData;
        DBGKD_FILL_MEMORY FillMemory;
        DBGKD_QUERY_MEMORY QueryMemory;
    } u;
} DBGKD_MANIPULATE_STATE64, *PDBGKD_MANIPULATE_STATE64;

__inline
ULONG
DbgkdManipulateState32To64(
    IN PDBGKD_MANIPULATE_STATE32 r32,
    OUT PDBGKD_MANIPULATE_STATE64 r64,
    OUT PULONG AdditionalDataSize
    )
{
    r64->ApiNumber = r32->ApiNumber;
    r64->ProcessorLevel = r32->ProcessorLevel;
    r64->Processor = r32->Processor;
    r64->ReturnStatus = r32->ReturnStatus;

    *AdditionalDataSize = 0;

    //
    // translate the messages which may be sent by the kernel
    //

    switch (r64->ApiNumber) {

        case DbgKdSetContextApi:
        case DbgKdRestoreBreakPointApi:
        case DbgKdContinueApi:
        case DbgKdContinueApi2:
        case DbgKdRebootApi:
        case DbgKdClearSpecialCallsApi:
        case DbgKdRestoreBreakPointExApi:
        case DbgKdCauseBugCheckApi:
        case DbgKdSwitchProcessor:
        case DbgKdWriteMachineSpecificRegister:
        case DbgKdWriteIoSpaceApi:
        case DbgKdSetSpecialCallApi:
        case DbgKdSetInternalBreakPointApi:
        case DbgKdWriteIoSpaceExtendedApi:
            break;



        case DbgKdReadMachineSpecificRegister:
            r64->u.ReadWriteMsr = r32->u.ReadWriteMsr;
            break;

        //
        // GetVersion may need to be handled by the calling code;
        // it needs to call DbgkdGetVersion32To64 with the DebuggerDataBlock.
        //

        case DbgKdGetVersionApi:
            break;

        case DbgKdGetContextApi:
            *AdditionalDataSize = sizeof(CONTEXT);
            break;

        //case DbgKdQuerySpecialCallsApi:
        //    r64->u.QuerySpecialCalls = r32->u.QuerySpecialCalls;
        //    *AdditionalDataSize = r64->u.QuerySpecialCalls.NumberOfSpecialCalls * sizeof(ULONG);
        //    break;

        case DbgKdWriteBreakPointExApi:
            r64->u.BreakPointEx = r32->u.BreakPointEx;
            *AdditionalDataSize = r64->u.BreakPointEx.BreakPointCount * sizeof(ULONG);
            break;

        case DbgKdReadVirtualMemoryApi:
        case DbgKdReadPhysicalMemoryApi:
        case DbgKdReadControlSpaceApi:
            DbgkdReadMemory32To64(&r32->u.ReadMemory, &r64->u.ReadMemory);
            if (NT_SUCCESS(r32->ReturnStatus)) {
                *AdditionalDataSize = r64->u.ReadMemory.ActualBytesRead;
            }
            break;

        case DbgKdWriteVirtualMemoryApi:
        case DbgKdWritePhysicalMemoryApi:
        case DbgKdWriteControlSpaceApi:
            DbgkdWriteMemory32To64(&r32->u.WriteMemory, &r64->u.WriteMemory);
            break;



        case DbgKdWriteBreakPointApi:
            DbgkdWriteBreakpoint32To64(&r32->u.WriteBreakPoint, &r64->u.WriteBreakPoint);
            break;

        case DbgKdReadIoSpaceApi:
            DbgkdReadWriteIo32To64(&r32->u.ReadWriteIo, &r64->u.ReadWriteIo);
            break;

        case DbgKdReadIoSpaceExtendedApi:
            DbgkdReadWriteIoExtended32To64(&r32->u.ReadWriteIoExtended, &r64->u.ReadWriteIoExtended);
            break;

        case DbgKdGetInternalBreakPointApi:
            DbgkdGetInternalBreakpoint32To64(&r32->u.GetInternalBreakpoint, &r64->u.GetInternalBreakpoint);
            break;

        case DbgKdSearchMemoryApi:
            r64->u.SearchMemory = r32->u.SearchMemory;
            break;
    }

    return sizeof(DBGKD_MANIPULATE_STATE64);
}

__inline
ULONG
DbgkdManipulateState64To32(
    IN PDBGKD_MANIPULATE_STATE64 r64,
    OUT PDBGKD_MANIPULATE_STATE32 r32
    )
{
    r32->ApiNumber = r64->ApiNumber;
    r32->ProcessorLevel = r64->ProcessorLevel;
    r32->Processor = r64->Processor;
    r32->ReturnStatus = r64->ReturnStatus;

    //
    // translate the messages sent by the debugger
    //

    switch (r32->ApiNumber) {

        //
        // These send nothing in the u part.
        case DbgKdGetContextApi:
        case DbgKdSetContextApi:
        case DbgKdClearSpecialCallsApi:
        case DbgKdRebootApi:
        case DbgKdCauseBugCheckApi:
        case DbgKdSwitchProcessor:
            break;


        case DbgKdRestoreBreakPointApi:
            r32->u.RestoreBreakPoint = r64->u.RestoreBreakPoint;
            break;

        case DbgKdContinueApi:
            r32->u.Continue = r64->u.Continue;
            break;

        case DbgKdContinueApi2:
            r32->u.Continue2 = r64->u.Continue2;
            break;

        //case DbgKdQuerySpecialCallsApi:
        //    r32->u.QuerySpecialCalls = r64->u.QuerySpecialCalls;
        //    break;

        case DbgKdRestoreBreakPointExApi:
            // NYI
            break;

        case DbgKdReadMachineSpecificRegister:
        case DbgKdWriteMachineSpecificRegister:
            r32->u.ReadWriteMsr = r64->u.ReadWriteMsr;
            break;

        case DbgKdGetVersionApi:
            r32->u.GetVersion32.ProtocolVersion = r64->u.GetVersion64.ProtocolVersion;
            break;

        case DbgKdWriteBreakPointExApi:
            r32->u.BreakPointEx = r64->u.BreakPointEx;
            break;

        case DbgKdWriteVirtualMemoryApi:
            DbgkdWriteMemory64To32(&r64->u.WriteMemory, &r32->u.WriteMemory);
            break;

        //
        // 32 bit systems only support 32 bit physical r/w
        //
        case DbgKdReadControlSpaceApi:
        case DbgKdReadVirtualMemoryApi:
        case DbgKdReadPhysicalMemoryApi:
            DbgkdReadMemory64To32(&r64->u.ReadMemory, &r32->u.ReadMemory);
            break;

        case DbgKdWritePhysicalMemoryApi:
            DbgkdWriteMemory64To32(&r64->u.WriteMemory, &r32->u.WriteMemory);
            break;

        case DbgKdWriteBreakPointApi:
            DbgkdWriteBreakpoint64To32(&r64->u.WriteBreakPoint, &r32->u.WriteBreakPoint);
            break;

        case DbgKdWriteControlSpaceApi:
            DbgkdWriteMemory64To32(&r64->u.WriteMemory, &r32->u.WriteMemory);
            break;

        case DbgKdReadIoSpaceApi:
        case DbgKdWriteIoSpaceApi:
            DbgkdReadWriteIo64To32(&r64->u.ReadWriteIo, &r32->u.ReadWriteIo);
            break;

        case DbgKdSetSpecialCallApi:
            DbgkdSetSpecialCall64To32(&r64->u.SetSpecialCall, &r32->u.SetSpecialCall);
            break;

        case DbgKdSetInternalBreakPointApi:
            DbgkdSetInternalBreakpoint64To32(&r64->u.SetInternalBreakpoint, &r32->u.SetInternalBreakpoint);
            break;

        case DbgKdGetInternalBreakPointApi:
            DbgkdGetInternalBreakpoint64To32(&r64->u.GetInternalBreakpoint, &r32->u.GetInternalBreakpoint);
            break;

        case DbgKdReadIoSpaceExtendedApi:
        case DbgKdWriteIoSpaceExtendedApi:
            DbgkdReadWriteIoExtended64To32(&r64->u.ReadWriteIoExtended, &r32->u.ReadWriteIoExtended);
            break;

        case DbgKdSearchMemoryApi:
            r32->u.SearchMemory = r64->u.SearchMemory;
            break;
    }

    return sizeof(DBGKD_MANIPULATE_STATE32);
}

//
// This is the format for the trace data passed back from the kernel to
// the debugger to describe multiple calls that have returned since the
// last trip back.  The basic format is that there are a bunch of these
// (4 byte) unions stuck together.  Each union is of one of two types: a
// 4 byte unsigned long integer, or a three field struct, describing a
// call (where "call" is delimited by returning or exiting the symbol
// scope).  If the number of instructions executed is too big to fit
// into a USHORT -1, then the Instructions field has
// TRACE_DATA_INSTRUCTIONS_BIG and the next union is a LongNumber
// containing the real number of instructions executed.
//
// The very first union returned in each callback is a LongNumber
// containing the number of unions returned (including the "size"
// record, so it's always at least 1 even if there's no data to return).
//
// This is all returned to the debugger when one of two things
// happens:
//
//   1) The pc moves out of all defined symbol ranges
//   2) The buffer of trace data entries is filled.
//
// The "trace done" case is hacked around on the debugger side.  It
// guarantees that the pc address that indicates a trace exit never
// winds up in a defined symbol range.
//
// The only other complexity in this system is handling the SymbolNumber
// table.  This table is kept in parallel by the kernel and the
// debugger.  When the PC exits a known symbol range, the Begin and End
// symbol ranges are set by the debugger and are allocated to the next
// symbol slot upon return.  "The next symbol slot" means the numerical
// next slot number, unless we've filled all slots, in which case it is
// #0.  (ie., allocation is cyclic and not LRU or something).  The
// SymbolNumber table is flushed when a SpecialCalls call is made (ie.,
// at the beginning of the WatchTrace).
//

typedef union _DBGKD_TRACE_DATA {
    struct {
        UCHAR SymbolNumber;
        CHAR LevelChange;
        USHORT Instructions;
    } s;
    ULONG LongNumber;
} DBGKD_TRACE_DATA, *PDBGKD_TRACE_DATA;

#define TRACE_DATA_INSTRUCTIONS_BIG 0xffff

#define TRACE_DATA_BUFFER_MAX_SIZE 40

//
// If the packet type is PACKET_TYPE_KD_DEBUG_IO, then
// the format of the packet data is as follows:
//

#define DbgKdPrintStringApi     0x00003230L
#define DbgKdGetStringApi       0x00003231L

//
// For print string, the Null terminated string to print
// immediately follows the message
//
typedef struct _DBGKD_PRINT_STRING {
    ULONG LengthOfString;
} DBGKD_PRINT_STRING, *PDBGKD_PRINT_STRING;

//
// For get string, the Null terminated prompt string
// immediately follows the message. The LengthOfStringRead
// field initially contains the maximum number of characters
// to read. Upon reply, this contains the number of bytes actually
// read. The data read immediately follows the message.
//
//
typedef struct _DBGKD_GET_STRING {
    ULONG LengthOfPromptString;
    ULONG LengthOfStringRead;
} DBGKD_GET_STRING, *PDBGKD_GET_STRING;

typedef struct _DBGKD_DEBUG_IO {
    ULONG ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    union {
        DBGKD_PRINT_STRING PrintString;
        DBGKD_GET_STRING GetString;
    } u;
} DBGKD_DEBUG_IO, *PDBGKD_DEBUG_IO;


//
// If the packet type is PACKET_TYPE_KD_TRACE_IO, then
// the format of the packet data is as follows:
//

#define DbgKdPrintTraceApi      0x00003330L

//
// For print trace, the trace buffer data
// immediately follows the message
//
typedef struct _DBGKD_PRINT_TRACE {
    ULONG LengthOfData;
} DBGKD_PRINT_TRACE, *PDBGKD_PRINT_TRACE;

typedef struct _DBGKD_TRACE_IO {
    ULONG ApiNumber;
    USHORT ProcessorLevel;
    USHORT Processor;
    union {
        ULONG64 ReserveSpace[7];
        DBGKD_PRINT_TRACE PrintTrace;
    } u;
} DBGKD_TRACE_IO, *PDBGKD_TRACE_IO;


//
// If the packet type is PACKET_TYPE_KD_CONTROL_REQUEST, then
// the format of the packet data is as follows:
//

#define DbgKdRequestHardwareBp  0x00004300L
#define DbgKdReleaseHardwareBp  0x00004301L

typedef struct _DBGKD_REQUEST_BREAKPOINT {
    ULONG HardwareBreakPointNumber;
    ULONG Available;
} DBGKD_REQUEST_BREAKPOINT, *PDBGKD_REQUEST_BREAKPOINT;

typedef struct _DBGKD_RELEASE_BREAKPOINT {
    ULONG HardwareBreakPointNumber;
    ULONG Released;
} DBGKD_RELEASE_BREAKPOINT, *PDBGKD_RELEASE_BREAKPOINT;


typedef struct _DBGKD_CONTROL_REQUEST {
    ULONG ApiNumber;
    union {
        DBGKD_REQUEST_BREAKPOINT RequestBreakpoint;
        DBGKD_RELEASE_BREAKPOINT ReleaseBreakpoint;
    } u;
} DBGKD_CONTROL_REQUEST, *PDBGKD_CONTROL_REQUEST;


//
// If the packet type is PACKET_TYPE_KD_FILE_IO, then
// the format of the packet data is as follows:
//

#define DbgKdCreateFileApi	0x00003430L
#define DbgKdReadFileApi        0x00003431L
#define DbgKdWriteFileApi       0x00003432L
#define DbgKdCloseFileApi       0x00003433L

// Unicode filename follows as additional data.
typedef struct _DBGKD_CREATE_FILE {
    ULONG DesiredAccess;
    ULONG FileAttributes;
    ULONG ShareAccess;
    ULONG CreateDisposition;
    ULONG CreateOptions;
    // Return values.
    ULONG64 Handle;
    ULONG64 Length;
} DBGKD_CREATE_FILE, *PDBGKD_CREATE_FILE;

// Data is returned as additional data in the response.
typedef struct _DBGKD_READ_FILE {
    ULONG64 Handle;
    ULONG64 Offset;
    ULONG Length;
} DBGKD_READ_FILE, *PDBGKD_READ_FILE;

// Data is given as additional data.
typedef struct _DBGKD_WRITE_FILE {
    ULONG64 Handle;
    ULONG64 Offset;
    ULONG Length;
} DBGKD_WRITE_FILE, *PDBGKD_WRITE_FILE;

typedef struct _DBGKD_CLOSE_FILE {
    ULONG64 Handle;
} DBGKD_CLOSE_FILE, *PDBGKD_CLOSE_FILE;

typedef struct _DBGKD_FILE_IO {
    ULONG ApiNumber;
    NTSTATUS Status;
    union {
        ULONG64 ReserveSpace[7];
        DBGKD_CREATE_FILE CreateFile;
        DBGKD_READ_FILE ReadFile;
        DBGKD_WRITE_FILE WriteFile;
        DBGKD_CLOSE_FILE CloseFile;
    } u;
} DBGKD_FILE_IO, *PDBGKD_FILE_IO;


//
// Define debug object access types. No security is present on this object.
//
#define DEBUG_READ_EVENT        (0x0001)
#define DEBUG_PROCESS_ASSIGN    (0x0002)
#define DEBUG_SET_INFORMATION   (0x0004)
#define DEBUG_QUERY_INFORMATION (0x0008)
#define DEBUG_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|DEBUG_READ_EVENT|DEBUG_PROCESS_ASSIGN|\
                              DEBUG_SET_INFORMATION|DEBUG_QUERY_INFORMATION)

#define DEBUG_KILL_ON_CLOSE  (0x1) // Kill all debuggees on last handle close

typedef enum _DEBUGOBJECTINFOCLASS {
    DebugObjectFlags = 1,
    MaxDebugObjectInfoClass
} DEBUGOBJECTINFOCLASS, *PDEBUGOBJECTINFOCLASS;

NTSTATUS
NtRemoveProcessDebug (
    IN HANDLE ProcessHandle,
    IN HANDLE DebugObjectHandle
    );

NTSTATUS
NtWaitForDebugEvent (
    IN HANDLE DebugObjectHandle,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    OUT PDBGUI_WAIT_STATE_CHANGE WaitStateChange
    );

NTSTATUS
NtDebugContinue (
    IN HANDLE DebugObjectHandle,
    IN PCLIENT_ID ClientId,
    IN NTSTATUS ContinueStatus
    );

NTSTATUS
NtCreateDebugObject (
    OUT PHANDLE DebugObjectHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Flags
    );

NTSTATUS
NtDebugActiveProcess (
    IN HANDLE ProcessHandle,
    IN HANDLE DebugObjectHandle
    );

NTSTATUS
NtSetInformationDebugObject (
    IN HANDLE DebugObjectHandle,
    IN DEBUGOBJECTINFOCLASS DebugObjectInformationClass,
    IN PVOID DebugInformation,
    IN ULONG DebugInformationLength,
    OUT PULONG ReturnLength OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif // _NTDBG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\sdktools\inc\pdhicalc.h ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

    pdhicalc.h

Abstract:

    calculation functions for the Data Provider Helper.

--*/

#ifndef _PDHICALC_H_
#define _PDHICALC_H_

#include <pdh.h>        // for public PDH data types
#include <winperf.h>    // for perf counter type constants

#if defined(__cplusplus)
#define LINK_SPEC extern "C"
#else
#define LINK_SPEC
#endif

// special perf counter type used by text log files
// value is stored as a double precision floating point value
#define PERF_DOUBLE_RAW     (PERF_SIZE_DWORD | 0x00002000 | PERF_TYPE_NUMBER | \
                                PERF_NUMBER_DECIMAL)


typedef double (APIENTRY COUNTERCALC) (PPDH_RAW_COUNTER, PPDH_RAW_COUNTER, LONGLONG*, LPDWORD);
typedef double (APIENTRY *LPCOUNTERCALC) (PPDH_RAW_COUNTER, PPDH_RAW_COUNTER, LONGLONG*, LPDWORD);

typedef PDH_STATUS (APIENTRY COUNTERSTAT) (LPVOID, DWORD, DWORD, DWORD, PPDH_RAW_COUNTER, PPDH_STATISTICS);
typedef PDH_STATUS (APIENTRY *LPCOUNTERSTAT) (LPVOID, DWORD, DWORD, DWORD, PPDH_RAW_COUNTER, PPDH_STATISTICS);

// calc functions
extern COUNTERCALC PdhiCalcDouble;
extern COUNTERCALC PdhiCalcAverage;
extern COUNTERCALC PdhiCalcElapsedTime;
extern COUNTERCALC PdhiCalcRawFraction;
extern COUNTERCALC PdhiCalcCounter;
extern COUNTERCALC PdhiCalcTimer;
extern COUNTERCALC PdhiCalcInverseTimer;
extern COUNTERCALC PdhiCalcRawCounter;
extern COUNTERCALC PdhiCalcNoData;
extern COUNTERCALC PdhiCalcDelta;

// status functions
extern COUNTERSTAT PdhiComputeFirstLastStats;
extern COUNTERSTAT PdhiComputeRawCountStats;
extern COUNTERSTAT PdhiComputeNoDataStats;

LINK_SPEC
PDH_STATUS 
PdhiComputeFormattedValue (
    IN      LPCOUNTERCALC       pCalcFunc,
    IN      DWORD               dwCounterType,
    IN      LONG                lScale,
    IN      DWORD               dwFormat,
    IN      PPDH_RAW_COUNTER    pRawValue1,
    IN      PPDH_RAW_COUNTER    pRawValue2,
    IN      PLONGLONG           pTimeBase,
    IN      DWORD               dwReserved,
    IN  OUT PPDH_FMT_COUNTERVALUE   fmtValue
);

LINK_SPEC
BOOL
AssignCalcFunction (
    IN      DWORD   dwCounterType,
    IN      LPCOUNTERCALC   *pCalcFunc,
    IN      LPCOUNTERSTAT   *pStatFunc
);

#endif // _PDHICALC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\sdktools\inc\pdhp.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pdhp.h

Abstract:

    PDH private APIs. Converts WMI event trace data to perf counters

Author:

    Melur Raghuraman (mraghu) 03-Oct-1997

Environment:

Revision History:


--*/

#ifndef __PDHP__
#define __PDHP__

#include <wchar.h>
#include <pdh.h>

#ifdef __cplusplus
extern "C" {
#endif

/*****************************************************************************\
    Private Pdh Section
\*****************************************************************************/


typedef struct _PDH_RELOG_INFO_A {
    LPSTR           strLog;
    DWORD           dwFileFormat;
    DWORD           dwFlags;
    PDH_TIME_INFO   TimeInfo;
    FILETIME        ftInterval;
    ULONG           Reserved1;
    ULONG           Reserved2;
} PDH_RELOG_INFO_A, *PPDH_RELOG_INFO_A;

typedef struct _PDH_RELOG_INFO_W {
    LPWSTR          strLog;
    DWORD           dwFileFormat;
    DWORD           dwFlags;
    PDH_TIME_INFO   TimeInfo;
    FILETIME        ftInterval;
    ULONG           Reserved1;
    ULONG           Reserved2;
} PDH_RELOG_INFO_W, *PPDH_RELOG_INFO_W;

PDH_FUNCTION
PdhRelogA( 
    HLOG    hLogIn,
    PPDH_RELOG_INFO_A  pRelogInfo
);

PDH_FUNCTION
PdhRelogW( 
    HLOG    hLogIn,
    PPDH_RELOG_INFO_W pRelogInfo
);

#ifdef UNICODE
#define PdhRelog            PdhRelogW
#define PDH_RELOG_INFO      PDH_RELOG_INFO_W
#define PPDH_RELOG_INFO     PPDH_RELOG_INFO_W
#else
#define PdhRelog            PdhRelogA
#define PDH_RELOG_INFO      PDH_RELOG_INFO_A
#define PPDH_RELOG_INFO     PPDH_RELOG_INFO_A
#endif

/*****************************************************************************\
    Performance Logs and Alerts Section
\*****************************************************************************/


#ifdef UNICODE
#define PdhPlaStart                PdhPlaStartW
#define PdhPlaStop                 PdhPlaStopW
#define PdhPlaSchedule             PdhPlaScheduleW
#define PdhPlaCreate               PdhPlaCreateW
#define PdhPlaDelete               PdhPlaDeleteW
#define PdhPlaAddItem              PdhPlaAddItemW
#define PdhPlaSetItemList          PdhPlaSetItemListW
#define PdhPlaRemoveAllItems       PdhPlaRemoveAllItemsW
#define PdhPlaGetInfo              PdhPlaGetInfoW
#define PdhPlaSetInfo              PdhPlaSetInfoW
#define PdhPlaSetRunAs             PdhPlaSetRunAsW
#define PdhPlaEnumCollections      PdhPlaEnumCollectionsW
#define PdhPlaValidateInfo         PdhPlaValidateInfoW
#define PDH_PLA_INFO               PDH_PLA_INFO_W
#define PPDH_PLA_INFO              PPDH_PLA_INFO_W
#define PDH_PLA_ITEM               PDH_PLA_ITEM_W
#define PPDH_PLA_ITEM              PPDH_PLA_ITEM_W
#define PdhTranslate009Counter     PdhTranslate009CounterW
#define PdhTranslateLocaleCounter  PdhTranslateLocaleCounterW
#define PdhAdd009Counter           PdhAdd009CounterW
#define PdhGetLogFileType          PdhGetLogFileTypeW
#define PdhPlaGetLogFileName       PdhPlaGetLogFileNameW
#define PdhPlaGetSchedule          PdhPlaGetScheduleW
#define PdhiPlaFormatBlanks        PdhiPlaFormatBlanksW
#else
#define PdhPlaStart                PdhPlaStartA
#define PdhPlaStop                 PdhPlaStopA
#define PdhPlaSchedule             PdhPlaScheduleW
#define PdhPlaCreate               PdhPlaCreateA
#define PdhPlaDelete               PdhPlaDeleteA
#define PdhPlaAddItem              PdhPlaAddItemA
#define PdhPlaSetItemList          PdhPlaSetItemListA
#define PdhPlaRemoveAllItems       PdhPlaRemoveAllItemA
#define PdhPlaGetInfo              PdhPlaGetInfoA
#define PdhPlaSetInfo              PdhPlaSetInfoA
#define PdhPlaSetRunAs             PdhPlaSetRunAsA
#define PdhPlaEnumCollections      PdhPlaEnumCollectionsA
#define PdhPlaValidateInfo         PdhPlaValidateInfoA
#define PDH_PLA_INFO               PDH_PLA_INFO_A
#define PPDH_PLA_INFO              PPDH_PLA_INFO_A
#define PDH_PLA_ITEM               PDH_PLA_ITEM_A
#define PPDH_PLA_ITEM              PPDH_PLA_ITEM_A
#define PdhTranslate009Counter     PdhTranslate009CounterA
#define PdhTranslateLocaleCounter  PdhTranslateLocaleCounterA
#define PdhAdd009Counter           PdhAdd009CounterA
#define PdhGetLogFileType          PdhGetLogFileTypeA
#define PdhPlaGetLogFileName       PdhPlaGetLogFileNameA
#define PdhPlaGetSchedule          PdhPlaGetScheduleA
#define PdhiPlaFormatBlanks        PdhiPlaFormatBlanksA
#endif

// wDataType values
#define PLA_TT_DTYPE_DATETIME   ((WORD)0x0001)
#define PLA_TT_DTYPE_UNITS      ((WORD)0x0002)

// dwMode values
#define PLA_AUTO_MODE_NONE      ((DWORD)0x00000000)       // Manual
#define PLA_AUTO_MODE_SIZE      ((DWORD)0x00000001)       // Size
#define PLA_AUTO_MODE_AT        ((DWORD)0x00000002)       // Time
#define PLA_AUTO_MODE_AFTER     ((DWORD)0x00000003)       // Value & unit type
#define PLA_AUTO_MODE_CALENDAR  ((DWORD)0x00000004)       // Schedule Calender

// wTimeType values
#define PLA_TT_TTYPE_START              ((WORD)0x0001)
#define PLA_TT_TTYPE_STOP               ((WORD)0x0002)
#define PLA_TT_TTYPE_RESTART            ((WORD)0x0003)
#define PLA_TT_TTYPE_SAMPLE             ((WORD)0x0004)
#define PLA_TT_TTYPE_LAST_MODIFIED      ((WORD)0x0005)
#define PLA_TT_TTYPE_CREATENEWFILE      ((WORD)0x0006)
#define PLA_TT_TTYPE_REPEAT_SCHEDULE    ((WORD)0x0007)

// dwUnitType values
#define PLA_TT_UTYPE_SECONDS        ((DWORD)0x00000001)    
#define PLA_TT_UTYPE_MINUTES        ((DWORD)0x00000002)   
#define PLA_TT_UTYPE_HOURS          ((DWORD)0x00000003)   
#define PLA_TT_UTYPE_DAYS           ((DWORD)0x00000004)   
#define PLA_TT_UTYPE_DAYSOFWEEK     ((DWORD)0x00000005)   

#pragma warning ( disable : 4201 )

typedef struct _PLA_TIME_INFO {
    WORD    wDataType;
    WORD    wTimeType;
    DWORD   dwAutoMode;
    union {
        LONGLONG    llDateTime; // filetime stored as a LONGLONG
        struct {
            DWORD   dwValue;
            DWORD   dwUnitType;
        };
    };
} PLA_TIME_INFO, *PPLA_TIME_INFO;

typedef struct _PDH_PLA_ITEM_W {
    DWORD dwType;
    union {
        LPWSTR strCounters;
        struct {
            LPWSTR strProviders;
            LPWSTR strFlags;
            LPWSTR strLevels;
        };
    };
} PDH_PLA_ITEM_W, *PPDH_PLA_ITEM_W;

typedef struct _PDH_PLA_ITEM_A {
    DWORD dwType;
    union {
        LPSTR strCounters;
        struct {
            LPSTR strProviders;
            LPSTR strFlags;
            LPSTR strLevels;
        };
    };
} PDH_PLA_ITEM_A, *PPDH_PLA_ITEM_A;

#pragma warning ( default : 4201 )

// Generic Fields
#define PLA_INFO_FLAG_USER        0x00000001
#define PLA_INFO_FLAG_FORMAT      0x00000002
#define PLA_INFO_FLAG_MAXLOGSIZE  0x00000004
#define PLA_INFO_FLAG_RUNCOMMAND  0x00000008
#define PLA_INFO_FLAG_FILENAME    0x00000010
#define PLA_INFO_FLAG_AUTOFORMAT  0x00000020
#define PLA_INFO_FLAG_DATASTORE   0x00000040
#define PLA_INFO_FLAG_REPEAT      0x00000080
#define PLA_INFO_FLAG_STATUS      0x00000100
#define PLA_INFO_FLAG_TYPE        0x00000200
#define PLA_INFO_FLAG_BEGIN       0x00000400
#define PLA_INFO_FLAG_END         0x00000800
#define PLA_INFO_FLAG_CRTNEWFILE  0x00001000
#define PLA_INFO_FLAG_DEFAULTDIR  0x00002000
#define PLA_INFO_FLAG_SRLNUMBER   0x00004000
#define PLA_INFO_FLAG_SQLNAME     0x00008000
#define PLA_INFO_FLAG_ALL         0xFFFFFFFF

// Trace Fields
#define PLA_INFO_FLAG_BUFFERSIZE  0x00010000
#define PLA_INFO_FLAG_LOGGERNAME  0x00020000
#define PLA_INFO_FLAG_MODE        0x00040000
#define PLA_INFO_FLAG_MINBUFFERS  0x00080000
#define PLA_INFO_FLAG_MAXBUFFERS  0x00100000
#define PLA_INFO_FLAG_FLUSHTIMER  0x00200000
#define PLA_INFO_FLAG_PROVIDERS   0x00400000
#define PLA_INFO_FLAG_TRACE       0x00FFFFFF

// Performance Fields
#define PLA_INFO_FLAG_INTERVAL    0x01000000
#define PLA_INFO_FLAG_COUNTERS    0x02000000
#define PLA_INFO_FLAG_PERF        0xFF00FFFF

#define PLA_INFO_CREATE_FILENAME    \
    (PLA_INFO_FLAG_FORMAT|          \
    PLA_INFO_FLAG_FILENAME|         \
    PLA_INFO_FLAG_AUTOFORMAT|       \
    PLA_INFO_FLAG_TYPE|             \
    PLA_INFO_FLAG_CRTNEWFILE|       \
    PLA_INFO_FLAG_DEFAULTDIR|       \
    PLA_INFO_FLAG_SRLNUMBER|        \
    PLA_INFO_FLAG_SQLNAME|          \
    PLA_INFO_FLAG_STATUS )          \


typedef struct _PDH_PLA_INFO_W {
    DWORD       dwMask;
    LPWSTR      strUser;
    LPWSTR      strPassword;
    DWORD       dwType;
    DWORD       dwMaxLogSize;
    DWORD       dwFlags;
    DWORD       dwLogQuota;
    LPWSTR      strLogFileCaption;
    LPWSTR      strDefaultDir;
    LPWSTR      strBaseFileName;
    LPWSTR      strSqlName;
    DWORD       dwFileFormat;
    DWORD       dwAutoNameFormat;
    DWORD       dwLogFileSerialNumber;
    LPWSTR      strCommandFileName;
    DWORD       dwDatastoreAttributes;
    PLA_TIME_INFO    ptLogBeginTime;
    PLA_TIME_INFO    ptLogEndTime;
    PLA_TIME_INFO    ptCreateNewFile;
    PLA_TIME_INFO    ptRepeat;
    DWORD       dwStatus;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
    union {
        struct {
            PDH_PLA_ITEM_W  piCounterList;
            DWORD           dwAutoNameInterval;
            DWORD           dwAutoNameUnits;
            PLA_TIME_INFO   ptSampleInterval;
        } Perf;
        struct {
            PDH_PLA_ITEM_W  piProviderList;
            LPWSTR  strLoggerName;
            DWORD   dwMode;
            DWORD   dwNumberOfBuffers;
            DWORD   dwMaximumBuffers;
            DWORD   dwMinimumBuffers;
            DWORD   dwBufferSize;
            DWORD   dwFlushTimer;
        } Trace;
    };
} PDH_PLA_INFO_W, *PPDH_PLA_INFO_W;

typedef struct _PDH_PLA_INFO_A {
    DWORD       dwMask;
    // NOT YET IMPLEMENTED
} PDH_PLA_INFO_A, *PPDH_PLA_INFO_A;

typedef struct _PLA_VERSION_ {
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuild;
    DWORD dwSubBuild;
} PLA_VERSION, *PPLA_VERSION;

HRESULT
PdhiPlaFormatBlanksA( 
    LPSTR strComputer, 
    LPSTR strFormat 
);

HRESULT
PdhiPlaFormatBlanksW( 
    LPWSTR strComputer, 
    LPWSTR strFormat 
);

PDH_FUNCTION
PdhPlaGetScheduleA(
    LPSTR strName, 
    LPSTR strComputer,
    LPDWORD pdwTypeStart,
    LPDWORD pdwTypeStop,
    PPDH_TIME_INFO pInfo
);

PDH_FUNCTION
PdhPlaGetScheduleW(
    LPWSTR strName, 
    LPWSTR strComputer,
    LPDWORD pdwTypeStart,
    LPDWORD pdwTypeStop,
    PPDH_TIME_INFO pInfo
);


PDH_FUNCTION
PlaTimeInfoToMilliSeconds(
    PLA_TIME_INFO* pTimeInfo,
    LONGLONG* pllmsecs
);

PDH_FUNCTION
PdhPlaValidateInfoA(
    LPSTR strName,
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION
PdhPlaValidateInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PdhPlaSetRunAsA(
    LPSTR strName,
    LPSTR strComputer,
    LPSTR strUser,
    LPSTR strPassword
);

PDH_FUNCTION
PdhPlaSetRunAsW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION 
PdhPlaScheduleA( 
    LPSTR strName, 
    LPSTR strComputer,
    DWORD fType,
    PPDH_TIME_INFO pInfo
);

PDH_FUNCTION 
PdhPlaScheduleW( 
    LPWSTR strName, 
    LPWSTR strComputer,
    DWORD fType,
    PPDH_TIME_INFO pInfo
);

PDH_FUNCTION 
PdhPlaStartA( 
    LPSTR strName, 
    LPSTR strComputer
);

PDH_FUNCTION 
PdhPlaStartW( 
    LPWSTR strName, 
    LPWSTR strComputer
);

PDH_FUNCTION 
PdhPlaStopA( 
    LPSTR strName, 
    LPSTR strComputer  
);

PDH_FUNCTION 
PdhPlaStopW( 
    LPWSTR strName, 
    LPWSTR strComputer  
);

PDH_FUNCTION 
PdhPlaCreateA( 
    LPSTR strName, 
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION 
PdhPlaCreateW( 
    LPWSTR strName, 
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION 
PdhPlaDeleteA( 
    LPSTR strName, 
    LPSTR strComputer
);

PDH_FUNCTION 
PdhPlaDeleteW( 
    LPWSTR strName, 
    LPWSTR strComputer
);

PDH_FUNCTION
PdhPlaAddItemA(
    LPSTR  strName,
    LPSTR  strComputer,
    PPDH_PLA_ITEM_A  pItem
);

PDH_FUNCTION 
PdhPlaAddItemW(
    LPWSTR  strName,
    LPWSTR  strComputer,
    PPDH_PLA_ITEM_W pItem
);

PDH_FUNCTION 
PdhPlaSetItemListA(
    LPSTR  strName,
    LPSTR  strComputer,
    PPDH_PLA_ITEM_A pItems
);

PDH_FUNCTION 
PdhPlaSetItemListW(
    LPWSTR  strName,
    LPWSTR  strComputer,
    PPDH_PLA_ITEM_W pItems
);

PDH_FUNCTION 
PdhPlaRemoveAllItemsA(
    LPSTR strName,
    LPSTR strComputer
);

PDH_FUNCTION 
PdhPlaRemoveAllItemsW(
    LPWSTR strName,
    LPWSTR strComputer
);

PDH_FUNCTION
PdhPlaGetInfoA(
    LPSTR strName,
    LPSTR strComputer,
    LPDWORD pdwBufferSize,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION
PdhPlaGetInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPDWORD pdwBufferSize,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PdhPlaSetInfoA(
    LPSTR strName,
    LPSTR strComputer,
    PPDH_PLA_INFO_A pInfo
);

PDH_FUNCTION
PdhPlaSetInfoW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo
);

PDH_FUNCTION
PdhPlaSetRunAsA(
    LPSTR strName,
    LPSTR strComputer,
    LPSTR strUser,
    LPSTR strPassword
);

PDH_FUNCTION
PdhPlaSetRunAsW(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION
PdhiPlaSetRunAs(
    LPWSTR strName,
    LPWSTR strComputer,
    LPWSTR strUser,
    LPWSTR strPassword
);

PDH_FUNCTION
PdhiPlaRunAs( 
    LPWSTR strName,
    LPWSTR strComputer,
    HANDLE* hToken
);

PDH_FUNCTION
PdhiPlaGetVersion(
    LPCWSTR strComputer,
    PPLA_VERSION pVersion 
);


PDH_FUNCTION
PdhPlaEnumCollectionsA( 
    LPSTR strComputer,
    LPDWORD pdwBufferSize,
    LPSTR mszCollections
);

PDH_FUNCTION
PdhPlaEnumCollectionsW( 
    LPWSTR strComputer,
    LPDWORD pdwBufferSize,
    LPWSTR mszCollections
);

PDH_FUNCTION
PdhPlaGetLogFileNameA(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_A pInfo,
    DWORD dwFlags,
    LPDWORD pdwBufferSize,
    LPWSTR strFileName
);

PDH_FUNCTION
PdhPlaGetLogFileNameW(
    LPWSTR strName,
    LPWSTR strComputer,
    PPDH_PLA_INFO_W pInfo,
    DWORD dwFlags,
    LPDWORD pdwBufferSize,
    LPWSTR strFileName
);

PDH_FUNCTION
PdhTranslate009CounterW(
    IN  LPWSTR      szLocalePath,
    IN  LPWSTR      pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhTranslate009CounterA(
    IN  LPSTR       szLocalePath,
    IN  LPSTR       pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhTranslateLocaleCounterW(
    IN  LPWSTR      sz009Path,
    IN  LPWSTR      pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhTranslateLocaleCounterA(
    IN  LPSTR       sz009Path,
    IN  LPSTR       pszFullPathName,
    IN  LPDWORD     pcchPathLength);

PDH_FUNCTION
PdhAdd009CounterW(
    IN  HQUERY      hQuery,
    IN  LPWSTR      szFullPath,
    IN  DWORD_PTR   dwUserData,
    OUT HCOUNTER  * phCounter);

PDH_FUNCTION
PdhAdd009CounterA(
    IN  HQUERY      hQuery,
    IN  LPSTR       szFullPath,
    IN  DWORD_PTR   dwUserData,
    OUT HCOUNTER  * phCounter);

PDH_FUNCTION
PdhGetLogFileTypeW(
    IN LPCWSTR LogFileName,
    IN LPDWORD LogFileType);

PDH_FUNCTION
PdhGetLogFileTypeA(
    IN LPCSTR  LogFileName,
    IN LPDWORD LogFileType);

PDH_FUNCTION
PdhListLogFileHeaderW (
    IN  LPCWSTR     szFileName,
    IN  LPWSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
);

PDH_FUNCTION
PdhListLogFileHeaderA (
    IN  LPCSTR     szFileName,
    IN  LPSTR      mszHeaderList,
    IN  LPDWORD     pcchHeaderListSize
);

#define PLA_SECONDS_IN_DAY      86400
#define PLA_SECONDS_IN_HOUR      3600
#define PLA_SECONDS_IN_MINUTE      60
#define _PLA_CONFIG_DLL_NAME_W_     L"SmLogCfg.dll"
#define _PLA_SERVICE_EXE_NAME_W_    L"SmLogSvc.exe"   

// Communication between smlogcfg and smlogsvc

#define PLA_MAX_AUTO_NAME_LEN   ((DWORD)0x0000000B)
#define PLA_MAX_COLLECTION_NAME   ((DWORD)(_MAX_FNAME - PLA_MAX_AUTO_NAME_LEN - 1))

#define PLA_FILENAME_USE_SUBEXT     0x00000001
#define PLA_FILENAME_GET_SUBFMT     0x00000002
#define PLA_FILENAME_GET_SUBXXX     0x00000004
#define PLA_FILENAME_CREATEONLY     0x00000008
#define PLA_FILENAME_CURRENTLOG     0x00000010

#define PLA_SERVICE_CONTROL_SYNCHRONIZE 128
#define PLA_QUERY_STOPPED       ((DWORD)0x00000000)              
#define PLA_QUERY_RUNNING       ((DWORD)0x00000001)
#define PLA_QUERY_START_PENDING ((DWORD)0x00000002)

#define PLA_NEW_LOG         ((DWORD)0xFFFFFFFF)
#define PLA_FIRST_LOG_TYPE  ((DWORD)0x00000000)
#define PLA_COUNTER_LOG     ((DWORD)0x00000000)
#define PLA_TRACE_LOG       ((DWORD)0x00000001)
#define PLA_ALERT           ((DWORD)0x00000002)
#define PLA_LAST_LOG_TYPE   ((DWORD)0x00000002)
#define PLA_NUM_LOG_TYPES   ((DWORD)0x00000003)

// Sysmon log output file configuration definitions

#define PLA_DATASTORE_APPEND_MASK       ((DWORD)0x000000F)     
#define PLA_DATASTORE_OVERWRITE         ((DWORD)0x0000001)     
#define PLA_DATASTORE_APPEND            ((DWORD)0x0000002)     

#define PLA_DATASTORE_SIZE_MASK         ((DWORD)0x00000F0)     
#define PLA_DATASTORE_SIZE_ONE_RECORD   ((DWORD)0x0000010)     
#define PLA_DATASTORE_SIZE_KB           ((DWORD)0x0000020)     
#define PLA_DATASTORE_SIZE_MB           ((DWORD)0x0000040)     

#define PLA_FIRST_FILE_TYPE ((DWORD)0x00000000)
#define PLA_CSV_FILE        ((DWORD)0x00000000)
#define PLA_TSV_FILE        ((DWORD)0x00000001)
#define PLA_BIN_FILE        ((DWORD)0x00000002)
#define PLA_BIN_CIRC_FILE   ((DWORD)0x00000003)
#define PLA_CIRC_TRACE_FILE ((DWORD)0x00000004)
#define PLA_SEQ_TRACE_FILE  ((DWORD)0x00000005)
#define PLA_SQL_LOG         ((DWORD)0x00000006)
#define PLA_NUM_FILE_TYPES  ((DWORD)0x00000007)

#define PLA_SLF_NAME_NONE           ((DWORD)0xFFFFFFFF)
#define PLA_SLF_NAME_FIRST_AUTO     ((DWORD)0x00000000)
#define PLA_SLF_NAME_MMDDHH         ((DWORD)0x00000000)
#define PLA_SLF_NAME_NNNNNN         ((DWORD)0x00000001)
#define PLA_SLF_NAME_YYYYDDD        ((DWORD)0x00000002)
#define PLA_SLF_NAME_YYYYMM         ((DWORD)0x00000003)
#define PLA_SLF_NAME_YYYYMMDD       ((DWORD)0x00000004)
#define PLA_SLF_NAME_YYYYMMDDHH     ((DWORD)0x00000005)
#define PLA_SLF_NAME_MMDDHHMM       ((DWORD)0x00000006)
#define PLA_SLF_NUM_AUTO_NAME_TYPES ((DWORD)0x00000007)

// Sysmon log query types and constants

// Constants
#define PLA_DISK_MAX_SIZE   ((DWORD)-1)

#define PLA_LOG_SIZE_UNIT_MB                (1024*1024)
#define PLA_LOG_SIZE_UNIT_KB                1024

#define PLA_TLI_ENABLE_BUFFER_FLUSH         ((DWORD)0x00000001)
#define PLA_TLI_ENABLE_KERNEL_TRACE         ((DWORD)0x00000002)
#define PLA_TLI_ENABLE_MEMMAN_TRACE         ((DWORD)0x00000004)
#define PLA_TLI_ENABLE_FILEIO_TRACE         ((DWORD)0x00000008)
#define PLA_TLI_ENABLE_PROCESS_TRACE        ((DWORD)0x00000010)
#define PLA_TLI_ENABLE_THREAD_TRACE         ((DWORD)0x00000020)
#define PLA_TLI_ENABLE_DISKIO_TRACE         ((DWORD)0x00000040)
#define PLA_TLI_ENABLE_NETWORK_TCPIP_TRACE  ((DWORD)0x00000080)

#define PLA_TLI_ENABLE_MASK                 ((DWORD)0x000000FF)
#define PLA_TLI_ENABLE_KERNEL_MASK          ((DWORD)0x000000FE)

// alert action flags
#define PLA_ALRT_ACTION_LOG_EVENT   ((DWORD)0x00000001)
#define PLA_ALRT_ACTION_SEND_MSG    ((DWORD)0x00000002)
#define PLA_ALRT_ACTION_EXEC_CMD    ((DWORD)0x00000004)
#define PLA_ALRT_ACTION_START_LOG   ((DWORD)0x00000008)
#define PLA_ALRT_ACTION_MASK        ((DWORD)0x0000000F)

#define PLA_ALRT_CMD_LINE_SINGLE    ((DWORD)0x00000100)
#define PLA_ALRT_CMD_LINE_A_NAME    ((DWORD)0x00000200)
#define PLA_ALRT_CMD_LINE_C_NAME    ((DWORD)0x00000400)
#define PLA_ALRT_CMD_LINE_D_TIME    ((DWORD)0x00000800)
#define PLA_ALRT_CMD_LINE_L_VAL     ((DWORD)0x00001000)
#define PLA_ALRT_CMD_LINE_M_VAL     ((DWORD)0x00002000)
#define PLA_ALRT_CMD_LINE_U_TEXT    ((DWORD)0x00004000)
#define PLA_ALRT_CMD_LINE_MASK      ((DWORD)0x00007F00)

#define PLA_ALRT_DEFAULT_ACTION     ((DWORD)0x00000001) // log event is default

#define PLA_AIBF_UNDER  0L
#define PLA_AIBF_OVER   ((DWORD)0x00000001) // true when "over" limit is selected
#define PLA_AIBF_SEEN   ((DWORD)0x00000002) // set when the user has seen this value
#define PLA_AIBF_SAVED  ((DWORD)0x00000004) // true when user has saved this entry in an edit box
 
typedef struct _PLA_ALERT_INFO_BLOCK {
    DWORD   dwSize;
    LPTSTR  szCounterPath;
    DWORD   dwFlags;
    double  dLimit;
} PLA_ALERT_INFO_BLOCK, *PPLA_ALERT_INFO_BLOCK;

#ifdef __cplusplus
}
#endif

#endif // __PDHP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\sdktools\inc\sptlib.h ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    spt.h

Abstract:

    SCSI_PASS_THROUGH header for user-mode apps

Environment:

    User mode only

Revision History:
    
    4/10/2000 - created

--*/

#ifndef __SPTLIB_H__
#define __SPTLIB_H__

#pragma warning(push)
#pragma warning(disable:4200) // array[0] is not a warning for this file

#include <windows.h>  // sdk
#include <devioctl.h> // sdk
#include <ntddscsi.h> // sdk 
#define _NTSRB_       // allow user-mode scsi.h
#include <scsi.h>     // ddk
#undef  _NTSRB_

#define SPT_DEFAULT_TIMEOUT    60 // one minute timeout is default
#define SPT_MODE_SENSE_TIMEOUT 10 // more than this is not likely

typedef enum _SPT_MODE_PAGE_TYPE {
    SptModePageTypeCurrent   = 0x00,
    SptModePageTypeChangable = 0x40,
    SptModePageTypeDefault   = 0x80,
    SptModePageTypeSaved     = 0xc0
} SPT_MODE_PAGE_TYPE, *PSPT_MODE_PAGE_TYPE;

//
// this simplified and speeds processing of MODE_SENSE 
// and MODE_SELECT commands
//

struct _SPT_MODE_PAGE_INFO;
typedef struct _SPT_MODE_PAGE_INFO
                SPT_MODE_PAGE_INFO,
              *PSPT_MODE_PAGE_INFO;

#define SPT_NOT_READY_RETRY_INTERVAL 100 // 10 seconds
#define MAXIMUM_DEFAULT_RETRIES        5 //  5 retries

/*++

Routine Description:

    Validates the CDB length matches the opcode's command group.

Arguments:

Return Value:

    TRUE if size is correct or cannot be verified.
    FALSE if size is mismatched.

--*/
BOOL
SptUtilValidateCdbLength(
    IN PCDB Cdb,
    IN UCHAR CdbSize
    );

/*++

Routine Description:

    Simplistic way to send a command to a device.

Arguments:

    DeviceHandle - handle to device to send command to
    
    Cdb - command to send to the device
    
    CdbSize - size of the cdb
    
    Buffer - Buffer to send to/get from the device 
    
    BufferSize - Size of available buffer on input.
                 Size of returned data when routine completes
                   iff GetDataFromDevice is TRUE
    
    GetDataFromDevice - TRUE if getting data from device
                        FALSE if sending data to the device

Return Value:

    TRUE if the command completed successfully

--*/
BOOL
SptSendCdbToDevice(
    IN      HANDLE  DeviceHandle,
    IN      PCDB    Cdb,
    IN      UCHAR   CdbSize,
    IN      PUCHAR  Buffer,
    IN OUT  PDWORD  BufferSize,
    IN      BOOLEAN GetDataFromDevice
    );

/*++

Routine Description:

Arguments:
    
    DeviceHandle - handle to device to send command to
    
    Cdb - command to send to the device
    
    CdbSize - size of the cdb
    
    Buffer - Buffer to send to/get from the device 
    
    BufferSize - Size of available buffer on input.
                 Size of returned data when routine completes
                   iff GetDataFromDevice is TRUE
    
    SenseData - Optional buffer to store sense data on errors.
                Must be NULL if SenseDataSize is zero.
                Must be non-NULL if SenseDataSize is non-zero.
    
    SenseDataSize - Size of sense data to return to host.
                    Must be zero if SenseData is NULL.
                    Must be non-zero if SenseData is non-NULL.
        
    
    GetDataFromDevice - TRUE if getting data from device
                        FALSE if sending data to the device
    
    TimeOut - Number of seconds before the command should timeout

Return Value:

    TRUE if the command completed successfully.
    
    FALSE if the command encountered an error
        Data will also be transferred (check *BufferSize) if there is sense
          data, but validity is not guaranteed.
        SenseData may be valid, and may report ERROR_SUCCESS, meaning that
          the resulting data is valid. (call SptUtilInterpretSenseInfo)

--*/
BOOL
SptSendCdbToDeviceEx(
    IN      HANDLE      DeviceHandle,
    IN      PCDB        Cdb,
    IN      UCHAR       CdbSize,
    IN OUT  PUCHAR      Buffer,
    IN OUT  PDWORD      BufferSize,
       OUT  PSENSE_DATA SenseData,         // if non-null, size must be non-zero
    IN      UCHAR       SenseDataSize,     
    IN      BOOLEAN     GetDataFromDevice, // true = receive data
    IN      DWORD       TimeOut            // in seconds
    );


/*++

Routine Description:

    This is a user-mode translation of ClassInterpretSenseInfo()
    from classpnp.sys.  The ErrorValue is deduced based upon the
    sense data, as well as whether the command should be retried or
    not (and in approximately how long). 
    
    NOTE: we default to RETRY==TRUE except for known error classes


Arguments:

    SenseData - pointer to the sense data
    
    SenseDataSize - size of sense data
    
    ErrorValue - pointer to location to store resulting error value.
        NOTE: may return ERROR_SUCCESS
        
    SuggestedRetry - pointer to location to store if the command should
        be retried.  it is the responsibility of the caller to limit the
        number of retries.
        
    SuggestedRetryDelay - pointer to location to store how long the caller
        should delay (in 1/10 second increments) before retrying the command
        if SuggestedRetry ends up being set to TRUE.

Return Value:

    None

--*/
VOID
SptUtilInterpretSenseInfo(
    IN     PSENSE_DATA SenseData,
    IN     UCHAR       SenseDataSize,
       OUT PDWORD      ErrorValue,  // from WinError.h
       OUT PBOOLEAN    SuggestRetry OPTIONAL,
       OUT PDWORD      SuggestRetryDelay OPTIONAL
    );

#pragma warning(pop)
#endif // __SPTLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\badapps.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    badapp.h

Abstract:

    Declares the structures used for CheckBadApps data.

Author:

    Calin Negreanu (calinn) 01/20/1999

Revision History:

--*/

#pragma once

#define APPTYPE_TYPE_MASK     0x000000FF

#define APPTYPE_INC_NOBLOCK   0x00000001
#define APPTYPE_INC_HARDBLOCK 0x00000002
#define APPTYPE_MINORPROBLEM  0x00000003
#define APPTYPE_REINSTALL     0x00000004
#define APPTYPE_VERSIONSUB    0x00000005
#define APPTYPE_SHIM          0x00000006

#define APPTYPE_FLAG_MASK     0xFFFFFF00

#define APPTYPE_FLAG_NONET    0x00000100
#define APPTYPE_FLAG_FAT32    0x00000200
#define APPTYPE_FLAG_NTFS     0x00000400

typedef struct {
    DWORD Size;
    DWORD MsgId;
    DWORD AppType;
} BADAPP_PROP, *PBADAPP_PROP;

typedef struct {
    DWORD Size;
    PCTSTR FilePath;
    PBYTE Blob;
    DWORD BlobSize;
} BADAPP_DATA, *PBADAPP_DATA;

BOOL
SHIsBadApp (
    IN      PBADAPP_DATA Data,
    OUT     PBADAPP_PROP Prop
    );

#define EDIT    TRUE
#define NOEDIT  FALSE

// version allowances
#define VA_ALLOWMAINFILE     0x01
#define VA_ALLOWADDNLFILES   0x02

#define VA_ALLOWALLFILES     0x03

//
// Do not change any values in this enum. You can only add new values
// immediately above VTID_LASTID
//
typedef enum {
    VTID_BAD_VTID           = 0,    // do not use or change !!!
    VTID_REQFILE            = 1,    // this should never change !!!
    VTID_FILESIZE           = VTID_REQFILE + 1,
    VTID_EXETYPE            = VTID_REQFILE + 2,
    VTID_BINFILEVER         = VTID_REQFILE + 3,
    VTID_BINPRODUCTVER      = VTID_REQFILE + 4,
    VTID_FILEDATEHI         = VTID_REQFILE + 5,
    VTID_FILEDATELO         = VTID_REQFILE + 6,
    VTID_FILEVEROS          = VTID_REQFILE + 7,
    VTID_FILEVERTYPE        = VTID_REQFILE + 8,
    VTID_CHECKSUM           = VTID_REQFILE + 9,
    VTID_PECHECKSUM         = VTID_REQFILE +10,
    VTID_COMPANYNAME        = VTID_REQFILE +11,
    VTID_PRODUCTVERSION     = VTID_REQFILE +12,
    VTID_PRODUCTNAME        = VTID_REQFILE +13,
    VTID_FILEDESCRIPTION    = VTID_REQFILE +14,
    VTID_FILEVERSION        = VTID_REQFILE +15,
    VTID_ORIGINALFILENAME   = VTID_REQFILE +16,
    VTID_INTERNALNAME       = VTID_REQFILE +17,
    VTID_LEGALCOPYRIGHT     = VTID_REQFILE +18,
    VTID_16BITDESCRIPTION   = VTID_REQFILE +19,
    VTID_UPTOBINPRODUCTVER  = VTID_REQFILE +20,
    VTID_PREVOSMAJORVERSION = VTID_REQFILE +21,
    VTID_PREVOSMINORVERSION = VTID_REQFILE +22,
    VTID_PREVOSPLATFORMID   = VTID_REQFILE +23,
    VTID_PREVOSBUILDNO      = VTID_REQFILE +24,

    // add new versions here

    VTID_LASTID
};

#define VERSION_STAMPS \
    LIBARGS(VTID_FILESIZE, ShCheckFileSize) \
    TOOLARGS(TEXT("FILESIZE"), TEXT("File Size:"), VA_ALLOWALLFILES, NOEDIT, QueryFileSize, OutputHexValue)\
    \
    LIBARGS(VTID_EXETYPE, ShCheckModuleType) \
    TOOLARGS(TEXT("EXETYPE"), TEXT("Module Type:"), VA_ALLOWADDNLFILES, NOEDIT, QueryModuleType, OutputModuleTypeValue)\
    \
    LIBARGS(VTID_BINFILEVER, ShCheckBinFileVer) \
    TOOLARGS(TEXT("BINFILEVER"), TEXT("Binary File Version:"), VA_ALLOWALLFILES, EDIT, QueryBinFileVer, OutputBinVerValue)\
    \
    LIBARGS(VTID_BINPRODUCTVER, ShCheckBinProductVer) \
    TOOLARGS(TEXT("BINPRODUCTVER"), TEXT("Binary Product Version:"), VA_ALLOWALLFILES, EDIT, QueryBinProductVer, OutputBinVerValue)\
    \
    LIBARGS(VTID_FILEDATEHI, ShCheckFileDateHi) \
    TOOLARGS(TEXT("FILEDATEHI"), TEXT("File Date (HI):"), VA_ALLOWALLFILES, NOEDIT, QueryFileDateHi, OutputHexValue)\
    \
    LIBARGS(VTID_FILEDATELO, ShCheckFileDateLo) \
    TOOLARGS(TEXT("FILEDATELO"), TEXT("File Date (LO):"), VA_ALLOWALLFILES, NOEDIT, QueryFileDateLo, OutputHexValue)\
    \
    LIBARGS(VTID_FILEVEROS, ShCheckFileVerOs) \
    TOOLARGS(TEXT("FILEVEROS"), TEXT("File OS Version:"), VA_ALLOWALLFILES, NOEDIT, QueryFileVerOs, OutputHexValue)\
    \
    LIBARGS(VTID_FILEVERTYPE, ShCheckFileVerType) \
    TOOLARGS(TEXT("FILEVERTYPE"), TEXT("File Type:"), VA_ALLOWALLFILES, NOEDIT, QueryFileVerType, OutputHexValue)\
    \
    LIBARGS(VTID_CHECKSUM, ShCheckFileCheckSum) \
    TOOLARGS(TEXT("CHECKSUM"), TEXT("File CheckSum:"), VA_ALLOWALLFILES, NOEDIT, QueryFileCheckSum, OutputHexValue)\
    \
    LIBARGS(VTID_PECHECKSUM, ShCheckFilePECheckSum) \
    TOOLARGS(TEXT("PECHECKSUM"), TEXT("File Header CheckSum:"), VA_ALLOWALLFILES, NOEDIT, QueryFilePECheckSum, OutputHexValue)\
    \
    LIBARGS(VTID_COMPANYNAME, ShCheckCompanyName) \
    TOOLARGS(TEXT("COMPANYNAME"), TEXT("Company Name:"), VA_ALLOWALLFILES, EDIT, QueryCompanyName, OutputStrValue)\
    \
    LIBARGS(VTID_PRODUCTVERSION, ShCheckProductVersion) \
    TOOLARGS(TEXT("PRODUCTVERSION"), TEXT("Product Version:"), VA_ALLOWALLFILES, EDIT, QueryProductVersion, OutputStrValue)\
    \
    LIBARGS(VTID_PRODUCTNAME, ShCheckProductName) \
    TOOLARGS(TEXT("PRODUCTNAME"), TEXT("Product Name:"), VA_ALLOWALLFILES, EDIT, QueryProductName, OutputStrValue)\
    \
    LIBARGS(VTID_FILEDESCRIPTION, ShCheckFileDescription) \
    TOOLARGS(TEXT("FILEDESCRIPTION"), TEXT("File Description:"), VA_ALLOWALLFILES, EDIT, QueryFileDescription, OutputStrValue)\
    \
    LIBARGS(VTID_FILEVERSION, ShCheckFileVersion) \
    TOOLARGS(TEXT("FILEVERSION"), TEXT("File Version:"), VA_ALLOWALLFILES, EDIT, QueryFileVersion, OutputStrValue)\
    \
    LIBARGS(VTID_ORIGINALFILENAME, ShCheckOriginalFileName) \
    TOOLARGS(TEXT("ORIGINALFILENAME"), TEXT("Original File Name:"), VA_ALLOWALLFILES, EDIT, QueryOriginalFileName, OutputStrValue)\
    \
    LIBARGS(VTID_INTERNALNAME, ShCheckInternalName) \
    TOOLARGS(TEXT("INTERNALNAME"), TEXT("Internal Name:"), VA_ALLOWALLFILES, EDIT, QueryInternalName, OutputStrValue)\
    \
    LIBARGS(VTID_LEGALCOPYRIGHT, ShCheckLegalCopyright) \
    TOOLARGS(TEXT("LEGALCOPYRIGHT"), TEXT("Legal Copyright:"), VA_ALLOWALLFILES, EDIT, QueryLegalCopyright, OutputStrValue)\
    \
    LIBARGS(VTID_16BITDESCRIPTION, ShCheck16BitDescription) \
    TOOLARGS(TEXT("DESCRIPTION"), TEXT("16 Bit Description:"), VA_ALLOWALLFILES, EDIT, Query16BitDescription, OutputStrValue)\
    \
    LIBARGS(VTID_UPTOBINPRODUCTVER, ShCheckUpToBinProductVer) \
    TOOLARGS(TEXT("UPTOBINPRODUCTVER"), TEXT("Up To Binary Product Version:"), VA_ALLOWALLFILES, EDIT, QueryBinProductVer, OutputUpToBinVerValue)\
    \
    LIBARGS(VTID_PREVOSMAJORVERSION, ShCheckPrevOsMajorVersion) \
    TOOLARGS(TEXT("PREVOSMAJORVERSION"), TEXT("Previous OS Major Version:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsMajorVersion, OutputDecValue)\
    \
    LIBARGS(VTID_PREVOSMINORVERSION, ShCheckPrevOsMinorVersion) \
    TOOLARGS(TEXT("PREVOSMINORVERSION"), TEXT("Previous OS Minor Version:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsMinorVersion, OutputDecValue)\
    \
    LIBARGS(VTID_PREVOSPLATFORMID, ShCheckPrevOsPlatformId) \
    TOOLARGS(TEXT("PREVOSPLATFORMID"), TEXT("Previous OS Platform Id:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsPlatformId, OutputDecValue)\
    \
    LIBARGS(VTID_PREVOSBUILDNO, ShCheckPrevOsBuildNo) \
    TOOLARGS(TEXT("PREVOSBUILDNR"), TEXT("Previous OS Build No:"), VA_ALLOWMAINFILE, EDIT, QueryPrevOsBuildNo, OutputDecValue)\
    \

#define S_KEY_PREVOSVERSION     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\PrevOsVersion")
#define S_VAL_BUILDNO           TEXT("BuildNumber")
#define S_VAL_MAJORVERSION      TEXT("MajorVersion")
#define S_VAL_MINORVERSION      TEXT("MinorVersion")
#define S_VAL_PLATFORMID        TEXT("PlatformId")

#define S_VER_COMPANYNAME       TEXT("CompanyName")
#define S_VER_PRODUCTVERSION    TEXT("ProductVersion")
#define S_VER_PRODUCTNAME       TEXT("ProductName")
#define S_VER_FILEDESCRIPTION   TEXT("FileDescription")
#define S_VER_FILEVERSION       TEXT("FileVersion")
#define S_VER_ORIGINALFILENAME  TEXT("OriginalFileName")
#define S_VER_INTERNALNAME      TEXT("InternalName")
#define S_VER_LEGALCOPYRIGHT    TEXT("LegalCopyright")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\sdktools\inc\traceprt.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    traceprt.h

Abstract:

    Trace formatting external definitions.

Revision History:

--*/
#ifdef __cplusplus
extern "C"{
#endif
#ifndef _TRACEPRT_
#define _TRACEPRT_

#define MAXLOGFILES       16
#define MAXSTR          1024

#define GUID_FILE       _T("default")
#define GUID_EXT        _T("tmf")

//
// Now the routines we export
//

#ifndef TRACE_API
#ifdef TRACE_EXPORTS
#define TRACE_API __declspec(dllexport)
#else
#define TRACE_API __declspec(dllimport)
#endif
#endif

#ifdef UNICODE
#define FormatTraceEvent        FormatTraceEventW
#define GetTraceGuids           GetTraceGuidsW
#define SummaryTraceEventList   SummaryTraceEventListW
#else
#define FormatTraceEvent        FormatTraceEventA
#define GetTraceGuids           GetTraceGuidsA
#define SummaryTraceEventList   SummaryTraceEventListA
#endif

TRACE_API SIZE_T
WINAPI
FormatTraceEventA(
        PLIST_ENTRY  HeadEventList,
        PEVENT_TRACE pEvent,
        CHAR       * EventBuf,
        ULONG        SizeEventBuf,
        CHAR       * pszMask
        );

TRACE_API ULONG 
WINAPI
GetTraceGuidsA(
        CHAR        * GuidFile, 
        PLIST_ENTRY * EventListHeader
        );

TRACE_API void
WINAPI
SummaryTraceEventListA(
        CHAR      * SummaryBlock ,
        ULONG       SizeSummaryBlock ,
        PLIST_ENTRY EventListhead
        );

TRACE_API SIZE_T
WINAPI
FormatTraceEventW(
        PLIST_ENTRY    HeadEventList,
        PEVENT_TRACE   pEvent,
        TCHAR        * EventBuf,
        ULONG          SizeEventBuf,
        TCHAR        * pszMask
        );

TRACE_API ULONG 
WINAPI
GetTraceGuidsW(
        LPTSTR        GuidFile, 
        PLIST_ENTRY * EventListHeader
        );

TRACE_API void
WINAPI
SummaryTraceEventListW(
        TCHAR     * SummaryBlock,
        ULONG       SizeSummaryBlock,
        PLIST_ENTRY EventListhead
        );

TRACE_API void
WINAPI
CleanupTraceEventList(
        PLIST_ENTRY EventListHead
        );

TRACE_API void
WINAPI
GetTraceElapseTime(
        __int64 * pElpaseTime
        );

typedef enum _PARAM_TYPE
{
    ParameterINDENT,
    ParameterSEQUENCE,
    ParameterGMT,
    ParameterTraceFormatSearchPath
} PARAMETER_TYPE ;


TRACE_API ULONG
WINAPI
SetTraceFormatParameter(
        PARAMETER_TYPE  Parameter ,
        PVOID           ParameterValue 
        );

TRACE_API ULONG
WINAPI
GetTraceFormatParameter(
        PARAMETER_TYPE  Parameter ,
        PVOID           ParameterValue 
        );

#endif  // #ifndef _TRACEPRT_

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\cplp.h ===
/*****************************************************************************\
*                                                                             *
* cplp.h -      Private Control panel extension DLL definitions               *
*                                                                             *
*               Version 3.10                                                  *
*                                                                             *
*               Copyright (c) Microsoft Corporation.  All rights reserved.    *
*                                                                             *
******************************************************************************/
#ifndef _INC_CPLP
#define _INC_CPLP
#include <pshpack1.h>   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */
/*  if lParam1 == CPL_INIT_DEVMODE_TAG for the display applet then */
/*  a Devmode structure is sent to lParam2 */
#define CPL_INIT_DEVMODE_TAG 0x4D564544      // represents "DEVM"

#define CPL_DO_PRINTER_SETUP    100
#define CPL_DO_NETPRN_SETUP     101
#define CPL_POLICYREFRESH       102
#ifdef __cplusplus
}
#endif    /* __cplusplus */

#include <poppack.h>
#endif /* _INC_CPLP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\commdlgp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    commdlgp.h

Abstract:

    Private
    Procedure declarations, constant definitions and macros for the Common
    Dialogs.

--*/
#ifndef _COMMDLGP_
#define _COMMDLGP_
#if !defined(_WIN64)
#include <pshpack1.h>         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */
// reserved for CD_WX86APP           0x04000000
// reserved for CD_WOWAPP            0x08000000
// reserved                          0xx0000000
// reserved                      0x?0000000
// 0x?0000000 is reserved for internal use
//  reserved for internal use      0x?0000000L
// reserved for CD_WX86APP             0x04000000
// reserved for CD_WOWAPP              0x08000000
#define PD_PAGESETUP                   0x40000000
////  reserved                         0x?0000000
#ifdef __cplusplus
}
#endif  /* __cplusplus */

#if !defined(_WIN64)
#include <poppack.h>
#endif
#endif  /* _COMMDLGP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\cmnquryp.h ===
#ifndef __cmnquryp_h
#define __cmnquryp_h

DEFINE_GUID(IID_IQueryFrame, 0x7e8c7c20, 0x7c9d, 0x11d0, 0x91, 0x3f, 0x0, 0xaa, 0x00, 0xc1, 0x6e, 0x65);
DEFINE_GUID(IID_IQueryHandler,  0xa60cc73f, 0xe0fc, 0x11d0, 0x97, 0x50, 0x0, 0xa0, 0xc9, 0x06, 0xaf, 0x45);

#ifndef GUID_DEFS_ONLY
#define CQFF_ISNEVERLISTED  0x0000004       // = 1 => form not listed in the form selector
#define CQPF_ISGLOBAL               0x00000001  // = 1 => this page is global, and added to all forms
#define OQWF_HIDESEARCHPANE         0x00000100 // = 1 => hide the search pane by on opening

//-----------------------------------------------------------------------------
// Query handler interfaces structures etc
//-----------------------------------------------------------------------------

//
// Query Scopes
// ============
//  A query scope is an opaque structure passed between the query handler
//  and the query frame.  When the handler is first invoked it is asked
//  to declare its scope objects, which inturn the frame holds.  When the
//  query is issued the scope is passed back to the handler.
//
//  When a scope is registered the cbSize field of the structure passed
//  is used to define how large the scope is, that entire blob is then
//  copied into a heap allocation.  Therefore allowing the handler
//  to create scope blocks on the stack, knowing that the frame will
//  take a copy when it calls the AddProc.
//

struct _cqscope;
typedef struct _cqscope CQSCOPE;
typedef CQSCOPE*        LPCQSCOPE;

typedef HRESULT (CALLBACK *LPCQSCOPEPROC)(LPCQSCOPE pScope, UINT uMsg, LPVOID pVoid);

struct _cqscope
{
    DWORD         cbStruct;
    DWORD         dwFlags;
    LPCQSCOPEPROC pScopeProc;
    LPARAM        lParam;
};

#define CQSM_INITIALIZE         0x0000000
#define CQSM_RELEASE            0x0000001
#define CQSM_GETDISPLAYINFO     0x0000003   // pVoid -> CQSCOPEDISPLAYINFO
#define CQSM_SCOPEEQUAL         0x0000004   // pVoid -> CQSCOPE

typedef struct
{
    DWORD  cbStruct;
    DWORD  dwFlags;
    LPWSTR pDisplayName;
    INT    cchDisplayName;
    LPWSTR pIconLocation;
    INT    cchIconLocation;
    INT    iIconResID;
    INT    iIndent;
} CQSCOPEDISPLAYINFO, * LPCQSCOPEDISPLAYINFO;


//
// Command ID's reserved for the frame to use when talking to
// the handler.  The handler must use only the IDs in the
// range defined by CQID_MINHANDLERMENUID and CQID_MAXHANDLERMENUID
//

#define CQID_MINHANDLERMENUID   0x0100
#define CQID_MAXHANDLERMENUID   0x4000                              // all handler IDs must be below this threshold

#define CQID_FILE_CLOSE         (CQID_MAXHANDLERMENUID + 0x0100)
#define CQID_VIEW_SEARCHPANE    (CQID_MAXHANDLERMENUID + 0x0101)

#define CQID_LOOKFORLABEL       (CQID_MAXHANDLERMENUID + 0x0200)
#define CQID_LOOKFOR            (CQID_MAXHANDLERMENUID + 0x0201)

#define CQID_LOOKINLABEL        (CQID_MAXHANDLERMENUID + 0x0202)
#define CQID_LOOKIN             (CQID_MAXHANDLERMENUID + 0x0203)
#define CQID_BROWSE             (CQID_MAXHANDLERMENUID + 0x0204)

#define CQID_FINDNOW            (CQID_MAXHANDLERMENUID + 0x0205)
#define CQID_STOP               (CQID_MAXHANDLERMENUID + 0x0206)
#define CQID_CLEARALL           (CQID_MAXHANDLERMENUID + 0x0207)

//
// When calling IQueryHandler::ActivateView the following reason codes
// are passed to indicate the type of activation being performed
//

#define CQRVA_ACTIVATE         0x00 // wParam = 0, lParam = 0
#define CQRVA_DEACTIVATE       0x01 // wParam = 0, lParam = 0
#define CQRVA_INITMENUBAR      0x02 // wParam/lParam => WM_INITMENU
#define CQRVA_INITMENUBARPOPUP 0x03 // wParam/lParam => WM_INITMENUPOPUP
#define CQRVA_FORMCHANGED      0x04 // wParam = title length, lParam -> title string
#define CQRVA_STARTQUERY       0x05 // wParam = fStarted, lParam = 0
#define CQRVA_HELP             0x06 // wParma = 0, lParam = LPHELPINFO
#define CQRVA_CONTEXTMENU      0x07 // wParam/lParam from the WM_CONTEXTMENU call on the frame

//
// The frame creates the view and then queries the handler for display
// information (title, icon, animation etc).  These are all loaded as
// resources from the hInstance specified, if 0 is specified for any
// of the resource ID's then defaults are used.
//

typedef struct
{
    DWORD       dwFlags;                    // display attributes
    HINSTANCE   hInstance;                  // resource hInstance
    INT         idLargeIcon;                // resource ID's for icons
    INT         idSmallIcon;
    INT         idTitle;                    // resource ID for title string
    INT         idAnimation;                // resource ID for animation
} CQVIEWINFO, * LPCQVIEWINFO;

//
// IQueryHandler::GetViewObject is passed a scope indiciator to allow it
// to trim the result set.  All handlers must support CQRVS_SELECTION. Also,
// CQRVS_HANDLERMASK defines the flags available for the handler to
// use internally.
//

#define CQRVS_ALL           0x00000001
#define CQRVS_SELECTION     0x00000002
#define CQRVS_MASK          0x00ffffff
#define CQRVS_HANDLERMASK   0xff000000

//
// When invoking the query all the parameters, the scope, the form
// etc are bundled into this structure and then passed to the
// IQueryHandler::IssueQuery method, it inturn populates the view
// previously created with IQueryHandler::CreateResultView.
//

typedef struct
{
    DWORD       cbStruct;
    DWORD       dwFlags;
    LPCQSCOPE   pQueryScope;                // handler specific scope
    LPVOID      pQueryParameters;           // handle specific argument block
    CLSID       clsidForm;                  // form ID
} CQPARAMS, * LPCQPARAMS;

//
// Query Frame Window Messages
// ===========================
//
//  CQFWM_ADDSCOPE
//  --------------
//      wParam = LPCQSCOPE, lParam = HIWORD(index), LOWORD(fSelect)
//
//  Add a scope to the scope list of the dialog, allows async scope collection
//  to be performed.  When the handlers AddScopes method is called then
//  handler can return S_OK, spin off a thread and post CQFWM_ADDSCOPE
//  messages to the frame, which will inturn allow the scopes to be
//  added to the control.  When the frame receives this message it copies
//  the scope as it does on IQueryFrame::AddScope, if the call fails it
//  returns FALSE.
//
#define CQFWM_ADDSCOPE (WM_USER+256)

//
//  CQFWM_GETFRAME
//  --------------
//      wParam = 0, lParam = (IQueryFrame**)
//
//  Allows an object to query for the frame window's IQueryFrame
//  interface, this is used by the property well to talk to the
//  other forms within the system.
//
#define CQFWM_GETFRAME (WM_USER+257)

//
//  CQFWM_ALLSCOPESADDED
//  --------------------
//      wParam = 0, lParam = 0
//
//  If a handler is adding scopes async, then it should issue this message
//  when all the scopes have been added.  That way if the caller specifies
//  OQWF_ISSUEONOPEN we can start the query once all the scopes have been
//  added.
//
#define CQFWM_ALLSCOPESADDED (WM_USER+258)

//
//  CQFWM_STARTQUERY
//  ----------------
//      wParam = 0, lParam = 0
//
//  This call can be made by the frame or the form, it allows it to
//  start the query running in those cases where a form really needs
//  this functionality.
//
//  NB: this should be kept private!
//
#define CQFWM_STARTQUERY (WM_USER+259)

//
//  CQFWM_SETDEFAULTFOCUS
//  ---------------------
//      Posted to ourselves to ensure focus is on the right control.
//
#define CQFWM_SETDEFAULTFOCUS (WM_USER+260)


//
// IQueryFrame
//

#undef  INTERFACE
#define INTERFACE   IQueryFrame

DECLARE_INTERFACE_(IQueryFrame, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IQueryFrame methods ***
    STDMETHOD(AddScope)(THIS_ LPCQSCOPE pScope, INT i, BOOL fSelect) PURE;
    STDMETHOD(GetWindow)(THIS_ HWND* phWnd) PURE;
    STDMETHOD(InsertMenus)(THIS_ HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidth) PURE;
    STDMETHOD(RemoveMenus)(THIS_ HMENU hmenuShared) PURE;
    STDMETHOD(SetMenu)(THIS_ HMENU hmenuShared, HOLEMENU holereservedMenu) PURE;
    STDMETHOD(SetStatusText)(THIS_ LPCTSTR pszStatusText) PURE;
    STDMETHOD(StartQuery)(THIS_ BOOL fStarting) PURE;
    STDMETHOD(LoadQuery)(THIS_ IPersistQuery* pPersistQuery) PURE;
    STDMETHOD(SaveQuery)(THIS_ IPersistQuery* pPersistQuery) PURE;
    STDMETHOD(CallForm)(THIS_ LPCLSID pForm, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD(GetScope)(THIS_ LPCQSCOPE* ppScope) PURE;
    STDMETHOD(GetHandler)(THIS_ REFIID riid, void **ppv) PURE;
};

//
// IQueryHandler interface
//

#undef  INTERFACE
#define INTERFACE IQueryHandler

DECLARE_INTERFACE_(IQueryHandler, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IQueryHandler methods ***
    STDMETHOD(Initialize)(THIS_ IQueryFrame* pQueryFrame, DWORD dwOQWFlags, LPVOID pParameters) PURE;
    STDMETHOD(GetViewInfo)(THIS_ LPCQVIEWINFO pViewInfo) PURE;
    STDMETHOD(AddScopes)(THIS) PURE;
    STDMETHOD(BrowseForScope)(THIS_ HWND hwndParent, LPCQSCOPE pCurrentScope, LPCQSCOPE* ppScope) PURE;
    STDMETHOD(CreateResultView)(THIS_ HWND hwndParent, HWND* phWndView) PURE;
    STDMETHOD(ActivateView)(THIS_ UINT uState, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD(InvokeCommand)(THIS_ HWND hwndParent, UINT idCmd) PURE;
    STDMETHOD(GetCommandString)(THIS_ UINT idCmd, DWORD dwFlags, LPTSTR pBuffer, INT cchBuffer) PURE;
    STDMETHOD(IssueQuery)(THIS_ LPCQPARAMS pQueryParams) PURE;
    STDMETHOD(StopQuery)(THIS) PURE;
    STDMETHOD(GetViewObject)(THIS_ UINT uScope, REFIID riid, LPVOID* ppvOut) PURE;
    STDMETHOD(LoadQuery)(THIS_ IPersistQuery* pPersistQuery) PURE;
    STDMETHOD(SaveQuery)(THIS_ IPersistQuery* pPersistQuery, LPCQSCOPE pScope) PURE;
};
#endif  // GUID_DEFS_ONLY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\cleanoc.h ===
#ifndef __CLEANOC_API__
#define __CLEANOC_API__

// Flags used in GetControlInfo()
#define GCI_NAME         1
#define GCI_FILE         2
#define GCI_CLSID        3
#define GCI_TYPELIBID    4
#define GCI_TOTALSIZE    5
#define GCI_SIZESAVED    6
#define GCI_TOTALFILES   7
#define GCI_CODEBASE     8
#define GCI_ISDISTUNIT   9
#define GCI_DIST_UNIT_VERSION 10
#define GCI_STATUS       11
#define GCI_HAS_ACTIVEX  12
#define GCI_HAS_JAVA     13

// control status flags
#define STATUS_CTRL_UNKNOWN             0   // Errors prevent determining the actual control state
#define STATUS_CTRL_INSTALLED           1   // Control is properly installed and ready for use
#define STATUS_CTRL_SHARED              2   // One or more components are shared by more than one control
#define STATUS_CTRL_DAMAGED             3   // The control file or some part of the installation is damaged or missing
#define STATUS_CTRL_UNPLUGGED           4   // The control has been re-registered in another location, the cache's
                                            // instance of the control is no longer being used.

// RemoveExpiredControls flags
#define REC_SILENT     1    // If set, controls whose deletion would require confirmation are not removed.

///////////////////////////////////////////////////////////////////////////////
// FindFirstControl
//
// Purpose:
//     Initiate a search on the registry for an installed ActiveX control.
//
// Return Value:
//     - ERROR_SUCCESS if a control is found and search has been successfully
//       initiated.
//     - ERROR_NO_MORE_ITEMS if no control is found.
//     - If an error has occurred, the return value is a error code defined in
//       winerror.h
//
// Parameters:
//     hFindHandle    -- a handle needed for resuming the search.  Caller must
//                       pass this handle to FindNextControl to retrieve the
//                       the next installed ActiveX control.
//     hControlHandle -- handle to a control's data.  Caller must pass this
//                       handle into GetControlInfo to retrieve information
//                       about the control.  Call ReleaseControlHandle on the
//                       handle when done.  
//     lpCachePath    -- points to a string buffer that has the path where
//                       all controls to be retrieved are located.  If it
//                       is NULL, the internet cache path will be read
//                       from the registry.  If a path is to be supplied,
//                       the path must be a full pathname without any ~'s
//                       in order for the enumeration to work correctly.
//
#define axcFINDFIRSTCONTROL "FindFirstControl"

LONG WINAPI FindFirstControl(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle, 
                     LPCTSTR lpszCachePath = NULL
                     );

typedef LONG (WINAPI *FINDFIRSTCONTROL)(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle, 
                     LPCTSTR lpszCachePath = NULL
                     );


///////////////////////////////////////////////////////////////////////////////
// FindNextControl
//
// Purpose:
//     Resume a previously started search for installed ActiveX controls. The
//     search must have been initiated by a call to FirstFirstControl.
//
// Return Value:
//     - ERROR_SUCCESS if a control is found and search has been successfully
//       initiated.
//     - ERROR_NO_MORE_ITEMS if no control is found.
//     - If an error has occurred, the return value is a error code defined in
//       winerror.h.  In this situation, the caller can choose to continue
//       the search with another call to FindNextControl, or simply abort.
//
// Parameters:
//     hFindHandle    -- a handle received from a call to FindFirstControl.
//                       Pass this handle to subsequent calls to
//                       FindNextControl to retrieve controls one at a time.
//     hControlHandle -- handle to a control's data.  Caller must pass this
//                       handle into GetControlInfo to retrieve information
//                       about the control.  Call ReleaseControlHandle on the
//                       handle when done.  
//
#define axcFINDNEXTCONTROL "FindNextControl"

LONG WINAPI FindNextControl(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle
                     );

typedef LONG (WINAPI *FINDNEXTCONTROL)(
                     HANDLE& hFindHandle,
                     HANDLE& hControlHandle
                     );

///////////////////////////////////////////////////////////////////////////////
// FindControlClose
//
// Purpose:
//     Called when search is over.  Missing a call to this function after a
//     search might contribute memory leak.  This function can be called
//     regardless of what FindFirstControl and/or FindNextControl return.
//
// Return Value:
//     None.
//
// Parameters:
//     hFindHandle -- a handle obtained from calls to FindFirstControl and
//                    FindNextControl in the current search.
//
#define axcFINDCONTROLCLOSE "FindControlClose"

void WINAPI FindControlClose(
                     HANDLE hFindHandle
                     );

typedef void (WINAPI *FINDCONTROLCLOSE)(
                     HANDLE hFindHandle
                     );


///////////////////////////////////////////////////////////////////////////////
// ReleaseControlHandle
//
// Purpose:
//     When a handle of a control is retrieved via FindFirstControl or
//     FindNextControl, the caller is responsible to release that handle
//     by call this function.
//
// Return Value:
//     None.
//
// Parameters:
//     hControlHandle -- a handle to a control obtained from FindFirstControl
//                       or FindNextControl.
//
#define axcRELEASECONTROLHANDLE "ReleaseControlHandle"

void WINAPI ReleaseControlHandle(
                          HANDLE hControlHandle
                          );

typedef void (WINAPI *RELEASECONTROLHANDLE)(
                          HANDLE hControlHandle
                          );


///////////////////////////////////////////////////////////////////////////////
// GetControlInfo
//
// Purpose:
//     Once a handle to a control is obtained via FindFirstControl or
//     FindNextControl, the caller may retrieve information about the control
//     by call this function with a flag (nFlag) indicating what info to
//     retrieve.  The supported flags are:
//     GCI_NAME       -- friendly name of control
//     GCI_FILE       -- main full path & file name of control
//     GCI_CLSID      -- clsid of control, in a NULL-terminated string
//     GCI_TYPELIBID  -- typelib guid of control, in a NULL-terminated string
//     GCI_TOTALSIZE  -- total size in bytes of all control's dependent files
//     GCI_SIZESAVED  -- total size in bytes restored if control is removed
//                       It can be different from GCI_TOTALSIZE since some
//                       of the control's dependent files might be shared dlls
//     GCI_TOTALFILES -- total number of control dependent files, including
//                       shared dlls if there are any
//     GCI_STATUS     -- the controls status value from STATUS_CTRL_* <above>
//     GCI_HAS_ACTIVEX -- non-zero if control includes ActiveX contols(s)
//     GCI_HAS_JAVA   -- non-zero if control includes Java packages
//
// Return Value:
//     TRUE if succeeded, FALSE otherwise.
//
// Parameters:
//     hControlHandle -- handle to a control for which information is to be
//                       retrieved.
//     nFlag          -- indicate which information to retrieve. Please refer
//                       to Purpose section above for a list of supported 
//                       flags.  nFlag can only equal to one of them so do
//                       not pass in multiple flags OR'ed together.
//     lpdwData       -- address of a buffer for storing a numerical value.
//                       (ie. GCI_TOTALSIZE, GCI_SIZESAVED & GCI_TOTALFILES)
//                       This parameter is ignored for other flags.
//     lpszData       -- address of a buffer for storing a NULL-terminated
//                       string value (ie. GCI_NAME, GCI_FILE, GCI_CLSID &
//                       GCI_TYPELIBID)  This paramter is ignored if other
//                       flags are specified.
//     nBufLen        -- length of string buffer pointed to by lpszData.
//                       This parameter is ignored if a numerical value is
//                       being retrieved.
//
#define axcGETCONTROLINFO "GetControlInfo"

BOOL WINAPI GetControlInfo(
                      HANDLE hControlHandle, 
                      UINT nFlag,
                      LPDWORD lpdwData,
                      LPTSTR lpszBuf,
                      int nBufLen
                      );

typedef BOOL (WINAPI *GETCONTROLINFO)(
                      HANDLE hControlHandle, 
                      UINT nFlag,
                      LPDWORD lpdwData,
                      LPTSTR lpszBuf,
                      int nBufLen
                      );


///////////////////////////////////////////////////////////////////////////////
// GetControlDependentFile
//
// Purpose:
//     A given control might depend on other files.  For instance, FOO.OCX
//     might need FOO.INF and MFCXX.DLL in order to work.  This function
//     retrieves one file at a time from a list of files depended upon by a
//     given ActiveX control.  The list of files is NOT sorted.
//
// Return Value:
//     - ERROR_SUCCESS if a file is found at position iFile in the list.
//     - ERROR_NO_MORE_FILES if no file is found at position iFile in the list.
//     - If an error has occurred, the return value is a error code defined in
//       winerror.h.
//     
// Parameters:
//     iFile          -- a zero-based index indicating which file in the list
//                       to retrieve.
//     hControlHandle -- handle to a control obtained via FindFirstControl
//                       or FindNextControl.
//     lpszFile       -- points to a buffer used to store the retrieved name.
//     lpszSize       -- points to a DWORD variable that is to store the size
//                       in bytes of the file retrieved.  If it is 0, the file
//                       does not exist.
//     bToUpper       -- TRUE if the filename returned is to be converted to
//                       uppercase.  No conversion takes place if FALSE
//          
#define axcGETCONTROLDEPENDENTFILE "GetControlDependentFile"
         
LONG WINAPI GetControlDependentFile(
             int iFile,
             HANDLE hControlHandle,
             LPTSTR lpszFile,
             LPDWORD lpdwSize,
             BOOL bToUpper = FALSE
             );

typedef LONG (WINAPI *GETCONTROLDEPENDENTFILE)(
             int iFile,
             HANDLE hControlHandle,
             LPTSTR lpszFile,
             LPDWORD lpdwSize,
             BOOL bToUpper = FALSE
             );


///////////////////////////////////////////////////////////////////////////////
// IsModuleRemovable
//
// Purpose:
//     Checks whether a file can be removed by looking into the registry.
//     This function is called "IsModuleRemovable" instead of
//     "IsFileRemovable" because this routine does not check the actual file
//     for its status.  For instance, a file can be deemed removable even if
//     is being exclusively opened by someone.  This routine only tells from
//     the registry's point of view if a file can be safely removed or not.
//
// Return Value:
//     - FALSE if there is any indication that the given file is being shared
//       by other applications.
//     - TRUE otherwise.
//
// Parameter: 
//     lpszFile -- points to a buffer that has the name (with full path) of
//                 the file whose removal status is to be verified.
//
#define axcISMODULEREMOVABLE "IsModuleRemovable"

BOOL WINAPI IsModuleRemovable(
             LPCTSTR lpszFile
             );

typedef BOOL (WINAPI *ISMODULEREMOVABLE)(
             LPCTSTR lpszFile
             );


///////////////////////////////////////////////////////////////////////////////
// RemoveControlByHandle
//
// Purpose:
//     Remove a control from registry as well as all the files that the control
//     depends on.  
//
// Return Value:
//     - S_OK if control has been successfully uninstalled.
//     - S_FALSE if minor error has occurred, but not serious enough to
//       abort the uninstallation.  Control has been uninstalled when the
//       call returns.
//     - An error code defined in winerror.h if an serious error has occurred
//       and uninstallation has been aborted.  The state of the control
//       is not gaurenteed.
//
// Parameters:
//     lpControlData -- points to an instance of CONTROL_DATA representing the
//                      control to be removed.  The struct must have been
//                      initialized by a call to FindFirstControl or
//                      FindNextControl.  Be sure to call ReleaseControlData
//                      on this struct after successful removal, for the data
//                      in this struct is no longer useful.
//     bForceRemove  -- If this flag is FALSE, the removal routine will check
//                      if the control is safe for removal before removing it.
//                      If the flag is TRUE, the control will be removed
//                      regardless of its removal status (except for Shared
//                      Violation).  The flag only applies to the control file
//                      itself.  Other files upon which the control depends are
//                      removed only if they are deemed as safe for removal.
//
#define axcREMOVECONTROLBYHANDLE "RemoveControlByHandle"

HRESULT WINAPI RemoveControlByHandle(
             HANDLE hControlHandle,
             BOOL bForceRemove = FALSE
             );

typedef HRESULT (WINAPI *REMOVECONTROLBYHANDLE)(
             HANDLE hControlHandle,
             BOOL bForceRemove = FALSE
             );


///////////////////////////////////////////////////////////////////////////////
// RemoveControlByName
//
// Purpose:
//     Remove a control from registry as well as all the files that the control
//     depends on.  It is an overloaded version.
//
// Return Value:
//     - S_OK if control has been successfully uninstalled.
//     - S_FALSE if minor error has occurred, but not serious enough to
//       abort the uninstallation.  Control has been uninstalled when the
//       call returns.
//     - An error code defined in winerror.h if an serious error has occurred
//       and uninstallation has been aborted.  The state of the control
//       is not gaurenteed.
//
// Parameters:
//     lpszFile      -- Address of a null-terminated string which is the main
//                      file for the control (ie "FOO.OCX" for FOO control).
//     lpszCLSID     -- Address of a null-terminated string which is the CLSID
//                      of the control.
//     lpszTypeLibID -- Address of a null-terminated string which is the TypeLib
//                      clsid of the control.
//     bForceRemove  -- If this flag is FALSE, the removal routine will check
//                      if the control is safe for removal before removing it.
//                      If the flag is TRUE, the control will be removed
//                      regardless of its removal status (except for Shared
//                      Violation).  The flag only applies to the control file
//                      itself.  Other files upon which the control depends are
//                      removed only if they are deemed as safe for removal.
//     dwIsDistUnit  -- boolean value to tell if this is really a dist unit
//
#define axcREMOVECONTROLBYNAME "RemoveControlByName"

HRESULT WINAPI RemoveControlByName(
             LPCTSTR lpszFile,
             LPCTSTR lpszCLSID,
             LPCTSTR lpszTypeLibID,
             BOOL bForceRemove = FALSE,
             DWORD dwIsDistUnit = FALSE
             );

typedef HRESULT (WINAPI *REMOVECONTROLBYNAME)(
             LPCTSTR lpszFile,
             LPCTSTR lpszCLSID,
             LPCTSTR lpszTypeLibID,
             BOOL bForceRemove = FALSE,
             DWORD dwIsDistUnit = FALSE
             );


///////////////////////////////////////////////////////////////////////////////
// type PFNDOBEFOREREMOVAL, used for function SweepControlsByLastAccessDate
//
// Purpose:
//     Define callback function to be called right before removing a control
//
// Return Values:
//     If a success code (S_XXX) is returned, the control will be removed.
//     If a fail code (E_XXX) is returned, the control will be skipped.
//
// Parameters:
//     HANDLE -- handle to the control to be removed.  One can get information
//               about the control using the GetControlInfo function.  Do NOT
//               call ReleaseControlHandle on the handle.
//     UINT   -- number of remaining controls including this one.
//
typedef HRESULT (CALLBACK *PFNDOBEFOREREMOVAL)(HANDLE, UINT);


///////////////////////////////////////////////////////////////////////////////
// type PFNDOAFTERREMOVAL, used for function SweepControlsByLastAccessDate
//
// Purpose:
//     Define callback function to be called right after removing a control
//
// Return Values:
//     If a success code (S_XXX) is returned, the removal operation proceeds.
//     If a fail code (E_XXX) is returned, the removal operation is aborted.
//
// Parameters:
//     HRESULT -- result of removing the control.  The handle to this control
//                was passed to the callback of type PFNDOBEFOREREMOVAL before
//                the control was removed.  The possible values for this
//                HRESULT parameter are:
//                - S_OK (succeeded)
//                - S_FALSE (control had been removed with possibly some very
//                  minor errors)
//                - E_ACCESSDENIED (control not safe for removal)
//                - STG_E_SHAREVIOLATION (control being used by others)
//                - Other errors returned by registry functions
//                It is up to the implementator of this function to decide
//                what to do given the result of removing the last control.
//     UINT    -- number of remaining controls, NOT including the one just
//                removed.
//
typedef HRESULT (CALLBACK *PFNDOAFTERREMOVAL)(HRESULT, UINT);


///////////////////////////////////////////////////////////////////////////////
// SweepControlsByLastAccessDate
//
// Purpose:
//     Remove all controls whose last access date is before and on a given
//     date.
//
// Return Value:
//     - S_OK if succeeded and at least one control was removed.
//     - S_FALSE if succeeded but no controls have been removed.
//     - E_XXX defined in winerror.h if an error has occurred.
//
// Parameters:
//     pLastAccessTime -- specify a last access date.  All controls accessed
//                        before and on this date are to be removed.  Note
//                        that all fields except wYear, wMonth and wDay are
//                        ignored.  If NULL, all control will be removed.
//     pfnDoBefore     -- callback function called just before a control is
//                        removed.  Please read the description for type
//                        PFNDOBEFOREREMOVAL for details.  If NULL, nothing
//                        is to be done prior to removing a control.
//     pfnDoAfter      -- callback function called right after a control is
//                        removed.  Please read the description for type
//                        PFNDOAFTERREMOVAL for details.  If NULL, nothing
//                        is to be done after a control is removed.
//     dwSizeLimit     -- controls will be removed only if the total size
//                        (in bytes) of all controls exceeds the size
//                        specified by this paramter.  This parameter is
//                        ignored if 0 is specified.
//
#define axcSWEEPCONTROLSBYLASTACCESSDATE "SweepControlsByLastAccessDate"

HRESULT WINAPI SweepControlsByLastAccessDate(
                              SYSTEMTIME *pLastAccessTime = NULL,
                              PFNDOBEFOREREMOVAL pfnDoBefore = NULL,
                              PFNDOAFTERREMOVAL pfnDoAfter = NULL,
                              DWORD dwSizeLimit = 0
                              );

typedef HRESULT (WINAPI *SWEEPCONTROLSBYLASTACCESSDATE)(
                              SYSTEMTIME *pLastAccessTime = NULL,
                              PFNDOBEFOREREMOVAL pfnDoBefore = NULL,
                              PFNDOAFTERREMOVAL pfnDoAfter = NULL,
                              DWORD dwSizeLimit = 0
                              );


///////////////////////////////////////////////////////////////////////////////
// RemoveExpiredControls
//
// Purpose:
//     Similar to IEmptyVolumeCache. Removes all controls with a last
//     access date in the distant past and all controls flagged for more
//     rapid auto-expire.
//
// Return Value:
//     - S_OK if succeeded and at least one control was removed.
//     - S_FALSE if succeeded but no controls have been removed.
//     - E_XXX defined in winerror.h if an error has occurred.
//
// Parameters:
//     dwFlags         -- Currently, only REC_SILENT is defined.
//     dwReserved      -- Must be 0.
//
#define axcREMOVEEXPIREDCONTROLS "RemoveExpiredControls"

HRESULT WINAPI RemoveExpiredControls(DWORD dwFlags, DWORD dwReserved);

typedef HRESULT (WINAPI *REMOVEEXPIREDCONTROLS)(DWORD dwFlags, DWORD dwReserved);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\dsqueryp.h ===
#ifndef __dsqueryp_h
#define __dsqueryp_h
#define IID_IDsQueryHandler CLSID_DsQuery
DEFINE_GUID(IID_IDsQueryColumnHandler, 0xc072999e, 0xfa49, 0x11d1, 0xa0, 0xaf, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);
#ifndef GUID_DEFS_ONLY
#define DSQPF_RETURNALLRESULTS       0x80000000 // = 1 => return all results on OK, not just selection
#define DSQPM_GCL_FORPROPERTYWELL   0x8000 // == 1 => for property well

//-----------------------------------------------------------------------------
// Internal form helper functions
//-----------------------------------------------------------------------------

// filter types

#define FILTER_FIRST                0x0100
#define FILTER_LAST                 0x0200

#define FILTER_CONTAINS             0x0100
#define FILTER_NOTCONTAINS          0x0101
#define FILTER_STARTSWITH           0x0102
#define FILTER_ENDSWITH             0x0103
#define FILTER_IS                   0x0104
#define FILTER_ISNOT                0x0105
#define FILTER_GREATEREQUAL         0x0106
#define FILTER_LESSEQUAL            0x0107
#define FILTER_DEFINED              0x0108
#define FILTER_UNDEFINED            0x0109
#define FILTER_ISTRUE               0x010A
#define FILTER_ISFALSE              0x010B

// structures

typedef struct
{
    INT    fmt;
    INT    cx;
    UINT   idsName;
    LONG   iPropertyIndex;
    LPWSTR pPropertyName;
} COLUMNINFO, * LPCOLUMNINFO;

typedef struct
{
    UINT   nIDDlgItem;
    LPWSTR pPropertyName;
    INT    iFilter;
} PAGECTRL, * LPPAGECTRL;

// form APIs - private

STDAPI ClassListAlloc(LPDSQUERYCLASSLIST* ppDsQueryClassList, LPWSTR* aClassNames, INT cClassNames);
STDAPI QueryParamsAlloc(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery, HINSTANCE hInstance, LONG iColumns, LPCOLUMNINFO aColumnInfo);
STDAPI QueryParamsAddQueryString(LPDSQUERYPARAMS* ppDsQueryParams, LPWSTR pQuery);
STDAPI GetFilterString(LPWSTR pFilter, UINT* pLen, INT iFilter, LPWSTR pProperty, LPWSTR pValue);
STDAPI GetQueryString(LPWSTR* ppQuery, LPWSTR pPrefixQuery, HWND hDlg, LPPAGECTRL aCtrls, INT iCtrls);
STDAPI GetPatternString(LPTSTR pFilter, UINT* pLen, INT iFilter, LPTSTR pValue);
STDAPI_(VOID) ResetPageControls(HWND hDlg, LPPAGECTRL aCtrl, INT iCtrls);
STDAPI_(VOID) EnablePageControls(HWND hDlg, LPPAGECTRL aCtrl, INT iCtrls, BOOL fEnable);
STDAPI PersistQuery(IPersistQuery* pPersistQuery, BOOL fRead, LPCTSTR pSection, HWND hDlg, LPPAGECTRL aCtrl, INT iCtrls);
STDAPI SetDlgItemFromProperty(IPropertyBag* ppb, LPCWSTR pszProperty, HWND hwnd, INT id, LPCWSTR pszDefault);


//---------------------------------------------------------------------------//
//
// IDsQueryColumnHandler
// =====================
//  This interface is used by the query result view to allow the form to replace
//  the contents of the form columns.
//
//  If the property name is property,{CLSID}, we CoCreateInstance the GUID
//  asking for the IDsQueryColumnHandler which we then call for each
//  string property we are going to place into the result view.
//
//  The handler only gets called when the results are being unpacked from
//  the server, subsequent filtering, sort etc of the view doesn't
//  invole this handler.
//
//  However perf should be considered when implementing this object.
//
//---------------------------------------------------------------------------//

#undef  INTERFACE
#define INTERFACE   IDsQueryColumnHandler

DECLARE_INTERFACE_(IDsQueryColumnHandler, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // **** IDsQueryColumnHandler ****
    STDMETHOD(Initialize)(THIS_ DWORD dwFlags, LPCWSTR pszServer, LPCWSTR pszUserName, LPCWSTR pszPassword) PURE;
    STDMETHOD(GetText)(THIS_ ADS_SEARCH_COLUMN* psc, LPWSTR pszBuffer, INT cchBuffer) PURE;
};

//---------------------------------------------------------------------------//


//---------------------------------------------------------------------------//
//
// IDsQuery
// ========
//
//---------------------------------------------------------------------------//

#undef  INTERFACE
#define INTERFACE   IDsQueryHandler

//
// flags passed to IDsQueryHandler::UpdateView
//

#define DSQRVF_REQUERY          0x00000000  
#define DSQRVF_ITEMSDELETED     0x00000001  // pdon -> array of items to remove from the view
#define DSQRVF_OPMASK           0x00000fff 

DECLARE_INTERFACE_(IDsQueryHandler, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // **** IDsQuery ****
    STDMETHOD(UpdateView)(THIS_ DWORD dwType, LPDSOBJECTNAMES pdon) PURE;
};

//---------------------------------------------------------------------------//


#endif  // GUID_DEFS_ONLY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\comctrlp.h ===
/*****************************************************************************\
*                                                                             *
* commctrl.h - - Interface for the Windows Common Controls                    *
*                                                                             *
* Version 1.2                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_COMCTRLP
#define _INC_COMCTRLP
#ifndef NOUSER

#ifdef __cplusplus
extern "C" {
#endif

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NOBTNLIST    A control which is a list of bitmap buttons.
//
//=============================================================================

#ifdef WINNT
#include <prshtp.h>
#endif
#if (_WIN32_IE >= 0x0501)
#define ICC_WINLOGON_REINIT    0x80000000
#endif
#if (_WIN32_WINNT >= 0x501)
#define ICC_ALL_CLASSES        0x0000FFFF
#define ICC_ALL_VALID          0x8000FFFF
#else
#define ICC_ALL_CLASSES        0x00003FFF
#define ICC_ALL_VALID          0x80003FFF
#endif
#define CCM_TRANSLATEACCELERATOR (CCM_FIRST + 0xa)  // lParam == lpMsg
WINCOMMCTRLAPI LRESULT WINAPI SendNotify(HWND hwndTo, HWND hwndFrom, int code, NMHDR *pnmhdr);
WINCOMMCTRLAPI LRESULT WINAPI SendNotifyEx(HWND hwndTo, HWND hwndFrom, int code, NMHDR *pnmhdr, BOOL bUnicode);
#define NM_STARTWAIT            (NM_FIRST-9)
#define NM_ENDWAIT              (NM_FIRST-10)
#define NM_BTNCLK               (NM_FIRST-11)
// Rundll reserved              (0U-500U) -  (0U-509U)

// Run file dialog reserved     (0U-510U) -  (0U-519U)

// Message Filter Proc codes - These are defined above MSGF_USER
/////                           0x00000001  // don't use because some apps return 1 for all notifies
#define CDRF_NOTIFYITEMERASE    0x00000080   //

#define CDRF_VALIDFLAGS         0xFFFF00F6   //

#define SSI_DEFAULT ((UINT)-1)


#define SSIF_SCROLLPROC    0x0001
#define SSIF_MAXSCROLLTIME 0x0002
#define SSIF_MINSCROLL     0x0004

typedef int (CALLBACK *PFNSMOOTHSCROLLPROC)(    HWND hWnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip ,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags);


typedef struct tagSSWInfo
{
    UINT cbSize;
    DWORD fMask;
    HWND hwnd;
    int dx;
    int dy;
    LPCRECT lprcSrc;
    LPCRECT lprcClip;
    HRGN hrgnUpdate;
    LPRECT lprcUpdate;
    UINT fuScroll;

    UINT uMaxScrollTime;
    UINT cxMinScroll;
    UINT cyMinScroll;

    PFNSMOOTHSCROLLPROC pfnScrollProc;  // we'll call this back instead
} SMOOTHSCROLLINFO, *PSMOOTHSCROLLINFO;

WINCOMMCTRLAPI INT  WINAPI SmoothScrollWindow(PSMOOTHSCROLLINFO pssi);

#define SSW_EX_NOTIMELIMIT      0x00010000
#define SSW_EX_IMMEDIATE        0x00020000
#define SSW_EX_IGNORESETTINGS   0x00040000  // ignore system settings to turn on/off smooth scroll
#define SSW_EX_UPDATEATEACHSTEP 0x00080000



// ================ READER MODE ================
struct tagReaderModeInfo;
typedef BOOL (CALLBACK *PFNREADERSCROLL)(struct tagReaderModeInfo*, int, int);
typedef BOOL (CALLBACK *PFNREADERTRANSLATEDISPATCH)(LPMSG);
typedef struct tagReaderModeInfo
{
    UINT cbSize;
    HWND hwnd;
    DWORD fFlags;
    LPRECT prc;
    PFNREADERSCROLL pfnScroll;
    PFNREADERTRANSLATEDISPATCH pfnTranslateDispatch;

    LPARAM lParam;
} READERMODEINFO, *PREADERMODEINFO;

#define RMF_ZEROCURSOR          0x00000001
#define RMF_VERTICALONLY        0x00000002
#define RMF_HORIZONTALONLY      0x00000004

#define RM_SCROLLUNIT 20

WINCOMMCTRLAPI void WINAPI DoReaderMode(PREADERMODEINFO prmi);

// Cursors and Bitmaps used by ReaderMode
#ifdef RC_INVOKED
#define IDC_HAND_INTERNAL       108
#define IDC_VERTICALONLY        109
#define IDC_HORIZONTALONLY      110
#define IDC_MOVE2D              111
#define IDC_NORTH               112
#define IDC_SOUTH               113
#define IDC_EAST                114
#define IDC_WEST                115
#define IDC_NORTHEAST           116
#define IDC_NORTHWEST           117
#define IDC_SOUTHEAST           118
#define IDC_SOUTHWEST           119

#define IDB_2DSCROLL    132
#define IDB_VSCROLL     133
#define IDB_HSCROLL     134
#else
#define IDC_HAND_INTERNAL       MAKEINTRESOURCE(108)
#define IDC_VERTICALONLY        MAKEINTRESOURCE(109)
#define IDC_HORIZONTALONLY      MAKEINTRESOURCE(110)
#define IDC_MOVE2D              MAKEINTRESOURCE(111)
#define IDC_NORTH               MAKEINTRESOURCE(112)
#define IDC_SOUTH               MAKEINTRESOURCE(113)
#define IDC_EAST                MAKEINTRESOURCE(114)
#define IDC_WEST                MAKEINTRESOURCE(115)
#define IDC_NORTHEAST           MAKEINTRESOURCE(116)
#define IDC_NORTHWEST           MAKEINTRESOURCE(117)
#define IDC_SOUTHEAST           MAKEINTRESOURCE(118)
#define IDC_SOUTHWEST           MAKEINTRESOURCE(119)

#define IDB_2DSCROLL    MAKEINTRESOURCE(132)
#define IDB_VSCROLL     MAKEINTRESOURCE(133)
#define IDB_HSCROLL     MAKEINTRESOURCE(134)
#endif
#define NUM_OVERLAY_IMAGES_0     4
#define NUM_OVERLAY_IMAGES      15
#define ILC_COLORMASK           0x000000FE
#define ILC_SHARED              0x00000100      // this is a shareable image list
#define ILC_LARGESMALL          0x00000200      // (not implenented) contains both large and small images
#define ILC_UNIQUE              0x00000400      // (not implenented) makes sure no dup. image exists in list
#define ILC_MOREOVERLAY         0x00001000      // contains more overlay in the structure
#if (_WIN32_WINNT >= 0x501)
#define ILC_VALID   (ILC_MASK | ILC_COLORMASK | ILC_SHARED | ILC_PALETTE | ILC_MIRROR | ILC_PERITEMMIRROR)   // legal implemented flags
#else
#define ILC_MIRROR              0x00002000      // Mirror the icons contained, if the process is mirrored;internal
#define ILC_VALID   (ILC_MASK | ILC_COLORMASK | ILC_SHARED | ILC_PALETTE | ILC_MIRROR)   // legal implemented flags
#endif	
#if (_WIN32_WINNT >= 0x501)
#define ILD_BLENDMASK           0x00000006
#else
#define ILD_BLENDMASK           0x0000000E
#endif
#define ILD_BLEND75             0x00000008   // not implemented
#define ILD_MIRROR              0x00000080
#define OVERLAYMASKTOINDEX(i)   ((((i) >> 8) & (ILD_OVERLAYMASK >> 8))-1)
#define OVERLAYMASKTO1BASEDINDEX(i)   (((i) >> 8) & (ILD_OVERLAYMASK >> 8))
WINCOMMCTRLAPI BOOL        WINAPI ImageList_GetIconSize(HIMAGELIST himl, int *cx, int *cy);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_GetImageRect(HIMAGELIST himl, int i, RECT *prcImage);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle);
#if (_WIN32_IE >= 0x0300)
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DrawIndirect(IMAGELISTDRAWPARAMS* pimldp);
#endif
WINCOMMCTRLAPI BOOL        WINAPI ImageList_Remove(HIMAGELIST himl, int i);
#define ILCF_VALID  (ILCF_SWAP)
#if (_WIN32_IE >= 0x0500)
WINCOMMCTRLAPI BOOL        WINAPI ImageList_SetFlags(HIMAGELIST himl, UINT flags);
#endif

typedef BOOL (CALLBACK *PFNIMLFILTER)(HIMAGELIST *, int *, LPARAM, BOOL);
WINCOMMCTRLAPI BOOL WINAPI ImageList_SetFilter(HIMAGELIST himl, PFNIMLFILTER pfnFilter, LPARAM lParamFilter);
WINCOMMCTRLAPI int ImageList_SetColorTable(HIMAGELIST piml, int start, int len, RGBQUAD *prgb);

WINCOMMCTRLAPI BOOL WINAPI MirrorIcon(HICON* phiconSmall, HICON* phiconLarge);
WINCOMMCTRLAPI UINT WINAPI ImageList_GetFlags(HIMAGELIST himl);
#if (_WIN32_WINNT >= 0x501)
WINCOMMCTRLAPI HRESULT WINAPI ImageList_CreateInstance(int cx, int cy, UINT flags, int cInitial, int cGrow, REFIID riid, void **ppv);
WINCOMMCTRLAPI HRESULT WINAPI HIMAGELIST_QueryInterface(HIMAGELIST himl, REFIID riid, void** ppv);
#define IImageListToHIMAGELIST(himl) reinterpret_cast<HIMAGELIST>(himl)
#endif
#define HDS_VERT                0x0001
#define HDS_SHAREDIMAGELISTS    0x0000
#define HDS_PRIVATEIMAGELISTS   0x0010

#define HDS_OWNERDATA           0x0020
#define HDFT_ISMASK         0x000f
#define HDI_ALL                 0x01ff
/* REVIEW: index, command, flag words, resource ids should be UINT */
/* REVIEW: is this internal? if not, call it TBCOLORMAP, prefix tbc */
#define CMB_DISCARDABLE         0x01
#define CMB_DIBSECTION          0x04

/*REVIEW: TBSTATE_* should be TBF_* (for Flags) */
#if (_WIN32_IE >= 0x0501)
#else
#define BTNS_SHOWTEXT   0x0040
#endif  // 0x0501
#if (_WIN32_IE >= 0x0501)
#elif (_WIN32_IE >= 0x0500)
#define TBSTYLE_EX_MIXEDBUTTONS             0x00000008
#define TBSTYLE_EX_HIDECLIPPEDBUTTONS       0x00000010
#endif  // 0x0501
#if (_WIN32_IE >= 0x0500)
#define TBSTYLE_EX_MULTICOLUMN              0x00000002 // conflicts w/ TBSTYLE_WRAPABLE
#define TBSTYLE_EX_VERTICAL                 0x00000004
#define TBSTYLE_EX_INVERTIBLEIMAGELIST      0x00000020  // Image list may contain inverted 
#define TBSTYLE_EX_FIXEDDROPDOWN            0x00000040 // Only used in the taskbar
#endif
#if (_WIN32_WINNT >= 0x501)
#define TBSTYLE_EX_TRANSPARENTDEADAREA      0x00000100
#define TBSTYLE_EX_TOOLTIPSEXCLUDETOOLBAR   0x00000200
#endif
/* Messages up to WM_USER+8 are reserved until we define more state bits */
/* Messages up to WM_USER+16 are reserved until we define more state bits */
#define IDB_STD_SMALL_MONO      2       /*  not supported yet */
#define IDB_STD_LARGE_MONO      3       /*  not supported yet */
#define IDB_VIEW_SMALL_MONO     6       /*  not supported yet */
#define IDB_VIEW_LARGE_MONO     7       /*  not supported yet */
#define STD_LAST                (STD_PRINT)     //
#define STD_MAX                 (STD_LAST + 1)  //
#define VIEW_LAST               (VIEW_VIEWMENU) //
#define VIEW_MAX                (VIEW_LAST + 1) //
#define HIST_LAST               (HIST_VIEWTREE) //
#define HIST_MAX                (HIST_LAST + 1) //
#define TB_SETBUTTONTYPE        (WM_USER + 34)
#ifdef _WIN32
#define TB_ADDBITMAP32          (WM_USER + 38)
#endif
#define TBBF_MONO               0x0002  /* not supported yet */
// since we don't have these for all the toolbar api's, we shouldn't expose any

#define ToolBar_ButtonCount(hwnd)  \
    (BOOL)SNDMSG((hwnd), TB_BUTTONCOUNT, 0, 0)

#define ToolBar_EnableButton(hwnd, idBtn, bSet)  \
    (BOOL)SNDMSG((hwnd), TB_ENABLEBUTTON, (WPARAM)(idBtn), (LPARAM)(bSet))

#define ToolBar_CheckButton(hwnd, idBtn, bSet)  \
    (BOOL)SNDMSG((hwnd), TB_CHECKBUTTON, (WPARAM)(idBtn), (LPARAM)(bSet))

#define ToolBar_PressButton(hwnd, idBtn, bSet)  \
    (BOOL)SNDMSG((hwnd), TB_PRESSBUTTON, (WPARAM)(idBtn), (LPARAM)(bSet))

#define ToolBar_HideButton(hwnd, idBtn, bSet)  \
    (BOOL)SNDMSG((hwnd), TB_HIDEBUTTON, (WPARAM)(idBtn), (LPARAM)(bSet))

#define ToolBar_MarkButton(hwnd, idBtn, bSet)  \
    (BOOL)SNDMSG((hwnd), TB_MARKBUTTON, (WPARAM)(idBtn), (LPARAM)(bSet))

#define ToolBar_CommandToIndex(hwnd, idBtn)  \
    (BOOL)SNDMSG((hwnd), TB_COMMANDTOINDEX, (WPARAM)(idBtn), 0)

#define ToolBar_SetState(hwnd, idBtn, dwState)  \
    (BOOL)SNDMSG((hwnd), TB_SETSTATE, (WPARAM)(idBtn), (LPARAM)(dwState))

#define ToolBar_GetState(hwnd, idBtn)  \
    (DWORD)SNDMSG((hwnd), TB_GETSTATE, (WPARAM)(idBtn), 0L)

#define ToolBar_GetRect(hwnd, idBtn, prect)  \
    (DWORD)SNDMSG((hwnd), TB_GETRECT, (WPARAM)(idBtn), (LPARAM)(prect))

#define ToolBar_SetButtonInfo(hwnd, idBtn, lptbbi)  \
    (BOOL)SNDMSG((hwnd), TB_SETBUTTONINFO, (WPARAM)(idBtn), (LPARAM)(lptbbi))

// returns -1 on failure, button index on success
#define ToolBar_GetButtonInfo(hwnd, idBtn, lptbbi)  \
    (int)(SNDMSG((hwnd), TB_GETBUTTONINFO, (WPARAM)(idBtn), (LPARAM)(lptbbi)))

#define ToolBar_GetButton(hwnd, iIndex, ptbb)  \
    (BOOL)SNDMSG((hwnd), TB_GETBUTTON, (WPARAM)(iIndex), (LPARAM)(ptbb))

#define ToolBar_SetStyle(hwnd, dwStyle)  \
    SNDMSG((hwnd), TB_SETSTYLE, 0, (LPARAM)(dwStyle))

#define ToolBar_GetStyle(hwnd)  \
    (DWORD)SNDMSG((hwnd), TB_GETSTYLE, 0, 0L)

#define ToolBar_GetHotItem(hwnd)  \
    (int)SNDMSG((hwnd), TB_GETHOTITEM, 0, 0L)

#define ToolBar_SetHotItem(hwnd, iPosHot)  \
    (int)SNDMSG((hwnd), TB_SETHOTITEM, (WPARAM)(iPosHot), 0L)

#define ToolBar_GetAnchorHighlight(hwnd)  \
    (BOOL)SNDMSG((hwnd), TB_GETANCHORHIGHLIGHT, 0, 0L)

#define ToolBar_SetAnchorHighlight(hwnd, bSet)  \
    SNDMSG((hwnd), TB_SETANCHORHIGHLIGHT, (WPARAM)(bSet), 0L)

#define ToolBar_MapAccelerator(hwnd, ch, pidBtn)  \
    (BOOL)SNDMSG((hwnd), TB_MAPACCELERATOR, (WPARAM)(ch), (LPARAM)(pidBtn))

#define ToolBar_GetInsertMark(hwnd, ptbim) \
    (void)SNDMSG((hwnd), TB_GETINSERTMARK, 0, (LPARAM)(ptbim))
#define ToolBar_SetInsertMark(hwnd, ptbim) \
    (void)SNDMSG((hwnd), TB_SETINSERTMARK, 0, (LPARAM)(ptbim))

#if (_WIN32_IE >= 0x0400)
#define ToolBar_GetInsertMarkColor(hwnd) \
    (COLORREF)SNDMSG((hwnd), TB_GETINSERTMARKCOLOR, 0, 0)
#define ToolBar_SetInsertMarkColor(hwnd, clr) \
    (COLORREF)SNDMSG((hwnd), TB_SETINSERTMARKCOLOR, 0, (LPARAM)(clr))

#define ToolBar_SetUnicodeFormat(hwnd, fUnicode)  \
    (BOOL)SNDMSG((hwnd), TB_SETUNICODEFORMAT, (WPARAM)(fUnicode), 0)

#define ToolBar_GetUnicodeFormat(hwnd)  \
    (BOOL)SNDMSG((hwnd), TB_GETUNICODEFORMAT, 0, 0)

#endif

// ToolBar_InsertMarkHitTest always fills in *ptbim with best hit information
//   returns TRUE if point is within the insert region (edge of buttons)
//   returns FALSE if point is outside the insert region (middle of button or background)
#define ToolBar_InsertMarkHitTest(hwnd, ppt, ptbim) \
    (BOOL)SNDMSG((hwnd), TB_INSERTMARKHITTEST, (WPARAM)(ppt), (LPARAM)(ptbim))

// ToolBar_MoveButton moves the button from position iOld to position iNew,
//   returns TRUE iff a button actually moved.
#define ToolBar_MoveButton(hwnd, iOld, iNew) \
    (BOOL)SNDMSG((hwnd), TB_MOVEBUTTON, (WPARAM)(iOld), (LPARAM)(iNew))

#define ToolBar_SetState(hwnd, idBtn, dwState)  \
    (BOOL)SNDMSG((hwnd), TB_SETSTATE, (WPARAM)(idBtn), (LPARAM)(dwState))

#define ToolBar_HitTest(hwnd, lppoint)  \
    (int)SNDMSG((hwnd), TB_HITTEST, 0, (LPARAM)(lppoint))

#define ToolBar_GetMaxSize(hwnd, lpsize) \
    (BOOL)SNDMSG((hwnd), TB_GETMAXSIZE, 0, (LPARAM) (lpsize))

#define ToolBar_GetPadding(hwnd) \
    (LONG)SNDMSG((hwnd), TB_GETPADDING, 0, 0)

#define ToolBar_SetPadding(hwnd, x, y) \
    (LONG)SNDMSG((hwnd), TB_SETPADDING, 0, MAKELONG(x, y))

#if (_WIN32_IE >= 0x0500)
#define ToolBar_SetExtendedStyle(hwnd, dw, dwMask)\
        (DWORD)SNDMSG((hwnd), TB_SETEXTENDEDSTYLE, dwMask, dw)

#define ToolBar_GetExtendedStyle(hwnd)\
        (DWORD)SNDMSG((hwnd), TB_GETEXTENDEDSTYLE, 0, 0)

#define ToolBar_SetBoundingSize(hwnd, lpSize)\
        (DWORD)SNDMSG((hwnd), TB_SETBOUNDINGSIZE, 0, (LPARAM)(lpSize))

#define ToolBar_SetHotItem2(hwnd, iPosHot, dwFlags)  \
    (int)SNDMSG((hwnd), TB_SETHOTITEM2, (WPARAM)(iPosHot), (LPARAM)(dwFlags))

#define ToolBar_HasAccelerator(hwnd, ch, piNum)  \
    (BOOL)SNDMSG((hwnd), TB_HASACCELERATOR, (WPARAM)(ch), (LPARAM)(piNum))

#define ToolBar_SetListGap(hwnd, iGap) \
    (BOOL)SNDMSG((hwnd), TB_SETLISTGAP, (WPARAM)(iGap), 0)
#define ToolBar_SetButtonHeight(hwnd, iMinHeight, iMaxHeight) \
    (BOOL)SNDMSG((hwnd), TB_SETBUTTONHEIGHT, 0, (LPARAM)(MAKELONG((iMinHeight),(iMaxHeight))))
#define ToolBar_SetButtonWidth(hwnd, iMinWidth, iMaxWidth) \
    (BOOL)SNDMSG((hwnd), TB_SETBUTTONWIDTH, 0, (LPARAM)(MAKELONG((iMinWidth),(iMaxWidth))))


#endif
#define TB_SETBOUNDINGSIZE      (WM_USER + 93)
#define TB_SETHOTITEM2          (WM_USER + 94)  // wParam == iHotItem,  lParam = dwFlags
#define TB_HASACCELERATOR       (WM_USER + 95)  // wParem == char, lParam = &iCount
#define TB_SETLISTGAP           (WM_USER + 96)
// empty space -- use me
#define TB_GETIMAGELISTCOUNT    (WM_USER + 98)
#define TB_GETIDEALSIZE         (WM_USER + 99)  // wParam == fHeight, lParam = psize
#define TB_SETDROPDOWNGAP       (WM_USER + 100)
// before using WM_USER + 103, recycle old space above (WM_USER + 97)
#define TB_TRANSLATEACCELERATOR     CCM_TRANSLATEACCELERATOR
#if (_WIN32_IE >= 0x0300)
#define TBN_CLOSEUP             (TBN_FIRST - 11)  //
#endif
#define TBN_WRAPHOTITEM         (TBN_FIRST - 24)
#define TBN_DUPACCELERATOR      (TBN_FIRST - 25)
#define TBN_WRAPACCELERATOR     (TBN_FIRST - 26)
#define TBN_DRAGOVER            (TBN_FIRST - 27)
#define TBN_MAPACCELERATOR      (TBN_FIRST - 28)
typedef struct tagNMTBDUPACCELERATOR
{
    NMHDR hdr;
    UINT ch;
    BOOL fDup;
} NMTBDUPACCELERATOR, *LPNMTBDUPACCELERATOR;

typedef struct tagNMTBWRAPACCELERATOR
{
    NMHDR hdr;
    UINT ch;
    int iButton;
} NMTBWRAPACCELERATOR, *LPNMTBWRAPACCELERATOR;

typedef struct tagNMTBWRAPHOTITEM
{
    NMHDR hdr;
    int iStart;
    int iDir;
    UINT nReason;       // HICF_* flags
} NMTBWRAPHOTITEM, *LPNMTBWRAPHOTITEM;
#ifndef _WIN32
// for compatibility with the old 16 bit WM_COMMAND hacks
typedef struct _ADJUSTINFO {
    TBBUTTON tbButton;
    char szDescription[1];
} ADJUSTINFO, NEAR* PADJUSTINFO, *LPADJUSTINFO;
#define TBN_BEGINDRAG           0x0201
#define TBN_ENDDRAG             0x0203
#define TBN_BEGINADJUST         0x0204
#define TBN_ADJUSTINFO          0x0205
#define TBN_ENDADJUST           0x0206
#define TBN_RESET               0x0207
#define TBN_QUERYINSERT         0x0208
#define TBN_QUERYDELETE         0x0209
#define TBN_TOOLBARCHANGE       0x020a
#define TBN_CUSTHELP            0x020b
#endif

#if (_WIN32_IE >= 0x0500)
typedef struct tagNMTBCUSTOMIZEDLG {
    NMHDR   hdr;
    HWND    hDlg;
} NMTBCUSTOMIZEDLG, *LPNMTBCUSTOMIZEDLG;
#endif


#define RBS_VALID       (RBS_AUTOSIZE | RBS_TOOLTIPS | RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_REGISTERDROP)
#if (_WIN32_IE >= 0x0400)               //
#if (_WIN32_IE >= 0x0500)               //
#if (_WIN32_IE >= 0x0501)               //
#endif // 0x0501                        //
#endif // 0x0500                        //
#define RBBS_FIXEDHEADERSIZE 0x40000000 //
#endif // 0x0400                        //
#define RBBS_DRAGBREAK      0x80000000  //
#define RB_GETBANDINFOOLD (WM_USER +  5)  //
#define RB_GETOBJECT    (WM_USER +  15) //
#define RB_PRIV_RESIZE   (WM_USER + 33)   //
#define RB_PRIV_DODELAYEDSTUFF (WM_USER+36)  // Private to delay doing toolbar stuff
// unused, reclaim      (WM_USER + 41)
// unused, reclaim      (WM_USER + 42)
// unused, reclaim          (RBN_FIRST - 9)
#define RBN_BANDHEIGHTCHANGE (RBN_FIRST - 20) // send when the rebar auto changes the height of a variableheight band
#if (_WIN32_IE >= 0x0400)                               //
//The following Style bit was 0x04. Now its set to zero
#define TTS_TOPMOST             0x00                    //
#endif                                                  //
// 0x04 used to be TTS_TOPMOST
// ie4 gold shell32 defview sets the flag (using SetWindowBits)
// so upgrade to ie5 will cause the new style to be used
// on tooltips in defview (not something we want)
#define TTF_STRIPACCELS         0x0008       // (this is implicit now)
#define TTF_UNICODE             0x0040       // Unicode Notify's
#define TTF_MEMALLOCED          0x0200
#if (_WIN32_IE >= 0x0400)
#define TTF_USEHITTEST          0x0400
#define TTF_RIGHT               0x0800       // right-aligned tooltips text (multi-line tooltips)
#endif
#if (_WIN32_IE >= 0x500)
#define TTF_EXCLUDETOOLAREA     0x4000
#endif
#if (_WIN32_IE >= 0x0500)
typedef struct tagNMTTSHOWINFO {
    NMHDR hdr;
    DWORD dwStyle;
} NMTTSHOWINFO, *LPNMTTSHOWINFO;
#endif
// SBS_* styles need to not overlap with CCS_* values

#define SB_SETBORDERS           (WM_USER+5)
// Warning +11-+13 are used in the unicode stuff above!
/*REVIEW: is this internal? */
/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOBTNLIST

/*REVIEW: should be BUTTONLIST_CLASS */
#define BUTTONLISTBOX           "ButtonListBox"

/* Button List Box Styles */
#define BLS_NUMBUTTONS          0x00FF
#define BLS_VERTICAL            0x0100
#define BLS_NOSCROLL            0x0200

/* Button List Box Messages */
#define BL_ADDBUTTON            (WM_USER+1)
#define BL_DELETEBUTTON         (WM_USER+2)
#define BL_GETCARETINDEX        (WM_USER+3)
#define BL_GETCOUNT             (WM_USER+4)
#define BL_GETCURSEL            (WM_USER+5)
#define BL_GETITEMDATA          (WM_USER+6)
#define BL_GETITEMRECT          (WM_USER+7)
#define BL_GETTEXT              (WM_USER+8)
#define BL_GETTEXTLEN           (WM_USER+9)
#define BL_GETTOPINDEX          (WM_USER+10)
#define BL_INSERTBUTTON         (WM_USER+11)
#define BL_RESETCONTENT         (WM_USER+12)
#define BL_SETCARETINDEX        (WM_USER+13)
#define BL_SETCURSEL            (WM_USER+14)
#define BL_SETITEMDATA          (WM_USER+15)
#define BL_SETTOPINDEX          (WM_USER+16)
#define BL_MSGMAX               (WM_USER+17)

/* Button listbox notification codes send in WM_COMMAND */
#define BLN_ERRSPACE            (-2)
#define BLN_SELCHANGE           1
#define BLN_CLICKED             2
#define BLN_SELCANCEL           3
#define BLN_SETFOCUS            4
#define BLN_KILLFOCUS           5

/* Message return values */
#define BL_OKAY                 0
#define BL_ERR                  (-1)
#define BL_ERRSPACE             (-2)

/* Create structure for                    */
/* BL_ADDBUTTON and                        */
/* BL_INSERTBUTTON                         */
/*   lpCLB = (LPCREATELISTBUTTON)lParam    */
typedef struct tagCREATELISTBUTTON {
    UINT        cbSize;     /* size of structure */
    DWORD_PTR    dwItemData; /* user defined item data */
                            /* for LB_GETITEMDATA and LB_SETITEMDATA */
    HBITMAP     hBitmap;    /* button bitmap */
    LPCSTR      lpszText;   /* button text */

} CREATELISTBUTTON, *LPCREATELISTBUTTON;

#endif /* NOBTNLIST */
//=============================================================================
/*REVIEW: these match the SB_ (scroll bar messages); define them that way? */

//
// Unnecessary to create a A and W version
// of this string since it is only passed
// to RegisterWindowMessage.
//
#if (_WIN32_IE >= 0x0501)
#define UDS_UNSIGNED            0x0200
#endif
#define PBS_SHOWPERCENT         0x01
#define PBS_SHOWPOS             0x02


// DOC'ed for DOJ compliance
#define CCS_NOHILITE            0x00000010L
#define LVS_PRIVATEIMAGELISTS   0x0000
#define LVS_ALIGNBOTTOM         0x0400
#define LVS_ALIGNRIGHT          0x0c00
#define LVIF_ALL                0x001f
#if (_WIN32_WINNT >= 0x501)
#define LVIF_VALID              0x0f1f
#else
#define LVIF_VALID              0x081f
#endif
#define LVIF_RESERVED           0xf000  // all bits in high nibble is for notify specific stuff
#define LVIS_LINK               0x0040
#define LVIS_USERMASK           LVIS_STATEIMAGEMASK
#define LVIS_ALL                0xFFFF
#define STATEIMAGEMASKTOINDEX(i) ((i & LVIS_STATEIMAGEMASK) >> 12)
    // all items above this line were for win95.  don't touch them.
    // all items above this line were for win95.  don't touch them.
#define I_IMAGENONE             (-2)
#define LVNI_PREVIOUS           0x0020
#define LVFI_SUBSTRING          0x0004
#define LVFI_NOCASE             0x0010
// the following #define's must be packed sequentially.
#define LVIR_MAX                4
#define LVHT_ONLEFTSIDEOFICON   0x0080 // on the left ~10% of the icon //
#define LVHT_ONRIGHTSIDEOFICON  0x0100 // on the right ~10% of the icon //
#define LVA_SORTASCENDING       0x0100
#define LVA_SORTDESCENDING      0x0200
    // all items above this line were for win95.  don't touch them.
    // all items above this line were for win95.  don't touch them.
#define LVCF_ALL                0x003f
#define LVCFMT_LEFT_TO_RIGHT    0x0010
#define LVCFMT_RIGHT_TO_LEFT    0x0020
#define LVCFMT_DIRECTION_MASK   (LVCFMT_LEFT_TO_RIGHT | LVCFMT_RIGHT_TO_LEFT)
#if (_WIN32_IE >= 0x0500)
#endif  // End (_WIN32_IE >= 0x0500)
#define LVM_GETHOTLIGHTCOLOR    (LVM_FIRST + 79)
#define ListView_GetHotlightColor(hwndLV)\
        (COLORREF)SNDMSG((hwndLV), LVM_GETHOTLIGHTCOLOR, 0, 0)

#define LVM_SETHOTLIGHTCOLOR    (LVM_FIRST + 80)
#define ListView_SetHotlightColor(hwndLV, clrHotlight)\
        (BOOL)SNDMSG((hwndLV), LVM_SETHOTLIGHTCOLOR, 0,  (LPARAM)(clrHotlight))
#if (_WIN32_WINNT >= 0x501)
#define LVGS_MASK           0x00000003
#define LVGA_ALIGN_MASK     0x0000002F
#define LVM_KEYBOARDSELECTED    (LVM_FIRST + 178)
#define ListView_KeyboardSelected(hwnd, i) \
    (BOOL)SNDMSG((hwnd), LVM_KEYBOARDSELECTED, (WPARAM)(i), 0)
#define LVM_ISITEMVISIBLE    (LVM_FIRST + 182)
#define ListView_IsItemVisible(hwnd, index) \
    (UINT)SNDMSG((hwnd), LVM_ISITEMVISIBLE, (WPARAM)index, (LPARAM)0)
#endif

#ifndef UNIX
#define  INTERFACE_PROLOGUE(a)
#define  INTERFACE_EPILOGUE(a)
#endif

#ifdef __IUnknown_INTERFACE_DEFINED__        // Don't assume they've #included objbase
#undef  INTERFACE
#define INTERFACE       ILVRange

DECLARE_INTERFACE_(ILVRange, IUnknown)
{
    INTERFACE_PROLOGUE(ILVRange)

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void * * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISelRange methods ***
    STDMETHOD(IncludeRange)(THIS_ LONG iBegin, LONG iEnd) PURE;
    STDMETHOD(ExcludeRange)(THIS_ LONG iBegin, LONG iEnd) PURE;
    STDMETHOD(InvertRange)(THIS_ LONG iBegin, LONG iEnd) PURE;
    STDMETHOD(InsertItem)(THIS_ LONG iItem) PURE;
    STDMETHOD(RemoveItem)(THIS_ LONG iItem) PURE;

    STDMETHOD(Clear)(THIS) PURE;
    STDMETHOD(IsSelected)(THIS_ LONG iItem) PURE;
    STDMETHOD(IsEmpty)(THIS) PURE;
    STDMETHOD(NextSelected)(THIS_ LONG iItem, LONG *piItem) PURE;
    STDMETHOD(NextUnSelected)(THIS_ LONG iItem, LONG *piItem) PURE;
    STDMETHOD(CountIncluded)(THIS_ LONG *pcIncluded) PURE;

    INTERFACE_EPILOGUE(ILVRange)
};
#endif // __IUnknown_INTERFACE_DEFINED__

#define LVSR_SELECTION          0x00000000              // Set the Selection range object
#define LVSR_CUT                0x00000001              // Set the Cut range object

#define LVM_SETLVRANGEOBJECT    (LVM_FIRST + 82)
#define ListView_SetLVRangeObject(hwndLV, iWhich, pilvRange)\
        (BOOL)SNDMSG((hwndLV), LVM_SETLVRANGEOBJECT, (WPARAM)(iWhich),  (LPARAM)(pilvRange))

#define LVM_RESETEMPTYTEXT      (LVM_FIRST + 84)
#define ListView_ResetEmptyText(hwndLV)\
        (BOOL)SNDMSG((hwndLV), LVM_RESETEMPTYTEXT, 0, 0)

#define LVM_SETFROZENITEM       (LVM_FIRST + 85)
#define ListView_SetFrozenItem(hwndLV, fFreezeOrUnfreeze, iIndex)\
        (BOOL)SNDMSG((hwndLV), LVM_SETFROZENITEM, (WPARAM)(fFreezeOrUnfreeze), (LPARAM)(iIndex))

#define LVM_GETFROZENITEM       (LVM_FIRST + 86)
#define ListView_GetFrozenItem(hwndLV)\
        (int)SNDMSG((hwndLV), LVM_GETFROZENITEM, 0, 0)

#define LVM_SETFROZENSLOT       (LVM_FIRST + 88)
#define ListView_SetFrozenSlot(hwndLV, fFreezeOrUnfreeze, lpPt)\
        (BOOL)SNDMSG((hwndLV), LVM_SETFROZENSLOT, (WPARAM)(fFreezeOrUnfreeze), (LPARAM)(lpPt))

#define LVM_GETFROZENSLOT       (LVM_FIRST + 89)
#define ListView_GetFrozenSlot(hwndLV, lpRect)\
        (BOOL)SNDMSG((hwndLV), LVM_GETFROZENSLOT, (WPARAM)(0), (LPARAM)(lpRect))

#define LVM_SETVIEWMARGINS (LVM_FIRST + 90)
#define ListView_SetViewMargins(hwndLV, lpRect)\
        (BOOL)SNDMSG((hwndLV), LVM_SETVIEWMARGINS, (WPARAM)(0), (LPARAM)(lpRect))

#define LVM_GETVIEWMARGINS (LVM_FIRST + 91)
#define ListView_GetViewMargins(hwndLV, lpRect)\
        (BOOL)SNDMSG((hwndLV), LVM_SETVIEWMARGINS, (WPARAM)(0), (LPARAM)(lpRect))

#define LVN_ENDDRAG             (LVN_FIRST-10)
#define LVN_ENDRDRAG            (LVN_FIRST-12)
#ifdef PW2
#define LVN_PEN                 (LVN_FIRST-20)
#endif
#define LVN_GETEMPTYTEXTA          (LVN_FIRST-60)
#define LVN_GETEMPTYTEXTW          (LVN_FIRST-61)

#ifdef UNICODE
#define LVN_GETEMPTYTEXT           LVN_GETEMPTYTEXTW
#else
#define LVN_GETEMPTYTEXT           LVN_GETEMPTYTEXTA
#endif
#if (_WIN32_IE >= 0x0500)
#define LVN_INCREMENTALSEARCHA   (LVN_FIRST-62)
#define LVN_INCREMENTALSEARCHW   (LVN_FIRST-63)

#ifdef UNICODE
#define LVN_INCREMENTALSEARCH    LVN_INCREMENTALSEARCHW
#else
#define LVN_INCREMENTALSEARCH    LVN_INCREMENTALSEARCHA
#endif

#endif      // _WIN32_IE >= 0x0500
#define TVS_SHAREDIMAGELISTS    0x0000  //
#define TVS_PRIVATEIMAGELISTS   0x0400  //
#if (_WIN32_WINNT >= 0x0501)
#define TVS_EX_NOSINGLECOLLAPSE    0x00000001 // for now make this internal
#endif
#define TVIF_WIN95              0x007F
#define TVIF_ALL                0x00FF
#define TVIF_RESERVED           0xf000  // all bits in high nibble is for notify specific stuff

#define TVIS_FOCUSED            0x0001  // Never implemented
#define TVIS_DISABLED           0        // GOING AWAY
#define TVIS_ALL                0xFF7E
#define I_CHILDRENAUTO      (-2)
    // all items above this line were for win95.  don't touch them.
    //  unfortunately, this structure was used inline in tv's notify structures
    //  which means that the size must be fixed for compat reasond
    // all items above this line were for win95.  don't touch them.
    //  unfortunately, this structure was used inline in tv's notify structures
    //  which means that the size must be fixed for compat reasond
    // all items above this line were for win95.  don't touch them.
#define TVE_ACTIONMASK          0x0003      //  (TVE_COLLAPSE | TVE_EXPAND | TVE_TOGGLE)
#define TV_FINDITEM             (TV_FIRST + 3)
#define TVGN_VALID              0x000F
#if (_WIN32_WINNT >= 0x501)
#else
#define TVSI_NOSINGLEEXPAND    0x8000 // Should not conflict with TVGN flags.
#define TVSI_VALID             0x8000
#endif
#define TVM_SETBORDER         (TV_FIRST + 35)
#define TreeView_SetBorder(hwnd,  dwFlags, xBorder, yBorder) \
    (int)SNDMSG((hwnd), TVM_SETBORDER, (WPARAM)(dwFlags), MAKELPARAM(xBorder, yBorder))

#define TVM_GETBORDER         (TV_FIRST + 36)
#define TreeView_GetBorder(hwnd) \
    (int)SNDMSG((hwnd), TVM_GETBORDER, 0, 0)


#define TVSBF_XBORDER   0x00000001
#define TVSBF_YBORDER   0x00000002
#define TVM_TRANSLATEACCELERATOR    CCM_TRANSLATEACCELERATOR
#define TVM_SETEXTENDEDSTYLE      (TV_FIRST + 44)
#define TreeView_SetExtendedStyle(hwnd, dw, mask) \
    (DWORD)SNDMSG((hwnd), TVM_SETEXTENDEDSTYLE, mask, dw)

#define TVM_GETEXTENDEDSTYLE      (TV_FIRST + 45)
#define TreeView_GetExtendedStyle(hwnd) \
    (DWORD)SNDMSG((hwnd), TVM_GETEXTENDEDSTYLE, 0, 0)
#define CBEN_ITEMCHANGED         (CBEN_FIRST - 3)  //
#define TCS_SHAREIMAGELISTS     0x0000
#define TCS_PRIVATEIMAGELISTS   0x0000
#define TCM_GETBKCOLOR          (TCM_FIRST + 0)
#define TabCtrl_GetBkColor(hwnd)  (COLORREF)SNDMSG((hwnd), TCM_GETBKCOLOR, 0, 0L)

#define TCM_SETBKCOLOR          (TCM_FIRST + 1)
#define TabCtrl_SetBkColor(hwnd, clrBk)  (BOOL)SNDMSG((hwnd), TCM_SETBKCOLOR, 0, (LPARAM)(COLORREF)(clrBk))
#define TCIF_ALL                0x001f
#define TCIS_HIDDEN             0x0004
    // This block must be identical to TC_TEIMHEADER
    // This block must be identical to TC_TEIMHEADER
// internal because it is not implemented yet
#define TCM_GETOBJECT           (TCM_FIRST + 54)
#define TabCtrl_GetObject(hwnd, piid, ppv) \
        (DWORD)SNDMSG((hwnd), TCM_GETOBJECT, (WPARAM)(piid), (LPARAM)(ppv))
#define MCSC_COLORCOUNT   6   //
// NOTE: this was MCN_FIRST + 2 but I changed it when I changed the structre //
#define MCS_VALIDBITS       0x001F          //
#define MCS_INVALIDBITS     ((~MCS_VALIDBITS) & 0x0000FFFF) //
#define DTS_FORMATMASK      0x000C
#define DTS_VALIDBITS       0x003F //
#define DTS_INVALIDBITS     ((~DTS_VALIDBITS) & 0x0000FFFF) //
#define PGM_SETSCROLLINFO      (PGM_FIRST + 13)
#define Pager_SetScrollInfo(hwnd, cTimeOut, cLinesPer, cPixelsPerLine) \
        (void) SNDMSG((hwnd), PGM_SETSCROLLINFO, cTimeOut, MAKELONG(cLinesPer, cPixelsPerLine))
#ifndef NOCOMBOBOX

// Combobox creates a specially registered version
// of the Listbox control called ComboLBox.

#ifdef _WIN32
#define WC_COMBOLBOXA           "ComboLBox"
#define WC_COMBOLBOXW           L"ComboLBox"

#ifdef UNICODE
#define WC_COMBOLBOX            WC_COMBOLBOXW
#else
#define WC_COMBOLBOX            WC_COMBOLBOXA
#endif

#else
#define WC_COMBOLBOX            "ComboLBox"
#endif  // _WIN32

#endif // NOCOMBOBOX
/// ===================== ReaderMode Control =========================
#ifndef NOREADERMODE


#ifdef _WIN32
#define WC_READERMODEA          "ReaderModeCtl"
#define WC_READERMODEW          L"ReaderModeCtl"

#ifdef UNICODE
#define WC_READERMODE           WC_READERMODEW
#else
#define WC_READERMODE           WC_READERMODEA
#endif

#else
#define WC_READERMODE           "ReaderModeCtl"
#endif  // _WIN32

#endif // NOREADERMODE
/// ===================== End ReaderMode Control =========================

#ifndef NO_COMMCTRL_DA
#define __COMMCTRL_DA_DEFINED__
//====== Dynamic Array routines ==========================================

// DOC'ed for DOJ compliance

WINCOMMCTRLAPI BOOL   WINAPI DSA_GetItem(HDSA hdsa, int i, void *pitem);
WINCOMMCTRLAPI BOOL   WINAPI DSA_SetItem(HDSA hdsa, int i, void *pitem);
WINCOMMCTRLAPI BOOL   WINAPI DSA_DeleteItem(HDSA hdsa, int i);
WINCOMMCTRLAPI BOOL   WINAPI DSA_DeleteAllItems(HDSA hdsa);
WINCOMMCTRLAPI void   WINAPI DSA_EnumCallback(HDSA hdsa, PFNDSAENUMCALLBACK pfnCB, void *pData);
#define     DSA_GetItemCount(hdsa)      (*(int *)(hdsa))
#define     DSA_AppendItem(hdsa, pitem) DSA_InsertItem(hdsa, DA_LAST, pitem)

// DOC'ed for DOJ compliance:
WINCOMMCTRLAPI HDPA   WINAPI DPA_CreateEx(int cpGrow, HANDLE hheap);
WINCOMMCTRLAPI HDPA   WINAPI DPA_Clone(HDPA hdpa, HDPA hdpaNew);
WINCOMMCTRLAPI int    WINAPI DPA_GetPtrIndex(HDPA hdpa, void *p);
WINCOMMCTRLAPI BOOL   WINAPI DPA_Grow(HDPA pdpa, int cp);
#define     DPA_GetPtrCount(hdpa)       (*(int *)(hdpa))
#define     DPA_FastDeleteLastPtr(hdpa) (--*(int *)(hdpa))
#define     DPA_GetPtrPtr(hdpa)         (*((void * **)((BYTE *)(hdpa) + sizeof(void *))))
#define     DPA_FastGetPtr(hdpa, i)     (DPA_GetPtrPtr(hdpa)[i])
#define     DPA_AppendPtr(hdpa, pitem)  DPA_InsertPtr(hdpa, DA_LAST, pitem)

#ifdef __IStream_INTERFACE_DEFINED__
// Save to and load from a stream.  The stream callback gets a pointer to
// a DPASTREAMINFO structure.
//
// For DPA_SaveStream, the callback is responsible for writing the pvItem
// info to the stream.  (It's not necessary to write the iPos to the
// stream.)  Return S_OK if the element was saved, S_FALSE if it wasn't
// but continue anyway, or some failure.
//
// For DPA_LoadStream, the callback is responsible for allocating an
// item and setting the pvItem field to the new pointer.  Return S_OK
// if the element was loaded, S_FALSE it it wasn't but continue anyway,
// or some failure.
//

typedef struct _DPASTREAMINFO
{
    int    iPos;        // Index of item
    void *pvItem;
} DPASTREAMINFO;

typedef HRESULT (CALLBACK *PFNDPASTREAM)(DPASTREAMINFO * pinfo, IStream * pstream, void *pvInstData);

WINCOMMCTRLAPI HRESULT WINAPI DPA_LoadStream(HDPA * phdpa, PFNDPASTREAM pfn, IStream * pstream, void *pvInstData);
WINCOMMCTRLAPI HRESULT WINAPI DPA_SaveStream(HDPA hdpa, PFNDPASTREAM pfn, IStream * pstream, void *pvInstData);
#endif

// DOC'ed for DOJ compliance

// Merge two DPAs.  This takes two (optionally) presorted arrays and merges
// the source array into the dest.  DPA_Merge uses the provided callbacks
// to perform comparison and merge operations.  The merge callback is
// called when two elements (one in each list) match according to the
// compare function.  This allows portions of an element in one list to
// be merged with the respective element in the second list.
//
// The first DPA (hdpaDest) is the output array.
//
// Merge options:
//
//    DPAM_SORTED       The arrays are already sorted; don't sort
//    DPAM_UNION        The resulting array is the union of all elements
//                      in both arrays (DPAMM_INSERT may be sent for
//                      this merge option.)
//    DPAM_INTERSECT    Only elements in the source array that intersect
//                      with the dest array are merged.  (DPAMM_DELETE
//                      may be sent for this merge option.)
//    DPAM_NORMAL       Like DPAM_INTERSECT except the dest array
//                      also maintains its original, additional elements.
//
#define DPAM_SORTED             0x00000001
#define DPAM_NORMAL             0x00000002
#define DPAM_UNION              0x00000004
#define DPAM_INTERSECT          0x00000008

// The merge callback should merge contents of the two items and return
// the pointer of the merged item.  It's okay to simply use pvDest
// as the returned pointer.
//
typedef void * (CALLBACK *PFNDPAMERGE)(UINT uMsg, void *pvDest, void *pvSrc, LPARAM lParam);

// Messages for merge callback
#define DPAMM_MERGE     1
#define DPAMM_DELETE    2
#define DPAMM_INSERT    3

WINCOMMCTRLAPI BOOL WINAPI DPA_Merge(HDPA hdpaDest, HDPA hdpaSrc, DWORD dwFlags, PFNDPACOMPARE pfnCompare, PFNDPAMERGE pfnMerge, LPARAM lParam);

// DOC'ed for DOJ compliance

#define DPA_SortedInsertPtr(hdpa, pFind, iStart, pfnCompare, lParam, options, pitem)  \
            DPA_InsertPtr(hdpa, DPA_Search(hdpa, pFind, iStart, pfnCompare, lParam, (DPAS_SORTED | (options))), (pitem))

//======================================================================
// String management helper routines

WINCOMMCTRLAPI int  WINAPI Str_GetPtrA(LPCSTR psz, LPSTR pszBuf, int cchBuf);
WINCOMMCTRLAPI int  WINAPI Str_GetPtrW(LPCWSTR psz, LPWSTR pszBuf, int cchBuf);
WINCOMMCTRLAPI BOOL WINAPI Str_SetPtrA(LPSTR * ppsz, LPCSTR psz);
// DOC'ed for DOJ compliance:

#ifdef UNICODE
#define Str_GetPtr              Str_GetPtrW
#define Str_SetPtr              Str_SetPtrW
#else
#define Str_GetPtr              Str_GetPtrA
#define Str_SetPtr              Str_SetPtrA
#endif

#endif // NO_COMMCTRL_DA

#ifndef NO_COMMCTRL_ALLOCFCNS
//====== Memory allocation functions ===================

#ifdef _WIN32
#define _huge
#endif

WINCOMMCTRLAPI void _huge* WINAPI Alloc(long cb);
WINCOMMCTRLAPI void _huge* WINAPI ReAlloc(void _huge* pb, long cb);
WINCOMMCTRLAPI BOOL        WINAPI Free(void _huge* pb);
WINCOMMCTRLAPI DWORD_PTR   WINAPI GetSize(void _huge* pb);

#endif


#ifndef _SIZE_T_DEFINED
#define _SIZE_T_DEFINED
typedef unsigned int size_t;
#endif

#ifdef _WIN32
//===================================================================
typedef int (CALLBACK *MRUCMPPROCA)(LPCSTR, LPCSTR);
typedef int (CALLBACK *MRUCMPPROCW)(LPCWSTR, LPCWSTR);

#ifdef UNICODE
#define MRUCMPPROC              MRUCMPPROCW
#else
#define MRUCMPPROC              MRUCMPPROCA
#endif

// NB This is cdecl - to be compatible with the crts.
typedef int (cdecl *MRUCMPDATAPROC)(const void *, const void *,
                                        size_t);



typedef struct _MRUINFOA {
    DWORD cbSize;
    UINT uMax;
    UINT fFlags;
    HKEY hKey;
    LPCSTR lpszSubKey;
    MRUCMPPROCA lpfnCompare;
} MRUINFOA, *LPMRUINFOA;

typedef struct _MRUINFOW {
    DWORD cbSize;
    UINT uMax;
    UINT fFlags;
    HKEY hKey;
    LPCWSTR lpszSubKey;
    MRUCMPPROCW lpfnCompare;
} MRUINFOW, *LPMRUINFOW;

typedef struct _MRUDATAINFOA {
    DWORD cbSize;
    UINT uMax;
    UINT fFlags;
    HKEY hKey;
    LPCSTR lpszSubKey;
    MRUCMPDATAPROC lpfnCompare;
} MRUDATAINFOA, *LPMRUDATAINFOA;

typedef struct _MRUDATAINFOW {
    DWORD cbSize;
    UINT uMax;
    UINT fFlags;
    HKEY hKey;
    LPCWSTR lpszSubKey;
    MRUCMPDATAPROC lpfnCompare;
} MRUDATAINFOW, *LPMRUDATAINFOW;


#ifdef UNICODE
#define MRUINFO                 MRUINFOW
#define LPMRUINFO               LPMRUINFOW
#define MRUDATAINFO             MRUDATAINFOW
#define LPMRUDATAINFO           LPMRUDATAINFOW
#else
#define MRUINFO                 MRUINFOA
#define LPMRUINFO               LPMRUINFOA
#define MRUDATAINFO             MRUDATAINFOA
#define LPMRUDATAINFO           LPMRUDATAINFOA
#endif

#define MRU_BINARY              0x0001
#define MRU_CACHEWRITE          0x0002
#define MRU_ANSI                0x0004
#define MRU_LAZY                0x8000

WINCOMMCTRLAPI HANDLE WINAPI CreateMRUListA(LPMRUINFOA lpmi);
WINCOMMCTRLAPI HANDLE WINAPI CreateMRUListW(LPMRUINFOW lpmi);
WINCOMMCTRLAPI void   WINAPI FreeMRUList(HANDLE hMRU);
WINCOMMCTRLAPI int    WINAPI AddMRUStringA(HANDLE hMRU, LPCSTR szString);
WINCOMMCTRLAPI int    WINAPI AddMRUStringW(HANDLE hMRU, LPCWSTR szString);
WINCOMMCTRLAPI int    WINAPI DelMRUString(HANDLE hMRU, int nItem);
WINCOMMCTRLAPI int    WINAPI FindMRUStringA(HANDLE hMRU, LPCSTR szString, LPINT lpiSlot);
WINCOMMCTRLAPI int    WINAPI FindMRUStringW(HANDLE hMRU, LPCWSTR szString, LPINT lpiSlot);
WINCOMMCTRLAPI int    WINAPI EnumMRUListA(HANDLE hMRU, int nItem, void * lpData, UINT uLen);
WINCOMMCTRLAPI int    WINAPI EnumMRUListW(HANDLE hMRU, int nItem, void * lpData, UINT uLen);

WINCOMMCTRLAPI int    WINAPI AddMRUData(HANDLE hMRU, const void *lpData, UINT cbData);
WINCOMMCTRLAPI int    WINAPI FindMRUData(HANDLE hMRU, const void *lpData, UINT cbData,
                          LPINT lpiSlot);
WINCOMMCTRLAPI HANDLE WINAPI CreateMRUListLazyA(LPMRUINFOA lpmi, const void *lpData, UINT cbData, LPINT lpiSlot);
WINCOMMCTRLAPI HANDLE WINAPI CreateMRUListLazyW(LPMRUINFOW lpmi, const void *lpData, UINT cbData, LPINT lpiSlot);

#ifdef UNICODE
#define CreateMRUList           CreateMRUListW
#define AddMRUString            AddMRUStringW
#define FindMRUString           FindMRUStringW
#define EnumMRUList             EnumMRUListW
#define CreateMRUListLazy       CreateMRUListLazyW
#else
#define CreateMRUList           CreateMRUListA
#define AddMRUString            AddMRUStringA
#define FindMRUString           FindMRUStringA
#define EnumMRUList             EnumMRUListA
#define CreateMRUListLazy       CreateMRUListLazyA
#endif

#endif

//=========================================================================
// for people that just gotta use GetProcAddress()

#ifdef _WIN32
#define DPA_CreateORD           328
#define DPA_DestroyORD          329
#define DPA_GrowORD             330
#define DPA_CloneORD            331
#define DPA_GetPtrORD           332
#define DPA_GetPtrIndexORD      333
#define DPA_InsertPtrORD        334
#define DPA_SetPtrORD           335
#define DPA_DeletePtrORD        336
#define DPA_DeleteAllPtrsORD    337
#define DPA_SortORD             338
#define DPA_SearchORD           339
#define DPA_CreateExORD         340
#define SendNotifyORD           341
#define CreatePageORD           163
#define CreateProxyPageORD      164
#endif
#define WM_TRACKMOUSEEVENT_FIRST        0x02A0
#define WM_TRACKMOUSEEVENT_LAST         0x02AF
#ifndef TME_VALID
#if (WINVER >= 0x0500)
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_NONCLIENT | TME_QUERY | TME_CANCEL)
#else
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_QUERY | TME_CANCEL)
#endif // WINVER >= 0x0500
#endif // !TME_VALID
// These definitions are never used as a bitmask; I don't know why
// they are all powers of two.
#if (_WIN32_IE >= 0x0500)
#define WSB_PROP_GUTTER     0x00001000L
#endif // (_WIN32_IE >= 0x0500)
// WSP_PROP_MASK is completely unused, but it was public in IE4
//====== SetPathWordBreakProc  ======================================
void WINAPI SetPathWordBreakProc(HWND hwndEdit, BOOL fSet);
#if (_WIN32_WINNT >= 0x501)
#else
//
// subclassing stuff
//
typedef LRESULT (CALLBACK *SUBCLASSPROC)(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

/* #!perl
	PoundIf("SetWindowSubclass", "(_WIN32_IE >= 0x560)");
	PoundIf("GetWindowSubclass", "(_WIN32_IE >= 0x560)");
	PoundIf("RemoveWindowSubclass", "(_WIN32_IE >= 0x560)");
	// DefSubclassProc doesn't reference the type SUBCLASSPROC, so it does not need the guard.
	// PoundIf("DefSubclassProc", "(_WIN32_IE >= 0x560)");
*/
BOOL WINAPI SetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR dwRefData);
BOOL WINAPI GetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR *pdwRefData);
BOOL WINAPI RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass,
    UINT_PTR uIdSubclass);
/* #!perl DeclareFunctionErrorValue("DefSubclassProc", "0"); */
LRESULT WINAPI DefSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
#endif

#if (_WIN32_WINNT >= 0x501)
/* #!perl DeclareFunctionErrorValue("DrawShadowText", "-1"); */
int WINAPI DrawShadowText(HDC hdc, LPCWSTR pszText, UINT cch, RECT* prc, DWORD dwFlags, COLORREF crText, COLORREF crShadow,
    int ixOffset, int iyOffset);
#endif


#ifdef __cplusplus
}
#endif

#endif

#endif  // _INC_COMMCTRLP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\dsclintp.h ===
#ifndef __dsclintp_h
#define __dsclintp_h
#ifndef GUID_DEFS_ONLY
#include "iadsp.h"
#include "comctrlp.h"
#define DSDSOF_INVOKEDFROMWAB           0x80000000      // = 1 => invoked from WAB
//
// The Exchange group use the DsBrowseForContainer API to brows the Exchange
// store, and other LDAP servers.   To support them we issue this callback
// which will request the filter they want to use and any other information.
//

typedef struct
{
    DWORD dwFlags;
    LPWSTR pszFilter;               // filter string to be used when searching the DS (== NULL for default)
    INT cchFilter;
    LPWSTR pszNameAttribute;        // attribute to request to get the display name of objects in the DS (== NULL for default).
    INT cchNameAttribute;
} DSBROWSEDATA, * PDSBROWSEDATA;

#define DSBM_GETBROWSEDATA      105 // lParam -> DSBROWSEDATA structure. Return TRUE if handled

//---------------------------------------------------------------------------//
//
// IDsFolderProperties
// ===================
//  This is a private interface used to override the "Properties" verb
//  displayed in the DS client UI.
//
//  Below the {CLISD_NameSpace}\Classes\<class name>\PropertiesHandler is
//  defined a GUID we will create an instance of that interface and
//  display the relevant UI.
//
//  dsfolder also supports this interface to allow the query UI to invoke
//  properties for a given selection.
// 
//---------------------------------------------------------------------------//

#undef  INTERFACE
#define INTERFACE   IDsFolderProperties

DECLARE_INTERFACE_(IDsFolderProperties, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // IDsFolder methods
    STDMETHOD(ShowProperties)(THIS_ HWND hwndParent, IDataObject* pDataObject) PURE;
};

//---------------------------------------------------------------------------//


//---------------------------------------------------------------------------//
// Private helper API's exported by 'dsuiext.dll'.
//---------------------------------------------------------------------------//

//
// To communicate information to the IShellFolder::ParseDisplayName method
// of the Directory namespace we pass a IBindCtx with a property bag
// associated with it.
//
// The property bag is used to pass in extra information about the
// objects we have selected.
//

#define DS_PDN_PROPERTYBAG      L"DsNamespaceShellFolderParsePropertyBag"

// 
// These are the properties passed to the objcts
//

#define DS_PDN_OBJECTLCASS      L"objectClass"


//---------------------------------------------------------------------------//
// String DPA helpers, adding strings to a DPA calling LocalAllocString and
// then the relevant DPA functions.
//---------------------------------------------------------------------------//

STDAPI StringDPA_InsertStringA(HDPA hdpa, INT i, LPCSTR pszString);
STDAPI StringDPA_InsertStringW(HDPA hdpa, INT i, LPCWSTR pszString);

STDAPI StringDPA_AppendStringA(HDPA hdpa, LPCSTR pszString, PUINT_PTR presult);
STDAPI StringDPA_AppendStringW(HDPA hdpa, LPCWSTR pszString, PUINT_PTR presult);

STDAPI_(VOID) StringDPA_DeleteString(HDPA hdpa, INT index);
STDAPI_(VOID) StringDPA_Destroy(HDPA* pHDPA);

#define StringDPA_GetStringA(hdpa, i) ((LPSTR)DPA_GetPtr(hdpa, i))
#define StringDPA_GetStringW(hdpa, i) ((LPWSTR)DPA_GetPtr(hdpa, i))

#ifndef UNICODE
#define StringDPA_InsertString  StringDPA_InsertStringA
#define StringDPA_AppendString  StringDPA_AppendStringA
#define StringDPA_GetString     StringDPA_GetStringA
#else
#define StringDPA_InsertString  StringDPA_InsertStringW
#define StringDPA_AppendString  StringDPA_AppendStringW
#define StringDPA_GetString     StringDPA_GetStringW
#endif


//---------------------------------------------------------------------------//
// Handle strings via LocalAlloc
//---------------------------------------------------------------------------//

STDAPI LocalAllocStringA(LPSTR* ppResult, LPCSTR pszString);
STDAPI LocalAllocStringLenA(LPSTR* ppResult, UINT cLen);
STDAPI_(VOID) LocalFreeStringA(LPSTR* ppString);
STDAPI LocalQueryStringA(LPSTR* ppResult, HKEY hk, LPCTSTR lpSubKey);

STDAPI LocalAllocStringW(LPWSTR* ppResult, LPCWSTR pString);
STDAPI LocalAllocStringLenW(LPWSTR* ppResult, UINT cLen);
STDAPI_(VOID) LocalFreeStringW(LPWSTR* ppString);
STDAPI LocalQueryStringW(LPWSTR* ppResult, HKEY hk, LPCTSTR lpSubKey);

STDAPI LocalAllocStringA2W(LPWSTR* ppResult, LPCSTR pszString);
STDAPI LocalAllocStringW2A(LPSTR* ppResult, LPCWSTR pszString);

#ifndef UNICODE
#define LocalAllocString    LocalAllocStringA
#define LocalAllocStringLen LocalAllocStringLenA
#define LocalFreeString     LocalFreeStringA
#define LocalQueryString    LocalQueryStringA
#define LocalAllocStringA2T LocalAllocString
#define LocalAllocStringW2T LocalAllocStringW2A
#else
#define LocalAllocString    LocalAllocStringW
#define LocalAllocStringLen LocalAllocStringLenW
#define LocalFreeString     LocalFreeStringW
#define LocalQueryString    LocalQueryStringW
#define LocalAllocStringA2T LocalAllocStringA2W
#define LocalAllocStringW2T LocalAllocString
#endif

STDAPI_(VOID) PutStringElementA(LPSTR pszBuffer, UINT* pLen, LPCSTR pszElement);
STDAPI_(VOID) PutStringElementW(LPWSTR pszszBuffer, UINT* pLen, LPCWSTR pszElement);
STDAPI GetStringElementA(LPSTR pszString, INT index, LPSTR pszBuffer, INT cchBuffer);
STDAPI GetStringElementW(LPWSTR pszString, INT index, LPWSTR pszBuffer, INT cchBuffer);

#ifndef UNICODE
#define PutStringElement PutStringElementA
#define GetStringElement GetStringElementA
#else
#define PutStringElement PutStringElementW
#define GetStringElement GetStringElementW
#endif


//---------------------------------------------------------------------------//
// Utility stuff common to dsfolder, dsquery etc
//---------------------------------------------------------------------------//

STDAPI_(INT) FormatMsgBox(HWND hWnd, HINSTANCE hInstance, UINT uidTitle, UINT uidPrompt, UINT uType, ...);
STDAPI FormatMsgResource(LPTSTR* ppString, HINSTANCE hInstance, UINT uID, ...);
STDAPI FormatDirectoryName(LPTSTR* ppString, HINSTANCE hInstance, UINT uID);

STDAPI StringFromSearchColumn(PADS_SEARCH_COLUMN pColumn, LPWSTR* ppBuffer);
STDAPI ObjectClassFromSearchColumn(PADS_SEARCH_COLUMN pColumn, LPWSTR* ppBuffer);

typedef HRESULT (CALLBACK * LPGETARRAYCONTENTCB)(DWORD dwIndex, BSTR bstrValue, LPVOID pData);
STDAPI GetArrayContents(LPVARIANT pVariant, LPGETARRAYCONTENTCB pCB, LPVOID pData);

STDAPI GetDisplayNameFromADsPath(LPCWSTR pszszPath, LPWSTR pszszBuffer, INT cchBuffer, IADsPathname *padp, BOOL fPrefix);

STDAPI_(DWORD) CheckDsPolicy(LPCTSTR pszSubKey, LPCTSTR pszValue);
STDAPI_(BOOL) ShowDirectoryUI(VOID);

#endif  // GUID_DEFS_ONLY
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\cscuiext.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000
//
//  File:       update.h
//
//--------------------------------------------------------------------------
#ifndef __INCLUDE_CSCUIEXT_H
#define __INCLUDE_CSCUIEXT_H
//
// Semi-public header for CSCUI.DLL.
// CSCUI.DLL provides the user interface for client-side caching.
// The code interacts with the CSC agent, Sync Manager (mobsync),
// winlogon, the shell, and the system tray (systray.exe).  
//
// 
STDAPI_(HWND) CSCUIInitialize(HANDLE hToken, DWORD dwFlags);
STDAPI_(LRESULT) CSCUISetState(UINT uMsg, WPARAM wParam, LPARAM lParam);
typedef HWND (*PFNCSCUIINITIALIZE)(HANDLE hToken, DWORD dwFlags);
//
// Flags for CSCUIInitialize
//
#define CI_INITIALIZE     0x0001
#define CI_TERMINATE      0x0002
#define CI_CREATEWINDOW   0x0004
#define CI_DESTROYWINDOW  0x0008
//
// These values are returned by CSCUISetState().
//
#define LRESULT_CSCWORKOFFLINE          1011   
#define LRESULT_CSCFAIL                 1012
#define LRESULT_CSCRETRY                1016
//
// These values are passed to CSCUISetState() as the uMsg arg.
//
#define STWM_CSCNETUP                   (WM_USER + 209)
#define STWM_CSCQUERYNETDOWN            (WM_USER + 210)
#define STWM_CSCCLOSEDIALOGS            (WM_USER + 212)
#define STWM_CSCNETDOWN                 (WM_USER + 213)
#define STWM_CACHE_CORRUPTED            (WM_USER + 214)
//
// These values are passed to CSCUISetState() as the wParam arg.
//
#define CSCUI_NO_AUTODIAL                   0
#define CSCUI_AUTODIAL_FOR_UNCACHED_SHARE   1
#define CSCUI_AUTODIAL_FOR_CACHED_SHARE     2
//
// These messages are private for the CSCUI hidden notification 
// window in systray.exe.
//
#define CSCWM_DONESYNCING               (WM_USER + 300)
#define CSCWM_UPDATESTATUS              (WM_USER + 301)
#define CSCWM_RECONNECT                 (WM_USER + 302)
#define CSCWM_SYNCHRONIZE               (WM_USER + 303)
#define CSCWM_ISSERVERBACK              (WM_USER + 304)
#define CSCWM_VIEWFILES                 (WM_USER + 305)
#define CSCWM_SETTINGS                  (WM_USER + 306)
#define CSCWM_GETSHARESTATUS            (WM_USER + 307)

//
// These constants are obtained by sending a CSCWM_GETSHARESTATUS
// message to the CSCUI hidden window.  They correspond to the 
// OfflineFolderStatus enumeration constants defined in shldisp.h.  
// These must remain in sync for the shell folder webview to work properly.
//
#define CSC_SHARESTATUS_INACTIVE    -1   // Same as OFS_INACTIVE
#define CSC_SHARESTATUS_ONLINE       0   // Same as OFS_ONLINE
#define CSC_SHARESTATUS_OFFLINE      1   // Same as OFS_OFFLINE
#define CSC_SHARESTATUS_SERVERBACK   2   // Same as OFS_SERVERBACK
#define CSC_SHARESTATUS_DIRTYCACHE   3   // Same as OFS_DIRTYCACHE

//
// Class name and title for the CSCUI hidden notification window.
//
#define STR_CSCHIDDENWND_CLASSNAME TEXT("CSCHiddenWindow")
#define STR_CSCHIDDENWND_TITLE TEXT("CSC Notifications Window")

//
// Function for deleting folders & contents from the cache.
//
//   pszFolder -- UNC path of folder to remove
//   pfnCB -- optional, may be NULL. Return FALSE to abort, TRUE to continue.
//   lParam -- passed to pfnCB
//
typedef BOOL (CALLBACK *PFN_CSCUIRemoveFolderCallback)(LPCWSTR, LPARAM);
STDAPI CSCUIRemoveFolderFromCache(LPCWSTR pszFolder, DWORD dwReserved, PFN_CSCUIRemoveFolderCallback pfnCB, LPARAM lParam);

//
// One of these is returned in the *pdwTsMode
// argument to CSCUI_IsTerminalServerCompatibleWithCSC API.
//
// CSCTSF_ = "CSC Terminal Server Flag"
//
#define CSCTSF_UNKNOWN       0  // Can't obtain TS status.
#define CSCTSF_CSC_OK        1  // OK to use CSC.
#define CSCTSF_APP_SERVER    2  // TS is configured as an app server.
#define CSCTSF_MULTI_CNX     3  // Multiple connections are allowed.
#define CSCTSF_REMOTE_CNX    4  // There are currently remote connections active.
#define CSCTSF_FUS_ENABLED   5  // Fast User Switching is enabled.
#define CSCTSF_COUNT         6
//
// Returns:
//    S_OK    - Terminal Server is in a mode that is compatible with CSC.
//    S_FALSE - Not OK to use CSC.  Inspect *pdwTsMode for reason.
//    other   - Failure.  *pdwTsMode contains CSCTSF_UNKNOWN.
//
HRESULT CSCUIIsTerminalServerCompatibleWithCSC(DWORD *pdwTsMode);

#endif // __INCLUDE_CSCUIEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\ginarcid.h ===
//  Don't use numbers lower than 20000. These are used by the DS component
//  of msgina.

// UI host failure
#define IDS_UIHOST_FAILURE                          20000
#define IDS_GENERIC_CAPTION                         20001
#define IDS_RECONNECT_FAILURE                       20005

#define IDD_GINA_TURNOFFCOMPUTER                    20050
#define IDD_GINA_RETURNTOWELCOME                    20051

#define IDD_TURNOFFCOMPUTER                         20100
#define IDC_TITLE_FLAG                              20101
#define IDC_TITLE_TURNOFF                           20102
#define IDC_BUTTON_TURNOFF                          20103
#define IDC_BUTTON_STANDBY                          20104
#define IDC_BUTTON_RESTART                          20105
#define IDC_BUTTON_HIBERNATE                        20106
#define IDC_TEXT_TURNOFF                            20107
#define IDC_TEXT_STANDBY                            20108
#define IDC_TEXT_RESTART                            20109
#define IDC_TEXT_HIBERNATE                          20110

#define IDS_TURNOFF_TITLE_FACENAME                  20125
#define IDS_TURNOFF_TITLE_FACESIZE                  20126
#define IDS_TURNOFF_BUTTON_FACENAME                 20127
#define IDS_TURNOFF_BUTTON_FACESIZE                 20128
#define IDS_TURNOFF_TOOLTIP_TEXT_TURNOFF            20129
#define IDS_TURNOFF_TOOLTIP_TEXT_STANDBY            20130
#define IDS_TURNOFF_TOOLTIP_TEXT_STANDBY_HIBERNATE  20131
#define IDS_TURNOFF_TOOLTIP_TEXT_RESTART            20132
#define IDS_TURNOFF_TOOLTIP_TEXT_HIBERNATE          20133

#define IDB_BACKGROUND_8                            20140
#define IDB_FLAG_8                                  20141
#define IDB_BACKGROUND_24                           20142
#define IDB_FLAG_24                                 20143

#define IDB_BUTTONS                                 20150
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\ieguidp.h ===
#ifndef _IEGUIDP_H_
#define _IEGUIDP_H_

#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif


//
// from shlguidp.h
//

#if (_WIN32_IE >= 0x0400)

// favorites band
// {EFA24E61-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_FavBand,              0xefa24e61, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// history band
// {EFA24E62-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_HistBand,              0xefa24e62, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// channels band
// {EFA24E63-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_ChannelBand,          0xefa24e63, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// {A2B0DD40-CC59-11d0-A3A5-00C04FD706EC}
DEFINE_GUID( CLSID_IESplashScreen, 0xa2b0dd40, 0xcc59, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

#endif  // (_WIN32_IE >= 0x0400)



#if (_WIN32_IE >= 0x0400)

DEFINE_GUID(IID_IWinEventHandler,       0xEA5F2D61L, 0xE008, 0x11CF, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x44, 0x97);

DEFINE_GUID(IID_IExplorerToolbar,       0x8455F0C1L, 0x158F, 0x11D0, 0x89, 0xAE, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);
#define SID_SExplorerToolbar IID_IExplorerToolbar

// IQueryCodePage {C7B236CE-EE80-11D0-985F-006008059382}
DEFINE_GUID(IID_IQueryCodePage, 0xC7B236CEL, 0xEE80, 0x11D0, 0x98, 0x5F, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

DEFINE_GUID(CGID_AddressEditBox, 0x72730b70, 0xe8f7, 0x11d0, 0xbc, 0x44, 0x0, 0xaa, 0x0, 0x6c, 0xe2, 0xf5);

/// AddressEditBox stuff
// {A08C11D1-A228-11d0-825B-00AA005B4383}
DEFINE_GUID(IID_IAddressEditBox, 0xa08c11d1, 0xa228, 0x11d0, 0x82, 0x5b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);
DEFINE_GUID(CLSID_AddressEditBox,0xa08c11d2, 0xa228, 0x11d0, 0x82, 0x5b, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {????} - For JITting in HTML Help Feature
DEFINE_GUID(CLSID_IEHelp, 0x45ea75a0L, 0xa269, 0x11d1, 0xb5, 0xbf, 0x00, 0x00, 0xf8, 0x05, 0x15, 0x15);

// {603D3800-BD81-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_ShellTaskScheduler,        0x603d3800, 0xbd81, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {6CCB7BE0-6807-11d0-B810-00C04FD706EC}
DEFINE_GUID(IID_IShellTaskScheduler,         0x6ccb7be0, 0x6807, 0x11d0, 0xb8, 0x10, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {04B3813B-0A23-11d2-B5AC-006097DF5BD4} - For JITting in FTP Shell Extension.
DEFINE_GUID(CLSID_FTPShellExtension, 0x4b3813b, 0xa23, 0x11d2, 0xb5, 0xac, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {CB81A3CB-1039-11d1-AB74-00C04FC30936}
DEFINE_GUID( IID_ISplashScreen, 0xcb81a3cb, 0x1039, 0x11d1, 0xab, 0x74, 0x0, 0xc0, 0x4f, 0xc3, 0x9, 0x36);

// {6B707A1C-744F-11d2-86B9-00C04F8EEA99}
DEFINE_GUID(IID_IBrowserBand, 0x6b707a1c, 0x744f, 0x11d2, 0x86, 0xb9, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99);

DEFINE_GUID(VID_WebView, 0x5984FFE0L, 0x28D4, 0x11CF, 0xAE, 0x66, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// {BE098140-A513-11d0-A3A4-00C04FD706EC}

// {603D3801-BD81-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_SharedTaskScheduler,       0x603d3801, 0xbd81, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

DEFINE_GUID(CLSID_ImageListCache,            0x3f4eef80, 0xbfe8, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

DEFINE_GUID(IID_IAddressBand,           0x106E86E1, 0x52B5, 0x11D0, 0xBF, 0xED, 0x0, 0xAA, 0x0, 0x5B, 0x43, 0x83);

// used by shell32 and ie components.
// same interface as IID_IExtractImage
// {D4029EC0-0920-11d1-9A0B-00C04FC2D6C1}
DEFINE_GUID(IID_IExtractLogo,                0xd4029ec0, 0x920, 0x11d1, 0x9a, 0xb, 0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

// {0D14E31C-D8C0-11d0-9816-00C04FD91972}
DEFINE_GUID(SID_SMenuBandHandler,           0xd14e31c, 0xd8c0, 0x11d0, 0x98, 0x16, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {3F4EEF80-BFE8-11d0-A3A5-00C04FD706EC}
// {4FCE9180-BFE8-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(IID_IImageCache,                 0x4fce9180, 0xbfe8, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {8A4D3EDC-13A4-11d1-9A22-00C04FC2D6C1}
DEFINE_GUID(CLSID_ThumbnailScaler, 0x8a4d3edc, 0x13a4, 0x11d1, 0x9a, 0x22, 0x0, 0xc0, 0x4f, 0xc2, 0xd6, 0xc1);

// {45B324CE-B8A1-11d1-98D3-00C04FB687DA}
DEFINE_GUID(IID_IScaleAndSharpenImage2, 0x45b324ce, 0xb8a1, 0x11d1, 0x98, 0xd3, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

DEFINE_GUID(IID_IDeskBarClient,         0xEB0FE175L, 0x1A3A, 0x11D0, 0x89, 0xB3, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xAC);

DEFINE_GUID(IID_IMultiMonitorDockingSite, 0x03879DE0L, 0xA205, 0x11D0, 0x99, 0xCB, 0x00, 0xC0, 0x4F, 0xD6, 0x55, 0xE1); 

// {D12F26B1-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(IID_IRestrict, 0xd12f26b1, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {D12F26B2-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(SID_SRestrictionHandler, 0xd12f26b2, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {D12F26B3-D90A-11d0-830D-00AA005B4383}
DEFINE_GUID(RID_RDeskBars, 0xd12f26b3, 0xd90a, 0x11d0, 0x83, 0xd, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {4622AD16-FF23-11d0-8D34-00A0C90F2719}
DEFINE_GUID(IID_IInitializeObject,0x4622ad16, 0xff23, 0x11d0, 0x8d, 0x34, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);



#endif  // (_WIN32_IE >= 0x0400)


#if _WIN32_IE >= 0x0500

DEFINE_GUID(IID_IPersistString, 0xD5E37E20L, 0x0257, 0x11CF, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// {8210BAC0-C6D2-11cf-89AA-00A0C9054129}

// {AC3E9E59-96D7-11d1-98A4-00C04FB687DA}
DEFINE_GUID(IID_IImageCache2,                0xac3e9e59, 0x96d7, 0x11d1, 0x98, 0xa4, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);

#endif  // _WIN32_IE >= 0x0500

#if (_WIN32_IE >= 0x0501)
// {58C73AE8-6AFE-4784-96FC-F97F65773B64}
DEFINE_GUID(IID_IShellTaskScheduler2,        0x58c73ae8, 0x6afe, 0x4784, 0x96, 0xfc, 0xf9, 0x7f, 0x65, 0x77, 0x3b, 0x64);

// {B61D9AB3-F120-4a5c-83A0-542923985BF7}
DEFINE_GUID(IID_IImageCache3,                0xb61d9ab3, 0xf120, 0x4a5c, 0x83, 0xa0, 0x54, 0x29, 0x23, 0x98, 0x5b, 0xf7);
#endif


#if _WIN32_IE >= 0x0600

#ifndef DEFINE_SHLGUID
#define DEFINE_SHLGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)

#endif

// SID_SBrandBand: the spinning globe {82A62DE8-32AC-4e4a-9935-9046C378CF90}
DEFINE_GUID(SID_SBrandBand, 0x82a62de8, 0x32ac, 0x4e4a, 0x99, 0x35, 0x90, 0x46, 0xc3, 0x78, 0xcf, 0x90);

// Command group for the BrandBand {25019D8C-9EE0-45c0-883B-972D48325E18}
DEFINE_GUID(CGID_BrandCmdGroup, 0x25019d8c, 0x9ee0, 0x45c0, 0x88, 0x3b, 0x97, 0x2d, 0x48, 0x32, 0x5e, 0x18);

// Command IDs for the BrandBand's CGID_BrandCmdGroup (to be called in Exec)
#define CBRANDIDM_STARTGLOBEANIMATION   1
#define CBRANDIDM_STOPGLOBEANIMATION    2


// {31D44C2F-6C6A-45fc-B8C7-946BA8EDB8B4}
DEFINE_GUID(CGID_MediaBar, 0x31d44c2f, 0x6c6a, 0x45fc, 0xb8, 0xc7, 0x94, 0x6b, 0xa8, 0xed, 0xb8, 0xb4);

#endif // _WIN32_IE >= 0x0600


// Private Dochost Commands
//
DEFINE_SHLGUID(CGID_DocHostCmdPriv,         0x000214D4L, 0, 0);



//
//  from shguidp.h
//

// explorer band
// {EFA24E64-B078-11d0-89E4-00C04FC9E26E}
DEFINE_GUID(CLSID_ExplorerBand,         0xefa24e64, 0xb078, 0x11d0, 0x89, 0xe4, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

/// INSCTree
// {43A8F463-4222-11d2-B641-006097DF5BD4}
DEFINE_GUID(CLSID_NSCTree,              0x43a8f463, 0x4222, 0x11d2, 0xb6, 0x41, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {1FBA04EE-3024-11d2-8F1F-0000F87ABD16}
DEFINE_GUID(CLSID_ToolbarExtExec, 0x1fba04ee, 0x3024, 0x11d2, 0x8f, 0x1f, 0x0, 0x0, 0xf8, 0x7a, 0xbd, 0x16);

// {E0DD6CAB-2D10-11d2-8F1A-0000F87ABD16}
DEFINE_GUID(CLSID_ToolbarExtBand, 0xe0dd6cab, 0x2d10, 0x11d2, 0x8f, 0x1a, 0x0, 0x0, 0xf8, 0x7a, 0xbd, 0x16);

// {83799FE0-1F5A-11d1-95C7-00609797EA4F}
DEFINE_GUID(CLSID_DocFileInfoTip,   0x83799fe0, 0x1f5a, 0x11d1, 0x95, 0xc7, 0x0, 0x60, 0x97, 0x97, 0xea, 0x4f);

// {8E6E6079-0CB7-11d2-8F10-0000F87ABD16}
DEFINE_GUID(CLSID_OfflinePagesCacheCleaner, 0x8e6e6079, 0xcb7, 0x11d2, 0x8f, 0x10, 0x0, 0x0, 0xf8, 0x7a, 0xbd, 0x16);

// Internet Cache Cleaner
// {9B0EFD60-F7B0-11D0-BAEF-00C04FC308C9}
DEFINE_GUID(CLSID_InternetCacheCleaner,     0x9b0efd60, 0xf7b0, 0x11d0, 0xba, 0xef, 0x0, 0xc0, 0x4f, 0xc3, 0x08, 0xc9);

// {67EA19A0-CCEF-11d0-8024-00C04FD75D13}
DEFINE_GUID(CLSID_CDFCopyHook, 0x67ea19a0, 0xccef, 0x11d0, 0x80, 0x24, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

//ffdc1a80-d527-11d0-a32c-34af06c10000
DEFINE_GUID (CLSID_WinListShellProc, 0xffdc1a80, 0xd527, 0x11d0, 0xa3, 0x2c, 0x34, 0xaf, 0x06, 0xc1, 0x00, 0x00);

DEFINE_GUID(CLSID_ChannelOC,            0x131A6951L, 0x7F78, 0x11D0, 0xA9, 0x79, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

DEFINE_GUID(CLSID_CStubBindStatusCallback, 
                                        0x2B4F54B1, 0x3D6D, 0x11d0, 0x82, 0x58, 0x00, 0xC0, 0x4F, 0xD5, 0xAE, 0x38);// 2B4F54B1-3D6D-11d0-8258-00C04FD5AE38

// History Shell Folder
DEFINE_GUID(CLSID_HistFolder,           0xFF393560L, 0xC2A7, 0x11CF, 0xBF, 0xF4, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);

// Cache Shell Folder UICLSID
DEFINE_GUID(CLSID_CacheFolder,          0x7BD29E00L, 0x76C1, 0x11CF, 0x9D, 0xD0, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x33);
// Cache Shell Folder full implementation
DEFINE_GUID(CLSID_CacheFolder2,         0x7BD29E01L, 0x76C1, 0x11CF, 0x9D, 0xD0, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x33);

DEFINE_GUID(CLSID_CDocObjectFolder,     0xE7E4BC40, 0xE76A, 0x11CE, 0xA9,0xBB,0x00,0xAA,0x00,0x4A,0xE8,0x37);//E7E4BC40-E76A-11CE-A9BB-00AA004AE837

// {BB90CD8B-4F08-11d0-B497-00C04FD90119}
DEFINE_GUID(IID_IShellHTMLWindowSupport,0xbb90cd8bL, 0x4f08, 0x11d0, 0xb4, 0x97, 0x00, 0xc0, 0x4f, 0xd9, 0x01, 0x19);

DEFINE_GUID(IID_IExpDispSupport,        0x0D7D1D00, 0x6FC0, 0x11D0, 0xA9, 0x74, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);//0D7D1D00-6FC0-11D0-A974-00C04FD705A2

DEFINE_GUID(IID_IDocNavigate,           0x131A6950L, 0x7F78, 0x11D0, 0xA9, 0x79, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

//***   SID_STopFrameBrowser -- like SID_STopLevelBrowser, but blocked by BrowserBand
// currently used to make BrowserBand get its own global history, but could
// be more generally useful than that, hence the more generic name.
// {A9227C3C-7F8E-11d0-8CB0-00A0C92DBFE8}
DEFINE_GUID(SID_STopFrameBrowser,       0xa9227c3c, 0x7f8e, 0x11d0, 0x8c, 0xb0, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

// {C7A30296-907E-11d2-B02F-00C04FA35D89}
DEFINE_GUID(IID_IUrlHistoryPriv,        0xc7a30296, 0x907e, 0x11d2, 0xb0, 0x2f, 0x0, 0xc0, 0x4f, 0xa3, 0x5d, 0x89);

// 20C46561-8491-11CF-960C-0080C7F4EE85 
// this is who should navigate instead
DEFINE_GUID(SID_SProxyBrowser,          0x20C46561L, 0x8491, 0x11CF, 0x96, 0x0C, 0x00, 0x80, 0xC7, 0xF4, 0xEE, 0x85);

//1E79697E-9CC5-11D1-A83F-00C04FC99D61
DEFINE_GUID(CLSID_CommonButtons, 0x1E79697EL, 0x9CC5, 0x11D1, 0xA8, 0x3F, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

DEFINE_GUID(SID_PendingBindStatusCallback, 0xfe390c68, 0xe2bc, 0x11d0, 0x88, 0x8c, 0x0, 0xc0, 0x4f, 0xc2, 0xc8, 0x36);

// {32bb8320-b41b-11cf-a6bb-0080c7b2d682}
DEFINE_GUID(IID_IBrowserExtension, 0x32bb8320, 0xb41b, 0x11cf, 0xa6, 0xbb, 0x0, 0x80, 0xc7, 0xb2, 0xd6, 0x82);

DEFINE_GUID(SID_ITopViewHost,           0xd1e7afec, 0x6a2e, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);

DEFINE_GUID(IID_IEFrameAuto,            0x131A6953L, 0x7F78, 0x11D0, 0xA9, 0x79, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);

DEFINE_GUID(IID_IExpDispSupportOC,      0x0D7D1D01, 0x6FC0, 0x11D0, 0xA9, 0x74, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xA2);//0D7D1D01-6FC0-11D0-A974-00C04FD705A2

// {48123bc4-99d9-11d1-a6b3-00c04fd91555}
DEFINE_GUID(CLSID_XMLViewerDocObj, 0x48123bc4, 0x99d9, 0x11d1, 0xa6, 0xb3, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x55);

DEFINE_GUID(IID_IOrderList,             0x8bfcb27d, 0xcf1a, 0x11d0, 0xb9, 0x3d, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);
DEFINE_GUID(CLSID_OrderListExport,      0xf3368374, 0xcf19, 0x11d0, 0xb9, 0x3d, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);

// Interface used to keep channel cache in sync.
DEFINE_GUID(IID_IChannelMgrPriv, 0xc9ace0f0, 0xac1, 0x11d1, 0x8f, 0x45, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x3f);
DEFINE_GUID(IID_IChannelMgrPriv2, 0xc9ace0f1, 0xac1, 0x11d1, 0x8f, 0x45, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x3f);

// {1ABCFC13-2340-11d2-B601-006097DF5BD4}
DEFINE_GUID(CLSID_FtpInstaller, 0x1abcfc13, 0x2340, 0x11d2, 0xb6, 0x1, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);
DEFINE_GUID(IID_IFtpInstaller, 0x1abcfc13, 0x2340, 0x11d2, 0xb6, 0x1, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// this is used in shdocvw's CConnectionPoint implementation
// to let CShellOcx type OCs get advised of Advise/Unadvise
// calls to the connection point. CShellFolderViewOC uses it.
//
DEFINE_GUID(IID_IConnectionPointCB,     0xAAAC9640L, 0x1252, 0x11D0, 0x89, 0xA9, 0x00, 0xA0, 0xC9, 0x05, 0x41, 0x29);

// {4ec5337e-4554-4705-81fd-06a3e1b0430a}
DEFINE_GUID(IID_IShellHTMLWindowSupport2,0x4ec5337e, 0x4554, 0x4705, 0x81, 0xfd, 0x06, 0xa3, 0xe1, 0xb0, 0x43, 0x0a);

// {DD313E04-FEFF-11d1-8ECD-0000F87A470C}
DEFINE_GUID(CLSID_UserAssist, 0xdd313e04, 0xfeff, 0x11d1, 0x8e, 0xcd, 0x0, 0x0, 0xf8, 0x7a, 0x47, 0xc);

// {DD313E05-FEFF-11d1-8ECD-0000F87A470C}
DEFINE_GUID(IID_IUserAssist, 0xdd313e05, 0xfeff, 0x11d1, 0x8e, 0xcd, 0x0, 0x0, 0xf8, 0x7a, 0x47, 0xc);

// navigate band UI from pidl
DEFINE_GUID(IID_IBandNavigate,          0x3697c30b, 0xcd88, 0x11d0, 0x8a, 0x3e, 0x0, 0xc0, 0x4f, 0xc9, 0xe2, 0x6e);

// {3050f803-98b5-11cf-bb82-00aa00bdce0b} SID_QIClientSite
DEFINE_GUID(SID_QIClientSite, 0x3050f803, 0x98b5, 0x11cf, 0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

// {996E1EB1-B524-11d1-9120-00A0C98BA67D}
DEFINE_GUID(SRCID_SFindComputer,   0x996e1eb1, 0xb524, 0x11d1, 0x91, 0x20, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x7d);

// {D515F311-B78B-11d1-9123-00A0C98BA67D}
DEFINE_GUID(SRCID_SFindPrinter,    0xd515f311, 0xb78b, 0x11d1, 0x91, 0x23, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x7d);

// {169A0691-8DF9-11d1-A1C4-00C04FD75D13}
DEFINE_GUID(CLSID_ShellSearchExt,       0x169a0691, 0x8df9, 0x11d1, 0xa1, 0xc4, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

// {23d9b0f1-40fc-11d2-bf8c-00c04fb93661}
DEFINE_GUID(IID_IFolderSearches, 0x23d9b0f1, 0x40fc, 0x11d2, 0xbf, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x36, 0x61);

// 830abff0-afd9-11d1-b9f1-00a0c98bc547
DEFINE_GUID(IID_ISearchItems,      0x830abff0L, 0xafd9, 0x11d1, 0xb9, 0xf1, 0x00, 0xa0, 0xc9, 0x8b, 0xc5, 0x47);

// New MSIE FTP UI from msieftp.dll
DEFINE_GUID(CLSID_FtpFolder,            0x63da6ec0, 0x2e98, 0x11cf, 0x8d,0x82,0x44,0x45,0x53,0x54,0,0);

//A48F1A32-A340-11D1-BC6B-00A0C90312E1
DEFINE_GUID(GUID_Restrictions, 0xA48F1A32L, 0xA340, 0x11D1, 0xBC, 0x6B, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

DEFINE_GUID (IID_IHist,                 0x06faeb04L, 0x191c, 0x11d3, 0x95, 0x73, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);
DEFINE_GUID (IID_ICache,                0x06faeb05L, 0x191c, 0x11d3, 0x95, 0x73, 0x00, 0xc0, 0x4f, 0xa3, 0x1a, 0x86);

// {B1E437E0-047A-11D1-B833-00C04FC9B31F}
DEFINE_GUID(IID_IDwnCodePage, 0xb1e437e0, 0x047a, 0x11d1, 0xb8, 0x33, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x1f);

// {AFD971E0-C870-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(IID_IPrivateOleObject, 0xafd971e0, 0xc870, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// {a28a872c-1bce-11d4-a114-00c04f8ef9b9}
DEFINE_GUID(IID_ISearchBandTBHelper, 0xa28a872c, 0x1bce, 0x11d4, 0xa1, 0x14, 0x0, 0xc0, 0x4f, 0x8e, 0xf9, 0xb9);

// used when communicating with the Internet Toolbar. 
DEFINE_GUID(CGID_ShellBrowser, 0x3531F060L, 0x22B3, 0x11D0, 0x96, 0x9E, 0x00, 0xAA, 0x00, 0xB6, 0x01, 0x04 );

/// IAddressList
// {D7E67AA1-AA76-11d0-8282-00AA005B4383}
DEFINE_GUID(IID_IAddressList,           0xd7e67aa1, 0xaa76, 0x11d0, 0x82, 0x82, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

/// IBandProxy
// {208CE801-754B-11d0-80CA-00AA005B4383}
DEFINE_GUID(IID_IBandProxy,             0x208ce801, 0x754b, 0x11d0, 0x80, 0xca, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {1011fa30-69da-11d2-8599-006097df8c11}
DEFINE_GUID(IID_IMRU,                   0x1011fa30, 0x69da, 0x11d2, 0x85, 0x99, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

//0F12079C-C193-11D0-8D49-00C04FC99D61
DEFINE_GUID(CGID_Theater, 0x0F12079CL, 0xC193, 0x11D0, 0x8D, 0x49, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

// {9581015C-D08E-11d0-8D36-00A0C92DBFE8}
DEFINE_GUID(CLSID_BrowserBar,           0x9581015c, 0xd08e, 0x11d0, 0x8d, 0x36, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);

// {2D3DDFC0-09E1-11d1-BC59-00AA006CE2F5}
DEFINE_GUID(CGID_MenuBandHandler, 0x2d3ddfc0, 0x9e1, 0x11d1, 0xbc, 0x59, 0x0, 0xaa, 0x0, 0x6c, 0xe2, 0xf5);

// this defines the deskbar and also id's for each of the toolbands that we implement
//ECD4FC4C-521C-11D0-B792-00A0C90312E1
DEFINE_GUID(CLSID_DeskBar,              0xECD4FC4CL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);
DEFINE_GUID(CLSID_RebarBandSite,        0xECD4FC4DL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);
DEFINE_GUID(CLSID_BandSiteMenu,         0xECD4FC4EL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);
DEFINE_GUID(CLSID_MenuDeskBar,          0xECD4FC4FL, 0x521C, 0x11D0, 0xB7, 0x92, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// {8C7461EF-2B13-11d2-BE35-3078302C2030}
DEFINE_GUID(CLSID_ComCatCacheTask,  0x8c7461ef, 0x2b13, 0x11d2, 0xbe, 0x35, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// {3CCF8A41-5C85-11d0-9796-00AA00B90ADF}
DEFINE_GUID(CLSID_DeskBarApp,           0x3ccf8a41, 0x5c85, 0x11d0, 0x97, 0x96, 0x0, 0xaa, 0x0, 0xb9, 0xa, 0xdf);

// 4AF4A5FA-912A-11D1-B945-00A0C90312E1
DEFINE_GUID(IID_IDockingBarPropertyBagInit, 0x4AF4A5FAL, 0x912A, 0x11D1, 0xB9, 0x45, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// ef8ad2d3-ae36-11d1-b2d2-006097df8c11
DEFINE_GUID(IID_IGlobalFolderSettings, 0xef8ad2d3L, 0xae36, 0x11d1, 0xb2, 0xd2, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

// {37e856d7-3dfd-11d2-bf8b-00c04fb93661}
DEFINE_GUID(IID_IEnumUrlSearch,   0x37e856d7, 0x3dfd, 0x11d2, 0xbf, 0x8b, 0x0, 0xc0, 0x4f, 0xb9, 0x36, 0x61);

DEFINE_GUID(SID_IBandProxy,             0x80243ac1, 0x569, 0x11d1, 0xa7, 0xae, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// {AF4F6511-F982-11d0-8595-00AA004CD6D8}
DEFINE_GUID(IID_IRegTreeOptions, 0xaf4f6511, 0xf982, 0x11d0, 0x85, 0x95, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0xd8);

// {07798131-AF23-11d1-9111-00A0C98BA67D}
DEFINE_GUID(CLSID_WebSearchExt,         0x7798131, 0xaf23, 0x11d1, 0x91, 0x11, 0x0, 0xa0, 0xc9, 0x8b, 0xa6, 0x7d);

// NOTE!  Different from the IID_ITranslateShellChangeNotify in IE4x and IE5.0
// {B4DF2675-BA23-11d2-B5EE-006097C686F6}
DEFINE_GUID(IID_ITranslateShellChangeNotify, 0xb4df2675, 0xba23, 0x11d2, 0xb5, 0xee, 0x0, 0x60, 0x97, 0xc6, 0x86, 0xf6);

//Pidl Filtering for Menu Bands.
// {B16C55D1-0534-11d1-8D3F-00A0C90F2719}
DEFINE_GUID(CGID_FilterObject,0xb16c55d1, 0x534, 0x11d1, 0x8d, 0x3f, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// {B16C55D3-0534-11d1-8D3F-00A0C90F2719}
DEFINE_GUID(SID_SHostProxyFilter,0xb16c55d3, 0x534, 0x11d1, 0x8d, 0x3f, 0x0, 0xa0, 0xc9, 0xf, 0x27, 0x19);

// Also used by SHCreateGlobalCounter to count changes to global folder settings
#define GUID_FolderSettingsChange       CLSID_ShellFldSetExt

// {7376D660-C583-11d0-A3A5-00C04FD706EC}
DEFINE_GUID(CLSID_ImgCtxThumbnailExtractor, 0x7376d660, 0xc583, 0x11d0, 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);

// 438755C2-A8BA-11D1-B96B-00A0C90312E1
DEFINE_GUID(CLSID_BrowseuiPreloader, 0x438755C2L, 0xA8BA, 0x11D1, 0xB9, 0x6B, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// ef8ad2d1-ae36-11d1-b2d2-006097df8c11
DEFINE_GUID(CLSID_GlobalFolderSettings, 0xef8ad2d1L, 0xae36, 0x11d1, 0xb2, 0xd2, 0x00, 0x60, 0x97, 0xdf, 0x8c, 0x11);

// {D1E7AFEA-6A2E-11d0-8C78-00C04FD918B4}
DEFINE_GUID(IID_IBandSiteHelper,        0xd1e7afea, 0x6a2e, 0x11d0, 0x8c, 0x78, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xb4);

//AF604EFE-8897-11D1-B944-00A0C90312E1
DEFINE_GUID(CLSID_CCommonBrowser, 0xAF604EFEL, 0x8897, 0x11D1, 0xB9, 0x44, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// Currently not used -- will be used when dbapp moves to shell32
// 4AF4A5FC-912A-11D1-B945-00A0C90312E1
DEFINE_GUID(CLSID_CDockingBarPropertyBag, 0x4AF4A5FCL, 0x912A, 0x11D1, 0xB9, 0x45, 0x00, 0xA0, 0xC9, 0x03, 0x12, 0xE1);

// {AF4F6510-F982-11d0-8595-00AA004CD6D8}
DEFINE_GUID(CLSID_CRegTreeOptions, 0xaf4f6510, 0xf982, 0x11d0, 0x85, 0x95, 0x0, 0xaa, 0x0, 0x4c, 0xd6, 0xd8);

// {E56829C9-2D59-11d2-BE38-3078302C2030}
DEFINE_GUID(CLSID_ComCatConditionalCacheTask, 0xe56829c9, 0x2d59, 0x11d2, 0xbe, 0x38, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

// URL Shell Execute Hook for IE4
// {AEB6717E-7E19-11d0-97EE-00C04FD91972}
DEFINE_GUID(CLSID_URLExecHook,          0xaeb6717e, 0x7e19, 0x11d0, 0x97, 0xee, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);



//
// From shdguid.h
//

// 3DC7A020-0ACD-11CF-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CURLFolder,       0x3DC7A020L, 0x0ACD, 0x11CF, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

//A5E46E3A-8849-11D1-9D8C-00C04FC99D61
DEFINE_GUID(CLSID_CBaseBrowser, 0xA5E46E3AL, 0x8849, 0x11D1, 0x9D, 0x8C, 0x00, 0xC0, 0x4F, 0xC9, 0x9D, 0x61);

// IID_IShellService is used in shdocvw and shell32.  Put it here so shdocvw builds.
DEFINE_GUID(IID_IShellService, 0x5836FB00L, 0x8187, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// f62d9369-75ef-4578-8856-232802c76468
DEFINE_GUID(IID_ITridentService2, 0xf62d9369, 0x75ef, 0x4578, 0x88, 0x56, 0x23, 0x28, 0x02, 0xc7, 0x64, 0x68);

// 3050f801-98b5-11cf-bb82-00aa00bdce0b
DEFINE_GUID(IID_ITridentService, 0x3050f801, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0, 0xaa, 0x00, 0xbd, 0xce, 0x0b);

DEFINE_GUID(IID_IBrowserService, 0x02ba3b52, 0x0547, 0x11d1, 0xb8, 0x33, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x1f);

// (old: E4A141D2-70C7-11D1-8DD7-00C04FC99D61 until 980512)
// (old: C3F16B61-E91A-11d1-BCD9-00A0C92DBFE8 until 980903)
// {68BD21CC-438B-11d2-A560-00A0C92DBFE8}
DEFINE_GUID(IID_IBrowserService2, 0x68bd21cc, 0x438b, 0x11d2, 0xa5, 0x60, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);
DEFINE_GUID(IID_IBrowserService3, 0x27D7CE21L, 0x762D, 0x48F3, 0x86, 0xF3, 0x40, 0xE2, 0xFD, 0x37, 0x49, 0xC4);

// C2EA74E0-0ED2-11CF-A9BB-00AA004AE837
DEFINE_GUID(CLSID_CDocObjectView,   0xC2EA74E0L, 0x0ED2, 0x11CF, 0xA9, 0xBB, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// 3050f804-98b5-11cf-bb82-00aa00bdce0b
DEFINE_GUID(IID_IWebBrowserPriv,  0x3050f804, 0x98b5, 0x11cf, 0xbb, 0x82, 0x0,  0xaa, 0x00, 0xbd, 0xce, 0x0b);

// Remove this after Beta 2.
DEFINE_GUID(CLSID_QuickLinksOld, 0x7BA4C741L, 0x9E81, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// 01E04581-4EEE-11d0-BFE9-00AA005B4383
DEFINE_GUID(CLSID_AddressBand, 0x1e04581, 0x4eee, 0x11d0, 0xbf, 0xe9, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {30D02401-6A81-11d0-8274-00C04FD5AE38}
DEFINE_GUID(CLSID_SearchBand, 0x30d02401, 0x6a81, 0x11d0, 0x82, 0x74, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38);
#define CGID_SearchBand CLSID_SearchBand

// {32683183-48a0-441b-a342-7c2a440a9478}
DEFINE_GUID(CLSID_MediaBand, 0x32683183, 0x48a0, 0x441b, 0xa3, 0x42, 0x7c, 0x2a, 0x44, 0x0a, 0x94, 0x78);

// {B6E3D794-F864-42a4-8F7B-1779A4DEAC83}
DEFINE_GUID(SID_SMediaBar, 0xb6e3d794, 0xf864, 0x42a4, 0x8f, 0x7b, 0x17, 0x79, 0xa4, 0xde, 0xac, 0x83);

// 5E6AB780-7743-11CF-A12B-00AA004AE837
DEFINE_GUID(CLSID_InternetToolbar, 0x5E6AB780L, 0x7743, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

/// {AFA7AD8A-51A7-11d2-83A1-00C04FD918D0}
DEFINE_GUID(IID_IOrderList2,    0xafa7ad8a, 0x51a7, 0x11d2, 0x83, 0xa1, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {F98D8294-2BBC-11d2-8DBD-0000F87A556C}
DEFINE_GUID(IID_IShellFolderSearchableCallback, 0xf98d8294, 0x2bbc, 0x11d2, 0x8d, 0xbd, 0x0, 0x0, 0xf8, 0x7a, 0x55, 0x6c);

// {4E1AE66C-204B-11d2-8DB3-0000F87A556C}
DEFINE_GUID(IID_IShellFolderSearchable, 0x4e1ae66c, 0x204b, 0x11d2, 0x8d, 0xb3, 0x0, 0x0, 0xf8, 0x7a, 0x55, 0x6c);

// {49422C1E-1C03-11d2-8DAB-0000F87A556C}
DEFINE_GUID(IID_IShellFolderViewType, 0x49422c1e, 0x1c03, 0x11d2, 0x8d, 0xab, 0x0, 0x0, 0xf8, 0x7a, 0x55, 0x6c);

// {94FD6891-92CD-11d1-A1C6-00C04FD75D13}
DEFINE_GUID(SRCID_SWebSearch,      0x94fd6891, 0x92cd, 0x11d1, 0xa1, 0xc6, 0x0, 0xc0, 0x4f, 0xd7, 0x5d, 0x13);

#define SRCID_SFileSearch          CLSID_ShellSearchExt

// {B8A9C381-19DF-11d1-9193-006097DF5BD4}
DEFINE_GUID(IID_IIsWebBrowserSB, 0xb8a9c381, 0x19df, 0x11d1, 0x91, 0x93, 0x0, 0x60, 0x97, 0xdf, 0x5b, 0xd4);

// 062E1261-A60E-11d0-82C2-00C04FD5AE38
DEFINE_GUID(IID_IHistSFPrivate, 0x62e1261, 0xa60e, 0x11d0, 0x82, 0xc2, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38);

// 22BF0C20-6DA7-11D0-B373-00A0C9034938
DEFINE_GUID(CLSID_BrandBand, 0x22BF0C20, 0x6DA7, 0x11D0, 0xB3, 0x73, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x38);

DEFINE_GUID(CLSID_BrowserBand, 0x7BA4C742L, 0x9E81, 0x11CF, 0x99, 0xD3, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);

// {4D5C8C2A-D075-11d0-B416-00C04FB90376}
DEFINE_GUID(CLSID_CommBand, 0x4d5c8c2a, 0xd075, 0x11d0, 0xb4, 0x16, 0x0, 0xc0, 0x4f, 0xb9, 0x3, 0x76);

// {35C042C1-75BE-11d0-80D2-00AA005B4383}
DEFINE_GUID(CLSID_MRUList, 0x35c042c1, 0x75be, 0x11d0, 0x80, 0xd2, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {91EA3F8C-C99B-11d0-9815-00C04FD91972}
DEFINE_GUID(IID_IAugmentedShellFolder,      0x91ea3f8c, 0xc99b, 0x11d0, 0x98, 0x15, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);
// {8DB3B3F4-6CFE-11d1-8AE9-00C04FD918D0}
DEFINE_GUID(IID_IAugmentedShellFolder2,     0x8db3b3f4, 0x6cfe, 0x11d1, 0x8a, 0xe9, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);

// {F61FFEC1-754F-11d0-80CA-00AA005B4383}
DEFINE_GUID(CLSID_BandProxy, 0xf61ffec1, 0x754f, 0x11d0, 0x80, 0xca, 0x0, 0xaa, 0x0, 0x5b, 0x43, 0x83);

// {91EA3F8B-C99B-11d0-9815-00C04FD91972}
DEFINE_GUID(CLSID_AugmentedShellFolder,     0x91ea3f8b, 0xc99b, 0x11d0, 0x98, 0x15, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {6413BA2C-B461-11d1-A18A-080036B11A03}
DEFINE_GUID(CLSID_AugmentedShellFolder2,    0x6413ba2c, 0xb461, 0x11d1, 0xa1, 0x8a, 0x8, 0x0, 0x36, 0xb1, 0x1a, 0x3);





#endif // _IEGUIDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\dssec.h ===
#ifndef _DSSEC_H_
#define _DSSEC_H_

#include <aclui.h>  // LPSECURITYINFO


//+---------------------------------------------------------------------------
//
//  Function:   PFNREADOBJECTSECURITY
//
//  Synopsis:   Reads the security descriptor of a DS object
//
//  Arguments:  [IN  LPCWSTR]               --  ADS path of DS Object
//              [IN  SECURITY_INFORMATION]  --  Which SD parts to read
//              [OUT PSECURITY_DESCRIPTOR*] --  Return SD here. Caller frees with LocalFree
//              [IN  LPARAM]                --  Context param
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
//
//  Function:   PFNWRITEOBJECTSECURITY
//
//  Synopsis:   Writes a security descriptor to a DS object
//
//  Arguments:  [IN  LPCWSTR]               --  ADS path of DS Object
//              [IN  SECURITY_INFORMATION]  --  Which SD parts to write
//              [OUT PSECURITY_DESCRIPTOR]  --  Security descriptor to write
//              [IN  LPARAM]                --  Context param
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
typedef HRESULT (WINAPI *PFNREADOBJECTSECURITY)(LPCWSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR*, LPARAM);
typedef HRESULT (WINAPI *PFNWRITEOBJECTSECURITY)(LPCWSTR, SECURITY_INFORMATION, PSECURITY_DESCRIPTOR, LPARAM);

//+---------------------------------------------------------------------------
//
//  Function:   DSCreateISecurityInfoObject
//
//  Synopsis:   Instantiates an ISecurityInfo interface for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT ppSI]              --  Interface pointer returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateISecurityInfoObject(LPCWSTR pwszObjectPath,
                            LPCWSTR pwszObjectClass,
                            DWORD dwFlags,
                            LPSECURITYINFO *ppSI,
                            PFNREADOBJECTSECURITY pfnReadSD,
                            PFNWRITEOBJECTSECURITY pfnWriteSD,
                            LPARAM lpContext);

// Flags for DSCreateISecurityInfoObject
#define DSSI_READ_ONLY          0x00000001
#define DSSI_NO_ACCESS_CHECK    0x00000002
#define DSSI_NO_EDIT_SACL       0x00000004
#define DSSI_NO_EDIT_OWNER      0x00000008
#define DSSI_IS_ROOT            0x00000010
#define DSSI_NO_FILTER          0x00000020
#define DSSI_NO_READONLY_MESSAGE          0x00000040

//
// Same as above, with optional server, user & password arguments.
// If use & password are not provided, ADSI defaults are used.
// If the server is not provided, it is obtained from the object
// path or DsGetDcName.
//
STDAPI
DSCreateISecurityInfoObjectEx(LPCWSTR pwszObjectPath,
                              LPCWSTR pwszObjectClass,
                              LPCWSTR pwszServer,
                              LPCWSTR pwszUserName,
                              LPCWSTR pwszPassword,
                              DWORD   dwFlags,
                              LPSECURITYINFO *ppSI,
                              PFNREADOBJECTSECURITY  pfnReadSD,
                              PFNWRITEOBJECTSECURITY pfnWriteSD,
                              LPARAM lpContext);


//+---------------------------------------------------------------------------
//
//  Function:   DSCreateSecurityPage
//
//  Synopsis:   Creates a Security property page for a DS object
//
//  Arguments:  [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [OUT phPage]            --  HPROPSHEETPAGE returned here
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSCreateSecurityPage(LPCWSTR pwszObjectPath,
                     LPCWSTR pwszObjectClass,
                     DWORD dwFlags,
                     HPROPSHEETPAGE *phPage,
                     PFNREADOBJECTSECURITY pfnReadSD,
                     PFNWRITEOBJECTSECURITY pfnWriteSD,
                     LPARAM lpContext);

//+---------------------------------------------------------------------------
//
//  Function:   DSEditSecurity
//
//  Synopsis:   Displays a modal dialog for editing security on a DS object
//
//  Arguments:  [IN  hwndOwner]         --  Dialog owner window
//              [IN  pwszObjectPath]    --  Full ADS path of DS object
//              [IN  pwszObjectClass]   --  Class of the object (optional)
//              [IN  dwFlags]           --  Combination of DSSI_* flags
//              [IN  pwszCaption]       --  Optional dialog caption
//              [IN  pfnReadSD]         --  Optional function for reading SD
//              [IN  pfnWriteSD]        --  Optional function for writing SD
//              [IN  LPARAM]            --  Passed to pfnReadSD/pfnWriteSD
//
//  Return:     HRESULT
//
//----------------------------------------------------------------------------
STDAPI
DSEditSecurity(HWND hwndOwner,
               LPCWSTR pwszObjectPath,
               LPCWSTR pwszObjectClass,
               DWORD dwFlags,
               LPCWSTR pwszCaption,
               PFNREADOBJECTSECURITY pfnReadSD,
               PFNWRITEOBJECTSECURITY pfnWriteSD,
               LPARAM lpContext);


typedef HRESULT (WINAPI *PFNDSCREATEISECINFO)(LPCWSTR,
                                              LPCWSTR,
                                              DWORD,
                                              LPSECURITYINFO*,
                                              PFNREADOBJECTSECURITY,
                                              PFNWRITEOBJECTSECURITY,
                                              LPARAM);

typedef HRESULT (WINAPI *PFNDSCREATEISECINFOEX)(LPCWSTR,
                                                LPCWSTR,
                                                LPCWSTR,
                                                LPCWSTR,
                                                LPCWSTR,
                                                DWORD,
                                                LPSECURITYINFO*,
                                                PFNREADOBJECTSECURITY,
                                                PFNWRITEOBJECTSECURITY,
                                                LPARAM);

typedef HRESULT (WINAPI *PFNDSCREATESECPAGE)(LPCWSTR,
                                             LPCWSTR,
                                             DWORD,
                                             HPROPSHEETPAGE*,
                                             PFNREADOBJECTSECURITY,
                                             PFNWRITEOBJECTSECURITY,
                                             LPARAM);

typedef HRESULT (WINAPI *PFNDSEDITSECURITY)(HWND,
                                            LPCWSTR,
                                            LPCWSTR,
                                            DWORD,
                                            LPCWSTR,
                                            PFNREADOBJECTSECURITY,
                                            PFNWRITEOBJECTSECURITY,
                                            LPARAM);

#endif  /* _DSSEC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\help.h ===
// This file contains help context id's in the master windows.h file.

// Id's over 61440 are reserved and will ALWAYS use windows.hlp when
// used for context-sensitive help.

// Id's from 1-999 are reserved for Object help

// REVIEW: has to be 28440 until new help compiler is available

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control

#define IDH_BACK    0x3023
#define IDH_NEXT    0x3024
#define IDH_FINISH  0x3025

#define IDH_NO_HELP                     28440
#define IDH_MISSING_CONTEXT             28441 // Control doesn't have matching help context
#define IDH_GENERIC_HELP_BUTTON         28442 // Property sheet help button
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445
#define IDH_COMM_APPLYNOW               28447
#define IDH_FONT_STYLE                  28448
#define IDH_FONT_SIZE                   28449
#define IDH_FONT_SAMPLE                 28450
#define IDH_FONT_EFFECTS                28451
#define IDH_FONT_FONT                   28452
#define IDH_PRINT_SETUP_AVAIL           28453
#define IDH_PRINT_SETUP_OPTIONS         28454
#define IDH_PRINT_SETUP_DETAILS         28455
#define IDH_OPEN_LOCATION               28456
#define IDH_OPEN_FILES                  28457
#define IDH_OPEN_READONLY               28459
#define IDH_OPEN_FILETYPE               28460
#define IDH_OPEN_PATH                   28461
#define IDH_OPEN_FILENAME               28462
#define IDH_FIND_SEARCHTEXT             28463
#define IDH_FIND_NEXT_BUTTON            28464
#define IDH_FIND_WHOLE                  28467
#define IDH_FIND_CASE                   28468
#define IDH_REPLACE_REPLACE             28469
#define IDH_REPLACE_REPLACE_ALL         28470
#define IDH_REPLACE_REPLACEWITH         28471
#define IDH_PRINT_PRINTER               28472
#define IDH_PRINT_PRINTER_SETUP         28473
#define IDH_PRINT_COPIES                28474
#define IDH_PRINT_COLLATE               28475
#define IDH_PRINT_TO_FILE               28476
#define IDH_PRINT_QUALITY               28477
#define IDH_PRINT_RANGE                 28478
#define IDH_PAGE_SAMPLE                 28485
#define IDH_PAGE_ORIENTATION            28486
#define IDH_PAGE_PAPER_SIZE             28487
#define IDH_PAGE_PAPER_SOURCE           28488
#define IDH_PAGE_MARGINS                28489
#define IDH_OPEN_DRIVES                 28490
#define IDH_COMM_DRIVE                  28491
#define IDH_COMM_PASSWDBUTT             28492
#define IDH_COMM_OLDPASSWD              28493
#define IDH_BROWSE                      28496
#define IDH_COLOR_CUSTOM                28497
#define IDH_COLOR_SAMPLE_COLOR          28498
#define IDH_COLOR_HUE                   28500
#define IDH_COLOR_SAT                   28501
#define IDH_COLOR_RED                   28502
#define IDH_COLOR_GREEN                 28503
#define IDH_COLOR_BLUE                  28504
#define IDH_COLOR_LUM                   28505
#define IDH_COLOR_ADD                   28506
#define IDH_COLOR_COLOR_SOLID           28507
#define IDH_COLOR_DEFINE                28508
#define IDH_QUICKINFO                   28509
#define IDH_NO_CROSSREF                 28510
#define IDH_CHARMAP_INSERT              28511
#define IDH_COMM_USER_NAME              28512
#define IDH_COMM_USER_SERVERNAME        28513
#define IDH_COMM_USER_SELECT_FROM       28514
#define IDH_COMM_USER_SELECTED          28515
#define IDH_PRINT32_RANGE               28516
#define IDH_PRINT_PROPERTIES            28517
#define IDH_PRINT_FILENAME              28518
#define IDH_PRINT_CHOOSE_PRINTER        28519
#define IDH_FIND_DIRECTION              28520
#define IDH_FONT_COLOR                  28521
#define IDH_PRINT_SETUP_PAPER           28522
#define IDH_PRINT_SETUP_ORIENT          28523
#define IDH_OPEN_BUTTON                 28529
#define IDH_SAVE_BUTTON                 28531
#define IDH_COLOR_BASIC                 28532
#define IDH_COLOR_CUSTOM_CUSTOM         28533
#define IDH_COLOR_SAMPLE_SCROLL         28534
#define IDH_FONT_SCRIPT                 28535
#define IDH_KERNEL_TASK_LIST            28536
#define IDH_KERNEL_END_TASK             28537
#define IDH_KERNEL_SHUTDOWN             28538
#define IDH_QVIEW_DISPLAY               28539
#define IDH_CHARMAP_COPY                28540
#define IDH_CHARMAP_FONT                28541
#define IDH_CHARMAP_CHARACTERS          28542
#define IDH_CHARMAP_SELECTED_CHARS      28543
#define IDH_CHARMAP_SELECT_BUTTON       28544
#define IDH_CHARMAP_HELP_BUTTON         28545
#define IDH_BOLD                        28546
#define IDH_ITALIC                      28547
#define IDH_COMM_GROUPBOX               28548
#define IDH_OPEN_FILES32                28549
#define IDH_SAVE_FILETYPE               28550
#define IDH_SYSTEM_CFG_OLDNAME          28551
#define IDH_DIAL_WHAT_WRONG             28552
#define IDH_COMCTL_RESET                28553
#define IDH_COMCTL_MOVEUP               28554
#define IDH_COMCTL_MOVEDOWN             28555
#define IDH_COMCTL_BUTTON_LIST          28556
#define IDH_COMCTL_ADD                  28557
#define IDH_COMCTL_REMOVE               28558
#define IDH_COMCTL_AVAIL_BUTTONS        28559
#define IDH_COMCTL_CLOSE                28560
#define IDH_PAGE_PRINTER                28561
#define IDH_DCC_WHAT_WRONG              28562
#define IDH_FILEVIEWER_PREVIEW          28563
#define IDH_PRINT_NETWORK               28564
#define IDH_PRINT_SETUP_DUPLEX          28565

#define IDH_OLEPROP_SUMMARY             28569
#define IDH_OLEPROP_STATISTICS          28570
#define IDH_CONFIGURE_LPT_PORT          28571
#define IDH_ADD_LOCAL_PORT              28572
#define IDH_PRINT_PORT_NAME             28573
#define IDH_PRINT_OUTPUT_FILE           28574
#define IDH_DISKCOPY_START              28575
#define IDH_DISKCOPY_FROM               28576
#define IDH_DISKCOPY_TO                 28577

#define IDH_PRINT_FIND_PRINTER          29010
#define IDH_PRINT_PREFERENCES           29011
#define IDH_PRINT_PRINTER_FOLDER        29015

#define IDH_OPEN_SHORTCUT_BAR           29500
#define IDH_OPEN_BACK_BUTTON            29501
#define IDH_PRINT_BTN                   29510

// ID value for Win 3.1 user transition piece: jump from First experience screen
#define WIN31_TRANSITION_PIECE          30000

#define IDH_FCAB_OPENWITH_LOOKONWEB     3001            // (for the link to the Web on the Open With dialog.)
#define IDH_CANNOTOPEN_USEWEB           3002            // (For the first radio button on the Cannot open this file dialog)
#define IDH_CANNOTOPEN_SELECTLIST       3003            // (For the second radio button on the Cannot open this file dialog)


// ID values 2100-2199 are reserved for Disk Compression.
// See dos\dos86\dblspace\utility\comphelp.h

// ID values 2200-2299 are reserved for Find File. See findhlp.h.

// ID values 2400-2499 are reserved for MultiMedia control panel. See medhelp.h

// ID values 2500-2699 are reserved for Print Trouble Shooter

// ID values 2700-2799 are reserved for Network control panel. See nethelp.h

// ID values 2800-2899 are reserved for Online Registration.

// ID values 2900-2999 are reserved for Clipbook and Chat.

#define IDH_COMM_NEWPASSWD              3018    // See pwdids.h
#define IDH_COMM_NEWPASSCONF            3019    // See pwdids.h

// Briefcase ids

#define IDH_BFC_UPDATE_SCREEN           3100
#define IDH_BFC_UPDATE_BUTTON           3101
#define IDH_BFC_PROP_FILEICON           3102
#define IDH_BFC_PROP_SPLIT_BUTTON       3103
#define IDH_BFC_PROP_FINDORIG_BUTTON    3104
#define IDH_BFC_FILTER_TYPE             3105
#define IDH_BFC_FILTER_INCLUDE          3106

// ID values 3300-3499 are reserved for international. See intlhlp.h

// ID values for the Keyboard property sheet

#define IDH_DLGKEY_REPDEL               4000
#define IDH_DLGKEY_REPSPEED             4001
#define IDH_DLGKEY_REPTEST              4002
#define IDH_DLGKEY_TYPE                 4008
#define IDH_DLGKEY_CHANGE               4010
#define IDH_DLGKEY_CURSBLNK             4011
#define IDH_DLGKEY_CURSOR_GRAPHIC       4012

#define IDH_KEYB_INPUT_LIST             4028
#define IDH_KEYB_INPUT_ADD              4029
#define IDH_KEYB_INPUT_PROP             4030
#define IDH_KEYB_INPUT_DEL              4031
#define IDH_KEYB_INPUT_DEFAULT          4032
#define IDH_KEYB_CAPSLOCK_LAYOUT        4033
#define IDH_KEYB_INPUT_LANG             4034
#define IDH_KEYB_INPUT_INDICATOR        4035
#define IDH_KEYB_INPUT_ONSCRN_KEYB      4036
#define IDH_KEYB_INPUT_PROP_LANG        4039
#define IDH_KEYB_INPUT_PROP_KEYLAY      4042
#define IDH_KEYB_INPUT_DEF_LANG         4043
#define IDH_KEYB_INPUT_SHORTCUT         4044
#define IDH_KEYB_INDICATOR_ON_TASKBAR   4045
#define IDH_KEYB_IME_SETTINGS           4046
#define IDH_KEYB_HOTKEY_LIST            4047
#define IDH_KEYB_CHANGE_HOTKEY          4048
#define IDH_KEYB_CHANGE_KEY             4049

// ID values for Desktop Property sheet

// Settings Page
#define IDH_SETTINGS_DISPLAYDESK        4064    //Monitor icon display area
#define IDH_SETTINGS_DISPLAYLIST        4065    //Monitor dropdown
#define IDH_SETTINGS_COLORBOX           4066    //Colors dropdown   
#define IDH_SETTINGS_SCREENSIZE         4067    //Screen Area dropdown      
#define IDH_SETTINGS_DISPLAYUSEME       4068    //Use this monitor chkbx
#define IDH_SETTINGS_DISPLAYPROPERTIES  4069    //Advanced button

// General Page
#define IDH_GENERAL_FONTSIZEGRP         4080    //Font size dropdown
#define IDH_GENERAL_DYNA                4081    //Compatibility option group
#define IDH_GENERAL_NODYNA              4082    //Restart the computer option
#define IDH_GENERAL_YESDYNA             4083    //Apply the changes option  
#define IDH_GENERAL_SHUTUP              4084    //Always prompt before option

// Background Page (Now the "Desktop" Page)
#define IDH_DSKTPBACKGROUND_MONITOR     4100
#define IDH_DSKTPBACKGROUND_PATTLIST    4102
#define IDH_DSKTPBACKGROUND_WALLLIST    4104
#define IDH_DSKTPBACKGROUND_BROWSE      4105
#define IDH_DSKTPBACKGROUND_TILE        4106
#define IDH_DSKTPBACKGROUND_CENTER      4107
#define IDH_DSKTPBACKGROUND_DISPLAY     4108
#define IDH_DSKTPBACKGROUND_EDITPAT     4109

// Screen Saver Page
#define IDH_DSKTPSCRSAVER_LISTBX        4111
#define IDH_DSKTPSCRSAVER_WAIT          4112
#define IDH_DSKTPSCRSAVER_TEST          4113
#define IDH_DSKTPSCRSAVER_SETTINGS      4114
#define IDH_DSKTPSCRSAVER_MONITOR       4115
#define IDH_SCRSAVER_GRAPHIC            4116
#define IDH_SCRSAVER_LOWPOWSTANDBY      4117
#define IDH_SCRSAVER_SHUTOFFPOW         4118

// Appearance Page

#define IDH_APPEAR_SCHEME               4120
#define IDH_APPEAR_SAVEAS               4121
#define IDH_APPEAR_DELETE               4122
#define IDH_APPEAR_GRAPHIC              4123
#define IDH_APPEAR_ITEMSIZE             4124
#define IDH_APPEAR_FONTBOLD             4125
#define IDH_APPEAR_FONTSIZE             4126
#define IDH_APPEAR_FONTCOLOR            4127
#define IDH_APPEAR_FONTITALIC           4128
#define IDH_APPEAR_BACKGRNDCOLOR        4129
#define IDH_APPEAR_ITEM                 4130
#define IDH_APPEAR_FONT                 4131

// Monitor Settings Page




#define IDH_DSKTPMONITOR_CHANGE_DISPLAY 4134
#define IDH_DSKTPMONITOR_COLOR          4135
#define IDH_DSKTPMONITOR_AREA           4136
#define IDH_DSKTPMONITOR_REFRESH        4137
#define IDH_DSKTPMONITOR_LIST_MODES     4138
#define IDH_DSKTPMONITOR_ENERGY         4139
#define IDH_DSKTPMONITOR_MONITOR        4140
#define IDH_DSKTPMONITOR_TEST           4141
#define IDH_DSKTPMONITOR_ADTYPE         4143
#define IDH_DSKTPMONITOR_CHANGE1        4144
#define IDH_DSKTPMONITOR_CHANGE2        4145
#define IDH_DSKTPMONITOR_MONTYPE        4146
#define IDH_DSKTPMONITOR_CUSTOM         4148
#define IDH_DSKTPMONITOR_FONTSIZE       4149
#define IDH_DSKTPMONITOR_AD_FACTS       4150
#define IDH_DSKTPMONITOR_DRIVER         4151
#define IDH_DSKTPMONITOR_DETECT         4152


#define IDH_SAVESCHEME_EDITFIELD        4170
#define IDH_CUSTOMFONTS_FONTSCALE       4171
#define IDH_CUSTOMFONTS_RULER           4172
#define IDH_CUSTOMFONTS_SAMPLE          4173

#define IDH_PATTERN_EDIT_NAME           4174
#define IDH_PATTERN_EDIT_SAMPLE         4175
#define IDH_PATTERN_EDIT_PIXEL_SCREEN   4176
#define IDH_PATTERN_EDIT_EXIT           4177
#define IDH_PATTERN_EDIT_ADD            4178
#define IDH_PATTERN_EDIT_CHANGE         4179
#define IDH_PATTERN_EDIT_REMOVE         4180

// ID values for Defrag

#define IDH_DEFRAG_START                        4200
#define IDH_DEFRAG_STOP                         4201
#define IDH_DEFRAG_PAUSE                        4202
#define IDH_DEFRAG_SHOWDETAILS                  4203
#define IDH_DEFRAG_HIDEDETAILS                  4204
#define IDH_DEFRAG_LEGEND                       4205
#define IDH_DEFRAG_SPARKLESCRN                  4206
#define IDH_DEFRAG_DEFRAGNOW_ANYWY              4207
#define IDH_DEFRAG_SELECTDRIVE                  4208
#define IDH_DEFRAG_ADVANCED                     4209
#define IDH_DEFRAG_EXIT                         4210
#define IDH_DEFRAG_DRIVELIST                    4211
#define IDH_DEFRAG_RESUME                       4212
#define IDH_DEFRAG_FULL                         4213
#define IDH_DEFRAG_FILESONLY                    4214
#define IDH_DEFRAG_FRSPCONLY                    4215
#define IDH_DEFRAG_USEONCE                      4218
#define IDH_DEFRAG_USEALWAYS                    4219
#define IDH_DEFRAG_GASGAUGE                     4220
#define IDH_DEFRAG_CHECK_DRIVE_FOR_ERRORS       4221

// RNA id values

#define IDH_RNA_CONNECT_NAME            4250
#define IDH_RNA_CONNECT_USER            4251
#define IDH_RNA_CONNECT_PASSWORD        4252
#define IDH_RNA_CONNECT_SAVEPW          4253
#define IDH_RNA_CONNECT_FROM            4254
#define IDH_RNA_OUT_PHONE_NUMBER        4255
#define IDH_RNA_OUT_DIALASST            4256
#define IDH_RNA_OUT_COMPLETE_PHONE      4257
#define IDH_RNA_OUT_CONNECT_BUTTON      4258
#define IDH_RNA_CHOOSE_MODEM            4273
#define IDH_RNA_CONFIG_MODEM            4274
#define IDH_RNA_MODEM_SERVER            4275
#define IDH_RNA_SERVERS                 4276
#define IDH_RNA_CONNECTION_LIST         4277
#define IDH_RNA_SERVER_COMPRESS         4278
#define IDH_RNA_SERVER_ENCRYPT          4279
#define IDH_RNA_SERVER_NETLOGON         4280
#define IDH_RNA_SERVER_PROTOCOL         4281
#define IDH_RNA_SERVER_TCPIPSET         4282
#define IDH_RNA_TCPIP_ASSIGNED_IP       4283
#define IDH_RNA_TCPIP_SPECIFY_IP        4284
#define IDH_RNA_TCPIP_ASSIGNED_DNS      4285
#define IDH_RNA_TCPIP_SPECIFY_DNS       4286
#define IDH_RNA_TCPIP_COMPRESS          4287
#define IDH_RNA_TCPIP_GATEWAY           4288
#define IDH_RNA_SETTINGS_REDIAL         4290
#define IDH_RNA_SETTINGS_TIMES          4291
#define IDH_RNA_SETTINGS_MINSEC         4292
#define IDH_RNA_SETTINGS_PROMPT         4293

// ID values for printing property sheets

#define IDH_PRTPROPS_TYPE_LOCATION              4501
#define IDH_PRTPROPS_COMMENT                    4502
#define IDH_PRTPROPS_NAME_STATIC                4505
#define IDH_PRTPROPS_PORT                       4506
#define IDH_PRTPROPS_DRIVER                     4507
#define IDH_PRTPROPS_NEW_PORT                   4508
#define IDH_PRTPROPS_NEW_DRIVER                 4509
#define IDH_PRTPROPS_SEPARATOR                  4510
#define IDH_PRTPROPS_ICON                       4512
#define IDH_PRTPROPS_SPOOL_SETTINGS             4513
#define IDH_PRTPROPS_PORT_SETTINGS              4514
#define IDH_PRTPROPS_SETUP                      4515
#define IDH_PRTPROPS_SEPARATOR_BROWSE           4516
#define IDH_PRTPROPS_TIMEOUT_NOTSELECTED        4517
#define IDH_PRTPROPS_TIMEOUT_TRANSRETRY         4518
#define IDH_PRTPROPS_TEST_PAGE                  4519
#define IDH_SPOOLSETTINGS_SPOOL                 4520
#define IDH_SPOOLSETTINGS_NOSPOOL               4521
#define IDH_SPOOLSETTINGS_PRINT_FASTER          4522
#define IDH_SPOOLSETTINGS_LESS_SPACE            4523
#define IDH_SPOOLSETTINGS_DATA_FORMAT           4524
#define IDH_SPOOLSETTINGS_RESTORE               4525
#define IDH_PRTPROPS_DEL_PORT                   4528
#define IDH_ADDPORT_NETWORK                     4529
#define IDH_ADDPORT_PORTMON                     4530
#define IDH_ADDPORT_NETPATH                     4531
#define IDH_ADDPORT_BROWSE                      4532
#define IDH_ADDPORT_LB                          4533
#define IDH_DELPORT_LB                          4534
#define IDH_PRTPROPS_MAP_PRN_PORT               4535
#define IDH_PRTPROPS_UNMAP_PRN_PORT             4536
#define IDH_SPOOLSETTINGS_ENABLE_BIDI           4537
#define IDH_SPOOLSETTINGS_DISABLE_BIDI          4538

// ID values for System property sheets

#define IDH_SYSTEM_SYSTEM               4600
#define IDH_SYSTEM_RESOURCES            4602
#define IDH_SYSTEM_OWNER                4603
#define IDH_SYSTEM_PRO_COPY             4624
#define IDH_SYSTEM_PRO_RENAME           4625
#define IDH_SYSTEM_PRO_DELETE           4626
#define IDH_SYSTEM_PRO_LIST             4627
#define IDH_SYSTEM_LOGO                 4628
#define IDH_SYSTEM_CFG_EDIT             4629
#define IDH_SYSTEM_PROCESSOR            4630
#define IDH_SYSTEM_VIEW_RESOURCETYPE    4631
#define IDH_SYSTEM_PAGING               4632
#define IDH_SYSTEM_ADVANCED             4633
#define IDH_SYSTEM_VIRTMEM_ADJUST       4634
#define IDH_SYSTEM_VIRTMEM_DISABLE      4635

#define IDH_SYSTEM_RESERVE_PICKONE      4636

#define IDH_SYSTEM_RESERVE_MODIFY       4639
#define IDH_SYSTEM_RESERVE_ADD          4640
#define IDH_SYSTEM_RESERVE_REMOVE       4641
#define IDH_SYSTEM_CLASSLIST            4642
#define IDH_SYS_PERF_GRAPHICS           4643
#define IDH_SYS_PERF_GRAPHICS_SLIDER    4644

#define IDH_SYSTEM_FILESYSTEM           4661
#define IDH_SYSTEM_DISK                 4662
#define IDH_SYSTEM_CDROM                4663
#define IDH_SYSTEM_CACHE                4664
#define IDH_SYSTEM_BALANCE              4665
#define IDH_SYSTEM_TROUBLESHOOT         4666
#define IDH_SYSTEM_FSCHANGE             4667
#define IDH_DEVMGR_REMOVEONE            4671
#define IDH_DEVMGR_REMOVEALL            4672
#define IDH_SYSTEM_VIEW_RESRES          4673
#define IDH_DEVMGR_CLASS                4674
#define IDH_DEVMGR_ENABLE_HEAD          4675
#define IDH_DEVMGR_PRINT_SELECT         4676
#define IDH_DEVMGR_PRINT_FILE           4677
#define IDH_DEVMGR_SCSI_INFO            4678
#define IDH_DEVMGR_DISKOPTIONS          4679
#define IDH_DEVMGR_DISCONNECT           4680
#define IDH_DEVMGR_SYNC                 4681
#define IDH_DEVMGR_AUTOINSERT           4682
#define IDH_DEVMGR_REMOVABLE            4683
#define IDH_DEVMGR_INT13                4684
#define IDH_DEVMGR_DRIVE_LETTER         4685
#define IDH_DEVMGR_DRIVE_RESERVED       4686
#define IDH_NHF_HELP                4687
#define IDH_NHF_WINDOWS             4688
#define IDH_NHF_DISK                4689
#define IDH_NHF_NODRIVER            4690
#define IDH_NHF_SIMILAR             4691
#define IDH_DMA_MEMORY              4692
#define IDH_DMA_ADDRESS             4693
#define IDH_DMA_DEFAULT             4694
#define IDH_SCSIPROP_SETTINGS       4695
#define IDH_PCI_ENUMTYPE            4697
#define IDH_PCI_IRQ_STEERING        4698
#define IDH_PCI_SETDEFAULTS         4699

// ID's for File properties

#define IDH_FPROP_VER_INFO                      4700
#define IDH_FPROP_GEN_COMPRESSED                4701
#define IDH_FPROP_GEN_COMPRESSED_SIZE           4702
#define IDH_FPROP_SECURITY_PERMISSIONS          4703
#define IDH_FPROP_SECURITY_AUDITING             4704
#define IDH_FPROP_SECURITY_OWNERSHIP            4705
#define IDH_FPROP_GEN_NAME                      4708
#define IDH_FPROP_GEN_TYPE                      4709
#define IDH_FPROP_GEN_SIZE                      4710
#define IDH_FPROP_GEN_LOCATION                  4711
#define IDH_FPROP_GEN_DOSNAME                   4712
#define IDH_FPROP_GEN_LASTCHANGE                4713
#define IDH_FPROP_GEN_LASTACCESS                4714
#define IDH_FPROP_GEN_READONLY                  4715
#define IDH_FPROP_GEN_ARCHIVE                   4716
#define IDH_FPROP_GEN_HIDDEN                    4717
#define IDH_FPROP_GEN_SYSTEM                    4718
#define IDH_FPROP_GEN_PATH                      4719
#define IDH_FPROP_VER_ABOUT                     4720
#define IDH_FCAB_LINK_NAME                      4721
#define IDH_FCAB_DRV_CLEANUP                    4722
#define IDH_FCAB_LINK_LOCATION                  4723
#define IDH_FCAB_LINK_LINKTO                    4724
#define IDH_FCAB_LINK_LINKTYPE                  4725
#define IDH_FCAB_LINK_SIZE                      4726
#define IDH_FCAB_LINK_WORKING                   4727
#define IDH_FCAB_LINK_HOTKEY                    4728
#define IDH_FCAB_LINK_RUN                       4729
#define IDH_FCAB_LINK_CHANGEICON                4730
#define IDH_FCAB_LINK_FIND                      4731
#define IDH_FCAB_LINK_ICONNAME                  4732
#define IDH_FCAB_LINK_CURRENT_ICON              4733
#define IDH_FCAB_DRV_ICON                       4734
#define IDH_FCAB_DRV_LABEL                      4735
#define IDH_FCAB_DRV_TYPE                       4736
#define IDH_FCAB_DRV_USEDCOLORS                 4737
#define IDH_FCAB_DRV_TOTSEP                     4738
#define IDH_FCAB_DRV_PIE                        4739
#define IDH_FCAB_DRV_LETTER                     4740
#define IDH_FCAB_DRV_FS                         4741
#define IDH_FCAB_DISKTOOLS_CHKNOW               4742
#define IDH_FCAB_DISKTOOLS_BKPNOW               4743
#define IDH_FCAB_DISKTOOLS_OPTNOW               4744
#define IDH_FCAB_DELFILEPROP_DELETED            4745
#define IDH_FCAB_DRV_COMPRESS                   4746
#define IDH_FPROP_GEN_DATE_CREATED              4747
#define IDH_FCAB_FOLDEROPTIONS_ALWAYS           4748
#define IDH_FCAB_FOLDEROPTIONS_NEVER            4749
#define IDH_FCAB_VIEWOPTIONS_SHOWALL            4750
#define IDH_FCAB_VIEWOPTIONS_HIDDENEXTS         4751
#define IDH_FCAB_VIEWOPTIONS_SHOWFULLPATH       4752
#define IDH_FCAB_VIEWOPTIONS_HIDEEXTS           4753
#define IDH_FCAB_VIEWOPTIONS_SHOWDESCBAR        4754
#define IDH_FCAB_FT_PROP_LV_FILETYPES           4755
#define IDH_FCAB_FT_PROP_NEW                    4756
#define IDH_FCAB_FT_PROP_REMOVE                 4757
#define IDH_FCAB_FT_PROP_FINDEXT                4758
#define IDH_FCAB_FT_PROP_EDIT                   4759
#define IDH_FCAB_FT_PROP_DETAILS                4760
#define IDH_FCAB_FT_CMD_ACTION                  4761
#define IDH_FCAB_FT_CMD_EXE                     4762
#define IDH_FCAB_FT_CMD_BROWSE                  4763
#define IDH_FCAB_FT_CMD_USEDDE                  4764
#define IDH_FCAB_FT_CMD_DDEMSG                  4765
#define IDH_FCAB_FT_CMD_DDEAPP                  4766
#define IDH_FCAB_FT_CMD_DDEAPPNOT               4767
#define IDH_FCAB_FT_CMD_DDETOPIC                4768
#define IDH_FCAB_FT_EDIT_DOCICON                4769
#define IDH_FCAB_FT_EDIT_CHANGEICON             4770
#define IDH_FCAB_FT_EDIT_DESC                   4771
#define IDH_FCAB_FT_EDIT_EXT                    4772
#define IDH_FCAB_FT_EDIT_LV_CMDS                4773
#define IDH_FCAB_FT_EDIT_DEFAULT                4774
#define IDH_FCAB_FT_EDIT_NEW                    4775
#define IDH_FCAB_FT_EDIT_EDIT                   4776
#define IDH_FCAB_FT_EDIT_REMOVE                 4777
#define IDH_FCAB_DELFILEPROP_COMPRESSED         4778
#define IDH_FPROP_GEN_ICON                      4779
#define IDH_MULTPROP_NAME                       4780
#define IDH_FPROP_FOLDER_CONTAINS               4781
#define IDH_FCAB_LINK_ICON                      4782
#define IDH_FCAB_DELFILEPROP_LOCATION           4783
#define IDH_FCAB_DELFILEPROP_READONLY           4784
#define IDH_FCAB_DELFILEPROP_HIDDEN             4785
#define IDH_FCAB_DELFILEPROP_ARCHIVE            4786
#define IDH_FCAB_DELFILEPROP_SYSTEM             4787
#define IDH_FCAB_OPENAS_DESCRIPTION             4788
#define IDH_FCAB_OPENAS_APPLIST                 4789
#define IDH_FCAB_OPENAS_OTHER                   4790
#define IDH_FCAB_FT_EDIT_QUICKVIEW              4791
#define IDH_GENDRV_CHKWARN                      4792
#define IDH_GENDRV_MBFREE                       4793
#define IDH_FCAB_OPENAS_MAKEASSOC               4794
#define IDH_FCAB_FT_EDIT_SHOWEXT                4795
#define IDH_FCAB_FT_PROP_CONTTYPERO             4796    // T.B.D. IExplorer merge
#define IDH_FCAB_FT_EDIT_CONTTYPE               4797    // T.B.D. IExplorer merge
#define IDH_FCAB_FT_EDIT_DEFEXT                 4798    // T.B.D. IExplorer merge
#define IDH_FCAB_VIEWOPTIONS_SHOWCOMPCOLOR      4799


// Screen saver ids

#define IDH_BEZIER_SPEED                4800
#define IDH_BEZIER_LINES                4801
#define IDH_BEZIER_CURVES               4802
#define IDH_BEZIER_DENSITY              4803
#define IDH_BEZIER_ONECOLOR             4804
#define IDH_BEZIER_CHOOSECLR            4805
#define IDH_BEZIER_MULTCOLOR            4806
#define IDH_BEZIER_CLRSCRN              4807
#define IDH_FLYINGWIN_WARP              4808
#define IDH_FLYINGWIN_DENSTY            4809
#define IDH_COMM_PASSWDCHKBOX           4810
#define IDH_MARQUEE_CENTER              4811
#define IDH_MARQUEE_RANDOM              4812
#define IDH_MARQUEE_SPEED               4813
#define IDH_MARQUEE_COLOR               4814
#define IDH_MARQUEE_TEXT                4815
#define IDH_MARQUEE_FORMAT              4817
#define IDH_MYST_SHAPE                  4818
#define IDH_MYST_ACTVBOX                4819
#define IDH_MYST_LINES                  4820
#define IDH_MYST_TWOCOLORS              4821
#define IDH_MYST_MULTIPLE               4822
#define IDH_MYST_CLEARSCRN              4823
#define IDH_STARS_WARP                  4824
#define IDH_STARS_DENSTY                4825
#define IDH_HOP_DELAY                   4826
#define IDH_HOP_SCALE                   4827

// More ids for file properties (first range wasn't big enough)
#define IDH_FCAB_VIEWOPTIONS_WEBVIEW                    4850
#define IDH_FCAB_VIEWOPTIONS_WIN95VIEW                  4851
#define IDH_FCAB_VIEWOPTIONS_DOUBLECLICKINWEBVIEW       4852
#define IDH_FCAB_VIEWOPTIONS_SINGLECLICKINWEBVIEW       4853
#define IDH_FCAB_LINK_DESCRIPTION                       4854

// New filetype's dialog help ID's
#define IDH_FCAB_FT_NE_ADV_BUT                          4855
#define IDH_FCAB_FT_NE_FILETYPE                         4856
#define IDH_FPROP_GEN_OPENSWITH                         4857
#define IDH_FPROP_GEN_ADVANCED                          4858
#define IDH_FPROP_GEN_INDEX                             4859
#define IDH_FPROP_GEN_ENCRYPT                           4860
#define IDH_FCAB_LINK_RUNASUSER                         4861
#define IDH_FCAB_DRV_INDEX                              4862

#define IDH_FCAB_FT_NE_FILEEXT                          4863
#define IDH_FCAB_FT_PROP_EDIT_RESTORE                   4864

#define IDH_FPROP_GEN_MOUNTEDPROP                       4865
#define IDH_FPROP_GEN_MOUNTEDTARGET                     4866

#define IDH_FPROP_GEN_FOLDER_READONLY                   4867

// id's for date-time property sheet

#define IDH_DATETIME_MONTH              4901
#define IDH_DATETIME_YEAR               4902
#define IDH_DATETIME_DATE               4903
#define IDH_DATETIME_TIME               4904
#define IDH_DATETIME_TIMEZONE           4907
#define IDH_DATETIME_BITMAP             4908
#define IDH_DATETIME_DAYLIGHT_SAVE      4909
#define IDH_DATETIME_CURRENT_TIME_ZONE  4910
#define IDH_DATETIME_DATE_GROUP         4911

// id's for Modem Setup

#define IDH_MODEM_SELECT                5000
#define IDH_MODEM_DETECT                5001
#define IDH_MODEM_PORT                  5002
#define IDH_MODEM_NAME                  5003
#define IDH_MODEM_INSTALLED             5004
#define IDH_MODEM_PROP                  5005
#define IDH_MODEM_NEW                   5006
#define IDH_MODEM_DELETE                5007

// id's for Unimodem property pages

#define IDH_UNI_GEN_MODEM               5050
#define IDH_UNI_GEN_PORT                5051
#define IDH_UNI_GEN_VOLUME              5052
#define IDH_UNI_GEN_MAX_SPEED           5053
#define IDH_UNI_GEN_THIS_SPEED          5054
#define IDH_UNI_CON_PREFS               5055
#define IDH_UNI_CON_CALL_PREFS          5056
//#define IDH_UNI_CON_TONE                5057      Deleted
#define IDH_UNI_CON_DIALTONE            5058
#define IDH_UNI_CON_CANCEL              5059
#define IDH_UNI_CON_DISCONNECT          5060
#define IDH_UNI_CON_PORT                5061
#define IDH_UNI_CON_ADVANCED            5062
#define IDH_UNI_CON_ADV_ERROR           5063
#define IDH_UNI_CON_ADV_REQUIRED        5064
#define IDH_UNI_CON_ADV_COMPRESS        5065
#define IDH_UNI_CON_ADV_CELLULAR        5066
#define IDH_UNI_CON_ADV_FLOW            5067
#define IDH_UNI_CON_ADV_MODULATION      5068
#define IDH_UNI_CON_ADV_CSITT           5069
#define IDH_UNI_CON_ADV_BELL            5070
#define IDH_UNI_CON_ADV_EXTRA           5071
#define IDH_UNI_CON_ADV_AUDIT           5072
//#define IDH_UNI_OPT_CONNECTION          5073      Deleted
#define IDH_UNI_OPT_PRE_DIAL            5074
#define IDH_UNI_OPT_POST_DIAL           5075
#define IDH_UNI_OPT_MANUAL              5076
#define IDH_UNI_OPT_STATUS              5077
#define IDH_UNI_TERMINAL                5078
#define IDH_UNI_STATUS_TALK             5079
#define IDH_UNI_STATUS_HANGUP           5080
#define IDH_UNI_GEN_PORT_INT            5081
#define IDH_UNI_OPT_WAIT                5082

#define IDH_LIGHTS                      5099

// id's for TAPI Dial Helper (5100-5199)

#define IDH_TAPI_ACCESS_LINE            5100
#define IDH_TAPI_AREA_CODE              5101
#define IDH_TAPI_CALLCARD_ADD           5102
#define IDH_TAPI_CALLCARD_ADV           5103
#define IDH_TAPI_CALLCARD_NUMBER        5104
#define IDH_TAPI_CALLCARD_REMOVE        5105
#define IDH_TAPI_CALLCARD_RULES         5106
#define IDH_TAPI_CALLCARDS              5107
#define IDH_TAPI_COPY_FROM_BUTTON       5108
#define IDH_TAPI_COPYFROM               5109
#define IDH_TAPI_COUNTRY                5110
#define IDH_TAPI_CREATE_CARD            5111
#define IDH_TAPI_CREATE_LOCATION        5112
#define IDH_TAPI_LOCATION_CALL_WAIT     5113
#define IDH_TAPI_LOCATION_CARD          5114
#define IDH_TAPI_LOCATION_CARD_CHANGE   5115
#define IDH_TAPI_LOCATION_NEW           5116
#define IDH_TAPI_LOCATION_PHONE         5117
#define IDH_TAPI_LOCATION_PULSE         5118
#define IDH_TAPI_LOCATION_REMOVE        5119
#define IDH_TAPI_LOCATIONS              5120
#define IDH_TAPI_LONG_DISTANCE          5121

// id's 5200 - 5500 are reserved for DOS

//  Add/Remove Program IDs reserved 5600-5699

// Miscellaneous ids

#define IDH_TRAY_RUN_COMMAND            6002
#define IDH_TRAY_RUN_SEPMEM             6003
#define IDH_TRAY_TASKBAR_ONTOP          6004
#define IDH_TRAY_TASKBAR_AUTOHIDE       6005
#define IDH_TRAY_SHUTDOWN_SHUTDOWN      6007
#define IDH_TRAY_SHUTDOWN_RESTART       6008
#define IDH_TRAY_SHUTDOWN_LOGOFF        6009
#define IDH_STARTMENU_SMALLICONS        6010
#define IDH_MENUCONFIG_CLEAR            6011
#define IDH_TRAY_ADD_PROGRAM            6012
#define IDH_TRAY_REMOVE_PROGRAM         6013
#define IDH_TRAY_ADVANCED               6014
#define IDH_TRAY_SHUTDOWN_HELP          6015
#define IDH_TRAY_SHOW_CLOCK             6016
#define IDH_TRAY_REMOVEDLG_LIST         6017
#define IDH_TRAY_REMOVEDLG_DEL          6018
#define IDH_TASKBAR_OPTIONS_BITMAP      6019
#define IDH_TRAY_USE_ADAPTIVE_MENUS     6020
#define IDH_TRAY_RESORT_BUTTON          6021
#define IDH_TRAY_RUN_OK                 6022
#define IDH_TRAY_RUN_CANCEL             6023
#define IDH_TRAY_GROUPING               6024
#define IDH_START_PREVIEW               6025
#define IDH_TRAY_CUSTOMIZE_ICONS        6026
#define IDH_TRAY_RESTOREDEFBUTTON       6027
#define IDH_TRAY_HIDE_ICONS             6028
#define IDH_START_SELECTCLASSIC         6029
#define IDH_START_CUSTOMIZECLASSIC      6030
#define IDH_START_SELECTPERSONAL        6031
#define IDH_START_CUSTOMIZEPERSONAL     6032
#define IDH_TRAY_QUICKLAUNCH            6033

// for the general and advanced tabs of the customize new start menu
#define IDH_START_SPCUST_LARGE          6050
#define IDH_START_SPCUST_SMALL          6051
#define IDH_START_SPCUST_MINPROGS       6052
#define IDH_START_SPCUST_CLEARPROG      6053
#define IDH_START_SPCUST_INTERNET       6054
#define IDH_START_SPCUST_INTERNETCB     6055
#define IDH_START_SPCUST_EMAIL          6056
#define IDH_START_SPCUST_EMAILCB        6057

#define IDH_START_SPCUST_HOVEROPEN      6058
#define IDH_START_SPCUST_NOTIFYNEW      6059
#define IDH_START_STARTMENUSETTINGS     6060
#define IDH_START_SPCUST_RECENT         6061
#define IDH_START_SPCUST_CLEARDOCS      6062

// ID values for Virtual Memory Property sheet

#define IDH_DEVMGR_VIEW_BY              6204
#define IDH_SYSTEM_DM_PRINT             6205
#define IDH_DEVMGR_PATH                 6206

#define IDH_DEVMGR_CONFLICT_TRB         6260
#define IDH_DEVMGR_DRIVERINFO           6261
#define IDH_DEVMGR_CHANGEDRIVER         6262
#define IDH_DEVMGR_DRIVERS              6264
#define IDH_DEVMGR_PRINTER              6265
#define IDH_DEVMGR_PRINTOVERVIEW        6266
#define IDH_DEVMGR_PRINT_SYS            6267
#define IDH_DEVMGR_PRINT_CLASS          6268
#define IDH_DEVMGR_SHOW                 6271
#define IDH_DEVMGR_HAVEDISK             6272
#define IDH_DEVMGR_CHOOSE_DEVICE        6273

//  Ids for the performance page
#define IDH_PERFLOWRES                  6301
#define IDH_PERFLOWMEM                  6302
#define IDH_4MBHELP                     6303
#define IDH_PERFCOMPATVIRTMEM           6304
#define IDH_PERFVIRTMEMOFF              6305
#define IDH_PERFPCMCIAOFF               6306
#define IDH_PERFRMCOMPRESS              6307
#define IDH_PERFNOPMODEDRIVES           6308
#define IDH_PERFMBRHOOK                 6309
#define IDH_PERFREALMODEDRIVE           6310
#define IDH_PERFNOPMODETSR              6311

#define IDH_SYS_PERF_MEMORY             6320
#define IDH_SYS_PERF_SR                 6321
#define IDH_SYS_PERF_FS                 6322
#define IDH_SYS_PERF_VMEM               6323
#define IDH_SYS_PERF_COMPRESS           6324
#define IDH_SYS_PERF_PCMCIA             6325
#define IDH_SYS_PERF_PROBLEM            6326
#define IDH_SYS_PERF_DETAILS            6327


//  sysclass.dll
#define IDH_FPU_DIAGTEXT                6350
#define IDH_FPU_SETTING                 6351
#define IDH_POWERCFG_ENABLE_PM          6352
#define IDH_POWERCFG_FORCE_APM          6353
#define IDH_POWERCFG_DISABLE_INTEL      6354
#define IDH_POWERCFG_POLLING            6355


// More ids for system cpl (ran out of #'s above)
#define IDH_SYSTEM_DMCONFIG_RETRY               6400
#define IDH_SYSTEM_DMCONFIG_IGNORE              6401

#define IDH_SYSTEM_OEMSUPPORT           6407
#define IDH_SYSTEM_DEVGEN_STATUS                6408
#define IDH_SYSTEM_DEGEN_SPECIALMF      6409
#define IDH_SYSTEM_DEVRES_SETTINGS              6410
#define IDH_SYSTEM_USESYSSETTINGS               6411
#define IDH_SYSTEM_DEVRES_CHANGE                6412
#define IDH_SYSTEM_LOGCONFIGLIST                6413
#define IDH_SYSTEM_REGRSTR_RESTORE              6417
#define IDH_SYSTEM_TREE                         6418
#define IDH_SYSTEM_PROPERTIES                   6419
#define IDH_SYSTEM_DM_REFRESH                   6420

#define IDH_SYSTEM_VIRTMEM_ON                   6421
#define IDH_SYSTEM_VIRTMEM_DEFAULT              6422
#define IDH_SYSTEM_VIRTMEM_SWAPDRIVE            6424
#define IDH_SYSTEM_VIRTMEM_MINSIZE              6427
#define IDH_SYSTEM_VIRTMEM_MAXSIZE              6428

#define IDH_SYSTEM_DEVRES_DESC                  6442
#define IDH_SYSTEM_CONFLICT_IO                  6443
#define IDH_SYSTEM_EDITRANGE_STARTVAL           6444
#define IDH_SYSTEM_CONFLICT_USED                6445
#define IDH_SYSTEM_DM_REMOVE                    6446

#define IDH_POWERCFG_ENABLEMETER                        6452
#define IDH_POWERCFG_POWERSTATUSBAR                     6453
#define IDH_POWERCFG_PMLEVELLIST                        6454
#define IDH_POWERCFG_OPTIONS                            6455

#define IDH_PCMCIA_SELECT                               6458
#define IDH_PCMCIA_MEMORY                               6459
#define IDH_PCMCIA_SOUND                                6460
#define IDH_PCMCIA_CARDSERV                             6461

#define IDH_SYSTEM_DEVGEN_DEVDESC                       6462
#define IDH_SYSTEM_DEVRES_MAKEFC                        6463

#define IDH_SYSTEM_DEVRES_LISTCONFLICT                  6474

#define IDH_SYSTEM_VIEW_LIST                            6483
#define IDH_SYSTEM_RCW_LIST                             6485
#define IDH_SYSTEM_RCW_DETAILS                          6488

#define IDH_POWERCFG_STARTMENU          6491
#define IDH_BATMETER_LOWBATWARN         6492

#define IDH_PCMCIA_TRAY                                 6493
#define IDH_PCMCIA_EJECT                                6494
#define IDH_PCMCIA_WARN                                 6495
#define IDH_PCMCIA_LIST                                 6496

// browseui.dll
#define IDH_BROWSEUI_TB_TEXTOPTIONS                             6800
#define IDH_BROWSEUI_TB_ICONOPTIONS                             6801

// More WinDisk IDs

#define IDH_WINDISK_DDEMDBPB_IGNORE                             7000
#define IDH_WINDISK_DDEMDBPB_REPAIR                             7005
#define IDH_WINDISK_DDERRBOOT_IGNORE                            7010
#define IDH_WINDISK_DDERRBOOT_REPAIR                            7015
#define IDH_WINDISK_DDERRCVFNM_IGNORE                           7020
#define IDH_WINDISK_DDERRCVFNM_REPAIR                           7025
#define IDH_WINDISK_DDERRLSTSQZ_DISCARD                         7030
#define IDH_WINDISK_DDERRLSTSQZ_IGNORE                          7035
#define IDH_WINDISK_DDERRLSTSQZ_KEEP                            7040
#define IDH_WINDISK_DDERRMDFAT_IGNORE                           7045
#define IDH_WINDISK_DDERRMDFAT_REPAIR                           7050
#define IDH_WINDISK_DDERRSIG_IGNORE                             7055
#define IDH_WINDISK_DDERRSIG_REPAIR                             7060
#define IDH_WINDISK_DDERRXLSQZ_COPY                             7065
#define IDH_WINDISK_DDERRXLSQZ_DELETE                           7070
#define IDH_WINDISK_DDERRXLSQZ_IGNORE                           7075
#define IDH_WINDISK_DDESIZE2_IGNORE                             7080
#define IDH_WINDISK_DDESIZE2_REPAIR                             7085
#define IDH_WINDISK_FATERRCDLIMIT_DELETE                        7090
#define IDH_WINDISK_FATERRCDLIMIT_IGNORE                        7095
#define IDH_WINDISK_FATERRCDLIMIT_REPAIR                        7100
#define IDH_WINDISK_FATERRFILE_DELETE_FILE                      7105
#define IDH_WINDISK_FATERRFILE_DELETE_FOLDER                    7107
#define IDH_WINDISK_FATERRFILE_IGNORE                           7110
#define IDH_WINDISK_FATERRFILE_REPAIR                           7115
#define IDH_WINDISK_FATERRLSTCLUS_CONVERT                       7120
#define IDH_WINDISK_FATERRLSTCLUS_DISCARD                       7125
#define IDH_WINDISK_FATERRLSTCLUS_IGNORE                        7130
#define IDH_WINDISK_FATERRMISMAT_DONT_REPAIR                    7135
#define IDH_WINDISK_FATERRMISMAT_REPAIR                         7140
#define IDH_WINDISK_FATERRMXPLEN_DELETE_FILE                    7145
#define IDH_WINDISK_FATERRMXPLEN_DELETE_FOLDER                  7150
#define IDH_WINDISK_FATERRMXPLEN_IGNORE_FILE                    7155
#define IDH_WINDISK_FATERRMXPLEN_IGNORE_FOLDER                  7160
#define IDH_WINDISK_FATERRMXPLEN_REPAIR_FILE                    7165
#define IDH_WINDISK_FATERRMXPLEN_REPAIR_FOLDER                  7170
#define IDH_WINDISK_FATERRRESVAL_DONT_REPAIR                    7175
#define IDH_WINDISK_FATERRRESVAL_REPAIR                         7180
#define IDH_WINDISK_FATERRXLNK_COPY                             7185
#define IDH_WINDISK_FATERRXLNK_DELETE                           7190
#define IDH_WINDISK_FATERRXLNK_IGNORE                           7195
#define IDH_WINDISK_FATERRXLNK_KEEP_SEL_DEL_OTH                 7200
#define IDH_WINDISK_FATERRXLNK_KEEP_SEL_TRUNC_OTH               7205
#define IDH_WINDISK_FATERRXLNK_TRUNCATE_ALL                     7210
#define IDH_WINDISK_ISBAD_COMP_HOST_DONE_REPAIR                 7215
#define IDH_WINDISK_ISBAD_COMP_HOST_NOTDONE_REPAIR              7220
#define IDH_WINDISK_ISBAD_COMP_HOST_NOTDONE_RESTART             7225
#define IDH_WINDISK_ISBAD_COMP_RETRY                            7230
#define IDH_WINDISK_ISBAD_IGNORE                                7235
#define IDH_WINDISK_ISBAD_SYSTEM_IGNORE                         7240
#define IDH_WINDISK_ISBAD_SYSTEM_RETRY                          7245
#define IDH_WINDISK_ISBAD_UNCOMP_DATA_REPAIR                    7250
#define IDH_WINDISK_ISBAD_UNCOMP_RETRY                          7255
#define IDH_WINDISK_ISNTBAD_RETRY                               7260
#define IDH_WINDISK_ISNTBAD_CLEAR                               7265
#define IDH_WINDISK_ISNTBAD_LEAVE                               7270
#define IDH_WINDISK_ISTR_FATERRCIRCC_DELETE                     7275
#define IDH_WINDISK_ISTR_FATERRCIRCC_IGNORE                     7280
#define IDH_WINDISK_ISTR_FATERRCIRCC_TRUNCATE                   7285
#define IDH_WINDISK_ISTR_FATERRDIR_DELETE                       7290
#define IDH_WINDISK_ISTR_FATERRDIR_IGNORE                       7295
#define IDH_WINDISK_ISTR_FATERRDIR_REPAIR                       7300
#define IDH_WINDISK_ISTR_FATERRINVCLUS_DELETE                   7305
#define IDH_WINDISK_ISTR_FATERRINVCLUS_IGNORE                   7310
#define IDH_WINDISK_ISTR_FATERRINVCLUS_TRUNCATE                 7315
#define IDH_WINDISK_ISTR_FATERRVOLLAB_DELETE_ISFRST_NOTSET      7320
#define IDH_WINDISK_ISTR_FATERRVOLLAB_DELETE_ISFRST_SET         7330
#define IDH_WINDISK_ISTR_FATERRVOLLAB_IGNORE_ISFRST_NOTSET      7340
#define IDH_WINDISK_ISTR_FATERRVOLLAB_IGNORE_ISFRST_SET         7350
#define IDH_WINDISK_ISTR_FATERRVOLLAB_REPAIR_ISFRST_NOTSET      7360
#define IDH_WINDISK_ISTR_FATERRVOLLAB_REPAIR_ISFRST_SET         7370
#define IDH_WINDISK_MEMORYERROR_IGNORE                          7380
#define IDH_WINDISK_MEMORYERROR_RETRY                           7385
#define IDH_WINDISK_READERROR_RETRY                             7390
#define IDH_WINDISK_READWRITEERROR_COMP_SYSTEM_IGNORE           7395
#define IDH_WINDISK_READWRITEERROR_COMP_THOROUGH                7400
#define IDH_WINDISK_READWRITEERROR_DATA_IGNORE                  7405
#define IDH_WINDISK_READWRITEERROR_UNCOMP_SYSTEM_IGNORE         7410
#define IDH_WINDISK_READWRITEERROR_UNCOMP_THOROUGH              7415
#define IDH_WINDISK_WRITEERROR_RETRY                            7420
#define IDH_WINDISK_FATERRMXPLEN_SHORT_IGNORE_FILE              7425
#define IDH_WINDISK_FATERRMXPLEN_SHORT_IGNORE_FOLDER            7430
#define IDH_SCANDISK                                            7431
#define IDH_SCANDISK_FINISH                                     7432
#define IDH_SCANDISK_FINISH_SURF_HOST                           7433
#define IDH_SCANDISK_FINISH_SURF                                7434
#define IDH_COMPRESS_CORRECT_SIZE                               7435
#define IDH_COMPRESS_CORRECT_RATIO                              7436
#define IDH_UTILITIES_DEFRAG_DISK_ERROR                         7437
#define IDH_CVF_TOO_SMALL_CHECK_HOST                            7438
#define IDH_THOROUGH_TEST_CHECK_HOST                            7439
#define IDH_DISK_LOGICAL                                        7440
#define IDH_DISK_PHYSICAL                                       7441
#define IDH_WINDISK_DDERRMDFAT_LOST_REPAIR                      7442
#define IDH_WINDISK_DDERRMDFAT_LOST_IGNORE                      7443
#define IDH_WINDISK_ISBAD_NO_FREE_CLUSTER                       7444
#define IDH_WINDISK_MAIN_LIST                                   7445
#define IDH_WINDISK_MAIN_STANDARD                               7446
#define IDH_WINDISK_MAIN_OPTIONS                                7447
#define IDH_WINDISK_MAIN_THOROUGH                               7448
#define IDH_WINDISK_MAIN_AUTOFIX                                7449
#define IDH_WINDISK_MAIN_ADVANCED                               7450
#define IDH_WINDISK_ADV_ALWAYS                                  7451
#define IDH_WINDISK_ADV_NEVER                                   7452
#define IDH_WINDISK_ADV_ONLY_IF_FOUND                           7453
#define IDH_WINDISK_ADV_DELETE                                  7454
#define IDH_WINDISK_ADV_MAKE_COPIES                             7455
#define IDH_WINDISK_ADV_IGNORE                                  7456
#define IDH_WINDISK_ADV_FILENAME                                7457
#define IDH_WINDISK_ADV_DATE_TIME                               7458
#define IDH_WINDISK_ADV_CHECK_HOST                              7459
#define IDH_WINDISK_ADV_FREE                                    7460
#define IDH_WINDISK_ADV_CONVERT                                 7461
#define IDH_WINDISK_OPTIONS_SYS_AND_DATA                        7462
#define IDH_WINDISK_OPTIONS_SYS_ONLY                            7463
#define IDH_WINDISK_OPTIONS_DATA_ONLY                           7464
#define IDH_WINDISK_OPTIONS_NO_WRITE_TEST                       7465
#define IDH_WINDISK_OPTIONS_NO_HID_SYS                          7466
#define IDH_FORMATDLG_CAPACITY                                  7467
#define IDH_FORMATDLG_QUICK                                     7468
#define IDH_FORMATDLG_FULL                                      7469
#define IDH_FORMATDLG_DOSYS                                     7470
#define IDH_FORMATDLG_LABEL                                     7471
#define IDH_FORMATDLG_NOLAB                                     7472
#define IDH_FORMATDLG_REPORT                                    7473
#define IDH_FORMATDLG_MKSYS                                     7474
#define IDH_WINDISK_MAIN_START                                  7475
#define IDH_WINDISK_MAIN_CLOSE                                  7476
#define IDH_WINDISK_OK_FOR_ERRORS                               7477
#define IDH_WINDISK_CANCEL_FOR_ERRORS                           7478
#define IDH_WINDISK_MORE_INFO                                   7479
#define IDH_FORMATDLG_START                                     7480
#define IDH_WINDISK_REPLACE_LOG                                 7481
#define IDH_WINDISK_APPEND_LOG                                  7482
#define IDH_WINDISK_NO_LOG                                      7483
#define IDH_FORMATDLG_FILESYS                                   7484
#define IDH_FORMATDLG_ALLOCSIZE                                 7485
#define IDH_FORMATDLG_QUICKFULL                                 7486
#define IDH_FORMATDLG_COMPRESS                                  7487

#define IDH_CHKDSKDLG_START                                     7488
#define IDH_CHKDSKDLG_FIXERRORS                                 7489
#define IDH_CHKDSKDLG_SCAN                                      7490
#define IDH_CHKDSKDLG_CANCEL                                    7491
#define IDH_CHKDSKDLG_PROGRESS                                  7492
#define IDH_FORMATDLG_PROGRESS                                  7493

// IDs for Port Settings

#define IDH_PORT_BAUD                                           7900
#define IDH_PORT_DATA                                           7901
#define IDH_PORT_PARITY                                         7902
#define IDH_PORT_STOPBITS                                       7903
#define IDH_PORT_FLOW                                           7904
#define IDH_PORT_RESTORE                                        7905

// IDs for Modem Diagnostics

#define IDH_MODEM_DIAG_INSTALLED                                7950
#define IDH_MODEM_DIAG_HELP                                     7951
#define IDH_MODEM_DIAG_MOREINFO                                 7952
#define IDH_MODEM_DIAG_DRIVER                                   7953

// IDs for Wastebasket/Recycle

#define IDH_WASTE_FREEING_DISK_SPACE                            8000
#define IDH_RECYCLE_CONFIG_INDEP                                8001
#define IDH_RECYCLE_CONFIG_ALL                                  8002
#define IDH_RECYCLE_PURGE_ON_DEL                                8003
#define IDH_RECYCLE_MAX_SIZE                                    8004
#define IDH_RECYCLE_DRIVE_SIZE                                  8005
#define IDH_RECYCLE_BIN_SIZE                                    8006
#define IDH_DELETE_CONFIRM_DLG                                  8007

#define IDH_FPROP_GEN_CHANGE                                    475102
#define IDH_CONFIRM_OPEN                                        51065
#define IDH_SAME_WINDOW                                         51066

// ID values 8100-8199 are reserved for Font dialog.

#define IDH_TRAY_START_MENU_SETTINGS                            51132
#define IDH_TRAY_DISPLAY_LOGOFF                                 51133
#define IDH_TRAY_DISPLAY_FAVORITES                              51134
#define IDH_TRAY_EXPAND_CPANEL                                  51135
#define IDH_TRAY_EXPAND_MYDOCS                                  51136
#define IDH_TRAY_EXPAND_PRINTERS                                51137
#define IDH_TRAY_SCROLL_PROGRAMS                                51138
#define IDH_TRAY_PERSONALIZED_MENUS                             51139
#define IDH_TRAY_DISPLAY_ADMIN_TOOLS                            51140

#define IDH_TRAY_ENABLEMOVERESIZE                               51143
#define IDH_TRAY_CONTEXTMENU                                    51144

#define IDH_DATETIME_AUTOSETFROMINTERNET                        51150
#define IDH_DATETIME_UPDATEFROMINTERNET                         51151
#define IDH_DATETIME_SERVER_EDIT                                51152
#define IDH_DATETIME_INFOTEXT                                   51153
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\efsui.h ===
/*
Copyright (c) 1985-1998, Microsoft Corporation

Module Name:


    efsui.h

Abstract:

    Header file for Encryped File System UI

*/

// Brings up the encryption details page
STDAPI_(void) EfsDetail(HWND hwndParent, LPCWSTR FileName);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\iepriv.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for iepriv.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iepriv_h__
#define __iepriv_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMruDataList_FWD_DEFINED__
#define __IMruDataList_FWD_DEFINED__
typedef interface IMruDataList IMruDataList;
#endif 	/* __IMruDataList_FWD_DEFINED__ */


#ifndef __IMruPidlList_FWD_DEFINED__
#define __IMruPidlList_FWD_DEFINED__
typedef interface IMruPidlList IMruPidlList;
#endif 	/* __IMruPidlList_FWD_DEFINED__ */


#ifndef __INSCTree_FWD_DEFINED__
#define __INSCTree_FWD_DEFINED__
typedef interface INSCTree INSCTree;
#endif 	/* __INSCTree_FWD_DEFINED__ */


#ifndef __INSCTree2_FWD_DEFINED__
#define __INSCTree2_FWD_DEFINED__
typedef interface INSCTree2 INSCTree2;
#endif 	/* __INSCTree2_FWD_DEFINED__ */


#ifndef __INotifyAppStart_FWD_DEFINED__
#define __INotifyAppStart_FWD_DEFINED__
typedef interface INotifyAppStart INotifyAppStart;
#endif 	/* __INotifyAppStart_FWD_DEFINED__ */


#ifndef __IInitViewLinkedWebOC_FWD_DEFINED__
#define __IInitViewLinkedWebOC_FWD_DEFINED__
typedef interface IInitViewLinkedWebOC IInitViewLinkedWebOC;
#endif 	/* __IInitViewLinkedWebOC_FWD_DEFINED__ */


#ifndef __INamespaceProxy_FWD_DEFINED__
#define __INamespaceProxy_FWD_DEFINED__
typedef interface INamespaceProxy INamespaceProxy;
#endif 	/* __INamespaceProxy_FWD_DEFINED__ */


#ifndef __IBrowserFrameOptions_FWD_DEFINED__
#define __IBrowserFrameOptions_FWD_DEFINED__
typedef interface IBrowserFrameOptions IBrowserFrameOptions;
#endif 	/* __IBrowserFrameOptions_FWD_DEFINED__ */


#ifndef __ISearchCompanionInfo_FWD_DEFINED__
#define __ISearchCompanionInfo_FWD_DEFINED__
typedef interface ISearchCompanionInfo ISearchCompanionInfo;
#endif 	/* __ISearchCompanionInfo_FWD_DEFINED__ */


#ifndef __IShellMenuCallback_FWD_DEFINED__
#define __IShellMenuCallback_FWD_DEFINED__
typedef interface IShellMenuCallback IShellMenuCallback;
#endif 	/* __IShellMenuCallback_FWD_DEFINED__ */


#ifndef __IShellMenu_FWD_DEFINED__
#define __IShellMenu_FWD_DEFINED__
typedef interface IShellMenu IShellMenu;
#endif 	/* __IShellMenu_FWD_DEFINED__ */


#ifndef __IShellMenu2_FWD_DEFINED__
#define __IShellMenu2_FWD_DEFINED__
typedef interface IShellMenu2 IShellMenu2;
#endif 	/* __IShellMenu2_FWD_DEFINED__ */


#ifndef __ITrackShellMenu_FWD_DEFINED__
#define __ITrackShellMenu_FWD_DEFINED__
typedef interface ITrackShellMenu ITrackShellMenu;
#endif 	/* __ITrackShellMenu_FWD_DEFINED__ */


#ifndef __IThumbnail_FWD_DEFINED__
#define __IThumbnail_FWD_DEFINED__
typedef interface IThumbnail IThumbnail;
#endif 	/* __IThumbnail_FWD_DEFINED__ */


#ifndef __IThumbnail2_FWD_DEFINED__
#define __IThumbnail2_FWD_DEFINED__
typedef interface IThumbnail2 IThumbnail2;
#endif 	/* __IThumbnail2_FWD_DEFINED__ */


#ifndef __IACLCustomMRU_FWD_DEFINED__
#define __IACLCustomMRU_FWD_DEFINED__
typedef interface IACLCustomMRU IACLCustomMRU;
#endif 	/* __IACLCustomMRU_FWD_DEFINED__ */


#ifndef __IShellBrowserService_FWD_DEFINED__
#define __IShellBrowserService_FWD_DEFINED__
typedef interface IShellBrowserService IShellBrowserService;
#endif 	/* __IShellBrowserService_FWD_DEFINED__ */


#ifndef __MruPidlList_FWD_DEFINED__
#define __MruPidlList_FWD_DEFINED__

#ifdef __cplusplus
typedef class MruPidlList MruPidlList;
#else
typedef struct MruPidlList MruPidlList;
#endif /* __cplusplus */

#endif 	/* __MruPidlList_FWD_DEFINED__ */


#ifndef __MruLongList_FWD_DEFINED__
#define __MruLongList_FWD_DEFINED__

#ifdef __cplusplus
typedef class MruLongList MruLongList;
#else
typedef struct MruLongList MruLongList;
#endif /* __cplusplus */

#endif 	/* __MruLongList_FWD_DEFINED__ */


#ifndef __MruShortList_FWD_DEFINED__
#define __MruShortList_FWD_DEFINED__

#ifdef __cplusplus
typedef class MruShortList MruShortList;
#else
typedef struct MruShortList MruShortList;
#endif /* __cplusplus */

#endif 	/* __MruShortList_FWD_DEFINED__ */


#ifndef __FolderMarshalStub_FWD_DEFINED__
#define __FolderMarshalStub_FWD_DEFINED__

#ifdef __cplusplus
typedef class FolderMarshalStub FolderMarshalStub;
#else
typedef struct FolderMarshalStub FolderMarshalStub;
#endif /* __cplusplus */

#endif 	/* __FolderMarshalStub_FWD_DEFINED__ */


#ifndef __MailRecipient_FWD_DEFINED__
#define __MailRecipient_FWD_DEFINED__

#ifdef __cplusplus
typedef class MailRecipient MailRecipient;
#else
typedef struct MailRecipient MailRecipient;
#endif /* __cplusplus */

#endif 	/* __MailRecipient_FWD_DEFINED__ */


#ifndef __SearchCompanionInfo_FWD_DEFINED__
#define __SearchCompanionInfo_FWD_DEFINED__

#ifdef __cplusplus
typedef class SearchCompanionInfo SearchCompanionInfo;
#else
typedef struct SearchCompanionInfo SearchCompanionInfo;
#endif /* __cplusplus */

#endif 	/* __SearchCompanionInfo_FWD_DEFINED__ */


#ifndef __TrackShellMenu_FWD_DEFINED__
#define __TrackShellMenu_FWD_DEFINED__

#ifdef __cplusplus
typedef class TrackShellMenu TrackShellMenu;
#else
typedef struct TrackShellMenu TrackShellMenu;
#endif /* __cplusplus */

#endif 	/* __TrackShellMenu_FWD_DEFINED__ */


#ifndef __Thumbnail_FWD_DEFINED__
#define __Thumbnail_FWD_DEFINED__

#ifdef __cplusplus
typedef class Thumbnail Thumbnail;
#else
typedef struct Thumbnail Thumbnail;
#endif /* __cplusplus */

#endif 	/* __Thumbnail_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "shtypes.h"
#include "shobjidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

#ifndef __IMruDataList_INTERFACE_DEFINED__
#define __IMruDataList_INTERFACE_DEFINED__

/* interface IMruDataList */
/* [object][local][helpstring][uuid] */ 

typedef int ( __stdcall *MRUDATALISTCOMPARE )( 
    const BYTE *__MIDL_0023,
    const BYTE *__MIDL_0024,
    int __MIDL_0025);


enum __MIDL_IMruDataList_0001
    {	MRULISTF_USE_MEMCMP	= 0,
	MRULISTF_USE_STRCMPIW	= 0x1,
	MRULISTF_USE_STRCMPW	= 0x2,
	MRULISTF_USE_ILISEQUAL	= 0x3
    } ;
typedef DWORD MRULISTF;


EXTERN_C const IID IID_IMruDataList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fe787bcb-0ee8-44fb-8c89-12f508913c40")
    IMruDataList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitData( 
            /* [in] */ UINT uMax,
            /* [in] */ MRULISTF flags,
            /* [in] */ HKEY hKey,
            /* [string][in] */ LPCWSTR pszSubKey,
            /* [in] */ MRUDATALISTCOMPARE pfnCompare) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddData( 
            /* [size_is][in] */ const BYTE *pData,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pdwSlot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindData( 
            /* [size_is][in] */ const BYTE *pData,
            /* [in] */ DWORD cbData,
            /* [out] */ int *piIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetData( 
            /* [in] */ int iIndex,
            /* [size_is][out] */ BYTE *pData,
            /* [in] */ DWORD cbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryInfo( 
            /* [in] */ int iIndex,
            /* [out][in] */ DWORD *pdwSlot,
            /* [out][in] */ DWORD *pcbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ int iIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMruDataListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMruDataList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMruDataList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMruDataList * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitData )( 
            IMruDataList * This,
            /* [in] */ UINT uMax,
            /* [in] */ MRULISTF flags,
            /* [in] */ HKEY hKey,
            /* [string][in] */ LPCWSTR pszSubKey,
            /* [in] */ MRUDATALISTCOMPARE pfnCompare);
        
        HRESULT ( STDMETHODCALLTYPE *AddData )( 
            IMruDataList * This,
            /* [size_is][in] */ const BYTE *pData,
            /* [in] */ DWORD cbData,
            /* [out] */ DWORD *pdwSlot);
        
        HRESULT ( STDMETHODCALLTYPE *FindData )( 
            IMruDataList * This,
            /* [size_is][in] */ const BYTE *pData,
            /* [in] */ DWORD cbData,
            /* [out] */ int *piIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetData )( 
            IMruDataList * This,
            /* [in] */ int iIndex,
            /* [size_is][out] */ BYTE *pData,
            /* [in] */ DWORD cbData);
        
        HRESULT ( STDMETHODCALLTYPE *QueryInfo )( 
            IMruDataList * This,
            /* [in] */ int iIndex,
            /* [out][in] */ DWORD *pdwSlot,
            /* [out][in] */ DWORD *pcbData);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IMruDataList * This,
            /* [in] */ int iIndex);
        
        END_INTERFACE
    } IMruDataListVtbl;

    interface IMruDataList
    {
        CONST_VTBL struct IMruDataListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMruDataList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMruDataList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMruDataList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMruDataList_InitData(This,uMax,flags,hKey,pszSubKey,pfnCompare)	\
    (This)->lpVtbl -> InitData(This,uMax,flags,hKey,pszSubKey,pfnCompare)

#define IMruDataList_AddData(This,pData,cbData,pdwSlot)	\
    (This)->lpVtbl -> AddData(This,pData,cbData,pdwSlot)

#define IMruDataList_FindData(This,pData,cbData,piIndex)	\
    (This)->lpVtbl -> FindData(This,pData,cbData,piIndex)

#define IMruDataList_GetData(This,iIndex,pData,cbData)	\
    (This)->lpVtbl -> GetData(This,iIndex,pData,cbData)

#define IMruDataList_QueryInfo(This,iIndex,pdwSlot,pcbData)	\
    (This)->lpVtbl -> QueryInfo(This,iIndex,pdwSlot,pcbData)

#define IMruDataList_Delete(This,iIndex)	\
    (This)->lpVtbl -> Delete(This,iIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMruDataList_InitData_Proxy( 
    IMruDataList * This,
    /* [in] */ UINT uMax,
    /* [in] */ MRULISTF flags,
    /* [in] */ HKEY hKey,
    /* [string][in] */ LPCWSTR pszSubKey,
    /* [in] */ MRUDATALISTCOMPARE pfnCompare);


void __RPC_STUB IMruDataList_InitData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMruDataList_AddData_Proxy( 
    IMruDataList * This,
    /* [size_is][in] */ const BYTE *pData,
    /* [in] */ DWORD cbData,
    /* [out] */ DWORD *pdwSlot);


void __RPC_STUB IMruDataList_AddData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMruDataList_FindData_Proxy( 
    IMruDataList * This,
    /* [size_is][in] */ const BYTE *pData,
    /* [in] */ DWORD cbData,
    /* [out] */ int *piIndex);


void __RPC_STUB IMruDataList_FindData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMruDataList_GetData_Proxy( 
    IMruDataList * This,
    /* [in] */ int iIndex,
    /* [size_is][out] */ BYTE *pData,
    /* [in] */ DWORD cbData);


void __RPC_STUB IMruDataList_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMruDataList_QueryInfo_Proxy( 
    IMruDataList * This,
    /* [in] */ int iIndex,
    /* [out][in] */ DWORD *pdwSlot,
    /* [out][in] */ DWORD *pcbData);


void __RPC_STUB IMruDataList_QueryInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMruDataList_Delete_Proxy( 
    IMruDataList * This,
    /* [in] */ int iIndex);


void __RPC_STUB IMruDataList_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMruDataList_INTERFACE_DEFINED__ */


#ifndef __IMruPidlList_INTERFACE_DEFINED__
#define __IMruPidlList_INTERFACE_DEFINED__

/* interface IMruPidlList */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IMruPidlList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47851649-a2ef-4e67-baec-c6a153ac72ec")
    IMruPidlList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitList( 
            /* [in] */ UINT uMax,
            /* [in] */ HKEY hKey,
            /* [string][in] */ LPCWSTR pszSubKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UsePidl( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [out] */ DWORD *pdwSlot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryPidl( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ DWORD cSlots,
            /* [length_is][size_is][out] */ DWORD *rgdwSlots,
            /* [out] */ DWORD *pcSlotsFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PruneKids( 
            /* [in] */ LPCITEMIDLIST pidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMruPidlListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMruPidlList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMruPidlList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMruPidlList * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitList )( 
            IMruPidlList * This,
            /* [in] */ UINT uMax,
            /* [in] */ HKEY hKey,
            /* [string][in] */ LPCWSTR pszSubKey);
        
        HRESULT ( STDMETHODCALLTYPE *UsePidl )( 
            IMruPidlList * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [out] */ DWORD *pdwSlot);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPidl )( 
            IMruPidlList * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ DWORD cSlots,
            /* [length_is][size_is][out] */ DWORD *rgdwSlots,
            /* [out] */ DWORD *pcSlotsFetched);
        
        HRESULT ( STDMETHODCALLTYPE *PruneKids )( 
            IMruPidlList * This,
            /* [in] */ LPCITEMIDLIST pidl);
        
        END_INTERFACE
    } IMruPidlListVtbl;

    interface IMruPidlList
    {
        CONST_VTBL struct IMruPidlListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMruPidlList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMruPidlList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMruPidlList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMruPidlList_InitList(This,uMax,hKey,pszSubKey)	\
    (This)->lpVtbl -> InitList(This,uMax,hKey,pszSubKey)

#define IMruPidlList_UsePidl(This,pidl,pdwSlot)	\
    (This)->lpVtbl -> UsePidl(This,pidl,pdwSlot)

#define IMruPidlList_QueryPidl(This,pidl,cSlots,rgdwSlots,pcSlotsFetched)	\
    (This)->lpVtbl -> QueryPidl(This,pidl,cSlots,rgdwSlots,pcSlotsFetched)

#define IMruPidlList_PruneKids(This,pidl)	\
    (This)->lpVtbl -> PruneKids(This,pidl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMruPidlList_InitList_Proxy( 
    IMruPidlList * This,
    /* [in] */ UINT uMax,
    /* [in] */ HKEY hKey,
    /* [string][in] */ LPCWSTR pszSubKey);


void __RPC_STUB IMruPidlList_InitList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMruPidlList_UsePidl_Proxy( 
    IMruPidlList * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [out] */ DWORD *pdwSlot);


void __RPC_STUB IMruPidlList_UsePidl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMruPidlList_QueryPidl_Proxy( 
    IMruPidlList * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [in] */ DWORD cSlots,
    /* [length_is][size_is][out] */ DWORD *rgdwSlots,
    /* [out] */ DWORD *pcSlotsFetched);


void __RPC_STUB IMruPidlList_QueryPidl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMruPidlList_PruneKids_Proxy( 
    IMruPidlList * This,
    /* [in] */ LPCITEMIDLIST pidl);


void __RPC_STUB IMruPidlList_PruneKids_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMruPidlList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_iepriv_0263 */
/* [local] */ 

#define NSS_DROPTARGET          0x0001      // register as a drop target
#define NSS_BROWSERSELECT       0x0002      // Use the browser style selection (see above)
#define NSS_NOHISTSELECT        0x0004      // Do not select the history entry on navigations.
#define NSS_MULTISELECT         0x0008
#define NSS_BORDER              0x0010
#define NSS_NORMALTREEVIEW      0x0020
#define NSS_HEADER              0x0040
typedef /* [public] */ 
enum __MIDL___MIDL_itf_iepriv_0263_0001
    {	MODE_NORMAL	= 0,
	MODE_CONTROL	= 0x1,
	MODE_HISTORY	= 0x2,
	MODE_FAVORITES	= 0x4,
	MODE_CUSTOM	= 0x8
    } 	nscTreeMode;



extern RPC_IF_HANDLE __MIDL_itf_iepriv_0263_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iepriv_0263_v0_0_s_ifspec;

#ifndef __INSCTree_INTERFACE_DEFINED__
#define __INSCTree_INTERFACE_DEFINED__

/* interface INSCTree */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_INSCTree;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("43A8F463-4222-11d2-B641-006097DF5BD4")
    INSCTree : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateTree( 
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwStyles,
            /* [out] */ HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCITEMIDLIST pidlRoot,
            /* [in] */ DWORD grfFlags,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowWindow( 
            /* [in] */ BOOL fShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedItem( 
            /* [out] */ LPITEMIDLIST *ppidl,
            /* [in] */ int nItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSelectedItem( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ BOOL fCreate,
            /* [in] */ BOOL fReinsert,
            /* [in] */ int nItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNscMode( 
            /* [out] */ UINT *pnMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNscMode( 
            /* [in] */ UINT nMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedItemName( 
            /* [out][in] */ LPWSTR pszName,
            /* [in] */ DWORD cchName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToSelectedItemParent( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [out] */ LPITEMIDLIST *ppidl) = 0;
        
        virtual BOOL STDMETHODCALLTYPE InLabelEdit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSCTreeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INSCTree * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INSCTree * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INSCTree * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTree )( 
            INSCTree * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwStyles,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            INSCTree * This,
            /* [in] */ LPCITEMIDLIST pidlRoot,
            /* [in] */ DWORD grfFlags,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ShowWindow )( 
            INSCTree * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            INSCTree * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedItem )( 
            INSCTree * This,
            /* [out] */ LPITEMIDLIST *ppidl,
            /* [in] */ int nItem);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelectedItem )( 
            INSCTree * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ BOOL fCreate,
            /* [in] */ BOOL fReinsert,
            /* [in] */ int nItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetNscMode )( 
            INSCTree * This,
            /* [out] */ UINT *pnMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetNscMode )( 
            INSCTree * This,
            /* [in] */ UINT nMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedItemName )( 
            INSCTree * This,
            /* [out][in] */ LPWSTR pszName,
            /* [in] */ DWORD cchName);
        
        HRESULT ( STDMETHODCALLTYPE *BindToSelectedItemParent )( 
            INSCTree * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [out] */ LPITEMIDLIST *ppidl);
        
        BOOL ( STDMETHODCALLTYPE *InLabelEdit )( 
            INSCTree * This);
        
        END_INTERFACE
    } INSCTreeVtbl;

    interface INSCTree
    {
        CONST_VTBL struct INSCTreeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSCTree_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSCTree_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSCTree_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSCTree_CreateTree(This,hwndParent,dwStyles,phwnd)	\
    (This)->lpVtbl -> CreateTree(This,hwndParent,dwStyles,phwnd)

#define INSCTree_Initialize(This,pidlRoot,grfFlags,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,pidlRoot,grfFlags,dwFlags)

#define INSCTree_ShowWindow(This,fShow)	\
    (This)->lpVtbl -> ShowWindow(This,fShow)

#define INSCTree_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define INSCTree_GetSelectedItem(This,ppidl,nItem)	\
    (This)->lpVtbl -> GetSelectedItem(This,ppidl,nItem)

#define INSCTree_SetSelectedItem(This,pidl,fCreate,fReinsert,nItem)	\
    (This)->lpVtbl -> SetSelectedItem(This,pidl,fCreate,fReinsert,nItem)

#define INSCTree_GetNscMode(This,pnMode)	\
    (This)->lpVtbl -> GetNscMode(This,pnMode)

#define INSCTree_SetNscMode(This,nMode)	\
    (This)->lpVtbl -> SetNscMode(This,nMode)

#define INSCTree_GetSelectedItemName(This,pszName,cchName)	\
    (This)->lpVtbl -> GetSelectedItemName(This,pszName,cchName)

#define INSCTree_BindToSelectedItemParent(This,riid,ppv,ppidl)	\
    (This)->lpVtbl -> BindToSelectedItemParent(This,riid,ppv,ppidl)

#define INSCTree_InLabelEdit(This)	\
    (This)->lpVtbl -> InLabelEdit(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSCTree_CreateTree_Proxy( 
    INSCTree * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwStyles,
    /* [out] */ HWND *phwnd);


void __RPC_STUB INSCTree_CreateTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSCTree_Initialize_Proxy( 
    INSCTree * This,
    /* [in] */ LPCITEMIDLIST pidlRoot,
    /* [in] */ DWORD grfFlags,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB INSCTree_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSCTree_ShowWindow_Proxy( 
    INSCTree * This,
    /* [in] */ BOOL fShow);


void __RPC_STUB INSCTree_ShowWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSCTree_Refresh_Proxy( 
    INSCTree * This);


void __RPC_STUB INSCTree_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSCTree_GetSelectedItem_Proxy( 
    INSCTree * This,
    /* [out] */ LPITEMIDLIST *ppidl,
    /* [in] */ int nItem);


void __RPC_STUB INSCTree_GetSelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSCTree_SetSelectedItem_Proxy( 
    INSCTree * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [in] */ BOOL fCreate,
    /* [in] */ BOOL fReinsert,
    /* [in] */ int nItem);


void __RPC_STUB INSCTree_SetSelectedItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSCTree_GetNscMode_Proxy( 
    INSCTree * This,
    /* [out] */ UINT *pnMode);


void __RPC_STUB INSCTree_GetNscMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSCTree_SetNscMode_Proxy( 
    INSCTree * This,
    /* [in] */ UINT nMode);


void __RPC_STUB INSCTree_SetNscMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSCTree_GetSelectedItemName_Proxy( 
    INSCTree * This,
    /* [out][in] */ LPWSTR pszName,
    /* [in] */ DWORD cchName);


void __RPC_STUB INSCTree_GetSelectedItemName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSCTree_BindToSelectedItemParent_Proxy( 
    INSCTree * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppv,
    /* [out] */ LPITEMIDLIST *ppidl);


void __RPC_STUB INSCTree_BindToSelectedItemParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


BOOL STDMETHODCALLTYPE INSCTree_InLabelEdit_Proxy( 
    INSCTree * This);


void __RPC_STUB INSCTree_InLabelEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSCTree_INTERFACE_DEFINED__ */


#ifndef __INSCTree2_INTERFACE_DEFINED__
#define __INSCTree2_INTERFACE_DEFINED__

/* interface INSCTree2 */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_INSCTree2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("801C1AD5-C47C-428c-97AF-E991E4857D97")
    INSCTree2 : public INSCTree
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RightPaneNavigationStarted( 
            /* [in] */ LPITEMIDLIST pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RightPaneNavigationFinished( 
            /* [in] */ LPITEMIDLIST pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTree2( 
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwStyle,
            /* [in] */ DWORD dwExStyle,
            /* [out] */ HWND *phwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INSCTree2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INSCTree2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INSCTree2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INSCTree2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTree )( 
            INSCTree2 * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwStyles,
            /* [out] */ HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            INSCTree2 * This,
            /* [in] */ LPCITEMIDLIST pidlRoot,
            /* [in] */ DWORD grfFlags,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ShowWindow )( 
            INSCTree2 * This,
            /* [in] */ BOOL fShow);
        
        HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            INSCTree2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedItem )( 
            INSCTree2 * This,
            /* [out] */ LPITEMIDLIST *ppidl,
            /* [in] */ int nItem);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelectedItem )( 
            INSCTree2 * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ BOOL fCreate,
            /* [in] */ BOOL fReinsert,
            /* [in] */ int nItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetNscMode )( 
            INSCTree2 * This,
            /* [out] */ UINT *pnMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetNscMode )( 
            INSCTree2 * This,
            /* [in] */ UINT nMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedItemName )( 
            INSCTree2 * This,
            /* [out][in] */ LPWSTR pszName,
            /* [in] */ DWORD cchName);
        
        HRESULT ( STDMETHODCALLTYPE *BindToSelectedItemParent )( 
            INSCTree2 * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppv,
            /* [out] */ LPITEMIDLIST *ppidl);
        
        BOOL ( STDMETHODCALLTYPE *InLabelEdit )( 
            INSCTree2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RightPaneNavigationStarted )( 
            INSCTree2 * This,
            /* [in] */ LPITEMIDLIST pidl);
        
        HRESULT ( STDMETHODCALLTYPE *RightPaneNavigationFinished )( 
            INSCTree2 * This,
            /* [in] */ LPITEMIDLIST pidl);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTree2 )( 
            INSCTree2 * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwStyle,
            /* [in] */ DWORD dwExStyle,
            /* [out] */ HWND *phwnd);
        
        END_INTERFACE
    } INSCTree2Vtbl;

    interface INSCTree2
    {
        CONST_VTBL struct INSCTree2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INSCTree2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INSCTree2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INSCTree2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INSCTree2_CreateTree(This,hwndParent,dwStyles,phwnd)	\
    (This)->lpVtbl -> CreateTree(This,hwndParent,dwStyles,phwnd)

#define INSCTree2_Initialize(This,pidlRoot,grfFlags,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,pidlRoot,grfFlags,dwFlags)

#define INSCTree2_ShowWindow(This,fShow)	\
    (This)->lpVtbl -> ShowWindow(This,fShow)

#define INSCTree2_Refresh(This)	\
    (This)->lpVtbl -> Refresh(This)

#define INSCTree2_GetSelectedItem(This,ppidl,nItem)	\
    (This)->lpVtbl -> GetSelectedItem(This,ppidl,nItem)

#define INSCTree2_SetSelectedItem(This,pidl,fCreate,fReinsert,nItem)	\
    (This)->lpVtbl -> SetSelectedItem(This,pidl,fCreate,fReinsert,nItem)

#define INSCTree2_GetNscMode(This,pnMode)	\
    (This)->lpVtbl -> GetNscMode(This,pnMode)

#define INSCTree2_SetNscMode(This,nMode)	\
    (This)->lpVtbl -> SetNscMode(This,nMode)

#define INSCTree2_GetSelectedItemName(This,pszName,cchName)	\
    (This)->lpVtbl -> GetSelectedItemName(This,pszName,cchName)

#define INSCTree2_BindToSelectedItemParent(This,riid,ppv,ppidl)	\
    (This)->lpVtbl -> BindToSelectedItemParent(This,riid,ppv,ppidl)

#define INSCTree2_InLabelEdit(This)	\
    (This)->lpVtbl -> InLabelEdit(This)


#define INSCTree2_RightPaneNavigationStarted(This,pidl)	\
    (This)->lpVtbl -> RightPaneNavigationStarted(This,pidl)

#define INSCTree2_RightPaneNavigationFinished(This,pidl)	\
    (This)->lpVtbl -> RightPaneNavigationFinished(This,pidl)

#define INSCTree2_CreateTree2(This,hwndParent,dwStyle,dwExStyle,phwnd)	\
    (This)->lpVtbl -> CreateTree2(This,hwndParent,dwStyle,dwExStyle,phwnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INSCTree2_RightPaneNavigationStarted_Proxy( 
    INSCTree2 * This,
    /* [in] */ LPITEMIDLIST pidl);


void __RPC_STUB INSCTree2_RightPaneNavigationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSCTree2_RightPaneNavigationFinished_Proxy( 
    INSCTree2 * This,
    /* [in] */ LPITEMIDLIST pidl);


void __RPC_STUB INSCTree2_RightPaneNavigationFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INSCTree2_CreateTree2_Proxy( 
    INSCTree2 * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwStyle,
    /* [in] */ DWORD dwExStyle,
    /* [out] */ HWND *phwnd);


void __RPC_STUB INSCTree2_CreateTree2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INSCTree2_INTERFACE_DEFINED__ */


#ifndef __INotifyAppStart_INTERFACE_DEFINED__
#define __INotifyAppStart_INTERFACE_DEFINED__

/* interface INotifyAppStart */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_INotifyAppStart;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3a77ce00-6f74-4594-9399-c4578aa4a1b6")
    INotifyAppStart : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AppStarting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppStarted( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INotifyAppStartVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INotifyAppStart * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INotifyAppStart * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INotifyAppStart * This);
        
        HRESULT ( STDMETHODCALLTYPE *AppStarting )( 
            INotifyAppStart * This);
        
        HRESULT ( STDMETHODCALLTYPE *AppStarted )( 
            INotifyAppStart * This);
        
        END_INTERFACE
    } INotifyAppStartVtbl;

    interface INotifyAppStart
    {
        CONST_VTBL struct INotifyAppStartVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INotifyAppStart_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INotifyAppStart_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INotifyAppStart_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INotifyAppStart_AppStarting(This)	\
    (This)->lpVtbl -> AppStarting(This)

#define INotifyAppStart_AppStarted(This)	\
    (This)->lpVtbl -> AppStarted(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INotifyAppStart_AppStarting_Proxy( 
    INotifyAppStart * This);


void __RPC_STUB INotifyAppStart_AppStarting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INotifyAppStart_AppStarted_Proxy( 
    INotifyAppStart * This);


void __RPC_STUB INotifyAppStart_AppStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INotifyAppStart_INTERFACE_DEFINED__ */


#ifndef __IInitViewLinkedWebOC_INTERFACE_DEFINED__
#define __IInitViewLinkedWebOC_INTERFACE_DEFINED__

/* interface IInitViewLinkedWebOC */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IInitViewLinkedWebOC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e787f2c0-3d21-4d98-85c8-a038195ba649")
    IInitViewLinkedWebOC : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetViewLinkedWebOC( 
            /* [in] */ BOOL bValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsViewLinkedWebOC( 
            /* [out] */ BOOL *pbValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetViewLinkedWebOCFrame( 
            /* [in] */ IDispatch *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetViewLinkedWebOCFrame( 
            /* [out] */ IDispatch **punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFrameName( 
            /* [in] */ BSTR bstrFrameName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitViewLinkedWebOCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInitViewLinkedWebOC * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInitViewLinkedWebOC * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInitViewLinkedWebOC * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewLinkedWebOC )( 
            IInitViewLinkedWebOC * This,
            /* [in] */ BOOL bValue);
        
        HRESULT ( STDMETHODCALLTYPE *IsViewLinkedWebOC )( 
            IInitViewLinkedWebOC * This,
            /* [out] */ BOOL *pbValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetViewLinkedWebOCFrame )( 
            IInitViewLinkedWebOC * This,
            /* [in] */ IDispatch *punk);
        
        HRESULT ( STDMETHODCALLTYPE *GetViewLinkedWebOCFrame )( 
            IInitViewLinkedWebOC * This,
            /* [out] */ IDispatch **punk);
        
        HRESULT ( STDMETHODCALLTYPE *SetFrameName )( 
            IInitViewLinkedWebOC * This,
            /* [in] */ BSTR bstrFrameName);
        
        END_INTERFACE
    } IInitViewLinkedWebOCVtbl;

    interface IInitViewLinkedWebOC
    {
        CONST_VTBL struct IInitViewLinkedWebOCVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitViewLinkedWebOC_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInitViewLinkedWebOC_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInitViewLinkedWebOC_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInitViewLinkedWebOC_SetViewLinkedWebOC(This,bValue)	\
    (This)->lpVtbl -> SetViewLinkedWebOC(This,bValue)

#define IInitViewLinkedWebOC_IsViewLinkedWebOC(This,pbValue)	\
    (This)->lpVtbl -> IsViewLinkedWebOC(This,pbValue)

#define IInitViewLinkedWebOC_SetViewLinkedWebOCFrame(This,punk)	\
    (This)->lpVtbl -> SetViewLinkedWebOCFrame(This,punk)

#define IInitViewLinkedWebOC_GetViewLinkedWebOCFrame(This,punk)	\
    (This)->lpVtbl -> GetViewLinkedWebOCFrame(This,punk)

#define IInitViewLinkedWebOC_SetFrameName(This,bstrFrameName)	\
    (This)->lpVtbl -> SetFrameName(This,bstrFrameName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInitViewLinkedWebOC_SetViewLinkedWebOC_Proxy( 
    IInitViewLinkedWebOC * This,
    /* [in] */ BOOL bValue);


void __RPC_STUB IInitViewLinkedWebOC_SetViewLinkedWebOC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitViewLinkedWebOC_IsViewLinkedWebOC_Proxy( 
    IInitViewLinkedWebOC * This,
    /* [out] */ BOOL *pbValue);


void __RPC_STUB IInitViewLinkedWebOC_IsViewLinkedWebOC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitViewLinkedWebOC_SetViewLinkedWebOCFrame_Proxy( 
    IInitViewLinkedWebOC * This,
    /* [in] */ IDispatch *punk);


void __RPC_STUB IInitViewLinkedWebOC_SetViewLinkedWebOCFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitViewLinkedWebOC_GetViewLinkedWebOCFrame_Proxy( 
    IInitViewLinkedWebOC * This,
    /* [out] */ IDispatch **punk);


void __RPC_STUB IInitViewLinkedWebOC_GetViewLinkedWebOCFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInitViewLinkedWebOC_SetFrameName_Proxy( 
    IInitViewLinkedWebOC * This,
    /* [in] */ BSTR bstrFrameName);


void __RPC_STUB IInitViewLinkedWebOC_SetFrameName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInitViewLinkedWebOC_INTERFACE_DEFINED__ */


#ifndef __INamespaceProxy_INTERFACE_DEFINED__
#define __INamespaceProxy_INTERFACE_DEFINED__

/* interface INamespaceProxy */
/* [local][object][uuid][helpstring] */ 


EXTERN_C const IID IID_INamespaceProxy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CF1609EC-FA4B-4818-AB01-55643367E66D")
    INamespaceProxy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNavigateTarget( 
            LPCITEMIDLIST pidl,
            LPITEMIDLIST *ppidlTarget,
            ULONG *pulAttrib) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invoke( 
            LPCITEMIDLIST pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnSelectionChanged( 
            LPCITEMIDLIST pidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RefreshFlags( 
            DWORD *pdwStyle,
            DWORD *pdwExStyle,
            DWORD *dwEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CacheItem( 
            LPCITEMIDLIST pidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INamespaceProxyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INamespaceProxy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INamespaceProxy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INamespaceProxy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNavigateTarget )( 
            INamespaceProxy * This,
            LPCITEMIDLIST pidl,
            LPITEMIDLIST *ppidlTarget,
            ULONG *pulAttrib);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INamespaceProxy * This,
            LPCITEMIDLIST pidl);
        
        HRESULT ( STDMETHODCALLTYPE *OnSelectionChanged )( 
            INamespaceProxy * This,
            LPCITEMIDLIST pidl);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshFlags )( 
            INamespaceProxy * This,
            DWORD *pdwStyle,
            DWORD *pdwExStyle,
            DWORD *dwEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CacheItem )( 
            INamespaceProxy * This,
            LPCITEMIDLIST pidl);
        
        END_INTERFACE
    } INamespaceProxyVtbl;

    interface INamespaceProxy
    {
        CONST_VTBL struct INamespaceProxyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INamespaceProxy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INamespaceProxy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INamespaceProxy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INamespaceProxy_GetNavigateTarget(This,pidl,ppidlTarget,pulAttrib)	\
    (This)->lpVtbl -> GetNavigateTarget(This,pidl,ppidlTarget,pulAttrib)

#define INamespaceProxy_Invoke(This,pidl)	\
    (This)->lpVtbl -> Invoke(This,pidl)

#define INamespaceProxy_OnSelectionChanged(This,pidl)	\
    (This)->lpVtbl -> OnSelectionChanged(This,pidl)

#define INamespaceProxy_RefreshFlags(This,pdwStyle,pdwExStyle,dwEnum)	\
    (This)->lpVtbl -> RefreshFlags(This,pdwStyle,pdwExStyle,dwEnum)

#define INamespaceProxy_CacheItem(This,pidl)	\
    (This)->lpVtbl -> CacheItem(This,pidl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INamespaceProxy_GetNavigateTarget_Proxy( 
    INamespaceProxy * This,
    LPCITEMIDLIST pidl,
    LPITEMIDLIST *ppidlTarget,
    ULONG *pulAttrib);


void __RPC_STUB INamespaceProxy_GetNavigateTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INamespaceProxy_Invoke_Proxy( 
    INamespaceProxy * This,
    LPCITEMIDLIST pidl);


void __RPC_STUB INamespaceProxy_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INamespaceProxy_OnSelectionChanged_Proxy( 
    INamespaceProxy * This,
    LPCITEMIDLIST pidl);


void __RPC_STUB INamespaceProxy_OnSelectionChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INamespaceProxy_RefreshFlags_Proxy( 
    INamespaceProxy * This,
    DWORD *pdwStyle,
    DWORD *pdwExStyle,
    DWORD *dwEnum);


void __RPC_STUB INamespaceProxy_RefreshFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INamespaceProxy_CacheItem_Proxy( 
    INamespaceProxy * This,
    LPCITEMIDLIST pidl);


void __RPC_STUB INamespaceProxy_CacheItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INamespaceProxy_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_iepriv_0268 */
/* [local] */ 

// INTERFACE: IBrowserFrameOptions
//
// This interface was implemented so a browser or host can ask a ShellView/ShelNameSpace what
// kind of 'Behavior' is appropriate for that view.  These are normally PM type decisions to
// refine the user experience.
// 
// For example, should the IE globe be added to the toolbar
// when the view is a HTTP web page? (Yes)  When the view is a FTP Folders?  When the view
// is the file system? (No) When the view is Web Folders? (Maybe, did you as a PM?)
// It's very important for the view to ask the NSE if it does or doesn't want the behavior instead of
// trying to sniff the pidl and guess.  An example of this kind of bad coding style is all the
// code that calls IsURLChild().  Currently we have a lot of hacky code that says turn such-and-such
// behavior on for HTTP and FTP URLs but not Web Folders and not ABOUT URLs, so it's very important to
// use this interface to do the work for you.  This will also allow Web Folders to fix a lot of bugs because
// the code hasn't yet been 'tweaked' to give the behavior Web Folders wants.
//
//    IBrowserFrameOptions::GetBrowserOptions()
//       dwMask is the logical OR of bits to look for.  pdwOptions is not optional and
//       it's return value will always equal or will be a subset of dwMask.
//       If the function succeeds, the return value must be S_OK and pdwOptions needs to be filled in.
//       If the function fails, pdwOptions needs to be filled in with BFO_NONE.
//
// NOTE: The definition of the bit needs to be OFF for the most common NSE.  This way shell name space
//       extensions that don't implement this interface or haven't been updated to handle this bit will
//       default to behavior that is the most common.  An example of this is the BFO_NO_FOLDER_OPTIONS
//       where this bit off will give the 'Folder Options', which is the most common case.  This is especially
//       true since this interface is internal only.


extern RPC_IF_HANDLE __MIDL_itf_iepriv_0268_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iepriv_0268_v0_0_s_ifspec;

#ifndef __IBrowserFrameOptions_INTERFACE_DEFINED__
#define __IBrowserFrameOptions_INTERFACE_DEFINED__

/* interface IBrowserFrameOptions */
/* [local][object][uuid] */ 

typedef /* [unique] */ IBrowserFrameOptions *LPBROWSERFRAMEOPTIONS;


enum __MIDL_IBrowserFrameOptions_0001
    {	BFO_NONE	= 0,
	BFO_BROWSER_PERSIST_SETTINGS	= 0x1,
	BFO_RENAME_FOLDER_OPTIONS_TOINTERNET	= 0x2,
	BFO_BOTH_OPTIONS	= 0x4,
	BIF_PREFER_INTERNET_SHORTCUT	= 0x8,
	BFO_BROWSE_NO_IN_NEW_PROCESS	= 0x10,
	BFO_ENABLE_HYPERLINK_TRACKING	= 0x20,
	BFO_USE_IE_OFFLINE_SUPPORT	= 0x40,
	BFO_SUBSTITUE_INTERNET_START_PAGE	= 0x80,
	BFO_USE_IE_LOGOBANDING	= 0x100,
	BFO_ADD_IE_TOCAPTIONBAR	= 0x200,
	BFO_USE_DIALUP_REF	= 0x400,
	BFO_USE_IE_TOOLBAR	= 0x800,
	BFO_NO_PARENT_FOLDER_SUPPORT	= 0x1000,
	BFO_NO_REOPEN_NEXT_RESTART	= 0x2000,
	BFO_GO_HOME_PAGE	= 0x4000,
	BFO_PREFER_IEPROCESS	= 0x8000,
	BFO_SHOW_NAVIGATION_CANCELLED	= 0x10000,
	BFO_QUERY_ALL	= 0xffffffff
    } ;
typedef DWORD BROWSERFRAMEOPTIONS;


EXTERN_C const IID IID_IBrowserFrameOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10DF43C8-1DBE-11d3-8B34-006097DF5BD4")
    IBrowserFrameOptions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrameOptions( 
            /* [in] */ BROWSERFRAMEOPTIONS dwMask,
            /* [out] */ BROWSERFRAMEOPTIONS *pdwOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBrowserFrameOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBrowserFrameOptions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBrowserFrameOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBrowserFrameOptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameOptions )( 
            IBrowserFrameOptions * This,
            /* [in] */ BROWSERFRAMEOPTIONS dwMask,
            /* [out] */ BROWSERFRAMEOPTIONS *pdwOptions);
        
        END_INTERFACE
    } IBrowserFrameOptionsVtbl;

    interface IBrowserFrameOptions
    {
        CONST_VTBL struct IBrowserFrameOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBrowserFrameOptions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBrowserFrameOptions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBrowserFrameOptions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBrowserFrameOptions_GetFrameOptions(This,dwMask,pdwOptions)	\
    (This)->lpVtbl -> GetFrameOptions(This,dwMask,pdwOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBrowserFrameOptions_GetFrameOptions_Proxy( 
    IBrowserFrameOptions * This,
    /* [in] */ BROWSERFRAMEOPTIONS dwMask,
    /* [out] */ BROWSERFRAMEOPTIONS *pdwOptions);


void __RPC_STUB IBrowserFrameOptions_GetFrameOptions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBrowserFrameOptions_INTERFACE_DEFINED__ */


#ifndef __ISearchCompanionInfo_INTERFACE_DEFINED__
#define __ISearchCompanionInfo_INTERFACE_DEFINED__

/* interface ISearchCompanionInfo */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_ISearchCompanionInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DB5CEF35-BEC6-4762-A1BD-253F5BF67C72")
    ISearchCompanionInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsSearchCompanionInetAvailable( 
            /* [out] */ BOOL *pfAvailable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISearchCompanionInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISearchCompanionInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISearchCompanionInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISearchCompanionInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSearchCompanionInetAvailable )( 
            ISearchCompanionInfo * This,
            /* [out] */ BOOL *pfAvailable);
        
        END_INTERFACE
    } ISearchCompanionInfoVtbl;

    interface ISearchCompanionInfo
    {
        CONST_VTBL struct ISearchCompanionInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISearchCompanionInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISearchCompanionInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISearchCompanionInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISearchCompanionInfo_IsSearchCompanionInetAvailable(This,pfAvailable)	\
    (This)->lpVtbl -> IsSearchCompanionInetAvailable(This,pfAvailable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISearchCompanionInfo_IsSearchCompanionInetAvailable_Proxy( 
    ISearchCompanionInfo * This,
    /* [out] */ BOOL *pfAvailable);


void __RPC_STUB ISearchCompanionInfo_IsSearchCompanionInetAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISearchCompanionInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_iepriv_0270 */
/* [local] */ 

#include <pshpack8.h>
typedef struct tagSMDATA
    {
    DWORD dwMask;
    DWORD dwFlags;
    HMENU hmenu;
    HWND hwnd;
    UINT uId;
    UINT uIdParent;
    UINT uIdAncestor;
    IUnknown *punk;
    LPITEMIDLIST pidlFolder;
    LPITEMIDLIST pidlItem;
    IShellFolder *psf;
    void *pvUserData;
    } 	SMDATA;

typedef struct tagSMDATA *LPSMDATA;

// Mask
#define SMDM_SHELLFOLDER               0x00000001  // This is for an item in the band
#define SMDM_HMENU                     0x00000002  // This is for the Band itself
#define SMDM_TOOLBAR                   0x00000004  // Plain toolbar, not associated with a shell folder or hmenu
// Flags (bitmask)
typedef struct tagSMINFO
    {
    DWORD dwMask;
    DWORD dwType;
    DWORD dwFlags;
    int iIcon;
    } 	SMINFO;

typedef struct tagSMINFO *PSMINFO;

typedef struct tagSHCSCHANGENOTIFYSTRUCT
    {
    LONG lEvent;
    LPCITEMIDLIST pidl1;
    LPCITEMIDLIST pidl2;
    } 	SMCSHCHANGENOTIFYSTRUCT;

typedef struct tagSHCSCHANGENOTIFYSTRUCT *PSMCSHCHANGENOTIFYSTRUCT;

#include <poppack.h>

enum __MIDL___MIDL_itf_iepriv_0270_0001
    {	SMIM_TYPE	= 0x1,
	SMIM_FLAGS	= 0x2,
	SMIM_ICON	= 0x4
    } ;

enum __MIDL___MIDL_itf_iepriv_0270_0002
    {	SMIT_SEPARATOR	= 0x1,
	SMIT_STRING	= 0x2
    } ;

enum __MIDL___MIDL_itf_iepriv_0270_0003
    {	SMIF_ICON	= 0x1,
	SMIF_ACCELERATOR	= 0x2,
	SMIF_DROPTARGET	= 0x4,
	SMIF_SUBMENU	= 0x8,
	SMIF_VOLATILE	= 0x10,
	SMIF_CHECKED	= 0x20,
	SMIF_DROPCASCADE	= 0x40,
	SMIF_HIDDEN	= 0x80,
	SMIF_DISABLED	= 0x100,
	SMIF_TRACKPOPUP	= 0x200,
	SMIF_DEMOTED	= 0x400,
	SMIF_ALTSTATE	= 0x800,
	SMIF_DRAGNDROP	= 0x1000,
	SMIF_NEW	= 0x2000
    } ;
#define SMC_INITMENU            0x00000001  // The callback is called to init a menuband
#define SMC_CREATE              0x00000002
#define SMC_EXITMENU            0x00000003  // The callback is called when menu is collapsing
#define SMC_EXEC                0x00000004  // The callback is called to execute an item
#define SMC_GETINFO             0x00000005  // The callback is called to return DWORD values
#define SMC_GETSFINFO           0x00000006  // The callback is called to return DWORD values
#define SMC_GETOBJECT           0x00000007  // The callback is called to get some object
#define SMC_GETSFOBJECT         0x00000008  // The callback is called to get some object
#define SMC_SFEXEC              0x00000009  // The callback is called to execute an shell folder item
#define SMC_SFSELECTITEM        0x0000000A  // The callback is called when an item is selected
#define SMC_SELECTITEM          0x0000000B  // The callback is called when an item is selected
#define SMC_GETSFINFOTIP        0x0000000C  // The callback is called to get some object
#define SMC_GETINFOTIP          0x0000000D  // The callback is called to get some object
#define SMC_INSERTINDEX         0x0000000E  // New item insert index
#define SMC_POPUP               0x0000000F  // InitMenu/InitMenuPopup (sort of)
#define SMC_REFRESH             0x00000010  // Menus have completely refreshed. Reset your state.
#define SMC_DEMOTE              0x00000011  // Demote an item
#define SMC_PROMOTE             0x00000012  // Promote an item, wParam = SMINV_* flag
#define SMC_BEGINENUM           0x00000013  // tell callback that we are beginning to ENUM the indicated parent
#define SMC_ENDENUM             0x00000014  // tell callback that we are ending the ENUM of the indicated paren
#define SMC_MAPACCELERATOR      0x00000015  // Called when processing an accelerator.
#define SMC_DEFAULTICON         0x00000016  // Returns Default icon location in wParam, index in lParam
#define SMC_NEWITEM             0x00000017  // Notifies item is not in the order stream.
#define SMC_GETMINPROMOTED      0x00000018  // Returns the minimum number of promoted items
#define SMC_CHEVRONEXPAND       0x00000019  // Notifies of a expansion via the chevron
#define SMC_DISPLAYCHEVRONTIP   0x0000002A  // S_OK display, S_FALSE not.
#define SMC_DESTROY             0x0000002B  // Called when a pane is being destroyed.
#define SMC_SETOBJECT           0x0000002C  // Called to save the passed object
#define SMC_SETSFOBJECT         0x0000002D  // Called to save the passed object
#define SMC_SHCHANGENOTIFY      0x0000002E  // Called when a Change notify is received. lParam points to SMCSHCHANGENOTIFYSTRUCT
#define SMC_CHEVRONGETTIP       0x0000002F  // Called to get the chevron tip text. wParam = Tip title, Lparam = TipText Both MAX_PATH
#define SMC_SFDDRESTRICTED      0x00000030  // Called requesting if it's ok to drop. wParam = IDropTarget.
#define SMC_GETIMAGELISTS       0x00000031  // Called to get the small & large icon image lists, otherwise it will default to shell image list
#define SMC_CUSTOMDRAW          0x00000032  // Requires SMINIT_CUSTOMDRAW
#define SMC_BEGINDRAG           0x00000033  // Called to get preferred drop effect. wParam = &pdwEffect
#define SMC_MOUSEFILTER         0x00000034  // Called to allow host to filter mouse messages. wParam=bRemove, lParam=pmsg
#define SMC_DUMPONUPDATE        0x00000035  // S_OK if host wants old trash-everything-on-update behavior (recent docs)

#define SMC_FILTERPIDL          0x10000000  // The callback is called to see if an item is visible
#define SMC_CALLBACKMASK        0xF0000000  // Mask of comutationally intense messages


extern RPC_IF_HANDLE __MIDL_itf_iepriv_0270_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iepriv_0270_v0_0_s_ifspec;

#ifndef __IShellMenuCallback_INTERFACE_DEFINED__
#define __IShellMenuCallback_INTERFACE_DEFINED__

/* interface IShellMenuCallback */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IShellMenuCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4CA300A1-9B8D-11d1-8B22-00C04FD918D0")
    IShellMenuCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallbackSM( 
            /* [out][in] */ LPSMDATA psmd,
            UINT uMsg,
            WPARAM wParam,
            LPARAM lParam) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellMenuCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellMenuCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellMenuCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellMenuCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *CallbackSM )( 
            IShellMenuCallback * This,
            /* [out][in] */ LPSMDATA psmd,
            UINT uMsg,
            WPARAM wParam,
            LPARAM lParam);
        
        END_INTERFACE
    } IShellMenuCallbackVtbl;

    interface IShellMenuCallback
    {
        CONST_VTBL struct IShellMenuCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellMenuCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellMenuCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellMenuCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellMenuCallback_CallbackSM(This,psmd,uMsg,wParam,lParam)	\
    (This)->lpVtbl -> CallbackSM(This,psmd,uMsg,wParam,lParam)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellMenuCallback_CallbackSM_Proxy( 
    IShellMenuCallback * This,
    /* [out][in] */ LPSMDATA psmd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);


void __RPC_STUB IShellMenuCallback_CallbackSM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellMenuCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_iepriv_0271 */
/* [local] */ 

#define SMINIT_DEFAULT              0x00000000  // No Options
#define SMINIT_RESTRICT_CONTEXTMENU 0x00000001  // Don't allow Context Menus
#define SMINIT_RESTRICT_DRAGDROP    0x00000002  // Don't allow Drag and Drop
#define SMINIT_TOPLEVEL             0x00000004  // This is the top band.
#define SMINIT_DEFAULTTOTRACKPOPUP  0x00000008  // When no callback is specified, 
#define SMINIT_CACHED               0x00000010
#define SMINIT_USEMESSAGEFILTER     0x00000020
#define SMINIT_LEGACYMENU           0x00000040  // Old Menu behaviour.
#define SMINIT_CUSTOMDRAW           0x00000080   // Send SMC_CUSTOMDRAW
#define SMINIT_NOSETSITE            0x00010000  // Internal setting
#define SMINIT_VERTICAL             0x10000000  // This is a vertical menu
#define SMINIT_HORIZONTAL           0x20000000  // This is a horizontal menu    (does not inherit)
#define SMINIT_MULTICOLUMN          0x40000000  // this is a multi column menu
#define ANCESTORDEFAULT      (UINT)-1
#define SMSET_TOP                   0x10000000    // Bias this namespace to the top of the menu
#define SMSET_BOTTOM                0x20000000    // Bias this namespace to the bottom of the menu
#define SMSET_DONTOWN               0x00000001    // The Menuband doesn't own the non-ref counted object
#define SMSET_MERGE                 0x00000002
#define SMSET_NOEMPTY               0x00000004   // Dont show (Empty) on shell folder
#define SMSET_USEBKICONEXTRACTION   0x00000008   // Use the background icon extractor
#define SMSET_HASEXPANDABLEFOLDERS  0x00000010   // Need to call SHIsExpandableFolder
#define SMSET_DONTREGISTERCHANGENOTIFY 0x00000020 // ShellFolder is a discontiguous child of a parent shell folder
#define SMSET_COLLAPSEONEMPTY       0x00000040   // When Empty, causes a menus to collapse
#define SMSET_USEPAGER              0x00000080    //Enable pagers in static menus
#define SMSET_NOPREFIX              0x00000100    //Enable ampersand in static menus
#define SMSET_SEPARATEMERGEFOLDER   0x00000200    //Insert separator when MergedFolder host changes
#define SMINV_REFRESH        0x00000001
#define SMINV_ICON           0x00000002
#define SMINV_POSITION       0x00000004
#define SMINV_ID             0x00000008
#define SMINV_NEXTSHOW       0x00000010       // Does Invalidates on next show.
#define SMINV_PROMOTE        0x00000020       // Does Invalidates on next show.
#define SMINV_DEMOTE         0x00000040       // Does Invalidates on next show.
#define SMINV_FORCE          0x00000080
#define SMINV_NOCALLBACK     0x00000100       // Invalidates, but does not call the callback.
#define SMINV_INITMENU       0x00000200       // Call callback's SMC_INITMENU as part of invalidate (Whistler)


extern RPC_IF_HANDLE __MIDL_itf_iepriv_0271_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iepriv_0271_v0_0_s_ifspec;

#ifndef __IShellMenu_INTERFACE_DEFINED__
#define __IShellMenu_INTERFACE_DEFINED__

/* interface IShellMenu */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IShellMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE1F7637-E138-11d1-8379-00C04FD918D0")
    IShellMenu : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IShellMenuCallback *psmc,
            UINT uId,
            UINT uIdAncestor,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenuInfo( 
            /* [out] */ IShellMenuCallback **ppsmc,
            /* [out] */ UINT *puId,
            /* [out] */ UINT *puIdAncestor,
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetShellFolder( 
            IShellFolder *psf,
            /* [in] */ LPCITEMIDLIST pidlFolder,
            HKEY hKey,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetShellFolder( 
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ LPITEMIDLIST *ppidl,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMenu( 
            /* [in] */ HMENU hmenu,
            /* [in] */ HWND hwnd,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMenu( 
            /* [out] */ HMENU *phmenu,
            /* [out] */ HWND *phwnd,
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateItem( 
            /* [in] */ LPSMDATA psmd,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            /* [out] */ LPSMDATA psmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMenuToolbar( 
            /* [in] */ IUnknown *punk,
            DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellMenu * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellMenu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellMenu * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IShellMenu * This,
            /* [in] */ IShellMenuCallback *psmc,
            UINT uId,
            UINT uIdAncestor,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuInfo )( 
            IShellMenu * This,
            /* [out] */ IShellMenuCallback **ppsmc,
            /* [out] */ UINT *puId,
            /* [out] */ UINT *puIdAncestor,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetShellFolder )( 
            IShellMenu * This,
            IShellFolder *psf,
            /* [in] */ LPCITEMIDLIST pidlFolder,
            HKEY hKey,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetShellFolder )( 
            IShellMenu * This,
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ LPITEMIDLIST *ppidl,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenu )( 
            IShellMenu * This,
            /* [in] */ HMENU hmenu,
            /* [in] */ HWND hwnd,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenu )( 
            IShellMenu * This,
            /* [out] */ HMENU *phmenu,
            /* [out] */ HWND *phwnd,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateItem )( 
            IShellMenu * This,
            /* [in] */ LPSMDATA psmd,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IShellMenu * This,
            /* [out] */ LPSMDATA psmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenuToolbar )( 
            IShellMenu * This,
            /* [in] */ IUnknown *punk,
            DWORD dwFlags);
        
        END_INTERFACE
    } IShellMenuVtbl;

    interface IShellMenu
    {
        CONST_VTBL struct IShellMenuVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellMenu_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellMenu_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellMenu_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellMenu_Initialize(This,psmc,uId,uIdAncestor,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,psmc,uId,uIdAncestor,dwFlags)

#define IShellMenu_GetMenuInfo(This,ppsmc,puId,puIdAncestor,pdwFlags)	\
    (This)->lpVtbl -> GetMenuInfo(This,ppsmc,puId,puIdAncestor,pdwFlags)

#define IShellMenu_SetShellFolder(This,psf,pidlFolder,hKey,dwFlags)	\
    (This)->lpVtbl -> SetShellFolder(This,psf,pidlFolder,hKey,dwFlags)

#define IShellMenu_GetShellFolder(This,pdwFlags,ppidl,riid,ppv)	\
    (This)->lpVtbl -> GetShellFolder(This,pdwFlags,ppidl,riid,ppv)

#define IShellMenu_SetMenu(This,hmenu,hwnd,dwFlags)	\
    (This)->lpVtbl -> SetMenu(This,hmenu,hwnd,dwFlags)

#define IShellMenu_GetMenu(This,phmenu,phwnd,pdwFlags)	\
    (This)->lpVtbl -> GetMenu(This,phmenu,phwnd,pdwFlags)

#define IShellMenu_InvalidateItem(This,psmd,dwFlags)	\
    (This)->lpVtbl -> InvalidateItem(This,psmd,dwFlags)

#define IShellMenu_GetState(This,psmd)	\
    (This)->lpVtbl -> GetState(This,psmd)

#define IShellMenu_SetMenuToolbar(This,punk,dwFlags)	\
    (This)->lpVtbl -> SetMenuToolbar(This,punk,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellMenu_Initialize_Proxy( 
    IShellMenu * This,
    /* [in] */ IShellMenuCallback *psmc,
    UINT uId,
    UINT uIdAncestor,
    DWORD dwFlags);


void __RPC_STUB IShellMenu_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellMenu_GetMenuInfo_Proxy( 
    IShellMenu * This,
    /* [out] */ IShellMenuCallback **ppsmc,
    /* [out] */ UINT *puId,
    /* [out] */ UINT *puIdAncestor,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB IShellMenu_GetMenuInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellMenu_SetShellFolder_Proxy( 
    IShellMenu * This,
    IShellFolder *psf,
    /* [in] */ LPCITEMIDLIST pidlFolder,
    HKEY hKey,
    DWORD dwFlags);


void __RPC_STUB IShellMenu_SetShellFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellMenu_GetShellFolder_Proxy( 
    IShellMenu * This,
    /* [out] */ DWORD *pdwFlags,
    /* [out] */ LPITEMIDLIST *ppidl,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IShellMenu_GetShellFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellMenu_SetMenu_Proxy( 
    IShellMenu * This,
    /* [in] */ HMENU hmenu,
    /* [in] */ HWND hwnd,
    DWORD dwFlags);


void __RPC_STUB IShellMenu_SetMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellMenu_GetMenu_Proxy( 
    IShellMenu * This,
    /* [out] */ HMENU *phmenu,
    /* [out] */ HWND *phwnd,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB IShellMenu_GetMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellMenu_InvalidateItem_Proxy( 
    IShellMenu * This,
    /* [in] */ LPSMDATA psmd,
    DWORD dwFlags);


void __RPC_STUB IShellMenu_InvalidateItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellMenu_GetState_Proxy( 
    IShellMenu * This,
    /* [out] */ LPSMDATA psmd);


void __RPC_STUB IShellMenu_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellMenu_SetMenuToolbar_Proxy( 
    IShellMenu * This,
    /* [in] */ IUnknown *punk,
    DWORD dwFlags);


void __RPC_STUB IShellMenu_SetMenuToolbar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellMenu_INTERFACE_DEFINED__ */


#ifndef __IShellMenu2_INTERFACE_DEFINED__
#define __IShellMenu2_INTERFACE_DEFINED__

/* interface IShellMenu2 */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_IShellMenu2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6f51c646-0efe-4370-882a-c1f61cb27c3b")
    IShellMenu2 : public IShellMenu
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSubMenu( 
            UINT idCmd,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetToolbar( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMinWidth( 
            /* [in] */ int cxMenu) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNoBorder( 
            /* [in] */ BOOL fNoBorder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTheme( 
            /* [string][in] */ LPCWSTR pszTheme) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellMenu2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellMenu2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellMenu2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellMenu2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IShellMenu2 * This,
            /* [in] */ IShellMenuCallback *psmc,
            UINT uId,
            UINT uIdAncestor,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuInfo )( 
            IShellMenu2 * This,
            /* [out] */ IShellMenuCallback **ppsmc,
            /* [out] */ UINT *puId,
            /* [out] */ UINT *puIdAncestor,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetShellFolder )( 
            IShellMenu2 * This,
            IShellFolder *psf,
            /* [in] */ LPCITEMIDLIST pidlFolder,
            HKEY hKey,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetShellFolder )( 
            IShellMenu2 * This,
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ LPITEMIDLIST *ppidl,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenu )( 
            IShellMenu2 * This,
            /* [in] */ HMENU hmenu,
            /* [in] */ HWND hwnd,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenu )( 
            IShellMenu2 * This,
            /* [out] */ HMENU *phmenu,
            /* [out] */ HWND *phwnd,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateItem )( 
            IShellMenu2 * This,
            /* [in] */ LPSMDATA psmd,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IShellMenu2 * This,
            /* [out] */ LPSMDATA psmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenuToolbar )( 
            IShellMenu2 * This,
            /* [in] */ IUnknown *punk,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSubMenu )( 
            IShellMenu2 * This,
            UINT idCmd,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObj);
        
        HRESULT ( STDMETHODCALLTYPE *SetToolbar )( 
            IShellMenu2 * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetMinWidth )( 
            IShellMenu2 * This,
            /* [in] */ int cxMenu);
        
        HRESULT ( STDMETHODCALLTYPE *SetNoBorder )( 
            IShellMenu2 * This,
            /* [in] */ BOOL fNoBorder);
        
        HRESULT ( STDMETHODCALLTYPE *SetTheme )( 
            IShellMenu2 * This,
            /* [string][in] */ LPCWSTR pszTheme);
        
        END_INTERFACE
    } IShellMenu2Vtbl;

    interface IShellMenu2
    {
        CONST_VTBL struct IShellMenu2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellMenu2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellMenu2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellMenu2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellMenu2_Initialize(This,psmc,uId,uIdAncestor,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,psmc,uId,uIdAncestor,dwFlags)

#define IShellMenu2_GetMenuInfo(This,ppsmc,puId,puIdAncestor,pdwFlags)	\
    (This)->lpVtbl -> GetMenuInfo(This,ppsmc,puId,puIdAncestor,pdwFlags)

#define IShellMenu2_SetShellFolder(This,psf,pidlFolder,hKey,dwFlags)	\
    (This)->lpVtbl -> SetShellFolder(This,psf,pidlFolder,hKey,dwFlags)

#define IShellMenu2_GetShellFolder(This,pdwFlags,ppidl,riid,ppv)	\
    (This)->lpVtbl -> GetShellFolder(This,pdwFlags,ppidl,riid,ppv)

#define IShellMenu2_SetMenu(This,hmenu,hwnd,dwFlags)	\
    (This)->lpVtbl -> SetMenu(This,hmenu,hwnd,dwFlags)

#define IShellMenu2_GetMenu(This,phmenu,phwnd,pdwFlags)	\
    (This)->lpVtbl -> GetMenu(This,phmenu,phwnd,pdwFlags)

#define IShellMenu2_InvalidateItem(This,psmd,dwFlags)	\
    (This)->lpVtbl -> InvalidateItem(This,psmd,dwFlags)

#define IShellMenu2_GetState(This,psmd)	\
    (This)->lpVtbl -> GetState(This,psmd)

#define IShellMenu2_SetMenuToolbar(This,punk,dwFlags)	\
    (This)->lpVtbl -> SetMenuToolbar(This,punk,dwFlags)


#define IShellMenu2_GetSubMenu(This,idCmd,riid,ppvObj)	\
    (This)->lpVtbl -> GetSubMenu(This,idCmd,riid,ppvObj)

#define IShellMenu2_SetToolbar(This,hwnd,dwFlags)	\
    (This)->lpVtbl -> SetToolbar(This,hwnd,dwFlags)

#define IShellMenu2_SetMinWidth(This,cxMenu)	\
    (This)->lpVtbl -> SetMinWidth(This,cxMenu)

#define IShellMenu2_SetNoBorder(This,fNoBorder)	\
    (This)->lpVtbl -> SetNoBorder(This,fNoBorder)

#define IShellMenu2_SetTheme(This,pszTheme)	\
    (This)->lpVtbl -> SetTheme(This,pszTheme)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellMenu2_GetSubMenu_Proxy( 
    IShellMenu2 * This,
    UINT idCmd,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvObj);


void __RPC_STUB IShellMenu2_GetSubMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellMenu2_SetToolbar_Proxy( 
    IShellMenu2 * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IShellMenu2_SetToolbar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellMenu2_SetMinWidth_Proxy( 
    IShellMenu2 * This,
    /* [in] */ int cxMenu);


void __RPC_STUB IShellMenu2_SetMinWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellMenu2_SetNoBorder_Proxy( 
    IShellMenu2 * This,
    /* [in] */ BOOL fNoBorder);


void __RPC_STUB IShellMenu2_SetNoBorder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellMenu2_SetTheme_Proxy( 
    IShellMenu2 * This,
    /* [string][in] */ LPCWSTR pszTheme);


void __RPC_STUB IShellMenu2_SetTheme_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellMenu2_INTERFACE_DEFINED__ */


#ifndef __ITrackShellMenu_INTERFACE_DEFINED__
#define __ITrackShellMenu_INTERFACE_DEFINED__

/* interface ITrackShellMenu */
/* [local][unique][object][uuid] */ 


EXTERN_C const IID IID_ITrackShellMenu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8278F932-2A3E-11d2-838F-00C04FD918D0")
    ITrackShellMenu : public IShellMenu
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetObscured( 
            /* [in] */ HWND hwndTB,
            /* [in] */ IUnknown *punkBand,
            DWORD dwSMSetFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Popup( 
            /* [in] */ HWND hwnd,
            /* [in] */ POINTL *ppt,
            /* [in] */ RECTL *prcExclude,
            DWORD dwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITrackShellMenuVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITrackShellMenu * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITrackShellMenu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITrackShellMenu * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ITrackShellMenu * This,
            /* [in] */ IShellMenuCallback *psmc,
            UINT uId,
            UINT uIdAncestor,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenuInfo )( 
            ITrackShellMenu * This,
            /* [out] */ IShellMenuCallback **ppsmc,
            /* [out] */ UINT *puId,
            /* [out] */ UINT *puIdAncestor,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetShellFolder )( 
            ITrackShellMenu * This,
            IShellFolder *psf,
            /* [in] */ LPCITEMIDLIST pidlFolder,
            HKEY hKey,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetShellFolder )( 
            ITrackShellMenu * This,
            /* [out] */ DWORD *pdwFlags,
            /* [out] */ LPITEMIDLIST *ppidl,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenu )( 
            ITrackShellMenu * This,
            /* [in] */ HMENU hmenu,
            /* [in] */ HWND hwnd,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetMenu )( 
            ITrackShellMenu * This,
            /* [out] */ HMENU *phmenu,
            /* [out] */ HWND *phwnd,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateItem )( 
            ITrackShellMenu * This,
            /* [in] */ LPSMDATA psmd,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            ITrackShellMenu * This,
            /* [out] */ LPSMDATA psmd);
        
        HRESULT ( STDMETHODCALLTYPE *SetMenuToolbar )( 
            ITrackShellMenu * This,
            /* [in] */ IUnknown *punk,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetObscured )( 
            ITrackShellMenu * This,
            /* [in] */ HWND hwndTB,
            /* [in] */ IUnknown *punkBand,
            DWORD dwSMSetFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Popup )( 
            ITrackShellMenu * This,
            /* [in] */ HWND hwnd,
            /* [in] */ POINTL *ppt,
            /* [in] */ RECTL *prcExclude,
            DWORD dwFlags);
        
        END_INTERFACE
    } ITrackShellMenuVtbl;

    interface ITrackShellMenu
    {
        CONST_VTBL struct ITrackShellMenuVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITrackShellMenu_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITrackShellMenu_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITrackShellMenu_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITrackShellMenu_Initialize(This,psmc,uId,uIdAncestor,dwFlags)	\
    (This)->lpVtbl -> Initialize(This,psmc,uId,uIdAncestor,dwFlags)

#define ITrackShellMenu_GetMenuInfo(This,ppsmc,puId,puIdAncestor,pdwFlags)	\
    (This)->lpVtbl -> GetMenuInfo(This,ppsmc,puId,puIdAncestor,pdwFlags)

#define ITrackShellMenu_SetShellFolder(This,psf,pidlFolder,hKey,dwFlags)	\
    (This)->lpVtbl -> SetShellFolder(This,psf,pidlFolder,hKey,dwFlags)

#define ITrackShellMenu_GetShellFolder(This,pdwFlags,ppidl,riid,ppv)	\
    (This)->lpVtbl -> GetShellFolder(This,pdwFlags,ppidl,riid,ppv)

#define ITrackShellMenu_SetMenu(This,hmenu,hwnd,dwFlags)	\
    (This)->lpVtbl -> SetMenu(This,hmenu,hwnd,dwFlags)

#define ITrackShellMenu_GetMenu(This,phmenu,phwnd,pdwFlags)	\
    (This)->lpVtbl -> GetMenu(This,phmenu,phwnd,pdwFlags)

#define ITrackShellMenu_InvalidateItem(This,psmd,dwFlags)	\
    (This)->lpVtbl -> InvalidateItem(This,psmd,dwFlags)

#define ITrackShellMenu_GetState(This,psmd)	\
    (This)->lpVtbl -> GetState(This,psmd)

#define ITrackShellMenu_SetMenuToolbar(This,punk,dwFlags)	\
    (This)->lpVtbl -> SetMenuToolbar(This,punk,dwFlags)


#define ITrackShellMenu_SetObscured(This,hwndTB,punkBand,dwSMSetFlags)	\
    (This)->lpVtbl -> SetObscured(This,hwndTB,punkBand,dwSMSetFlags)

#define ITrackShellMenu_Popup(This,hwnd,ppt,prcExclude,dwFlags)	\
    (This)->lpVtbl -> Popup(This,hwnd,ppt,prcExclude,dwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITrackShellMenu_SetObscured_Proxy( 
    ITrackShellMenu * This,
    /* [in] */ HWND hwndTB,
    /* [in] */ IUnknown *punkBand,
    DWORD dwSMSetFlags);


void __RPC_STUB ITrackShellMenu_SetObscured_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITrackShellMenu_Popup_Proxy( 
    ITrackShellMenu * This,
    /* [in] */ HWND hwnd,
    /* [in] */ POINTL *ppt,
    /* [in] */ RECTL *prcExclude,
    DWORD dwFlags);


void __RPC_STUB ITrackShellMenu_Popup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITrackShellMenu_INTERFACE_DEFINED__ */


#ifndef __IThumbnail_INTERFACE_DEFINED__
#define __IThumbnail_INTERFACE_DEFINED__

/* interface IThumbnail */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IThumbnail;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d45a930-f71a-11d0-9ea7-00805f714772")
    IThumbnail : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            HWND hwnd,
            UINT uMsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBitmap( 
            LPCWSTR pszFile,
            DWORD dwItem,
            LONG lWidth,
            LONG lHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IThumbnailVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IThumbnail * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IThumbnail * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IThumbnail * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IThumbnail * This,
            HWND hwnd,
            UINT uMsg);
        
        HRESULT ( STDMETHODCALLTYPE *GetBitmap )( 
            IThumbnail * This,
            LPCWSTR pszFile,
            DWORD dwItem,
            LONG lWidth,
            LONG lHeight);
        
        END_INTERFACE
    } IThumbnailVtbl;

    interface IThumbnail
    {
        CONST_VTBL struct IThumbnailVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IThumbnail_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IThumbnail_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IThumbnail_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IThumbnail_Init(This,hwnd,uMsg)	\
    (This)->lpVtbl -> Init(This,hwnd,uMsg)

#define IThumbnail_GetBitmap(This,pszFile,dwItem,lWidth,lHeight)	\
    (This)->lpVtbl -> GetBitmap(This,pszFile,dwItem,lWidth,lHeight)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IThumbnail_Init_Proxy( 
    IThumbnail * This,
    HWND hwnd,
    UINT uMsg);


void __RPC_STUB IThumbnail_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThumbnail_GetBitmap_Proxy( 
    IThumbnail * This,
    LPCWSTR pszFile,
    DWORD dwItem,
    LONG lWidth,
    LONG lHeight);


void __RPC_STUB IThumbnail_GetBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IThumbnail_INTERFACE_DEFINED__ */


#ifndef __IThumbnail2_INTERFACE_DEFINED__
#define __IThumbnail2_INTERFACE_DEFINED__

/* interface IThumbnail2 */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IThumbnail2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("500202A0-731E-11d0-B829-00C04FD706EC")
    IThumbnail2 : public IThumbnail
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBitmapFromIDList( 
            LPCITEMIDLIST pidl,
            DWORD dwItem,
            LONG lWidth,
            LONG lHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IThumbnail2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IThumbnail2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IThumbnail2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IThumbnail2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IThumbnail2 * This,
            HWND hwnd,
            UINT uMsg);
        
        HRESULT ( STDMETHODCALLTYPE *GetBitmap )( 
            IThumbnail2 * This,
            LPCWSTR pszFile,
            DWORD dwItem,
            LONG lWidth,
            LONG lHeight);
        
        HRESULT ( STDMETHODCALLTYPE *GetBitmapFromIDList )( 
            IThumbnail2 * This,
            LPCITEMIDLIST pidl,
            DWORD dwItem,
            LONG lWidth,
            LONG lHeight);
        
        END_INTERFACE
    } IThumbnail2Vtbl;

    interface IThumbnail2
    {
        CONST_VTBL struct IThumbnail2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IThumbnail2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IThumbnail2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IThumbnail2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IThumbnail2_Init(This,hwnd,uMsg)	\
    (This)->lpVtbl -> Init(This,hwnd,uMsg)

#define IThumbnail2_GetBitmap(This,pszFile,dwItem,lWidth,lHeight)	\
    (This)->lpVtbl -> GetBitmap(This,pszFile,dwItem,lWidth,lHeight)


#define IThumbnail2_GetBitmapFromIDList(This,pidl,dwItem,lWidth,lHeight)	\
    (This)->lpVtbl -> GetBitmapFromIDList(This,pidl,dwItem,lWidth,lHeight)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IThumbnail2_GetBitmapFromIDList_Proxy( 
    IThumbnail2 * This,
    LPCITEMIDLIST pidl,
    DWORD dwItem,
    LONG lWidth,
    LONG lHeight);


void __RPC_STUB IThumbnail2_GetBitmapFromIDList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IThumbnail2_INTERFACE_DEFINED__ */


#ifndef __IACLCustomMRU_INTERFACE_DEFINED__
#define __IACLCustomMRU_INTERFACE_DEFINED__

/* interface IACLCustomMRU */
/* [local][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IACLCustomMRU;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F729FC5E-8769-4f3e-BDB2-D7B50FD2275B")
    IACLCustomMRU : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [string][in] */ LPCWSTR pwszMRURegKey,
            /* [in] */ DWORD dwMax) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddMRUString( 
            /* [string][in] */ LPCWSTR pwszEntry) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IACLCustomMRUVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IACLCustomMRU * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IACLCustomMRU * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IACLCustomMRU * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IACLCustomMRU * This,
            /* [string][in] */ LPCWSTR pwszMRURegKey,
            /* [in] */ DWORD dwMax);
        
        HRESULT ( STDMETHODCALLTYPE *AddMRUString )( 
            IACLCustomMRU * This,
            /* [string][in] */ LPCWSTR pwszEntry);
        
        END_INTERFACE
    } IACLCustomMRUVtbl;

    interface IACLCustomMRU
    {
        CONST_VTBL struct IACLCustomMRUVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IACLCustomMRU_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IACLCustomMRU_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IACLCustomMRU_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IACLCustomMRU_Initialize(This,pwszMRURegKey,dwMax)	\
    (This)->lpVtbl -> Initialize(This,pwszMRURegKey,dwMax)

#define IACLCustomMRU_AddMRUString(This,pwszEntry)	\
    (This)->lpVtbl -> AddMRUString(This,pwszEntry)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IACLCustomMRU_Initialize_Proxy( 
    IACLCustomMRU * This,
    /* [string][in] */ LPCWSTR pwszMRURegKey,
    /* [in] */ DWORD dwMax);


void __RPC_STUB IACLCustomMRU_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IACLCustomMRU_AddMRUString_Proxy( 
    IACLCustomMRU * This,
    /* [string][in] */ LPCWSTR pwszEntry);


void __RPC_STUB IACLCustomMRU_AddMRUString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IACLCustomMRU_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_iepriv_0277 */
/* [local] */ 

#if _WIN32_IE >= 0x0600
// used in both shell32 and browseui


extern RPC_IF_HANDLE __MIDL_itf_iepriv_0277_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iepriv_0277_v0_0_s_ifspec;

#ifndef __IShellBrowserService_INTERFACE_DEFINED__
#define __IShellBrowserService_INTERFACE_DEFINED__

/* interface IShellBrowserService */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IShellBrowserService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1307ee17-ea83-49eb-96b2-3a28e2d7048a")
    IShellBrowserService : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropertyBag( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellBrowserServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellBrowserService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellBrowserService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellBrowserService * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropertyBag )( 
            IShellBrowserService * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        END_INTERFACE
    } IShellBrowserServiceVtbl;

    interface IShellBrowserService
    {
        CONST_VTBL struct IShellBrowserServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellBrowserService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellBrowserService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellBrowserService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellBrowserService_GetPropertyBag(This,dwFlags,riid,ppv)	\
    (This)->lpVtbl -> GetPropertyBag(This,dwFlags,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellBrowserService_GetPropertyBag_Proxy( 
    IShellBrowserService * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IShellBrowserService_GetPropertyBag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellBrowserService_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_iepriv_0278 */
/* [local] */ 

#endif // _WIN32_IE >= 0x0600


extern RPC_IF_HANDLE __MIDL_itf_iepriv_0278_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iepriv_0278_v0_0_s_ifspec;


#ifndef __IEPrivateObjects_LIBRARY_DEFINED__
#define __IEPrivateObjects_LIBRARY_DEFINED__

/* library IEPrivateObjects */
/* [uuid] */ 


EXTERN_C const IID LIBID_IEPrivateObjects;

EXTERN_C const CLSID CLSID_MruPidlList;

#ifdef __cplusplus

class DECLSPEC_UUID("42aedc87-2188-41fd-b9a3-0c966feabec1")
MruPidlList;
#endif

EXTERN_C const CLSID CLSID_MruLongList;

#ifdef __cplusplus

class DECLSPEC_UUID("53bd6b4e-3780-4693-afc3-7161c2f3ee9c")
MruLongList;
#endif

EXTERN_C const CLSID CLSID_MruShortList;

#ifdef __cplusplus

class DECLSPEC_UUID("53bd6b4f-3780-4693-afc3-7161c2f3ee9c")
MruShortList;
#endif

EXTERN_C const CLSID CLSID_FolderMarshalStub;

#ifdef __cplusplus

class DECLSPEC_UUID("bf50b68e-29b8-4386-ae9c-9734d5117cd5")
FolderMarshalStub;
#endif

EXTERN_C const CLSID CLSID_MailRecipient;

#ifdef __cplusplus

class DECLSPEC_UUID("9E56BE60-C50F-11CF-9A2C-00A0C90A90CE")
MailRecipient;
#endif

EXTERN_C const CLSID CLSID_SearchCompanionInfo;

#ifdef __cplusplus

class DECLSPEC_UUID("AC1B0D5D-DD59-4ff0-93F8-A84373821606")
SearchCompanionInfo;
#endif

EXTERN_C const CLSID CLSID_TrackShellMenu;

#ifdef __cplusplus

class DECLSPEC_UUID("8278F931-2A3E-11d2-838F-00C04FD918D0")
TrackShellMenu;
#endif

EXTERN_C const CLSID CLSID_Thumbnail;

#ifdef __cplusplus

class DECLSPEC_UUID("7487cd30-f71a-11d0-9ea7-00805f714772")
Thumbnail;
#endif
#endif /* __IEPrivateObjects_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\lpcfus.h ===
//  --------------------------------------------------------------------------
//  Module Name: LPCFUS.h
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  This file contains structs for PORT_MESSAGE appends which are specific to
//  the bad application API.
//
//  History:    2000-08-26  vtan        created
//              2000-10-12  vtan        moved from DS to SHELL depot
//  --------------------------------------------------------------------------

#ifndef     _LPCFUS_
#define     _LPCFUS_

#include <LPCGeneric.h>

static  const TCHAR     FUS_PORT_NAME[]             =   L"\\FusApiPort";
static  const TCHAR     FUS_CONNECTION_REQUEST[]    =   L"FusApiConnectionRequest";

enum
{
    API_BAM_QUERYRUNNING            =   1,
    API_BAM_REGISTERRUNNING,
    API_BAM_QUERYUSERPERMISSION,
    API_BAM_TERMINATERUNNING,

    API_BAM_REQUESTSWITCHUSER       =   1001,
};

typedef enum
{
    BAM_TYPE_MINIMUM                            =   0,
    BAM_TYPE_UNKNOWN                            =   BAM_TYPE_MINIMUM,
    BAM_TYPE_SECOND_INSTANCE_START,
    BAM_TYPE_SWITCH_USER,
    BAM_TYPE_SWITCH_TO_NEW_USER_WITH_RESTORE,
    BAM_TYPE_SWITCH_TO_NEW_USER,
    BAM_TYPE_MAXIMUM
} BAM_TYPE;

typedef struct
{
    const WCHAR     *pszImageName;
    int             cchImageName;
} API_BAM_QUERYRUNNING_IN;

typedef struct
{
    bool            fResult;
} API_BAM_QUERYRUNNING_OUT;

typedef struct
{
    const WCHAR     *pszImageName;
    int             cchImageName;
    DWORD           dwProcessID;
    BAM_TYPE        bamType;
} API_BAM_REGISTERRUNNING_IN;

typedef struct
{
} API_BAM_REGISTERRUNNING_OUT;

typedef struct
{
    const WCHAR     *pszImageName;
    int             cchImageName;
    WCHAR           *pszUser;
    int             cchUser;
} API_BAM_QUERYUSERPERMISSION_IN;

typedef struct
{
    bool            fCanShutdownApplication;
} API_BAM_QUERYUSERPERMISSION_OUT;

typedef struct
{
    const WCHAR     *pszImageName;
    int             cchImageName;
} API_BAM_TERMINATERUNNING_IN;

typedef struct
{
    bool            fResult;
} API_BAM_TERMINATERUNNING_OUT;

typedef struct
{
} API_BAM_REQUESTSWITCHUSER_IN;

typedef struct
{
    bool            fAllowSwitch;
} API_BAM_REQUESTSWITCHUSER_OUT;

typedef union
{
    union
    {
        API_BAM_QUERYRUNNING_IN             in;
        API_BAM_QUERYRUNNING_OUT            out;
    } apiQueryRunning;
    union
    {
        API_BAM_REGISTERRUNNING_IN          in;
        API_BAM_REGISTERRUNNING_OUT         out;
    } apiRegisterRunning;
    union
    {
        API_BAM_QUERYUSERPERMISSION_IN      in;
        API_BAM_QUERYUSERPERMISSION_OUT     out;
    } apiQueryUserPermission;
    union
    {
        API_BAM_TERMINATERUNNING_IN         in;
        API_BAM_TERMINATERUNNING_OUT        out;
    } apiTerminateRunning;
    union
    {
        API_BAM_REQUESTSWITCHUSER_IN        in;
        API_BAM_REQUESTSWITCHUSER_OUT       out;
    } apiRequestSwitchUser;
} API_BAM_SPECIFIC;

typedef struct
{
    API_GENERIC         apiGeneric;
    API_BAM_SPECIFIC    apiSpecific;
} API_BAM, *PAPI_BAM;

typedef struct
{
    PORT_MESSAGE    portMessage;
    API_BAM         apiBAM;
} FUSAPI_PORT_MESSAGE, *PFUSAPI_PORT_MESSAGE;

#endif  /*  _LPCFUS_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\lpcthemes.h ===
//  --------------------------------------------------------------------------
//  Module Name: LPCThemes.h
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  This file contains structs for PORT_MESSAGE appends which are specific to
//  the theme services API.
//
//  History:    2000-10-10  vtan        created
//              2000-11-11  vtan        collapse to single instance
//  --------------------------------------------------------------------------

#ifndef     _LPCThemes_
#define     _LPCThemes_

#include <LPCGeneric.h>

static  const WCHAR     THEMES_PORT_NAME[]              =   L"\\ThemeApiPort";
static  const WCHAR     THEMES_CONNECTION_REQUEST[]     =   L"ThemeApiConnectionRequest";
static  const WCHAR     THEMES_START_EVENT_NAME[]       =   L"ThemesStartEvent";

enum
{
    API_THEMES_THEMEHOOKSON             =   1,
    API_THEMES_THEMEHOOKSOFF,
    API_THEMES_GETSTATUSFLAGS,
    API_THEMES_GETCURRENTCHANGENUMBER,
    API_THEMES_GETNEWCHANGENUMBER,
    API_THEMES_SETGLOBALTHEME,
    API_THEMES_GETGLOBALTHEME,
    API_THEMES_CHECKTHEMESIGNATURE,
    API_THEMES_LOADTHEME,
    API_THEMES_MARKSECTION,

    API_THEMES_USERLOGON                =   1001,
    API_THEMES_USERLOGOFF,
    API_THEMES_SESSIONCREATE,
    API_THEMES_SESSIONDESTROY,
    API_THEMES_PING
};

typedef struct
{
} API_THEMES_THEMEHOOKSON_IN;

typedef struct
{
    HRESULT             hr;
} API_THEMES_THEMEHOOKSON_OUT;

typedef struct
{
} API_THEMES_THEMEHOOKSOFF_IN;

typedef struct
{
    HRESULT         hr;
} API_THEMES_THEMEHOOKSOFF_OUT;

typedef struct
{
} API_THEMES_GETSTATUSFLAGS_IN;

typedef struct
{
    DWORD           dwFlags;
} API_THEMES_GETSTATUSFLAGS_OUT;

typedef struct
{
} API_THEMES_GETCURRENTCHANGENUMBER_IN;

typedef struct
{
    int             iChangeNumber;
} API_THEMES_GETCURRENTCHANGENUMBER_OUT;

typedef struct
{
} API_THEMES_GETNEWCHANGENUMBER_IN;

typedef struct
{
    int             iChangeNumber;
} API_THEMES_GETNEWCHANGENUMBER_OUT;

typedef struct
{
    HANDLE          hSection;
} API_THEMES_SETGLOBALTHEME_IN;

typedef struct
{
    HANDLE          hSection;
    DWORD           dwAdd;
    DWORD           dwRemove;
} API_THEMES_MARKSECTION_IN;

typedef struct
{
} API_THEMES_MARKSECTION_OUT;

typedef struct
{
    HRESULT         hr;
} API_THEMES_SETGLOBALTHEME_OUT;

typedef struct
{
} API_THEMES_GETGLOBALTHEME_IN;

typedef struct
{
    HRESULT         hr;
    HANDLE          hSection;
} API_THEMES_GETGLOBALTHEME_OUT;

typedef struct
{
    const WCHAR     *pszName;
    int             cchName;
} API_THEMES_CHECKTHEMESIGNATURE_IN;

typedef struct
{
    HRESULT         hr;
} API_THEMES_CHECKTHEMESIGNATURE_OUT;

typedef struct
{
    const WCHAR     *pszName;
    int             cchName;
    const WCHAR     *pszColor;
    int             cchColor;
    const WCHAR     *pszSize;
    int             cchSize;
    HANDLE          hSection;
} API_THEMES_LOADTHEME_IN;

typedef struct
{
    HRESULT         hr;
    HANDLE          hSection;
} API_THEMES_LOADTHEME_OUT;

typedef struct
{
} API_THEMES_GETLASTERRORCONTEXT_IN;

typedef struct
{
} API_THEMES_GETLASTERRORCONTEXT_OUT;

typedef struct
{
} API_THEMES_GETERRORCONTEXTSECTION_IN;

typedef struct
{
    HANDLE          hSection;
} API_THEMES_GETERRORCONTEXTSECTION_OUT;

typedef struct
{
    HANDLE          hToken;
} API_THEMES_USERLOGON_IN;

typedef struct
{
} API_THEMES_USERLOGON_OUT;

typedef struct
{
} API_THEMES_USERLOGOFF_IN;

typedef struct
{
} API_THEMES_USERLOGOFF_OUT;

typedef struct
{
    void            *pfnRegister;
    void            *pfnUnregister;
    void            *pfnClearStockObjects;
    DWORD           dwStackSizeReserve;
    DWORD           dwStackSizeCommit;
} API_THEMES_SESSIONCREATE_IN;

typedef struct
{
} API_THEMES_SESSIONCREATE_OUT;

typedef struct
{
} API_THEMES_SESSIONDESTROY_IN;

typedef struct
{
} API_THEMES_SESSIONDESTROY_OUT;

typedef struct
{
} API_THEMES_PING_IN;

typedef struct
{
} API_THEMES_PING_OUT;

typedef union
{
    union
    {
        API_THEMES_THEMEHOOKSON_IN             in;
        API_THEMES_THEMEHOOKSON_OUT            out;
    } apiThemeHooksOn;
    union
    {
        API_THEMES_THEMEHOOKSOFF_IN             in;
        API_THEMES_THEMEHOOKSOFF_OUT            out;
    } apiThemeHooksOff;
    union
    {
        API_THEMES_GETSTATUSFLAGS_IN            in;
        API_THEMES_GETSTATUSFLAGS_OUT           out;
    } apiGetStatusFlags;
    union
    {
        API_THEMES_GETCURRENTCHANGENUMBER_IN    in;
        API_THEMES_GETCURRENTCHANGENUMBER_OUT   out;
    } apiGetCurrentChangeNumber;
    union
    {
        API_THEMES_GETNEWCHANGENUMBER_IN        in;
        API_THEMES_GETNEWCHANGENUMBER_OUT       out;
    } apiGetNewChangeNumber;
    union
    {
        API_THEMES_SETGLOBALTHEME_IN            in;
        API_THEMES_SETGLOBALTHEME_OUT           out;
    } apiSetGlobalTheme;
    union
    {
        API_THEMES_MARKSECTION_IN               in;
        API_THEMES_MARKSECTION_OUT              out;
    } apiMarkSection;
    union
    {
        API_THEMES_GETGLOBALTHEME_IN            in;
        API_THEMES_GETGLOBALTHEME_OUT           out;
    } apiGetGlobalTheme;
    union
    {
        API_THEMES_CHECKTHEMESIGNATURE_IN       in;
        API_THEMES_CHECKTHEMESIGNATURE_OUT      out;
    } apiCheckThemeSignature;
    union
    {
        API_THEMES_LOADTHEME_IN                 in;
        API_THEMES_LOADTHEME_OUT                out;
    } apiLoadTheme;
    union
    {
        API_THEMES_USERLOGON_IN                 in;
        API_THEMES_USERLOGON_OUT                out;
    } apiUserLogon;
    union
    {
        API_THEMES_USERLOGOFF_IN                in;
        API_THEMES_USERLOGOFF_OUT               out;
    } apiUserLogoff;
    union
    {
        API_THEMES_SESSIONCREATE_IN             in;
        API_THEMES_SESSIONCREATE_OUT            out;
    } apiSessionCreate;
    union
    {
        API_THEMES_SESSIONDESTROY_IN            in;
        API_THEMES_SESSIONDESTROY_OUT           out;
    } apiSessionDestroy;
    union
    {
        API_THEMES_PING_IN                      in;
        API_THEMES_PING_OUT                     out;
    } apiPing;
} API_THEMES_SPECIFIC;

typedef struct
{
    API_GENERIC             apiGeneric;
    API_THEMES_SPECIFIC     apiSpecific;
} API_THEMES, *PAPI_THEMES;

typedef struct
{
    PORT_MESSAGE    portMessage;
    API_THEMES      apiThemes;
} THEMESAPI_PORT_MESSAGE, *PTHEMESAPI_PORT_MESSAGE;

EXTERN_C    DWORD   WINAPI  ThemeWaitForServiceReady (DWORD dwTimeout);
EXTERN_C    BOOL    WINAPI  ThemeWatchForStart (void);
EXTERN_C    BOOL    WINAPI  ThemeUserLogon (HANDLE hToken);
EXTERN_C    BOOL    WINAPI  ThemeUserLogoff (void);
EXTERN_C    BOOL    WINAPI  ThemeUserTSReconnect (void);
EXTERN_C    BOOL    WINAPI  ThemeUserStartShell (void);

typedef DWORD   (WINAPI * PFNTHEMEWAITFORSERVICEREADY) (DWORD dwTimeout);
typedef BOOL    (WINAPI * PFNTHEMEWATCHFORSTART) (void);
typedef HANDLE  (WINAPI * PFNTHEMEUSERLOGON) (HANDLE hToken);
typedef HANDLE  (WINAPI * PFNTHEMEUSERLOGOFF) (void);
typedef HANDLE  (WINAPI * PFNTHEMEUSERTSRECONNECT) (void);
typedef HANDLE  (WINAPI * PFNTHEMEUSERSTARTSHELL) (void);

#define ORDINAL_THEMEWAITFORSERVICEREADY    1
#define ORDINAL_THEMEWATCHFORSTART          2
#define ORDINAL_THEMEUSERLOGON              3
#define ORDINAL_THEMEUSERLOGFF              4
#define ORDINAL_THEMEUSERTSRECONNECT        5
#define ORDINAL_THEMEUSERSTARTSHELL         6

#endif  /*  _LPCThemes_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\inetcpl.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*         Copyright(c) Microsoft Corporation. All rights reserved. **
//*********************************************************************

#ifndef _INETCPLP_H_
#define _INETCPLP_H_

// property sheet page IDs
#define INET_PAGE_GENERAL       0x00000001
#define INET_PAGE_CONNECTION    0x00000002
#define INET_PAGE_PLACES        0x00000004      // OBSOLETE: IE40 users! DO NOT use this ID
#define INET_PAGE_PROGRAMS      0x00000008
#define INET_PAGE_SECURITY_OLD  0x00000010      // OBSOLETE: IE40 users! DO NOT use this ID
#define INET_PAGE_ADVANCED      0x00000020
#define INET_PAGE_PRINT         0x00000040      // OBSOLETE: IE40 users! DO NOT use this ID
#define INET_PAGE_CONTENT       0x00000080
#define INET_PAGE_SECURITY      0x00000100
#define INET_PAGE_ASSOC         0x00000200      // UNIX Assocations
#define INET_PAGE_ALIAS         0x00000400      // UNIX Aliases
#define INET_PAGE_PRIVACY       0x00000800


//  restrict flags
#define R_MULTIMEDIA    0x00000001              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_COLORS        0x00000002              // colors section of the Colors Dialog
#define R_LINKS         0x00000004              // links section of the Colors Dialog
#define R_TOOLBARS      0x00000008              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_FONTS         0x00000010              // Fonts Dialog
#define R_DIALING       0x00000020              // Connection section of Connection tab (incl Settings subdialog)
#define R_PROXYSERVER   0x00000040              // Proxy server section of Connection tab (incl Advanced subdialog)
#define R_CUSTOMIZE     0x00000080              // Homepage section of General tab
#define R_HISTORY       0x00000100              // History section of General tab
#define R_MAILANDNEWS   0x00000200              // Messaging section of Programs tab
#define R_VIEWERS       0x00000400              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_RATINGS       0x00000800              // Ratings section of Content tab
#define R_CERTIFICATES  0x00001000              // Certificates section of Content tab
#define R_ACTIVECONTENT 0x00002000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_WARNINGS      0x00004000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_CACHE         0x00008000              // Temporary Internet Files section of General Tab (incl Settings subdialog)
#define R_CRYPTOGRAPHY  0x00010000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_PLACESDEFAULT 0x00020000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_OTHER         0x00040000              // OBSOLETE: IE40 users! DO NOT use this ID
#define R_CHECKBROWSER  0x00080000              // "IE should check if default browser" checkbox on Programs tab
#define R_LANGUAGES     0x00100000              // Languages Dialog off of the General tab
#define R_ACCESSIBILITY 0x00200000              // Accessibility Dialog off of the General tab
#define R_SECURITY_HKLM_ONLY 0x00400000         // Security tab settings (everything is read only)
#define R_SECURITY_CHANGE_SETTINGS 0x00800000   // Security tab settings (can't change security level for a zone)
#define R_SECURITY_CHANGE_SITES 0x01000000      // Security tab settings (disable everything on Add sites)
#define R_PROFILES      0x02000000              // Profile Asst. section of Content tab
#define R_WALLET        0x04000000              // MS Wallet section of Content tab
#define R_CONNECTION_WIZARD 0x08000000          // Connection wizard button on Connection tab
#define R_AUTOCONFIG    0x10000000              // Auto config section of Programs tab
#define R_ADVANCED      0x20000000              // Entire Advanced tab (including "Restore Defaults")
#define R_CAL_CONTACT   0x40000000              // Personal Info section of Programs tab

#define STR_INETCPL TEXT("inetcpl.cpl") // LoadLibrary() with this string

// structure to pass info to the control panel
typedef struct {
    UINT cbSize;                    // size of the structure
    DWORD dwFlags;                  // enabled page flags (remove pages)
    LPSTR pszCurrentURL;            // the current URL (NULL=none)
    DWORD dwRestrictMask;           // disable sections of the control panel
    DWORD dwRestrictFlags;          // masking for the above
} IEPROPPAGEINFO, *LPIEPROPPAGEINFO;

// GetProcAddress() with this string
#define STR_ADDINTERNETPROPSHEETS "AddInternetPropertySheets"

typedef HRESULT (STDMETHODCALLTYPE * PFNADDINTERNETPROPERTYSHEETS)(
    LPFNADDPROPSHEETPAGE pfnAddPage,   // add PS callback function
    LPARAM lparam,                     // pointer to prop. sheet header
    PUINT pucRefCount,                 // reference counter (NULL if not used)
    LPFNPSPCALLBACK pfnCallback        // PS-to-be-added's callback function (NULL if not used);
);


// GetProcAddress() with this string
#define STR_ADDINTERNETPROPSHEETSEX "AddInternetPropertySheetsEx"

typedef HRESULT (STDMETHODCALLTYPE * PFNADDINTERNETPROPERTYSHEETSEX)(
    LPFNADDPROPSHEETPAGE pfnAddPage, // add PS callback function
    LPARAM lparam,                   // pointer to prop. sheet header
    PUINT pucRefCount,               // reference counter (NULL if not used)
    LPFNPSPCALLBACK pfnCallback,     // PS-to-be-added's callback function (NULL if not used)
    LPIEPROPPAGEINFO piepi           // structure to pass info to control panel
);

STDAPI_(INT_PTR) OpenFontsDialog(HWND hDlg, LPCSTR lpszKeyPath);
STDAPI_(BOOL) LaunchSecurityDialogEx(HWND hDlg, DWORD dwZone, DWORD dwFlags);

#define STR_LAUNCHSECURITYDIALOGEX TEXT("LaunchSecurityDialogEx")

// Flags understood by LaunchSecurityDialog
typedef enum {
    LSDFLAG_DEFAULT    = 0x00000000,
    LSDFLAG_NOADDSITES = 0x00000001,
    LSDFLAG_FORCEUI    = 0x00000002
} LSDFLAG;

typedef BOOL (STDMETHODCALLTYPE * PFNLAUNCHSECURITYDIALOGEX)(
    HWND        hDlg,    // Parent Window
    DWORD       dwZone,  // Initial Zone to display, as defined in urlmon
    DWORD       dwFlags // Initialization flags: or'd combination of LSD_FLAGS
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\mdi.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1993,1994,1995
 *  All Rights Reserved.
 *
 *  MDI.H - Diamond Memory Decompression Interface (MDI)
 *
 *  History:
 *      01-Dec-1993     bens        Initial version.
 *      16-Jan-1994     msliger     Split into MCI, MDI.
 *      11-Feb-1994     msliger     Changed M*ICreate() to adjust size.
 *      13-Feb-1994     msliger     revised type names, ie, UINT16 -> UINT.
 *                                  changed handles to HANDLEs.
 *                                  normalized MDI_MEMORY type.
 *      24-Feb-1994     msliger     Changed alloc,free to common typedefs.
 *                                  Changed HANDLE to MHANDLE.
 *                                  Changed MDI_MEMORY to MI_MEMORY.
 *      22-Mar-1994     msliger     Changed !INT32 to BIT16.
 *                                  Changed interface USHORT to UINT.
 *      31-Jan-1995     msliger     Supported MDICreateDecompression query.
 *      25-May-1995     msliger     Clarified *pcbResult on entry.
 *
 *  Functions:
 *      MDICreateDecompression  - Create and reset an MDI decompression context
 *      MDIDecompress           - Decompress a block of data
 *      MDIResetDecompression   - Reset MDI decompression context
 *      MDIDestroyDecompression - Destroy MDI Decompression context
 *
 *  Types:
 *      MDI_CONTEXT_HANDLE      - Handle to an MDI decompression context
 *      PFNALLOC                - Memory allocation function for MDI
 *      PFNFREE                 - Free memory function for MDI
 */

/* --- types -------------------------------------------------------------- */

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif

#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef unsigned char  BYTE;
#endif

#ifndef _UINT_DEFINED
#define _UINT_DEFINED
typedef unsigned int  UINT;
#endif

#ifndef _ULONG_DEFINED
#define _ULONG_DEFINED
typedef unsigned long  ULONG;
#endif

#ifndef FAR
#ifdef BIT16
#define FAR far
#else
#define FAR
#endif
#endif

#ifndef HUGE
#ifdef BIT16
#define HUGE huge
#else
#define HUGE
#endif
#endif

#ifndef _MI_MEMORY_DEFINED
#define _MI_MEMORY_DEFINED
typedef void HUGE *  MI_MEMORY;
#endif

#ifndef _MHANDLE_DEFINED
#define _MHANDLE_DEFINED
#if defined(_WIN64)
typedef unsigned __int64 MHANDLE;
#else
typedef unsigned long  MHANDLE;
#endif
#endif

/* --- MDI-defined types -------------------------------------------------- */

/* MDI_CONTEXT_HANDLE - Handle to an MDI decompression context */

typedef MHANDLE MDI_CONTEXT_HANDLE;      /* hmd */


/***    PFNALLOC - Memory allocation function for MDI
 *
 *  Entry:
 *      cb - Size in bytes of memory block to allocate
 *
 *  Exit-Success:
 *      Returns !NULL pointer to memory block
 *
 *  Exit-Failure:
 *      Returns NULL; insufficient memory
 */
#ifndef _PFNALLOC_DEFINED
#define _PFNALLOC_DEFINED
typedef MI_MEMORY (FAR DIAMONDAPI *PFNALLOC)(ULONG cb);       /* pfnma */
#endif


/***    PFNFREE - Free memory function for MDI
 *
 *  Entry:
 *      pv - Memory block allocated by matching PFNALLOC function
 *
 *  Exit:
 *      Memory block freed.
 */
#ifndef _PFNFREE_DEFINED
#define _PFNFREE_DEFINED
typedef void (FAR DIAMONDAPI *PFNFREE)(MI_MEMORY pv);          /* pfnmf */
#endif

/* --- prototypes --------------------------------------------------------- */

/***    MDICreateDecompression - Create MDI decompression context
 *
 *  Entry:
 *      pcbDataBlockMax     *largest uncompressed data block size expected,
 *                          gets largest uncompressed data block allowed
 *      pfnma               memory allocation function pointer
 *      pfnmf               memory free function pointer
 *      pcbSrcBufferMin     gets max compressed buffer size
 *      pmdhHandle          gets newly-created context's handle
 *                          If pmdhHandle==NULL, *pcbDataBlockMax and
 *                          *pcbSrcBufferMin will be filled in, but no
 *                          context will be created.  This query will allow
 *                          the caller to determine required buffer sizes
 *                          before creating a context.
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      *pcbDataBlockMax, *pcbSrcBufferMin, *pmdhHandle filled in.
 *
 *  Exit-Failure:
 *      MDI_ERROR_NOT_ENOUGH_MEMORY, could not allocate enough memory.
 *      MDI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 */
int FAR DIAMONDAPI MDICreateDecompression(
        UINT FAR *      pcbDataBlockMax,  /* max uncompressed data block size */
        PFNALLOC        pfnma,            /* Memory allocation function ptr */
        PFNFREE         pfnmf,            /* Memory free function ptr */
        UINT FAR *      pcbSrcBufferMin,  /* gets max. comp. buffer size */
        MDI_CONTEXT_HANDLE *pmdhHandle);  /* gets newly-created handle */


/***    MDIDecompress - Decompress a block of data
 *
 *  Entry:
 *      hmd                 handle to decompression context
 *      pbSrc               source buffer (compressed data)
 *      cbSrc               compressed data size
 *      pbDst               destination buffer (for decompressed data)
 *      *pcbResult          decompressed data size
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      *pcbResult gets actual size of decompressed data in pbDst.
 *      Decompression context possibly updated.
 *
 *  Exit-Failure:
 *      MDI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 *      MDI_ERROR_BUFFER_OVERFLOW, cbDataBlockMax was too small.
 */
int FAR DIAMONDAPI MDIDecompress(
        MDI_CONTEXT_HANDLE  hmd,         /* decompression context */
        void FAR *          pbSrc,       /* source buffer */
        UINT                cbSrc,       /* source data size */
        void FAR *          pbDst,       /* target buffer */
        UINT FAR *          pcbResult);  /* gets target data size */


/***    MDIResetDecompression - Reset decompression history (if any)
 *
 *  De-compression can only be started on a block which was compressed
 *  immediately following a MCICreateCompression() or MCIResetCompression()
 *  call.  This function provides notification to the decompressor that the
 *  next compressed block begins on a compression boundary.
 *
 *  Entry:
 *      hmd - handle to decompression context
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      Decompression context reset.
 *
 *  Exit-Failure:
 *      Returns MDI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI MDIResetDecompression(MDI_CONTEXT_HANDLE hmd);


/***    MDIDestroyDecompression - Destroy MDI decompression context
 *
 *  Entry:
 *      hmd - handle to decompression context
 *
 *  Exit-Success:
 *      Returns MDI_ERROR_NO_ERROR;
 *      Decompression context destroyed.
 *
 *  Exit-Failure:
 *      Returns MDI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI MDIDestroyDecompression(MDI_CONTEXT_HANDLE hmd);

/* --- constants ---------------------------------------------------------- */

/* return codes */

#define     MDI_ERROR_NO_ERROR              0
#define     MDI_ERROR_NOT_ENOUGH_MEMORY     1
#define     MDI_ERROR_BAD_PARAMETERS        2
#define     MDI_ERROR_BUFFER_OVERFLOW       3
#define     MDI_ERROR_FAILED                4

/* ----------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\mci.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1993,1994
 *  All Rights Reserved.
 *
 *  MCI.H - Diamond Memory Compression Interface (MCI)
 *
 *  History:
 *      01-Dec-1993     bens        Initial version.
 *      16-Jan-1994     msliger     Split into MCI, MDI.
 *      11-Feb-1994     msliger     Changed M*ICreate() to adjust size.
 *      13-Feb-1994     msliger     revised type names, ie, UINT16 -> UINT.
 *                                  changed handles to HANDLEs.
 *                                  normalized MCI_MEMORY type.
 *      24-Feb-1994     msliger     Changed alloc,free to common typedefs.
 *                                  Changed HANDLE to MHANDLE.
 *                                  Changed MCI_MEMORY to MI_MEMORY.
 *      15-Mar-1994     msliger     Changes for 32 bits.
 *      22-Mar-1994     msliger     Changed !INT32 to BIT16.
 *                                  Changed interface USHORT to UINT.
 *
 *  Functions:
 *      MCICreateCompression    - Create and reset an MCI compression context
 *      MCICloneCompression     - Make a copy of a compression context
 *      MCICompress             - Compress a block of data
 *      MCIResetCompression     - Reset compression context
 *      MCIDestroyCompression   - Destroy MCI compression context
 *
 *  Types:
 *      MCI_CONTEXT_HANDLE      - Handle to an MCI compression context
 *      PFNALLOC                - Memory allocation function for MCI
 *      PFNFREE                 - Free memory function for MCI
 */

/* --- types -------------------------------------------------------------- */

#ifndef DIAMONDAPI
#define DIAMONDAPI __cdecl
#endif

#ifndef _BYTE_DEFINED
#define _BYTE_DEFINED
typedef unsigned char  BYTE;
#endif

#ifndef _UINT_DEFINED
#define _UINT_DEFINED
typedef unsigned int UINT;
#endif

#ifndef _ULONG_DEFINED
#define _ULONG_DEFINED
typedef unsigned long  ULONG;
#endif

#ifndef FAR
#ifdef BIT16
#define FAR far
#else
#define FAR
#endif
#endif

#ifndef HUGE
#ifdef BIT16
#define HUGE huge
#else
#define HUGE
#endif
#endif

#ifndef _MI_MEMORY_DEFINED
#define _MI_MEMORY_DEFINED
typedef void HUGE *  MI_MEMORY;
#endif

#ifndef _MHANDLE_DEFINED
#define _MHANDLE_DEFINED
#if defined(_WIN64)
typedef unsigned __int64 MHANDLE;
#else
typedef unsigned long  MHANDLE;
#endif
#endif

/* --- MCI-defined types -------------------------------------------------- */

/* MCI_CONTEXT_HANDLE - Handle to an MCI compression context */

typedef MHANDLE MCI_CONTEXT_HANDLE;      /* hmc */


/***    PFNALLOC - Memory allocation function for MCI
 *
 *  Entry:
 *      cb - Size in bytes of memory block to allocate
 *
 *  Exit-Success:
 *      Returns !NULL pointer to memory block
 *
 *  Exit-Failure:
 *      Returns NULL; insufficient memory
 */
#ifndef _PFNALLOC_DEFINED
#define _PFNALLOC_DEFINED
typedef MI_MEMORY (FAR DIAMONDAPI *PFNALLOC)(ULONG cb);       /* pfnma */
#endif


/***    PFNFREE - Free memory function for MCI
 *
 *  Entry:
 *      pv - Memory block allocated by matching PFNALLOC function
 *
 *  Exit:
 *      Memory block freed.
 */
#ifndef _PFNFREE_DEFINED
#define _PFNFREE_DEFINED
typedef void (FAR DIAMONDAPI *PFNFREE)(MI_MEMORY pv);          /* pfnmf */
#endif

/* --- prototypes --------------------------------------------------------- */

/***    MCICreateCompression - Create MCI compression context
 *
 *  Entry:
 *      pcbDataBlockMax     *largest uncompressed data block size desired,
 *                          gets largest uncompressed data block allowed
 *      pfnma               memory allocation function pointer
 *      pfnmf               memory free function pointer
 *      pcbDstBufferMin     gets required compressed data buffer size
 *      pmchHandle          gets newly-created context's handle
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      *pcbDataBlockMax, *pcbDstBufferMin, *pmchHandle filled in.
 *
 *  Exit-Failure:
 *      MCI_ERROR_NOT_ENOUGH_MEMORY, could not allocate enough memory.
 *      MCI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 */
int FAR DIAMONDAPI MCICreateCompression(
        UINT FAR *      pcbDataBlockMax,  /* max uncompressed data block size */
        PFNALLOC        pfnma,            /* Memory allocation function ptr */
        PFNFREE         pfnmf,            /* Memory free function ptr */
        UINT FAR *      pcbDstBufferMin,  /* gets required output buffer size */
        MCI_CONTEXT_HANDLE FAR *pmchHandle);  /* gets newly-created handle */


/***    MCICloneCompression - Make a copy of a compression context
 *
 *  Entry:
 *      hmc                 handle to current compression context
 *      pmchHandle          gets newly-created handle
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      *pmchHandle filled in.
 *
 *  Exit-Failure:
 *      Returns:
 *          MCI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 *          MCI_ERROR_NOT_ENOUGH_MEMORY, could not allocate enough memory.
 *
 *  NOTES:
 *  (1) This API is intended to permit "roll-back" of a sequence of
 *      of MCICompress() calls.  Before starting a sequence that may need
 *      to be rolled-back, use MCICloneCompression() to save the state of
 *      the compression context, then do the MCICompress() calls.  If the
 *      sequence is successful, the "cloned" hmc can be destroyed with
 *      MCIDestroyCompression().  If the sequence is *not* successful, then
 *      the original hmc can be destroyed, and the cloned one can be used
 *      to restart as if the sequence of MCICompress() calls had never
 *      occurred.
 */
int FAR DIAMONDAPI MCICloneCompression(
        MCI_CONTEXT_HANDLE  hmc,         /* current compression context */
        MCI_CONTEXT_HANDLE *pmchHandle); /* gets newly-created handle */


/***    MCICompress - Compress a block of data
 *
 *  Entry:
 *      hmc                 handle to compression context
 *      pbSrc               source buffer (uncompressed data)
 *      cbSrc               size of data to be compressed
 *      pbDst               destination buffer (for compressed data)
 *      cbDst               size of destination buffer
 *      pcbResult           receives compressed size of data
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      *pcbResult has size of compressed data in pbDst.
 *      Compression context possibly updated.
 *
 *  Exit-Failure:
 *      MCI_ERROR_BAD_PARAMETERS, something wrong with parameters.
 */
int FAR DIAMONDAPI MCICompress(
        MCI_CONTEXT_HANDLE  hmc,         /* compression context */
        void FAR *          pbSrc,       /* source buffer */
        UINT                cbSrc,       /* source buffer size */
        void FAR *          pbDst,       /* target buffer */
        UINT                cbDst,       /* target buffer size */
        UINT FAR *          pcbResult);  /* gets target data size */


/***    MCIResetCompression - Reset compression history (if any)
 *
 *  De-compression can only be started on a block which was compressed
 *  immediately following a MCICreateCompression() or MCIResetCompression()
 *  call.  This function forces such a new "compression boundary" to be
 *  created (only by causing the compressor to ignore history, can the data
 *  output be decompressed without history.)
 *
 *  Entry:
 *      hmc - handle to compression context
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      Compression context reset.
 *
 *  Exit-Failure:
 *      Returns MCI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI MCIResetCompression(MCI_CONTEXT_HANDLE hmc);


/***    MCIDestroyCompression - Destroy MCI compression context
 *
 *  Entry:
 *      hmc - handle to compression context
 *
 *  Exit-Success:
 *      Returns MCI_ERROR_NO_ERROR;
 *      Compression context destroyed.
 *
 *  Exit-Failure:
 *      Returns MCI_ERROR_BAD_PARAMETERS, invalid context handle.
 */
int FAR DIAMONDAPI MCIDestroyCompression(MCI_CONTEXT_HANDLE hmc);

/* --- constants ---------------------------------------------------------- */

/* return codes */

#define     MCI_ERROR_NO_ERROR              0
#define     MCI_ERROR_NOT_ENOUGH_MEMORY     1
#define     MCI_ERROR_BAD_PARAMETERS        2
#define     MCI_ERROR_BUFFER_OVERFLOW       3
#define     MCI_ERROR_FAILED                4

/* ----------------------------------------------------------------------- */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\lpcgeneric.h ===
//  --------------------------------------------------------------------------
//  Module Name: LPCGeneric.h
//
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  This file contains structs for PORT_MESSAGE appends which are generic to
//  any API.
//
//  History:    1999-11-17  vtan        created
//              2000-08-25  vtan        moved from Neptune to Whistler
//              2000-10-12  vtan        moved from DS to SHELL depot
//  --------------------------------------------------------------------------

#ifndef     _LPCGeneric_
#define     _LPCGeneric_

enum
{
    API_GENERIC_STOPSERVER              =   0x00010000,
    API_GENERIC_EXECUTE_IMMEDIATELY     =   0x80000000,

    API_GENERIC_SPECIAL_MASK            =   0x00FF0000,
    API_GENERIC_OPTIONS_MASK            =   0xFF000000,
    API_GENERIC_RESERVED_MASK           =   0xFFFF0000,
    API_GENERIC_NUMBER_MASK             =   0x0000FFFF
};

typedef union
{
    unsigned long   ulAPINumber;        //   IN: API number request to server
    NTSTATUS        status;             //  OUT: NTSTATUS error code returned from server
} API_GENERIC;

#endif  /*  _LPCGeneric_    */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\msident.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for msident.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __msident_h__
#define __msident_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUserIdentity_FWD_DEFINED__
#define __IUserIdentity_FWD_DEFINED__
typedef interface IUserIdentity IUserIdentity;
#endif 	/* __IUserIdentity_FWD_DEFINED__ */


#ifndef __IEnumUserIdentity_FWD_DEFINED__
#define __IEnumUserIdentity_FWD_DEFINED__
typedef interface IEnumUserIdentity IEnumUserIdentity;
#endif 	/* __IEnumUserIdentity_FWD_DEFINED__ */


#ifndef __IUserIdentityManager_FWD_DEFINED__
#define __IUserIdentityManager_FWD_DEFINED__
typedef interface IUserIdentityManager IUserIdentityManager;
#endif 	/* __IUserIdentityManager_FWD_DEFINED__ */


#ifndef __IIdentityChangeNotify_FWD_DEFINED__
#define __IIdentityChangeNotify_FWD_DEFINED__
typedef interface IIdentityChangeNotify IIdentityChangeNotify;
#endif 	/* __IIdentityChangeNotify_FWD_DEFINED__ */


#ifndef __IPrivateIdentityManager_FWD_DEFINED__
#define __IPrivateIdentityManager_FWD_DEFINED__
typedef interface IPrivateIdentityManager IPrivateIdentityManager;
#endif 	/* __IPrivateIdentityManager_FWD_DEFINED__ */


#ifndef __IPrivateIdentityManager2_FWD_DEFINED__
#define __IPrivateIdentityManager2_FWD_DEFINED__
typedef interface IPrivateIdentityManager2 IPrivateIdentityManager2;
#endif 	/* __IPrivateIdentityManager2_FWD_DEFINED__ */


#ifndef __IUserIdentity2_FWD_DEFINED__
#define __IUserIdentity2_FWD_DEFINED__
typedef interface IUserIdentity2 IUserIdentity2;
#endif 	/* __IUserIdentity2_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_msident_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// msident.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// Lightweight User Profile Interfaces.

// --------------------------------------------------------------------------------
// GUIDS
// --------------------------------------------------------------------------------
// {A9AE6C91-1D1B-11D2-B21A-00C04FA357FA}
DEFINE_GUID(CLSID_UserIdentityManager, 0xa9ae6C91, 0x1d1b, 0x11d2, 0xb2, 0x1a, 0x0, 0xc0, 0x4f, 0xa3, 0x57, 0xfa);
// {A9AE6C8E-1D1B-11D2-B21A-00C04FA357FA}
DEFINE_GUID(IID_IUserIdentity, 0xa9ae6C8e, 0x1d1b, 0x11d2, 0xb2, 0x1a, 0x0, 0xc0, 0x4f, 0xa3, 0x57, 0xfa);
// {A9AE6C8F-1D1B-11D2-B21A-00C04FA357FA}
DEFINE_GUID(IID_IEnumUserIdentity, 0xa9ae6C8f, 0x1d1b, 0x11d2, 0xb2, 0x1a, 0x0, 0xc0, 0x4f, 0xa3, 0x57, 0xfa);
// {A9AE6C90-1D1B-11D2-B21A-00C04FA357FA}
DEFINE_GUID(IID_IUserIdentityManager, 0xa9ae6C90, 0x1d1b, 0x11d2, 0xb2, 0x1a, 0x0, 0xc0, 0x4f, 0xa3, 0x57, 0xfa);
// {A9AE6C92-1D1B-11D2-B21A-00C04FA357FA}
DEFINE_GUID(IID_IIdentityChangeNotify, 0xa9ae6C92, 0x1d1b, 0x11d2, 0xb2, 0x1a, 0x0, 0xc0, 0x4f, 0xa3, 0x57, 0xfa);
// {A9AE6C93-1D1B-11D2-B21A-00C04FA357FA}
DEFINE_GUID(IID_IPrivateIdentityManager, 0xa9ae6C93, 0x1d1b, 0x11d2, 0xb2, 0x1a, 0x0, 0xc0, 0x4f, 0xa3, 0x57, 0xfa);
// {A9AE6C94-1D1B-11D2-B21A-00C04FA357FA}
DEFINE_GUID(IID_IUserIdentity2, 0xa9ae6C94, 0x1d1b, 0x11d2, 0xb2, 0x1a, 0x0, 0xc0, 0x4f, 0xa3, 0x57, 0xfa);
// {47172E6C-EA67-4ccd-B5CE-2EABBE051404}
DEFINE_GUID(IID_IPrivateIdentityManager2, 0x47172e6c, 0xea67, 0x4ccd, 0xb5, 0xce, 0x2e, 0xab, 0xbe, 0x5, 0x14, 0x4);
// {C28E26E6-219D-11d2-B200-0000F8085266}
DEFINE_GUID(UID_GIBC_DEFAULT_USER, 0xc28e26e6, 0x219d, 0x11d2, 0xb2, 0x0, 0x0, 0x0, 0xf8, 0x8, 0x52, 0x66);
// {C28E26E7-219D-11d2-B200-0000F8085266}
DEFINE_GUID(UID_GIBC_CURRENT_USER, 0xc28e26e7, 0x219d, 0x11d2, 0xb2, 0x0, 0x0, 0x0, 0xf8, 0x8, 0x52, 0x66);
// {C28E26E8-219D-11d2-B200-0000F8085266}
DEFINE_GUID(UID_GIBC_OUTGOING_USER, 0xc28e26e8, 0x219d, 0x11d2, 0xb2, 0x0, 0x0, 0x0, 0xf8, 0x8, 0x52, 0x66);
// {C28E26E9-219D-11d2-B200-0000F8085266}
DEFINE_GUID(UID_GIBC_INCOMING_USER, 0xc28e26e9, 0x219d, 0x11d2, 0xb2, 0x0, 0x0, 0x0, 0xf8, 0x8, 0x52, 0x66);

// --------------------------------------------------------------------------------
// ERROR CODES
// --------------------------------------------------------------------------------
#define E_IDENTITIES_DISABLED                           _HRESULT_TYPEDEF_(0x80007110L)
#define S_IDENTITIES_DISABLED                           _HRESULT_TYPEDEF_(0x00007110L)
#define E_NO_CURRENT_IDENTITY                           _HRESULT_TYPEDEF_(0x80007111L)
#define E_USER_CANCELLED                                _HRESULT_TYPEDEF_(0x80007112L)
#define E_PROCESS_CANCELLED_SWITCH                      _HRESULT_TYPEDEF_(0x80007113L)
#define E_IDENTITY_NOT_FOUND                            _HRESULT_TYPEDEF_(0x80007114L)
#define E_IDENTITY_EXISTS                               _HRESULT_TYPEDEF_(0x80007115L)
#define E_IDENTITY_CHANGING                             _HRESULT_TYPEDEF_(0x80007116L)

#define CCH_IDENTITY_NAME_MAX_LENGTH                         (63)


extern RPC_IF_HANDLE __MIDL_itf_msident_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msident_0000_v0_0_s_ifspec;

#ifndef __IUserIdentity_INTERFACE_DEFINED__
#define __IUserIdentity_INTERFACE_DEFINED__

/* interface IUserIdentity */
/* [object][helpstring][uuid] */ 

#define GIF_ROAMING_FOLDER            0x00000001
#define GIF_NON_ROAMING_FOLDER        0x00000002

EXTERN_C const IID IID_IUserIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9AE6C8E-1D1B-11D2-B21A-00C04FA357FA")
    IUserIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCookie( 
            /* [out] */ GUID *puidCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ WCHAR *pszName,
            /* [in] */ ULONG ulBuffSize) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE OpenIdentityRegKey( 
            /* [in] */ DWORD dwDesiredAccess,
            /* [out] */ HKEY *phKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIdentityFolder( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ WCHAR *pszPath,
            /* [in] */ ULONG ulBuffSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUserIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUserIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUserIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCookie )( 
            IUserIdentity * This,
            /* [out] */ GUID *puidCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IUserIdentity * This,
            /* [in] */ WCHAR *pszName,
            /* [in] */ ULONG ulBuffSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *OpenIdentityRegKey )( 
            IUserIdentity * This,
            /* [in] */ DWORD dwDesiredAccess,
            /* [out] */ HKEY *phKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdentityFolder )( 
            IUserIdentity * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ WCHAR *pszPath,
            /* [in] */ ULONG ulBuffSize);
        
        END_INTERFACE
    } IUserIdentityVtbl;

    interface IUserIdentity
    {
        CONST_VTBL struct IUserIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUserIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUserIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUserIdentity_GetCookie(This,puidCookie)	\
    (This)->lpVtbl -> GetCookie(This,puidCookie)

#define IUserIdentity_GetName(This,pszName,ulBuffSize)	\
    (This)->lpVtbl -> GetName(This,pszName,ulBuffSize)

#define IUserIdentity_OpenIdentityRegKey(This,dwDesiredAccess,phKey)	\
    (This)->lpVtbl -> OpenIdentityRegKey(This,dwDesiredAccess,phKey)

#define IUserIdentity_GetIdentityFolder(This,dwFlags,pszPath,ulBuffSize)	\
    (This)->lpVtbl -> GetIdentityFolder(This,dwFlags,pszPath,ulBuffSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUserIdentity_GetCookie_Proxy( 
    IUserIdentity * This,
    /* [out] */ GUID *puidCookie);


void __RPC_STUB IUserIdentity_GetCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserIdentity_GetName_Proxy( 
    IUserIdentity * This,
    /* [in] */ WCHAR *pszName,
    /* [in] */ ULONG ulBuffSize);


void __RPC_STUB IUserIdentity_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [local] */ HRESULT STDMETHODCALLTYPE IUserIdentity_OpenIdentityRegKey_Proxy( 
    IUserIdentity * This,
    /* [in] */ DWORD dwDesiredAccess,
    /* [out] */ HKEY *phKey);


void __RPC_STUB IUserIdentity_OpenIdentityRegKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserIdentity_GetIdentityFolder_Proxy( 
    IUserIdentity * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ WCHAR *pszPath,
    /* [in] */ ULONG ulBuffSize);


void __RPC_STUB IUserIdentity_GetIdentityFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUserIdentity_INTERFACE_DEFINED__ */


#ifndef __IEnumUserIdentity_INTERFACE_DEFINED__
#define __IEnumUserIdentity_INTERFACE_DEFINED__

/* interface IEnumUserIdentity */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumUserIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9AE6C8F-1D1B-11D2-B21A-00C04FA357FA")
    IEnumUserIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IUnknown **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumUserIdentity **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pnCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumUserIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumUserIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumUserIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumUserIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumUserIdentity * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IUnknown **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumUserIdentity * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumUserIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumUserIdentity * This,
            /* [out] */ IEnumUserIdentity **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IEnumUserIdentity * This,
            /* [out] */ ULONG *pnCount);
        
        END_INTERFACE
    } IEnumUserIdentityVtbl;

    interface IEnumUserIdentity
    {
        CONST_VTBL struct IEnumUserIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumUserIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumUserIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumUserIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumUserIdentity_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumUserIdentity_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumUserIdentity_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumUserIdentity_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#define IEnumUserIdentity_GetCount(This,pnCount)	\
    (This)->lpVtbl -> GetCount(This,pnCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumUserIdentity_Next_Proxy( 
    IEnumUserIdentity * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IUnknown **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumUserIdentity_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumUserIdentity_Skip_Proxy( 
    IEnumUserIdentity * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumUserIdentity_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumUserIdentity_Reset_Proxy( 
    IEnumUserIdentity * This);


void __RPC_STUB IEnumUserIdentity_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumUserIdentity_Clone_Proxy( 
    IEnumUserIdentity * This,
    /* [out] */ IEnumUserIdentity **ppenum);


void __RPC_STUB IEnumUserIdentity_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumUserIdentity_GetCount_Proxy( 
    IEnumUserIdentity * This,
    /* [out] */ ULONG *pnCount);


void __RPC_STUB IEnumUserIdentity_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumUserIdentity_INTERFACE_DEFINED__ */


#ifndef __IUserIdentityManager_INTERFACE_DEFINED__
#define __IUserIdentityManager_INTERFACE_DEFINED__

/* interface IUserIdentityManager */
/* [object][helpstring][uuid] */ 

#define UIMI_CREATE_NEW_IDENTITY        0x00000001
#define UIL_FORCE_UI        0x80000001

EXTERN_C const IID IID_IUserIdentityManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9AE6C90-1D1B-11D2-B21A-00C04FA357FA")
    IUserIdentityManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumIdentities( 
            /* [out] */ IEnumUserIdentity **ppEnumUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ManageIdentities( 
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Logon( 
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IUserIdentity **ppIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Logoff( 
            /* [in] */ HWND hwndParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIdentityByCookie( 
            /* [in] */ GUID *uidCookie,
            /* [out] */ IUserIdentity **ppIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserIdentityManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUserIdentityManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUserIdentityManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUserIdentityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumIdentities )( 
            IUserIdentityManager * This,
            /* [out] */ IEnumUserIdentity **ppEnumUser);
        
        HRESULT ( STDMETHODCALLTYPE *ManageIdentities )( 
            IUserIdentityManager * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Logon )( 
            IUserIdentityManager * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IUserIdentity **ppIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *Logoff )( 
            IUserIdentityManager * This,
            /* [in] */ HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdentityByCookie )( 
            IUserIdentityManager * This,
            /* [in] */ GUID *uidCookie,
            /* [out] */ IUserIdentity **ppIdentity);
        
        END_INTERFACE
    } IUserIdentityManagerVtbl;

    interface IUserIdentityManager
    {
        CONST_VTBL struct IUserIdentityManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserIdentityManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUserIdentityManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUserIdentityManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUserIdentityManager_EnumIdentities(This,ppEnumUser)	\
    (This)->lpVtbl -> EnumIdentities(This,ppEnumUser)

#define IUserIdentityManager_ManageIdentities(This,hwndParent,dwFlags)	\
    (This)->lpVtbl -> ManageIdentities(This,hwndParent,dwFlags)

#define IUserIdentityManager_Logon(This,hwndParent,dwFlags,ppIdentity)	\
    (This)->lpVtbl -> Logon(This,hwndParent,dwFlags,ppIdentity)

#define IUserIdentityManager_Logoff(This,hwndParent)	\
    (This)->lpVtbl -> Logoff(This,hwndParent)

#define IUserIdentityManager_GetIdentityByCookie(This,uidCookie,ppIdentity)	\
    (This)->lpVtbl -> GetIdentityByCookie(This,uidCookie,ppIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUserIdentityManager_EnumIdentities_Proxy( 
    IUserIdentityManager * This,
    /* [out] */ IEnumUserIdentity **ppEnumUser);


void __RPC_STUB IUserIdentityManager_EnumIdentities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserIdentityManager_ManageIdentities_Proxy( 
    IUserIdentityManager * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IUserIdentityManager_ManageIdentities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserIdentityManager_Logon_Proxy( 
    IUserIdentityManager * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IUserIdentity **ppIdentity);


void __RPC_STUB IUserIdentityManager_Logon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserIdentityManager_Logoff_Proxy( 
    IUserIdentityManager * This,
    /* [in] */ HWND hwndParent);


void __RPC_STUB IUserIdentityManager_Logoff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserIdentityManager_GetIdentityByCookie_Proxy( 
    IUserIdentityManager * This,
    /* [in] */ GUID *uidCookie,
    /* [out] */ IUserIdentity **ppIdentity);


void __RPC_STUB IUserIdentityManager_GetIdentityByCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUserIdentityManager_INTERFACE_DEFINED__ */


#ifndef __IIdentityChangeNotify_INTERFACE_DEFINED__
#define __IIdentityChangeNotify_INTERFACE_DEFINED__

/* interface IIdentityChangeNotify */
/* [object][helpstring][uuid] */ 

#define IIC_CURRENT_IDENTITY_CHANGED      0x00000001
#define IIC_IDENTITY_CHANGED              0x00000002
#define IIC_IDENTITY_DELETED              0x00000004
#define IIC_IDENTITY_ADDED                0x00000008

EXTERN_C const IID IID_IIdentityChangeNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9AE6C92-1D1B-11D2-B21A-00C04FA357FA")
    IIdentityChangeNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QuerySwitchIdentities( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchIdentities( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IdentityInformationChanged( 
            DWORD dwType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIdentityChangeNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIdentityChangeNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIdentityChangeNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIdentityChangeNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *QuerySwitchIdentities )( 
            IIdentityChangeNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchIdentities )( 
            IIdentityChangeNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *IdentityInformationChanged )( 
            IIdentityChangeNotify * This,
            DWORD dwType);
        
        END_INTERFACE
    } IIdentityChangeNotifyVtbl;

    interface IIdentityChangeNotify
    {
        CONST_VTBL struct IIdentityChangeNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIdentityChangeNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIdentityChangeNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIdentityChangeNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIdentityChangeNotify_QuerySwitchIdentities(This)	\
    (This)->lpVtbl -> QuerySwitchIdentities(This)

#define IIdentityChangeNotify_SwitchIdentities(This)	\
    (This)->lpVtbl -> SwitchIdentities(This)

#define IIdentityChangeNotify_IdentityInformationChanged(This,dwType)	\
    (This)->lpVtbl -> IdentityInformationChanged(This,dwType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIdentityChangeNotify_QuerySwitchIdentities_Proxy( 
    IIdentityChangeNotify * This);


void __RPC_STUB IIdentityChangeNotify_QuerySwitchIdentities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityChangeNotify_SwitchIdentities_Proxy( 
    IIdentityChangeNotify * This);


void __RPC_STUB IIdentityChangeNotify_SwitchIdentities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityChangeNotify_IdentityInformationChanged_Proxy( 
    IIdentityChangeNotify * This,
    DWORD dwType);


void __RPC_STUB IIdentityChangeNotify_IdentityInformationChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIdentityChangeNotify_INTERFACE_DEFINED__ */


#ifndef __IPrivateIdentityManager_INTERFACE_DEFINED__
#define __IPrivateIdentityManager_INTERFACE_DEFINED__

/* interface IPrivateIdentityManager */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IPrivateIdentityManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9AE6C93-1D1B-11D2-B21A-00C04FA357FA")
    IPrivateIdentityManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateIdentity( 
            /* [in] */ WCHAR *pszName,
            /* [out] */ IUserIdentity **ppIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfirmPassword( 
            /* [in] */ GUID *uidCookie,
            /* [in] */ WCHAR *pszPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrivateIdentityManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrivateIdentityManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrivateIdentityManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrivateIdentityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateIdentity )( 
            IPrivateIdentityManager * This,
            /* [in] */ WCHAR *pszName,
            /* [out] */ IUserIdentity **ppIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *ConfirmPassword )( 
            IPrivateIdentityManager * This,
            /* [in] */ GUID *uidCookie,
            /* [in] */ WCHAR *pszPassword);
        
        END_INTERFACE
    } IPrivateIdentityManagerVtbl;

    interface IPrivateIdentityManager
    {
        CONST_VTBL struct IPrivateIdentityManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrivateIdentityManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrivateIdentityManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPrivateIdentityManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPrivateIdentityManager_CreateIdentity(This,pszName,ppIdentity)	\
    (This)->lpVtbl -> CreateIdentity(This,pszName,ppIdentity)

#define IPrivateIdentityManager_ConfirmPassword(This,uidCookie,pszPassword)	\
    (This)->lpVtbl -> ConfirmPassword(This,uidCookie,pszPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPrivateIdentityManager_CreateIdentity_Proxy( 
    IPrivateIdentityManager * This,
    /* [in] */ WCHAR *pszName,
    /* [out] */ IUserIdentity **ppIdentity);


void __RPC_STUB IPrivateIdentityManager_CreateIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivateIdentityManager_ConfirmPassword_Proxy( 
    IPrivateIdentityManager * This,
    /* [in] */ GUID *uidCookie,
    /* [in] */ WCHAR *pszPassword);


void __RPC_STUB IPrivateIdentityManager_ConfirmPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrivateIdentityManager_INTERFACE_DEFINED__ */


#ifndef __IPrivateIdentityManager2_INTERFACE_DEFINED__
#define __IPrivateIdentityManager2_INTERFACE_DEFINED__

/* interface IPrivateIdentityManager2 */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IPrivateIdentityManager2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15E84C92-2E4D-11d3-9C92-00104B35E7F9")
    IPrivateIdentityManager2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateIdentity2( 
            /* [in] */ WCHAR *pszName,
            /* [in] */ WCHAR *pszPassword,
            /* [out] */ IUserIdentity **ppIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyIdentity( 
            /* [in] */ GUID *uidCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogonAs( 
            /* [in] */ WCHAR *pszName,
            /* [in] */ WCHAR *pszPassword,
            /* [out] */ IUserIdentity **ppIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultIdentity( 
            /* [in] */ GUID *puidCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIdentity( 
            /* [out] */ GUID *puidCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPrivateIdentityManager2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPrivateIdentityManager2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPrivateIdentityManager2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPrivateIdentityManager2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateIdentity2 )( 
            IPrivateIdentityManager2 * This,
            /* [in] */ WCHAR *pszName,
            /* [in] */ WCHAR *pszPassword,
            /* [out] */ IUserIdentity **ppIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyIdentity )( 
            IPrivateIdentityManager2 * This,
            /* [in] */ GUID *uidCookie);
        
        HRESULT ( STDMETHODCALLTYPE *LogonAs )( 
            IPrivateIdentityManager2 * This,
            /* [in] */ WCHAR *pszName,
            /* [in] */ WCHAR *pszPassword,
            /* [out] */ IUserIdentity **ppIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultIdentity )( 
            IPrivateIdentityManager2 * This,
            /* [in] */ GUID *puidCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIdentity )( 
            IPrivateIdentityManager2 * This,
            /* [out] */ GUID *puidCookie);
        
        END_INTERFACE
    } IPrivateIdentityManager2Vtbl;

    interface IPrivateIdentityManager2
    {
        CONST_VTBL struct IPrivateIdentityManager2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPrivateIdentityManager2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPrivateIdentityManager2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPrivateIdentityManager2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPrivateIdentityManager2_CreateIdentity2(This,pszName,pszPassword,ppIdentity)	\
    (This)->lpVtbl -> CreateIdentity2(This,pszName,pszPassword,ppIdentity)

#define IPrivateIdentityManager2_DestroyIdentity(This,uidCookie)	\
    (This)->lpVtbl -> DestroyIdentity(This,uidCookie)

#define IPrivateIdentityManager2_LogonAs(This,pszName,pszPassword,ppIdentity)	\
    (This)->lpVtbl -> LogonAs(This,pszName,pszPassword,ppIdentity)

#define IPrivateIdentityManager2_SetDefaultIdentity(This,puidCookie)	\
    (This)->lpVtbl -> SetDefaultIdentity(This,puidCookie)

#define IPrivateIdentityManager2_GetDefaultIdentity(This,puidCookie)	\
    (This)->lpVtbl -> GetDefaultIdentity(This,puidCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPrivateIdentityManager2_CreateIdentity2_Proxy( 
    IPrivateIdentityManager2 * This,
    /* [in] */ WCHAR *pszName,
    /* [in] */ WCHAR *pszPassword,
    /* [out] */ IUserIdentity **ppIdentity);


void __RPC_STUB IPrivateIdentityManager2_CreateIdentity2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivateIdentityManager2_DestroyIdentity_Proxy( 
    IPrivateIdentityManager2 * This,
    /* [in] */ GUID *uidCookie);


void __RPC_STUB IPrivateIdentityManager2_DestroyIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivateIdentityManager2_LogonAs_Proxy( 
    IPrivateIdentityManager2 * This,
    /* [in] */ WCHAR *pszName,
    /* [in] */ WCHAR *pszPassword,
    /* [out] */ IUserIdentity **ppIdentity);


void __RPC_STUB IPrivateIdentityManager2_LogonAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivateIdentityManager2_SetDefaultIdentity_Proxy( 
    IPrivateIdentityManager2 * This,
    /* [in] */ GUID *puidCookie);


void __RPC_STUB IPrivateIdentityManager2_SetDefaultIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPrivateIdentityManager2_GetDefaultIdentity_Proxy( 
    IPrivateIdentityManager2 * This,
    /* [out] */ GUID *puidCookie);


void __RPC_STUB IPrivateIdentityManager2_GetDefaultIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPrivateIdentityManager2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_msident_0260 */
/* [local] */ 

extern const IID CLSID_UserIdentityManager;


extern RPC_IF_HANDLE __MIDL_itf_msident_0260_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_msident_0260_v0_0_s_ifspec;

#ifndef __IUserIdentity2_INTERFACE_DEFINED__
#define __IUserIdentity2_INTERFACE_DEFINED__

/* interface IUserIdentity2 */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IUserIdentity2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9AE6C94-1D1B-11D2-B21A-00C04FA357FA")
    IUserIdentity2 : public IUserIdentity
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetOrdinal( 
            /* [out] */ DWORD *dwOrdinal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetName( 
            /* [in] */ WCHAR *pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePassword( 
            /* [in] */ WCHAR *szOldPass,
            /* [in] */ WCHAR *szNewPass) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUserIdentity2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUserIdentity2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUserIdentity2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUserIdentity2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCookie )( 
            IUserIdentity2 * This,
            /* [out] */ GUID *puidCookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IUserIdentity2 * This,
            /* [in] */ WCHAR *pszName,
            /* [in] */ ULONG ulBuffSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *OpenIdentityRegKey )( 
            IUserIdentity2 * This,
            /* [in] */ DWORD dwDesiredAccess,
            /* [out] */ HKEY *phKey);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdentityFolder )( 
            IUserIdentity2 * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ WCHAR *pszPath,
            /* [in] */ ULONG ulBuffSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetOrdinal )( 
            IUserIdentity2 * This,
            /* [out] */ DWORD *dwOrdinal);
        
        HRESULT ( STDMETHODCALLTYPE *SetName )( 
            IUserIdentity2 * This,
            /* [in] */ WCHAR *pszName);
        
        HRESULT ( STDMETHODCALLTYPE *ChangePassword )( 
            IUserIdentity2 * This,
            /* [in] */ WCHAR *szOldPass,
            /* [in] */ WCHAR *szNewPass);
        
        END_INTERFACE
    } IUserIdentity2Vtbl;

    interface IUserIdentity2
    {
        CONST_VTBL struct IUserIdentity2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUserIdentity2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUserIdentity2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUserIdentity2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUserIdentity2_GetCookie(This,puidCookie)	\
    (This)->lpVtbl -> GetCookie(This,puidCookie)

#define IUserIdentity2_GetName(This,pszName,ulBuffSize)	\
    (This)->lpVtbl -> GetName(This,pszName,ulBuffSize)

#define IUserIdentity2_OpenIdentityRegKey(This,dwDesiredAccess,phKey)	\
    (This)->lpVtbl -> OpenIdentityRegKey(This,dwDesiredAccess,phKey)

#define IUserIdentity2_GetIdentityFolder(This,dwFlags,pszPath,ulBuffSize)	\
    (This)->lpVtbl -> GetIdentityFolder(This,dwFlags,pszPath,ulBuffSize)


#define IUserIdentity2_GetOrdinal(This,dwOrdinal)	\
    (This)->lpVtbl -> GetOrdinal(This,dwOrdinal)

#define IUserIdentity2_SetName(This,pszName)	\
    (This)->lpVtbl -> SetName(This,pszName)

#define IUserIdentity2_ChangePassword(This,szOldPass,szNewPass)	\
    (This)->lpVtbl -> ChangePassword(This,szOldPass,szNewPass)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUserIdentity2_GetOrdinal_Proxy( 
    IUserIdentity2 * This,
    /* [out] */ DWORD *dwOrdinal);


void __RPC_STUB IUserIdentity2_GetOrdinal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserIdentity2_SetName_Proxy( 
    IUserIdentity2 * This,
    /* [in] */ WCHAR *pszName);


void __RPC_STUB IUserIdentity2_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUserIdentity2_ChangePassword_Proxy( 
    IUserIdentity2 * This,
    /* [in] */ WCHAR *szOldPass,
    /* [in] */ WCHAR *szNewPass);


void __RPC_STUB IUserIdentity2_ChangePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUserIdentity2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\msluapi.h ===
//*********************************************************************
//*                  Microsoft Internet Explorer                     **
//*        Copyright (c) Microsoft Corporation. All rights reserved. **
//*********************************************************************

#ifndef _MSLUAPI_H_
#define _MSLUAPI_H_

#ifdef USER_SETTINGS_IMPLEMENTED

/************************************************************************

IUserSettings interface

This interface is used to manipulate the settings for a particular component,
corresponding to a local user account.  An IUserSettings interface may be
obtained by CLSID or name, or through enumeration;  in both cases, this is
relative to a particular user.

Member functions, other than IUnknown:

GetCLSID(CLSID *pclsidOut)
	Returns the CLSID identifying the component.  May be GUID_NULL if no
	CLSID is defined for the component.

GetName(LPSTR pbBuffer, UINT cbBuffer)
	Returns a unique name identifying the component.  This may be used
	instead of a CLSID if the component provider does not wish to provide
	a COM server to help administer the settings.

GetDisplayName(LPSTR pbBuffer, UINT cbBuffer)
	Returns a user-friendly name for the component, suitable for presentation
	to the user.

QueryKey(HKEY *phkeyOut)
	Returns a registry key where the component stores settings for the
	specified user.  The key is owned by the interface and must not be
	closed by the application using RegCloseKey, otherwise changes will
	not be propagated correctly.

((((
OpenKey(HKEY *phkeyOut, DWORD fdwAccess)
	Returns a registry key where the component stores settings for the
	specified user.  The key MUST be closed using IUserSettings::CloseKey
	so that changes will be propagated correctly.  fdwAccess indicates
	the type of access desired;  valid values include GENERIC_READ and
	GENERIC_WRITE.

CloseKey(HKEY hKey)
	Closes a registry key obtained via IUserSettings::OpenKey.

Lock(BOOL fLock)
	Locks or unlocks the settings for updates.  Attempting to lock the
	settings will fail if they are already locked.  Locking the settings
	does not, however, affect any of the other member functions
))))
************************************************************************/

DECLARE_INTERFACE_(IUserSettings, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(GetCLSID) (THIS_ CLSID *pclsidOut) PURE;
	STDMETHOD(GetName) (THIS_ LPSTR pbBuffer, LPDWORD pcbBuffer) PURE;
	STDMETHOD(GetDisplayName) (THIS_ LPSTR pbBuffer, LPDWORD pcbBuffer) PURE;

	STDMETHOD(QueryKey) (THIS_ HKEY *phkeyOut) PURE;
};
#endif  /* USER_SETTINGS_IMPLEMENTED */


/************************************************************************

IUser interface

This interface is used to manipulate a local user account.  It allows
various operations to be performed on a particular user.  To obtain one
of these interfaces, the companion interface IUserDatabase must be
used -- its AddUser, GetUser, and GetCurrentUser member functions all
return IUser objects, as does IEnumUsers::Next.

In all descriptions here, "the user" refers to the user which this
ILocalUser object describes.  "The current user" means the user who
is currently logged on at the workstation.

If the current user is a supervisor, all functions are allowed.  Otherwise,
a more limited set of member functions is available if the IUser object
corresponds to the current user.  If the current user is not a supervisor
and the IUser object refers to a different user, a still more limited set
of functions is allowed.

Member functions, other than IUnknown:

GetName(LPSTR pbBuffer, UINT cbBuffer)
	Returns the user's logon name.

GetProfileDirectory(LPSTR pbBuffer, UINT cbBuffer)
	Returns the user's local profile directory (e.g., C:\WINDOWS\PROFILES\gregj).
	May fail if the user is the default user (doesn't really have a profile
	directory as such).

IsSupervisor()
	Returns whether the user is a supervisor or not.  This is not a generic
	property because it's actually based on the presence of security info
	in the user's PWL (at least on win95).

SetSupervisorPrivilege(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword)
	Grants or revokes supervisor privilege for the user.  Only supervisors
	can grant or revoke that privilege, of course.  If pszSupervisorPassword
    is not NULL, it is used to determine whether the current user is a
    supervisor.  If it is NULL, then the current user's password cache is
    used instead.  This allows making any user into a supervisor without
    the current user being one.

MakeTempSupervisor(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword)
    Grants or revokes supervisor privilege for the user, but only for the
    lifetime of this IUser object.  As soon as the object is destroyed,
    the user is no longer considered a supervisor, and in fact other IUser
    objects currently in existence which refer to the same user will not
    indicate him as a supervisor.

    Note that MakeTempSupervisor(FALSE) only revokes temporary-supervisor
    privilege granted by MakeTempSupervisor(TRUE).  If the user still has
    the supervisor password in his PWL, he will still be considered a
    supervisor.

AppearsSupervisor()
	Returns whether or not the user should appear as a supervisor in a list
	of users.  This allows querying this property on each user for display
	purposes without taking the large performance hit to locate each user's
	PWL, open it up, get the supervisor key out, and validate it.  Instead,
	a registry value under the user's key is used to maintain this value.
	It should NOT be used to determine whether the user has permission to
	do something, because the simple registry value is not as secure.

Authenticate(LPCSTR pszPassword)
	Attempts to authenticate the user using the given password.  Returns
	S_OK if the password is correct for the user, or an error otherwise.
	No user interface is displayed by this function.

ChangePassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword)
	Attempts to change the user's password from the given old password
	to the given new password.  Returns an error code indicating success
	or failure.  If the current user is a supervisor, the old password
	may be NULL, in which case the supervisor's credentials are used to
	get the password via other means.

GetPasswordCache(LPCSTR pszPassword, LPHPWL phOut)
	Returns a handle to the user's password cache, suitable for use with
	the MSPWL32.DLL APIs.  May fail, of course, if password caching is
	disabled.

LoadProfile(LPHKEY phkeyUser)
    Loads the user's profile into the registry and returns a handle to the
    root key.  The current user can always load his own profile (just returns
    HKEY_CURRENT_USER);  to load other users' profiles, the current user must
    be a supervisor.  IUser::UnloadProfile() should always be called when the
    caller is done playing with the user's profile.

UnloadProfile(HKEY hkeyUser)
    Unloads the user's profile from the registry if possible, and closes the
    key handle returned by IUser::LoadProfile.  If the specified user is the
    current user, this function does nothing.

GetComponentSettings(REFCLSID clsidComponent, LPCSTR pszName,
					 IUnknown **ppOut, DWORD fdwAccess)
    CURRENTLY NOT IMPLEMENTED
	Returns an IUserSettings interface which can be used to access the
	user's settings for a particular component.  Either clsidComponent or
	pszName may be used to refer to the component whose settings are to be
	accessed.  If pszName is not NULL, it takes precedence over clsidComponent.
	fdwAccess specifies whether the caller wants read or write access to the
	settings.  If the component's settings are restricted and the current user
	is not a supervisor, only GENERIC_READ access will be allowed;
	GENERIC_WRITE will fail.

EnumerateComponentSettings(IEnumUnknown **ppOut, DWORD fdwAccess)
    CURRENTLY NOT IMPLEMENTED
	Returns an IEnumUnknown interface which can be used to enumerate all
	components which have settings recorded for the user.  fdwAccess
	specifies the desired access, read or write.  If the current user
	is not a supervisor and the caller requests write access, the enumerator
	will not return any components which do not permit such access.

************************************************************************/

DECLARE_INTERFACE_(IUser, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(GetName) (THIS_ LPSTR pbBuffer, LPDWORD pcbBuffer) PURE;
	STDMETHOD(GetProfileDirectory) (THIS_ LPSTR pbBuffer, LPDWORD pcbBuffer) PURE;

	STDMETHOD(IsSupervisor) (THIS) PURE;
	STDMETHOD(SetSupervisorPrivilege) (THIS_ BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword) PURE;
	STDMETHOD(MakeTempSupervisor) (THIS_ BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword) PURE;
	STDMETHOD(AppearsSupervisor) (THIS) PURE;

	STDMETHOD(Authenticate) (THIS_ LPCSTR pszPassword) PURE;
	STDMETHOD(ChangePassword) (THIS_ LPCSTR pszOldPassword, LPCSTR pszNewPassword) PURE;
	STDMETHOD(GetPasswordCache) (THIS_ LPCSTR pszPassword, LPHANDLE phOut) PURE;

    STDMETHOD(LoadProfile) (THIS_ HKEY *phkeyUser) PURE;
    STDMETHOD(UnloadProfile) (THIS_ HKEY hkeyUser) PURE;

	STDMETHOD(GetComponentSettings) (THIS_ REFCLSID clsidComponent,
									 LPCSTR pszName, IUnknown **ppOut,
									 DWORD fdwAccess) PURE;
	STDMETHOD(EnumerateComponentSettings) (THIS_ IEnumUnknown **ppOut,
										   DWORD fdwAccess) PURE;
};


/************************************************************************

IUserProfileInit interface

This interface is a helper for IUserDatabase::Install and IUserDatabase::Create.
It allows the client of those functions to perform initialization of a new
user's profile before and after the new user's per-user folders are set up.

Member functions, other than IUnknown:

PreInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir)
	Called when the user's profile has been created, but no per-user folders
    have been created or initialized yet.  Here the implementer can add keys to
    the user's profile which will affect the initialization of those per-user
    folders.  hkeyUser is the root of the user's profile, which would be
    HKEY_CURRENT_USER if the user were currently logged on.

PostInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir)
    Called after the user's per-user folders have been created and initialized.
    Here the implementer can add keys to the user's profile which will control
    roaming of per-user folders, without causing the IUserDatabase profile
    cloning code to want to initialize those folders from their default
    locations.

************************************************************************/

DECLARE_INTERFACE_(IUserProfileInit, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(PreInitProfile) (THIS_ HKEY hkeyUser, LPCSTR pszProfileDir) PURE;
    STDMETHOD(PostInitProfile) (THIS_ HKEY hkeyUser, LPCSTR pszProfileDir) PURE;
};


/************************************************************************

IUserDatabase interface

This interface is used to manage the local user database as a whole.  Any
activities which deal with the list of users in any way are done through
this interface;  operations which deal with the properties (other than the
name) of an existing user are done through IUser.

Member functions, other than IUnknown:

Install(LPCSTR pszSupervisorName, LPCSTR pszSupervisorPassword,
        LPCSTR pszRatingsPassword, IUserProfileInit *pInit)
	Installs the user settings subsystem.  This includes creating an account
	for the supervisor.  A separate member function is necessary for doing
	this because all the others would insist that the current user already
	be a supervisor.  The pInit object (optional, may be NULL) is called
    back to allow the installer to do initialization of the profile being
    created, before and after its per-user files are copied.

AddUser(LPCSTR pszName, IUser *pSourceUser, IUserProfileInit *pInit,
        IUser **ppOut)
	Creates a new user on the system.  This includes creating a profile
	for the user.  It does not, however, include creating a password list
	file.  IUser::ChangePassword can be used to configure the password
	for the user.  An IUser object is returned to the caller so that the
	caller can configure the properties of the user.  This function will
	fail if the current user is not a supervisor.  The caller can optionally
	specify a user account to be cloned.  The pInit object (optional, may be
	NULL) is called back to allow the installer to do initialization of the
	profile being created, before and after its per-user files are copied.

GetUser(LPCSTR pszName, IUser **ppOut)
	Gets an IUser object corresponding to the specified user.  The current
	user need not be a supervisor to call this function, and any user's
	name may be specified.  The IUser interface will control what a non-
	supervisor can and cannot do to the user object.

GetSpecialUser(DWORD nSpecialUserCode, IUser **ppOut)
	Gets an IUser object corresponding to a special particular user.
	Current values for nSpecialUserCode include GSU_CURRENT, meaning
	the currently logged on user, and GSU_DEFAULT, meaning the default
	user identity (i.e., the identity used when nobody is logged on,
	also used as a template when creating new identities).

GetCurrentUser(IUser **ppOut)
	Gets an IUser object corresponding to the currently logged on user.
	Shorthand for GetSpecialUser(GSU_CURRENT, ppOut).

SetCurrentUser(IUser *pUser)
	Sets this IUserDatabase object's idea of who the current user is.
	The user must have previously been authenticated.  This user object
	is used for all checks which, for example, determine whether the
	"current user" is a supervisor, or whether a user can access his
	or her own settings, etc.  SetCurrentUser does not AddRef the IUser
	object passed.

DeleteUser(LPCSTR pszName)
	Deletes the profile and password cache for the specified user,
	effectively destroying that user's identity.  This function may
	only be called if the current user is a supervisor.  Any existing
	IUser objects which refer to the user are no longer useful, but
	still must be destroyed in the ordinary way (Release()).

RenameUser(LPCSTR pszOldName, LPCSTR pszNewName)
	Changes the username of a user.  This function may only be called
	if the current user is a supervisor.

EnumUsers(IEnumUnknown **ppOut)
	Returns an IEnumUnknown object which the caller can use to enumerate
	the local users on the system.

Authenticate(HWND hwndOwner, DWORD dwFlags, LPCSTR pszName, LPCSTR pszPassword,
			 IUser **ppOut)
	Attempts to authenticate a user.  dwFlags specifies whether or not
	to prompt for credentials, and whether or not non-supervisors are
	acceptable.  If no dialog is to be displayed by the API, then the
	pszName and pszPassword parameters are used instead.  If the credentials
	are authenticated succcessfully, S_OK is returned.  The ppOut parameter,
	if not NULL, is filled with a pointer to an IUser object describing the
	user who was authenticated, in case the caller cares to find out about
	who typed in their name and password.

    The dwFlags parameter specifies whether UI will be displayed by the
    function, and whether or not the credentials will be cached in memory
    for use at the next logon.

InstallComponent(REFCLSID clsidComponent, LPCSTR pszName, DWORD dwFlags)
    CURRENTLY NOT IMPLEMENTED

	Installs a component into the settings database, so that it will appear
	in the settings UI.  clsidComponent or pszName can be used to refer to
	the component being installed;  use of a CLSID is preferable because
	then the component can provide server code which renders the settings
	UI for that component, and knows how to initialize the settings for a
	new user.

	The only bit currently defined for dwFlags is:

	SETTINGS_NS_CAN_WRITE:		Non-supervisors can change their own settings
								for this component.

	A component's settings for the current user can always be read, at least
	programmatically -- there is no point in storing settings which can only
	be accessed if the current user is a supervisor.  If non-supervisors
	should not be shown the UI for restricted settings (even a read-only UI),
	that decision can be made at the UI level.

	InstallComponent fails if the current user is not a supervisor.

RemoveComponent(REFCLSID clsidComponent, LPCSTR pszName)
    CURRENTLY NOT IMPLEMENTED

	Removes a component from the settings database, so that it will no longer
	appear in the settings UI.  This also removes this component's settings
	from all user identities.

	RemoveComponent fails if the current user is not a supervisor.

InstallWizard(HWND hwndParent)
    Runs the wizard that switches to multiuser mode.

AddUserWizard(HWND hwndParent)
    Runs the wizard that adds a new user, invoking the go-multiuser wizard
    if necessary.

UserCPL(HWND hwndParent)
    Invokes the general user management UI as seen in Control panel, invoking
    the go-multiuser wizard if necessary.

************************************************************************/

DECLARE_INTERFACE_(IUserDatabase, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(Install) (THIS_ LPCSTR pszSupervisorName, LPCSTR pszSupervisorPassword,
	                    LPCSTR pszRatingsPassword, IUserProfileInit *pInit) PURE;
	STDMETHOD(AddUser) (THIS_ LPCSTR pszName, IUser *pSourceUser,
	                    IUserProfileInit *pInit, IUser **ppOut) PURE;
	STDMETHOD(GetUser) (THIS_ LPCSTR pszName, IUser **ppOut) PURE;
	STDMETHOD(GetSpecialUser) (THIS_ DWORD nSpecialUserCode, IUser **ppOut) PURE;
	STDMETHOD(GetCurrentUser) (THIS_ IUser **ppOut) PURE;
	STDMETHOD(SetCurrentUser) (THIS_ IUser *pUser) PURE;
	STDMETHOD(DeleteUser) (THIS_ LPCSTR pszName) PURE;
	STDMETHOD(RenameUser) (THIS_ LPCSTR pszOldName, LPCSTR pszNewName) PURE;
	STDMETHOD(EnumUsers) (THIS_ IEnumUnknown **ppOut) PURE;

	STDMETHOD(Authenticate) (THIS_ HWND hwndOwner, DWORD dwFlags,
							 LPCSTR pszName, LPCSTR pszPassword,
							 IUser **ppOut) PURE;

	STDMETHOD(InstallComponent) (THIS_ REFCLSID clsidComponent, LPCSTR pszName,
								 DWORD dwFlags) PURE;
	STDMETHOD(RemoveComponent) (THIS_ REFCLSID clsidComponent, LPCSTR pszName) PURE;
    STDMETHOD(InstallWizard) (THIS_ HWND hwndParent) PURE;
    STDMETHOD(AddUserWizard) (THIS_ HWND hwndParent) PURE;

    STDMETHOD(UserCPL) (THIS_ HWND hwndParent) PURE;
};

// codes for IUserDatabase::GetSpecialUser

const DWORD GSU_CURRENT = 0;				// current user
const DWORD GSU_DEFAULT = 1;				// default user profile

// flags for IUserDatabase::Authenticate
const DWORD LUA_DIALOG = 0x00000001;			// display dialog to get credentials
												// otherwise use pszName, pszPassword
const DWORD LUA_SUPERVISORONLY = 0x00000002;	// authenticate supervisors only
const DWORD LUA_FORNEXTLOGON = 0x00000004;      // cache credentials for next logon

// flags for IUserDatabase::InstallComponent
const DWORD SETTINGS_NS_CAN_WRITE = 0x01;	// non-supervisors can change their own settings

#endif  // _MSLUAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\msluguid.h ===
//*********************************************************************
//*                  Microsoft Internet Explorer                     **
//*        Copyright (c) Microsoft Corporation. All rights reserved. **
//*********************************************************************

#ifndef _MSLUGUID_H_
#define _MSLUGUID_H_

// 95D0F020-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(CLSID_LocalUsers, 0x95D0F020L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

// 95D0F023-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(IID_IUser,0x95D0F023L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

// 95D0F022-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(IID_IUserDatabase,0x95D0F023L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

// 95D0F024-451D-11CF-8DAB-00AA006C1A01
DEFINE_GUID(IID_IUserProfileInit,0x95D0F024L, 0x451D, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01);

#ifdef USER_SETTINGS_IMPLEMENTED
// EA7364C0-0730-11D0-83B1-00C04FD705B2
DEFINE_GUID(IID_IUserSettings,0xEA7364C0L, 0x0730, 0x11D0, 0x83, 0xB1, 0x00, 0xC0, 0x4F, 0xD7, 0x05, 0xB2);
#endif

#endif  // _MSLUGUID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\multimop.h ===
#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif // __cplusplus
#ifndef MULTIMON_FNS_DEFINED

int      (WINAPI* g_pfnGetSystemMetrics)(int) = NULL;
HMONITOR (WINAPI* g_pfnMonitorFromWindow)(HWND, DWORD) = NULL;
HMONITOR (WINAPI* g_pfnMonitorFromRect)(LPCRECT, DWORD) = NULL;
HMONITOR (WINAPI* g_pfnMonitorFromPoint)(POINT, DWORD) = NULL;
BOOL     (WINAPI* g_pfnGetMonitorInfo)(HMONITOR, LPMONITORINFO) = NULL;
BOOL     (WINAPI* g_pfnEnumDisplayMonitors)(HDC, LPCRECT, MONITORENUMPROC, LPARAM) = NULL;
BOOL     (WINAPI* g_pfnEnumDisplayDevices)(PVOID, DWORD, PDISPLAY_DEVICE,DWORD) = NULL;
BOOL     g_fMultiMonInitDone = FALSE;
BOOL     g_fMultimonPlatformNT = FALSE;
#define MULTIMON_FNS_DEFINED

#endif
#ifdef __cplusplus
}
#endif  // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\msshrui.h ===
/*****************************************************************/
/**                      Microsoft Windows                      **/
//*   Copyright (c) Microsoft Corporation. All rights reserved. **/
/*****************************************************************/

/*
    msshrui.h
    Prototypes and definitions for sharing APIs

    FILE HISTORY:
    gregj    06/03/93    Created
	brucefo  3/5/96      Fixed prototypes for NT
*/

#ifndef _INC_MSSHRUI
#define _INC_MSSHRUI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


// Note: make sure you GetProcAddress the proper (ANSI/UNICODE) entrypoint!

BOOL WINAPI
IsPathShared(
    IN LPCTSTR lpPath,
    IN BOOL fRefresh
    );

typedef
BOOL
(WINAPI* PFNISPATHSHARED)(
    IN LPCTSTR lpPath,
    IN BOOL fRefresh
    );

BOOL WINAPI
SharingDialog(
    IN HWND hwndParent,
    IN LPTSTR pszComputerName,
    IN LPTSTR pszPath
    );

typedef
BOOL
(WINAPI* PFNSHARINGDIALOG)(
    IN HWND hwndParent,
    IN LPTSTR pszComputerName,
    IN LPTSTR pszPath
    );

BOOL WINAPI
GetNetResourceFromLocalPath(
    IN     LPCTSTR lpcszPath,
    IN OUT LPTSTR lpszNameBuf,
    IN     DWORD cchNameBufLen,
    OUT    PDWORD pdwNetType
    );

typedef
BOOL
(WINAPI* PFNGETNETRESOURCEFROMLOCALPATH)(
    IN     LPCTSTR lpcszPath,
    IN OUT LPTSTR lpszNameBuf,
    IN     DWORD cchNameBufLen,
    OUT    PDWORD pdwNetType
    );

BOOL WINAPI
GetLocalPathFromNetResource(
    IN     LPCTSTR lpcszName,
    IN     DWORD dwNetType,
    IN OUT LPTSTR lpszLocalPathBuf,
    IN     DWORD cchLocalPathBufLen,
    OUT    PBOOL pbIsLocal
    );

typedef
BOOL
(WINAPI* PFNGETLOCALPATHFROMNETRESOURCE)(
    IN     LPCTSTR lpcszName,
    IN     DWORD dwNetType,
    IN OUT LPTSTR lpszLocalPathBuf,
    IN     DWORD cchLocalPathBufLen,
    OUT    PBOOL pbIsLocal
    );

// Flags returned by IsFolderPrivateForUser via pdwPrivateType
#define IFPFU_NOT_PRIVATE               0x0000
#define IFPFU_PRIVATE                   0x0001
#define IFPFU_PRIVATE_INHERITED         0x0002
#define IFPFU_NOT_NTFS                  0x0004

BOOL WINAPI
IsFolderPrivateForUser(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    OUT    PDWORD pdwPrivateType,
    OUT    PWSTR* ppszInheritanceSource
    );

typedef
BOOL
(WINAPI* PFNISFOLDERPRIVATEFORUSER)(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    OUT    PDWORD pdwPrivateType,
    OUT    PWSTR* ppszInheritanceSource
    );

BOOL WINAPI
SetFolderPermissionsForSharing(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    IN     DWORD dwLevel,
    IN     HWND hwndParent
    );

typedef
BOOL
(WINAPI* PFNSETFOLDERPERMISSIONSFORSHARING)(
    IN     PCWSTR pszFolderPath,
    IN     PCWSTR pszUserSID,
    IN     DWORD dwLevel,
    IN     HWND hwndParent
    );

#ifndef WINNT

UINT WINAPI ShareDirectoryNotify(HWND hwnd, LPCSTR lpDir, DWORD dwOper);

#ifndef WNDN_MKDIR
#define WNDN_MKDIR  1
#define WNDN_RMDIR  2
#define WNDN_MVDIR  3
#endif

#define ORD_SHARESHUTDOWNNOTIFY 12

BOOL WINAPI
ShareShutdownNotify(
    DWORD dwFlags,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam
    );

typedef
BOOL
(WINAPI* pfnShareShutdownNotify)(
    DWORD dwFlags,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam
    );

#endif // WINNT

#ifndef RC_INVOKED
#pragma pack()
#endif

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  /* !_INC_MSSHRUI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\shappmgrp.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for shappmgrp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __shappmgrp_h__
#define __shappmgrp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IADCCtl_FWD_DEFINED__
#define __IADCCtl_FWD_DEFINED__
typedef interface IADCCtl IADCCtl;
#endif 	/* __IADCCtl_FWD_DEFINED__ */


#ifndef __ADCCtl_FWD_DEFINED__
#define __ADCCtl_FWD_DEFINED__

#ifdef __cplusplus
typedef class ADCCtl ADCCtl;
#else
typedef struct ADCCtl ADCCtl;
#endif /* __cplusplus */

#endif 	/* __ADCCtl_FWD_DEFINED__ */


#ifndef __IInstalledApp_FWD_DEFINED__
#define __IInstalledApp_FWD_DEFINED__
typedef interface IInstalledApp IInstalledApp;
#endif 	/* __IInstalledApp_FWD_DEFINED__ */


#ifndef __IEnumInstalledApps_FWD_DEFINED__
#define __IEnumInstalledApps_FWD_DEFINED__
typedef interface IEnumInstalledApps IEnumInstalledApps;
#endif 	/* __IEnumInstalledApps_FWD_DEFINED__ */


#ifndef __EnumInstalledApps_FWD_DEFINED__
#define __EnumInstalledApps_FWD_DEFINED__

#ifdef __cplusplus
typedef class EnumInstalledApps EnumInstalledApps;
#else
typedef struct EnumInstalledApps EnumInstalledApps;
#endif /* __cplusplus */

#endif 	/* __EnumInstalledApps_FWD_DEFINED__ */


#ifndef __IShellAppManager_FWD_DEFINED__
#define __IShellAppManager_FWD_DEFINED__
typedef interface IShellAppManager IShellAppManager;
#endif 	/* __IShellAppManager_FWD_DEFINED__ */


#ifndef __ShellAppManager_FWD_DEFINED__
#define __ShellAppManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellAppManager ShellAppManager;
#else
typedef struct ShellAppManager ShellAppManager;
#endif /* __cplusplus */

#endif 	/* __ShellAppManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "oaidl.h"
#include "shappmgr.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_shappmgrp_0000 */
/* [local] */ 

#ifndef _SHAPPMGRP_H_
#define _SHAPPMGRP_H_


extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0000_v0_0_s_ifspec;


#ifndef __SHAPPMGRPLib_LIBRARY_DEFINED__
#define __SHAPPMGRPLib_LIBRARY_DEFINED__

/* library SHAPPMGRPLib */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_SHAPPMGRPLib;

#ifndef __IADCCtl_INTERFACE_DEFINED__
#define __IADCCtl_INTERFACE_DEFINED__

/* interface IADCCtl */
/* [dual][object][oleautomation][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IADCCtl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3964D99F-AC96-11D1-9851-00C04FD91972")
    IADCCtl : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Dirty( 
            /* [in] */ VARIANT_BOOL bDirty) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Dirty( 
            /* [retval][out] */ VARIANT_BOOL *pbDirty) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Category( 
            /* [in] */ BSTR bstrCategory) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Category( 
            /* [retval][out] */ BSTR *pbstrCategory) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Sort( 
            /* [in] */ BSTR bstrSortExpr) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Sort( 
            /* [retval][out] */ BSTR *pbstrSortExpr) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Forcex86( 
            /* [in] */ VARIANT_BOOL bForce) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Forcex86( 
            /* [retval][out] */ VARIANT_BOOL *pbForce) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_ShowPostSetup( 
            /* [retval][out] */ VARIANT_BOOL *pbShow) = 0;
        
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_OnDomain( 
            /* [in] */ VARIANT_BOOL bOnDomain) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_OnDomain( 
            /* [retval][out] */ VARIANT_BOOL *pbOnDomain) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultCategory( 
            /* [retval][out] */ BSTR *pbstrCategory) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE msDataSourceObject( 
            /* [in] */ BSTR qualifier,
            /* [retval][out] */ IUnknown **ppUnk) = 0;
        
        virtual /* [id][restricted] */ HRESULT STDMETHODCALLTYPE addDataSourceListener( 
            /* [in] */ IUnknown *pEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( 
            BSTR bstrQualifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRestricted( 
            /* [in] */ BSTR bstrPolicy,
            /* [retval][out] */ VARIANT_BOOL *pbRestricted) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exec( 
            BSTR bstrQualifier,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ LONG nRecord) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IADCCtlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IADCCtl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IADCCtl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IADCCtl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IADCCtl * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IADCCtl * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IADCCtl * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IADCCtl * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Dirty )( 
            IADCCtl * This,
            /* [in] */ VARIANT_BOOL bDirty);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Dirty )( 
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbDirty);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Category )( 
            IADCCtl * This,
            /* [in] */ BSTR bstrCategory);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Category )( 
            IADCCtl * This,
            /* [retval][out] */ BSTR *pbstrCategory);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Sort )( 
            IADCCtl * This,
            /* [in] */ BSTR bstrSortExpr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Sort )( 
            IADCCtl * This,
            /* [retval][out] */ BSTR *pbstrSortExpr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Forcex86 )( 
            IADCCtl * This,
            /* [in] */ VARIANT_BOOL bForce);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Forcex86 )( 
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbForce);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ShowPostSetup )( 
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbShow);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_OnDomain )( 
            IADCCtl * This,
            /* [in] */ VARIANT_BOOL bOnDomain);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_OnDomain )( 
            IADCCtl * This,
            /* [retval][out] */ VARIANT_BOOL *pbOnDomain);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultCategory )( 
            IADCCtl * This,
            /* [retval][out] */ BSTR *pbstrCategory);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *msDataSourceObject )( 
            IADCCtl * This,
            /* [in] */ BSTR qualifier,
            /* [retval][out] */ IUnknown **ppUnk);
        
        /* [id][restricted] */ HRESULT ( STDMETHODCALLTYPE *addDataSourceListener )( 
            IADCCtl * This,
            /* [in] */ IUnknown *pEvent);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IADCCtl * This,
            BSTR bstrQualifier);
        
        HRESULT ( STDMETHODCALLTYPE *IsRestricted )( 
            IADCCtl * This,
            /* [in] */ BSTR bstrPolicy,
            /* [retval][out] */ VARIANT_BOOL *pbRestricted);
        
        HRESULT ( STDMETHODCALLTYPE *Exec )( 
            IADCCtl * This,
            BSTR bstrQualifier,
            /* [in] */ BSTR bstrCmd,
            /* [in] */ LONG nRecord);
        
        END_INTERFACE
    } IADCCtlVtbl;

    interface IADCCtl
    {
        CONST_VTBL struct IADCCtlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IADCCtl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IADCCtl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IADCCtl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IADCCtl_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IADCCtl_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IADCCtl_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IADCCtl_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IADCCtl_put_Dirty(This,bDirty)	\
    (This)->lpVtbl -> put_Dirty(This,bDirty)

#define IADCCtl_get_Dirty(This,pbDirty)	\
    (This)->lpVtbl -> get_Dirty(This,pbDirty)

#define IADCCtl_put_Category(This,bstrCategory)	\
    (This)->lpVtbl -> put_Category(This,bstrCategory)

#define IADCCtl_get_Category(This,pbstrCategory)	\
    (This)->lpVtbl -> get_Category(This,pbstrCategory)

#define IADCCtl_put_Sort(This,bstrSortExpr)	\
    (This)->lpVtbl -> put_Sort(This,bstrSortExpr)

#define IADCCtl_get_Sort(This,pbstrSortExpr)	\
    (This)->lpVtbl -> get_Sort(This,pbstrSortExpr)

#define IADCCtl_put_Forcex86(This,bForce)	\
    (This)->lpVtbl -> put_Forcex86(This,bForce)

#define IADCCtl_get_Forcex86(This,pbForce)	\
    (This)->lpVtbl -> get_Forcex86(This,pbForce)

#define IADCCtl_get_ShowPostSetup(This,pbShow)	\
    (This)->lpVtbl -> get_ShowPostSetup(This,pbShow)

#define IADCCtl_put_OnDomain(This,bOnDomain)	\
    (This)->lpVtbl -> put_OnDomain(This,bOnDomain)

#define IADCCtl_get_OnDomain(This,pbOnDomain)	\
    (This)->lpVtbl -> get_OnDomain(This,pbOnDomain)

#define IADCCtl_get_DefaultCategory(This,pbstrCategory)	\
    (This)->lpVtbl -> get_DefaultCategory(This,pbstrCategory)

#define IADCCtl_msDataSourceObject(This,qualifier,ppUnk)	\
    (This)->lpVtbl -> msDataSourceObject(This,qualifier,ppUnk)

#define IADCCtl_addDataSourceListener(This,pEvent)	\
    (This)->lpVtbl -> addDataSourceListener(This,pEvent)

#define IADCCtl_Reset(This,bstrQualifier)	\
    (This)->lpVtbl -> Reset(This,bstrQualifier)

#define IADCCtl_IsRestricted(This,bstrPolicy,pbRestricted)	\
    (This)->lpVtbl -> IsRestricted(This,bstrPolicy,pbRestricted)

#define IADCCtl_Exec(This,bstrQualifier,bstrCmd,nRecord)	\
    (This)->lpVtbl -> Exec(This,bstrQualifier,bstrCmd,nRecord)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Dirty_Proxy( 
    IADCCtl * This,
    /* [in] */ VARIANT_BOOL bDirty);


void __RPC_STUB IADCCtl_put_Dirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Dirty_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbDirty);


void __RPC_STUB IADCCtl_get_Dirty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Category_Proxy( 
    IADCCtl * This,
    /* [in] */ BSTR bstrCategory);


void __RPC_STUB IADCCtl_put_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Category_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ BSTR *pbstrCategory);


void __RPC_STUB IADCCtl_get_Category_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Sort_Proxy( 
    IADCCtl * This,
    /* [in] */ BSTR bstrSortExpr);


void __RPC_STUB IADCCtl_put_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Sort_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ BSTR *pbstrSortExpr);


void __RPC_STUB IADCCtl_get_Sort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_Forcex86_Proxy( 
    IADCCtl * This,
    /* [in] */ VARIANT_BOOL bForce);


void __RPC_STUB IADCCtl_put_Forcex86_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_Forcex86_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbForce);


void __RPC_STUB IADCCtl_get_Forcex86_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_ShowPostSetup_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbShow);


void __RPC_STUB IADCCtl_get_ShowPostSetup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propput] */ HRESULT STDMETHODCALLTYPE IADCCtl_put_OnDomain_Proxy( 
    IADCCtl * This,
    /* [in] */ VARIANT_BOOL bOnDomain);


void __RPC_STUB IADCCtl_put_OnDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_OnDomain_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ VARIANT_BOOL *pbOnDomain);


void __RPC_STUB IADCCtl_get_OnDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][propget] */ HRESULT STDMETHODCALLTYPE IADCCtl_get_DefaultCategory_Proxy( 
    IADCCtl * This,
    /* [retval][out] */ BSTR *pbstrCategory);


void __RPC_STUB IADCCtl_get_DefaultCategory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE IADCCtl_msDataSourceObject_Proxy( 
    IADCCtl * This,
    /* [in] */ BSTR qualifier,
    /* [retval][out] */ IUnknown **ppUnk);


void __RPC_STUB IADCCtl_msDataSourceObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id][restricted] */ HRESULT STDMETHODCALLTYPE IADCCtl_addDataSourceListener_Proxy( 
    IADCCtl * This,
    /* [in] */ IUnknown *pEvent);


void __RPC_STUB IADCCtl_addDataSourceListener_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADCCtl_Reset_Proxy( 
    IADCCtl * This,
    BSTR bstrQualifier);


void __RPC_STUB IADCCtl_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADCCtl_IsRestricted_Proxy( 
    IADCCtl * This,
    /* [in] */ BSTR bstrPolicy,
    /* [retval][out] */ VARIANT_BOOL *pbRestricted);


void __RPC_STUB IADCCtl_IsRestricted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IADCCtl_Exec_Proxy( 
    IADCCtl * This,
    BSTR bstrQualifier,
    /* [in] */ BSTR bstrCmd,
    /* [in] */ LONG nRecord);


void __RPC_STUB IADCCtl_Exec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IADCCtl_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ADCCtl;

#ifdef __cplusplus

class DECLSPEC_UUID("3964D9A0-AC96-11D1-9851-00C04FD91972")
ADCCtl;
#endif

#ifndef __IInstalledApp_INTERFACE_DEFINED__
#define __IInstalledApp_INTERFACE_DEFINED__

/* interface IInstalledApp */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IInstalledApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1BC752DF-9046-11D1-B8B3-006008059382")
    IInstalledApp : public IShellApp
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Uninstall( 
            HWND hwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Modify( 
            HWND hwndParent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Repair( 
            /* [in] */ BOOL bReinstall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Upgrade( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstalledAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstalledApp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstalledApp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstalledApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppInfo )( 
            IInstalledApp * This,
            /* [out][in] */ PAPPINFODATA pai);
        
        HRESULT ( STDMETHODCALLTYPE *GetPossibleActions )( 
            IInstalledApp * This,
            /* [out] */ DWORD *pdwActions);
        
        HRESULT ( STDMETHODCALLTYPE *GetSlowAppInfo )( 
            IInstalledApp * This,
            /* [in] */ PSLOWAPPINFO psaid);
        
        HRESULT ( STDMETHODCALLTYPE *GetCachedSlowAppInfo )( 
            IInstalledApp * This,
            /* [in] */ PSLOWAPPINFO psaid);
        
        HRESULT ( STDMETHODCALLTYPE *IsInstalled )( 
            IInstalledApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *Uninstall )( 
            IInstalledApp * This,
            HWND hwnd);
        
        HRESULT ( STDMETHODCALLTYPE *Modify )( 
            IInstalledApp * This,
            HWND hwndParent);
        
        HRESULT ( STDMETHODCALLTYPE *Repair )( 
            IInstalledApp * This,
            /* [in] */ BOOL bReinstall);
        
        HRESULT ( STDMETHODCALLTYPE *Upgrade )( 
            IInstalledApp * This);
        
        END_INTERFACE
    } IInstalledAppVtbl;

    interface IInstalledApp
    {
        CONST_VTBL struct IInstalledAppVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstalledApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstalledApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstalledApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstalledApp_GetAppInfo(This,pai)	\
    (This)->lpVtbl -> GetAppInfo(This,pai)

#define IInstalledApp_GetPossibleActions(This,pdwActions)	\
    (This)->lpVtbl -> GetPossibleActions(This,pdwActions)

#define IInstalledApp_GetSlowAppInfo(This,psaid)	\
    (This)->lpVtbl -> GetSlowAppInfo(This,psaid)

#define IInstalledApp_GetCachedSlowAppInfo(This,psaid)	\
    (This)->lpVtbl -> GetCachedSlowAppInfo(This,psaid)

#define IInstalledApp_IsInstalled(This)	\
    (This)->lpVtbl -> IsInstalled(This)


#define IInstalledApp_Uninstall(This,hwnd)	\
    (This)->lpVtbl -> Uninstall(This,hwnd)

#define IInstalledApp_Modify(This,hwndParent)	\
    (This)->lpVtbl -> Modify(This,hwndParent)

#define IInstalledApp_Repair(This,bReinstall)	\
    (This)->lpVtbl -> Repair(This,bReinstall)

#define IInstalledApp_Upgrade(This)	\
    (This)->lpVtbl -> Upgrade(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstalledApp_Uninstall_Proxy( 
    IInstalledApp * This,
    HWND hwnd);


void __RPC_STUB IInstalledApp_Uninstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstalledApp_Modify_Proxy( 
    IInstalledApp * This,
    HWND hwndParent);


void __RPC_STUB IInstalledApp_Modify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstalledApp_Repair_Proxy( 
    IInstalledApp * This,
    /* [in] */ BOOL bReinstall);


void __RPC_STUB IInstalledApp_Repair_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IInstalledApp_Upgrade_Proxy( 
    IInstalledApp * This);


void __RPC_STUB IInstalledApp_Upgrade_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstalledApp_INTERFACE_DEFINED__ */


#ifndef __IEnumInstalledApps_INTERFACE_DEFINED__
#define __IEnumInstalledApps_INTERFACE_DEFINED__

/* interface IEnumInstalledApps */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IEnumInstalledApps;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1BC752E1-9046-11D1-B8B3-006008059382")
    IEnumInstalledApps : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [out] */ IInstalledApp **pia) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumInstalledAppsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumInstalledApps * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumInstalledApps * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumInstalledApps * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumInstalledApps * This,
            /* [out] */ IInstalledApp **pia);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumInstalledApps * This);
        
        END_INTERFACE
    } IEnumInstalledAppsVtbl;

    interface IEnumInstalledApps
    {
        CONST_VTBL struct IEnumInstalledAppsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumInstalledApps_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumInstalledApps_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumInstalledApps_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumInstalledApps_Next(This,pia)	\
    (This)->lpVtbl -> Next(This,pia)

#define IEnumInstalledApps_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumInstalledApps_Next_Proxy( 
    IEnumInstalledApps * This,
    /* [out] */ IInstalledApp **pia);


void __RPC_STUB IEnumInstalledApps_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInstalledApps_Reset_Proxy( 
    IEnumInstalledApps * This);


void __RPC_STUB IEnumInstalledApps_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumInstalledApps_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_EnumInstalledApps;

#ifdef __cplusplus

class DECLSPEC_UUID("0B124F8F-91F0-11D1-B8B5-006008059382")
EnumInstalledApps;
#endif

#ifndef __IShellAppManager_INTERFACE_DEFINED__
#define __IShellAppManager_INTERFACE_DEFINED__

/* interface IShellAppManager */
/* [object][helpstring][uuid] */ 

typedef struct _ShellAppCategory
    {
    LPWSTR pszCategory;
    UINT idCategory;
    } 	SHELLAPPCATEGORY;

typedef struct _ShellAppCategory *PSHELLAPPCATEGORY;

typedef struct _ShellAppCategoryList
    {
    UINT cCategories;
    SHELLAPPCATEGORY *pCategory;
    } 	SHELLAPPCATEGORYLIST;

typedef struct _ShellAppCategoryList *PSHELLAPPCATEGORYLIST;


EXTERN_C const IID IID_IShellAppManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("352EC2B8-8B9A-11D1-B8AE-006008059382")
    IShellAppManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNumberofInstalledApps( 
            DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInstalledApps( 
            IEnumInstalledApps **peia) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPublishedAppCategories( 
            PSHELLAPPCATEGORYLIST pCategoryList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPublishedApps( 
            LPCWSTR pszCategory,
            IEnumPublishedApps **ppepa) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallFromFloppyOrCDROM( 
            HWND hwndParent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellAppManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellAppManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellAppManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellAppManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumberofInstalledApps )( 
            IShellAppManager * This,
            DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInstalledApps )( 
            IShellAppManager * This,
            IEnumInstalledApps **peia);
        
        HRESULT ( STDMETHODCALLTYPE *GetPublishedAppCategories )( 
            IShellAppManager * This,
            PSHELLAPPCATEGORYLIST pCategoryList);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPublishedApps )( 
            IShellAppManager * This,
            LPCWSTR pszCategory,
            IEnumPublishedApps **ppepa);
        
        HRESULT ( STDMETHODCALLTYPE *InstallFromFloppyOrCDROM )( 
            IShellAppManager * This,
            HWND hwndParent);
        
        END_INTERFACE
    } IShellAppManagerVtbl;

    interface IShellAppManager
    {
        CONST_VTBL struct IShellAppManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellAppManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellAppManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellAppManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellAppManager_GetNumberofInstalledApps(This,pdwResult)	\
    (This)->lpVtbl -> GetNumberofInstalledApps(This,pdwResult)

#define IShellAppManager_EnumInstalledApps(This,peia)	\
    (This)->lpVtbl -> EnumInstalledApps(This,peia)

#define IShellAppManager_GetPublishedAppCategories(This,pCategoryList)	\
    (This)->lpVtbl -> GetPublishedAppCategories(This,pCategoryList)

#define IShellAppManager_EnumPublishedApps(This,pszCategory,ppepa)	\
    (This)->lpVtbl -> EnumPublishedApps(This,pszCategory,ppepa)

#define IShellAppManager_InstallFromFloppyOrCDROM(This,hwndParent)	\
    (This)->lpVtbl -> InstallFromFloppyOrCDROM(This,hwndParent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellAppManager_GetNumberofInstalledApps_Proxy( 
    IShellAppManager * This,
    DWORD *pdwResult);


void __RPC_STUB IShellAppManager_GetNumberofInstalledApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_EnumInstalledApps_Proxy( 
    IShellAppManager * This,
    IEnumInstalledApps **peia);


void __RPC_STUB IShellAppManager_EnumInstalledApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_GetPublishedAppCategories_Proxy( 
    IShellAppManager * This,
    PSHELLAPPCATEGORYLIST pCategoryList);


void __RPC_STUB IShellAppManager_GetPublishedAppCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_EnumPublishedApps_Proxy( 
    IShellAppManager * This,
    LPCWSTR pszCategory,
    IEnumPublishedApps **ppepa);


void __RPC_STUB IShellAppManager_EnumPublishedApps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellAppManager_InstallFromFloppyOrCDROM_Proxy( 
    IShellAppManager * This,
    HWND hwndParent);


void __RPC_STUB IShellAppManager_InstallFromFloppyOrCDROM_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellAppManager_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellAppManager;

#ifdef __cplusplus

class DECLSPEC_UUID("352EC2B7-8B9A-11D1-B8AE-006008059382")
ShellAppManager;
#endif
#endif /* __SHAPPMGRPLib_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_shappmgrp_0264 */
/* [local] */ 

#endif // _SHAPPMGRP_H_


extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0264_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shappmgrp_0264_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\msprintx.h ===
//////////////////////////////////////////////////////////////////////////
//
// This is the public header file for apps that call MSPRINT.DLL
//
//////////////////////////////////////////////////////////////////////////

#ifdef _WIN32

// Typedef for the following function:
//
// BOOL WINAPI PrinterSetup32(HWND hWnd,WORD wAction,WORD wBufSize,
//                            LPBYTE lpBuffer,LPWORD lpwRequired);

typedef BOOL (WINAPI* PRINTERSETUPPROC32)(HWND,WORD,WORD,LPBYTE,LPWORD);

#define MSPRINT2_PRINTERSETUP32  ("PrinterSetup32")

#endif

#define MSP_NEWPRINTER             1
#define MSP_NETPRINTER             2
#define MSP_NEWDRIVER              3
#define MSP_NETADMIN               4
#define MSP_TESTPAGEFULLPROMPT     5
#define MSP_TESTPAGEPARTIALPROMPT  6
#define MSP_TESTPAGENOPROMPT       7
#define MSP_REMOVEPRINTER          8
#define MSP_SPOOLERFOUNDPRINTER    9
#define MSP_REMOVENETPRINTER       10
#define MSP_NEWPRINTER_MODELESS    11
#define MSP_FINDPRINTER            12

#if 0

#define MSPRINT_TESTONLY

#define MSP_BATCHPRINTERS        100

#define PBD_INSTALLED             1L

typedef struct tagONEPRINTERBATCHDATA
{
    char  szFriendlyName[32];
    char  szModelName[32];
    char  szPort[60];
    DWORD dwFlags;
} ONEPRINTERBATCHDATA, FAR * LPONEPRINTERBATCHDATA;

typedef struct tagPRINTERBATCHDATA
{
    char                szFileSource[60];
    DWORD               dwCount;
    ONEPRINTERBATCHDATA Printers[1];
} PRINTERBATCHDATA, FAR * LPPRINTERBATCHDATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\powrprofp.h ===
/*****************************************************************************\
*                                                                             *
* powrprof.h - - Interface for powrprof.dll, the power policy applicator      *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

// Debug definitions used by power management UI.
#ifdef DEBUG

void CDECL DebugPrintA(LPCSTR pszFmt, ...);

#define DebugPrint               DebugPrintA

#else  // DEBUG

#define DebugPrint        1 ? (void)0 : (void)

#endif // DEBUG


// Define the following to debug batmeter on machines with no battery support.
//#define SIM_BATTERY 1

#define CURRENT_REVISION 1

#define STRSIZE(psz) ((lstrlen(psz) + 1) * sizeof(TCHAR))

#define MAX_NAME_LEN  32    // Max length of name in characters.
#define MAX_NAME_SIZE (MAX_NAME_LEN +1) * sizeof(TCHAR)

#define MAX_DESC_LEN  512   // Max length of description in characters.
#define MAX_DESC_SIZE (MAX_DESC_LEN +1) * sizeof(TCHAR)

#define SEMAPHORE_TIMEOUT  10000

#define NUM_DEC_DIGITS 10+1+1       // 10 digits + NUll and sign.
#define SIZE_DEC_DIGITS (10+1+1) * sizeof(TCHAR)

// Registry storage structures for the GLOBAL_POWER_POLICY data. There are two
// structures, GLOBAL_MACHINE_POWER_POLICY and GLOBAL_USER_POWER_POLICY. the
// GLOBAL_MACHINE_POWER_POLICY stores per machine data for which there is no UI.
// GLOBAL_USER_POWER_POLICY stores the per user data.

typedef struct _GLOBAL_MACHINE_POWER_POLICY{
    ULONG                   Revision;
    SYSTEM_POWER_STATE      LidOpenWakeAc;
    SYSTEM_POWER_STATE      LidOpenWakeDc;
    ULONG                   BroadcastCapacityResolution;
} GLOBAL_MACHINE_POWER_POLICY, *PGLOBAL_MACHINE_POWER_POLICY;

typedef struct _GLOBAL_USER_POWER_POLICY{
    ULONG                   Revision;
    POWER_ACTION_POLICY     PowerButtonAc;
    POWER_ACTION_POLICY     PowerButtonDc;
    POWER_ACTION_POLICY     SleepButtonAc;
    POWER_ACTION_POLICY     SleepButtonDc;
    POWER_ACTION_POLICY     LidCloseAc;
    POWER_ACTION_POLICY     LidCloseDc;
    SYSTEM_POWER_LEVEL      DischargePolicy[NUM_DISCHARGE_POLICIES];
    ULONG                   GlobalFlags;
} GLOBAL_USER_POWER_POLICY, *PGLOBAL_USER_POWER_POLICY;

// Structure to manage global power policies at the user level. This structure
// contains data which is common across all power policy profiles.

typedef struct _GLOBAL_POWER_POLICY{
    GLOBAL_USER_POWER_POLICY    user;
    GLOBAL_MACHINE_POWER_POLICY mach;
} GLOBAL_POWER_POLICY, *PGLOBAL_POWER_POLICY;


// Registry storage structures for the POWER_POLICY data. There are three
// structures, MACHINE_POWER_POLICY, MACHINE_PROCESSOR_POWER_POLICY and USER_POWER_POLICY. the
// MACHINE_POWER_POLICY stores per machine data for which there is no UI.
// USER_POWER_POLICY stores the per user data.

typedef struct _MACHINE_POWER_POLICY{
    ULONG                   Revision;       // 1

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MinSleepAc;
    SYSTEM_POWER_STATE      MinSleepDc;
    SYSTEM_POWER_STATE      ReducedLatencySleepAc;
    SYSTEM_POWER_STATE      ReducedLatencySleepDc;

    // parameters for dozing
    ULONG                   DozeTimeoutAc;
    ULONG                   DozeTimeoutDc;
    ULONG                   DozeS4TimeoutAc;
    ULONG                   DozeS4TimeoutDc;

    // processor policies
    UCHAR                   MinThrottleAc;
    UCHAR                   MinThrottleDc;
    UCHAR                   pad1[2];
    POWER_ACTION_POLICY     OverThrottledAc;
    POWER_ACTION_POLICY     OverThrottledDc;

} MACHINE_POWER_POLICY, *PMACHINE_POWER_POLICY;

typedef struct _MACHINE_PROCESSOR_POWER_POLICY {
    ULONG                   Revision;       // 1
    
    PROCESSOR_POWER_POLICY  ProcessorPolicyAc;    
    PROCESSOR_POWER_POLICY  ProcessorPolicyDc;    

} MACHINE_PROCESSOR_POWER_POLICY, *PMACHINE_PROCESSOR_POWER_POLICY;

typedef struct _USER_POWER_POLICY{
    ULONG                   Revision;       // 1


    // "system idle" detection
    POWER_ACTION_POLICY     IdleAc;
    POWER_ACTION_POLICY     IdleDc;
    ULONG                   IdleTimeoutAc;
    ULONG                   IdleTimeoutDc;
    UCHAR                   IdleSensitivityAc;
    UCHAR                   IdleSensitivityDc;
    
    // Throttling Policy
    UCHAR                   ThrottlePolicyAc;
    UCHAR                   ThrottlePolicyDc;

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MaxSleepAc;
    SYSTEM_POWER_STATE      MaxSleepDc;

    // For future use
    ULONG                   Reserved[2];

    // video policies
    ULONG                   VideoTimeoutAc;
    ULONG                   VideoTimeoutDc;

    // hard disk policies
    ULONG                   SpindownTimeoutAc;
    ULONG                   SpindownTimeoutDc;

    // processor policies
    BOOLEAN                 OptimizeForPowerAc;
    BOOLEAN                 OptimizeForPowerDc;
    UCHAR                   FanThrottleToleranceAc;
    UCHAR                   FanThrottleToleranceDc;
    UCHAR                   ForcedThrottleAc;
    UCHAR                   ForcedThrottleDc;
    
} USER_POWER_POLICY, *PUSER_POWER_POLICY;

// Structure to manage power policies at the user level. This structure
// contains data which is unique across power policy profiles.

typedef struct _POWER_POLICY{
    USER_POWER_POLICY       user;
    MACHINE_POWER_POLICY    mach;
} POWER_POLICY, *PPOWER_POLICY;


// Constants for GlobalFlags

#define EnableSysTrayBatteryMeter   0x01
#define EnableMultiBatteryDisplay   0x02
#define EnablePasswordLogon         0x04
#define EnableWakeOnRing            0x08
#define EnableVideoDimDisplay       0x10

// This constant is passed as a uiID to WritePwrScheme.
#define NEWSCHEME (UINT)-1

// Prototype for EnumPwrSchemes callback proceedures.

typedef BOOLEAN (CALLBACK* PWRSCHEMESENUMPROC)(UINT, DWORD, LPTSTR, DWORD, LPTSTR, PPOWER_POLICY, LPARAM);
typedef BOOLEAN (CALLBACK* PFNNTINITIATEPWRACTION)(POWER_ACTION, SYSTEM_POWER_STATE, ULONG, BOOLEAN);

// Public function prototypes

BOOLEAN WINAPI GetPwrDiskSpindownRange(PUINT, PUINT);
BOOLEAN WINAPI EnumPwrSchemes(PWRSCHEMESENUMPROC, LPARAM);
BOOLEAN WINAPI ReadGlobalPwrPolicy(PGLOBAL_POWER_POLICY);
BOOLEAN WINAPI ReadPwrScheme(UINT, PPOWER_POLICY);
BOOLEAN WINAPI WritePwrScheme(PUINT, LPTSTR, LPTSTR, PPOWER_POLICY);
BOOLEAN WINAPI WriteGlobalPwrPolicy(PGLOBAL_POWER_POLICY);
BOOLEAN WINAPI DeletePwrScheme(UINT);
BOOLEAN WINAPI GetActivePwrScheme(PUINT);
BOOLEAN WINAPI SetActivePwrScheme(UINT, PGLOBAL_POWER_POLICY, PPOWER_POLICY);
BOOLEAN WINAPI GetPwrCapabilities(PSYSTEM_POWER_CAPABILITIES);
BOOLEAN WINAPI IsPwrSuspendAllowed(VOID);
BOOLEAN WINAPI IsPwrHibernateAllowed(VOID);
BOOLEAN WINAPI IsPwrShutdownAllowed(VOID);
BOOLEAN WINAPI IsAdminOverrideActive(PADMINISTRATOR_POWER_POLICY);
BOOLEAN WINAPI SetSuspendState(BOOLEAN, BOOLEAN, BOOLEAN);
BOOLEAN WINAPI GetCurrentPowerPolicies(PGLOBAL_POWER_POLICY, PPOWER_POLICY);
BOOLEAN WINAPI CanUserWritePwrScheme(VOID);
BOOLEAN WINAPI ReadProcessorPwrScheme(UINT, PMACHINE_PROCESSOR_POWER_POLICY);
BOOLEAN WINAPI WriteProcessorPwrScheme(UINT, PMACHINE_PROCESSOR_POWER_POLICY);

#ifndef NT_SUCCESS
#define NTSTATUS LONG
#define _OVERRIDE_NTSTATUS_
#endif

NTSTATUS WINAPI CallNtPowerInformation(POWER_INFORMATION_LEVEL, PVOID, ULONG, PVOID, ULONG);

#ifdef _OVERRIDE_NTSTATUS_
#undef NTSTATUS
#endif

void WINAPI LoadCurrentPwrScheme(HWND hwnd, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow);
void WINAPI MergeLegacyPwrScheme(HWND hwnd, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow);


// Private function prototypes implemented in powrprof.c
BOOLEAN ValidatePowerPolicies(PGLOBAL_POWER_POLICY, PPOWER_POLICY);
BOOLEAN ValidateSystemPolicies(PSYSTEM_POWER_POLICY, PSYSTEM_POWER_POLICY);
BOOLEAN GetCurrentSystemPowerPolicies(PSYSTEM_POWER_POLICY, PSYSTEM_POWER_POLICY);
BOOLEAN MyStrToInt(LPCTSTR, PINT);
BOOLEAN RegistryInit(PUINT);
HANDLE  MyCreateSemaphore(LPCTSTR);

NTSTATUS CallNtSetValidateAcDc(BOOLEAN, BOOLEAN, PVOID, PVOID, PVOID, PVOID);
void CDECL DebugPrintA(LPCSTR pszFmt, ...);

DWORD SetPrivilegeAttribute(LPCTSTR, DWORD, LPDWORD);
VOID  InitAdmin(PADMINISTRATOR_POWER_POLICY papp);

#ifdef DEBUG
VOID ReadOptionalDebugSettings(VOID);
#endif

// Private function prototypes implemented in reghelp.c:
BOOLEAN OpenCurrentUser(PHKEY phKey);
BOOLEAN CloseCurrentUser(HKEY hKey);
BOOLEAN OpenMachineUserKeys(LPTSTR, LPTSTR, PHKEY, PHKEY);
BOOLEAN TakeRegSemaphore(VOID);
BOOLEAN WritePwrPolicyEx(LPTSTR, LPTSTR, PUINT, LPTSTR, LPTSTR, LPVOID, DWORD, LPVOID, DWORD);
BOOLEAN ReadPwrPolicyEx(LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPDWORD, LPVOID, DWORD, LPVOID, DWORD);
BOOLEAN ReadWritePowerValue(HKEY, LPTSTR, LPTSTR, LPTSTR, LPDWORD, BOOLEAN, BOOLEAN);
BOOLEAN ReadPowerValueOptional(HKEY, LPTSTR, LPTSTR, LPTSTR, LPDWORD);
BOOLEAN ReadPowerIntOptional(HKEY, LPTSTR, LPTSTR, PINT);
BOOLEAN CreatePowerValue(HKEY, LPCTSTR, LPCTSTR, LPCTSTR);

// Private function prototypes implemented in merge.c
BOOLEAN MergePolicies(PUSER_POWER_POLICY, PMACHINE_POWER_POLICY, PPOWER_POLICY);
BOOLEAN SplitPolicies(PPOWER_POLICY, PUSER_POWER_POLICY, PMACHINE_POWER_POLICY);
BOOLEAN MergeGlobalPolicies(PGLOBAL_USER_POWER_POLICY, PGLOBAL_MACHINE_POWER_POLICY, PGLOBAL_POWER_POLICY);
BOOLEAN SplitGlobalPolicies(PGLOBAL_POWER_POLICY, PGLOBAL_USER_POWER_POLICY, PGLOBAL_MACHINE_POWER_POLICY);
BOOLEAN MergeToSystemPowerPolicies(PGLOBAL_POWER_POLICY, PPOWER_POLICY, PSYSTEM_POWER_POLICY, PSYSTEM_POWER_POLICY);
BOOLEAN SplitFromSystemPowerPolicies(PSYSTEM_POWER_POLICY, PSYSTEM_POWER_POLICY, PGLOBAL_POWER_POLICY, PPOWER_POLICY);

// Private function prototypes implemented in debug.c
#ifdef DEBUG
void DumpPowerActionPolicy(LPSTR, PPOWER_ACTION_POLICY);
void DumpSystemPowerLevel(LPSTR, PSYSTEM_POWER_LEVEL);
void DumpSystemPowerPolicy(LPSTR, PSYSTEM_POWER_POLICY);
void DumpSystemPowerCapabilities(LPSTR, PSYSTEM_POWER_CAPABILITIES);
void DifSystemPowerPolicies(LPSTR, PSYSTEM_POWER_POLICY, PSYSTEM_POWER_POLICY);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\pif.h ===
/*
 *  Microsoft  Confidential
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  All Rights Reserved.
 *
 *
 *  PIF.H
 *  DOS Program Information File structures, constants, etc.
 */


#ifndef _INC_PIF
#define _INC_PIF

#include <shlobj.h>

/* XLATOFF */
#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */
/* XLATON */

// for DOJ compliance, size defines moved to shlobj.w

#ifndef LF_FACESIZE
#define LF_FACESIZE     32
#endif

#define LARGEST_GROUP   sizeof(PROPPRG)

// for DOJ compliance, some property flags moved to shlobj.h
#define OPENPROPS_RAWIO         0x0001		//;Internal
#define OPENPROPS_INFONLY       0x0002		//;Internal
#define OPENPROPS_FORCEREALMODE 0x0004		//;Internal

#define GETPROPS_RAWIO          0x0001		//;Internal
#define GETPROPS_EXTENDED       0x0004          //;Internal
#define GETPROPS_OEM            0x0008		//;Internal

#define FLUSHPROPS_NONE         0x0000		//;Internal
#define FLUSHPROPS_DISCARD      0x0001		//;Internal

#define CREATEPROPS_NONE        0x0000		//;Internal

#define SETPROPS_RAWIO          0x0001		//;Internal
#define SETPROPS_CACHE          0x0002		//;Internal
#define SETPROPS_EXTENDED       0x0004          //;Internal
#define SETPROPS_OEM            0x0008		//;Internal

#define DELETEPROPS_NONE        0x0000		
#define DELETEPROPS_DISCARD     0x0001		
#define DELETEPROPS_ABORT       0x0002

#define LOADPROPLIB_DEFER       0x0001



/* XLATOFF */
#ifndef FAR
#define FAR
#endif
/* XLATON */

//#ifdef  RECT
//#define _INC_WINDOWS
//#endif

//#ifndef _INC_WINDOWS

/* ASM
RECT    struc
        rcLeft      dw  ?
        rcTop       dw  ?
        rcRight     dw  ?
        rcBottom    dw  ?
RECT    ends
*/

/* XLATOFF */
typedef struct tagPIFRECT {
    WORD left;
    WORD top;
    WORD right;
    WORD bottom;
} PIFRECT;
typedef PIFRECT *PPIFRECT;
typedef PIFRECT FAR *LPPIFRECT;
/* XLATON */

//#endif


/*
 *  Property groups, used by PIFMGR.DLL and VxD interfaces
 *
 *  The structures for each of the pre-defined, ordinal-based groups
 *  is a logical view of data in the associated PIF file, if any -- not a
 *  physical view.
 */

#define GROUP_PRG               1           // program group

#define PRG_DEFAULT             0
#define PRG_CLOSEONEXIT         0x0001      // MSflags & EXITMASK
#define PRG_NOSUGGESTMSDOS      0x0400      // see also: PfW386Flags & fNoSuggestMSDOS

#define PRGINIT_DEFAULT         0
#define PRGINIT_MINIMIZED       0x0001      // see also: PfW386Flags & fMinimized
#define PRGINIT_MAXIMIZED       0x0002      // see also: PfW386Flags & fMaximized
#define PRGINIT_WINLIE          0x0004      // see also: PfW386Flags & fWinLie
#define PRGINIT_REALMODE        0x0008      // see also: PfW386Flags & fRealMode
#define PRGINIT_REALMODESILENT  0x0100      // see also: PfW386Flags & fRealModeSilent
#define PRGINIT_QUICKSTART      0x0200      // see also: PfW386Flags & fQuickStart  /* ;Internal */
#define PRGINIT_AMBIGUOUSPIF    0x0400      // see also: PfW386Flags & fAmbiguousPIF
#define PRGINIT_NOPIF           0x1000      // no PIF found
#define PRGINIT_DEFAULTPIF      0x2000      // default PIF found
#define PRGINIT_INFSETTINGS     0x4000      // INF settings found
#define PRGINIT_INHIBITPIF      0x8000      // INF indicates that no PIF be created

/*
 *  Real mode option flags.  NOTE: this field is a dword.  The low word
 *  uses these flags to indicate required options.  The high word is used
 *  to specify "nice" but not required options.
 */
#define RMOPT_MOUSE             0x0001      // Real mode mouse
#define RMOPT_EMS               0x0002      // Expanded Memory
#define RMOPT_CDROM             0x0004      // CD-ROM support
#define RMOPT_NETWORK           0x0008      // Network support
#define RMOPT_DISKLOCK          0x0010      // disk locking required
#define RMOPT_PRIVATECFG        0x0020      // use private configuration (ie, CONFIG/AUTOEXEC)
#define RMOPT_VESA              0x0040      // VESA driver


#define ICONFILE_DEFAULT        TEXT("PIFMGR.DLL")
#define ICONINDEX_DEFAULT       0


// for DOJ compliance, PROPPRG moved to shlobj.w


#define GROUP_TSK               2           // tasking group

#define TSK_DEFAULT             (TSK_BACKGROUND)
#define TSK_ALLOWCLOSE          0x0001      // PfW386Flags & fEnableClose
#define TSK_BACKGROUND          0x0002      // PfW386Flags & fBackground
#define TSK_EXCLUSIVE           0x0004      // PfW386Flags & fExclusive             /* ;Internal */
#define TSK_NOWARNTERMINATE     0x0010      // Don't warn before closing
#define TSK_NOSCREENSAVER       0x0020      // Do not activate screen saver

#define TSKINIT_DEFAULT         0

#define TSKFGNDBOOST_DEFAULT    0           // fgnd boost                           /* ;Internal */
#define TSKBGNDBOOST_DEFAULT    0           // bgnd boost                           /* ;Internal */
                                                                                    /* ;Internal */
#define TSKFGND_OLD_DEFAULT     100         // normal fgnd setting                  /* ;Internal */
#define TSKBGND_OLD_DEFAULT     50          // normal bgnd setting                  /* ;Internal */
                                                                                    /* ;Internal */
#define TSKIDLESENS_DEFAULT     50          // % (min-max == 0-100)

typedef struct PROPTSK {                    /* tsk */
    WORD    flTsk;                          // see TSK_ flags
    WORD    flTskInit;                      // see TSKINIT_ flags
    WORD    wReserved1;                     // (reserved, must be zero)
    WORD    wReserved2;                     // (reserved, must be zero)
    WORD    wReserved3;                     // (reserved, must be zero)
    WORD    wReserved4;                     // (reserved, must be zero)
    WORD    wIdleSensitivity;               // %, also affects PfW386Flags & fPollingDetect
} PROPTSK;
typedef UNALIGNED PROPTSK *PPROPTSK;
typedef UNALIGNED PROPTSK FAR *LPPROPTSK;


#define GROUP_VID               3           // video group

#define VID_DEFAULT             (VID_TEXTEMULATE)
#define VID_TEXTEMULATE         0x0001      // PfW386Flags2 & fVidTxtEmulate
#define VID_RETAINMEMORY        0x0080      // PfW386Flags2 & fVidRetainAllo
#define VID_FULLSCREEN          0x0100      // PfW386Flags  & fFullScreen

#define VIDINIT_DEFAULT         0

#define VIDSCREENLINES_MIN      0           // in # lines (0 = use VDD value)
#define VIDSCREENLINES_DEFAULT  0           // in # lines
#define VIDSCREENLINES_MAX      50          // in # lines                           /* ;Internal */

typedef struct PROPVID {                    /* vid */
    WORD    flVid;                          // see VID_ flags
    WORD    flVidInit;                      // see VIDINIT_ flags
    WORD    wReserved1;                     // (reserved, must be zero)
    WORD    wReserved2;                     // (reserved, must be zero)
    WORD    wReserved3;                     // (reserved, must be zero)
    WORD    cScreenLines;                   // ([NonWindowsApp]:ScreenLines)
} PROPVID;
typedef UNALIGNED PROPVID *PPROPVID;
typedef UNALIGNED PROPVID FAR *LPPROPVID;


#define GROUP_MEM               4           // memory group

#define MEM_DEFAULT             0

#define MEMINIT_DEFAULT         0
#define MEMINIT_NOHMA           0x0001      // PfW386Flags & fNoHMA
#define MEMINIT_LOWLOCKED       0x0002      // PfW386Flags & fVMLocked
#define MEMINIT_EMSLOCKED       0x0004      // PfW386Flags & fEMSLocked
#define MEMINIT_XMSLOCKED       0x0008      // PfW386Flags & fXMSLocked
#define MEMINIT_GLOBALPROTECT   0x0010      // PfW386Flags & fGlobalProtect
#define MEMINIT_STRAYPTRDETECT  0x0020      // PfW386Flags & fStrayPtrDetect        /* ;Internal */
#define MEMINIT_LOCALUMBS       0x0040      // PfW386Flags & fLocalUMBs             /* ;Internal */

#define MEMLOW_MIN              0           // in KB
#define MEMLOW_DEFAULT          0           // in KB
#define MEMLOW_MAX              640         // in KB

#define MEMEMS_MIN              0           // in KB
#define MEMEMS_DEFAULT          0           // in KB
#define MEMEMS_MAX              0xFFFF      // in KB

#define MEMXMS_MIN              0           // in KB
#define MEMXMS_DEFAULT          0           // in KB
#define MEMXMS_MAX              0xFFFF      // in KB

typedef struct PROPMEM {                    /* mem */
    WORD    flMem;                          // see MEM_ flags
    WORD    flMemInit;                      // see MEMINIT_ flags
    WORD    wMinLow;                        // PfW386minmem
    WORD    wMaxLow;                        // PfW386maxmem
    WORD    wMinEMS;                        // PfMinEMMK
    WORD    wMaxEMS;                        // PfMaxEMMK
    WORD    wMinXMS;                        // PfMinXmsK
    WORD    wMaxXMS;                        // PfMaxXmsK
} PROPMEM;
typedef UNALIGNED PROPMEM *PPROPMEM;
typedef UNALIGNED PROPMEM FAR *LPPROPMEM;


#define GROUP_KBD               5           // keyboard group

#define KBD_DEFAULT             (KBD_FASTPASTE)
#define KBD_FASTPASTE           0x0001      // PfW386Flags & fINT16Paste
#define KBD_NOALTTAB            0x0020      // PfW386Flags & fALTTABdis
#define KBD_NOALTESC            0x0040      // PfW386Flags & fALTESCdis
#define KBD_NOALTSPACE          0x0080      // PfW386Flags & fALTSPACEdis
#define KBD_NOALTENTER          0x0100      // PfW386Flags & fALTENTERdis
#define KBD_NOALTPRTSC          0x0200      // PfW386Flags & fALTPRTSCdis
#define KBD_NOPRTSC             0x0400      // PfW386Flags & fPRTSCdis
#define KBD_NOCTRLESC           0x0800      // PfW386Flags & fCTRLESCdis

#define KBDINIT_DEFAULT         0

#define KBDALTDELAY_MIN             1
#define KBDALTDELAY_DEFAULT         5
#define KBDALTDELAY_MAX             5000

#define KBDALTPASTEDELAY_MIN        1
#define KBDALTPASTEDELAY_DEFAULT    25
#define KBDALTPASTEDELAY_MAX        5000

#define KBDPASTEDELAY_MIN           1
#define KBDPASTEDELAY_DEFAULT       3
#define KBDPASTEDELAY_MAX           5000

#define KBDPASTEFULLDELAY_MIN       1
#define KBDPASTEFULLDELAY_DEFAULT   200
#define KBDPASTEFULLDELAY_MAX       5000

#define KBDPASTETIMEOUT_MIN         1
#define KBDPASTETIMEOUT_DEFAULT     1000
#define KBDPASTETIMEOUT_MAX         5000

#define KBDPASTESKIP_MIN            1
#define KBDPASTESKIP_DEFAULT        2
#define KBDPASTESKIP_MAX            100

#define KBDPASTECRSKIP_MIN          1
#define KBDPASTECRSKIP_DEFAULT      10
#define KBDPASTECRSKIP_MAX          100

typedef struct PROPKBD {                    /* kbd */
    WORD    flKbd;                          // see KBD_ flags
    WORD    flKbdInit;                      // see KBDINIT_ flags
    WORD    msAltDelay;                     // ([386Enh]:AltKeyDelay)
    WORD    msAltPasteDelay;                // ([386Enh]:AltPasteDelay)
    WORD    msPasteDelay;                   // ([386Enh]:KeyPasteDelay)
    WORD    msPasteFullDelay;               // ([386Enh]:KeyBufferDelay)
    WORD    msPasteTimeout;                 // ([386Enh]:KeyPasteTimeOut)
    WORD    cPasteSkip;                     // ([386Enh]:KeyPasteSkipCount)
    WORD    cPasteCRSkip;                   // ([386Enh]:KeyPasteCRSkipCount)
} PROPKBD;
typedef UNALIGNED PROPKBD *PPROPKBD;
typedef UNALIGNED PROPKBD FAR *LPPROPKBD;


#define GROUP_MSE               6           // mouse group

/* No VxD currently pays attention to PROPMSE. VMDOSAPP should know how to
 * handle all cases resulting from a change in these flags.
 *
 * Note that MSE_WINDOWENABLE corresponds to the Windows NT "QuickEdit"
 * property, except backwards.
 */

#define MSE_DEFAULT             (MSE_WINDOWENABLE)
#define MSE_WINDOWENABLE        0x0001      // ([NonWindowsApp]:MouseInDosBox)
#define MSE_EXCLUSIVE           0x0002      //

#define MSEINIT_DEFAULT         0           // default flags

typedef struct PROPMSE {                    /* mse */
    WORD    flMse;                          // see MSE_ flags
    WORD    flMseInit;                      // see MSEINIT_ flags
} PROPMSE;
typedef UNALIGNED PROPMSE *PPROPMSE;
typedef UNALIGNED PROPMSE FAR *LPPROPMSE;


#define GROUP_SND               7           // sound group                  /* ;Internal */
                                                                            /* ;Internal */
#define SND_DEFAULT             (SND_SPEAKERENABLE)                         /* ;Internal */
#define SND_SPEAKERENABLE       0x0001      //                              /* ;Internal */
                                                                            /* ;Internal */
#define SNDINIT_DEFAULT         0                                           /* ;Internal */
                                                                            /* ;Internal */
typedef struct PROPSND {                    /* snd */                       /* ;Internal */
    WORD    flSnd;                          // see SND_ flags               /* ;Internal */
    WORD    flSndInit;                      // see SNDINIT_ flags           /* ;Internal */
} PROPSND;                                                                  /* ;Internal */
typedef UNALIGNED PROPSND *PPROPSND;                                        /* ;Internal */
typedef UNALIGNED PROPSND FAR *LPPROPSND;                                   /* ;Internal */
                                                                            /* ;Internal */
                                                                            /* ;Internal */
#define GROUP_FNT               8           // font group

#define FNT_DEFAULT             (FNT_BOTHFONTS | FNT_AUTOSIZE)
#define FNT_RASTERFONTS         0x0004      // allow raster fonts in dialog
#define FNT_TTFONTS             0x0008      // allow truetype fonts in dialog
#define FNT_BOTHFONTS           (FNT_RASTERFONTS | FNT_TTFONTS)
#define FNT_AUTOSIZE            0x0010      // enable auto-sizing
#define FNT_RASTER              0x0400      // specified font is raster
#define FNT_TT                  0x0800      // specified font is truetype

#define FNT_FONTMASK            (FNT_BOTHFONTS)
#define FNT_FONTMASKBITS        2           // # of bits shifted left

#define FNTINIT_DEFAULT         0
#define FNTINIT_NORESTORE       0x0001      // don't restore on restart

typedef struct PROPFNT {                    /* fnt */
    WORD    flFnt;                          // see FNT_ flags
    WORD    flFntInit;                      // see FNTINIT_ flags
    WORD    cxFont;                         // width of desired font
    WORD    cyFont;                         // height of desired font
    WORD    cxFontActual;                   // actual width of desired font
    WORD    cyFontActual;                   // actual height of desired font
    CHAR    achRasterFaceName[LF_FACESIZE]; // name to use for raster font
    CHAR    achTTFaceName[LF_FACESIZE];     // name to use for tt font
    WORD    wCurrentCP;                     // Current Codepage
} PROPFNT;
typedef UNALIGNED PROPFNT *PPROPFNT;
typedef UNALIGNED PROPFNT FAR *LPPROPFNT;

#define GROUP_WIN               9          // window group

#define WIN_DEFAULT             (WIN_SAVESETTINGS | WIN_TOOLBAR)
#define WIN_SAVESETTINGS        0x0001      // save settings on exit (default)
#define WIN_TOOLBAR             0x0002      // enable toolbar

#define WININIT_DEFAULT         0
#define WININIT_NORESTORE       0x0001      // don't restore on restart

typedef struct PROPWIN {                    /* win */
    WORD    flWin;                          // see WIN_ flags
    WORD    flWinInit;                      // see WININIT flags
    WORD    cxCells;                        // width in cells
    WORD    cyCells;                        // height in cells
    WORD    cxClient;                       // width of client window
    WORD    cyClient;                       // height of client window
    WORD    cxWindow;                       // width of entire window
    WORD    cyWindow;                       // height of entire window
    WORD    wLength;
    WORD    wShowFlags;
    WORD    wShowCmd;
    WORD    xMinimize;
    WORD    yMinimize;
    WORD    xMaximize;
    WORD    yMaximize;
    PIFRECT rcNormal;
} PROPWIN;
typedef UNALIGNED PROPWIN *PPROPWIN;
typedef UNALIGNED PROPWIN FAR *LPPROPWIN;

#define PIF_WP_SIZE             ((sizeof(WORD)*7) + sizeof(PIFRECT))

#define GROUP_ENV               10          // environment/startup group

#define ENV_DEFAULT             0

#define ENVINIT_DEFAULT         0

#define ENVSIZE_MIN             0
#define ENVSIZE_DEFAULT         0
#define ENVSIZE_MAX             32768

#define ENVDPMI_MIN             0           // in KB
#define ENVDPMI_DEFAULT         0           // in KB (0 = Auto)
#define ENVDPMI_MAX             0xFFFF      // in KB

typedef struct PROPENV {                    /* env */
    WORD    flEnv;                          // see ENV_ flags
    WORD    flEnvInit;                      // see ENVINIT_ flags
    CHAR    achBatchFile[PIFDEFFILESIZE];   //
    WORD    cbEnvironment;                  // ([386Enh]:CommandEnvSize)
    WORD    wMaxDPMI;                       // (NEW)
} PROPENV;
typedef UNALIGNED PROPENV *PPROPENV;
typedef UNALIGNED PROPENV FAR *LPPROPENV;

#ifdef WINNT

#define GROUP_NT31              11
#ifndef UNICODE
#define MAX_VALID_GROUP         GROUP_NT31
#endif

typedef struct PROPNT31 {
   DWORD dwWNTFlags;                                                        /* ;Internal */
   DWORD dwRes1;                                                            /* ;Internal */
   DWORD dwRes2;                                                            /* ;Internal */
   char  achConfigFile[PIFDEFPATHSIZE];                                     /* ;Internal */
   char  achAutoexecFile[PIFDEFPATHSIZE];                                   /* ;Internal */
} PROPNT31;
typedef UNALIGNED PROPNT31 *PPROPNT31;
typedef UNALIGNED PROPNT31 FAR *LPPROPNT31;
#define COMPAT_TIMERTIC 0x10                                                /* ;Internal */
#define NT31_COMPATTIMER COMPAT_TIMERTIC                                    /* ;Internal */
#endif

#ifdef UNICODE
#ifdef GROUP_NT31
#define GROUP_NT40              12
#else
#define GROUP_NT40              11
#endif
#define MAX_VALID_GROUP         GROUP_NT40


#define WNT_LET_SYS_POS         0x0001
#define WNT_CONSOLE_PROPS       0x0002

typedef struct PROPNT40 {                                   /* wnt */
   DWORD    flWnt;                                          // NT Specific PIF falgs

// UNICODE version of strings, and copy of ANSI to see if they've changed

   WCHAR    awchCmdLine[PIFSTARTLOCSIZE+PIFPARAMSSIZE+1];   // Command line
   CHAR     achSaveCmdLine[PIFSTARTLOCSIZE+PIFPARAMSSIZE+1];// Saved ANSI Command Line

   WCHAR    awchOtherFile[PIFDEFFILESIZE];                  // name of "other" file in directory
   CHAR     achSaveOtherFile[PIFDEFFILESIZE];               // Saved ANSI "other" file in directory

   WCHAR    awchPIFFile[PIFDEFFILESIZE];                    // name of PIF file
   CHAR     achSavePIFFile[PIFDEFFILESIZE];                 // Saved ANSI name of PIF file

   WCHAR    awchTitle[PIFNAMESIZE];                         // Title for cmd window
   CHAR     achSaveTitle[PIFNAMESIZE];                      // Saved ANSI Title for cmd window

   WCHAR    awchIconFile[PIFDEFFILESIZE];                   // Name of file containing icons
   CHAR     achSaveIconFile[PIFDEFFILESIZE];                // Saved ANSI Name of file containing icons

   WCHAR    awchWorkDir[PIFDEFPATHSIZE];                    // working directory
   CHAR     achSaveWorkDir[PIFDEFPATHSIZE];                 // Saved ANSI working directory

   WCHAR    awchBatchFile[PIFDEFFILESIZE];                  // batch file
   CHAR     achSaveBatchFile[PIFDEFFILESIZE];               // Saved ANSI batch file

// Console properties

   DWORD    dwForeColor;                                    // Console Text Foreground Color
   DWORD    dwBackColor;                                    // Console Text Background Color
   DWORD    dwPopupForeColor;                               // Console Popup Text Foreground Color
   DWORD    dwPopupBackColor;                               // Console Popup Text Background Color
   COORD    WinSize;                                        // Console Window Size
   COORD    BuffSize;                                       // Console Buffer Size
   POINT    WinPos;                                         // Console Window Position
   DWORD    dwCursorSize;                                   // Console Cursor Size
   DWORD    dwCmdHistBufSize;                               // Console Command Histroy Buffer Size
   DWORD    dwNumCmdHist;                                   // Number of Command Histories for Console

} PROPNT40;
typedef UNALIGNED PROPNT40 *PPROPNT40;
typedef UNALIGNED PROPNT40 FAR *LPPROPNT40;

#else

#ifndef WINNT
#define MAX_VALID_GROUP         GROUP_ENV
#endif

#endif // UNICODE

#define GROUP_ICON              (MAX_VALID_GROUP+1)
#define GROUP_MAX               0x0FF

                                                                                // ;Internal
                                                                                // ;Internal
/*                                                                              // ;Internal
 * Additional group ordinal bits that can be passed to VxD property hooks       // ;Internal
 */                                                                             // ;Internal
#define EXT_GROUP_QUERY         0x100                                           // ;Internal
#define EXT_GROUP_UPDATE        0x200                                           // ;Internal
                                                                                // ;Internal
                                                                                // ;Internal
/*
 *  PIF "file" structures, used by .PIFs
 */

#define PIFEXTSIGSIZE   16                  // Length of extension signatures
#define MAX_GROUP_NAME  PIFEXTSIGSIZE       //
#define STDHDRSIG       "MICROSOFT PIFEX"   // extsig value for stdpifext
#define LASTHDRPTR      0xFFFF              // This value in the
                                            //  extnxthdrfloff field indicates
                                            //   there are no more extensions.
#define W286HDRSIG30     "WINDOWS 286 3.0"
#define W386HDRSIG30     "WINDOWS 386 3.0"
#define WNTHDRSIG31      "WINDOWS NT  3.1"
#define WENHHDRSIG40     "WINDOWS VMM 4.0"  //
#define WNTHDRSIG40      "WINDOWS NT  4.0"

#define CONFIGHDRSIG40   "CONFIG  SYS 4.0"  //
#define AUTOEXECHDRSIG40 "AUTOEXECBAT 4.0"  //

#define MAX_CONFIG_SIZE     4096
#define MAX_AUTOEXEC_SIZE   4096

#define CONFIGFILE      TEXT("\\CONFIG.SYS")      // normal filenames
#define AUTOEXECFILE    TEXT("\\AUTOEXEC.BAT")

#define MCONFIGFILE     TEXT("\\CONFIG.APP")      // msdos-mode temp filenames
#define MAUTOEXECFILE   TEXT("\\AUTOEXEC.APP")

#define WCONFIGFILE     TEXT("\\CONFIG.WOS")      // windows-mode temp filenames
#define WAUTOEXECFILE   TEXT("\\AUTOEXEC.WOS")


typedef struct PIFEXTHDR {                  /* peh */
    CHAR    extsig[PIFEXTSIGSIZE];
    WORD    extnxthdrfloff;
    WORD    extfileoffset;
    WORD    extsizebytes;
} PIFEXTHDR;
typedef UNALIGNED PIFEXTHDR *PPIFEXTHDR;
typedef UNALIGNED PIFEXTHDR FAR *LPPIFEXTHDR;


/* Flags for MSflags
 */

#define fResident       0x01    // Directly Modifies: Memory
#define fGraphics       0x02    // Screen Exchange: Graphics/Text
#define fNoSwitch       0x04    // Program Switch: Prevent
#define fNoGrab         0x08    // Screen Exchange: None
#define fDestroy        0x10    // Close Window on exit
#define fCOM2           0x40    // Directly Modifies: COM2
#define fCOM1           0x80    // Directly Modifies: COM1

#define MEMMASK         fResident
#define GRAPHMASK       fGraphics
#define TEXTMASK        ((BYTE)(~GRAPHMASK))
#define PSMASK          fNoSwitch
#define SGMASK          fNoGrab
#define EXITMASK        fDestroy
#define COM2MASK        fCOM2
#define COM1MASK        fCOM1

/* Flags for behavior
 */
#define fScreen         0x80    // Directly Modifies: Screen
#define fForeground     0x40    // Set same as fScreen (alias)
#define f8087           0x20    // No PIFEDIT control
#define fKeyboard       0x10    // Directly Modifies: Keyboard

#define SCRMASK         (fScreen + fForeground)
#define MASK8087        f8087
#define KEYMASK         fKeyboard

/* Flags for sysflags
 */

#define SWAPMASK        0x20
#define PARMMASK        0x40

/*
 * All strings in the STDPIF are in the OEM character set.
 */
typedef struct STDPIF {                     /* std */ //Examples
    BYTE    unknown;                        // 0x00     0x00
    BYTE    id;                             // 0x01     0x78
    CHAR    appname[PIFNAMESIZE];           // 0x02     'MS-DOS Prompt'
    WORD    maxmem;                         // 0x20     0x0200 (512Kb)
    WORD    minmem;                         // 0x22     0x0080 (128Kb)
    CHAR    startfile[PIFSTARTLOCSIZE];     // 0x24     "COMMAND.COM"
    BYTE    MSflags;                        // 0x63     0x10
    BYTE    reserved;                       // 0x64     0x00
    CHAR    defpath[PIFDEFPATHSIZE];        // 0x65     "\"
    CHAR    params[PIFPARAMSSIZE];          // 0xA5     ""
    BYTE    screen;                         // 0xE5     0x00
    BYTE    cPages;                         // 0xE6     0x01 (ALWAYS!)
    BYTE    lowVector;                      // 0xE7     0x00 (ALWAYS!)
    BYTE    highVector;                     // 0xE8     0xFF (ALWAYS!)
    BYTE    rows;                           // 0xE9     0x19 (Not used)
    BYTE    cols;                           // 0xEA     0x50 (Not used)
    BYTE    rowoff;                         // 0xEB     0x00 (Not used)
    BYTE    coloff;                         // 0xEC     0x00 (Not used)
    WORD    sysmem;                         // 0xED   0x0007 (Not used; 7=>Text, 23=>Grfx/Mult Text)
    CHAR    shprog[PIFSHPROGSIZE];          // 0xEF     0's  (Not used)
    CHAR    shdata[PIFSHDATASIZE];          // 0x12F    0's  (Not used)
    BYTE    behavior;                       // 0x16F    0x00
    BYTE    sysflags;                       // 0x170    0x00 (Not used)
} STDPIF;
typedef UNALIGNED STDPIF *PSTDPIF;
typedef UNALIGNED STDPIF FAR *LPSTDPIF;


/* Flags for PfW286Flags
 */

#define fALTTABdis286   0x0001
#define fALTESCdis286   0x0002
#define fALTPRTSCdis286 0x0004
#define fPRTSCdis286    0x0008
#define fCTRLESCdis286  0x0010
#define fNoSaveVid286   0x0020              // New for 3.10
#define fCOM3_286       0x4000
#define fCOM4_286       0x8000

typedef struct W286PIF30 {                  /* 286 */ //Examples
    WORD    PfMaxXmsK;                      // 0x19D    0x0000
    WORD    PfMinXmsK;                      // 0x19F    0x0000
    WORD    PfW286Flags;                    // 0x1A1    0x0000
} W286PIF30;
typedef UNALIGNED W286PIF30 *PW286PIF30;
typedef UNALIGNED W286PIF30 FAR *LPW286PIF30;


/* Flags for PfW386Flags
 */

#define fEnableClose    0x00000001          //
#define fEnableCloseBit             0       //
#define fBackground     0x00000002          //
#define fBackgroundBit              1       //
#define fExclusive      0x00000004          //                          /* ;Internal */
#define fExclusiveBit               2       //                          /* ;Internal */
#define fFullScreen     0x00000008          //
#define fFullScreenBit              3       //
#define fALTTABdis      0x00000020          //
#define fALTTABdisBit               5       //
#define fALTESCdis      0x00000040          //
#define fALTESCdisBit               6       //
#define fALTSPACEdis    0x00000080          //
#define fALTSPACEdisBit             7       //
#define fALTENTERdis    0x00000100          //
#define fALTENTERdisBit             8       //
#define fALTPRTSCdis    0x00000200          //
#define fALTPRTSCdisBit             9       //
#define fPRTSCdis       0x00000400          //
#define fPRTSCdisBit                10      //
#define fCTRLESCdis     0x00000800          //
#define fCTRLESCdisBit              11      //
#define fPollingDetect  0x00001000          //
#define fPollingDetectBit           12      //
#define fNoHMA          0x00002000          //
#define fNoHMABit                   13      //
#define fHasHotKey      0x00004000          //
#define fHasHotKeyBit               14      //
#define fEMSLocked      0x00008000          //
#define fEMSLockedBit               15      //
#define fXMSLocked      0x00010000          //
#define fXMSLockedBit               16      //
#define fINT16Paste     0x00020000          //
#define fINT16PasteBit              17      //
#define fVMLocked       0x00040000          //
#define fVMLockedBit                18      //
#define fGlobalProtect  0x00080000          //  New for 4.00
#define fGlobalProtectBit           19      //  New for 4.00
#define fMinimized      0x00100000          //  New for 4.00
#define fMinimizedBit               20      //  New for 4.00
#define fMaximized      0x00200000          //  New for 4.00
#define fMaximizedBit               21      //  New for 4.00
//                      0x00400000          //  Not used                /* ;Internal */
//                                  22      //  Not used                /* ;Internal */
#define fRealMode       0x00800000          //  New for 4.00
#define fRealModeBit                23      //  New for 4.00
#define fWinLie         0x01000000          //  New for 4.00
#define fWinLieBit                  24      //  New for 4.00
#define fStrayPtrDetect 0x02000000          //  New for 4.00            /* ;Internal */
#define fStrayPtrDetectBit          25      //  New for 4.00            /* ;Internal */
#define fNoSuggestMSDOS 0x04000000          //  New for 4.00
#define fNoSuggestMSDOSBit          26      //  New for 4.00
#define fLocalUMBs      0x08000000          //  New for 4.00            /* ;Internal */
#define fLocalUMBsBit               27      //  New for 4.00            /* ;Internal */
#define fRealModeSilent 0x10000000          //  New for 4.00
#define fRealModeSilentBit          28      //  New for 4.00
#define fQuickStart     0x20000000          //  New for 4.00            /* ;Internal */
#define fQuickStartBit              29      //  New for 4.00            /* ;Internal */
#define fAmbiguousPIF   0x40000000          //  New for 4.00
#define fAmbiguousPIFBit            30      //  New for 4.00

/* Flags for PfW386Flags2
 *
 *  NOTE THAT THE LOW 16 BITS OF THIS DWORD ARE VDD RELATED
 *  NOTE THAT ALL OF THE LOW 16 BITS ARE RESERVED FOR VIDEO BITS
 *
 *  You cannot monkey with these bits locations without breaking
 *  all VDDs as well as all old PIFs. SO DON'T MESS WITH THEM.
 */

#define fVDDMask        0x0000FFFF          //
#define fVDDMinBit                  0       //
#define fVDDMaxBit                  15      //

#define fVidTxtEmulate  0x00000001          //
#define fVidTxtEmulateBit           0       //
#define fVidNoTrpTxt    0x00000002          // Obsolete
#define fVidNoTrpTxtBit             1       // Obsolete
#define fVidNoTrpLRGrfx 0x00000004          // Obsolete
#define fVidNoTrpLRGrfxBit          2       // Obsolete
#define fVidNoTrpHRGrfx 0x00000008          // Obsolete
#define fVidNoTrpHRGrfxBit          3       // Obsolete
#define fVidTextMd      0x00000010          // Obsolete
#define fVidTextMdBit               4       // Obsolete
#define fVidLowRsGrfxMd 0x00000020          // Obsolete
#define fVidLowRsGrfxMdBit          5       // Obsolete
#define fVidHghRsGrfxMd 0x00000040          // Obsolete
#define fVidHghRsGrfxMdBit          6       // Obsolete
#define fVidRetainAllo  0x00000080          //
#define fVidRetainAlloBit           7       //

/*                                                                             ;Internal
 * This mask is used to isolate status bits shared with VM_Descriptor          ;Internal
 */                                                                         /* ;Internal */
                                                                            /* ;Internal */
#define PifDescMask                                                         /* ;Internal */ \
(fALTTABdis   + fALTESCdis    + fALTSPACEdis +                              /* ;Internal */ \
 fALTENTERdis + fALTPRTSCdis  + fPRTSCdis +                                 /* ;Internal */ \
 fCTRLESCdis  + fPollingDetect+ fNoHMA +                                    /* ;Internal */ \
 fHasHotKey   + fEMSLocked    + fXMSLocked +                                /* ;Internal */ \
 fINT16Paste  + fVMLocked)                                                  /* ;Internal */
                                                                            /* ;Internal */
                                                                            /* ;Internal */
typedef struct W386PIF30 {                  /* 386 */ //Examples
    // These new maxmem/minmem fields allow values
    // that will not conflict with the 286-specific values
    WORD    PfW386maxmem;                   // 0x1B9    0xFFFF (-1)
    WORD    PfW386minmem;                   // 0x1BB    0xFFFF (-1)
    WORD    PfFPriority;                    // 0x1BD    0x0064 (100)
    WORD    PfBPriority;                    // 0x1BF    0x0032 (50)
    WORD    PfMaxEMMK;                      // 0x1C1    0x0000 (0)
    WORD    PfMinEMMK;                      // 0x1C3    0x0000 (0)
    WORD    PfMaxXmsK;                      // 0x1C5    0x0800 (2048)
    WORD    PfMinXmsK;                      // 0x1C7    0x0000 (0)
    DWORD   PfW386Flags;                    // 0x1C9    0x00021003
    DWORD   PfW386Flags2;                   // 0x1CD    0x0000001F
    WORD    PfHotKeyScan;                   // 0x1D1    Scan code in lower byte
    WORD    PfHotKeyShVal;                  // 0x1D3    Shift state
    WORD    PfHotKeyShMsk;                  // 0x1D5    Mask for shift states interested in
    BYTE    PfHotKeyVal;                    // 0x1D7    Enhanced flags
    BYTE    PfHotKeyPad[9];                 // 0x1D8    Pad Hot key section to 16 bytes
    CHAR    PfW386params[PIFPARAMSSIZE];    // 0x1E1
} W386PIF30;
typedef UNALIGNED W386PIF30 *PW386PIF30;
typedef UNALIGNED W386PIF30 FAR *LPW386PIF30;


typedef struct WENHPIF40 {                  /* enh */                       /* ;Internal */
    DWORD   dwEnhModeFlagsProp;             // PROPPRG data (subset)        /* ;Internal */
    DWORD   dwRealModeFlagsProp;            // PROPPRG data (subset)        /* ;Internal */
    CHAR    achOtherFileProp[PIFDEFFILESIZE];//PROPPRG data (subset)        /* ;Internal */
    CHAR    achIconFileProp[PIFDEFFILESIZE];// PROPPRG data (subset)        /* ;Internal */
    WORD    wIconIndexProp;                 // PROPPRG data (subset)        /* ;Internal */
    PROPTSK tskProp;                        // PROPTSK data                 /* ;Internal */
    PROPVID vidProp;                        // PROPVID data                 /* ;Internal */
    PROPKBD kbdProp;                        // PROPKBD data                 /* ;Internal */
    PROPMSE mseProp;                        // PROPMSE data                 /* ;Internal */
    PROPSND sndProp;                        // PROPSND data                 /* ;Internal */
    PROPFNT fntProp;                        // PROPFNT data                 /* ;Internal */
    PROPWIN winProp;                        // PROPWIN data                 /* ;Internal */
    PROPENV envProp;                        // PROPENV data                 /* ;Internal */
    WORD    wInternalRevision;              // Internal WENHPIF40 version   /* ;Internal */
} WENHPIF40;                                                                /* ;Internal */
typedef UNALIGNED WENHPIF40 *PWENHPIF40;                                    /* ;Internal */
typedef UNALIGNED WENHPIF40 FAR *LPWENHPIF40;                               /* ;Internal */

#ifdef WINNT
/* Windows NT extension format */
typedef struct WNTPIF31 {                                                   /* ;Internal */
   PROPNT31 nt31Prop;                                                       /* ;Internal */
   WORD     wInternalRevision;                                              /* ;Internal */
} WNTPIF31;                                                                 /* ;Internal */
typedef UNALIGNED WNTPIF31 *PWNTPIF31;                                      /* ;Internal */
typedef UNALIGNED WNTPIF31 FAR *LPWNTPIF31;                                 /* ;Internal */
#endif
                                                                            /* ;Internal */
#ifdef UNICODE
typedef struct WNTPIF40 {                   /* adv */                       /* ;Internal */
    PROPNT40 nt40Prop;                      // PROPWNT data                 /* ;Internal */
    WORD    wInternalRevision;              // Internal WNTPIF40 version    /* ;Internal */
} WNTPIF40;                                                                 /* ;Internal */
typedef UNALIGNED WNTPIF40 *PWNTPIF40;                                      /* ;Internal */
typedef UNALIGNED WNTPIF40 FAR *LPWNTPIF40;                                 /* ;Internal */
#endif
                                                                            /* ;Internal */
//                                                                          /* ;Internal */
// Whenever a previously reserved field or bit becomes used, increment      /* ;Internal */
// the internal revision so that we know to zero them out when we see a     /* ;Internal */
// down-level PIF file.                                                     /* ;Internal */
//                                                                          /* ;Internal */
#define WENHPIF40_VERSION       1           // Current internal version     /* ;Internal */
#define WNTPIF40_VERSION        1           // Current internal version     /* ;Internal */
#define WNTPIF31_VERSION        1           // Current internal version     /* ;Internal */

                                                                            /* ;Internal */
typedef struct PIFDATA {                    /* pd */  //Examples            /* ;Internal */
                                                                            /* ;Internal */
    STDPIF      stdpifdata;                 // 0x000                        /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   stdpifext;                  // 0x171                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x171    "MICROSOFT PIFEX"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x181    0x0187 (or 0xFFFF)  /* ;Internal */
//      WORD    extfileoffset;              // 0x183    0x0000              /* ;Internal */
//      WORD    extsizebytes;               // 0x185    0x0171              /* ;Internal */
//  };                                                                      /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   w286hdr30;                  // 0x187                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x187    "WINDOWS 286 3.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x197    0x01A3 (or 0xFFFF)  /* ;Internal */
//      WORD    extfileoffset;              // 0x199    0x019D              /* ;Internal */
//      WORD    extsizebytes;               // 0x19B    0x0006              /* ;Internal */
//  };                                                                      /* ;Internal */
    W286PIF30   w286ext30;                  // 0x19D                        /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   w386hdr30;                  // 0x1A3                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x1A3    "WINDOWS 386 3.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x1B3    0xFFFF (ENH=0x221)  /* ;Internal */
//      WORD    extfileoffset;              // 0x1B5    0x01B9              /* ;Internal */
//      WORD    extsizebytes;               // 0x1B7    0x0068              /* ;Internal */
//  };                                                                      /* ;Internal */
    W386PIF30   w386ext30;                  // 0x1B9                        /* ;Internal */
                                                                            /* ;Internal */
    PIFEXTHDR   wenhhdr40;                  // 0x221                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x221    "WINDOWS VMM 4.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x231    0x????              /* ;Internal */
//      WORD    extfileoffset;              // 0x233    0x0237              /* ;Internal */
//      WORD    extsizebytes;               // 0x235    ???                 /* ;Internal */
//  };                                                                      /* ;Internal */
    WENHPIF40   wenhext40;                  // 0x237                        /* ;Internal */

#ifdef WINNT
    PIFEXTHDR   wnthdr31;                   // 0x000                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x000    "WINDOWS NT  3.1"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x000    0xFFFF              /* ;Internal */
//      WORD    extfileoffset;              // 0x000    0x0237              /* ;Internal */
//      WORD    extsizebytes;               // 0x000    ???                 /* ;Internal */
//  };                                                                      /* ;Internal */
    WNTPIF31    wntpif31;                   // 0x000                        /* ;Internal */
#endif


#ifdef UNICODE
    PIFEXTHDR   wnthdr40;                   // 0x000                        /* ;Internal */
//  struct {                                                                /* ;Internal */
//      CHAR    extsig[PIFEXTSIGSIZE];      // 0x000    "WINDOWS NT  4.0"   /* ;Internal */
//      WORD    extnxthdrfloff;             // 0x000    0xFFFF              /* ;Internal */
//      WORD    extfileoffset;              // 0x000    0x0237              /* ;Internal */
//      WORD    extsizebytes;               // 0x000    ???                 /* ;Internal */
//  };                                                                      /* ;Internal */
    WNTPIF40    wntpif40;                   // 0x000                        /* ;Internal */
#endif
                                                                            /* ;Internal */
} PIFDATA;                                  // 0x221 if Windows 3.x PIF     /* ;Internal */
typedef UNALIGNED PIFDATA *PPIFDATA;                                        /* ;Internal */
typedef UNALIGNED PIFDATA FAR *LPPIFDATA;                                   /* ;Internal */
                                                                            /* ;Internal */
                                                                            /* ;Internal */                                                                            /* ;Internal */
/* AssociateProperties associations
 */

#define HVM_ASSOCIATION         1
#define HWND_ASSOCIATION        2
#define LPARGS_ASSOCIATION      3                                           /* ;Internal */


/* SHEETTYPEs for AddPropertySheet/EnumPropertySheets
 */

#define SHEETTYPE_SIMPLE    0
#define SHEETTYPE_ADVANCED  1


/*  External function ordinals and prototypes
 */

#define ORD_OPENPROPERTIES      2
#define ORD_GETPROPERTIES       3
#define ORD_SETPROPERTIES       4
#define ORD_EDITPROPERTIES      5
#define ORD_FLUSHPROPERTIES     6
#define ORD_ENUMPROPERTIES      7
#define ORD_ASSOCIATEPROPERTIES 8
#define ORD_CLOSEPROPERTIES     9
#define ORD_LOADPROPERTYLIB     10
#define ORD_ENUMPROPERTYLIBS    11
#define ORD_FREEPROPERTYLIB     12
#define ORD_ADDPROPERTYSHEET    13
#define ORD_REMOVEPROPERTYSHEET 14
#define ORD_LOADPROPERTYSHEETS  15
#define ORD_ENUMPROPERTYSHEETS  16
#define ORD_FREEPROPERTYSHEETS  17
#define ORD_CREATESTARTUPPROPERTIES 20
#define ORD_DELETESTARTUPPROPERTIES 21

typedef UINT PIFWIZERR;

#define PIFWIZERR_SUCCESS           0
#define PIFWIZERR_GENERALFAILURE    1
#define PIFWIZERR_INVALIDPARAM      2
#define PIFWIZERR_UNSUPPORTEDOPT    3
#define PIFWIZERR_OUTOFMEM          4
#define PIFWIZERR_USERCANCELED      5

#define WIZACTION_UICONFIGPROP      0
#define WIZACTION_SILENTCONFIGPROP  1
#define WIZACTION_CREATEDEFCLEANCFG 2

/* XLATOFF */

#ifdef WINAPI
PIFWIZERR WINAPI AppWizard(HWND hwnd, HANDLE hProps, UINT action);

int  WINAPI OpenProperties(LPCTSTR lpszApp, LPCTSTR lpszPIF, UINT hInf, UINT flOpt);
int  WINAPI GetProperties(HANDLE hProps, LPCSTR lpszGroup, LPVOID lpProps, int cbProps, UINT flOpt);
int  WINAPI SetProperties(HANDLE hProps, LPCSTR lpszGroup, const VOID FAR *lpProps, int cbProps, UINT flOpt);
int  WINAPI EditProperties(HANDLE hProps, LPCTSTR lpszTitle, UINT uStartPage, HWND hwnd, UINT uMsgPost);
int  WINAPI FlushProperties(HANDLE hProps, UINT flOpt);
HANDLE  WINAPI EnumProperties(HANDLE hProps);
LONG_PTR WINAPI AssociateProperties(HANDLE hProps, int iAssociate, LONG_PTR lData);
int  WINAPI CloseProperties(HANDLE hProps, UINT flOpt);
int  WINAPI CreateStartupProperties(HANDLE hProps, UINT flOpt);
int  WINAPI DeleteStartupProperties(HANDLE hProps, UINT flOpt);
BOOL WINAPI PifPropGetPages(LPVOID lpv, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);


#ifdef  PIF_PROPERTY_SHEETS
HANDLE  WINAPI LoadPropertyLib(LPCTSTR lpszDLL, int fLoad);
HANDLE  WINAPI EnumPropertyLibs(HANDLE iLib, LPHANDLE lphDLL, LPSTR lpszDLL, int cbszDLL);
BOOL WINAPI FreePropertyLib(HANDLE hLib);
HANDLE  WINAPI AddPropertySheet(const PROPSHEETPAGE FAR *lppsi, int iType);
BOOL WINAPI RemovePropertySheet(HANDLE hSheet);
int  WINAPI LoadPropertySheets(HANDLE hProps, int flags);
INT_PTR  WINAPI EnumPropertySheets(HANDLE hProps, int iType, INT_PTR iSheet, LPPROPSHEETPAGE lppsi);
HANDLE  WINAPI FreePropertySheets(HANDLE hProps, int flags);
#endif  /* PIF_PROPERTY_SHEETS */

#endif  /* WINAPI */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

/* XLATON */

#endif // _INC_PIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\prshtp.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHTP_H_
#define _PRSHTP_H_
//  BUGBUG: Exact same block is in commctrl.h   /*
//  BUGBUG: Exact same block is in commctrl.h   /*

#ifdef _WIN64
#include <pshpack8.h>
#else
#include <pshpack4.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define PSP_DONOTUSE               0x00000200  // Dead flag - do not recycle
#define PSP_ALL                    0x0000FFFF
#define PSP_IS16                   0x00008000
// we are such morons.  Wiz97 underwent a redesign between IE4 and IE5
// so we have to treat them as two unrelated wizard styles that happen to
// have frighteningly similar names.
#define PSH_WIZARD97IE4         0x00002000
#define PSH_WIZARD97IE5         0x01000000
#define PSH_THUNKED             0x00800000
#define PSH_ALL                 0x03FFFFFF
#ifdef _WIN32
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreateProxyPage32Ex(HPROPSHEETPAGE hpage16, HINSTANCE hinst16);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreateProxyPage(HPROPSHEETPAGE hpage16, HINSTANCE hinst16);
#endif
// these need to match shell.h's ranges
#define PSN_HASHELP             (PSN_FIRST-4)
#define PSN_LASTCHANCEAPPLY     (PSN_FIRST-11)
// Note!  If you add a new PSN_*, make sure to tell the WOW people
// Do not rely on PSNRET_INVALID because some apps return 1 for
// all WM_NOTIFY messages, even if they weren't handled.
//
// we keep PSM_DISABLEAPPLY / PSM_ENABLEAPPLY messages private,
// because we dont want random prop sheets screwing with this.
//
#define PSM_DISABLEAPPLY        (WM_USER + 122)
#define PropSheet_DisableApply(hDlg) \
        SendMessage(hDlg, PSM_DISABLEAPPLY, 0, 0L)

#define PSM_ENABLEAPPLY         (WM_USER + 123)
#define PropSheet_EnableApply(hDlg) \
        SendMessage(hDlg, PSM_ENABLEAPPLY, 0, 0L)
#define PropSheet_SetWizButtonsNow(hDlg, dwFlags) PropSheet_SetWizButtons(hDlg, dwFlags)

#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _PRSHTP_H_     //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\shfusion.h ===
#ifndef SHFUSION_H
#define SHFUSION_H

#include <winbase.h>

#ifdef __cplusplus
extern "C" {
#endif

extern HANDLE g_hActCtx;       // Global app context for this DLL.

#define SHFUSION_DEFAULT_RESOURCE_ID    ( 123 )
#define SHFUSION_CPL_RESOURCE_ID        ( 124 )

// These are only needed for the callers, not the implementation
// define SHFUSION_NO_API_REDEFINE to prevent this API redefinition
#if !defined(SHFUSION_IMPL) && !defined(SHFUSION_NO_API_REDEFINE)

// The following require app contexts
//#undef LoadLibrary
#undef CreateWindow
#undef CreateWindowEx
#undef CreateDialogParam
#undef CreateDialogIndirectParam
#undef DialogBoxParam
#undef DialogBoxIndirectParam
//#undef GetClassInfo
//#undef GetClassInfoEx


//#define LoadLibrary                  SHFusionLoadLibrary
#define CreateWindow                   SHFusionCreateWindow
#define CreateWindowEx                 SHFusionCreateWindowEx
#define CreateDialogParam              SHFusionCreateDialogParam
#define CreateDialogIndirectParam      SHFusionCreateDialogIndirectParam
#define DialogBoxParam                 SHFusionDialogBoxParam
#define DialogBoxIndirectParam         SHFusionDialogBoxIndirectParam
//#define GetClassInfo                   SHFusionGetClassInfo
//#define GetClassInfoEx                 SHFusionGetClassInfoEx
#endif

void __stdcall SHGetManifest(PTSTR pszManifest, int cch);
BOOL __stdcall SHFusionInitialize(PTSTR pszPath);
BOOL __stdcall SHFusionInitializeFromModule(HMODULE hMod);
BOOL __stdcall SHFusionInitializeFromModuleID(HMODULE hMod, int id);
void __stdcall SHFusionUninitialize();
BOOL __stdcall SHActivateContext(ULONG_PTR * pdwCookie);
void __stdcall SHDeactivateContext(ULONG_PTR dwCookie);
BOOL __stdcall NT5_ActivateActCtx(HANDLE h, ULONG_PTR * p);
BOOL __stdcall NT5_DeactivateActCtx(ULONG_PTR p);

// This is designed for Callers that know that they are creating a property
// sheet on behalf of another that may be using an old version of common controls
// PROPSHEETPAGE is designed so that it can contain extra information, so we can't
// just wax part of the data structure for fusion use.
HPROPSHEETPAGE __stdcall SHNoFusionCreatePropertySheetPageW (LPCPROPSHEETPAGEW a);
HPROPSHEETPAGE __stdcall SHNoFusionCreatePropertySheetPageA (LPCPROPSHEETPAGEA a);


STDAPI __stdcall SHSquirtManifest(HINSTANCE hInst, UINT uIdManifest, LPTSTR pszPath);

HMODULE __stdcall SHFusionLoadLibrary(LPCTSTR lpLibFileName);

HWND __stdcall SHFusionCreateWindow(
  LPCTSTR lpClassName,  // registered class name
  LPCTSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
);

// NOTE: There are times when we don't want to use the manifest for creating a window.
// The #1 case is creating the host for MSHTML. Since MSHTML is a host of ActiveX controls,
// the window manager will keep enabling fusion.
HWND __stdcall SHNoFusionCreateWindowEx(
  DWORD dwExStyle,      // extended window style
  LPCTSTR lpClassName,  // registered class name
  LPCTSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
);


HWND __stdcall SHFusionCreateWindowEx(
  DWORD dwExStyle,      // extended window style
  LPCTSTR lpClassName,  // registered class name
  LPCTSTR lpWindowName, // window name
  DWORD dwStyle,        // window style
  int x,                // horizontal position of window
  int y,                // vertical position of window
  int nWidth,           // window width
  int nHeight,          // window height
  HWND hWndParent,      // handle to parent or owner window
  HMENU hMenu,          // menu handle or child identifier
  HINSTANCE hInstance,  // handle to application instance
  LPVOID lpParam        // window-creation data
);

HWND __stdcall SHFusionCreateDialogIndirect(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc        // dialog box procedure
);

HWND __stdcall SHFusionCreateDialogParam(
  HINSTANCE hInstance,     // handle to module
  LPCTSTR lpTemplateName,  // dialog box template
  HWND hWndParent,         // handle to owner window
  DLGPROC lpDialogFunc,    // dialog box procedure
  LPARAM dwInitParam       // initialization value
);

HWND __stdcall SHFusionCreateDialogIndirectParam(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc,       // dialog box procedure
  LPARAM lParamInit           // initialization value
);

HWND __stdcall SHNoFusionCreateDialogIndirectParam(
  HINSTANCE hInstance,        // handle to module
  LPCDLGTEMPLATE lpTemplate,  // dialog box template
  HWND hWndParent,            // handle to owner window
  DLGPROC lpDialogFunc,       // dialog box procedure
  LPARAM lParamInit           // initialization value
);

INT_PTR __stdcall SHFusionDialogBoxIndirectParam(
  HINSTANCE hInstance,             // handle to module
  LPCDLGTEMPLATE hDialogTemplate,  // dialog box template
  HWND hWndParent,                 // handle to owner window
  DLGPROC lpDialogFunc,            // dialog box procedure
  LPARAM dwInitParam               // initialization value
);

INT_PTR __stdcall SHFusionDialogBoxParam(
  HINSTANCE hInstance,     // handle to module
  LPCTSTR lpTemplateName,  // dialog box template
  HWND hWndParent,         // handle to owner window
  DLGPROC lpDialogFunc,    // dialog box procedure
  LPARAM dwInitParam       // initialization value
);


ATOM __stdcall SHFusionRegisterClass(
  CONST WNDCLASS *lpWndClass  // class data
);

ATOM __stdcall SHFusionRegisterClassEx(
  CONST WNDCLASSEX *lpwcx  // class data
);

BOOL __stdcall SHFusionGetClassInfo(
  HINSTANCE hInstance,    // handle to application instance
  LPCTSTR lpClassName,    // class name
  LPWNDCLASS lpWndClass   // class data
);

BOOL __stdcall SHFusionGetClassInfoEx(
  HINSTANCE hinst,    // handle to application instance
  LPCTSTR lpszClass,  // class name
  LPWNDCLASSEX lpwcx  // class data
);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\shellids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//
//  Contents:   Helpids for Shell Help project (windows.hlp) - the help ids
//              in this DLL are for shell componentns (not browser only or redist)
//              ie.  Shdoc401 has a "fixed in stone" version of this headerfile
//              for the "update.hlp" help file shipped with IE.
//              ("iexplore.hlp" is used for shdocvw.dll/browseui.dll.  see iehelpid.h)
//
//  Please keep this file ordered by help ID.  That way we can
//  find space for new ids easily.
//

#define IDH_MYDOCS_TARGET       1101
#define IDH_MYDOCS_BROWSE       1102
#define IDH_MYDOCS_FIND_TARGET  1103
#define IDH_MYDOCS_RESET        1104

// Background Tab implemented in shell32.dll (Win2K version) which replaces
// the background tab implemented in desk.cpl.  The "Background" tab has been
// renamed to "Desktop" in Whistler
// (The corresponding help texts for these IDs are in "Display.hlp")
#define IDH_DISPLAY_BACKGROUND_MONITOR              4000
#define IDH_DISPLAY_BACKGROUND_WALLPAPERLIST        4001
#define IDH_DISPLAY_BACKGROUND_BROWSE_BUTTON        4002
#define IDH_DISPLAY_BACKGROUND_PICTUREDISPLAY       4003
#define IDH_DISPLAY_BACKGROUND_DISPLAY_TILE         4004
#define IDH_DISPLAY_BACKGROUND_DISPLAY_CENTER       4005
#define IDH_DISPLAY_BACKGROUND_DISPLAY_STRETCH      4006
#define IDH_DISPLAY_BACKGROUND_PATTERN_BUTTON       4007
#define IDH_DISPLAY_BACKGROUND_PATTERN_PATTERNLIST  4008
#define IDH_DISPLAY_BACKGROUND_PATTERN_PREVIEW      4009
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_BUTTON   4010
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_NAME     4011
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_SAMPLE   4012
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_PATTERN  4013
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_DONE     4177
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_ADD      4178
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_CHANGE   4179
#define IDH_DISPLAY_BACKGROUND_EDITPATTERN_REMOVE   4180
#define IDH_DISPLAY_BACKGROUND_DESKTOP_ITEMS        4181        // This brings up the "Desktop Items..." dialog, previously the "Web" tab.
#define IDH_DISPLAY_BACKGROUND_BACKGROUND_COLOR     4182        // This is the help for the Color Picking control that lets users change their background color

// Web Tab implemented in shell32.dll (Win2K version)
// (The corresponding help texts for these IDs are in "Display.hlp")
#define IDH_DISPLAY_WEB_GRAPHIC                     4500
#define IDH_DISPLAY_WEB_SHOWWEB_CHECKBOX            4501
#define IDH_DISPLAY_WEB_ACTIVEDESKTOP_LIST          4502
#define IDH_DISPLAY_WEB_NEW_BUTTON                  4503
#define IDH_DISPLAY_WEB_DELETE_BUTTON               4504
#define IDH_DISPLAY_WEB_PROPERTIES_BUTTON           4505
#define IDH_DISPLAY_WEB_SYNCHRONIZE_BUTTON          4506


// For Display Properties, Background Tab (implemented in shdoc401.dll)
#define IDH_GROUPBOX                       51000
#define IDH_WALLPAPER_LIST                 51001
#define IDH_BROWSE_WALLPAPER               51002
#define IDH_DESKTOP_PATTERN                51003
#define IDH_DISPLAY_WALLPAPER              51004
#define IDH_DISABLE_ACTIVE_DESKTOP         51005
#define IDH_WALLPAPER_SAMPLE               51006

// For Properties button (implemented in shdoc401.dll)
#define IDH_DISPLAY_PATTERN                51010
#define IDH_EDIT_PATTERN                   51011

// For Pattern Editor (implemented in shdoc401.dll)
#define IDH_PATTERN_NAME                   51012
#define IDH_PATTERN_SAMPLE                 51013
#define IDH_PATTERN_EDIT                   51014
#define IDH_ADD_PATTERN                    51015
#define IDH_CHANGE_PATTERN                 51016
#define IDH_REMOVE_PATTERN                 51017

// For Display Properties, Web tab (implemented in shdoc401.dll)
#define IDH_LIST_CHANNELS                  51020
#define IDH_NEW_CHANNEL                    51021
#define IDH_DELETE_CHANNEL                 51022
#define IDH_CHANNEL_PROPERTIES             51023
#define IDH_TRY_IT                         51024
#define IDH_RESET_ALL                      51025
#define IDH_DISPLAY_CHANNELS               51027
#define IDH_VIEW_AS_WEB_PAGE               51026
#define IDH_FOLDER_OPTIONS                 51029

// For Web tab, Properties button, Subscription tab
#define IDH_SUBSCRIBED_URL                 51030
#define IDH_SUBSCRIPTION_SUMMARY           51031
// Login button
#define IDH_CHANNEL_LOGIN                  51032
// Login Options dialog
#define IDH_LOGIN_USER_ID                  51033
#define IDH_LOGIN_PASSWORD                 51034


// For Web tab, Properties button, Receiving tab
#define IDH_EMAIL_NOTIFICATION             51035
#define IDH_DOWNLOAD                       51036
#define IDH_ADVANCED                       51028
// Change Address button
#define IDH_CHANGE_ADDRESS                 51037
// Mail Options dialog
#define IDH_EMAIL_ADDRESS                  51038
#define IDH_EMAIL_SERVER                   51039

// Advanced Download Options dialog
#define IDH_MAX_DOWNLOAD                   51040
#define IDH_HIGH_PRIORITY                  51041
#define IDH_DOWNLOAD_IMAGES                51042
#define IDH_DOWNLOAD_SOUND                 51043
#define IDH_DOWNLOAD_ACTIVEX               51044
#define IDH_DOWNLOAD_PAGES_DEEP            51045
#define IDH_FOLLOW_LINKS                   51046

// For Web tab, Properties button, Schedule tab
#define IDH_AUTO_SCHEDULE                  51050
#define IDH_CUSTOM_SCHEDULE                51051
#define IDH_MANUAL_SCHEDULE                51052

// For Custom Schedule dialog
#define IDH_NEW_NAME                       51053
#define IDH_SCHED_DAYS                     51054
#define IDH_SCHED_FREQUENCY                51055
#define IDH_SCHED_TIME                     51056
#define IDH_SCHED_REPEAT                   51057
#define IDH_VARY_START                     51058

// For View, Options, General tab, Folders and desktop (My Computer)
//#define IDH_SAMPLE_GRAPHIC                 51060 // shdoc401
//#define IDH_WEB_VIEW                       51061 // shdoc401

//  View\Options menu, Files Types tab, Add New File Type dialog box
#define  IDH_MIME_TYPE                     51063
#define  IDH_DEFAULT_EXT                   51064
#define  IDH_CONFIRM_OPEN                  51065
#define  IDH_SAME_WINDOW                   51066

//  View\Options menu, File Types tab
#define  IDH_EXTENSION                     51067
#define  IDH_OPENS_WITH                    51068

// For View, Options, View tab (My Computer)
//#define IDH_SHOW_MAP_NETWORK               51070 // shdoc401 selfreg
#define IDH_SHOW_FILE_ATTRIB               51071
#define IDH_ALLOW_UPPERCASE                51072 // shell32 selfreg
#define IDH_SMOOTH_EDGES                   51073 // shell32 selfreg
#define IDH_SHOW_WINDOW                    51074 // shell32 selfreg
#define IDH_RESTORE_DEFAULT                51075
#define IDH_VIEW_STATE                     51076 // shell32 selfreg
#define IDH_USE_CURRENT_FOLDER             51077
#define IDH_RESET_TO_ORIGINAL              51078
#define IDH_FOLDERS_IN_SEP_PROCESS         51079 // shell32 selfreg

// For Folder Properties, General tab
#define IDH_PROPERTIES_GENERAL_THUMBNAIL   51080

// For Browse for Folder (right-click taskbar, Toolbar, New Toolbar)
#define IDH_BROWSE_FOLDER_ADDRESS          51082

//   Display properties, Screen Saver tab, Channel Screen Saver settings
#define  IDH_CHANNELS_LIST                 51083
#define  IDH_SET_LENGTH                    51084
#define  IDH_PLAY_SOUNDS                   51085
#define  IDH_CLOSE_SCREENSAVER             51086

//  Subscription properties, Unsubscribe button
#define  IDH_UNSUBSCRIBE                   51087

//  Subscription properties, Schedule
#define  IDH_SCHEDULE_NEW                  51088
#define  IDH_SCHEDULE_REMOVE               51089

// For View, Options, General tab, Folders and desktop (My Computer)
//#define IDH_CLASSIC_STYLE                  51090 // shdoc401
//#define IDH_CUSTOM                         51091 // shdoc401

// For View, Options, General Tab
#define IDH_BROWSE_SAME_WINDOW             51092
#define IDH_BROWSE_SEPARATE_WINDOWS        51093
#define IDH_SHOW_WEB_WHEN_POSSIBLE         51094
#define IDH_SHOW_WEB_WHEN_CHOOSE           51095
#define IDH_SINGLE_CLICK_MODE              51096
#define IDH_TITLES_LIKE_LINKS              51097
#define IDH_TITLES_WHEN_POINT              51098
#define IDH_DOUBLE_CLICK_MODE              51099

// For View, Folder Options, Advanced
#define IDH_FULL_PATH                      51100 // shell32 selfreg
#define IDH_HIDE_EXTENSIONS                51101 // shell32 selfreg
#define IDH_SHOW_TIPS                      51102 // shell32 selfreg
#define IDH_HIDE_HIDDEN_SYSTEM             51103 // shell32 selfreg
#define IDH_HIDE_HIDDEN_ONLY               51104 // shell32 selfreg
#define IDH_SHOW_ALL                       51105 // shell32 selfreg
#define IDH_HIDE_ICONS                     51106 // shell32 selfreg
#define IDH_FULL_PATH_ADDRESSBAR           51107 // shdoc401

// For View, Options, General Tab
#define IDH_ENABLE_WEB_CONTENT             51108
#define IDH_USE_WINDOWS_CLASSIC            51109
//#define IDH_CUSTOMIZE_ACTIVE_DESKTOP       51110 // shdoc401
#define IDH_ACTIVEDESKTOP_GEN              51111
#define IDH_WEB_VIEW_GEN                   51112
#define IDH_BROWSE_FOLDERS_GEN             51113
#define IDH_ICON_OPEN_GEN                  51114
#define IDH_RESTORE_DEFAULTS_GEN           51115


// For Folder Customization Wizard
// Start Page
#define IDH_FCW_CHOOSE_OR_EDIT_TEMPLATE    51116
#define IDH_FCW_CHOOSE_BACKGROUND_PICTURE  51117
#define IDH_FCW_REMOVE_CUST                51118
#define IDH_FCW_DESCRIBE_CHOICE            51119
// Template Page
#define IDH_FCW_TEMPLATE_LIST              51120
#define IDH_FCW_TEMPLATE_PREVIEW           51121
#define IDH_FCW_DESCRIBE_TEMPLATE          51122
#define IDH_FCW_ENABLE_EDITING             51123
// Background Page
#define IDH_FCW_BACKGROUND_PREVIEW         51124
#define IDH_FCW_BACKGROUND_LIST            51125
#define IDH_FCW_BACKGROUND_BROWSE          51126
#define IDH_FCW_ICON_TEXT_COLOR            51127
#define IDH_FCW_ENABLE_ICON_BACKGROUND_COLOR    51128
#define IDH_FCW_ICON_BACKGROUND_COLOR      51129

#define IDH_SHOW_COMP_COLOR                51130 // shell32 selfreg
#define IDH_HIDDEN_FILES_GROUP             51131 // shell32 selfreg
#define IDH_STARTMENU                      51132 // shell32 selfreg
#define IDH_STARTMENU_FAVORITES            51133 // shell32 selfreg
#define IDH_STARTMENU_LOGOFF               51134 // shell32 selfreg
#define IDH_STARTMENU_CONTROLPANEL         51135 // shell32 selfreg
#define IDH_STARTMENU_MYDOCUMENTS          51136 // shell32 selfreg
#define IDH_STARTMENU_PRINTERS             51137 // shell32 selfreg
#define IDH_STARTMENU_SCROLLPROGRAMS       51138 // shell32 selfreg
#define IDH_STARTMENU_INTELLIMENUS         51139 // shell32 selfreg
#define IDH_FILES_AND_FOLDERS              51140 // shell32 selfreg

#define IDH_SHOW_MY_DOCUMENTS              51141 // mydocs selfreg (shell.hlp)

#define IDH_TASKBAR_EXPAND_NETCONNECT      51141 // shell32 selfreg
#define IDH_TASKBAR_DISPLAY_RUN            51142 // shell32 selfreg
#define IDH_TASKBAR_SIZE_MOVE              51143 // shell32 selfreg
#define IDH_TASKBAR_CONTEXTMENU            51144 // shell32 selfreg
#define IDH_TASKBAR_STARTMENU_DRAGDROP     51145 // shell32 selfreg
#define IDH_TASKBAR_EXPAND_MYPICTURES      51146 // shell32 selfreg

#define IDH_DISABLE_NETCRAWLER             51147 // shell32 selfreg
#define IDH_HIDE_CONTENT                   51148 // shell32 selfreg
#define IDH_FRIENDLY_TREE                  51149 // shell32 selfreg

// Themes Tab in Display Control Panel.  The code is in themeui.dll
#define IDH_DISPLAY_THEMES_PREVIEW               51190       // Preview window
#define IDH_DISPLAY_THEMES_LIST                 51191       // Drop Down containing Plus! Themes
#define IDH_DISPLAY_THEMES_SETTINGS             51192       // "Properties" button to Advanced settings.
#define IDH_DISPLAY_THEMES_SAVEAS               51196       // Button for Theme "Save As..."
#define IDH_DISPLAY_THEMES_DELETETHEME          51197       // Button for Theme "Delete"

// Theme Settings: These controls go on the "Theme Settings" dialog
// which is the Advanced dialog for the Theme tab in the Display
// Control Panel.  The code is in themeui.dll
#define IDH_DISPLAY_THEMESETTINGS_NAMELABLE     51200
#define IDH_DISPLAY_THEMESETTINGS_NAME          51201
#define IDH_DISPLAY_THEMESETTINGS_LABEL         51202
#define IDH_DISPLAY_THEMESETTINGS_WALLPAPER     51203
#define IDH_DISPLAY_THEMESETTINGS_SOUNDS        51204
#define IDH_DISPLAY_THEMESETTINGS_MOUSE         51205
#define IDH_DISPLAY_THEMESETTINGS_SCREENSAVER   51206
#define IDH_DISPLAY_THEMESETTINGS_ICONS         51207
#define IDH_DISPLAY_THEMESETTINGS_COLORS        51208
#define IDH_DISPLAY_THEMESETTINGS_FONTS         51209
#define IDH_DISPLAY_THEMESETTINGS_BORDERS       51210

// Appearance Tab in Display Control Panel.  The code is in themeui.dll
#define IDH_DISPLAY_APPEARANCE_PREVIEW          51220
#define IDH_DISPLAY_APPEARANCE_LOOKFEEL         51221
#define IDH_DISPLAY_APPEARANCE_LOOKFEELLABEL    51222
#define IDH_DISPLAY_APPEARANCE_COLORSCHEMELABEL 51223
#define IDH_DISPLAY_APPEARANCE_COLORSCHEME      51224
#define IDH_DISPLAY_APPEARANCE_WNDSIZELABEL     51225
#define IDH_DISPLAY_APPEARANCE_WNDSIZE          51226 
#define IDH_DISPLAY_APPEARANCE_EFFECTS          51227
#define IDH_DISPLAY_APPEARANCE_ADVANCED         51228

// Desktop Items Dialog: These controls go on the dialog
// that appears when "Desktop Items" is click in the
// Desktop tab of the Display Control Panel.
#define IDH_DESKTOPITEMS_DESKTOPICONS_GROUP     51235
#define IDH_DESKTOPITEMS_ICON_MYDOCS            51236
#define IDH_DESKTOPITEMS_ICON_MYCOMP            51237
#define IDH_DESKTOPITEMS_ICON_MYNET             51238
#define IDH_DESKTOPITEMS_ICON_RECYCLE           51239
#define IDH_DESKTOPITEMS_CHANGEDESKTOPICON_LABEL 51240
#define IDH_DESKTOPITEMS_ICONS                  51241       // List of icons
#define IDH_DESKTOPITEMS_CHANGEICON2            51242       // Change Icon Button
#define IDH_DESKTOPITEMS_ICONDEFAULT            51243       // Default Icon Button
#define IDH_DESKTOPITEMS_DESKTOPWEBPAGES_LABEL  51244
#define IDH_DESKTOPITEMS_DESKCLNR_CHECK         51245
#define IDH_DESKTOPITEMS_DESKCLNR_RUNNOW        51246
#define IDH_DESKTOPITEMS_LOCKDESKITEMS_CHECK    51247
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\shgina.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for shgina.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __shgina_h__
#define __shgina_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ILogonUser_FWD_DEFINED__
#define __ILogonUser_FWD_DEFINED__
typedef interface ILogonUser ILogonUser;
#endif 	/* __ILogonUser_FWD_DEFINED__ */


#ifndef __ShellLogonUser_FWD_DEFINED__
#define __ShellLogonUser_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellLogonUser ShellLogonUser;
#else
typedef struct ShellLogonUser ShellLogonUser;
#endif /* __cplusplus */

#endif 	/* __ShellLogonUser_FWD_DEFINED__ */


#ifndef __ILogonEnumUsers_FWD_DEFINED__
#define __ILogonEnumUsers_FWD_DEFINED__
typedef interface ILogonEnumUsers ILogonEnumUsers;
#endif 	/* __ILogonEnumUsers_FWD_DEFINED__ */


#ifndef __ShellLogonEnumUsers_FWD_DEFINED__
#define __ShellLogonEnumUsers_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellLogonEnumUsers ShellLogonEnumUsers;
#else
typedef struct ShellLogonEnumUsers ShellLogonEnumUsers;
#endif /* __cplusplus */

#endif 	/* __ShellLogonEnumUsers_FWD_DEFINED__ */


#ifndef __ILocalMachine_FWD_DEFINED__
#define __ILocalMachine_FWD_DEFINED__
typedef interface ILocalMachine ILocalMachine;
#endif 	/* __ILocalMachine_FWD_DEFINED__ */


#ifndef __ShellLocalMachine_FWD_DEFINED__
#define __ShellLocalMachine_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellLocalMachine ShellLocalMachine;
#else
typedef struct ShellLocalMachine ShellLocalMachine;
#endif /* __cplusplus */

#endif 	/* __ShellLocalMachine_FWD_DEFINED__ */


#ifndef __ILogonStatusHost_FWD_DEFINED__
#define __ILogonStatusHost_FWD_DEFINED__
typedef interface ILogonStatusHost ILogonStatusHost;
#endif 	/* __ILogonStatusHost_FWD_DEFINED__ */


#ifndef __ShellLogonStatusHost_FWD_DEFINED__
#define __ShellLogonStatusHost_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellLogonStatusHost ShellLogonStatusHost;
#else
typedef struct ShellLogonStatusHost ShellLogonStatusHost;
#endif /* __cplusplus */

#endif 	/* __ShellLogonStatusHost_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_shgina_0000 */
/* [local] */ 

typedef 
enum ILUEOrder
    {	ILEU_MOSTRECENT	= 0,
	ILEU_ALPHABETICAL	= 1
    } 	ILUEORDER;



extern RPC_IF_HANDLE __MIDL_itf_shgina_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shgina_0000_v0_0_s_ifspec;


#ifndef __SHGINALib_LIBRARY_DEFINED__
#define __SHGINALib_LIBRARY_DEFINED__

/* library SHGINALib */
/* [version][lcid][helpstring][uuid] */ 

typedef 
enum ILM_GUEST_FLAGS
    {	ILM_GUEST_ACCOUNT	= 0,
	ILM_GUEST_INTERACTIVE_LOGON	= 0x1,
	ILM_GUEST_NETWORK_LOGON	= 0x2
    } 	ILM_GUEST_FLAGS;


EXTERN_C const IID LIBID_SHGINALib;

#ifndef __ILogonUser_INTERFACE_DEFINED__
#define __ILogonUser_INTERFACE_DEFINED__

/* interface ILogonUser */
/* [oleautomation][helpstring][hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_ILogonUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60664CAF-AF0D-1003-A300-5C7D25FF22A0")
    ILogonUser : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_setting( 
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvarVal) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_setting( 
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT varVal) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isLoggedOn( 
            /* [retval][out] */ VARIANT_BOOL *pbLoggedIn) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_passwordRequired( 
            /* [retval][out] */ VARIANT_BOOL *pbPasswordRequired) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_interactiveLogonAllowed( 
            /* [retval][out] */ VARIANT_BOOL *pbInteractiveLogonAllowed) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isProfilePrivate( 
            /* [retval][out] */ VARIANT_BOOL *pbPrivate) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isPasswordResetAvailable( 
            /* [retval][out] */ VARIANT_BOOL *pbResetAvailable) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE logon( 
            /* [in] */ BSTR pstrPassword,
            /* [retval][out] */ VARIANT_BOOL *pbRet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE logoff( 
            /* [retval][out] */ VARIANT_BOOL *pbRet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE changePassword( 
            /* [in] */ VARIANT varNewPassword,
            /* [in] */ VARIANT varOldPassword,
            /* [retval][out] */ VARIANT_BOOL *pbRet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE makeProfilePrivate( 
            /* [in] */ VARIANT_BOOL bPrivate) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE getMailAccountInfo( 
            /* [in] */ UINT uiAccountIndex,
            /* [out] */ VARIANT *pvarAccountName,
            /* [out] */ UINT *pcUnreadMessages) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogonUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILogonUser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILogonUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILogonUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ILogonUser * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ILogonUser * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ILogonUser * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILogonUser * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_setting )( 
            ILogonUser * This,
            /* [in] */ BSTR bstrName,
            /* [retval][out] */ VARIANT *pvarVal);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_setting )( 
            ILogonUser * This,
            /* [in] */ BSTR bstrName,
            /* [in] */ VARIANT varVal);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isLoggedOn )( 
            ILogonUser * This,
            /* [retval][out] */ VARIANT_BOOL *pbLoggedIn);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_passwordRequired )( 
            ILogonUser * This,
            /* [retval][out] */ VARIANT_BOOL *pbPasswordRequired);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_interactiveLogonAllowed )( 
            ILogonUser * This,
            /* [retval][out] */ VARIANT_BOOL *pbInteractiveLogonAllowed);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isProfilePrivate )( 
            ILogonUser * This,
            /* [retval][out] */ VARIANT_BOOL *pbPrivate);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isPasswordResetAvailable )( 
            ILogonUser * This,
            /* [retval][out] */ VARIANT_BOOL *pbResetAvailable);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *logon )( 
            ILogonUser * This,
            /* [in] */ BSTR pstrPassword,
            /* [retval][out] */ VARIANT_BOOL *pbRet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *logoff )( 
            ILogonUser * This,
            /* [retval][out] */ VARIANT_BOOL *pbRet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *changePassword )( 
            ILogonUser * This,
            /* [in] */ VARIANT varNewPassword,
            /* [in] */ VARIANT varOldPassword,
            /* [retval][out] */ VARIANT_BOOL *pbRet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *makeProfilePrivate )( 
            ILogonUser * This,
            /* [in] */ VARIANT_BOOL bPrivate);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *getMailAccountInfo )( 
            ILogonUser * This,
            /* [in] */ UINT uiAccountIndex,
            /* [out] */ VARIANT *pvarAccountName,
            /* [out] */ UINT *pcUnreadMessages);
        
        END_INTERFACE
    } ILogonUserVtbl;

    interface ILogonUser
    {
        CONST_VTBL struct ILogonUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILogonUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILogonUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILogonUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILogonUser_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILogonUser_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILogonUser_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILogonUser_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILogonUser_get_setting(This,bstrName,pvarVal)	\
    (This)->lpVtbl -> get_setting(This,bstrName,pvarVal)

#define ILogonUser_put_setting(This,bstrName,varVal)	\
    (This)->lpVtbl -> put_setting(This,bstrName,varVal)

#define ILogonUser_get_isLoggedOn(This,pbLoggedIn)	\
    (This)->lpVtbl -> get_isLoggedOn(This,pbLoggedIn)

#define ILogonUser_get_passwordRequired(This,pbPasswordRequired)	\
    (This)->lpVtbl -> get_passwordRequired(This,pbPasswordRequired)

#define ILogonUser_get_interactiveLogonAllowed(This,pbInteractiveLogonAllowed)	\
    (This)->lpVtbl -> get_interactiveLogonAllowed(This,pbInteractiveLogonAllowed)

#define ILogonUser_get_isProfilePrivate(This,pbPrivate)	\
    (This)->lpVtbl -> get_isProfilePrivate(This,pbPrivate)

#define ILogonUser_get_isPasswordResetAvailable(This,pbResetAvailable)	\
    (This)->lpVtbl -> get_isPasswordResetAvailable(This,pbResetAvailable)

#define ILogonUser_logon(This,pstrPassword,pbRet)	\
    (This)->lpVtbl -> logon(This,pstrPassword,pbRet)

#define ILogonUser_logoff(This,pbRet)	\
    (This)->lpVtbl -> logoff(This,pbRet)

#define ILogonUser_changePassword(This,varNewPassword,varOldPassword,pbRet)	\
    (This)->lpVtbl -> changePassword(This,varNewPassword,varOldPassword,pbRet)

#define ILogonUser_makeProfilePrivate(This,bPrivate)	\
    (This)->lpVtbl -> makeProfilePrivate(This,bPrivate)

#define ILogonUser_getMailAccountInfo(This,uiAccountIndex,pvarAccountName,pcUnreadMessages)	\
    (This)->lpVtbl -> getMailAccountInfo(This,uiAccountIndex,pvarAccountName,pcUnreadMessages)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILogonUser_get_setting_Proxy( 
    ILogonUser * This,
    /* [in] */ BSTR bstrName,
    /* [retval][out] */ VARIANT *pvarVal);


void __RPC_STUB ILogonUser_get_setting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ILogonUser_put_setting_Proxy( 
    ILogonUser * This,
    /* [in] */ BSTR bstrName,
    /* [in] */ VARIANT varVal);


void __RPC_STUB ILogonUser_put_setting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILogonUser_get_isLoggedOn_Proxy( 
    ILogonUser * This,
    /* [retval][out] */ VARIANT_BOOL *pbLoggedIn);


void __RPC_STUB ILogonUser_get_isLoggedOn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILogonUser_get_passwordRequired_Proxy( 
    ILogonUser * This,
    /* [retval][out] */ VARIANT_BOOL *pbPasswordRequired);


void __RPC_STUB ILogonUser_get_passwordRequired_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILogonUser_get_interactiveLogonAllowed_Proxy( 
    ILogonUser * This,
    /* [retval][out] */ VARIANT_BOOL *pbInteractiveLogonAllowed);


void __RPC_STUB ILogonUser_get_interactiveLogonAllowed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILogonUser_get_isProfilePrivate_Proxy( 
    ILogonUser * This,
    /* [retval][out] */ VARIANT_BOOL *pbPrivate);


void __RPC_STUB ILogonUser_get_isProfilePrivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILogonUser_get_isPasswordResetAvailable_Proxy( 
    ILogonUser * This,
    /* [retval][out] */ VARIANT_BOOL *pbResetAvailable);


void __RPC_STUB ILogonUser_get_isPasswordResetAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILogonUser_logon_Proxy( 
    ILogonUser * This,
    /* [in] */ BSTR pstrPassword,
    /* [retval][out] */ VARIANT_BOOL *pbRet);


void __RPC_STUB ILogonUser_logon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILogonUser_logoff_Proxy( 
    ILogonUser * This,
    /* [retval][out] */ VARIANT_BOOL *pbRet);


void __RPC_STUB ILogonUser_logoff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILogonUser_changePassword_Proxy( 
    ILogonUser * This,
    /* [in] */ VARIANT varNewPassword,
    /* [in] */ VARIANT varOldPassword,
    /* [retval][out] */ VARIANT_BOOL *pbRet);


void __RPC_STUB ILogonUser_changePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILogonUser_makeProfilePrivate_Proxy( 
    ILogonUser * This,
    /* [in] */ VARIANT_BOOL bPrivate);


void __RPC_STUB ILogonUser_makeProfilePrivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ILogonUser_getMailAccountInfo_Proxy( 
    ILogonUser * This,
    /* [in] */ UINT uiAccountIndex,
    /* [out] */ VARIANT *pvarAccountName,
    /* [out] */ UINT *pcUnreadMessages);


void __RPC_STUB ILogonUser_getMailAccountInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILogonUser_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellLogonUser;

#ifdef __cplusplus

class DECLSPEC_UUID("60664CAF-AF0D-0003-A300-5C7D25FF22A0")
ShellLogonUser;
#endif

#ifndef __ILogonEnumUsers_INTERFACE_DEFINED__
#define __ILogonEnumUsers_INTERFACE_DEFINED__

/* interface ILogonEnumUsers */
/* [oleautomation][helpstring][hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_ILogonEnumUsers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60664CAF-AF0D-1004-A300-5C7D25FF22A0")
    ILogonEnumUsers : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Domain( 
            /* [retval][out] */ BSTR *pbstr) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Domain( 
            /* [in] */ BSTR bstr) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EnumFlags( 
            /* [retval][out] */ ILUEORDER *porder) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EnumFlags( 
            /* [in] */ ILUEORDER order) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_length( 
            /* [retval][out] */ UINT *pcUsers) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_currentUser( 
            /* [retval][out] */ ILogonUser **ppLogonUserInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE item( 
            /* [in] */ VARIANT varUserId,
            /* [retval][out] */ ILogonUser **ppLogonUserInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE _NewEnum( 
            /* [retval][out] */ IUnknown **retval) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE create( 
            /* [in] */ BSTR bstrLoginName,
            /* [retval][out] */ ILogonUser **ppLogonUser) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE remove( 
            /* [in] */ VARIANT varUserId,
            /* [optional][in] */ VARIANT varBackupPath,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogonEnumUsersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILogonEnumUsers * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILogonEnumUsers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILogonEnumUsers * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ILogonEnumUsers * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ILogonEnumUsers * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ILogonEnumUsers * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILogonEnumUsers * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Domain )( 
            ILogonEnumUsers * This,
            /* [retval][out] */ BSTR *pbstr);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Domain )( 
            ILogonEnumUsers * This,
            /* [in] */ BSTR bstr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnumFlags )( 
            ILogonEnumUsers * This,
            /* [retval][out] */ ILUEORDER *porder);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnumFlags )( 
            ILogonEnumUsers * This,
            /* [in] */ ILUEORDER order);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_length )( 
            ILogonEnumUsers * This,
            /* [retval][out] */ UINT *pcUsers);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_currentUser )( 
            ILogonEnumUsers * This,
            /* [retval][out] */ ILogonUser **ppLogonUserInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *item )( 
            ILogonEnumUsers * This,
            /* [in] */ VARIANT varUserId,
            /* [retval][out] */ ILogonUser **ppLogonUserInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *_NewEnum )( 
            ILogonEnumUsers * This,
            /* [retval][out] */ IUnknown **retval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *create )( 
            ILogonEnumUsers * This,
            /* [in] */ BSTR bstrLoginName,
            /* [retval][out] */ ILogonUser **ppLogonUser);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *remove )( 
            ILogonEnumUsers * This,
            /* [in] */ VARIANT varUserId,
            /* [optional][in] */ VARIANT varBackupPath,
            /* [retval][out] */ VARIANT_BOOL *pbSuccess);
        
        END_INTERFACE
    } ILogonEnumUsersVtbl;

    interface ILogonEnumUsers
    {
        CONST_VTBL struct ILogonEnumUsersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILogonEnumUsers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILogonEnumUsers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILogonEnumUsers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILogonEnumUsers_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILogonEnumUsers_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILogonEnumUsers_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILogonEnumUsers_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILogonEnumUsers_get_Domain(This,pbstr)	\
    (This)->lpVtbl -> get_Domain(This,pbstr)

#define ILogonEnumUsers_put_Domain(This,bstr)	\
    (This)->lpVtbl -> put_Domain(This,bstr)

#define ILogonEnumUsers_get_EnumFlags(This,porder)	\
    (This)->lpVtbl -> get_EnumFlags(This,porder)

#define ILogonEnumUsers_put_EnumFlags(This,order)	\
    (This)->lpVtbl -> put_EnumFlags(This,order)

#define ILogonEnumUsers_get_length(This,pcUsers)	\
    (This)->lpVtbl -> get_length(This,pcUsers)

#define ILogonEnumUsers_get_currentUser(This,ppLogonUserInfo)	\
    (This)->lpVtbl -> get_currentUser(This,ppLogonUserInfo)

#define ILogonEnumUsers_item(This,varUserId,ppLogonUserInfo)	\
    (This)->lpVtbl -> item(This,varUserId,ppLogonUserInfo)

#define ILogonEnumUsers__NewEnum(This,retval)	\
    (This)->lpVtbl -> _NewEnum(This,retval)

#define ILogonEnumUsers_create(This,bstrLoginName,ppLogonUser)	\
    (This)->lpVtbl -> create(This,bstrLoginName,ppLogonUser)

#define ILogonEnumUsers_remove(This,varUserId,varBackupPath,pbSuccess)	\
    (This)->lpVtbl -> remove(This,varUserId,varBackupPath,pbSuccess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILogonEnumUsers_get_Domain_Proxy( 
    ILogonEnumUsers * This,
    /* [retval][out] */ BSTR *pbstr);


void __RPC_STUB ILogonEnumUsers_get_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ILogonEnumUsers_put_Domain_Proxy( 
    ILogonEnumUsers * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ILogonEnumUsers_put_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILogonEnumUsers_get_EnumFlags_Proxy( 
    ILogonEnumUsers * This,
    /* [retval][out] */ ILUEORDER *porder);


void __RPC_STUB ILogonEnumUsers_get_EnumFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ILogonEnumUsers_put_EnumFlags_Proxy( 
    ILogonEnumUsers * This,
    /* [in] */ ILUEORDER order);


void __RPC_STUB ILogonEnumUsers_put_EnumFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILogonEnumUsers_get_length_Proxy( 
    ILogonEnumUsers * This,
    /* [retval][out] */ UINT *pcUsers);


void __RPC_STUB ILogonEnumUsers_get_length_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILogonEnumUsers_get_currentUser_Proxy( 
    ILogonEnumUsers * This,
    /* [retval][out] */ ILogonUser **ppLogonUserInfo);


void __RPC_STUB ILogonEnumUsers_get_currentUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILogonEnumUsers_item_Proxy( 
    ILogonEnumUsers * This,
    /* [in] */ VARIANT varUserId,
    /* [retval][out] */ ILogonUser **ppLogonUserInfo);


void __RPC_STUB ILogonEnumUsers_item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILogonEnumUsers__NewEnum_Proxy( 
    ILogonEnumUsers * This,
    /* [retval][out] */ IUnknown **retval);


void __RPC_STUB ILogonEnumUsers__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILogonEnumUsers_create_Proxy( 
    ILogonEnumUsers * This,
    /* [in] */ BSTR bstrLoginName,
    /* [retval][out] */ ILogonUser **ppLogonUser);


void __RPC_STUB ILogonEnumUsers_create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILogonEnumUsers_remove_Proxy( 
    ILogonEnumUsers * This,
    /* [in] */ VARIANT varUserId,
    /* [optional][in] */ VARIANT varBackupPath,
    /* [retval][out] */ VARIANT_BOOL *pbSuccess);


void __RPC_STUB ILogonEnumUsers_remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILogonEnumUsers_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellLogonEnumUsers;

#ifdef __cplusplus

class DECLSPEC_UUID("60664CAF-AF0D-0004-A300-5C7D25FF22A0")
ShellLogonEnumUsers;
#endif

#ifndef __ILocalMachine_INTERFACE_DEFINED__
#define __ILocalMachine_INTERFACE_DEFINED__

/* interface ILocalMachine */
/* [oleautomation][helpstring][hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_ILocalMachine;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60664CAF-AF0D-1005-A300-5C7D25FF22A0")
    ILocalMachine : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MachineName( 
            /* [retval][out] */ VARIANT *pvarVal) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isGuestEnabled( 
            /* [in] */ ILM_GUEST_FLAGS flags,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isFriendlyUIEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_isFriendlyUIEnabled( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isMultipleUsersEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_isMultipleUsersEnabled( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isRemoteConnectionsEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_isRemoteConnectionsEnabled( 
            /* [in] */ VARIANT_BOOL bEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AccountName( 
            /* [in] */ VARIANT varAccount,
            /* [retval][out] */ VARIANT *pvarVal) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isUndockEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isShutdownAllowed( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isGuestAccessMode( 
            /* [retval][out] */ VARIANT_BOOL *pbForceGuest) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_isOfflineFilesEnabled( 
            /* [retval][out] */ VARIANT_BOOL *pbEnabled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE TurnOffComputer( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SignalUIHostFailure( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AllowExternalCredentials( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RequestExternalCredentials( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LogonWithExternalCredentials( 
            /* [in] */ BSTR pstrUsername,
            /* [in] */ BSTR pstrDomain,
            /* [in] */ BSTR pstrPassword,
            /* [retval][out] */ VARIANT_BOOL *pbRet) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitiateInteractiveLogon( 
            /* [in] */ BSTR pstrUsername,
            /* [in] */ BSTR pstrDomain,
            /* [in] */ BSTR pstrPassword,
            /* [in] */ DWORD dwTimeout,
            /* [retval][out] */ VARIANT_BOOL *pbRet) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UndockComputer( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableGuest( 
            ILM_GUEST_FLAGS flags) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisableGuest( 
            ILM_GUEST_FLAGS flags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocalMachineVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILocalMachine * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILocalMachine * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILocalMachine * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ILocalMachine * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ILocalMachine * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ILocalMachine * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILocalMachine * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MachineName )( 
            ILocalMachine * This,
            /* [retval][out] */ VARIANT *pvarVal);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isGuestEnabled )( 
            ILocalMachine * This,
            /* [in] */ ILM_GUEST_FLAGS flags,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isFriendlyUIEnabled )( 
            ILocalMachine * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_isFriendlyUIEnabled )( 
            ILocalMachine * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isMultipleUsersEnabled )( 
            ILocalMachine * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_isMultipleUsersEnabled )( 
            ILocalMachine * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isRemoteConnectionsEnabled )( 
            ILocalMachine * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_isRemoteConnectionsEnabled )( 
            ILocalMachine * This,
            /* [in] */ VARIANT_BOOL bEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AccountName )( 
            ILocalMachine * This,
            /* [in] */ VARIANT varAccount,
            /* [retval][out] */ VARIANT *pvarVal);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isUndockEnabled )( 
            ILocalMachine * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isShutdownAllowed )( 
            ILocalMachine * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isGuestAccessMode )( 
            ILocalMachine * This,
            /* [retval][out] */ VARIANT_BOOL *pbForceGuest);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_isOfflineFilesEnabled )( 
            ILocalMachine * This,
            /* [retval][out] */ VARIANT_BOOL *pbEnabled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *TurnOffComputer )( 
            ILocalMachine * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SignalUIHostFailure )( 
            ILocalMachine * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AllowExternalCredentials )( 
            ILocalMachine * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RequestExternalCredentials )( 
            ILocalMachine * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LogonWithExternalCredentials )( 
            ILocalMachine * This,
            /* [in] */ BSTR pstrUsername,
            /* [in] */ BSTR pstrDomain,
            /* [in] */ BSTR pstrPassword,
            /* [retval][out] */ VARIANT_BOOL *pbRet);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InitiateInteractiveLogon )( 
            ILocalMachine * This,
            /* [in] */ BSTR pstrUsername,
            /* [in] */ BSTR pstrDomain,
            /* [in] */ BSTR pstrPassword,
            /* [in] */ DWORD dwTimeout,
            /* [retval][out] */ VARIANT_BOOL *pbRet);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UndockComputer )( 
            ILocalMachine * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableGuest )( 
            ILocalMachine * This,
            ILM_GUEST_FLAGS flags);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisableGuest )( 
            ILocalMachine * This,
            ILM_GUEST_FLAGS flags);
        
        END_INTERFACE
    } ILocalMachineVtbl;

    interface ILocalMachine
    {
        CONST_VTBL struct ILocalMachineVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocalMachine_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILocalMachine_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILocalMachine_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILocalMachine_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILocalMachine_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILocalMachine_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILocalMachine_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILocalMachine_get_MachineName(This,pvarVal)	\
    (This)->lpVtbl -> get_MachineName(This,pvarVal)

#define ILocalMachine_get_isGuestEnabled(This,flags,pbEnabled)	\
    (This)->lpVtbl -> get_isGuestEnabled(This,flags,pbEnabled)

#define ILocalMachine_get_isFriendlyUIEnabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_isFriendlyUIEnabled(This,pbEnabled)

#define ILocalMachine_put_isFriendlyUIEnabled(This,bEnabled)	\
    (This)->lpVtbl -> put_isFriendlyUIEnabled(This,bEnabled)

#define ILocalMachine_get_isMultipleUsersEnabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_isMultipleUsersEnabled(This,pbEnabled)

#define ILocalMachine_put_isMultipleUsersEnabled(This,bEnabled)	\
    (This)->lpVtbl -> put_isMultipleUsersEnabled(This,bEnabled)

#define ILocalMachine_get_isRemoteConnectionsEnabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_isRemoteConnectionsEnabled(This,pbEnabled)

#define ILocalMachine_put_isRemoteConnectionsEnabled(This,bEnabled)	\
    (This)->lpVtbl -> put_isRemoteConnectionsEnabled(This,bEnabled)

#define ILocalMachine_get_AccountName(This,varAccount,pvarVal)	\
    (This)->lpVtbl -> get_AccountName(This,varAccount,pvarVal)

#define ILocalMachine_get_isUndockEnabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_isUndockEnabled(This,pbEnabled)

#define ILocalMachine_get_isShutdownAllowed(This,pbEnabled)	\
    (This)->lpVtbl -> get_isShutdownAllowed(This,pbEnabled)

#define ILocalMachine_get_isGuestAccessMode(This,pbForceGuest)	\
    (This)->lpVtbl -> get_isGuestAccessMode(This,pbForceGuest)

#define ILocalMachine_get_isOfflineFilesEnabled(This,pbEnabled)	\
    (This)->lpVtbl -> get_isOfflineFilesEnabled(This,pbEnabled)

#define ILocalMachine_TurnOffComputer(This)	\
    (This)->lpVtbl -> TurnOffComputer(This)

#define ILocalMachine_SignalUIHostFailure(This)	\
    (This)->lpVtbl -> SignalUIHostFailure(This)

#define ILocalMachine_AllowExternalCredentials(This)	\
    (This)->lpVtbl -> AllowExternalCredentials(This)

#define ILocalMachine_RequestExternalCredentials(This)	\
    (This)->lpVtbl -> RequestExternalCredentials(This)

#define ILocalMachine_LogonWithExternalCredentials(This,pstrUsername,pstrDomain,pstrPassword,pbRet)	\
    (This)->lpVtbl -> LogonWithExternalCredentials(This,pstrUsername,pstrDomain,pstrPassword,pbRet)

#define ILocalMachine_InitiateInteractiveLogon(This,pstrUsername,pstrDomain,pstrPassword,dwTimeout,pbRet)	\
    (This)->lpVtbl -> InitiateInteractiveLogon(This,pstrUsername,pstrDomain,pstrPassword,dwTimeout,pbRet)

#define ILocalMachine_UndockComputer(This)	\
    (This)->lpVtbl -> UndockComputer(This)

#define ILocalMachine_EnableGuest(This,flags)	\
    (This)->lpVtbl -> EnableGuest(This,flags)

#define ILocalMachine_DisableGuest(This,flags)	\
    (This)->lpVtbl -> DisableGuest(This,flags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_get_MachineName_Proxy( 
    ILocalMachine * This,
    /* [retval][out] */ VARIANT *pvarVal);


void __RPC_STUB ILocalMachine_get_MachineName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_get_isGuestEnabled_Proxy( 
    ILocalMachine * This,
    /* [in] */ ILM_GUEST_FLAGS flags,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB ILocalMachine_get_isGuestEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_get_isFriendlyUIEnabled_Proxy( 
    ILocalMachine * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB ILocalMachine_get_isFriendlyUIEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_put_isFriendlyUIEnabled_Proxy( 
    ILocalMachine * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB ILocalMachine_put_isFriendlyUIEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_get_isMultipleUsersEnabled_Proxy( 
    ILocalMachine * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB ILocalMachine_get_isMultipleUsersEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_put_isMultipleUsersEnabled_Proxy( 
    ILocalMachine * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB ILocalMachine_put_isMultipleUsersEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_get_isRemoteConnectionsEnabled_Proxy( 
    ILocalMachine * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB ILocalMachine_get_isRemoteConnectionsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_put_isRemoteConnectionsEnabled_Proxy( 
    ILocalMachine * This,
    /* [in] */ VARIANT_BOOL bEnabled);


void __RPC_STUB ILocalMachine_put_isRemoteConnectionsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_get_AccountName_Proxy( 
    ILocalMachine * This,
    /* [in] */ VARIANT varAccount,
    /* [retval][out] */ VARIANT *pvarVal);


void __RPC_STUB ILocalMachine_get_AccountName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_get_isUndockEnabled_Proxy( 
    ILocalMachine * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB ILocalMachine_get_isUndockEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_get_isShutdownAllowed_Proxy( 
    ILocalMachine * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB ILocalMachine_get_isShutdownAllowed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_get_isGuestAccessMode_Proxy( 
    ILocalMachine * This,
    /* [retval][out] */ VARIANT_BOOL *pbForceGuest);


void __RPC_STUB ILocalMachine_get_isGuestAccessMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_get_isOfflineFilesEnabled_Proxy( 
    ILocalMachine * This,
    /* [retval][out] */ VARIANT_BOOL *pbEnabled);


void __RPC_STUB ILocalMachine_get_isOfflineFilesEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_TurnOffComputer_Proxy( 
    ILocalMachine * This);


void __RPC_STUB ILocalMachine_TurnOffComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_SignalUIHostFailure_Proxy( 
    ILocalMachine * This);


void __RPC_STUB ILocalMachine_SignalUIHostFailure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_AllowExternalCredentials_Proxy( 
    ILocalMachine * This);


void __RPC_STUB ILocalMachine_AllowExternalCredentials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_RequestExternalCredentials_Proxy( 
    ILocalMachine * This);


void __RPC_STUB ILocalMachine_RequestExternalCredentials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_LogonWithExternalCredentials_Proxy( 
    ILocalMachine * This,
    /* [in] */ BSTR pstrUsername,
    /* [in] */ BSTR pstrDomain,
    /* [in] */ BSTR pstrPassword,
    /* [retval][out] */ VARIANT_BOOL *pbRet);


void __RPC_STUB ILocalMachine_LogonWithExternalCredentials_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_InitiateInteractiveLogon_Proxy( 
    ILocalMachine * This,
    /* [in] */ BSTR pstrUsername,
    /* [in] */ BSTR pstrDomain,
    /* [in] */ BSTR pstrPassword,
    /* [in] */ DWORD dwTimeout,
    /* [retval][out] */ VARIANT_BOOL *pbRet);


void __RPC_STUB ILocalMachine_InitiateInteractiveLogon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_UndockComputer_Proxy( 
    ILocalMachine * This);


void __RPC_STUB ILocalMachine_UndockComputer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_EnableGuest_Proxy( 
    ILocalMachine * This,
    ILM_GUEST_FLAGS flags);


void __RPC_STUB ILocalMachine_EnableGuest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILocalMachine_DisableGuest_Proxy( 
    ILocalMachine * This,
    ILM_GUEST_FLAGS flags);


void __RPC_STUB ILocalMachine_DisableGuest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILocalMachine_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellLocalMachine;

#ifdef __cplusplus

class DECLSPEC_UUID("60664CAF-AF0D-0005-A300-5C7D25FF22A0")
ShellLocalMachine;
#endif

#ifndef __ILogonStatusHost_INTERFACE_DEFINED__
#define __ILogonStatusHost_INTERFACE_DEFINED__

/* interface ILogonStatusHost */
/* [oleautomation][helpstring][hidden][dual][uuid][object] */ 


EXTERN_C const IID IID_ILogonStatusHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("60664CAF-AF0D-1007-A300-5C7D25FF22A0")
    ILogonStatusHost : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ HINSTANCE hInstance,
            /* [in] */ HWND hwndHost) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WindowProcedureHelper( 
            /* [in] */ HWND hwnd,
            /* [in] */ UINT uMsg,
            /* [in] */ VARIANT wParam,
            /* [in] */ VARIANT lParam) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UnInitialize( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogonStatusHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILogonStatusHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILogonStatusHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILogonStatusHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ILogonStatusHost * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ILogonStatusHost * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ILogonStatusHost * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILogonStatusHost * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ILogonStatusHost * This,
            /* [in] */ HINSTANCE hInstance,
            /* [in] */ HWND hwndHost);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WindowProcedureHelper )( 
            ILogonStatusHost * This,
            /* [in] */ HWND hwnd,
            /* [in] */ UINT uMsg,
            /* [in] */ VARIANT wParam,
            /* [in] */ VARIANT lParam);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UnInitialize )( 
            ILogonStatusHost * This);
        
        END_INTERFACE
    } ILogonStatusHostVtbl;

    interface ILogonStatusHost
    {
        CONST_VTBL struct ILogonStatusHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILogonStatusHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILogonStatusHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILogonStatusHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILogonStatusHost_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILogonStatusHost_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILogonStatusHost_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILogonStatusHost_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILogonStatusHost_Initialize(This,hInstance,hwndHost)	\
    (This)->lpVtbl -> Initialize(This,hInstance,hwndHost)

#define ILogonStatusHost_WindowProcedureHelper(This,hwnd,uMsg,wParam,lParam)	\
    (This)->lpVtbl -> WindowProcedureHelper(This,hwnd,uMsg,wParam,lParam)

#define ILogonStatusHost_UnInitialize(This)	\
    (This)->lpVtbl -> UnInitialize(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILogonStatusHost_Initialize_Proxy( 
    ILogonStatusHost * This,
    /* [in] */ HINSTANCE hInstance,
    /* [in] */ HWND hwndHost);


void __RPC_STUB ILogonStatusHost_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILogonStatusHost_WindowProcedureHelper_Proxy( 
    ILogonStatusHost * This,
    /* [in] */ HWND hwnd,
    /* [in] */ UINT uMsg,
    /* [in] */ VARIANT wParam,
    /* [in] */ VARIANT lParam);


void __RPC_STUB ILogonStatusHost_WindowProcedureHelper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ILogonStatusHost_UnInitialize_Proxy( 
    ILogonStatusHost * This);


void __RPC_STUB ILogonStatusHost_UnInitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILogonStatusHost_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ShellLogonStatusHost;

#ifdef __cplusplus

class DECLSPEC_UUID("60664CAF-AF0D-0007-A300-5C7D25FF22A0")
ShellLogonStatusHost;
#endif
#endif /* __SHGINALib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\shlapip.h ===
//***************************************************************************
//  --- SHELLAPI.W SHSEMIP.H SHLOBJ.W SHOBJIDL.IDL SHLDISP.IDL SHPRIV.IDL ---
//                Which header is best for my new API?
//
//  SHELLAPI    - ALL NEW SHELL32 EXPORTS public and private
//              used for both public and private exports from shell32
//
//  SHLOBJ      - *AVOID NEW USAGE*, PREFER OTHER HEADERS
//              used primarily for legacy compatibility
//
//  SHSEMIP     - *AVOID _ALL_ USAGE*, NO EXPORTS, SUPER PRIVATE
//              used for very private shell defines.
//
//  SHOBJIDL    - ALL NEW SHELL PUBLIC INTERFACES
//              primary file for public shell (shell32+) interfaces
//
//  SHLDISP     - ALL NEW SHELL AUTOMATION INTERFACES
//              automation interfaces are always public
//
//  SHPRIV      - ALL NEW SHELL PRIVATE INTERFACES
//              private interfaces used anywhere in the shell
//
//***************************************************************************
#ifndef _SHELAPIP_
#define _SHELAPIP_

#include <objbase.h>

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI       DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#ifndef SHSTDAPI
#if !defined(_SHELL32_)
#define SHSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define SHSTDAPI          STDAPI
#define SHSTDAPI_(type)   STDAPI_(type)
#endif
#endif // SHSTDAPI

#ifndef SHDOCAPI
#if !defined(_SHDOCVW_)
#define SHDOCAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define SHDOCAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define SHDOCAPI          STDAPI
#define SHDOCAPI_(type)   STDAPI_(type)
#endif
#endif // SHDOCAPI


#if !defined(_WIN64)
#include <pshpack1.h>
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


// BUGBUG this API needs to be A/W. Don't make it public until it is.
SHSTDAPI_(BOOL) DragQueryInfo(HDROP hDrop, LPDRAGINFO lpdi);
// WARNING! If you add a new ABM_* message, you might need to add a
// "case ABM_NEWMESSAGE:" to it in SHAppBarMessage.
#define ABE_MAX         4

//
//  We have to define this structure twice.
//  The public definition uses HWNDs and LPARAMs.
//  The private definition uses DWORDs for Win32/64 interop.
//  The private version is called "APPBARDATA3264" because it is the
//  explicit cross-bitness version.
//
//  Make sure to keep them in sync!
//
//  If you add any fields to this structure, you must also change the
//  32/64 thunk code in SHAppBarMessage.
//
#include <pshpack8.h>

typedef struct _AppBarData3264
{
    DWORD cbSize;
    DWORD dwWnd;
    UINT uCallbackMessage;
    UINT uEdge;
    RECT rc;
    DWORDLONG lParam; // message specific
} APPBARDATA3264, *PAPPBARDATA3264;

typedef struct _TRAYAPPBARDATA
{
    APPBARDATA3264 abd;
    DWORD dwMessage;
    DWORD hSharedABD;
    DWORD dwProcId;
} TRAYAPPBARDATA, *PTRAYAPPBARDATA;

#include <poppack.h>
SHSTDAPI_(HGLOBAL) InternalExtractIconA(HINSTANCE hInst, LPCSTR lpszFile, UINT nIconIndex, UINT nIcons);
SHSTDAPI_(HGLOBAL) InternalExtractIconW(HINSTANCE hInst, LPCWSTR lpszFile, UINT nIconIndex, UINT nIcons);
#ifdef UNICODE
#define InternalExtractIcon  InternalExtractIconW
#else
#define InternalExtractIcon  InternalExtractIconA
#endif // !UNICODE
SHSTDAPI_(HGLOBAL) InternalExtractIconListA(HANDLE hInst, LPSTR lpszExeFileName, LPINT lpnIcons);
SHSTDAPI_(HGLOBAL) InternalExtractIconListW(HANDLE hInst, LPWSTR lpszExeFileName, LPINT lpnIcons);
#ifdef UNICODE
#define InternalExtractIconList  InternalExtractIconListW
#else
#define InternalExtractIconList  InternalExtractIconListA
#endif // !UNICODE
SHSTDAPI_(BOOL)    RegisterShellHook(HWND, BOOL);
#define SHGetNameMappingCount(_hnm) DSA_GetItemCount(_hnm)
#define SHGetNameMappingPtr(_hnm, _iItem) (LPSHNAMEMAPPING)DSA_GetItemPtr(_hnm, _iItem)

typedef struct _RUNDLL_NOTIFYA {
    NMHDR     hdr;
    HICON     hIcon;
    LPSTR     lpszTitle;
} RUNDLL_NOTIFYA;
typedef struct _RUNDLL_NOTIFYW {
    NMHDR     hdr;
    HICON     hIcon;
    LPWSTR    lpszTitle;
} RUNDLL_NOTIFYW;
#ifdef UNICODE
typedef RUNDLL_NOTIFYW RUNDLL_NOTIFY;
#else
typedef RUNDLL_NOTIFYA RUNDLL_NOTIFY;
#endif // UNICODE

typedef void (WINAPI *RUNDLLPROCA)(HWND hwndStub, HINSTANCE hInstance, LPSTR pszCmdLine, int nCmdShow);
typedef void (WINAPI *RUNDLLPROCW)(HWND hwndStub, HINSTANCE hInstance, LPWSTR pszCmdLine, int nCmdShow);
#ifdef UNICODE
#define RUNDLLPROC  RUNDLLPROCW
#else
#define RUNDLLPROC  RUNDLLPROCA
#endif // !UNICODE

#define RDN_FIRST       (0U-500U)
#define RDN_LAST        (0U-509U)
#define RDN_TASKINFO    (RDN_FIRST-0)

#define SEN_DDEEXECUTE (SEN_FIRST-0)

HINSTANCE RealShellExecuteA(
    HWND hwndParent,
    LPCSTR lpOperation,
    LPCSTR lpFile,
    LPCSTR lpParameters,
    LPCSTR lpDirectory,
    LPSTR lpResult,
    LPCSTR lpTitle,
    LPSTR lpReserved,
    WORD nShow,
    LPHANDLE lphProcess);
HINSTANCE RealShellExecuteW(
    HWND hwndParent,
    LPCWSTR lpOperation,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    LPWSTR lpResult,
    LPCWSTR lpTitle,
    LPWSTR lpReserved,
    WORD nShow,
    LPHANDLE lphProcess);
#ifdef UNICODE
#define RealShellExecute  RealShellExecuteW
#else
#define RealShellExecute  RealShellExecuteA
#endif // !UNICODE

HINSTANCE RealShellExecuteExA(
    HWND hwndParent,
    LPCSTR lpOperation,
    LPCSTR lpFile,
    LPCSTR lpParameters,
    LPCSTR lpDirectory,
    LPSTR lpResult,
    LPCSTR lpTitle,
    LPSTR lpReserved,
    WORD nShow,
    LPHANDLE lphProcess,
    DWORD dwFlags);
HINSTANCE RealShellExecuteExW(
    HWND hwndParent,
    LPCWSTR lpOperation,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    LPWSTR lpResult,
    LPCWSTR lpTitle,
    LPWSTR lpReserved,
    WORD nShow,
    LPHANDLE lphProcess,
    DWORD dwFlags);
#ifdef UNICODE
#define RealShellExecuteEx  RealShellExecuteExW
#else
#define RealShellExecuteEx  RealShellExecuteExA
#endif // !UNICODE

//
// RealShellExecuteEx flags
//
#define EXEC_SEPARATE_VDM     0x00000001
#define EXEC_NO_CONSOLE       0x00000002
#define SEE_MASK_FLAG_SHELLEXEC    0x00000800
#define SEE_MASK_FORCENOIDLIST     0x00001000
#define SEE_MASK_NO_HOOKS          0x00002000
#define SEE_MASK_HASLINKNAME       0x00010000
#define SEE_MASK_FLAG_SEPVDM       0x00020000
#define SEE_MASK_RESERVED          0x00040000
#define SEE_MASK_HASTITLE          0x00080000
#define SEE_MASK_FILEANDURL        0x00400000
// we have CMIC_MASK_ values that don't have corospongind SEE_MASK_ counterparts
//      CMIC_MASK_SHIFT_DOWN      0x10000000
//      CMIC_MASK_PTINVOKE        0x20000000
//      CMIC_MASK_CONTROL_DOWN    0x40000000

// All other bits are masked off when we do an InvokeCommand
#define SEE_VALID_CMIC_BITS       0x348FAFF0
#define SEE_VALID_CMIC_FLAGS      0x048FAFC0
#define SEE_MASK_VALID            0x07FFFFFF
// The LPVOID lpIDList parameter is the IDList
//
//  We have to define this structure twice.
//  The public definition uses HWNDs and HICONs.
//  The private definition uses DWORDs for Win32/64 interop.
//  The private definition is in a pack(1) block for the same reason.
//  The private version is called "NOTIFYICONDATA32" because it is the
//  explicit 32-bit version.
//
//  Make sure to keep them in sync!
//

#if defined(_WIN64)
#include <pshpack1.h>
#endif
typedef struct _NOTIFYICONDATA32A {
        DWORD cbSize;
        DWORD dwWnd;                        // NB!
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        DWORD dwIcon;                       // NB!
#if (_WIN32_IE < 0x0500)
        CHAR   szTip[64];
#else
        CHAR   szTip[128];
#endif
#if (_WIN32_IE >= 0x0500)
        DWORD dwState;
        DWORD dwStateMask;
        CHAR   szInfo[256];
        union {
            UINT  uTimeout;
            UINT  uVersion;
        } DUMMYUNIONNAME;
        CHAR   szInfoTitle[64];
        DWORD dwInfoFlags;
#endif
#if (_WIN32_IE >= 0x600)
        GUID guidItem;
#endif
} NOTIFYICONDATA32A, *PNOTIFYICONDATA32A;
typedef struct _NOTIFYICONDATA32W {
        DWORD cbSize;
        DWORD dwWnd;                        // NB!
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        DWORD dwIcon;                       // NB!
#if (_WIN32_IE < 0x0500)
        WCHAR  szTip[64];
#else
        WCHAR  szTip[128];
#endif
#if (_WIN32_IE >= 0x0500)
        DWORD dwState;
        DWORD dwStateMask;
        WCHAR  szInfo[256];
        union {
            UINT  uTimeout;
            UINT  uVersion;
        } DUMMYUNIONNAME;
        WCHAR  szInfoTitle[64];
        DWORD dwInfoFlags;
#endif
#if (_WIN32_IE >= 0x600)
        GUID guidItem;
#endif
} NOTIFYICONDATA32W, *PNOTIFYICONDATA32W;
#ifdef UNICODE
typedef NOTIFYICONDATA32W NOTIFYICONDATA32;
typedef PNOTIFYICONDATA32W PNOTIFYICONDATA32;
#else
typedef NOTIFYICONDATA32A NOTIFYICONDATA32;
typedef PNOTIFYICONDATA32A PNOTIFYICONDATA32;
#endif // UNICODE
#if defined(_WIN64)
#include <poppack.h>
#endif
#if defined(_WIN64)
#include <pshpack1.h>
#endif
typedef struct _TRAYNOTIFYDATAA {
        DWORD dwSignature;
        DWORD dwMessage;
        NOTIFYICONDATA32 nid;
} TRAYNOTIFYDATAA, *PTRAYNOTIFYDATAA;
typedef struct _TRAYNOTIFYDATAW {
        DWORD dwSignature;
        DWORD dwMessage;
        NOTIFYICONDATA32 nid;
} TRAYNOTIFYDATAW, *PTRAYNOTIFYDATAW;
#ifdef UNICODE
typedef TRAYNOTIFYDATAW TRAYNOTIFYDATA;
typedef PTRAYNOTIFYDATAW PTRAYNOTIFYDATA;
#else
typedef TRAYNOTIFYDATAA TRAYNOTIFYDATA;
typedef PTRAYNOTIFYDATAA PTRAYNOTIFYDATA;
#endif // UNICODE
#if defined(_WIN64)
#include <poppack.h>
#endif
#define NI_SIGNATURE    0x34753423

#define WNDCLASS_TRAYNOTIFY     "Shell_TrayWnd"
#define ENABLE_BALLOONTIP_MESSAGE L"Enable Balloon Tip"
//                          (WM_USER + 1) = NIN_KEYSELECT
#define NIF_VALID_V1    0x00000007
#define NIF_VALID_V2    0x0000001F
#define NIF_VALID       0x0000003F

//
// IMPORTANT! IMPORTANT! 
// Keep enum ICONSTATEFLAGS in trayitem.h in sync when a new flag is defined here..
//

#if (_WIN32_IE >= 0x0600)                       
#define NIS_SHOWALWAYS          0x20000000      
#endif

// NOTE : The NIS_SHOWALWAYS flag above is 0x20000000
#define NISP_SHAREDICONSOURCE   0x10000000

// NOTE: NIS_SHOWALWAYS flag is defined with 0x20000000...

#define NISP_DEMOTED             0x00100000
#define NISP_STARTUPICON         0x00200000
#define NISP_ONCEVISIBLE         0x00400000
#define NISP_ITEMCLICKED         0x00800000
#define NISP_ITEMSAMEICONMODIFY  0x01000000
//
// Old NT Compatibility stuff (remove later)
//
SHSTDAPI_(VOID) CheckEscapesA(LPSTR lpFileA, DWORD cch);
//
// Old NT Compatibility stuff (remove later)
//
SHSTDAPI_(VOID) CheckEscapesW(LPWSTR lpFileA, DWORD cch);
#ifdef UNICODE
#define CheckEscapes  CheckEscapesW
#else
#define CheckEscapes  CheckEscapesA
#endif // !UNICODE
SHSTDAPI_(LPSTR) SheRemoveQuotesA(LPSTR sz);
SHSTDAPI_(LPWSTR) SheRemoveQuotesW(LPWSTR sz);
#ifdef UNICODE
#define SheRemoveQuotes  SheRemoveQuotesW
#else
#define SheRemoveQuotes  SheRemoveQuotesA
#endif // !UNICODE
SHSTDAPI_(WORD) ExtractIconResInfoA(HANDLE hInst,LPSTR lpszFileName,WORD wIconIndex,LPWORD lpwSize,LPHANDLE lphIconRes);
SHSTDAPI_(WORD) ExtractIconResInfoW(HANDLE hInst,LPWSTR lpszFileName,WORD wIconIndex,LPWORD lpwSize,LPHANDLE lphIconRes);
#ifdef UNICODE
#define ExtractIconResInfo  ExtractIconResInfoW
#else
#define ExtractIconResInfo  ExtractIconResInfoA
#endif // !UNICODE
SHSTDAPI_(int) SheSetCurDrive(int iDrive);
SHSTDAPI_(int) SheChangeDirA(register CHAR *newdir);
SHSTDAPI_(int) SheChangeDirW(register WCHAR *newdir);
#ifdef UNICODE
#define SheChangeDir  SheChangeDirW
#else
#define SheChangeDir  SheChangeDirA
#endif // !UNICODE
SHSTDAPI_(int) SheGetDirA(int iDrive, CHAR *str);
SHSTDAPI_(int) SheGetDirW(int iDrive, WCHAR *str);
#ifdef UNICODE
#define SheGetDir  SheGetDirW
#else
#define SheGetDir  SheGetDirA
#endif // !UNICODE
SHSTDAPI_(BOOL) SheConvertPathA(LPSTR lpApp, LPSTR lpFile, UINT cchCmdBuf);
SHSTDAPI_(BOOL) SheConvertPathW(LPWSTR lpApp, LPWSTR lpFile, UINT cchCmdBuf);
#ifdef UNICODE
#define SheConvertPath  SheConvertPathW
#else
#define SheConvertPath  SheConvertPathA
#endif // !UNICODE
SHSTDAPI_(BOOL) SheShortenPathA(LPSTR pPath, BOOL bShorten);
SHSTDAPI_(BOOL) SheShortenPathW(LPWSTR pPath, BOOL bShorten);
#ifdef UNICODE
#define SheShortenPath  SheShortenPathW
#else
#define SheShortenPath  SheShortenPathA
#endif // !UNICODE
SHSTDAPI_(BOOL) RegenerateUserEnvironment(PVOID *pPrevEnv,
                                        BOOL bSetCurrentEnv);
SHSTDAPI_(INT) SheGetPathOffsetW(LPWSTR lpszDir);
SHSTDAPI_(BOOL) SheGetDirExW(LPWSTR lpszCurDisk, LPDWORD lpcchCurDir,LPWSTR lpszCurDir);
SHSTDAPI_(DWORD) ExtractVersionResource16W(LPCWSTR  lpwstrFilename, LPHANDLE lphData);
SHSTDAPI_(INT) SheChangeDirExA(register CHAR *newdir);
SHSTDAPI_(INT) SheChangeDirExW(register WCHAR *newdir);
#ifdef UNICODE
#define SheChangeDirEx  SheChangeDirExW
#else
#define SheChangeDirEx  SheChangeDirExA
#endif // !UNICODE

//
// PRINTQ
//
VOID Printer_LoadIconsA(LPCSTR pszPrinterName, HICON* phLargeIcon, HICON* phSmallIcon);
//
// PRINTQ
//
VOID Printer_LoadIconsW(LPCWSTR pszPrinterName, HICON* phLargeIcon, HICON* phSmallIcon);
#ifdef UNICODE
#define Printer_LoadIcons  Printer_LoadIconsW
#else
#define Printer_LoadIcons  Printer_LoadIconsA
#endif // !UNICODE
LPSTR ShortSizeFormatA(DWORD dw, LPSTR szBuf);
LPWSTR ShortSizeFormatW(DWORD dw, LPWSTR szBuf);
#ifdef UNICODE
#define ShortSizeFormat  ShortSizeFormatW
#else
#define ShortSizeFormat  ShortSizeFormatA
#endif // !UNICODE
LPSTR AddCommasA(DWORD dw, LPSTR pszResult);
LPWSTR AddCommasW(DWORD dw, LPWSTR pszResult);
#ifdef UNICODE
#define AddCommas  AddCommasW
#else
#define AddCommas  AddCommasA
#endif // !UNICODE

BOOL Printers_RegisterWindowA(LPCSTR pszPrinter, DWORD dwType, PHANDLE phClassPidl, HWND *phwnd);
BOOL Printers_RegisterWindowW(LPCWSTR pszPrinter, DWORD dwType, PHANDLE phClassPidl, HWND *phwnd);
#ifdef UNICODE
#define Printers_RegisterWindow  Printers_RegisterWindowW
#else
#define Printers_RegisterWindow  Printers_RegisterWindowA
#endif // !UNICODE
VOID Printers_UnregisterWindow(HANDLE hClassPidl, HWND hwnd);

#define PRINTER_PIDL_TYPE_PROPERTIES       0x1
#define PRINTER_PIDL_TYPE_DOCUMENTDEFAULTS 0x2
#define PRINTER_PIDL_TYPE_ALL_USERS_DOCDEF 0x3
#define PRINTER_PIDL_TYPE_JOBID            0x80000000
//
// Internal APIs Follow.  NOT FOR PUBLIC CONSUMPTION.
//

// DOC'ed for DOJ compliance

//====== Random stuff ================================================


// DOC'ed for DOJ Compliance

//  INTERNAL: User picture APIs. These functions live in util.cpp

#if         _WIN32_IE >= 0x0600

#define SHGUPP_FLAG_BASEPATH            0x00000001
#define SHGUPP_FLAG_DEFAULTPICSPATH     0x00000002
#define SHGUPP_FLAG_CREATE              0x80000000
#define SHGUPP_FLAG_VALID_MASK          0x80000003
#define SHGUPP_FLAG_INVALID_MASK        ~SHGUPP_FLAG_VALID_MASK

STDAPI          SHGetUserPicturePathA(LPCSTR pszUsername, DWORD dwFlags, LPSTR pszPath);
STDAPI          SHGetUserPicturePathW(LPCWSTR pszUsername, DWORD dwFlags, LPWSTR pszPath);
#ifdef UNICODE
#define SHGetUserPicturePath  SHGetUserPicturePathW
#else
#define SHGetUserPicturePath  SHGetUserPicturePathA
#endif // !UNICODE

#define SHSUPP_FLAG_VALID_MASK          0x00000000
#define SHSUPP_FLAG_INVALID_MASK        ~SHSUPP_FLAG_VALID_MASK

STDAPI          SHSetUserPicturePathA(LPCSTR pszUsername, DWORD dwFlags, LPCSTR pszPath);
STDAPI          SHSetUserPicturePathW(LPCWSTR pszUsername, DWORD dwFlags, LPCWSTR pszPath);
#ifdef UNICODE
#define SHSetUserPicturePath  SHSetUserPicturePathW
#else
#define SHSetUserPicturePath  SHSetUserPicturePathA
#endif // !UNICODE

//  INTERNAL: Multiple user and friendly UI APIs. These functions live in util.cpp

STDAPI          SHGetUserDisplayName(LPWSTR pszDisplayName, PULONG uLen);
STDAPI_(BOOL)   SHIsCurrentThreadInteractive(void);

#endif  /*  _WIN32_IE >= 0x0600     */


#if         _WIN32_IE >= 0x0600

//  INTERNAL: These functions live in securent.cpp

typedef HRESULT (CALLBACK * PFNPRIVILEGEDFUNCTION) (void *pv);

STDAPI_(BOOL)   SHOpenEffectiveToken(HANDLE *phToken);
STDAPI_(BOOL)   SHTestTokenPrivilegeA(HANDLE hToken, LPCSTR pszPrivilegeName);
STDAPI_(BOOL)   SHTestTokenPrivilegeW(HANDLE hToken, LPCWSTR pszPrivilegeName);
#ifdef UNICODE
#define SHTestTokenPrivilege  SHTestTokenPrivilegeW
#else
#define SHTestTokenPrivilege  SHTestTokenPrivilegeA
#endif // !UNICODE
// DOC'ed for DOJ compliance
STDAPI          SHInvokePrivilegedFunctionA(LPCSTR pszPrivilegeName, PFNPRIVILEGEDFUNCTION pfnPrivilegedFunction, void *pv);
// DOC'ed for DOJ compliance
STDAPI          SHInvokePrivilegedFunctionW(LPCWSTR pszPrivilegeName, PFNPRIVILEGEDFUNCTION pfnPrivilegedFunction, void *pv);
#ifdef UNICODE
#define SHInvokePrivilegedFunction  SHInvokePrivilegedFunctionW
#else
#define SHInvokePrivilegedFunction  SHInvokePrivilegedFunctionA
#endif // !UNICODE
STDAPI_(DWORD)  SHGetActiveConsoleSessionId(void);
STDAPI_(DWORD)  SHGetUserSessionId(HANDLE hToken);
STDAPI_(BOOL)   SHIsCurrentProcessConsoleSession(void);

#endif  /*  _WIN32_IE >= 0x0600     */

//
// *** please keep the SHIL_'s arranged in alternating large/small order, if possible ***
// (see comments in shell32\shapi.cpp, function _GetILIndexGivenPXIcon)
//

// API to format and return the computer name/description

#define SGCDNF_NOCACHEDENTRY    0x00000001
#define SGCDNF_DESCRIPTIONONLY  0x00010000

STDAPI SHGetComputerDisplayNameA(LPCSTR pszMachineName, DWORD dwFlags, LPSTR pszDisplay, DWORD cchDisplay);
STDAPI SHGetComputerDisplayNameW(LPCWSTR pszMachineName, DWORD dwFlags, LPWSTR pszDisplay, DWORD cchDisplay);
#ifdef UNICODE
#define SHGetComputerDisplayName  SHGetComputerDisplayNameW
#else
#define SHGetComputerDisplayName  SHGetComputerDisplayNameA
#endif // !UNICODE


// Namespaces that used to expose one or two tasks through a Wizard
// need a common heuristic to use to determine when they should expose
// these through a Web View Task or through the legacy way of a Wizard.
// Call this from your enumerator:
//   S_FALSE -> wizards should not be enumerated, S_OK -> wizards should be shown
STDAPI SHShouldShowWizards(IUnknown *punksite); 

// Netplwiz Disconnect Drive Dialog
STDAPI_(DWORD) SHDisconnectNetDrives(HWND hwndParent);
typedef DWORD (STDMETHODCALLTYPE *PFNSHDISCONNECTNETDRIVES)(IN HWND hwndParent);

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#if !defined(_WIN64)
#include <poppack.h>
#endif
// Function to remove a thumbnail for a file from the thumbnail databse
STDAPI DeleteFileThumbnail(IN LPCWSTR pszFilePath);

#endif  /* _SHELAPIP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\shimgdata.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for shimgdata.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __shimgdata_h__
#define __shimgdata_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IShellImageDataFactory_FWD_DEFINED__
#define __IShellImageDataFactory_FWD_DEFINED__
typedef interface IShellImageDataFactory IShellImageDataFactory;
#endif 	/* __IShellImageDataFactory_FWD_DEFINED__ */


#ifndef __IShellImageData_FWD_DEFINED__
#define __IShellImageData_FWD_DEFINED__
typedef interface IShellImageData IShellImageData;
#endif 	/* __IShellImageData_FWD_DEFINED__ */


#ifndef __IShellImageDataAbort_FWD_DEFINED__
#define __IShellImageDataAbort_FWD_DEFINED__
typedef interface IShellImageDataAbort IShellImageDataAbort;
#endif 	/* __IShellImageDataAbort_FWD_DEFINED__ */


#ifndef __ShellImageDataFactory_FWD_DEFINED__
#define __ShellImageDataFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellImageDataFactory ShellImageDataFactory;
#else
typedef struct ShellImageDataFactory ShellImageDataFactory;
#endif /* __cplusplus */

#endif 	/* __ShellImageDataFactory_FWD_DEFINED__ */


#ifndef __AutoplayForSlideShow_FWD_DEFINED__
#define __AutoplayForSlideShow_FWD_DEFINED__

#ifdef __cplusplus
typedef class AutoplayForSlideShow AutoplayForSlideShow;
#else
typedef struct AutoplayForSlideShow AutoplayForSlideShow;
#endif /* __cplusplus */

#endif 	/* __AutoplayForSlideShow_FWD_DEFINED__ */


/* header files for imported files */
#include "oleidl.h"
#include "shobjidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_shimgdata_0000 */
/* [local] */ 





#if !defined(_GDIPLUSPIXELFORMATS_H)
typedef DWORD PixelFormat;

#endif
#if !defined(_GDIPLUSENUMS_H)
typedef DWORD InterpolationMode;

#endif
#if !defined(_GDIPLUSHEADERS_H)
typedef BYTE EncoderParameters;

typedef BYTE Image;

#endif
#define  SHIMGKEY_QUALITY    L"Compression"
#define  SHIMGKEY_RAWFORMAT  L"RawDataFormat"

#define  SHIMGDEC_DEFAULT            0x00000000
#define  SHIMGDEC_THUMBNAIL          0x00000001
#define  SHIMGDEC_LOADFULL           0x00000002
#define  E_NOTVALIDFORANIMATEDIMAGE  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x01)


extern RPC_IF_HANDLE __MIDL_itf_shimgdata_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shimgdata_0000_v0_0_s_ifspec;

#ifndef __IShellImageDataFactory_INTERFACE_DEFINED__
#define __IShellImageDataFactory_INTERFACE_DEFINED__

/* interface IShellImageDataFactory */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IShellImageDataFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9be8ed5c-edab-4d75-90f3-bd5bdbb21c82")
    IShellImageDataFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateIShellImageData( 
            /* [out] */ IShellImageData **ppshimg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateImageFromFile( 
            /* [in] */ LPCWSTR pszPath,
            /* [out] */ IShellImageData **ppshimg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateImageFromStream( 
            /* [in] */ IStream *pStream,
            /* [out] */ IShellImageData **ppshimg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataFormatFromPath( 
            /* [in] */ LPCWSTR pszPath,
            /* [out] */ GUID *pDataFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellImageDataFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellImageDataFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellImageDataFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellImageDataFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateIShellImageData )( 
            IShellImageDataFactory * This,
            /* [out] */ IShellImageData **ppshimg);
        
        HRESULT ( STDMETHODCALLTYPE *CreateImageFromFile )( 
            IShellImageDataFactory * This,
            /* [in] */ LPCWSTR pszPath,
            /* [out] */ IShellImageData **ppshimg);
        
        HRESULT ( STDMETHODCALLTYPE *CreateImageFromStream )( 
            IShellImageDataFactory * This,
            /* [in] */ IStream *pStream,
            /* [out] */ IShellImageData **ppshimg);
        
        HRESULT ( STDMETHODCALLTYPE *GetDataFormatFromPath )( 
            IShellImageDataFactory * This,
            /* [in] */ LPCWSTR pszPath,
            /* [out] */ GUID *pDataFormat);
        
        END_INTERFACE
    } IShellImageDataFactoryVtbl;

    interface IShellImageDataFactory
    {
        CONST_VTBL struct IShellImageDataFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellImageDataFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellImageDataFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellImageDataFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellImageDataFactory_CreateIShellImageData(This,ppshimg)	\
    (This)->lpVtbl -> CreateIShellImageData(This,ppshimg)

#define IShellImageDataFactory_CreateImageFromFile(This,pszPath,ppshimg)	\
    (This)->lpVtbl -> CreateImageFromFile(This,pszPath,ppshimg)

#define IShellImageDataFactory_CreateImageFromStream(This,pStream,ppshimg)	\
    (This)->lpVtbl -> CreateImageFromStream(This,pStream,ppshimg)

#define IShellImageDataFactory_GetDataFormatFromPath(This,pszPath,pDataFormat)	\
    (This)->lpVtbl -> GetDataFormatFromPath(This,pszPath,pDataFormat)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellImageDataFactory_CreateIShellImageData_Proxy( 
    IShellImageDataFactory * This,
    /* [out] */ IShellImageData **ppshimg);


void __RPC_STUB IShellImageDataFactory_CreateIShellImageData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageDataFactory_CreateImageFromFile_Proxy( 
    IShellImageDataFactory * This,
    /* [in] */ LPCWSTR pszPath,
    /* [out] */ IShellImageData **ppshimg);


void __RPC_STUB IShellImageDataFactory_CreateImageFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageDataFactory_CreateImageFromStream_Proxy( 
    IShellImageDataFactory * This,
    /* [in] */ IStream *pStream,
    /* [out] */ IShellImageData **ppshimg);


void __RPC_STUB IShellImageDataFactory_CreateImageFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageDataFactory_GetDataFormatFromPath_Proxy( 
    IShellImageDataFactory * This,
    /* [in] */ LPCWSTR pszPath,
    /* [out] */ GUID *pDataFormat);


void __RPC_STUB IShellImageDataFactory_GetDataFormatFromPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellImageDataFactory_INTERFACE_DEFINED__ */


#ifndef __IShellImageData_INTERFACE_DEFINED__
#define __IShellImageData_INTERFACE_DEFINED__

/* interface IShellImageData */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IShellImageData;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("bfdeec12-8040-4403-a5ea-9e07dafcf530")
    IShellImageData : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Decode( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cxDesired,
            /* [in] */ ULONG cyDesired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Draw( 
            /* [in] */ HDC hdc,
            /* [in] */ LPRECT prcDest,
            /* [in] */ LPRECT prcSrc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextFrame( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextPage( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PrevPage( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsTransparent( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAnimated( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsVector( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsMultipage( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEditable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPrintable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDecoded( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentPage( 
            /* [out] */ ULONG *pnPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPageCount( 
            /* [out] */ ULONG *pcPages) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectPage( 
            /* [in] */ ULONG iPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ SIZE *pSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRawDataFormat( 
            /* [out] */ GUID *pDataFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPixelFormat( 
            /* [out] */ PixelFormat *pFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDelay( 
            /* [out] */ DWORD *pdwDelay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperties( 
            /* [in] */ DWORD dwMode,
            /* [out] */ IPropertySetStorage **ppPropSet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Rotate( 
            /* [in] */ DWORD dwAngle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Scale( 
            /* [in] */ ULONG cx,
            /* [in] */ ULONG cy,
            /* [in] */ InterpolationMode hints) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DiscardEdit( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEncoderParams( 
            /* [in] */ IPropertyBag *pbagEnc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplayName( 
            /* [out][in] */ LPWSTR wszName,
            /* [in] */ UINT cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResolution( 
            /* [out] */ ULONG *puResolutionX,
            /* [out] */ ULONG *puResolutionY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEncoderParams( 
            /* [in] */ GUID *pguidFmt,
            /* [out] */ EncoderParameters **ppEncParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterAbort( 
            /* [in] */ IShellImageDataAbort *pAbort,
            /* [optional][out] */ IShellImageDataAbort **ppAbortPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloneFrame( 
            /* [out] */ Image **ppImg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplaceFrame( 
            /* [in] */ Image *pImg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellImageDataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellImageData * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellImageData * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellImageData * This);
        
        HRESULT ( STDMETHODCALLTYPE *Decode )( 
            IShellImageData * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ULONG cxDesired,
            /* [in] */ ULONG cyDesired);
        
        HRESULT ( STDMETHODCALLTYPE *Draw )( 
            IShellImageData * This,
            /* [in] */ HDC hdc,
            /* [in] */ LPRECT prcDest,
            /* [in] */ LPRECT prcSrc);
        
        HRESULT ( STDMETHODCALLTYPE *NextFrame )( 
            IShellImageData * This);
        
        HRESULT ( STDMETHODCALLTYPE *NextPage )( 
            IShellImageData * This);
        
        HRESULT ( STDMETHODCALLTYPE *PrevPage )( 
            IShellImageData * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsTransparent )( 
            IShellImageData * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsAnimated )( 
            IShellImageData * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsVector )( 
            IShellImageData * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsMultipage )( 
            IShellImageData * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsEditable )( 
            IShellImageData * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsPrintable )( 
            IShellImageData * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsDecoded )( 
            IShellImageData * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentPage )( 
            IShellImageData * This,
            /* [out] */ ULONG *pnPage);
        
        HRESULT ( STDMETHODCALLTYPE *GetPageCount )( 
            IShellImageData * This,
            /* [out] */ ULONG *pcPages);
        
        HRESULT ( STDMETHODCALLTYPE *SelectPage )( 
            IShellImageData * This,
            /* [in] */ ULONG iPage);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            IShellImageData * This,
            /* [out] */ SIZE *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetRawDataFormat )( 
            IShellImageData * This,
            /* [out] */ GUID *pDataFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetPixelFormat )( 
            IShellImageData * This,
            /* [out] */ PixelFormat *pFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetDelay )( 
            IShellImageData * This,
            /* [out] */ DWORD *pdwDelay);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperties )( 
            IShellImageData * This,
            /* [in] */ DWORD dwMode,
            /* [out] */ IPropertySetStorage **ppPropSet);
        
        HRESULT ( STDMETHODCALLTYPE *Rotate )( 
            IShellImageData * This,
            /* [in] */ DWORD dwAngle);
        
        HRESULT ( STDMETHODCALLTYPE *Scale )( 
            IShellImageData * This,
            /* [in] */ ULONG cx,
            /* [in] */ ULONG cy,
            /* [in] */ InterpolationMode hints);
        
        HRESULT ( STDMETHODCALLTYPE *DiscardEdit )( 
            IShellImageData * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetEncoderParams )( 
            IShellImageData * This,
            /* [in] */ IPropertyBag *pbagEnc);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayName )( 
            IShellImageData * This,
            /* [out][in] */ LPWSTR wszName,
            /* [in] */ UINT cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetResolution )( 
            IShellImageData * This,
            /* [out] */ ULONG *puResolutionX,
            /* [out] */ ULONG *puResolutionY);
        
        HRESULT ( STDMETHODCALLTYPE *GetEncoderParams )( 
            IShellImageData * This,
            /* [in] */ GUID *pguidFmt,
            /* [out] */ EncoderParameters **ppEncParams);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterAbort )( 
            IShellImageData * This,
            /* [in] */ IShellImageDataAbort *pAbort,
            /* [optional][out] */ IShellImageDataAbort **ppAbortPrev);
        
        HRESULT ( STDMETHODCALLTYPE *CloneFrame )( 
            IShellImageData * This,
            /* [out] */ Image **ppImg);
        
        HRESULT ( STDMETHODCALLTYPE *ReplaceFrame )( 
            IShellImageData * This,
            /* [in] */ Image *pImg);
        
        END_INTERFACE
    } IShellImageDataVtbl;

    interface IShellImageData
    {
        CONST_VTBL struct IShellImageDataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellImageData_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellImageData_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellImageData_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellImageData_Decode(This,dwFlags,cxDesired,cyDesired)	\
    (This)->lpVtbl -> Decode(This,dwFlags,cxDesired,cyDesired)

#define IShellImageData_Draw(This,hdc,prcDest,prcSrc)	\
    (This)->lpVtbl -> Draw(This,hdc,prcDest,prcSrc)

#define IShellImageData_NextFrame(This)	\
    (This)->lpVtbl -> NextFrame(This)

#define IShellImageData_NextPage(This)	\
    (This)->lpVtbl -> NextPage(This)

#define IShellImageData_PrevPage(This)	\
    (This)->lpVtbl -> PrevPage(This)

#define IShellImageData_IsTransparent(This)	\
    (This)->lpVtbl -> IsTransparent(This)

#define IShellImageData_IsAnimated(This)	\
    (This)->lpVtbl -> IsAnimated(This)

#define IShellImageData_IsVector(This)	\
    (This)->lpVtbl -> IsVector(This)

#define IShellImageData_IsMultipage(This)	\
    (This)->lpVtbl -> IsMultipage(This)

#define IShellImageData_IsEditable(This)	\
    (This)->lpVtbl -> IsEditable(This)

#define IShellImageData_IsPrintable(This)	\
    (This)->lpVtbl -> IsPrintable(This)

#define IShellImageData_IsDecoded(This)	\
    (This)->lpVtbl -> IsDecoded(This)

#define IShellImageData_GetCurrentPage(This,pnPage)	\
    (This)->lpVtbl -> GetCurrentPage(This,pnPage)

#define IShellImageData_GetPageCount(This,pcPages)	\
    (This)->lpVtbl -> GetPageCount(This,pcPages)

#define IShellImageData_SelectPage(This,iPage)	\
    (This)->lpVtbl -> SelectPage(This,iPage)

#define IShellImageData_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define IShellImageData_GetRawDataFormat(This,pDataFormat)	\
    (This)->lpVtbl -> GetRawDataFormat(This,pDataFormat)

#define IShellImageData_GetPixelFormat(This,pFormat)	\
    (This)->lpVtbl -> GetPixelFormat(This,pFormat)

#define IShellImageData_GetDelay(This,pdwDelay)	\
    (This)->lpVtbl -> GetDelay(This,pdwDelay)

#define IShellImageData_GetProperties(This,dwMode,ppPropSet)	\
    (This)->lpVtbl -> GetProperties(This,dwMode,ppPropSet)

#define IShellImageData_Rotate(This,dwAngle)	\
    (This)->lpVtbl -> Rotate(This,dwAngle)

#define IShellImageData_Scale(This,cx,cy,hints)	\
    (This)->lpVtbl -> Scale(This,cx,cy,hints)

#define IShellImageData_DiscardEdit(This)	\
    (This)->lpVtbl -> DiscardEdit(This)

#define IShellImageData_SetEncoderParams(This,pbagEnc)	\
    (This)->lpVtbl -> SetEncoderParams(This,pbagEnc)

#define IShellImageData_DisplayName(This,wszName,cch)	\
    (This)->lpVtbl -> DisplayName(This,wszName,cch)

#define IShellImageData_GetResolution(This,puResolutionX,puResolutionY)	\
    (This)->lpVtbl -> GetResolution(This,puResolutionX,puResolutionY)

#define IShellImageData_GetEncoderParams(This,pguidFmt,ppEncParams)	\
    (This)->lpVtbl -> GetEncoderParams(This,pguidFmt,ppEncParams)

#define IShellImageData_RegisterAbort(This,pAbort,ppAbortPrev)	\
    (This)->lpVtbl -> RegisterAbort(This,pAbort,ppAbortPrev)

#define IShellImageData_CloneFrame(This,ppImg)	\
    (This)->lpVtbl -> CloneFrame(This,ppImg)

#define IShellImageData_ReplaceFrame(This,pImg)	\
    (This)->lpVtbl -> ReplaceFrame(This,pImg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellImageData_Decode_Proxy( 
    IShellImageData * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ULONG cxDesired,
    /* [in] */ ULONG cyDesired);


void __RPC_STUB IShellImageData_Decode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_Draw_Proxy( 
    IShellImageData * This,
    /* [in] */ HDC hdc,
    /* [in] */ LPRECT prcDest,
    /* [in] */ LPRECT prcSrc);


void __RPC_STUB IShellImageData_Draw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_NextFrame_Proxy( 
    IShellImageData * This);


void __RPC_STUB IShellImageData_NextFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_NextPage_Proxy( 
    IShellImageData * This);


void __RPC_STUB IShellImageData_NextPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_PrevPage_Proxy( 
    IShellImageData * This);


void __RPC_STUB IShellImageData_PrevPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsTransparent_Proxy( 
    IShellImageData * This);


void __RPC_STUB IShellImageData_IsTransparent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsAnimated_Proxy( 
    IShellImageData * This);


void __RPC_STUB IShellImageData_IsAnimated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsVector_Proxy( 
    IShellImageData * This);


void __RPC_STUB IShellImageData_IsVector_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsMultipage_Proxy( 
    IShellImageData * This);


void __RPC_STUB IShellImageData_IsMultipage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsEditable_Proxy( 
    IShellImageData * This);


void __RPC_STUB IShellImageData_IsEditable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsPrintable_Proxy( 
    IShellImageData * This);


void __RPC_STUB IShellImageData_IsPrintable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_IsDecoded_Proxy( 
    IShellImageData * This);


void __RPC_STUB IShellImageData_IsDecoded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetCurrentPage_Proxy( 
    IShellImageData * This,
    /* [out] */ ULONG *pnPage);


void __RPC_STUB IShellImageData_GetCurrentPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetPageCount_Proxy( 
    IShellImageData * This,
    /* [out] */ ULONG *pcPages);


void __RPC_STUB IShellImageData_GetPageCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_SelectPage_Proxy( 
    IShellImageData * This,
    /* [in] */ ULONG iPage);


void __RPC_STUB IShellImageData_SelectPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetSize_Proxy( 
    IShellImageData * This,
    /* [out] */ SIZE *pSize);


void __RPC_STUB IShellImageData_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetRawDataFormat_Proxy( 
    IShellImageData * This,
    /* [out] */ GUID *pDataFormat);


void __RPC_STUB IShellImageData_GetRawDataFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetPixelFormat_Proxy( 
    IShellImageData * This,
    /* [out] */ PixelFormat *pFormat);


void __RPC_STUB IShellImageData_GetPixelFormat_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetDelay_Proxy( 
    IShellImageData * This,
    /* [out] */ DWORD *pdwDelay);


void __RPC_STUB IShellImageData_GetDelay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetProperties_Proxy( 
    IShellImageData * This,
    /* [in] */ DWORD dwMode,
    /* [out] */ IPropertySetStorage **ppPropSet);


void __RPC_STUB IShellImageData_GetProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_Rotate_Proxy( 
    IShellImageData * This,
    /* [in] */ DWORD dwAngle);


void __RPC_STUB IShellImageData_Rotate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_Scale_Proxy( 
    IShellImageData * This,
    /* [in] */ ULONG cx,
    /* [in] */ ULONG cy,
    /* [in] */ InterpolationMode hints);


void __RPC_STUB IShellImageData_Scale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_DiscardEdit_Proxy( 
    IShellImageData * This);


void __RPC_STUB IShellImageData_DiscardEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_SetEncoderParams_Proxy( 
    IShellImageData * This,
    /* [in] */ IPropertyBag *pbagEnc);


void __RPC_STUB IShellImageData_SetEncoderParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_DisplayName_Proxy( 
    IShellImageData * This,
    /* [out][in] */ LPWSTR wszName,
    /* [in] */ UINT cch);


void __RPC_STUB IShellImageData_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetResolution_Proxy( 
    IShellImageData * This,
    /* [out] */ ULONG *puResolutionX,
    /* [out] */ ULONG *puResolutionY);


void __RPC_STUB IShellImageData_GetResolution_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_GetEncoderParams_Proxy( 
    IShellImageData * This,
    /* [in] */ GUID *pguidFmt,
    /* [out] */ EncoderParameters **ppEncParams);


void __RPC_STUB IShellImageData_GetEncoderParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_RegisterAbort_Proxy( 
    IShellImageData * This,
    /* [in] */ IShellImageDataAbort *pAbort,
    /* [optional][out] */ IShellImageDataAbort **ppAbortPrev);


void __RPC_STUB IShellImageData_RegisterAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_CloneFrame_Proxy( 
    IShellImageData * This,
    /* [out] */ Image **ppImg);


void __RPC_STUB IShellImageData_CloneFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellImageData_ReplaceFrame_Proxy( 
    IShellImageData * This,
    /* [in] */ Image *pImg);


void __RPC_STUB IShellImageData_ReplaceFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellImageData_INTERFACE_DEFINED__ */


#ifndef __IShellImageDataAbort_INTERFACE_DEFINED__
#define __IShellImageDataAbort_INTERFACE_DEFINED__

/* interface IShellImageDataAbort */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IShellImageDataAbort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53fb8e58-50c0-4003-b4aa-0c8df28e7f3a")
    IShellImageDataAbort : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryAbort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellImageDataAbortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellImageDataAbort * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellImageDataAbort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellImageDataAbort * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAbort )( 
            IShellImageDataAbort * This);
        
        END_INTERFACE
    } IShellImageDataAbortVtbl;

    interface IShellImageDataAbort
    {
        CONST_VTBL struct IShellImageDataAbortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellImageDataAbort_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellImageDataAbort_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellImageDataAbort_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellImageDataAbort_QueryAbort(This)	\
    (This)->lpVtbl -> QueryAbort(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellImageDataAbort_QueryAbort_Proxy( 
    IShellImageDataAbort * This);


void __RPC_STUB IShellImageDataAbort_QueryAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellImageDataAbort_INTERFACE_DEFINED__ */



#ifndef __ShellImageData_LIBRARY_DEFINED__
#define __ShellImageData_LIBRARY_DEFINED__

/* library ShellImageData */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_ShellImageData;

EXTERN_C const CLSID CLSID_ShellImageDataFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("66e4e4fb-f385-4dd0-8d74-a2efd1bc6178")
ShellImageDataFactory;
#endif

EXTERN_C const CLSID CLSID_AutoplayForSlideShow;

#ifdef __cplusplus

class DECLSPEC_UUID("00E7B358-F65B-4dcf-83DF-CD026B94BFD4")
AutoplayForSlideShow;
#endif
#endif /* __ShellImageData_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HDC_UserSize(     unsigned long *, unsigned long            , HDC * ); 
unsigned char * __RPC_USER  HDC_UserMarshal(  unsigned long *, unsigned char *, HDC * ); 
unsigned char * __RPC_USER  HDC_UserUnmarshal(unsigned long *, unsigned char *, HDC * ); 
void                      __RPC_USER  HDC_UserFree(     unsigned long *, HDC * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\shlguidp.h ===
#ifndef _SHLGUIDP_H_
#define _SHLGUIDP_H_

#ifndef _WIN32_IE
#define _WIN32_IE 0x0501
#else
#if (_WIN32_IE < 0x0400) && defined(_WIN32_WINNT) && (_WIN32_WINNT >= 0x0500)
#error _WIN32_IE setting conflicts with _WIN32_WINNT setting
#endif
#endif

#ifndef DEFINE_SHLGUID
#define DEFINE_SHLGUID(name, l, w1, w2) DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)
#endif
#if (_WIN32_IE >= 0x0400)
#endif

#if (_WIN32_IE >= 0x0400)
// {27DC26B1-41B3-11D1-B850-006008059382}
DEFINE_GUID(CLSID_CMultiMonConfig,           0x27DC26B1L, 0x41B3, 0x11D1, 0xB8, 0x50, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);
// {C7264BF0-EDB6-11d1-8546-006008059368}
DEFINE_GUID(IID_IPersistFreeThreadedObject,  0xc7264bf0, 0xedb6, 0x11d1, 0x85, 0x46, 0x0, 0x60, 0x8, 0x5, 0x93, 0x68);
// {be1af9f0-b231-11d2-963e-00c04f79adf0}
DEFINE_GUID(IID_IDropTargetWithDADSupport, 0xb0061660, 0xb231, 0x11d2, 0x96, 0x3e, 0x00, 0xc0, 0x4f, 0x79, 0xad, 0xf0);

#if (_WIN32_IE >= 0x0500)
#endif


#if (_WIN32_IE >= 0x0500)
// {7BB0B520-B1A7-11d2-BB23-00C04F79ABCD}
DEFINE_GUID(IID_IThumbnailView,              0x7bb0b520, 0xb1a7, 0x11d2, 0xbb, 0x23, 0x0, 0xc0, 0x4f, 0x79, 0xab, 0xcd);

#endif

// {27DC26B0-41B3-11D1-B850-006008059382}
DEFINE_GUID(IID_IMultiMonConfig, 0x27DC26B0L, 0x41B3, 0x11D1, 0xB8, 0x50, 0x00, 0x60, 0x08, 0x05, 0x93, 0x82);

#endif // _WIN32_IE >= 0x0400
#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(IID_IShellDetails2,         0xb1223e01, 0xb1db, 0x11d0, 0x82, 0xcc, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38);

#define CGID_DeskBar  IID_IDeskBar
#define CGID_DeskBarClient IID_IDeskBarClient

// These can probably move back to shell\inc\shellp.h...

// {2C6DE24C-9C39-4e75-ABD0-482C0CC07CED}
DEFINE_GUID(SID_ShellTaskScheduler,     0x2c6de24c, 0x9c39, 0x4e75, 0xab, 0xd0, 0x48, 0x2c, 0xc, 0xc0, 0x7c, 0xed);

DEFINE_GUID(CGID_DefViewTask,           0x1168BEAFL, 0x3506, 0x4468, 0x81, 0xCD, 0x85, 0x2A, 0xCC, 0xAD, 0x35, 0xEB);
#define CMDID_TASK_RENAME 1
#define CMDID_TASK_COPY   2
#define CMDID_TASK_DELETE 3

DEFINE_GUID(CLSID_PreviewOC,0xA74E7F04L,0xC3D2,0x11CF,0x85,0x78,0x00,0x80,0x5F,0xE4,0x80,0x9B);

#define CLSID_ShellMenu CLSID_MenuBand

#define CGID_ShellFolderBand    IID_IShellFolderBand

#if (_WIN32_IE >= 0x0600)
#endif

#if (_WIN32_IE >= 0x0500)
// 37A378C0-F82D-11CE-AE65-08002B2E1262
DEFINE_GUID(IID_IShellFolderView, 0x37A378C0L, 0xF82D, 0x11CE, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 3D8ECEA0-0242-11CF-AE65-08002B2E1262
DEFINE_GUID(IID_IEnumSFVViews, 0x3D8ECEA0L, 0x0242, 0x11CF, 0xAE, 0x65, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// D5E37E20-0257-11CF-AE65-08002B2E1262
DEFINE_GUID(IID_IDefViewExtInit, 0x8210bac0, 0xc6d2, 0x11cf, 0x89, 0xaa, 0x0, 0xa0, 0xc9, 0x5, 0x41, 0x29);
// {2CEB7CB2-E64C-11d2-9652-00C04FC30871}
DEFINE_GUID(IID_IDefViewExtInit2, 0x2ceb7cb2, 0xe64c, 0x11d2, 0x96, 0x52, 0x0, 0xc0, 0x4f, 0xc3, 0x8, 0x71);


// 710EB7A1-45ED-11D0-924A-0020AFC7AC4D
DEFINE_GUID(CGID_DefViewFrame, 0x710EB7A1L, 0x45ED, 0x11D0, 0x92, 0x4A, 0x00, 0x20, 0xAF, 0xC7, 0xAC, 0x4D);

#endif // _WIN32_IE >= 0x0500

//
//  When the browser is navigating to a document, we call IBC::SetObjectParam
// with "{d4db6850-5385-11d0-89e9-00a0c90a90ac}" so that the DocObject can get
// to the client site while processing IPersistMoniker::Load.
//
#define WSZGUID_OPID_DocObjClientSite L"{d4db6850-5385-11d0-89e9-00a0c90a90ac}"
DEFINE_GUID(OPID_DobObjClientSite,0xd4db6850L, 0x5385, 0x11d0, 0x89, 0xe9, 0x00, 0xa0, 0xc9, 0x0a, 0x90, 0xac);
#endif // _WIN32_IE >= 0x0400


#if (_WIN32_IE >= 0x0400)
DEFINE_GUID(VID_FolderState, 0xbe098140, 0xa513, 0x11d0, 0xa3, 0xa4, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);
#endif // _WIN32_IE >= 0x0400

// To keep people from breaking, let the old misnamed dudes work
#define IID_IShellExplorer        IID_IWebBrowser
#define DIID_DShellExplorerEvents DIID_DWebBrowserEvents
#define CLSID_ShellExplorer       CLSID_WebBrowser
#define IID_DIExplorer            IID_IWebBrowserApp
#define DIID_DExplorerEvents      DIID_DInternetExplorer
#if (_WIN32_IE >= 0x0400)
#define DIID_DInternetExplorerEvents DIID_DWebBrowserEvents
#define DInternetExplorerEvents DWebBrowserEvents
#define IID_IInternetExplorer IID_IWebBrowserApp

#endif // _WIN32_IE >= 0x0400

#if (_WIN32_IE >= 0x0400)

// 266F5E60-80E6-11CF-A12B-00AA004AE837
DEFINE_GUID(CLSID_CShellTargetFrame, 0x266F5E60L, 0x80E6, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);


// CShellList implementation
//
// {FC2A24F0-5876-11d0-97D8-00C04FD91972}
DEFINE_GUID(CLSID_CShellList, 0xfc2a24f0, 0x5876, 0x11d0, 0x97, 0xd8, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {FE5C88F4-587F-11d0-97D8-00C04FD91972}
DEFINE_GUID(IID_IShellList, 0xfe5c88f4, 0x587f, 0x11d0, 0x97, 0xd8, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);

// {FE5C88F5-587F-11d0-97D8-00C04FD91972}
DEFINE_GUID(IID_IShellListSink, 0xfe5c88f5, 0x587f, 0x11d0, 0x97, 0xd8, 0x0, 0xc0, 0x4f, 0xd9, 0x19, 0x72);


#endif

#if (_WIN32_IE >= 0x0300)
// {05f6fe1a-ecef-11d0-aae7-00c04fc9b304}
DEFINE_GUID( CLSID_IntDitherer, 0x05f6fe1a, 0xecef, 0x11d0, 0xaa, 0xe7, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x04 );

// {06670ca0-ecef-11d0-aae7-00c04fc9b304}
DEFINE_GUID( IID_IIntDitherer, 0x06670ca0, 0xecef, 0x11d0, 0xaa, 0xe7, 0x0, 0xc0, 0x4f, 0xc9, 0xb3, 0x04 );

#endif // _WIN32_IE >= 0x0300

#if (_WIN32_IE >= 0x0400)
// {f39a0dc0-9cc8-11d0-a599-00c04fd64433}
DEFINE_GUID(CLSID_CDFView, 0xf39a0dc0L, 0x9cc8, 0x11d0, 0xa5, 0x99, 0x00, 0xc0, 0x4f, 0xd6, 0x44, 0x33);
// { 3037a71d-d6fe-499e-8d60-6b4b132e8e9d}
DEFINE_GUID(CLSID_ProgidQueryAssociations, 0x3037a71d, 0xd6fe, 0x499e, 0x8d, 0x60, 0x6b, 0x4b, 0x13, 0x2e, 0x8e, 0x9d);
// { 3037a71e-d6fe-499e-8d60-6b4b132e8e9d}
DEFINE_GUID(CLSID_CustomQueryAssociations, 0x3037a71e, 0xd6fe, 0x499e, 0x8d, 0x60, 0x6b, 0x4b, 0x13, 0x2e, 0x8e, 0x9d);
#endif  // _WIN32_IE >= 0x0400
#if (_WIN32_IE >= 0x0500)
// Define the CLSID for local and net users prop pages
// {D707877E-4D9C-11d2-8784-F6E920524153}
DEFINE_GUID(CLSID_UserPropertyPages, 
0xd707877e, 0x4d9c, 0x11d2, 0x87, 0x84, 0xf6, 0xe9, 0x20, 0x52, 0x41, 0x53);

// IOleCommandTarget arugments for the Network Connections Folder.
// {EAF70CE4-B521-11d1-B550-00C04FD918D0}
DEFINE_GUID(CGID_ConnectionsFolder, 
    0xeaf70ce4, 0xb521, 0x11d1, 0xb5, 0x50, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);


// {FEF10DDD-355E-4e06-9381-9B24D7F7CC88}
DEFINE_GUID(CLSID_TripleD, 0xfef10DDD, 0x355e, 0x4e06, 0x93, 0x81, 0x9b, 0x24, 0xd7, 0xf7, 0xcc, 0x88);

// {A470F8CF-A1E8-4f65-8335-227475AA5C46}
DEFINE_GUID(CLSID_EncryptionContextMenuHandler, 0xa470f8cf, 0xa1e8, 0x4f65, 0x83, 0x35, 0x22, 0x74, 0x75, 0xAA, 0x5C, 0x46);

// {CA359AC1-7D7A-404d-8F02-5C90C6131884}
DEFINE_GUID(SID_WebViewObject, 0xca359ac1, 0x7d7a, 0x404d, 0x8f, 0x2, 0x5c, 0x90, 0xc6, 0x13, 0x18, 0x84);


//  BHIDs for IShellItemArray::BindToHandler()
// {B8C0BD9F-ED24-455c-83E6-D5390C4FE8C4}
DEFINE_GUID(BHID_DataObject, 0xb8c0bd9f, 0xed24, 0x455c, 0x83, 0xe6, 0xd5, 0x39, 0xc, 0x4f, 0xe8, 0xc4);

#endif // _WIN32_IE >= 0x0500
#if _WIN32_IE >= 0x0501
// {C3742917-66C9-454c-81C5-5CFCF5D23C9E}
DEFINE_GUID(CLSID_NavBand, 0xc3742917, 0x66c9, 0x454c, 0x81, 0xc5, 0x5c, 0xfc, 0xf5, 0xd2, 0x3c, 0x9e);
#endif
// PPID (Property Page IDs)
DEFINE_GUID(PPID_Theme, 0xc6b37009, 0xc2b0, 0x4d1e, 0xab, 0xcf, 0xe2, 0xfa, 0x57, 0xe, 0x8e, 0x31);   // {C6B37009-C2B0-4d1e-ABCF-E2FA570E8E31}
DEFINE_GUID(PPID_Background, 0x69cebe01, 0xd4d3, 0x4a18, 0x8d, 0x44, 0xe, 0x9b, 0xed, 0x64, 0x62, 0x31);   // {69CEBE01-D4D3-4a18-8D44-0E9BED646231}
DEFINE_GUID(PPID_ScreenSaver, 0x2323123d, 0xa64, 0x4028, 0xab, 0x5b, 0xae, 0x49, 0xc7, 0xae, 0xa4, 0x5f);   // {2323123D-0A64-4028-AB5B-AE49C7AEA45F}
DEFINE_GUID(PPID_BaseAppearance, 0x92356fb8, 0x4808, 0x4df9, 0xb5, 0x6f, 0x9d, 0x56, 0x40, 0x31, 0x6c, 0x7c);   // {92356FB8-4808-4df9-B56F-9D5640316C7C}
DEFINE_GUID(PPID_Settings, 0x27f7c873, 0x7cdc, 0x4a2f, 0xbd, 0xfa, 0x0, 0xdc, 0xbc, 0x77, 0xc6, 0xfc);   // {27F7C873-7CDC-4a2f-BDFA-00DCBC77C6FC}

DEFINE_GUID(PPID_ThemeSettings, 0x9bc83d06, 0x16bd, 0x4f17, 0xb5, 0x4a, 0x72, 0xdc, 0x0, 0x17, 0x1d, 0x5a); // {9BC83D06-16BD-4f17-B54A-72DC00171D5A}
DEFINE_GUID(PPID_AdvAppearance, 0x476974b4, 0x8061, 0x4ec3, 0x8e, 0x38, 0x3b, 0xad, 0x4a, 0xf7, 0xd7, 0xf5);// {476974B4-8061-4ec3-8E38-3BAD4AF7D7F5}
DEFINE_GUID(PPID_Web, 0xa8ebe8f2, 0x3e4b, 0x4153, 0x8e, 0xb9, 0xbd, 0xa0, 0x5b, 0xbd, 0xe2, 0xed);          // {A8EBE8F2-3E4B-4153-8EB9-BDA05BBDE2ED}
DEFINE_GUID(PPID_Effects, 0xf932ce42, 0xbaa1, 0x4c7c, 0x9c, 0x27, 0x6b, 0x98, 0x4, 0x57, 0x74, 0x31);       // {F932CE42-BAA1-4c7c-9C27-6B9804577431}


// IUICommand IDs
DEFINE_GUID(UICID_Copy, 0xF0FF2AE6L, 0x3A15, 0x48C3, 0x98, 0xF2, 0xFE, 0xBE, 0x2B, 0xA7, 0x80, 0xD8);
DEFINE_GUID(UICID_Move, 0xCC11C262L, 0x70E9, 0x4455, 0x84, 0x4E, 0xB2, 0x8A, 0xCF, 0x6D, 0x51, 0x3B);
DEFINE_GUID(UICID_Rename, 0x3AAD0259L, 0xBE8D, 0x41A0, 0x89, 0x7D, 0x03, 0x80, 0x79, 0x68, 0xBA, 0xDF);
DEFINE_GUID(UICID_Delete, 0x9ED8204CL, 0xC3DE, 0x4D66, 0x98, 0x51, 0x42, 0x94, 0x3F, 0x9F, 0xCC, 0x77);
DEFINE_GUID(UICID_NewFolder, 0xE44616ADL, 0x6DF1, 0x4B94, 0x85, 0xA4, 0xE4, 0x65, 0xAE, 0x8A, 0x19, 0xDB);
DEFINE_GUID(UICID_Publish, 0x1B060A62L, 0x2EB5, 0x481B, 0x86, 0xAB, 0xCF, 0x7B, 0xC9, 0x48, 0x4F, 0xBF);
DEFINE_GUID(UICID_Share, 0xE39543A3L, 0x079B, 0x4BFB, 0xA4, 0x98, 0x47, 0x77, 0x98, 0x41, 0x55, 0xCA);
DEFINE_GUID(UICID_Email, 0x6D3EBC98L, 0x4515, 0x4E78, 0xB9, 0x47, 0xEE, 0x71, 0x3A, 0x78, 0x8C, 0xF2);
DEFINE_GUID(UICID_Print, 0x94DD8801L, 0xBAE1, 0x49B3, 0x96, 0x64, 0x29, 0xD9, 0xAB, 0xC8, 0x29, 0x16);
DEFINE_GUID(UICID_PlayMusic, 0x220898A1L, 0xE3F3, 0x46B4, 0x96, 0xEA, 0xB0, 0x85, 0x5D, 0xC9, 0x68, 0xB6);
DEFINE_GUID(UICID_ShopForMusicOnline, 0x99A1BEFEL, 0x260E, 0x4128, 0xB2, 0x2B, 0x51, 0x88, 0x96, 0xC6, 0x25, 0x87);
DEFINE_GUID(UICID_ShopForPicturesOnline, 0x20023689, 0x243a, 0x44a6, 0xB5, 0x50, 0x0d, 0x0b, 0x42, 0xb0, 0xe4, 0x46);
// 20023689-243a-44a6-b550-0d0b42b0e446
DEFINE_GUID(UICID_GetFromCamera, 0x76764FD5L, 0x95EB, 0x4B81, 0x98, 0x53, 0x26, 0x20, 0x6F, 0xFF, 0x04, 0x62);
DEFINE_GUID(UICID_SlideShow, 0x73BCE053L, 0x3BBC, 0x4AD7, 0x9F, 0xE7, 0x7A, 0x7C, 0x21, 0x2C, 0x98, 0xE6);
DEFINE_GUID(UICID_SetAsWallpaper, 0x2E1ABBFFL, 0xDBE7, 0x4F76, 0x9F, 0xB4, 0x33, 0x1D, 0xFA, 0x8D, 0xA2, 0x85);
DEFINE_GUID(UICID_ViewContents, 0x37b8eae3, 0x8bee, 0x4860, 0xaa, 0x4f, 0x10, 0xa8, 0xba, 0x63, 0x47, 0xc8);
DEFINE_GUID(UICID_HideContents, 0x9fbcf4c9, 0x3679, 0x4f9d, 0xa7, 0x3b, 0x6b, 0xaa, 0x3e, 0xd5, 0x54, 0xb0);
DEFINE_GUID(UICID_AddRemovePrograms, 0xa2e6d9cc, 0xf866, 0x40b6, 0xa4, 0xb2, 0xee, 0x9e, 0x10, 0x4, 0xbd, 0xfc);
DEFINE_GUID(UICID_SearchFiles, 0x231ebfaa, 0x50ea, 0x44f8, 0x86, 0x9, 0x4e, 0xd0, 0x3d, 0x49, 0xc2, 0x77);


// printscan components don't have a private GUID lib, so piggy back on the shell for now
// CLSID_PrintPhotosWizard      {4c649c49-c48f-4222-9a0d-cbbf4231221d}
DEFINE_GUID(CLSID_PrintPhotosWizard, 0x4c649c49, 0xc48f, 0x4222, 0x9a, 0x0d, 0xcb, 0xbf, 0x42, 0x31, 0x22, 0x1d);

//IID_IPrintPhotosWizardSetInfo  {ccbc306b-e6d2-4efd-9b32-8c4c8f643775}
DEFINE_GUID (IID_IPrintPhotosWizardSetInfo, 0xccbc306b, 0xe6d2, 0x4efd, 0x9b, 0x32, 0x8c, 0x4c, 0x8f, 0x64, 0x37, 0x75);
// SID_SMenuPopup == IID_IMenuPopup
// Storage Transfer Confirmations

//			Confirmation                                                                       Sample description:
DEFINE_GUID(STCONFIRM_RENAME_SYSTEM_STREAM          , 0x00000001, 0,0, 0,0,0,0,0,0,0,0);    // Src is part of the system, are you sure?
DEFINE_GUID(STCONFIRM_RENAME_SYSTEM_STORAGE         , 0x00000002, 0,0, 0,0,0,0,0,0,0,0);    // Src is part of the system, are you sure?
DEFINE_GUID(STCONFIRM_MOVE_SYSTEM_STREAM            , 0x00000003, 0,0, 0,0,0,0,0,0,0,0);    // Src is part of the system, are you sure?
DEFINE_GUID(STCONFIRM_MOVE_SYSTEM_STORAGE           , 0x00000004, 0,0, 0,0,0,0,0,0,0,0);    // Src is part of the system, are you sure?

DEFINE_GUID(STCONFIRM_DELETE_STREAM                 , 0x00000005, 0,0, 0,0,0,0,0,0,0,0);    // Move Src to recycle bin, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_STORAGE                , 0x00000006, 0,0, 0,0,0,0,0,0,0,0);    // Move Src to recycle bin, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_HIDDEN_STREAM          , 0x00000007, 0,0, 0,0,0,0,0,0,0,0);    // Src is hidden, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_HIDDEN_STORAGE         , 0x00000008, 0,0, 0,0,0,0,0,0,0,0);    // Src is hidden, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_READONLY_STREAM        , 0x00000009, 0,0, 0,0,0,0,0,0,0,0);    // Src is read-only, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_READONLY_STORAGE       , 0x0000000a, 0,0, 0,0,0,0,0,0,0,0);    // Src is read-only, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_SYSTEM_STREAM          , 0x0000000b, 0,0, 0,0,0,0,0,0,0,0);    // Src is part of the system, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_SYSTEM_STORAGE         , 0x0000000c, 0,0, 0,0,0,0,0,0,0,0);    // Src is part of the system, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_SYSTEMHIDDEN_STREAM    , 0x0000000d, 0,0, 0,0,0,0,0,0,0,0);    // Src is part of the system, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_SYSTEMHIDDEN_STORAGE   , 0x0000000e, 0,0, 0,0,0,0,0,0,0,0);    // Src is part of the system, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_PROGRAM_STREAM         , 0x0000000f, 0,0, 0,0,0,0,0,0,0,0);    // Src is a program, deleting a program may leave behind unused files and data, use ARP to uninstall programs.  Are you sure?

DEFINE_GUID(STCONFIRM_REPLACE_STREAM                , 0x00000010, 0,0, 0,0,0,0,0,0,0,0);    // Move Src to recycle bin, are you sure?
DEFINE_GUID(STCONFIRM_REPLACE_STORAGE               , 0x00000011, 0,0, 0,0,0,0,0,0,0,0);    // Move Src to recycle bin, are you sure?
DEFINE_GUID(STCONFIRM_REPLACE_HIDDEN_STREAM         , 0x00000012, 0,0, 0,0,0,0,0,0,0,0);    // Src is hidden, are you sure?
DEFINE_GUID(STCONFIRM_REPLACE_HIDDEN_STORAGE        , 0x00000013, 0,0, 0,0,0,0,0,0,0,0);    // Src is hidden, are you sure?
DEFINE_GUID(STCONFIRM_REPLACE_READONLY_STREAM       , 0x00000014, 0,0, 0,0,0,0,0,0,0,0);    // Src is read-only, are you sure?
DEFINE_GUID(STCONFIRM_REPLACE_READONLY_STORAGE      , 0x00000015, 0,0, 0,0,0,0,0,0,0,0);    // Src is read-only, are you sure?
DEFINE_GUID(STCONFIRM_REPLACE_SYSTEM_STREAM         , 0x00000016, 0,0, 0,0,0,0,0,0,0,0);    // Src is part of the system, are you sure?
DEFINE_GUID(STCONFIRM_REPLACE_SYSTEM_STORAGE        , 0x00000017, 0,0, 0,0,0,0,0,0,0,0);    // Src is part of the system, are you sure?
DEFINE_GUID(STCONFIRM_REPLACE_SYSTEMHIDDEN_STREAM   , 0x00000018, 0,0, 0,0,0,0,0,0,0,0);    // Src is part of the system, are you sure?
DEFINE_GUID(STCONFIRM_REPLACE_SYSTEMHIDDEN_STORAGE  , 0x00000019, 0,0, 0,0,0,0,0,0,0,0);    // Src is part of the system, are you sure?
DEFINE_GUID(STCONFIRM_REPLACE_PROGRAM_STREAM        , 0x0000001a, 0,0, 0,0,0,0,0,0,0,0);    // Src is a program, deleting a program may leave behind unused files and data, use ARP to uninstall programs.  Are you sure?

DEFINE_GUID(STCONFIRM_DELETE_WONT_RECYCLE_STREAM    , 0x0000001b, 0,0, 0,0,0,0,0,0,0,0);    // Src will be perminately deleted, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_WONT_RECYCLE_STORAGE   , 0x0000001c, 0,0, 0,0,0,0,0,0,0,0);    // Src will be perminately deleted, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_TOOLARGE_STREAM        , 0x0000001d, 0,0, 0,0,0,0,0,0,0,0);    // Src is too large to recycle and will be perminately deleted, are you sure?
DEFINE_GUID(STCONFIRM_DELETE_TOOLARGE_STORAGE       , 0x0000001e, 0,0, 0,0,0,0,0,0,0,0);    // Src is too large to recycle and will be perminately deleted, are you sure?

DEFINE_GUID(STCONFIRM_COMPRESSION_LOSS_STREAM       , 0x0000001f, 0,0, 0,0,0,0,0,0,0,0);    // Src is compressed, continuing will uncommpress, are you sure?
DEFINE_GUID(STCONFIRM_COMPRESSION_LOSS_STORAGE      , 0x00000020, 0,0, 0,0,0,0,0,0,0,0);    // Src is compressed, continuing will uncommpress, are you sure?
DEFINE_GUID(STCONFIRM_ENCRYPTION_LOSS_STREAM        , 0x00000021, 0,0, 0,0,0,0,0,0,0,0);    // Src is encrypted, contining will un-encrypt, are you sure?
DEFINE_GUID(STCONFIRM_ENCRYPTION_LOSS_STORAGE       , 0x00000022, 0,0, 0,0,0,0,0,0,0,0);    // Src is encrypted, contining will un-encrypt, are you sure?
DEFINE_GUID(STCONFIRM_METADATA_LOSS_STREAM          , 0x00000023, 0,0, 0,0,0,0,0,0,0,0);    // Src contains secondary properties that are not supported by the destination, are you sure?
DEFINE_GUID(STCONFIRM_METADATA_LOSS_STORAGE         , 0x00000024, 0,0, 0,0,0,0,0,0,0,0);    // Src contains secondary properties that are not supported by the destination, are you sure?
DEFINE_GUID(STCONFIRM_SPARSEDATA_LOSS_STREAM        , 0x00000025, 0,0, 0,0,0,0,0,0,0,0);    // Src is a sparse file and would need to be expanded, are you sure?
DEFINE_GUID(STCONFIRM_ACCESSCONTROL_LOSS_STREAM     , 0x00000026, 0,0, 0,0,0,0,0,0,0,0);    // Src contains ACLs that are not supported by the destination, are you sure?
DEFINE_GUID(STCONFIRM_ACCESSCONTROL_LOSS_STORAGE    , 0x00000027, 0,0, 0,0,0,0,0,0,0,0);    // Src contains ACLs that are not supported by the destination, are you sure?
DEFINE_GUID(STCONFIRM_LFNTOFAT_STREAM               , 0x00000028, 0,0, 0,0,0,0,0,0,0,0);    // Src supports long filenames but destination is a FAT filesystem, names will be truncated to 8.3 format, are you sure?
DEFINE_GUID(STCONFIRM_LFNTOFAT_STORAGE              , 0x00000029, 0,0, 0,0,0,0,0,0,0,0);    // Src supports long directorynames but destination is a FAT directorysystem, names will be truncated to 8.3 format, are you sure?
DEFINE_GUID(STCONFIRM_STREAM_LOSS_STREAM            , 0x0000002a, 0,0, 0,0,0,0,0,0,0,0);    // Src contains secondary streams that are not supported by the destination, are you sure?
DEFINE_GUID(STCONFIRM_STREAM_LOSS_STORAGE           , 0x0000002b, 0,0, 0,0,0,0,0,0,0,0);    // Src contains secondary streams that are not supported by the destination, are you sure?

DEFINE_GUID(STCONFIRM_ACCESS_DENIED                 , 0x0000002c, 0,0, 0,0,0,0,0,0,0,0);    //
#endif // _SHLGUIDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\shlwapip.h ===
/*****************************************************************************\
*                                                                             *
* shlwapi.h - Interface for the Windows light-weight utility APIs             *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHLWAPIP
#define _INC_SHLWAPIP
#ifndef NOSHLWAPI

#include <objbase.h>
#include <shtypes.h>

#ifdef _WIN32
#include <pshpack8.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NO_SHLWAPI_STRFCNS    String functions
//    NO_SHLWAPI_PATH       Path functions
//    NO_SHLWAPI_REG        Registry functions
//    NO_SHLWAPI_UALSTR     Unaligned string functions
//    NO_SHLWAPI_STREAM     Stream functions
//    NO_SHLWAPI_HTTP       HTTP helper routines
//    NO_SHLWAPI_INTERNAL   Other random internal things
//    NO_SHLWAPI_GDI        GDI helper functions
//    NO_SHLWAPI_UNITHUNK   Unicode wrapper functions
//    NO_SHLWAPI_TPS        Thread Pool Services
//    NO_SHLWAPI_MLUI       Multi Language UI functions

#ifndef NO_SHLWAPI_STRFCNS
//
//=============== String Routines ===================================
//

LWSTDAPI_(LPSTR)    StrCpyNXA(LPSTR psz1, LPCSTR psz2, int cchMax);
LWSTDAPI_(LPWSTR)   StrCpyNXW(LPWSTR psz1, LPCWSTR psz2, int cchMax);

#define ORD_SHLOADREGUISTRINGA  438
#define ORD_SHLOADREGUISTRINGW  439
LWSTDAPI SHLoadRegUIStringA(HKEY hkey, LPCSTR pszValue, LPSTR pszOutBuf, UINT cchOutBuf);
LWSTDAPI SHLoadRegUIStringW(HKEY hkey, LPCWSTR pszValue, LPWSTR pszOutBuf, UINT cchOutBuf);
#ifdef UNICODE
#define SHLoadRegUIString  SHLoadRegUIStringW
#else
#define SHLoadRegUIString  SHLoadRegUIStringA
#endif // !UNICODE

LWSTDAPI_(BOOL) IsCharCntrlW(WCHAR wch);
LWSTDAPI_(BOOL) IsCharDigitW(WCHAR wch);
LWSTDAPI_(BOOL) IsCharXDigitW(WCHAR wch);
LWSTDAPI_(BOOL) IsCharSpaceW(WCHAR wch);
LWSTDAPI_(BOOL) IsCharBlankW(WCHAR wch);
LWSTDAPI_(BOOL) IsCharPunctW(WCHAR wch);
LWSTDAPI_(BOOL) GetStringType3ExW( LPCWSTR, int, LPWORD );

// StrCmp*C* - Compare strings using C runtime collation rules.
// These functions are faster than the StrCmp family of functions
// above and can be used when the character set of the strings is
// known to be limited to seven ASCII character set.

LWSTDAPI_(int)  StrCmpNCA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)  StrCmpNCW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)  StrCmpNICA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)  StrCmpNICW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)  StrCmpCA(LPCSTR lpStr1, LPCSTR lpStr2);
LWSTDAPI_(int)  StrCmpCW(LPCWSTR lpStr1, LPCWSTR lpStr2);
LWSTDAPI_(int)  StrCmpICA(LPCSTR lpStr1, LPCSTR lpStr2);
LWSTDAPI_(int)  StrCmpICW(LPCWSTR lpStr1, LPCWSTR lpStr2);

// This is a true-Unicode version of CompareString.  It only supports
// STRING_SORT, however.  After better test coverage, it shall replace
// the CompareString Unicode wrapper itself.  In the mean time, we only
// call this from the find dialog/OM method of Trident.

LWSTDAPI_(int)  CompareStringAltW( LCID lcid, DWORD dwFlags, LPCWSTR lpchA, int cchA, LPCWSTR lpchB, int cchB );

//
// Macros for IsCharAlpha, IsCharAlphaNumeric, IsCharLower, IsCharUpper
// are in winuser.h
//
//

#define IsCharCntrl             IsCharCntrlW
#define IsCharDigit             IsCharDigitW
#define IsCharXDigit            IsCharXDigitW
#define IsCharSpace             IsCharSpaceW
#define IsCharBlank             IsCharBlankW
#define IsCharPunct             IsCharPunctW
#define GetStringType3Ex        GetStringType3ExW


#ifdef UNICODE

#define StrCmpNC                StrCmpNCW
#define StrCmpNIC               StrCmpNICW
#define StrCmpC                 StrCmpCW
#define StrCmpIC                StrCmpICW
#define StrCpyNX                StrCpyNXW

#else

#define StrCmpNC                StrCmpNCA
#define StrCmpNIC               StrCmpNICA
#define StrCmpC                 StrCmpCA
#define StrCmpIC                StrCmpICA
#define StrCpyNX                StrCpyNXA

#endif


#endif //  NO_SHLWAPI_STRFCNS


#ifndef NO_SHLWAPI_PATH

//
//=============== Path Routines ===================================
//


#if (_WIN32_IE >= 0x0501)

LWSTDAPI_(BOOL)     PathUnExpandEnvStringsForUserA(HANDLE hToken, LPCSTR pszPath, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(BOOL)     PathUnExpandEnvStringsForUserW(HANDLE hToken, LPCWSTR pszPath, LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define PathUnExpandEnvStringsForUser  PathUnExpandEnvStringsForUserW
#else
#define PathUnExpandEnvStringsForUser  PathUnExpandEnvStringsForUserA
#endif // !UNICODE
LWSTDAPI_(void) PrettifyFileDescriptionA(LPTSTR pszDescA, LPCSTR pszCutList);
LWSTDAPI_(void) PrettifyFileDescriptionW(LPTSTR pszDescW, LPCWSTR pszCutList);
#ifdef UNICODE
#define PrettifyFileDescription  PrettifyFileDescriptionW
#else
#define PrettifyFileDescription  PrettifyFileDescriptionA
#endif // !UNICODE

#endif // (_WIN32_IE >= 0x0501)


#if defined(WINNT) && (_WIN32_IE >= 0x0550)
//====== ACL helpers ==================================================

//
// shell struct to identify user/group for each ACE
//
typedef struct _SHELL_USER_SID
{
    SID_IDENTIFIER_AUTHORITY sidAuthority;
    DWORD dwUserGroupID;
    DWORD dwUserID;
} SHELL_USER_SID, *PSHELL_USER_SID;

//
// common SHELL_USER_SID's
//
// NOTE: you need to link to stocklib.lib to resolve these
//
extern const SHELL_USER_SID susCurrentUser;     // the current user 
extern const SHELL_USER_SID susSystem;          // the "SYSTEM" group
extern const SHELL_USER_SID susAdministrators;  // the "Administrators" group
extern const SHELL_USER_SID susPowerUsers;      // the "Power Users" group
extern const SHELL_USER_SID susGuests;          // the "Guests" group
extern const SHELL_USER_SID susEveryone;        // the "Everyone" group

//
// shell struct that is passed to GetShellSecurityDescriptor()
//
typedef struct _SHELL_USER_PERMISSION
{
    SHELL_USER_SID susID;       // identifies the user for whom you want to grant permissions to
    DWORD dwAccessType;         // this is either ACCESS_ALLOWED_ACE_TYPE or  ACCESS_DENIED_ACE_TYPE
    BOOL fInherit;              // the permissions inheritable? (eg a directory or reg key and you want new children to inherit this permission)
    DWORD dwAccessMask;         // access granted (eg FILE_LIST_CONTENTS, KEY_ALL_ACCESS, etc...)
    DWORD dwInheritMask;        // mask used for inheritance, usually (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE)
    DWORD dwInheritAccessMask;  // the inheritable access granted (eg GENERIC_ALL)
} SHELL_USER_PERMISSION, *PSHELL_USER_PERMISSION;


//
// The GetShellSecurityDescriptor API takes an array of PSHELL_USER_PERMISSION's
// and returns a PSECURITY_DESCRIPTOR based on those permission (an ACL is
// contained in the PSECURITY_DESCRIPTOR).
//
// NOTE: The PSECURITY_DESCRIPTOR returned to the caller must be freed with LocalFree()
//       if it is non-null.
//
//
// Parameters:
//      apUserPerm - Array of shell_user_permission structs that defines what type
//                   of access various users are allowed
//
//      cUserPerm  - count of elements in apUserPerm.
//
// Returns:
//      SECURITY_DESCRIPTOR* or NULL if failed.
//
LWSTDAPI_(SECURITY_DESCRIPTOR*) GetShellSecurityDescriptor(PSHELL_USER_PERMISSION* apUserPerm, int cUserPerm);
#endif // defined(WINNT) && (_WIN32_IE >= 0x0550)

LWSTDAPI                UrlFixupW(LPCWSTR pszIn, LPWSTR pszOut, DWORD cchOut);  

// NTRAID:108139 akabir We need to move the components stuff from wininet.h to shlwapi.

typedef WORD SHINTERNET_PORT;
typedef SHINTERNET_PORT * LPSHINTERNET_PORT;

//
// SHINTERNET_SCHEME - enumerated URL scheme type
//

typedef enum {
    SHINTERNET_SCHEME_PARTIAL = -2,
    SHINTERNET_SCHEME_UNKNOWN = -1,
    SHINTERNET_SCHEME_DEFAULT = 0,
    SHINTERNET_SCHEME_FTP,
    SHINTERNET_SCHEME_GOPHER,
    SHINTERNET_SCHEME_HTTP,
    SHINTERNET_SCHEME_HTTPS,
    SHINTERNET_SCHEME_FILE,
    SHINTERNET_SCHEME_NEWS,
    SHINTERNET_SCHEME_MAILTO,
    SHINTERNET_SCHEME_SOCKS,
    SHINTERNET_SCHEME_JAVASCRIPT,
    SHINTERNET_SCHEME_VBSCRIPT,
    SHINTERNET_SCHEME_RES,
    SHINTERNET_SCHEME_FIRST = SHINTERNET_SCHEME_FTP,
    SHINTERNET_SCHEME_LAST = SHINTERNET_SCHEME_RES
} SHINTERNET_SCHEME, * LPSHINTERNET_SCHEME;

//
// SHURL_COMPONENTS - the constituent parts of an URL. Used in InternetCrackUrl()
// and InternetCreateUrl()
//
// For InternetCrackUrl(), if a pointer field and its corresponding length field
// are both 0 then that component is not returned. If the pointer field is NULL
// but the length field is not zero, then both the pointer and length fields are
// returned if both pointer and corresponding length fields are non-zero then
// the pointer field points to a buffer where the component is copied. The
// component may be un-escaped, depending on dwFlags
//
// For InternetCreateUrl(), the pointer fields should be NULL if the component
// is not required. If the corresponding length field is zero then the pointer
// field is the address of a zero-terminated string. If the length field is not
// zero then it is the string length of the corresponding pointer field
//

#pragma warning( disable : 4121 )   // disable alignment warning

typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPSTR   lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    SHINTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPSTR   lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    SHINTERNET_PORT nPort;        // converted port number
    LPSTR   lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPSTR   lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPSTR   lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPSTR   lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} SHURL_COMPONENTSA, * LPSHURL_COMPONENTSA;
typedef struct {
    DWORD   dwStructSize;       // size of this structure. Used in version check
    LPWSTR  lpszScheme;         // pointer to scheme name
    DWORD   dwSchemeLength;     // length of scheme name
    SHINTERNET_SCHEME nScheme;    // enumerated scheme type (if known)
    LPWSTR  lpszHostName;       // pointer to host name
    DWORD   dwHostNameLength;   // length of host name
    SHINTERNET_PORT nPort;        // converted port number
    LPWSTR  lpszUserName;       // pointer to user name
    DWORD   dwUserNameLength;   // length of user name
    LPWSTR  lpszPassword;       // pointer to password
    DWORD   dwPasswordLength;   // length of password
    LPWSTR  lpszUrlPath;        // pointer to URL-path
    DWORD   dwUrlPathLength;    // length of URL-path
    LPWSTR  lpszExtraInfo;      // pointer to extra information (e.g. ?foo or #foo)
    DWORD   dwExtraInfoLength;  // length of extra information
} SHURL_COMPONENTSW, * LPSHURL_COMPONENTSW;
#ifdef UNICODE
typedef SHURL_COMPONENTSW SHURL_COMPONENTS;
typedef LPSHURL_COMPONENTSW LPSHURL_COMPONENTS;
#else
typedef SHURL_COMPONENTSA SHURL_COMPONENTS;
typedef LPSHURL_COMPONENTSA LPSHURL_COMPONENTS;
#endif // UNICODE


BOOL WINAPI             UrlCrackW(LPCWSTR lpszUrl, DWORD dwUrlLength, DWORD dwFlags, LPSHURL_COMPONENTSW lpUrlComponents);

#define UrlFixup                UrlFixupW
// no UrlFixupA
//
// Internal APIs which we're not yet sure whether to make public
//

// Private IHlinkFrame::Navigate flags related to history
// This navigate should not go in the History ShellFolder
#define SHHLNF_WRITENOHISTORY 0x08000000
// This navigate should not automatically select History ShellFolder
#define SHHLNF_NOAUTOSELECT       0x04000000

// The order of these flags is important.  See the source before
// changing these.

#define PFOPEX_NONE        0x00000000
#define PFOPEX_PIF         0x00000001
#define PFOPEX_COM         0x00000002
#define PFOPEX_EXE         0x00000004
#define PFOPEX_BAT         0x00000008
#define PFOPEX_LNK         0x00000010
#define PFOPEX_CMD         0x00000020
#define PFOPEX_OPTIONAL    0x00000040   // Search only if Extension not present
#define PFOPEX_DEFAULT     (PFOPEX_CMD | PFOPEX_COM | PFOPEX_BAT | PFOPEX_PIF | PFOPEX_EXE | PFOPEX_LNK)

LWSTDAPI_(BOOL)     PathFileExistsDefExtA(LPSTR pszPath, UINT uFlags);
LWSTDAPI_(BOOL)     PathFileExistsDefExtW(LPWSTR pszPath, UINT uFlags);
#ifdef UNICODE
#define PathFileExistsDefExt  PathFileExistsDefExtW
#else
#define PathFileExistsDefExt  PathFileExistsDefExtA
#endif // !UNICODE
LWSTDAPI_(BOOL)     PathFindOnPathExA(LPSTR pszPath, LPCSTR * ppszOtherDirs, UINT uFlags);
LWSTDAPI_(BOOL)     PathFindOnPathExW(LPWSTR pszPath, LPCWSTR * ppszOtherDirs, UINT uFlags);
#ifdef UNICODE
#define PathFindOnPathEx  PathFindOnPathExW
#else
#define PathFindOnPathEx  PathFindOnPathExA
#endif // !UNICODE
LWSTDAPI_(LPCSTR) PathSkipLeadingSlashesA(LPCSTR pszURL);
LWSTDAPI_(LPCWSTR) PathSkipLeadingSlashesW(LPCWSTR pszURL);
#ifdef UNICODE
#define PathSkipLeadingSlashes  PathSkipLeadingSlashesW
#else
#define PathSkipLeadingSlashes  PathSkipLeadingSlashesA
#endif // !UNICODE

LWSTDAPI_(UINT)     SHGetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);
LWSTDAPI_(UINT)     SHGetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize);
#ifdef UNICODE
#define SHGetSystemWindowsDirectory  SHGetSystemWindowsDirectoryW
#else
#define SHGetSystemWindowsDirectory  SHGetSystemWindowsDirectoryA
#endif // !UNICODE


#if (_WIN32_IE >= 0x0501)
//
// These are functions that used to be duplicated in shell32, but have
// be consolidated here. They are exported privately until someone decides
// we really want to document them.
//
LWSTDAPI_(BOOL) PathFileExistsAndAttributesA(LPCSTR pszPath, OPTIONAL DWORD* pdwAttributes);
//
// These are functions that used to be duplicated in shell32, but have
// be consolidated here. They are exported privately until someone decides
// we really want to document them.
//
LWSTDAPI_(BOOL) PathFileExistsAndAttributesW(LPCWSTR pszPath, OPTIONAL DWORD* pdwAttributes);
#ifdef UNICODE
#define PathFileExistsAndAttributes  PathFileExistsAndAttributesW
#else
#define PathFileExistsAndAttributes  PathFileExistsAndAttributesA
#endif // !UNICODE
LWSTDAPI_(BOOL) PathFileExistsDefExtAndAttributesA(LPSTR pszPath, UINT uFlags, DWORD *pdwAttribs);
LWSTDAPI_(BOOL) PathFileExistsDefExtAndAttributesW(LPWSTR pszPath, UINT uFlags, DWORD *pdwAttribs);
#ifdef UNICODE
#define PathFileExistsDefExtAndAttributes  PathFileExistsDefExtAndAttributesW
#else
#define PathFileExistsDefExtAndAttributes  PathFileExistsDefExtAndAttributesA
#endif // !UNICODE
LWSTDAPI_(void) FixSlashesAndColonA(LPSTR pszPath);
LWSTDAPI_(void) FixSlashesAndColonW(LPWSTR pszPath);
#ifdef UNICODE
#define FixSlashesAndColon  FixSlashesAndColonW
#else
#define FixSlashesAndColon  FixSlashesAndColonA
#endif // !UNICODE
LWSTDAPI_(LPCSTR) NextPathA(LPCSTR lpPath, LPSTR szPath, int cchPath);
LWSTDAPI_(LPCWSTR) NextPathW(LPCWSTR lpPath, LPWSTR szPath, int cchPath);
#ifdef UNICODE
#define NextPath  NextPathW
#else
#define NextPath  NextPathA
#endif // !UNICODE
LWSTDAPI_(LPSTR) CharUpperNoDBCSA(LPSTR psz);
LWSTDAPI_(LPWSTR) CharUpperNoDBCSW(LPWSTR psz);
#ifdef UNICODE
#define CharUpperNoDBCS  CharUpperNoDBCSW
#else
#define CharUpperNoDBCS  CharUpperNoDBCSA
#endif // !UNICODE
LWSTDAPI_(LPSTR) CharLowerNoDBCSA(LPSTR psz);
LWSTDAPI_(LPWSTR) CharLowerNoDBCSW(LPWSTR psz);
#ifdef UNICODE
#define CharLowerNoDBCS  CharLowerNoDBCSW
#else
#define CharLowerNoDBCS  CharLowerNoDBCSA
#endif // !UNICODE


//
// flags for PathIsValidChar()
//
#define PIVC_ALLOW_QUESTIONMARK     0x00000001  // treat '?' as valid
#define PIVC_ALLOW_STAR             0x00000002  // treat '*' as valid
#define PIVC_ALLOW_DOT              0x00000004  // treat '.' as valid
#define PIVC_ALLOW_SLASH            0x00000008  // treat '\\' as valid
#define PIVC_ALLOW_COLON            0x00000010  // treat ':' as valid
#define PIVC_ALLOW_SEMICOLON        0x00000020  // treat ';' as valid
#define PIVC_ALLOW_COMMA            0x00000040  // treat ',' as valid
#define PIVC_ALLOW_SPACE            0x00000080  // treat ' ' as valid
#define PIVC_ALLOW_NONALPAHABETIC   0x00000100  // treat non-alphabetic exteneded chars as valid
#define PIVC_ALLOW_QUOTE            0x00000200  // treat '"' as valid

//
// standard masks for PathIsValidChar()
//
#define PIVC_SFN_NAME               (PIVC_ALLOW_DOT | PIVC_ALLOW_NONALPAHABETIC)
#define PIVC_SFN_FULLPATH           (PIVC_SFN_NAME | PIVC_ALLOW_COLON | PIVC_ALLOW_SLASH)
#define PIVC_LFN_NAME               (PIVC_ALLOW_DOT | PIVC_ALLOW_NONALPAHABETIC | PIVC_ALLOW_SEMICOLON | PIVC_ALLOW_COMMA | PIVC_ALLOW_SPACE)
#define PIVC_LFN_FULLPATH           (PIVC_LFN_NAME | PIVC_ALLOW_COLON | PIVC_ALLOW_SLASH)
#define PIVC_SFN_FILESPEC           (PIVC_SFN_FULLPATH | PIVC_ALLOW_STAR | PIVC_ALLOW_QUESTIONMARK)
#define PIVC_LFN_FILESPEC           (PIVC_LFN_FULLPATH | PIVC_ALLOW_STAR | PIVC_ALLOW_QUESTIONMARK)

LWSTDAPI_(BOOL) PathIsValidCharA(UCHAR ch, DWORD dwFlags);
LWSTDAPI_(BOOL) PathIsValidCharW(WCHAR ch, DWORD dwFlags);
#ifdef UNICODE
#define PathIsValidChar  PathIsValidCharW
#else
#define PathIsValidChar  PathIsValidCharA
#endif // !UNICODE

#endif // (_WIN32_IE >= 0x0501)


// parsed URL information returned by ParseURL()
//
// Internet_CrackURL is the correct function for external components
// to use. URL.DLL calls this function to do some work and the shell
// uses this function as a leight-weight parsing function as well.

typedef struct tagPARSEDURLA {
    DWORD     cbSize;
    // Pointers into the buffer that was provided to ParseURL
    LPCSTR    pszProtocol;
    UINT      cchProtocol;
    LPCSTR    pszSuffix;
    UINT      cchSuffix;
    UINT      nScheme;            // One of URL_SCHEME_*
    } PARSEDURLA, * PPARSEDURLA;
typedef struct tagPARSEDURLW {
    DWORD     cbSize;
    // Pointers into the buffer that was provided to ParseURL
    LPCWSTR   pszProtocol;
    UINT      cchProtocol;
    LPCWSTR   pszSuffix;
    UINT      cchSuffix;
    UINT      nScheme;            // One of URL_SCHEME_*
    } PARSEDURLW, * PPARSEDURLW;
#ifdef UNICODE
typedef PARSEDURLW PARSEDURL;
typedef PPARSEDURLW PPARSEDURL;
#else
typedef PARSEDURLA PARSEDURL;
typedef PPARSEDURLA PPARSEDURL;
#endif // UNICODE

LWSTDAPI            ParseURLA(LPCSTR pcszURL, PARSEDURLA * ppu);
LWSTDAPI            ParseURLW(LPCWSTR pcszURL, PARSEDURLW * ppu);
#ifdef UNICODE
#define ParseURL  ParseURLW
#else
#define ParseURL  ParseURLA
#endif // !UNICODE



#endif //  NO_SHLWAPI_PATH


#ifndef NO_SHLWAPI_REG
//
//=============== Registry Routines ===================================
//

// BUGBUG (scotth): SHDeleteOrphanKey is the old name for SHDeleteEmptyKey.
//                  This will be removed soon.  SHDeleteOrphanKey already
//                  maps to SHDeleteEmptyKey in the DLL exports.

LWSTDAPI_(DWORD)    SHDeleteOrphanKeyA(HKEY hkey, LPCSTR pszSubKey);
LWSTDAPI_(DWORD)    SHDeleteOrphanKeyW(HKEY hkey, LPCWSTR pszSubKey);
#ifdef UNICODE
#define SHDeleteOrphanKey  SHDeleteOrphanKeyW
#else
#define SHDeleteOrphanKey  SHDeleteOrphanKeyA
#endif // !UNICODE

typedef struct tagAssocDDEExec
{
    LPCWSTR pszDDEExec;
    LPCWSTR pszApplication;
    LPCWSTR pszTopic;
    BOOL fNoActivateHandler;
} ASSOCDDEEXEC;

typedef struct tagAssocVerb
{
    LPCWSTR pszVerb;
    LPCWSTR pszTitle;
    LPCWSTR pszFriendlyAppName;
    LPCWSTR pszApplication;
    LPCWSTR pszParams;
    ASSOCDDEEXEC *pDDEExec;
} ASSOCVERB;

typedef struct tagAssocShell
{
    ASSOCVERB *rgVerbs;
    DWORD cVerbs;
    DWORD iDefaultVerb;
} ASSOCSHELL;

typedef struct tagAssocProgid
{
    DWORD cbSize;
    LPCWSTR pszProgid;
    LPCWSTR pszFriendlyDocName;
    LPCWSTR pszDefaultIcon;
    ASSOCSHELL *pShellKey;
    LPCWSTR pszExtensions;
} ASSOCPROGID;

typedef struct tagAssocApp
{
    DWORD cbSize;
    LPCWSTR pszFriendlyAppName;
    ASSOCSHELL *pShellKey;
} ASSOCAPP;

enum {
    ASSOCMAKEF_VERIFY                  = 0x00000040,  //  verify data is accurate (DISK HITS)
    ASSOCMAKEF_USEEXPAND               = 0x00000200,  //  strings have environment vars and need REG_EXPAND_SZ
    ASSOCMAKEF_SUBSTENV                = 0x00000400,  //  attempt to use std env if they match...
    ASSOCMAKEF_VOLATILE                = 0x00000800,  //  the progid will not persist between sessions
    ASSOCMAKEF_DELETE                  = 0x00002000,  //  remove this association if possible
};

typedef DWORD ASSOCMAKEF;

LWSTDAPI AssocMakeProgid(ASSOCMAKEF flags, LPCWSTR pszApplication, ASSOCPROGID *pProgid, HKEY *phkProgid);
LWSTDAPI AssocMakeApp(ASSOCMAKEF flags, LPCWSTR pszApplication, ASSOCAPP *pApp, HKEY *phkApp);

LWSTDAPI AssocMakeApplicationByKeyA(ASSOCMAKEF flags, HKEY hkAssoc, LPCSTR pszVerb);
LWSTDAPI AssocMakeApplicationByKeyW(ASSOCMAKEF flags, HKEY hkAssoc, LPCWSTR pszVerb);
#ifdef UNICODE
#define AssocMakeApplicationByKey  AssocMakeApplicationByKeyW
#else
#define AssocMakeApplicationByKey  AssocMakeApplicationByKeyA
#endif // !UNICODE
LWSTDAPI AssocMakeFileExtsToApplicationA(ASSOCMAKEF flags, LPCSTR pszExt, LPCSTR pszApplication);
LWSTDAPI AssocMakeFileExtsToApplicationW(ASSOCMAKEF flags, LPCWSTR pszExt, LPCWSTR pszApplication);
#ifdef UNICODE
#define AssocMakeFileExtsToApplication  AssocMakeFileExtsToApplicationW
#else
#define AssocMakeFileExtsToApplication  AssocMakeFileExtsToApplicationA
#endif // !UNICODE

LWSTDAPI AssocCopyVerbs(HKEY hkSrc, HKEY hkDst);


typedef enum _SHELLKEY
{
    SKROOT_HKCU                     = 0x00000001,       //  internal to the function
    SKROOT_HKLM                     = 0x00000002,       //  internal to the function
    SKROOT_MASK                     = 0x0000000F,       //  internal to the function
    SKPATH_EXPLORER                 = 0x00000000,       //  internal to the function
    SKPATH_SHELL                    = 0x00000010,       //  internal to the function
    SKPATH_SHELLNOROAM              = 0x00000020,       //  internal to the function
    SKPATH_CLASSES                  = 0x00000030,       //  internal to the function
    SKPATH_MASK                     = 0x00000FF0,       //  internal to the function
    SKSUB_NONE                      = 0x00000000,       //  internal to the function
    SKSUB_LOCALIZEDNAMES            = 0x00001000,       //  internal to the function
    SKSUB_HANDLERS                  = 0x00002000,       //  internal to the function
    SKSUB_ASSOCIATIONS              = 0x00003000,       //  internal to the function
    SKSUB_VOLATILE                  = 0x00004000,       //  internal to the function
    SKSUB_MUICACHE                  = 0x00005000,       //  internal to the function
    SKSUB_FILEEXTS                  = 0x00006000,       //  internal to the function
    SKSUB_MASK                      = 0x000FF000,       //  internal to the function

    SHELLKEY_HKCU_EXPLORER          = SKROOT_HKCU | SKPATH_EXPLORER | SKSUB_NONE,
    SHELLKEY_HKLM_EXPLORER          = SKROOT_HKLM | SKPATH_EXPLORER | SKSUB_NONE,
    SHELLKEY_HKCU_SHELL             = SKROOT_HKCU | SKPATH_SHELL | SKSUB_NONE,
    SHELLKEY_HKLM_SHELL             = SKROOT_HKLM | SKPATH_SHELL | SKSUB_NONE,
    SHELLKEY_HKCU_SHELLNOROAM       = SKROOT_HKCU | SKPATH_SHELLNOROAM | SKSUB_NONE,
    SHELLKEY_HKCULM_SHELL           = SHELLKEY_HKCU_SHELLNOROAM,
    SHELLKEY_HKCULM_CLASSES         = SKROOT_HKCU | SKPATH_CLASSES | SKSUB_NONE,
    SHELLKEY_HKCU_LOCALIZEDNAMES    = SKROOT_HKCU | SKPATH_SHELL | SKSUB_LOCALIZEDNAMES,
    SHELLKEY_HKCULM_HANDLERS        = SKROOT_HKCU | SKPATH_SHELLNOROAM | SKSUB_HANDLERS,
    SHELLKEY_HKCULM_ASSOCIATIONS    = SKROOT_HKCU | SKPATH_SHELLNOROAM | SKSUB_ASSOCIATIONS,
    SHELLKEY_HKCULM_VOLATILE        = SKROOT_HKCU | SKPATH_SHELLNOROAM | SKSUB_VOLATILE,
    SHELLKEY_HKCULM_MUICACHE        = SKROOT_HKCU | SKPATH_SHELLNOROAM | SKSUB_MUICACHE,
    SHELLKEY_HKCU_FILEEXTS          = SKROOT_HKCU | SKPATH_EXPLORER | SKSUB_FILEEXTS,

    SHELLKEY_HKCULM_HANDLERS_RO     = SHELLKEY_HKCULM_HANDLERS,      //  deprecated
    SHELLKEY_HKCULM_HANDLERS_RW     = SHELLKEY_HKCULM_HANDLERS,      //  deprecated
    SHELLKEY_HKCULM_ASSOCIATIONS_RO = SHELLKEY_HKCULM_ASSOCIATIONS,    //  deprecated
    SHELLKEY_HKCULM_ASSOCIATIONS_RW = SHELLKEY_HKCULM_ASSOCIATIONS,    //  deprecated
    SHELLKEY_HKCULM_RO              = SHELLKEY_HKCU_SHELLNOROAM,     //  deprecated
    SHELLKEY_HKCULM_RW              = SHELLKEY_HKCU_SHELLNOROAM,     //  deprecated
} SHELLKEY;

LWSTDAPI_(HKEY) SHGetShellKey(SHELLKEY sk, LPCWSTR pszSubKey, BOOL fCreateSub);

LWSTDAPI SKGetValueA(SHELLKEY sk, LPCSTR pszSubKey, LPCSTR pszValue, DWORD *pdwType, void *pvData, DWORD *pcbData);
LWSTDAPI SKGetValueW(SHELLKEY sk, LPCWSTR pszSubKey, LPCWSTR pszValue, DWORD *pdwType, void *pvData, DWORD *pcbData);
#ifdef UNICODE
#define SKGetValue  SKGetValueW
#else
#define SKGetValue  SKGetValueA
#endif // !UNICODE
LWSTDAPI SKSetValueA(SHELLKEY sk, LPCSTR pszSubKey, LPCSTR pszValue, DWORD dwType, LPCVOID pvData, DWORD cbData);
LWSTDAPI SKSetValueW(SHELLKEY sk, LPCWSTR pszSubKey, LPCWSTR pszValue, DWORD dwType, LPCVOID pvData, DWORD cbData);
#ifdef UNICODE
#define SKSetValue  SKSetValueW
#else
#define SKSetValue  SKSetValueA
#endif // !UNICODE
LWSTDAPI SKDeleteValueA(SHELLKEY sk, LPCSTR pszSubKey, LPCSTR pszValue);
LWSTDAPI SKDeleteValueW(SHELLKEY sk, LPCWSTR pszSubKey, LPCWSTR pszValue);
#ifdef UNICODE
#define SKDeleteValue  SKDeleteValueW
#else
#define SKDeleteValue  SKDeleteValueA
#endif // !UNICODE
LWSTDAPI SKAllocValueA(SHELLKEY sk, LPCSTR pszSubKey, LPCSTR pszValue, DWORD *pdwType, void **pvData, DWORD *pcbData);
LWSTDAPI SKAllocValueW(SHELLKEY sk, LPCWSTR pszSubKey, LPCWSTR pszValue, DWORD *pdwType, void **pvData, DWORD *pcbData);
#ifdef UNICODE
#define SKAllocValue  SKAllocValueW
#else
#define SKAllocValue  SKAllocValueA
#endif // !UNICODE

LWSTDAPI QuerySourceCreateFromKey(HKEY hk, PCWSTR pszSub, BOOL fCreate, REFIID riid, void **ppv);


#endif //  NO_SHLWAPI_REG


#ifndef NO_SHLWAPI_UALSTR
#include <uastrfnc.h>
#endif //  NO_SHLWAPI_UALSTR


#ifndef NO_SHLWAPI_STREAM
//
//=============== Stream Routines ===================================
//
//
//  We must say "struct IStream" instead of "IStream" in case we are
//  #include'd before <ole2.h>.
//
LWSTDAPI MapWin32ErrorToSTG(HRESULT hrIn);
LWSTDAPI ModeToCreateFileFlags(DWORD grfMode, BOOL fCreate, DWORD *pdwDesiredAccess, DWORD *pdwShareMode, DWORD *pdwCreationDisposition);

// SHConvertGraphicsFile Description:
// pszFile: The source file name to convert.  The file can be a JPEG, GIF, PNG, TIFF, BMP, EMF, WMF, or ICO filetype.
// pszDestFile: This is the destination file that will be created.  The extension will determine type of
//          format for the destiation file.  If this file already exists, the function will fail with
//          HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) unless the flag SHCGF_REPLACEFILE is specified.
// Return value: S_OK if the destination file was able to be created, otherwise an HRESULT error.
//
// NOTE: This is currently internal because: 1) we are using a temporary GDI+ interface, 2)
//    we can't fix any bugs we find (since they are in GDI+), and 3) it's best if GDI+ owns
//    the public version of this interface.  GDI+ is working on version 1 of their API for
//    whistler.  They don't have time to create this API, make it public, and support it
//    until version 2, which will be after whistler.
//
// dwFlags:
#define SHCGF_NONE              0x00000000          // Normal behavior
#define SHCGF_REPLACEFILE       0x00000001          // If pszDestFile already exists, delete it.

LWSTDAPI SHConvertGraphicsFile(IN LPCWSTR pszFile, IN LPCWSTR pszDestFile, IN DWORD dwFlags);

LWSTDAPI_(struct IStream *) SHCreateMemStream(LPBYTE pInit, UINT cbInit);

// SHCreateStreamWrapper creates an IStream that spans multiple IStream implementations.
// NOTE: STGM_READ is the only mode currently supported
LWSTDAPI SHCreateStreamWrapper(IStream *aStreams[], UINT cStreams, DWORD grfMode, IStream **ppstm);


// These functions read, write, and maintain a list of DATABLOCK_HEADERs.
// Blocks can be of any size (cbSize) and they are added, found, and removed
// by dwSignature. Each block is guranteed to be aligned on a DWORD boundary
// in memory. The stream format is identical to Windows 95 and NT 4
// CShellLink's "EXP" data format (with one bug fix: stream data is NULL
// terminated on write...)
//
// SHReadDataBlocks and SHAddDataBlock will allocate your pdbList for you.
//
// SHFindDataBlock returns a pointer into the pdbList.
//
// SHAddDataBlock and SHRemoveDataBlock return TRUE if ppdbList modified.
//

/*
 *  Temporary definition because the definition doesn't show up until shlobj.w.
 */

#define LPDATABLOCK_HEADER  struct tagDATABLOCKHEADER *
#define LPDBLIST            struct tagDATABLOCKHEADER *

LWSTDAPI SHWriteDataBlockList(struct IStream* pstm, LPDBLIST pdbList);
LWSTDAPI SHReadDataBlockList(struct IStream* pstm, LPDBLIST * ppdbList);
LWSTDAPI_(void) SHFreeDataBlockList(LPDBLIST pdbList);
LWSTDAPI_(BOOL) SHAddDataBlock(LPDBLIST * ppdbList, LPDATABLOCK_HEADER pdb);
LWSTDAPI_(BOOL) SHRemoveDataBlock(LPDBLIST * ppdbList, DWORD dwSignature);
LWSTDAPI_(void *) SHFindDataBlock(LPDBLIST pdbList, DWORD dwSignature);

#undef LPDATABLOCK_HEADER
#undef LPDBLIST

// FUNCTION: SHCheckDiskForMedia
//
// hwnd - NULL means no UI will be displayed.  Non-NULL means
// punkEnableModless - Make caller modal during UI. (OPTIONAL)
// pszPath - Path that needs verification.
// wFunc - Type of operation (FO_MOVE, FO_COPY, FO_DELETE, FO_RENAME - shellapi.h)
//
// NOTE: USE NT5's SHPathPrepareForWrite() instead, it's MUCH MUCH BETTER.

LWSTDAPI_(BOOL) SHCheckDiskForMediaA(HWND hwnd, IUnknown * punkEnableModless, LPCSTR pszPath, UINT wFunc);
LWSTDAPI_(BOOL) SHCheckDiskForMediaW(HWND hwnd, IUnknown * punkEnableModless, LPCWSTR pwzPath, UINT wFunc);

#ifdef UNICODE
#define SHCheckDiskForMedia      SHCheckDiskForMediaW
#else
#define SHCheckDiskForMedia      SHCheckDiskForMediaA
#endif


#endif // NO_SHLWAPI_STREAM

#ifndef NO_SHLWAPI_MLUI
//
//=============== Multi Language UI Routines ===================================
//


#define     ORD_SHGETWEBFOLDERFILEPATHA 440
#define     ORD_SHGETWEBFOLDERFILEPATHW 441
LWSTDAPI    SHGetWebFolderFilePathA(LPCSTR pszFileName, LPSTR pszMUIPath, UINT cchMUIPath);
LWSTDAPI    SHGetWebFolderFilePathW(LPCWSTR pszFileName, LPWSTR pszMUIPath, UINT cchMUIPath);
#ifdef UNICODE
#define SHGetWebFolderFilePath  SHGetWebFolderFilePathW
#else
#define SHGetWebFolderFilePath  SHGetWebFolderFilePathA
#endif // !UNICODE

// Use MLLoadLibrary to get the ML-resource file.  This function tags the file so
// all standard shlwapi wrap functions automatically get ML-behavior.
//

#define ORD_MLLOADLIBRARYA  377
#define ORD_MLLOADLIBRARYW  378
LWSTDAPI_(HINSTANCE) MLLoadLibraryA(LPCSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
LWSTDAPI_(HINSTANCE) MLLoadLibraryW(LPCWSTR lpLibFileName, HMODULE hModule, DWORD dwCrossCodePage);
#ifdef UNICODE
#define MLLoadLibrary  MLLoadLibraryW
#else
#define MLLoadLibrary  MLLoadLibraryA
#endif // !UNICODE
LWSTDAPI_(BOOL) MLFreeLibrary(HMODULE hModule);

#define ML_NO_CROSSCODEPAGE     0
#define ML_CROSSCODEPAGE_NT     1
#define ML_CROSSCODEPAGE        2
#define ML_SHELL_LANGUAGE       4
#define ML_CROSSCODEPAGE_MASK   7

// If you are a global distributable a-la comctl32 that doesn't follow the IE5
// PlugUI resource layout, then load your own hinstance and poke it into shlwapi
// using these functions:
//
LWSTDAPI MLSetMLHInstance(HINSTANCE hInst, LANGID lidUI);
LWSTDAPI MLClearMLHInstance(HINSTANCE hInst);

// Of course you need to know what UI language to use:
//
#define ORD_MLGETUILANGUAGE 376
LWSTDAPI_(LANGID) MLGetUILanguage(void);

// Super internal and you probably don't need this one, but comctl32 does
// some font munging in PlugUI cases on your apps behalf:
//
LWSTDAPI_(BOOL) MLIsMLHInstance(HINSTANCE hInst);


LWSTDAPI_(HRESULT) MLBuildResURLA(LPCSTR szLibFile, HMODULE hModule, DWORD dwCrossCodePage, LPCSTR szResourceName, LPSTR pszResURL, int nBufSize);
LWSTDAPI_(HRESULT) MLBuildResURLW(LPCWSTR szLibFile, HMODULE hModule, DWORD dwCrossCodePage, LPCWSTR szResourceName, LPWSTR pszResURL, int nBufSize);
#ifdef UNICODE
#define MLBuildResURL  MLBuildResURLW
#else
#define MLBuildResURL  MLBuildResURLA
#endif // !UNICODE
#define ORD_MLWINHELPA      395
#define ORD_MLWINHELPW      397
LWSTDAPI_(BOOL) MLWinHelpA(HWND hWndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
LWSTDAPI_(BOOL) MLWinHelpW(HWND hWndCaller, LPCWSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
#ifdef UNICODE
#define MLWinHelp  MLWinHelpW
#else
#define MLWinHelp  MLWinHelpA
#endif // !UNICODE
#define ORD_MLHTMLHELPA     396
#define ORD_MLHTMLHELPW     398
LWSTDAPI_(HWND) MLHtmlHelpA(HWND hWndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);
LWSTDAPI_(HWND) MLHtmlHelpW(HWND hWndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);
#ifdef UNICODE
#define MLHtmlHelp  MLHtmlHelpW
#else
#define MLHtmlHelp  MLHtmlHelpA
#endif // !UNICODE



#endif // NO_SHLWAPI_MLUI


#ifndef NO_SHLWAPI_HTTP
//
//=============== HTTP helper Routines ===================================
//  The calling thread must have called CoInitialize() before using this
//  function - it will create a format enumerator and associate it as a
// property with the IShellBrowser passed in, so that it will be reused.
//

//
//  We must say "struct IWhatever" instead of "IWhatever" in case we are
//  #include'd before <ole2.h>.
//
LWSTDAPI RegisterDefaultAcceptHeaders(struct IBindCtx* pbc, struct IShellBrowser* psb);

LWSTDAPI RunRegCommand(HWND hwnd, HKEY hkey, LPCWSTR pszKey);
LWSTDAPI RunIndirectRegCommand(HWND hwnd, HKEY hkey, LPCWSTR pszKey, LPCWSTR pszVerb);
LWSTDAPI SHRunIndirectRegClientCommand(HWND hwnd, LPCWSTR pszClient);

LWSTDAPI   GetAcceptLanguagesA(LPSTR psz, LPDWORD pcch);
LWSTDAPI   GetAcceptLanguagesW(LPWSTR pwz, LPDWORD pcch);

#ifdef UNICODE
#define GetAcceptLanguages      GetAcceptLanguagesW
#else
#define GetAcceptLanguages      GetAcceptLanguagesA
#endif

#endif // NO_SHLWAPI_HTTP



LWSTDAPI_(HWND) SHHtmlHelpOnDemandW(HWND hwnd, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage, BOOL bUseML);
LWSTDAPI_(HWND) SHHtmlHelpOnDemandA(HWND hwnd, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage, BOOL bUseML);
LWSTDAPI_(BOOL) SHWinHelpOnDemandW(HWND hwnd, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, BOOL bUseML);
LWSTDAPI_(BOOL) SHWinHelpOnDemandA(HWND hwnd, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, BOOL bUseML);
LWSTDAPI_(BOOL) WINAPI Shell_GetCachedImageIndexWrapW(LPCWSTR pszIconPath, int iIconIndex, UINT uIconFlags);
LWSTDAPI_(BOOL) WINAPI Shell_GetCachedImageIndexWrapA(LPCSTR pszIconPath, int iIconIndex, UINT uIconFlags);

#ifdef UNICODE
#define SHHtmlHelpOnDemand      SHHtmlHelpOnDemandW
#define SHWinHelpOnDemand       SHWinHelpOnDemandW
#define Shell_GetCachedImageIndexWrap Shell_GetCachedImageIndexWrapW
#else
#define SHHtmlHelpOnDemand      SHHtmlHelpOnDemandA
#define SHWinHelpOnDemand       SHWinHelpOnDemandA
#define Shell_GetCachedImageIndexWrap Shell_GetCachedImageIndexWrapA
#endif


#ifndef NO_SHLWAPI_STOPWATCH
//
//=============== Performance timing macros and prototypes ================

// StopWatch performance mode flags used in dwFlags param in API's and in Mode key at
// HKLM\software\microsoft\windows\currentversion\explorer\performance
// NOTE: low word is used for the mode, high word is used to change the default painter timer interval.
//       If we need more mode bits then we'll need a new reg key for paint timer
#define SPMODE_SHELL      0x00000001
#define SPMODE_DEBUGOUT   0x00000002
#define SPMODE_TEST       0x00000004
#define SPMODE_BROWSER    0x00000008
#define SPMODE_FLUSH      0x00000010
#define SPMODE_EVENT      0x00000020
#define SPMODE_JAVA       0x00000040
#define SPMODE_FORMATTEXT 0x00000080
#define SPMODE_PROFILE    0x00000100
#define SPMODE_DEBUGBREAK 0x00000200
#define SPMODE_MSGTRACE   0x00000400
#define SPMODE_PERFTAGS   0x00000800
#define SPMODE_MEMWATCH   0x00001000
#define SPMODE_DBMON      0x00002000
#define SPMODE_MARS       0x00004000
#ifndef NO_ETW_TRACING
#define SPMODE_EVENTTRACE 0x00008000 // Event Tracing for Windows Enabled
#endif
#define SPMODE_RESERVED   0xffff0000
#ifndef NO_ETW_TRACING
#define SPMODES (SPMODE_SHELL | SPMODE_BROWSER | SPMODE_JAVA |  SPMODE_MSGTRACE | SPMODE_MEMWATCH | SPMODE_DBMON | SPMODE_MARS | SPMODE_EVENTTRACE)
#else
#define SPMODES (SPMODE_SHELL | SPMODE_BROWSER | SPMODE_JAVA |  SPMODE_MSGTRACE | SPMODE_MEMWATCH | SPMODE_DBMON | SPMODE_MARS)
#endif

#ifndef NO_ETW_TRACING
// Event tracing capability enabled by setting the mode to SPMODE_EVENTTRACE and
// selecting the part of the shell to trace in the "EventTrace" Value in the
// following key:
// HKLM\software\microsoft\windows\currentversion\explorer\performance

// BROWSER TRACING
// Do not use with SPMODE_BROWSER.  If SPMODE_EVENT is used, the
// STOPWATCH_STOP_EVENT will be signaled when a web page is done loading.
#define SPTRACE_BROWSER 0x00000001
// Used to turn on/off browser event tracing.  Setting the registry key enables
// event tracing use, but doesn't turn it on.
// {5576F62E-4142-45a8-9516-262A510C13F0}
DEFINE_GUID(c_BrowserControlGuid,
            0x5576f62e,
            0x4142,
            0x45a8,
            0x95, 0x16, 0x26, 0x2a, 0x51, 0xc, 0x13, 0xf0);

// Maps to the structure sent to ETW.  ETW definition in
// \nt\sdktools\trace\tracedmp\mofdata.guid
// {2B992163-736F-4a68-9153-95BC5F34D884}
DEFINE_GUID(c_BrowserTraceGuid,
            0x2b992163,
            0x736f,
            0x4a68,
            0x91, 0x53, 0x95, 0xbc, 0x5f, 0x34, 0xd8, 0x84);

// BROWSING EVENTS
// See \nt\sdktools\trace\tracedmp\mofdata.guid
// The page load starts with a user keystroke message
#define EVENT_TRACE_TYPE_BROWSE_USERINPUTRET    10
#define EVENT_TRACE_TYPE_BROWSE_USERINPUTBACK   11
#define EVENT_TRACE_TYPE_BROWSE_USERINPUTLBUT   12
#define EVENT_TRACE_TYPE_BROWSE_USERINPUTNEXT   13
#define EVENT_TRACE_TYPE_BROWSE_USERINPUTPRIOR  14
#define EVENT_TRACE_TYPE_BROWSE_STARTFRAME      16
#define EVENT_TRACE_TYPE_BROWSE_LOADEDPARSED    18
#define EVENT_TRACE_TYPE_BROWSE_LAYOUT          19
#define EVENT_TRACE_TYPE_BROWSE_LAYOUTTASK      20
#define EVENT_TRACE_TYPE_BROWSE_PAINT           21
// Url the user types into the address bar.
#define EVENT_TRACE_TYPE_BROWSE_ADDRESS         22

#endif


// StopWatch node types used in memory log to identify the type of node
#define EMPTY_NODE  0x0
#define START_NODE  0x1
#define LAP_NODE    0x2
#define STOP_NODE   0x3
#define OUT_OF_NODES 0x4

// StopWatch timing ids used to identify the type of timing being performed
#define SWID_STARTUP         0x0
#define SWID_FRAME           0x1
#define SWID_COPY            0x2
#define SWID_TREE            0x3
#define SWID_BROWSER_FRAME   0x4
#define SWID_JAVA_APP        0x5
#define SWID_MENU            0x6
#define SWID_BITBUCKET       0x7
#define SWID_EXPLBAR         0x8
#define SWID_MSGDISPATCH     0x9
#define SWID_TRACEMSG        0xa
#define SWID_DBMON_DLLLOAD   0xb
#define SWID_DBMON_EXCEPTION 0xc
#define SWID_THUMBVW_CACHEREAD  0xd
#define SWID_THUMBVW_EXTRACT    0xe
#define SWID_THUMBVW_CACHEWRITE 0xf
#define SWID_THUMBVW_FETCH      0x10
#define SWID_THUMBVW_INIT   0x11
#define SWID_MASK_BROWSER_STOPBTN 0x8000000     // identifies BROWSER_FRAME stop caused by stop button

#define SWID_MASKS         SWID_MASK_BROWSER_STOPBTN // add any SWID_MASK_* defines here

#define SWID(dwId) (dwId & (~SWID_MASKS))

// The following StopWatch messages are used to drive the timer msg handler.  The timer proc is used
// as a means of delaying while watching paint messages.  If the defined number of timer ticks has
// passed without getting any paint messages, then we mark the time of the last paint message we've
// saved as the stop time.
#define SWMSG_PAINT    1    // paint message rcvd
#define SWMSG_TIMER    2    // timer tick
#define SWMSG_CREATE   3    // init handler and create timer
#define SWMSG_STATUS   4    // get status of whether timing is active or not

#define ID_STOPWATCH_TIMER 0xabcd   // Timer id

// Stopwatch defaults
#define STOPWATCH_MAX_NODES                 100
#define STOPWATCH_DEFAULT_PAINT_INTERVAL   1000
#define STOPWATCH_DEFAULT_MAX_DISPATCH_TIME 150
#define STOPWATCH_DEFAULT_MAX_MSG_TIME     1000
#define STOPWATCH_DEFAULT_MAX_MSG_INTERVAL   50
#define STOPWATCH_DEFAULT_CLASSNAMES TEXT("Internet Explorer_Server") TEXT("\0") TEXT("SHELLDLL_DefView") TEXT("\0") TEXT("SysListView32") TEXT("\0\0")

#define MEMWATCH_DEFAULT_PAGES  512
#define MEMWATCH_DEFAULT_TIME  1000
#define MEMWATCH_DEFAULT_FLAGS    0


#ifdef UNICODE
#define StopWatch StopWatchW
#define StopWatchEx StopWatchExW
#else
#define StopWatch StopWatchA
#define StopWatchEx StopWatchExA
#endif

#define StopWatch_Start(dwId, pszDesc, dwFlags) StopWatch(dwId, pszDesc, START_NODE, dwFlags, 0)
#define StopWatch_Lap(dwId, pszDesc, dwFlags)   StopWatch(dwId, pszDesc, LAP_NODE, dwFlags, 0)
#define StopWatch_Stop(dwId, pszDesc, dwFlags)  StopWatch(dwId, pszDesc, STOP_NODE, dwFlags, 0)
#define StopWatch_StartTimed(dwId, pszDesc, dwFlags, dwCount)  StopWatch(dwId, pszDesc, START_NODE, dwFlags, dwCount)
#define StopWatch_LapTimed(dwId, pszDesc, dwFlags, dwCount)  StopWatch(dwId, pszDesc, LAP_NODE, dwFlags, dwCount)
#define StopWatch_StopTimed(dwId, pszDesc, dwFlags, dwCount)  StopWatch(dwId, pszDesc, STOP_NODE, dwFlags, dwCount)

#define StopWatch_StartEx(dwId, pszDesc, dwFlags, dwCookie) StopWatchEx(dwId, pszDesc, START_NODE, dwFlags, 0, dwCookie)
#define StopWatch_LapEx(dwId, pszDesc, dwFlags, dwCookie)   StopWatchEx(dwId, pszDesc, LAP_NODE, dwFlags, 0, dwCookie)
#define StopWatch_StopEx(dwId, pszDesc, dwFlags, dwCookie)  StopWatchEx(dwId, pszDesc, STOP_NODE, dwFlags, 0, dwCookie)
#define StopWatch_StartTimedEx(dwId, pszDesc, dwFlags, dwCount, dwCookie)  StopWatchEx(dwId, pszDesc, START_NODE, dwFlags, dwCount, dwCookie)
#define StopWatch_LapTimedEx(dwId, pszDesc, dwFlags, dwCount, dwCookie)  StopWatchEx(dwId, pszDesc, LAP_NODE, dwFlags, dwCount, dwCookie)
#define StopWatch_StopTimedEx(dwId, pszDesc, dwFlags, dwCount, dwCookie)  StopWatchEx(dwId, pszDesc, STOP_NODE, dwFlags, dwCount, dwCookie)

VOID InitStopWatchMode(VOID);

// EXPORTED FUNCTIONS
DWORD WINAPI StopWatchW(DWORD dwId, LPCWSTR pszDesc, DWORD dwType, DWORD dwFlags, DWORD dwCount);
DWORD WINAPI StopWatchA(DWORD dwId, LPCSTR pszDesc, DWORD dwType, DWORD dwFlags, DWORD dwCount);
DWORD WINAPI StopWatchExW(DWORD dwId, LPCWSTR pszDesc, DWORD dwType, DWORD dwFlags, DWORD dwCount, DWORD dwUniqueId);
DWORD WINAPI StopWatchExA(DWORD dwId, LPCSTR pszDesc, DWORD dwType, DWORD dwFlags, DWORD dwCount, DWORD dwUniqueId);
DWORD WINAPI StopWatchMode(VOID);
DWORD WINAPI StopWatchFlush(VOID);
BOOL WINAPI StopWatch_TimerHandler(HWND hwnd, UINT uInc, DWORD dwFlag, MSG *pmsg);
VOID WINAPI StopWatch_CheckMsg(HWND hwnd, MSG msg, LPCSTR lpStr);
VOID WINAPI StopWatch_MarkFrameStart(LPCSTR lpExplStr);
VOID WINAPI StopWatch_MarkSameFrameStart(HWND hwnd);
VOID WINAPI StopWatch_MarkJavaStop(LPCSTR  lpStringToSend, HWND hwnd, BOOL fChType);
DWORD WINAPI GetPerfTime(VOID);
VOID WINAPI StopWatch_SetMsgLastLocation(DWORD dwLast);
DWORD WINAPI StopWatch_DispatchTime(BOOL fStartTime, MSG msg, DWORD dwStart);
#ifndef NO_ETW_TRACING
VOID WINAPI EventTraceHandler(UCHAR uchEventType, PVOID pvData);
#endif

extern DWORD g_dwStopWatchMode;
//
//=============== End Performance timing macros and prototypes ================

#endif //#ifndef NO_SHLWAPI_STOPWATCH



#ifndef NO_SHLWAPI_INTERNAL
//
//=============== Internal helper routines ===================================

//
//  Declare some OLE interfaces we need to refer to and which aren't
//  already defined in objbase.h
//

#ifndef RC_INVOKED /* { rc doesn't like these long symbol names */
#ifndef __IOleCommandTarget_FWD_DEFINED__
#define __IOleCommandTarget_FWD_DEFINED__
typedef struct IOleCommandTarget IOleCommandTarget;
#endif  /* __IOleCommandTarget_FWD_DEFINED__ */

#ifndef __IDropTarget_FWD_DEFINED__
#define __IDropTarget_FWD_DEFINED__
typedef struct IDropTarget IDropTarget;
#endif  /* __IDropTarget_FWD_DEFINED__ */

#ifndef __IPropertyBag_FWD_DEFINED__
#define __IPropertyBag_FWD_DEFINED__
typedef struct IPropertyBag IPropertyBag;
#endif  /* __IPropertyBag_FWD_DEFINED__ */

#ifndef __IConnectionPoint_FWD_DEFINED__
#define __IConnectionPoint_FWD_DEFINED__
typedef struct IConnectionPoint IConnectionPoint;
#endif  /* __IConnectionPoint_FWD_DEFINED__ */

#ifdef __cplusplus
extern "C++" {
    template <typename T>
    void IUnknown_SafeReleaseAndNullPtr(T *& p)
    {
        if (p)
        {
            T *pTemp = p;
            p = NULL;
            pTemp->Release();
        }
    }
}
#endif  // __cplusplus

    LWSTDAPI_(void) IUnknown_AtomicRelease(void ** ppunk);
    LWSTDAPI_(BOOL) SHIsSameObject(IUnknown* punk1, IUnknown* punk2);
    LWSTDAPI IUnknown_GetWindow(IUnknown* punk, HWND* phwnd);
    LWSTDAPI IUnknown_SetOwner(IUnknown* punk, IUnknown* punkOwner);
    LWSTDAPI IUnknown_SetSite(IUnknown *punk, IUnknown *punkSite);
    LWSTDAPI IUnknown_GetSite(IUnknown *punk, REFIID riid, void **ppvOut);
    LWSTDAPI IUnknown_EnableModeless(IUnknown * punk, BOOL fEnabled);
    LWSTDAPI IUnknown_GetClassID(IUnknown *punk, CLSID *pclsid);
    LWSTDAPI IUnknown_QueryService(IUnknown* punk, REFGUID guidService, REFIID riid, void ** ppvOut);
    LWSTDAPI IUnknown_QueryServiceForWebBrowserApp(IUnknown* punk, REFIID riid, void **ppvOut);
    LWSTDAPI IUnknown_QueryServiceExec(IUnknown* punk, REFGUID guidService, const GUID *guid,
                                 DWORD cmdID, DWORD cmdParam, VARIANT* pvarargIn, VARIANT* pvarargOut);
    LWSTDAPI IUnknown_ShowBrowserBar(IUnknown* punk, REFCLSID clsidBrowserBar, BOOL fShow);
    LWSTDAPI IUnknown_HandleIRestrict(IUnknown * punk, const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, DWORD * pdwRestrictionResult);
    LWSTDAPI IUnknown_OnFocusOCS(IUnknown *punk, BOOL fGotFocus);
    LWSTDAPI IUnknown_TranslateAcceleratorOCS(IUnknown *punk, LPMSG lpMsg, DWORD grfMods);
    LWSTDAPI_(void) IUnknown_Set(IUnknown ** ppunk, IUnknown * punk);
    LWSTDAPI IUnknown_ProfferService(IUnknown *punkSite, 
                                     REFGUID sidWhat, IServiceProvider *punkService, 
                                     DWORD *pdwCookie);
    LWSTDAPI IUnknown_QueryServicePropertyBag(IUnknown* punk, DWORD dwFlags, REFIID riid, void ** ppvOut);

    LWSTDAPI IUnknown_TranslateAcceleratorIO(IUnknown* punk, LPMSG lpMsg);
    LWSTDAPI IUnknown_UIActivateIO(IUnknown *punk, BOOL fActivate, LPMSG lpMsg);
    LWSTDAPI IUnknown_OnFocusChangeIS(IUnknown *punk, IUnknown *punkSrc, BOOL fSetFocus);
    LWSTDAPI IUnknown_HasFocusIO(IUnknown *punk);

    LWSTDAPI SHWeakQueryInterface(IUnknown *punkOuter, IUnknown *punkTarget, REFIID riid, void **ppvOut);
    LWSTDAPI_(void) SHWeakReleaseInterface(IUnknown *punkOuter, IUnknown **ppunk);

    #define IUnknown_EnableModless IUnknown_EnableModeless

    // Helper macros for the Weak interface functions.
    #define     SHQueryInnerInterface           SHWeakQueryInterface
    #define     SHReleaseInnerInterface         SHWeakReleaseInterface
    #define     SHReleaseOuterInterface         SHWeakReleaseInterface

    __inline HRESULT SHQueryOuterInterface(IUnknown *punkOuter, REFIID riid, void **ppvOut)
    {
        return SHWeakQueryInterface(punkOuter, punkOuter, riid, ppvOut);
    }

#if (_WIN32_IE >= 0x0600)
    // App compat-aware CoCreateInstance
    LWSTDAPI SHCoCreateInstanceAC(REFCLSID rclsid,
                                  IUnknown *punkOuter, DWORD dwClsCtx,
                                  REFIID riid, void **ppvOut);
#endif // (_WIN32_IE >= 0x0600)

#if defined(__IOleAutomationTypes_INTERFACE_DEFINED__) && \
    defined(__IOleCommandTarget_INTERFACE_DEFINED__)
    LWSTDAPI IUnknown_QueryStatus(IUnknown *punk, const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    LWSTDAPI IUnknown_Exec(IUnknown* punk, const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // Some of the many connection point helper functions available in
    // connect.cpp.  We export only the ones people actually use.  If
    // you need a helper function, maybe it's already in connect.cpp
    // and merely needs to be exported.

    LWSTDAPI SHPackDispParamsV(DISPPARAMS * pdispparams, VARIANTARG *rgvt,
                               UINT cArgs, va_list arglist);
    LWSTDAPIV SHPackDispParams(DISPPARAMS * pdispparams, VARIANTARG *rgvt,
                               UINT cArgs, ...);

    typedef HRESULT (CALLBACK *SHINVOKECALLBACK)(IDispatch *pdisp, struct SHINVOKEPARAMS *pinv);

#include <pshpack1.h>
    typedef struct SHINVOKEPARAMS {
        UINT flags;                     // mandatory
        DISPID dispidMember;            // mandatory
        const IID*piid;                 // IPFL_USEDEFAULTS will fill this in
        LCID lcid;                      // IPFL_USEDEFAULTS will fill this in
        WORD wFlags;                    // IPFL_USEDEFAULTS will fill this in
        DISPPARAMS * pdispparams;       // mandatory, may be NULL
        VARIANT * pvarResult;           // IPFL_USEDEFAULTS will fill this in
        EXCEPINFO * pexcepinfo;         // IPFL_USEDEFAULTS will fill this in
        UINT * puArgErr;                // IPFL_USEDEFAULTS will fill this in
        SHINVOKECALLBACK Callback;      // required if IPFL_USECALLBACK
    } SHINVOKEPARAMS, *LPSHINVOKEPARAMS;
#include <poppack.h>        /* Return to byte packing */


    #define IPFL_USECALLBACK        0x0001
    #define IPFL_USEDEFAULTS        0x0002

#if 0 // These functions not yet needed
    LWSTDAPI IConnectionPoint_InvokeIndirect(IConnectionPoint *pcp,
                            SHINVOKEPARAMS *pinv);
#endif

    LWSTDAPI IConnectionPoint_InvokeWithCancel(IConnectionPoint *pcp,
                    DISPID dispidMember, DISPPARAMS * pdispparams,
                    LPBOOL pfCancel, LPVOID *ppvCancel);
    LWSTDAPI IConnectionPoint_SimpleInvoke(IConnectionPoint *pcp,
                    DISPID dispidMember, DISPPARAMS * pdispparams);

#if 0 // These functions not yet needed
    LWSTDAPI IConnectionPoint_InvokeParamV(IConnectionPoint *pcp,
                    DISPID dispidMember, VARIANTARG *rgvarg,
                    UINT cArgs, va_list ap);
    LWSTDAPIV IConnectionPoint_InvokeParam(IConnectionPoint *pcp,
                    DISPID dispidMember, VARIANTARG *rgvarg, UINT cArgs, ...)
#endif

    LWSTDAPI IConnectionPoint_OnChanged(IConnectionPoint *pcp, DISPID dispid);

#if 0 // These functions not yet needed
    LWSTDAPI IUnknown_FindConnectionPoint(IUnknown *punk,
                    REFIID riidCP, IConnectionPoint **pcpOut);
#endif

    LWSTDAPI IUnknown_CPContainerInvokeIndirect(IUnknown *punk, REFIID riidCP,
                SHINVOKEPARAMS *pinv);
    LWSTDAPIV IUnknown_CPContainerInvokeParam(IUnknown *punk, REFIID riidCP,
                DISPID dispidMember, VARIANTARG *rgvarg, UINT cArgs, ...);
    LWSTDAPI IUnknown_CPContainerOnChanged(IUnknown *punk, DISPID dispid);

#endif /* IOleAutomationTypes && IOleCommandTarget */
#endif  /* } !RC_INVOKED */

    LWSTDAPI IStream_Read(IStream *pstm, void *pv, ULONG cb);
    LWSTDAPI IStream_Write(IStream *pstm, const void *pv, ULONG cb);
    LWSTDAPI IStream_Reset(IStream *pstm);
    LWSTDAPI IStream_Size(IStream *pstm, ULARGE_INTEGER *pui);
    LWSTDAPI IStream_WritePidl(IStream *pstm, LPCITEMIDLIST pidlWrite);
    LWSTDAPI IStream_ReadPidl(IStream *pstm, LPITEMIDLIST *ppidlOut);

    LWSTDAPI_(BOOL) SHIsEmptyStream(IStream* pstm);

    LWSTDAPI SHSimulateDrop(IDropTarget *pdrop, IDataObject *pdtobj, DWORD grfKeyState,
                         const POINTL *ppt, DWORD *pdwEffect);

    LWSTDAPI SHLoadFromPropertyBag(IUnknown* punk, IPropertyBag* ppg);

    LWSTDAPI ConnectToConnectionPoint(IUnknown* punkThis, REFIID riidEvent, BOOL fConnect, IUnknown* punkTarget, DWORD* pdwCookie, IConnectionPoint** ppcpOut);

LWSTDAPI SHCreatePropertyBagOnRegKey(HKEY hk, LPCWSTR pszSubKey, DWORD grfMode, REFIID riid, void **ppv);
LWSTDAPI SHCreatePropertyBagOnProfileSection(LPCWSTR pszFile, LPCWSTR pszSection, DWORD grfMode, REFIID riid, void **ppv);
LWSTDAPI SHCreatePropertyBagOnMemory(DWORD grfMode, REFIID riid, void **ppv);

LWSTDAPI SHPropertyBag_ReadType(IPropertyBag* ppb, LPCWSTR pszPropName, VARIANT* pv, VARTYPE vt);
LWSTDAPI SHPropertyBag_ReadStr(IPropertyBag* ppb, LPCWSTR pwzPropName, LPWSTR psz, int cch);
LWSTDAPI SHPropertyBag_ReadBSTR(IPropertyBag *ppb, LPCWSTR pwzPropName, BSTR* pbstr);
LWSTDAPI SHPropertyBag_WriteStr(IPropertyBag* ppb, LPCWSTR pwzPropName, LPCWSTR psz);
LWSTDAPI SHPropertyBag_ReadInt(IPropertyBag* ppb, LPCWSTR pwzPropName, INT* piResult);
LWSTDAPI SHPropertyBag_WriteInt(IPropertyBag* ppb, LPCWSTR pwzPropName, INT iValue);
LWSTDAPI SHPropertyBag_ReadSHORT(IPropertyBag* ppb, LPCWSTR pwzPropName, SHORT* psh);
LWSTDAPI SHPropertyBag_WriteSHORT(IPropertyBag* ppb, LPCWSTR pwzPropName, SHORT sh);
LWSTDAPI SHPropertyBag_ReadLONG(IPropertyBag* ppb, LPCWSTR pwzPropName, LONG* pl);
LWSTDAPI SHPropertyBag_WriteLONG(IPropertyBag* ppb, LPCWSTR pwzPropName, LONG l);
LWSTDAPI SHPropertyBag_ReadDWORD(IPropertyBag* ppb, LPCWSTR pwzPropName, DWORD* pdw);
LWSTDAPI SHPropertyBag_WriteDWORD(IPropertyBag* ppb, LPCWSTR pwzPropName, DWORD dw);
LWSTDAPI SHPropertyBag_ReadBOOL(IPropertyBag* ppb, LPCWSTR pwzPropName, BOOL* pfResult);
LWSTDAPI SHPropertyBag_WriteBOOL(IPropertyBag* ppb, LPCWSTR pwzPropName, BOOL fValue);
LWSTDAPI SHPropertyBag_ReadGUID(IPropertyBag* ppb, LPCWSTR pwzPropName, GUID* pguid);
LWSTDAPI SHPropertyBag_WriteGUID(IPropertyBag* ppb, LPCWSTR pwzPropName, const GUID* pguid);
LWSTDAPI SHPropertyBag_ReadPIDL(IPropertyBag *ppb, LPCWSTR pwzPropName, LPITEMIDLIST* ppidl);
LWSTDAPI SHPropertyBag_WritePIDL(IPropertyBag *ppb, LPCWSTR pwzPropName, LPCITEMIDLIST pidl);
LWSTDAPI SHPropertyBag_ReadPOINTL(IPropertyBag* ppb, LPCWSTR pwzPropName, POINTL* ppt);
LWSTDAPI SHPropertyBag_WritePOINTL(IPropertyBag* ppb, LPCWSTR pwzPropName, const POINTL* ppt);
LWSTDAPI SHPropertyBag_ReadPOINTS(IPropertyBag* ppb, LPCWSTR pwzPropName, POINTS* ppt);
LWSTDAPI SHPropertyBag_WritePOINTS(IPropertyBag* ppb, LPCWSTR pwzPropName, const POINTS* ppt);
LWSTDAPI SHPropertyBag_ReadRECTL(IPropertyBag* ppb, LPCWSTR pwzPropName, RECTL* prc);
LWSTDAPI SHPropertyBag_WriteRECTL(IPropertyBag* ppb, LPCWSTR pwzPropName, const RECTL* prc);
LWSTDAPI SHPropertyBag_ReadStream(IPropertyBag* ppb, LPCWSTR pwzPropName, IStream** ppstm);
LWSTDAPI SHPropertyBag_WriteStream(IPropertyBag* ppb, LPCWSTR pwzPropName, IStream* pstm);
LWSTDAPI SHPropertyBag_Delete(IPropertyBag* ppb, LPCWSTR pszPropName);

// Doc'ed for DOJ compliance

LWSTDAPI_(ULONG) SHGetPerScreenResName(WCHAR* pszRes, ULONG cch, DWORD dwVersion);

//
// SH(Get/Set)IniStringUTF7
//
// These are just like Get/WriteProfileString except that if the KeyName
// begins with SZ_CANBEUNICODE, we will use SHGetIniString instead of
// the profile functions.  (The SZ_CANBEUNICODE will be stripped off
// before calling SHGetIniString.)  This allows us to stash unicode
// strings into INI files (which are ASCII) by encoding them as UTF7.
//
// In other words, SHGetIniStringUTF7("Settings", SZ_CANBEUNICODE "Name", ...)
// will read from section "Settings", key name "Name", but will also
// look at the UTF7-encoded version stashed in the "Settings.W" section.
//
#define CH_CANBEUNICODEW     L'@'

LWSTDAPI_(DWORD) SHGetIniStringUTF7W(LPCWSTR lpSection, LPCWSTR lpKey, LPWSTR lpBuf, DWORD nSize, LPCWSTR lpFile);
LWSTDAPI_(BOOL) SHSetIniStringUTF7W(LPCWSTR lpSection, LPCWSTR lpKey, LPCWSTR lpString, LPCWSTR lpFile);
#ifdef UNICODE
#define SZ_CANBEUNICODE     TEXT("@")
#define SHSetIniStringUTF7  SHSetIniStringUTF7W
#define SHGetIniStringUTF7  SHGetIniStringUTF7W
#else
#define SZ_CANBEUNICODE     TEXT("")
#define SHGetIniStringUTF7(lpSection, lpKey, lpBuf, nSize, lpFile) \
  GetPrivateProfileStringA(lpSection, lpKey, "", lpBuf, nSize, lpFile)
#define SHSetIniStringUTF7 WritePrivateProfileStringA
#endif

/*
 *  Like PrivateProfileString except that UNICODE strings are encoded so they
 *  will successfully round-trip.
 */
LWSTDAPI_(DWORD) SHGetIniStringW(LPCWSTR lpSection, LPCWSTR lpKey, LPWSTR lpBuf, DWORD nSize, LPCWSTR lpFile);
#define SHGetIniStringA(lpSection, lpKey, lpBuf, nSize, lpFile) \
        GetPrivateProfileStringA(lpSection, lpKey, "", lpBuf, nSize, lpFile)

LWSTDAPI_(BOOL) SHSetIniStringW(LPCWSTR lpSection, LPCWSTR lpKey, LPCWSTR lpString, LPCWSTR lpFile);
#define SHSetIniStringA  WritePrivateProfileStringA

LWSTDAPI CreateURLFileContentsW(LPCWSTR pwszUrl, LPSTR *ppszOut);
LWSTDAPI CreateURLFileContentsA(LPCSTR pszUrl, LPSTR *ppszOut);

#ifdef UNICODE
#define SHGetIniString SHGetIniStringW
#define SHSetIniString SHSetIniStringW
#define CreateURLFileContents CreateURLFileContentsW
#else
#define SHGetIniString SHGetIniStringA
#define SHSetIniString SHSetIniStringA
#define CreateURLFileContents CreateURLFileContentsA
#endif // UNICODE

#define ISHGDN2_CANREMOVEFORPARSING     0x0001
LWSTDAPI IShellFolder_GetDisplayNameOf(struct IShellFolder *psf,
    LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pstr, DWORD dwFlags2);

LWSTDAPI IShellFolder_ParseDisplayName(struct IShellFolder *psf, HWND hwnd,
    struct IBindCtx *pbc, LPWSTR pszDisplayName, ULONG *pchEaten,
    LPITEMIDLIST *ppidl, ULONG *pdwAttributes);

LWSTDAPI IShellFolder_CompareIDs(struct IShellFolder *psf, LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

LWSTDAPI IShellFolder_EnumObjects(struct IShellFolder *psf, HWND hwnd,
    DWORD grfFlags, struct IEnumIDList **ppenumIDList);

LWSTDAPI_(BOOL) SHIsExpandableFolder(struct IShellFolder *psf, LPCITEMIDLIST pidl);
LWSTDAPI IContextMenu_Invoke(struct IContextMenu* pcm, HWND hwndOwner, LPCSTR pVerb, UINT fFlags);

#ifdef UNICODE
// SHTruncateString takes a BUFFER SIZE, so subtract 1 to properly null terminate.
//
#define SHTruncateString(wzStr, cch)            ((cch) ? ((wzStr)[cch-1]=L'\0', (cch-1)) : 0)
#else
LWSTDAPI_(int)  SHTruncateString(CHAR *sz, int cchBufferSize);
#endif // UNICODE

// SHFormatDateTime flags
//  (FDTF_SHORTDATE and FDTF_LONGDATE are mutually exclusive, as is
//   FDTF_SHORTIME and FDTF_LONGTIME.)
//
#define FDTF_SHORTTIME      0x00000001      // eg, "7:48 PM"
#define FDTF_SHORTDATE      0x00000002      // eg, "3/29/98"
#define FDTF_DEFAULT        (FDTF_SHORTDATE | FDTF_SHORTTIME) // eg, "3/29/98 7:48 PM"
#define FDTF_LONGDATE       0x00000004      // eg, "Monday, March 29, 1998"
#define FDTF_LONGTIME       0x00000008      // eg. "7:48:33 PM"
#define FDTF_RELATIVE       0x00000010      // uses "Yesterday", etc. if possible
#define FDTF_LTRDATE        0x00000100      // Left To Right reading order
#define FDTF_RTLDATE        0x00000200      // Right To Left reading order

LWSTDAPI_(int)  SHFormatDateTimeA(const FILETIME UNALIGNED * pft, DWORD * pdwFlags, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(int)  SHFormatDateTimeW(const FILETIME UNALIGNED * pft, DWORD * pdwFlags, LPWSTR pszBuf, UINT cchBuf);
#ifdef UNICODE
#define SHFormatDateTime  SHFormatDateTimeW
#else
#define SHFormatDateTime  SHFormatDateTimeA
#endif // !UNICODE

LWSTDAPI_(SECURITY_ATTRIBUTES*) CreateAllAccessSecurityAttributes(SECURITY_ATTRIBUTES* psa, SECURITY_DESCRIPTOR* psd, PACL *ppacl);

LWSTDAPI_(int)  SHAnsiToUnicode(LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf);
LWSTDAPI_(int)  SHAnsiToUnicodeCP(UINT uiCP, LPCSTR pszSrc, LPWSTR pwszDst, int cwchBuf);
LWSTDAPI_(int)  SHAnsiToAnsi(LPCSTR pszSrc, LPSTR pszDst, int cchBuf);
LWSTDAPI_(int)  SHUnicodeToAnsi(LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf);
LWSTDAPI_(int)  SHUnicodeToAnsiCP(UINT uiCP, LPCWSTR pwszSrc, LPSTR pszDst, int cchBuf);
LWSTDAPI_(int)  SHUnicodeToUnicode(LPCWSTR pwzSrc, LPWSTR pwzDst, int cwchBuf);
LWSTDAPI_(BOOL) DoesStringRoundTripA(LPCSTR pwszIn, LPSTR pszOut, UINT cchOut);
LWSTDAPI_(BOOL) DoesStringRoundTripW(LPCWSTR pwszIn, LPSTR pszOut, UINT cchOut);
#ifdef UNICODE
#define DoesStringRoundTrip     DoesStringRoundTripW
#else
#define DoesStringRoundTrip     DoesStringRoundTripA
#endif

// The return value from all SH<Type>To<Type> is the size of szDest including the terminater.
#ifdef UNICODE
#define SHTCharToUnicode(wzSrc, wzDest, cchSize)                SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHTCharToUnicodeCP(uiCP, wzSrc, wzDest, cchSize)        SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHTCharToAnsi(wzSrc, szDest, cchSize)                   SHUnicodeToAnsi(wzSrc, szDest, cchSize)
#define SHTCharToAnsiCP(uiCP, wzSrc, szDest, cchSize)           SHUnicodeToAnsiCP(uiCP, wzSrc, szDest, cchSize)
#define SHUnicodeToTChar(wzSrc, wzDest, cchSize)                SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHUnicodeToTCharCP(uiCP, wzSrc, wzDest, cchSize)        SHUnicodeToUnicode(wzSrc, wzDest, cchSize)
#define SHAnsiToTChar(szSrc, wzDest, cchSize)                   SHAnsiToUnicode(szSrc, wzDest, cchSize)
#define SHAnsiToTCharCP(uiCP, szSrc, wzDest, cchSize)           SHAnsiToUnicodeCP(uiCP, szSrc, wzDest, cchSize)
#define SHOtherToTChar(szSrc, szDest, cchSize)                  SHAnsiToUnicode(szSrc, szDest, cchSize)
#define SHTCharToOther(szSrc, szDest, cchSize)                  SHUnicodeToAnsi(szSrc, szDest, cchSize)
#else // UNICODE
#define SHTCharToUnicode(szSrc, wzDest, cchSize)                SHAnsiToUnicode(szSrc, wzDest, cchSize)
#define SHTCharToUnicodeCP(uiCP, szSrc, wzDest, cchSize)        SHAnsiToUnicodeCP(uiCP, szSrc, wzDest, cchSize)
#define SHTCharToAnsi(szSrc, szDest, cchSize)                   SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHTCharToAnsiCP(uiCP, szSrc, szDest, cchSize)           SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHUnicodeToTChar(wzSrc, szDest, cchSize)                SHUnicodeToAnsi(wzSrc, szDest, cchSize)
#define SHUnicodeToTCharCP(uiCP, wzSrc, szDest, cchSize)        SHUnicodeToAnsiCP(uiCP, wzSrc, szDest, cchSize)
#define SHAnsiToTChar(szSrc, szDest, cchSize)                   SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHAnsiToTCharCP(uiCP, szSrc, szDest, cchSize)           SHAnsiToAnsi(szSrc, szDest, cchSize)
#define SHOtherToTChar(szSrc, szDest, cchSize)                  SHUnicodeToAnsi(szSrc, szDest, cchSize)
#define SHTCharToOther(szSrc, szDest, cchSize)                  SHAnsiToUnicode(szSrc, szDest, cchSize)
#endif // UNICODE

// Internal HRESULT-to-help-topic mapping structure
typedef struct _tagHRESULTHELPMAPPING
{
    HRESULT hr;
    LPCSTR   szHelpFile;
    LPCSTR   szHelpTopic;
} HRESULTHELPMAPPING;

LWSTDAPI_(BOOL)    SHRegisterClassA(const WNDCLASSA* pwc);
LWSTDAPI_(BOOL)    SHRegisterClassW(const WNDCLASSW* pwc);
LWSTDAPI_(void)    SHUnregisterClassesA(HINSTANCE hinst, const LPCSTR *rgpszClasses, UINT cpsz);
LWSTDAPI_(void)    SHUnregisterClassesW(HINSTANCE hinst, const LPCWSTR *rgpszClasses, UINT cpsz);
LWSTDAPI_(int) SHMessageBoxHelpW(HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType, HRESULT hrErr, HRESULTHELPMAPPING* prghhm, DWORD chhm);
LWSTDAPI_(int) SHMessageBoxHelpA(HWND hwnd, LPCSTR pszText, LPCSTR pszCaption, UINT uType, HRESULT hrErr, HRESULTHELPMAPPING* prghhm, DWORD chhm);
LWSTDAPI_(int) SHMessageBoxCheckW(HWND hwnd, LPCWSTR pszText, LPCWSTR pszCaption, UINT uType, int iDefault, LPCWSTR pszRegVal);
LWSTDAPI_(int) SHMessageBoxCheckA(HWND hwnd, LPCSTR pszText, LPCSTR pszCaption, UINT uType, int iDefault, LPCSTR pszRegVal);
LWSTDAPI_(void) SHRestrictedMessageBox(HWND hwnd);
LWSTDAPI_(HMENU) SHGetMenuFromID(HMENU hmMain, UINT uID);
LWSTDAPI_(int) SHMenuIndexFromID(HMENU hm, UINT id);
LWSTDAPI_(void) SHRemoveDefaultDialogFont(HWND hDlg);
LWSTDAPI_(void) SHSetDefaultDialogFont(HWND hDlg, int idCtl);
LWSTDAPI_(void) SHRemoveAllSubMenus(HMENU hmenu);
LWSTDAPI_(void) SHEnableMenuItem(HMENU hmenu, UINT id, BOOL fEnable);
LWSTDAPI_(void) SHCheckMenuItem(HMENU hmenu, UINT id, BOOL fChecked);
LWSTDAPI_(DWORD) SHSetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue);
LWSTDAPI_(HMENU) SHLoadMenuPopup(HINSTANCE hinst, UINT id);

#define SPM_POST        0x0000
#define SPM_SEND        0x0001
#define SPM_ONELEVEL    0x0002  // default: send to all descendants including grandkids, etc.

LWSTDAPI_(void) SHPropagateMessage(HWND hwndParent, UINT uMsg, WPARAM wParam, LPARAM lParam, int iFlags);
LWSTDAPI_(void) SHSetParentHwnd(HWND hwnd, HWND hwndParent);
LWSTDAPI_(UINT) SHGetCurColorRes();
LWSTDAPI_(DWORD) SHWaitForSendMessageThread(HANDLE hThread, DWORD dwTimeout);
LWSTDAPI SHWaitForCOMSendMessageThread(HANDLE hThread, DWORD dwTimeout);
LWSTDAPI_(BOOL) SHVerbExistsNA(LPCSTR szExtension, LPCSTR pszVerb, LPSTR pszCommand, DWORD cchCommand);
LWSTDAPI_(void) SHFillRectClr(HDC hdc, LPRECT prc, COLORREF clr);
LWSTDAPI_(int) SHSearchMapInt(const int *src, const int *dst, int cnt, int val);
LWSTDAPI_(CHAR) SHStripMneumonicA(LPSTR pszMenu);
LWSTDAPI_(WCHAR) SHStripMneumonicW(LPWSTR pszMenu);
LWSTDAPI SHIsChildOrSelf(HWND hwndParent, HWND hwnd);
LWSTDAPI_(DWORD) SHGetValueGoodBootA(HKEY hkeyParent, LPCSTR pcszSubKey,
                                   LPCSTR pcszValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen);
LWSTDAPI_(DWORD) SHGetValueGoodBootW(HKEY hkeyParent, LPCWSTR pcwzSubKey,
                                   LPCWSTR pcwzValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen);
LWSTDAPI_(LRESULT) SHDefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


LWSTDAPI_(BOOL) SHGetFileDescriptionA(LPCSTR pszPath, LPCSTR pszVersionKeyIn, LPCSTR pszCutListIn, LPSTR pszDesc, UINT *pcchDesc);
LWSTDAPI_(BOOL) SHGetFileDescriptionW(LPCWSTR pszPath, LPCWSTR pszVersionKeyIn, LPCWSTR pszCutListIn, LPWSTR pszDesc, UINT *pcchDesc);
#ifdef UNICODE
#define SHGetFileDescription  SHGetFileDescriptionW
#else
#define SHGetFileDescription  SHGetFileDescriptionA
#endif // !UNICODE

LWSTDAPI_(int) SHMessageBoxCheckExA(HWND hwnd, HINSTANCE hinst, LPCSTR pszTemplateName, DLGPROC pDlgProc, LPVOID pData, int iDefault, LPCSTR pszRegVal);
LWSTDAPI_(int) SHMessageBoxCheckExW(HWND hwnd, HINSTANCE hinst, LPCWSTR pszTemplateName, DLGPROC pDlgProc, LPVOID pData, int iDefault, LPCWSTR pszRegVal);
#ifdef UNICODE
#define SHMessageBoxCheckEx  SHMessageBoxCheckExW
#else
#define SHMessageBoxCheckEx  SHMessageBoxCheckExA
#endif // !UNICODE

#define IDC_MESSAGEBOXCHECKEX 0x1202

// Prevents shell hang do to hung window on broadcast
LWSTDAPI_(LRESULT) SHSendMessageBroadcastA(UINT uMsg, WPARAM wParam, LPARAM lParam);
// Prevents shell hang do to hung window on broadcast
LWSTDAPI_(LRESULT) SHSendMessageBroadcastW(UINT uMsg, WPARAM wParam, LPARAM lParam);
#ifdef UNICODE
#define SHSendMessageBroadcast  SHSendMessageBroadcastW
#else
#define SHSendMessageBroadcast  SHSendMessageBroadcastA
#endif // !UNICODE

#ifdef UNICODE
#define SHGetValueGoodBoot      SHGetValueGoodBootW
#define SHStripMneumonic        SHStripMneumonicW
#define SHMessageBoxHelp        SHMessageBoxHelpW
#define SHMessageBoxCheck       SHMessageBoxCheckW
#define SHRegisterClass         SHRegisterClassW
#define SHUnregisterClasses     SHUnregisterClassesW
#define SHSendMessageBroadcast  SHSendMessageBroadcastW
#else // UNICODE
#define SHGetValueGoodBoot      SHGetValueGoodBootA
#define SHStripMneumonic        SHStripMneumonicA
#define SHMessageBoxHelp        SHMessageBoxHelpA
#define SHMessageBoxCheck       SHMessageBoxCheckA
#define SHRegisterClass         SHRegisterClassA
#define SHUnregisterClasses     SHUnregisterClassesA
#define SHSendMessageBroadcast  SHSendMessageBroadcastA
#endif // UNICODE


// old IsOS() flags -- don't use these
// we have to keep them public since we shipped them in win2k
#define OS_MEMPHIS                  OS_WIN98ORGREATER   // don't use this
#define OS_MEMPHIS_GOLD             OS_WIN98_GOLD       // don't use this
#define OS_WIN95GOLD                OS_WIN95_GOLD
#define OS_WIN2000EMBED             OS_EMBEDDED
#define OS_WIN2000                  OS_WIN2000ORGREATER // lame, but IsOS(WIN2000) meant >= win2k
#define OS_WIN95                    OS_WIN95ORGREATER   // lame, but IsOS(WIN95) meant >= win95
#define OS_NT4                      OS_NT4ORGREATER     // lame, but IsOS(NT4) meant >= NT4
#define OS_NT5                      OS_WIN2000ORGREATER // lame, but IsOS(NT5) meant >= wink2
#define OS_WIN98                    OS_WIN98ORGREATER   // lame, but IsOS(OS_WIN98) meant >= win98
#define OS_MILLENNIUM               OS_MILLENNIUMORGREATER  // lame, but IsOS(OS_MILLENNIUM) meant >= winMe
// end old flags


// Returns TRUE/FALSE depending on question
#define OS_WINDOWS                  0           // windows vs. NT
#define OS_NT                       1           // windows vs. NT
#define OS_WIN95ORGREATER           2           // Win95 or greater
#define OS_NT4ORGREATER             3           // NT4 or greater
// don't use (used to be OS_NT5)    4           // this flag is redundant w/ OS_WIN2000ORGREATER, use that instead
#define OS_WIN98ORGREATER           5           // Win98 or greater
#define OS_WIN98_GOLD               6           // Win98 Gold (Version 4.10 build 1998)
#define OS_WIN2000ORGREATER         7           // Some derivative of Win2000

// NOTE: these flags are bogus, they check explicitly for (dwMajorVersion == 5) so they will fail when majorversion is bumped to 6
// !!! DO NOT USE THESE FLAGS !!!
#define OS_WIN2000PRO               8           // Windows 2000 Professional (Workstation)
#define OS_WIN2000SERVER            9           // Windows 2000 Server
#define OS_WIN2000ADVSERVER         10          // Windows 2000 Advanced Server
#define OS_WIN2000DATACENTER        11          // Windows 2000 Data Center Server
#define OS_WIN2000TERMINAL          12          // Windows 2000 Terminal Server in "Application Server" mode (now simply called "Terminal Server")
// END bogus flags

#define OS_EMBEDDED                 13          // Embedded Windows Edition
#define OS_TERMINALCLIENT           14          // Windows Terminal Client (eg user is comming in via tsclient)
#define OS_TERMINALREMOTEADMIN      15          // Terminal Server in "Remote Administration" mode
#define OS_WIN95_GOLD               16          // Windows 95 Gold (Version 4.0 Build 1995)
#define OS_MILLENNIUMORGREATER      17          // Windows Millennium (Version 5.0)

// BUGBUG - when were these added?? We didn't ship win2k w/ these, right?
#define OS_WHISTLERORGREATER        18          // Whistler or greater
#define OS_PERSONAL                 19          // Personal (eg NOT Professional, Server, Advanced Server, or Datacenter)
#if (_WIN32_IE >= 0x0600)
#define OS_PROFESSIONAL             20          // Professional     (aka Workstation; eg NOT Server, Advanced Server, or Datacenter)
#define OS_DATACENTER               21          // Datacenter       (eg NOT Server, Advanced Server, Professional, or Personal)
#define OS_ADVSERVER                22          // Advanced Server  (eg NOT Datacenter, Server, Professional, or Personal) 
#define OS_SERVER                   23          // Server           (eg NOT Datacenter, Advanced Server, Professional, or Personal) 

#define OS_TERMINALSERVER           24          // Terminal Server - server running in what used to be called "Application Server" mode (now simply called "Terminal Server")
//      OS_TERMINALREMOTEADMIN      15          // Terminal Server - server running in "Remote Administration" mode
#define OS_PERSONALTERMINALSERVER   25          // Personal Terminal Server - per/pro machine running in single user TS mode
#define OS_FASTUSERSWITCHING        26          // Fast User Switching
#define OS_FRIENDLYLOGONUI          27          // New friendly logon UI
#define OS_DOMAINMEMBER             28          // Is this machine a member of a domain (eg NOT a workgroup)
#define OS_ANYSERVER                29          // is this machine any type of server? (eg datacenter or advanced server or server)?
#define OS_WOW6432                  30          // Is this process a 32-bit process running on an 64-bit platform?
#define OS_TABLETPC                 33          // Are we running on a TabletPC?

#define OS_MEDIACENTER              35          // eHome Freestyle Project

#endif // _WIN32_IE >= 0x0600

LWSTDAPI_(BOOL) IsOS(DWORD dwOS);

///// BEGIN Private CommandTarget helpers
//***   IOleCommandTarget helpers {

//***   octd -- OleCT direction
// NOTES
//  used both as a return value from IsXxxForward, and as an iUpDown
//  param for MayXxxForward.
enum octd {
    // do *not* change these values; we rely upon all 3 of:
    //  - sign +/-
    //  - powers of 2
    //  - (?) broadcast > down
    OCTD_DOWN=+1,
    OCTD_DOWNBROADCAST=+2,
    OCTD_UP=-1
};


#ifndef RC_INVOKED /* { rc doesn't like these long symbol names */
#ifdef __IOleCommandTarget_INTERFACE_DEFINED__
    HRESULT IsQSForward(const GUID *pguidCmdGroup, int cCmds, OLECMD rgCmds[]);
    // WARNING: note the hoaky cast of nCmdID to a struct ptr
    #define IsExecForward(pguidCmdGroup, nCmdID) \
        IsQSForward(pguidCmdGroup, 1, (OLECMD *) &nCmdID)

    HRESULT MayQSForward(IUnknown *punk, int iUpDown, const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    HRESULT MayExecForward(IUnknown *punk, int iUpDown, const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
#endif //__IOleCommandTarget_INTERFACE_DEFINED__
#endif  /* } !RC_INVOKED */
// }
///// end



typedef struct _FDSA {
    // cItem *must* be at beginning of struct for GetItemCount() to work
    int     cItem;          // # elements
    void *  aItem;          // data for elements (either static or dynamic)
    int     cItemAlloc;     // # of elements currently alloc'ed (>= cItem)
    int     cItemGrow:8;    // # of elements to grow cItemAlloc by
    int     cbItem:8;       // sizeof element
    DWORD   fAllocated:1;   // 1:overflowed from static to dynamic array
    DWORD     unused:15;
} FDSA, *PFDSA;

LWSTDAPI_(BOOL)  FDSA_Initialize(int cbItem, int cItemGrow, PFDSA pfdsa, void * aItemStatic, int cItemStatic);
LWSTDAPI_(BOOL)  FDSA_Destroy(PFDSA pfdsa);
LWSTDAPI_(int)   FDSA_InsertItem(PFDSA pfdsa, int index, void * pitem);
LWSTDAPI_(BOOL)  FDSA_DeleteItem(PFDSA pfdsa, int index);

#define FDSA_AppendItem(pfdsa, pitem)       FDSA_InsertItem(pfdsa, DA_LAST, pitem)
#define FDSA_GetItemPtr(pfdsa, i, type)     (&(((type *)((pfdsa)->aItem))[(i)]))
#define FDSA_GetItemCount(hdsa)      (*(int *)(hdsa))




#if defined( __LPGUID_DEFINED__ )
// Copied from OLE source code
// format for string form of GUID is:
// ????{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

LWSTDAPI_(BOOL) GUIDFromStringA(LPCSTR psz, LPGUID pguid);
LWSTDAPI_(BOOL) GUIDFromStringW(LPCWSTR psz, LPGUID pguid);
#ifdef UNICODE
#define GUIDFromString  GUIDFromStringW
#else
#define GUIDFromString  GUIDFromStringA
#endif // !UNICODE

#endif

#ifdef _REFGUID_DEFINED
LWSTDAPI_(int) SHStringFromGUIDA(UNALIGNED REFGUID rguid, LPSTR psz, int cchMax);
LWSTDAPI_(int) SHStringFromGUIDW(UNALIGNED REFGUID rguid, LPWSTR psz, int cchMax);
#ifdef UNICODE
#define SHStringFromGUID  SHStringFromGUIDW
#else
#define SHStringFromGUID  SHStringFromGUIDA
#endif // !UNICODE

LWSTDAPI SHRegGetCLSIDKeyA(UNALIGNED REFGUID rguid, LPCSTR lpszSubKey, BOOL fUserSpecific, BOOL fCreate, HKEY *phkey);
LWSTDAPI SHRegGetCLSIDKeyW(UNALIGNED REFGUID rguid, LPCWSTR lpszSubKey, BOOL fUserSpecific, BOOL fCreate, HKEY *phkey);
#ifdef UNICODE
#define SHRegGetCLSIDKey  SHRegGetCLSIDKeyW
#else
#define SHRegGetCLSIDKey  SHRegGetCLSIDKeyA
#endif // !UNICODE

LWSTDAPI_(HANDLE) SHGlobalCounterCreate(REFGUID rguid);
LWSTDAPI_(HANDLE) SHGlobalCounterCreateNamedA(LPCSTR szName, LONG lInitialValue);
LWSTDAPI_(HANDLE) SHGlobalCounterCreateNamedW(LPCWSTR szName, LONG lInitialValue);
#ifdef UNICODE
#define SHGlobalCounterCreateNamed  SHGlobalCounterCreateNamedW
#else
#define SHGlobalCounterCreateNamed  SHGlobalCounterCreateNamedA
#endif // !UNICODE
LWSTDAPI_(long) SHGlobalCounterGetValue(HANDLE hCounter);
LWSTDAPI_(long) SHGlobalCounterIncrement(HANDLE hCounter);
LWSTDAPI_(long) SHGlobalCounterDecrement(HANDLE hCounter);
#define         SHGlobalCounterDestroy      CloseHandle
#endif

// WNDPROCs are thunked by user to send ANSI/UNICODE messages (ex: WM_WININICHANGE)
// so providing a W version that automatically thunks to the A version
// is dangerous.  but we do it anyway.  if a caller needs to work on both win95 and NT
// it needs to be aware that on win95 the W version actually calls the A version.
// thus all worker windows on win95 are ANSI.  this should rarely affect worker wndprocs
// because they are internal, and the messages are usually custom.  but system messages
// like WM_WININICHANGE, and the WM_DDE* messages will be changed accordingly
HWND SHCreateWorkerWindowA(WNDPROC pfnWndProc, HWND hwndParent, DWORD dwExStyle, DWORD dwFlags, HMENU hmenu, void * p);
HWND SHCreateWorkerWindowW(WNDPROC pfnWndProc, HWND hwndParent, DWORD dwExStyle, DWORD dwFlags, HMENU hmenu, void * p);
#ifdef UNICODE
#define SHCreateWorkerWindow SHCreateWorkerWindowW
#else
#define SHCreateWorkerWindow SHCreateWorkerWindowA
#endif

BOOL    SHAboutInfoA(LPSTR lpszInfo, DWORD cchSize);
BOOL    SHAboutInfoW(LPWSTR lpszInfo, DWORD cchSize);

#ifdef UNICODE
#define SHAboutInfo SHAboutInfoW
#else
#define SHAboutInfo SHAboutInfoA
#endif

// Types for SHIsLowMemoryMachine
#define ILMM_IE4    0       // 1997-style machine

LWSTDAPI_(BOOL) SHIsLowMemoryMachine(DWORD dwType);

LWSTDAPI_(HINSTANCE) SHPinDllOfCLSID(const CLSID *pclsid);

// Menu Helpers
LWSTDAPI_(int)  GetMenuPosFromID(HMENU hmenu, UINT id);

LWSTDAPI        SHGetInverseCMAP(BYTE *pbMap, ULONG cbMap);

//
// Shared memory apis
//

LWSTDAPI_(HANDLE)   SHAllocShared(const void *pvData, DWORD dwSize, DWORD dwProcessId);
LWSTDAPI_(BOOL)     SHFreeShared(HANDLE hData,DWORD dwProcessId);
LWSTDAPI_(void *)   SHLockShared(HANDLE hData, DWORD dwProcessId);
LWSTDAPI_(void *)   SHLockSharedEx(HANDLE hData, DWORD dwProcessId, BOOL fForWriting);
LWSTDAPI_(BOOL)     SHUnlockShared(void *pvData);
LWSTDAPI_(HANDLE)   SHMapHandle(HANDLE h, DWORD dwProcSrc, DWORD dwProcDest, DWORD dwDesiredAccess, DWORD dwFlags);

//
// Shared memory structs
//

#define MAPHEAD_SIG     0xbaff1aff

typedef struct _shmapheader {
    DWORD dwSize;
    DWORD dwSig;
    DWORD dwSrcId;
    DWORD dwDstId;
} SHMAPHEADER;  // NOTE: should always be QUADWORD alignment


#ifdef UNIX
#include <urlmon.h>
#endif /* UNIX */

//
//  Zone Security APIs
//
LWSTDAPI ZoneCheckPathA(LPCSTR pszPath, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);
LWSTDAPI ZoneCheckPathW(LPCWSTR pwzPath, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);

LWSTDAPI ZoneCheckUrlA(LPCSTR pszUrl, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);
LWSTDAPI ZoneCheckUrlW(LPCWSTR pwzUrl, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);
LWSTDAPI ZoneCheckUrlExA(LPCSTR pszUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext, DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);
LWSTDAPI ZoneCheckUrlExW(LPCWSTR pwzUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext, DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms);
LWSTDAPI ZoneCheckUrlExCacheA(LPCSTR pszUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext, DWORD dwContextSize,
                            DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms, IInternetSecurityManager ** ppismCache);
LWSTDAPI ZoneCheckUrlExCacheW(LPCWSTR pwzUrl, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext, DWORD dwContextSize,
                            DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms, IInternetSecurityManager ** ppismCache);

LWSTDAPI ZoneCheckHost(IInternetHostSecurityManager * pihsm, DWORD dwActionType, DWORD dwFlags);
LWSTDAPI ZoneCheckHostEx(IInternetHostSecurityManager * pihsm, DWORD * pdwPolicy, DWORD dwPolicySize, DWORD * pdwContext,
                        DWORD dwContextSize, DWORD dwActionType, DWORD dwFlags);
LWSTDAPI_(int) ZoneComputePaneSize(HWND hwndStatus);
LWSTDAPI_(void) ZoneConfigureW(HWND hwnd, LPCWSTR pwszUrl);

#ifdef UNICODE
#define ZoneCheckUrl            ZoneCheckUrlW
#define ZoneCheckPath           ZoneCheckPathW
#define ZoneCheckUrlEx          ZoneCheckUrlExW
#define ZoneCheckUrlExCache     ZoneCheckUrlExCacheW
#else // UNICODE
#define ZoneCheckUrl            ZoneCheckUrlA
#define ZoneCheckPath           ZoneCheckPathA
#define ZoneCheckUrlEx          ZoneCheckUrlExA
#define ZoneCheckUrlExCache     ZoneCheckUrlExCacheA
#endif // UNICODE

LWSTDAPI SHRegisterValidateTemplate(LPCWSTR pwzTemplate, DWORD dwFlags);

// Flags for SHRegisterValidateTemplate
#define SHRVT_REGISTER                  0x00000001
#define SHRVT_VALIDATE                  0x00000002
#define SHRVT_PROMPTUSER                0x00000004
#define SHRVT_REGISTERIFPROMPTOK        0x00000008
#define SHRVT_ALLOW_INTRANET            0x00000010
#define SHRVT_VALID                     0x0000001f

BOOL RegisterGlobalHotkeyW(WORD wOldHotkey, WORD wNewHotkey,LPCWSTR pcwszPath);
BOOL RegisterGlobalHotkeyA(WORD wOldHotkey, WORD wNewHotkey,LPCSTR pcszPath);

LWSTDAPI_(UINT) WhichPlatform(void);

// Return values of WhichPlatform
#define PLATFORM_UNKNOWN     0
#define PLATFORM_IE3         1      // obsolete: use PLATFORM_BROWSERONLY
#define PLATFORM_BROWSERONLY 1      // browser-only (no new shell)
#define PLATFORM_INTEGRATED  2      // integrated shell

#ifdef UNICODE
#define RegisterGlobalHotkey    RegisterGlobalHotkeyW
#else // UNICODE
#define RegisterGlobalHotkey    RegisterGlobalHotkeyA
#endif // UNICODE

// qistub {

//***   QueryInterface helpers
// NOTES
//  ATL has a fancier version of this.  if we need to extend ours, we
//  should probably just switch to ATL's rather than reinvent.
// EXAMPLE
//  Cfoo::QI(REFIID riid, void **ppv)
//  {
//      // (the IID_xxx comments make grep'ing work!)
//      static const QITAB qit = {
//          QITABENT(Cfoo, Iiface1),    // IID_Iiface1
//          ...
//          QITABENT(Cfoo, IifaceN),    // IID_IifaceN
//          { 0 },                      // n.b. don't forget the 0
//      };
//
//      // n.b. make sure you don't cast 'this'
//      hr = QISearch(this, qit, riid, ppv);
//      if (FAILED(hr))
//          hr = SUPER::QI(riid, ppv);
//      // custom code could be added here for FAILED() case
//      return hr;
//  }

typedef struct
{
    const IID * piid;
    int         dwOffset;
} QITAB, *LPQITAB;
typedef const QITAB *LPCQITAB;

#define QITABENTMULTI(Cthis, Ifoo, Iimpl) \
    { (IID*) &IID_##Ifoo, OFFSETOFCLASS(Iimpl, Cthis) }

#define QITABENTMULTI2(Cthis, Ifoo, Iimpl) \
    { (IID*) &Ifoo, OFFSETOFCLASS(Iimpl, Cthis) }

#define QITABENT(Cthis, Ifoo) QITABENTMULTI(Cthis, Ifoo, Ifoo)

STDAPI QISearch(void* that, LPCQITAB pqit, REFIID riid, void **ppv);


#ifndef STATIC_CAST
//***   STATIC_CAST -- 'portable' static_cast<>
// NOTES
//  do *not* use SAFE_CAST (see comment in OFFSETOFCLASS)
#define STATIC_CAST(typ)   static_cast<typ>
#ifndef _X86_
    // assume only intel compiler (>=vc5) supports static_cast for now
    // we could key off of _MSC_VER >= 1100 but i'm not sure that will work
    //
    // a straight cast will give the correct result but no error checking,
    // so we'll have to catch errors on intel.
    #undef  STATIC_CAST
    #define STATIC_CAST(typ)   (typ)
#endif
#endif

#ifndef OFFSETOFCLASS
//***   OFFSETOFCLASS -- (stolen from ATL)
// we use STATIC_CAST not SAFE_CAST because the compiler gets confused
// (it doesn't constant-fold the ,-op in SAFE_CAST so we end up generating
// code for the table!)

#define OFFSETOFCLASS(base, derived) \
    ((DWORD)(DWORD_PTR)(STATIC_CAST(base*)((derived*)8))-8)
#endif

// } qistub


#if (_WIN32_IE >= 0x0500)

// SHRestrictionLookup
typedef struct
{
    INT     iFlag;
    LPCWSTR pszKey;
    LPCWSTR pszValue;
} SHRESTRICTIONITEMS;

LWSTDAPI_(DWORD) SHRestrictionLookup(INT iFlag, LPCWSTR pszBaseKey,
                                     const SHRESTRICTIONITEMS *pRestrictions,
                                     DWORD* rdwRestrictionItemValues);
LWSTDAPI_(DWORD) SHGetRestriction(LPCWSTR pszBaseKey, LPCWSTR pszGroup, LPCWSTR pszSubKey);

typedef INT_PTR (CALLBACK* SHDLGPROC)(void *lpData, HWND, UINT, WPARAM, LPARAM);
LWSTDAPI_(INT_PTR) SHDialogBox(HINSTANCE hInstance, LPCWSTR lpTemplateName,
    HWND hwndParent, SHDLGPROC lpDlgFunc, void*lpData);

LWSTDAPI SHInvokeDefaultCommand(HWND hwnd, struct IShellFolder* psf, LPCITEMIDLIST pidl);
LWSTDAPI SHInvokeCommand(HWND hwnd, struct IShellFolder* psf, LPCITEMIDLIST pidl, LPCSTR lpVerb);
LWSTDAPI SHInvokeCommandOnContextMenu(HWND hwnd, struct IUnknown* punk, struct IContextMenu *pcm, DWORD fMask, LPCSTR lpVerb);
LWSTDAPI SHInvokeCommandsOnContextMenu(HWND hwnd, struct IUnknown* punk, struct IContextMenu *pcm, DWORD fMask, const LPCSTR rgszVerbs[], UINT cVerbs);
LWSTDAPI SHForwardContextMenuMsg(struct IContextMenu* pcm, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult, BOOL fAllowICM2);
LWSTDAPI IUnknown_DoContextMenuPopup(struct IUnknown *punkSite, struct IContextMenu* pcm, UINT fFlags, POINT pt);

#endif // _WIN32_IE >= 0x0500

//============= Internal Routines that are always to be built ================
LWSTDAPI_(DWORD)
GetLongPathNameWrapW(
        LPCWSTR lpszShortPath,
        LPWSTR lpszLongPath,
        DWORD cchBuffer);

LWSTDAPI_(DWORD)
GetLongPathNameWrapA(
        LPCSTR lpszShortPath,
        LPSTR lpszLongPath,
        DWORD cchBuffer);

#ifdef UNICODE
#define GetLongPathNameWrap         GetLongPathNameWrapW
#else
#define GetLongPathNameWrap         GetLongPathNameWrapA
#endif //UNICODE


//=============== Unicode Wrapper Routines ===================================

#if (_WIN32_IE >= 0x0500) && !defined(NO_SHLWAPI_UNITHUNK)

//
//  There are two styles of usage for the wrap functions.
//
//  *   Explicit wrapping.
//
//      If you explicitly call GetPropWrap (for example), then
//      your UNICODE build will call the wrapper function, and your ANSI
//      build will call the normal ANSI API directly.
//
//      Calls to GetProp, GetPropW, and GetPropA still go
//      directly to the underlying system DLL that implements them.
//
//      This lets you select which calls to UNICODE APIs should get
//      wrapped and which should go straight through to the OS
//      (and most likely fail on Win95).
//
//  *   Automatic wrapping.
//
//      If you #include <w95wraps.h>, then when you call GetProp,
//      your UNICODE build will call the wrapper function, and your ANSI
//      ANSI build will call the normal ANSI API directly.
//
//      This lets you just call the UNICODE APIs normally throughout
//      your code, and the wrappers will do their best.
//
//  Here's a table explaining what you get under the various scenarios.
//
//                    You Get
//                                                <w95wraps.h>  <w95wraps.h>
//      You Write     UNICODE       ANSI          UNICODE       ANSI
//      ============  ============  ============  ============  ============
//      GetProp       GetPropW      GetPropA      GetPropWrapW  GetPropA
//      GetPropWrap   GetPropWrapW  GetPropA      GetPropWrapW  GetPropA
//
//      GetPropW      GetPropW      GetPropW      GetPropWrapW  GetPropWrapW
//      GetPropA      GetPropA      GetPropA      GetPropA      GetPropA
//      GetPropWrapW  GetPropWrapW  GetPropWrapW  GetPropWrapW  GetPropWrapW
//      GetPropWrapA  GetPropA      GetPropA      GetPropA      GetPropA
//
//  Final quirk:  If you are running on a non-x86 platform, then the
//  wrap functions are forwarded to the unwrapped functions, since
//  the only OS that runs on non-x86 is NT.
//
//  Before using the wrapper functions, see the warnings at the top of
//  <w95wraps.h> to make sure you understand the consequences.
//
LWSTDAPI_(BOOL) IsCharAlphaWrapW(IN WCHAR ch);
LWSTDAPI_(BOOL) IsCharUpperWrapW(IN WCHAR ch);
LWSTDAPI_(BOOL) IsCharLowerWrapW(IN WCHAR ch);
LWSTDAPI_(BOOL) IsCharAlphaNumericWrapW(IN WCHAR ch);

LWSTDAPI_(BOOL)
AppendMenuWrapW(
    IN HMENU hMenu,
    IN UINT uFlags,
    IN UINT_PTR uIDNewItem,
    IN LPCWSTR lpNewItem
    );

LWSTDAPI_(LRESULT)
CallWindowProcWrapW(
    WNDPROC lpPrevWndFunc,
    HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam);

#ifdef POST_IE5_BETA
LWSTDAPI_(BOOL) CallMsgFilterWrapW(LPMSG lpMsg, int nCode);
#endif

LWSTDAPI_(LPWSTR) CharLowerWrapW( LPWSTR pch );

LWSTDAPI_(DWORD)  CharLowerBuffWrapW( LPWSTR pch, DWORD cchLength );

LWSTDAPI_(LPWSTR) CharNextWrapW(LPCWSTR lpszCurrent);
LWSTDAPI_(LPWSTR) CharPrevWrapW(LPCWSTR lpszStart, LPCWSTR lpszCurrent);
LWSTDAPI_(BOOL)   CharToOemWrapW(LPCWSTR lpszSrc, LPSTR lpszDst);
LWSTDAPI_(LPWSTR) CharUpperWrapW( LPWSTR pch );
LWSTDAPI_(DWORD)  CharUpperBuffWrapW( LPWSTR pch, DWORD cchLength );

LWSTDAPI_(HRESULT) CLSIDFromStringWrap(LPOLESTR lpsz, LPCLSID pclsid);
LWSTDAPI_(HRESULT) CLSIDFromProgIDWrap(LPCOLESTR lpszProgID, LPCLSID lpclsid);

LWSTDAPI_(int)
CompareStringWrapW(
    LCID     Locale,
    DWORD    dwCmpFlags,
    LPCWSTR lpString1,
    int      cchCount1,
    LPCWSTR lpString2,
    int      cchCount2);

LWSTDAPI_(int)
CopyAcceleratorTableWrapW(
        HACCEL  hAccelSrc,
        LPACCEL lpAccelDst,
        int     cAccelEntries);

LWSTDAPI_(HACCEL)
CreateAcceleratorTableWrapW(LPACCEL lpAccel, int cEntries);

LWSTDAPI_(HDC)
CreateDCWrapW(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData);

LWSTDAPI_(BOOL)
CreateDirectoryWrapW(
        LPCWSTR                 lpPathName,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes);

LWSTDAPI_(HANDLE)
CreateEventWrapW(
        LPSECURITY_ATTRIBUTES   lpEventAttributes,
        BOOL                    bManualReset,
        BOOL                    bInitialState,
        LPCWSTR                 lpName);

LWSTDAPI_(HANDLE)
CreateFileWrapW(
        LPCWSTR                 lpFileName,
        DWORD                   dwDesiredAccess,
        DWORD                   dwShareMode,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
        DWORD                   dwCreationDisposition,
        DWORD                   dwFlagsAndAttributes,
        HANDLE                  hTemplateFile);


LWSTDAPI_(HFONT)
CreateFontIndirectWrapW(CONST LOGFONTW * plfw);

LWSTDAPI_(HDC)
CreateICWrapW(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData);

LWSTDAPI_(HWND)
CreateWindowExWrapW(
        DWORD       dwExStyle,
        LPCWSTR     lpClassName,
        LPCWSTR     lpWindowName,
        DWORD       dwStyle,
        int         X,
        int         Y,
        int         nWidth,
        int         nHeight,
        HWND        hWndParent,
        HMENU       hMenu,
        HINSTANCE   hInstance,
        void *     lpParam);

LWSTDAPI_(LRESULT)
DefWindowProcWrapW(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);

LWSTDAPI_(BOOL) DeleteFileWrapW(LPCWSTR pwsz);

LWSTDAPI_(LRESULT)
DispatchMessageWrapW(CONST MSG * lpMsg);

LWSTDAPI_(int)
DrawTextWrapW(
        HDC     hDC,
        LPCWSTR lpString,
        int     nCount,
        LPRECT  lpRect,
        UINT    uFormat);

LWSTDAPI_(int)
EnumFontFamiliesWrapW(
        HDC          hdc,
        LPCWSTR      lpszFamily,
        FONTENUMPROCW lpEnumFontProc,
        LPARAM       lParam);

LWSTDAPI_(int)
EnumFontFamiliesExWrapW(
        HDC          hdc,
        LPLOGFONTW   lplfw,
        FONTENUMPROCW lpEnumFontProc,
        LPARAM       lParam,
        DWORD        dwFlags );

LWSTDAPI_(BOOL)
EnumResourceNamesWrapW(
        HINSTANCE        hModule,
        LPCWSTR          lpType,
        ENUMRESNAMEPROCW lpEnumFunc,
        LONG_PTR         lParam);

LWSTDAPI_(BOOL)
ExtTextOutWrapW(
        HDC             hdc,
        int             x,
        int             y,
        UINT            fuOptions,
        CONST RECT *    lprc,
        LPCWSTR         lpString,
        UINT            nCount,
        CONST INT *     lpDx);

LWSTDAPI_(HANDLE)
FindFirstFileWrapW(
        LPCWSTR             lpFileName,
        LPWIN32_FIND_DATAW  pwszFd);

LWSTDAPI_(HRSRC)
FindResourceWrapW(HINSTANCE hModule, LPCWSTR lpName, LPCWSTR lpType);

LWSTDAPI_(HWND)
FindWindowWrapW(LPCWSTR lpClassName, LPCWSTR lpWindowName);

LWSTDAPI_(DWORD)
FormatMessageWrapW(
    DWORD       dwFlags,
    LPCVOID     lpSource,
    DWORD       dwMessageId,
    DWORD       dwLanguageId,
    LPWSTR      lpBuffer,
    DWORD       nSize,
    va_list *   Arguments);

LWSTDAPI_(BOOL)
GetClassInfoWrapW(HINSTANCE hModule, LPCWSTR lpClassName, LPWNDCLASSW lpWndClassW);

LWSTDAPI_(DWORD)
GetClassLongWrapW(HWND hWnd, int nIndex);

LWSTDAPI_(int)
GetClassNameWrapW(HWND hWnd, LPWSTR lpClassName, int nMaxCount);

LWSTDAPI_(int)
GetClipboardFormatNameWrapW(UINT format, LPWSTR lpFormatName, int cchFormatName);

LWSTDAPI_(DWORD)
GetCurrentDirectoryWrapW(DWORD nBufferLength, LPWSTR lpBuffer);

LWSTDAPI_(UINT)
GetDlgItemTextWrapW(
        HWND    hWndDlg,
        int     idControl,
        LPWSTR  lpsz,
        int     cchMax);

LWSTDAPI_(DWORD)
GetFileAttributesWrapW(LPCWSTR lpFileName);

// Cannot be LWSTDAPI because winver.h declares the function as STDAPI and not DLLIMPORT
STDAPI_(BOOL)
GetFileVersionInfoWrapW(LPWSTR pwzFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);

// Cannot be LWSTDAPI because winver.h declares the function as STDAPI and not DLLIMPORT
STDAPI_(DWORD)
GetFileVersionInfoSizeWrapW(LPWSTR pwzFilename,  LPDWORD lpdwHandle);

LWSTDAPI_(DWORD)
GetFullPathNameWrapW( LPCWSTR lpFileName,
                     DWORD  nBufferLength,
                     LPWSTR lpBuffer,
                     LPWSTR *lpFilePart);

LWSTDAPI_(int)
GetLocaleInfoWrapW(LCID Locale, LCTYPE LCType, LPWSTR lpsz, int cchData);

LWSTDAPI_(int)
GetMenuStringWrapW(
        HMENU   hMenu,
        UINT    uIDItem,
        LPWSTR  lpString,
        int     nMaxCount,
        UINT    uFlag);

LWSTDAPI_(BOOL)
GetMessageWrapW(
        LPMSG   lpMsg,
        HWND    hWnd,
        UINT    wMsgFilterMin,
        UINT    wMsgFilterMax);

LWSTDAPI_(DWORD)
GetModuleFileNameWrapW(HINSTANCE hModule, LPWSTR pwszFilename, DWORD nSize);

LWSTDAPI_(UINT)
GetSystemDirectoryWrapW(LPWSTR lpBuffer, UINT uSize);

LWSTDAPI_(DWORD)
GetEnvironmentVariableWrapW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);

LWSTDAPI_(DWORD)
SearchPathWrapW(
        LPCWSTR lpPathName,
        LPCWSTR lpFileName,
        LPCWSTR lpExtension,
        DWORD   cchReturnBuffer,
        LPWSTR  lpReturnBuffer,
        LPWSTR *  plpfilePart);

LWSTDAPI_(HMODULE)
GetModuleHandleWrapW(LPCWSTR lpModuleName);

LWSTDAPI_(int)
GetObjectWrapW(HGDIOBJ hgdiObj, int cbBuffer, void *lpvObj);

LWSTDAPI_(UINT)
GetPrivateProfileIntWrapW(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        INT     nDefault,
        LPCWSTR lpFileName);

LWSTDAPI_(DWORD)
GetProfileStringWrapW(
        LPCWSTR lpAppName,
        LPCWSTR lpKeyName,
        LPCWSTR lpDefault,
        LPWSTR  lpBuffer,
        DWORD   dwBuffersize);

LWSTDAPI_(HANDLE)
GetPropWrapW(HWND hWnd, LPCWSTR lpString);

LWSTDAPI_(ATOM)
GlobalAddAtomWrapW(LPCWSTR lpAtomName);

LWSTDAPI_(ATOM)
GlobalFindAtomWrapW(LPCWSTR lpAtomName);

LWSTDAPI_(DWORD)
GetShortPathNameWrapW(
    LPCWSTR lpszLongPath,
    LPWSTR  lpszShortPath,
    DWORD    cchBuffer);

LWSTDAPI_(BOOL)
GetStringTypeExWrapW(LCID lcid, DWORD dwInfoType, LPCWSTR lpSrcStr, int cchSrc, LPWORD lpCharType);

LWSTDAPI_(UINT)
GetTempFileNameWrapW(
        LPCWSTR lpPathName,
        LPCWSTR lpPrefixString,
        UINT    uUnique,
        LPWSTR  lpTempFileName);

LWSTDAPI_(DWORD)
GetTempPathWrapW(DWORD nBufferLength, LPWSTR lpBuffer);

LWSTDAPI_(BOOL)
GetTextExtentPoint32WrapW(
        HDC     hdc,
        LPCWSTR pwsz,
        int     cb,
        LPSIZE  pSize);

LWSTDAPI_(int)
GetTextFaceWrapW(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName);

LWSTDAPI_(BOOL)
GetTextMetricsWrapW(HDC hdc, LPTEXTMETRICW lptm);

LWSTDAPI_(BOOL)
GetUserNameWrapW(LPWSTR lpUserName, LPDWORD lpcchName);

LWSTDAPI_(LONG)
GetWindowLongWrapW(HWND hWnd, int nIndex);


LWSTDAPI_(int)
GetWindowTextWrapW(HWND hWnd, LPWSTR lpString, int nMaxCount);

LWSTDAPI_(int)
GetWindowTextLengthWrapW(HWND hWnd);

LWSTDAPI_(UINT)
GetWindowsDirectoryWrapW(LPWSTR lpWinPath, UINT cch);

LWSTDAPI_(BOOL)
InsertMenuWrapW(
        HMENU   hMenu,
        UINT    uPosition,
        UINT    uFlags,
        UINT_PTR  uIDNewItem,
        LPCWSTR lpNewItem);

LWSTDAPI_(BOOL)
IsDialogMessageWrapW(HWND hWndDlg, LPMSG lpMsg);

LWSTDAPI_(HACCEL)
LoadAcceleratorsWrapW(HINSTANCE hInstance, LPCWSTR lpTableName);

LWSTDAPI_(HBITMAP)
LoadBitmapWrapW(HINSTANCE hInstance, LPCWSTR lpBitmapName);

LWSTDAPI_(HCURSOR)
LoadCursorWrapW(HINSTANCE hInstance, LPCWSTR lpCursorName);

LWSTDAPI_(HICON)
LoadIconWrapW(HINSTANCE hInstance, LPCWSTR lpIconName);

LWSTDAPI_(HANDLE)
LoadImageWrapA(
        HINSTANCE hInstance,
        LPCSTR lpName,
        UINT uType,
        int cxDesired,
        int cyDesired,
        UINT fuLoad);

LWSTDAPI_(HANDLE)
LoadImageWrapW(
        HINSTANCE hInstance,
        LPCWSTR lpName,
        UINT uType,
        int cxDesired,
        int cyDesired,
        UINT fuLoad);

LWSTDAPI_(HINSTANCE)
LoadLibraryExWrapW(
        LPCWSTR lpLibFileName,
        HANDLE  hFile,
        DWORD   dwFlags);

LWSTDAPI_(HMENU)
LoadMenuWrapW(HINSTANCE hInstance, LPCWSTR lpMenuName);

LWSTDAPI_(int)
LoadStringWrapW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBufferMax);

#ifndef UNIX
LWSTDAPI_(BOOL)
MessageBoxIndirectWrapW(CONST MSGBOXPARAMSW *pmbp);
#else
LWSTDAPI_(int)
MessageBoxIndirectWrapW(LPMSGBOXPARAMSW pmbp);
#endif /* UNIX */

LWSTDAPI_(BOOL)
ModifyMenuWrapW(
        HMENU   hMenu,
        UINT    uPosition,
        UINT    uFlags,
        UINT_PTR uIDNewItem,
        LPCWSTR lpNewItem);

LWSTDAPI_(BOOL)
GetCharWidth32WrapW(
     HDC hdc,
     UINT iFirstChar,
     UINT iLastChar,
     LPINT lpBuffer);

LWSTDAPI_(DWORD)
GetCharacterPlacementWrapW(
    HDC hdc,            // handle to device context
    LPCWSTR lpString,   // pointer to string
    int nCount,         // number of characters in string
    int nMaxExtent,     // maximum extent for displayed string
    LPGCP_RESULTSW lpResults, // pointer to buffer for placement result
    DWORD dwFlags       // placement flags
   );

LWSTDAPI_(BOOL)
CopyFileWrapW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);

LWSTDAPI_(BOOL)
MoveFileWrapW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);

LWSTDAPI_(BOOL)
OemToCharWrapW(LPCSTR lpszSrc, LPWSTR lpszDst);

LWSTDAPI_(HANDLE)
OpenEventWrapW(
        DWORD                   fdwAccess,
        BOOL                    fInherit,
        LPCWSTR                 lpszEventName);


LWSTDAPI_(void)
OutputDebugStringWrapW(LPCWSTR lpOutputString);

LWSTDAPI_(BOOL)
PeekMessageWrapW(
        LPMSG   lpMsg,
        HWND    hWnd,
        UINT    wMsgFilterMin,
        UINT    wMsgFilterMax,
        UINT    wRemoveMsg);

LWSTDAPI_(BOOL)
PlaySoundWrapW(
        LPCWSTR pszSound,
        HMODULE hmod,
        DWORD fdwSound);

LWSTDAPI_(BOOL)
PostMessageWrapW(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam);

LWSTDAPI_(BOOL)
PostThreadMessageWrapW(
        DWORD idThread,
        UINT Msg,
        WPARAM wParam,
        LPARAM lParam);

LWSTDAPI_(LONG)
RegCreateKeyWrapW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);

LWSTDAPI_(LONG)
RegCreateKeyExWrapW(HKEY hKey, LPCWSTR lpSubKey, DWORD Reserved, LPWSTR lpClass, DWORD dwOptions, REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);

LWSTDAPI_(LONG)
RegDeleteKeyWrapW(HKEY hKey, LPCWSTR pwszSubKey);

LWSTDAPI_(LONG)
RegDeleteValueWrapW(HKEY hKey, LPCWSTR pwszSubKey);

LWSTDAPI_(LONG)
RegEnumKeyWrapW(
        HKEY    hKey,
        DWORD   dwIndex,
        LPWSTR  lpName,
        DWORD   cbName);

LWSTDAPI_(LONG)
RegEnumKeyExWrapW(
        HKEY        hKey,
        DWORD       dwIndex,
        LPWSTR      lpName,
        LPDWORD     lpcbName,
        LPDWORD     lpReserved,
        LPWSTR      lpClass,
        LPDWORD     lpcbClass,
        PFILETIME   lpftLastWriteTime);

LWSTDAPI_(LONG)
RegOpenKeyWrapW(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult);

LWSTDAPI_(LONG)
RegOpenKeyExWrapW(
        HKEY    hKey,
        LPCWSTR lpSubKey,
        DWORD   ulOptions,
        REGSAM  samDesired,
        PHKEY   phkResult);

LWSTDAPI_(LONG)
RegQueryInfoKeyWrapW(
        HKEY hKey,
        LPWSTR lpClass,
        LPDWORD lpcbClass,
        LPDWORD lpReserved,
        LPDWORD lpcSubKeys,
        LPDWORD lpcbMaxSubKeyLen,
        LPDWORD lpcbMaxClassLen,
        LPDWORD lpcValues,
        LPDWORD lpcbMaxValueNameLen,
        LPDWORD lpcbMaxValueLen,
        LPDWORD lpcbSecurityDescriptor,
        PFILETIME lpftLastWriteTime);

LWSTDAPI_(LONG)
RegQueryValueWrapW(
        HKEY    hKey,
        LPCWSTR pwszSubKey,
        LPWSTR  pwszValue,
        PLONG   lpcbValue);

LWSTDAPI_(LONG)
RegQueryValueExWrapW(
        HKEY    hKey,
        LPCWSTR lpValueName,
        LPDWORD lpReserved,
        LPDWORD lpType,
        LPBYTE  lpData,
        LPDWORD lpcbData);

LWSTDAPI_(LONG)
RegSetValueWrapW(
        HKEY    hKey,
        LPCWSTR lpSubKey,
        DWORD   dwType,
        LPCWSTR lpData,
        DWORD   cbData);

LWSTDAPI_(LONG)
RegSetValueExWrapW(
        HKEY        hKey,
        LPCWSTR     lpValueName,
        DWORD       Reserved,
        DWORD       dwType,
        CONST BYTE* lpData,
        DWORD       cbData);

LWSTDAPI_(ATOM)
RegisterClassWrapW(CONST WNDCLASSW * lpWndClass);

LWSTDAPI_(UINT)
RegisterClipboardFormatWrapW(LPCWSTR lpString);

LWSTDAPI_(UINT)
RegisterWindowMessageWrapW(LPCWSTR lpString);

LWSTDAPI_(BOOL)
RemoveDirectoryWrapW(LPCWSTR lpszDir);

LWSTDAPI_(HANDLE)
RemovePropWrapW(
        HWND    hWnd,
        LPCWSTR lpString);

LWSTDAPI_(LRESULT)
SendDlgItemMessageWrapW(
        HWND    hDlg,
        int     nIDDlgItem,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam);

LWSTDAPI_(LRESULT)
SendMessageWrapW(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam);

LWSTDAPI_(LRESULT)
SendMessageTimeoutWrapW(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam,
        UINT    uFlags,
        UINT    uTimeout,
        PULONG_PTR lpdwResult);

LWSTDAPI_(BOOL)
SetCurrentDirectoryWrapW(LPCWSTR lpszCurDir);

LWSTDAPI_(BOOL)
SetDlgItemTextWrapW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);

LWSTDAPI_(BOOL)
SetMenuItemInfoWrapW(
    HMENU hMenu,
    UINT uItem,
    BOOL fByPosition,
    LPCMENUITEMINFOW lpmiiW);

LWSTDAPI_(BOOL)
SetPropWrapW(
    HWND    hWnd,
    LPCWSTR lpString,
    HANDLE  hData);

LWSTDAPI_(LONG)
SetWindowLongWrapW(HWND hWnd, int nIndex, LONG dwNewLong);

LWSTDAPI_(HHOOK)
SetWindowsHookExWrapW(
    int idHook,
    HOOKPROC lpfn,
    HINSTANCE hmod,
    DWORD dwThreadId);

LWSTDAPI_(int)
StartDocWrapW( HDC hDC, const DOCINFOW * lpdi );

LWSTDAPI_(BOOL)
SystemParametersInfoWrapW(
        UINT    uiAction,
        UINT    uiParam,
        void    *pvParam,
        UINT    fWinIni);

LWSTDAPI_(BOOL)
TrackPopupMenuWrap(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, CONST RECT *prcRect);

LWSTDAPI_(BOOL)
TrackPopupMenuExWrap(HMENU hMenu, UINT uFlags, int x, int y, HWND hWnd, LPTPMPARAMS lptpm);

LWSTDAPI_(int)
TranslateAcceleratorWrapW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);

LWSTDAPI_(BOOL)
UnregisterClassWrapW(LPCWSTR lpClassName, HINSTANCE hInstance);

// Cannot be LWSTDAPI because winver.h declares the function as STDAPI and not DLLIMPORT
STDAPI_(BOOL)
VerQueryValueWrapW(const LPVOID pBlock, LPWSTR pwzSubBlock, LPVOID *ppBuffer, PUINT puLen);

LWSTDAPI_(SHORT)
VkKeyScanWrapW(WCHAR ch);

LWSTDAPI_(BOOL)
WinHelpWrapW(HWND hwnd, LPCWSTR szFile, UINT uCmd, DWORD_PTR dwData);

LWSTDAPI_(int)
wvsprintfWrapW(LPWSTR pwszOut, LPCWSTR pwszFormat, va_list arglist);

// Cannot be LWSTDAPI because winnetp.h declares the function as STDAPI and not DLLIMPORT
STDAPI_(DWORD) WNetRestoreConnectionWrapW(IN HWND hwndParent, IN LPCWSTR pwzDevice);
// Cannot be LWSTDAPI because winnetwk.h declares the function as STDAPI and not DLLIMPORT
STDAPI_(DWORD) WNetGetLastErrorWrapW(OUT LPDWORD pdwError, OUT LPWSTR pwzErrorBuf, IN DWORD cchErrorBufSize, OUT LPWSTR pwzNameBuf, IN DWORD cchNameBufSize);

LWSTDAPI_(int) DrawTextExWrapW(HDC hdc, LPWSTR pwzText, int cchText, LPRECT lprc, UINT dwDTFormat, LPDRAWTEXTPARAMS lpDTParams);
LWSTDAPI_(BOOL) GetMenuItemInfoWrapW(HMENU hMenu, UINT uItem, BOOL fByPosition, LPMENUITEMINFOW pmiiW);
LWSTDAPI_(BOOL) InsertMenuItemWrapW(HMENU hMenu, UINT uItem, BOOL fByPosition, LPCMENUITEMINFOW pmiiW);

LWSTDAPI_(HFONT) CreateFontWrapW(int nHeight, int nWidth, int nEscapement, int nOrientation, int fnWeight, DWORD fdwItalic, DWORD fdwUnderline,
                    DWORD fdwStrikeOut, DWORD fdwCharSet, DWORD fdwOutputPrecision, DWORD fdwClipPrecision,
                    DWORD fdwQuality, DWORD fdwPitchAndFamily, LPCWSTR lpszFace);
LWSTDAPI_(HDC) CreateMetaFileWrapW(LPCWSTR pwzFile);
LWSTDAPI_(HANDLE) CreateMutexWrapW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR pwzName);
LWSTDAPI_(DWORD) ExpandEnvironmentStringsWrapW(LPCWSTR pwszSrc, LPWSTR pwszDst, DWORD cchSize);
LWSTDAPI_(DWORD) SHExpandEnvironmentStringsA(LPCSTR pszSrc, LPSTR pszDst, DWORD cchSize);
LWSTDAPI_(DWORD) SHExpandEnvironmentStringsW(LPCWSTR pszSrc, LPWSTR pszDst, DWORD cchSize);
#ifdef UNICODE
#define SHExpandEnvironmentStrings  SHExpandEnvironmentStringsW
#else
#define SHExpandEnvironmentStrings  SHExpandEnvironmentStringsA
#endif // !UNICODE
LWSTDAPI_(DWORD) SHExpandEnvironmentStringsForUserA(HANDLE hToken, LPCSTR pszSrc, LPSTR pszDst, DWORD cchSize);
LWSTDAPI_(DWORD) SHExpandEnvironmentStringsForUserW(HANDLE hToken, LPCWSTR pszSrc, LPWSTR pszDst, DWORD cchSize);
#ifdef UNICODE
#define SHExpandEnvironmentStringsForUser  SHExpandEnvironmentStringsForUserW
#else
#define SHExpandEnvironmentStringsForUser  SHExpandEnvironmentStringsForUserA
#endif // !UNICODE

LWSTDAPI_(HANDLE) CreateSemaphoreWrapW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR pwzName);
LWSTDAPI_(BOOL) IsBadStringPtrWrapW(LPCWSTR pwzString, UINT_PTR ucchMax);
LWSTDAPI_(HINSTANCE) LoadLibraryWrapW(LPCWSTR pwzLibFileName);
LWSTDAPI_(int) GetTimeFormatWrapW(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpTime, LPCWSTR pwzFormat, LPWSTR pwzTimeStr, int cchTime);
LWSTDAPI_(int) GetDateFormatWrapW(LCID Locale, DWORD dwFlags, CONST SYSTEMTIME * lpDate, LPCWSTR pwzFormat, LPWSTR pwzDateStr, int cchDate);
LWSTDAPI_(DWORD) GetPrivateProfileStringWrapW(LPCWSTR pwzAppName, LPCWSTR pwzKeyName, LPCWSTR pwzDefault, LPWSTR pwzReturnedString, DWORD cchSize, LPCWSTR pwzFileName);
LWSTDAPI_(BOOL) WritePrivateProfileStringWrapW(LPCWSTR pwzAppName, LPCWSTR pwzKeyName, LPCWSTR pwzString, LPCWSTR pwzFileName);

#ifndef SHFILEINFO_DEFINED
#define SHFILEINFO_DEFINED

/*
 * The SHGetFileInfo API provides an easy way to get attributes
 * for a file given a pathname.
 *
 *   PARAMETERS
 *
 *     pszPath              file name to get info about
 *     dwFileAttributes     file attribs, only used with SHGFI_USEFILEATTRIBUTES
 *     psfi                 place to return file info
 *     cbFileInfo           size of structure
 *     uFlags               flags
 *
 *   RETURN
 *     TRUE if things worked
 */

typedef struct _SHFILEINFOA
{
    HICON       hIcon;                      // out: icon
    int         iIcon;                      // out: icon index
    DWORD       dwAttributes;               // out: SFGAO_ flags
    CHAR        szDisplayName[MAX_PATH];    // out: display name (or path)
    CHAR        szTypeName[80];             // out: type name
} SHFILEINFOA;
typedef struct _SHFILEINFOW
{
    HICON       hIcon;                      // out: icon
    int         iIcon;                      // out: icon index
    DWORD       dwAttributes;               // out: SFGAO_ flags
    WCHAR       szDisplayName[MAX_PATH];    // out: display name (or path)
    WCHAR       szTypeName[80];             // out: type name
} SHFILEINFOW;
#ifdef UNICODE
typedef SHFILEINFOW SHFILEINFO;
#else
typedef SHFILEINFOA SHFILEINFO;
#endif // UNICODE


// NOTE: This is also in shellapi.h.  Please keep in synch.
#endif // !SHFILEINFO_DEFINED
LWSTDAPI_(DWORD_PTR) SHGetFileInfoWrapW(LPCWSTR pwzPath, DWORD dwFileAttributes, SHFILEINFOW *psfi, UINT cbFileInfo, UINT uFlags);

LWSTDAPI_(ATOM) RegisterClassExWrapW(CONST WNDCLASSEXW *pwcx);
LWSTDAPI_(BOOL) GetClassInfoExWrapW(HINSTANCE hinst, LPCWSTR pwzClass, LPWNDCLASSEXW lpwcx);

// This allows us to be included either before or after shellapi.h
#ifdef STRICT
LWSTDAPI_(UINT) DragQueryFileWrapW(struct HDROP__*,UINT,LPWSTR,UINT);
#else
LWSTDAPI_(UINT) DragQueryFileWrapW(HANDLE,UINT,LPWSTR,UINT);
#endif

LWSTDAPI_(HWND) FindWindowExWrapW(HWND hwndParent, HWND hwndChildAfter, LPCWSTR pwzClassName, LPCWSTR pwzWindowName);
LWSTDAPI_(LPITEMIDLIST) SHBrowseForFolderWrapW(struct _browseinfoW * pbiW);
LWSTDAPI_(BOOL) SHGetPathFromIDListWrapW(LPCITEMIDLIST pidl, LPWSTR pwzPath);
LWSTDAPI_(BOOL) SHGetNewLinkInfoWrapW(LPCWSTR pszpdlLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL *pfMustCopy, UINT uFlags);
LWSTDAPI SHDefExtractIconWrapW(LPCWSTR pszIconFile, int iIndex, UINT uFlags, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);
LWSTDAPI_(BOOL) GetUserNameWrapW(LPWSTR pszBuffer, LPDWORD pcch);
LWSTDAPI_(LONG) RegEnumValueWrapW(HKEY hkey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcbValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);
LWSTDAPI_(BOOL) WritePrivateProfileStructWrapW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);
LWSTDAPI_(BOOL) GetPrivateProfileStructWrapW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);
LWSTDAPI_(BOOL) CreateProcessWrapW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCWSTR lpCurrentDirectory,
LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
LWSTDAPI_(HICON) ExtractIconWrapW(HINSTANCE hInst, LPCWSTR lpszExeFileName, UINT nIconIndex);
#ifndef WIN32_LEAN_AND_MEAN
// Cannot be LWSTDAPI because ddeml.h declares the function as STDAPI and not DLLIMPORT
STDAPI_(UINT) DdeInitializeWrapW(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes);
STDAPI_(HSZ) DdeCreateStringHandleWrapW(DWORD idInst, LPCWSTR psz, int iCodePage);
STDAPI_(DWORD) DdeQueryStringWrapW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage);

LWSTDAPI_(BOOL) GetSaveFileNameWrapW(LPOPENFILENAMEW lpofn);
LWSTDAPI_(BOOL) GetOpenFileNameWrapW(LPOPENFILENAMEW lpofn);
LWSTDAPI_(BOOL) PrintDlgWrapW(LPPRINTDLGW lppd);
LWSTDAPI_(BOOL) PageSetupDlgWrapW(LPPAGESETUPDLGW lppsd);
#endif
LWSTDAPI_(void) SHChangeNotifyWrap(LONG wEventId, UINT uFlags, LPCVOID dwItem1, LPCVOID dwItem2);
LWSTDAPI_(void) SHFlushSFCacheWrap(void);
LWSTDAPI_(BOOL) ShellExecuteExWrapW(struct _SHELLEXECUTEINFOW * pExecInfoW);
LWSTDAPI_(int) SHFileOperationWrapW(struct _SHFILEOPSTRUCTW * pFileOpW);
LWSTDAPI_(UINT) ExtractIconExWrapW(LPCWSTR pwzFile, int nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIcons);
LWSTDAPI_(BOOL) SetFileAttributesWrapW(LPCWSTR pwzFile, DWORD dwFileAttributes);
LWSTDAPI_(int) GetNumberFormatWrapW(LCID Locale, DWORD dwFlags, LPCWSTR pwzValue, CONST NUMBERFMTW * pFormatW, LPWSTR pwzNumberStr, int cchNumber);
LWSTDAPI_(int) MessageBoxWrapW(HWND hwnd, LPCWSTR pwzText, LPCWSTR pwzCaption, UINT uType);
LWSTDAPI_(BOOL) FindNextFileWrapW(HANDLE hSearchHandle, LPWIN32_FIND_DATAW pFindFileDataW);

#ifdef UNICODE

#define IsCharAlphaWrap             IsCharAlphaWrapW
#define IsCharUpperWrap             IsCharUpperWrapW
#define IsCharLowerWrap             IsCharLowerWrapW
#define IsCharAlphaNumericWrap      IsCharAlphaNumericWrapW
#define AppendMenuWrap              AppendMenuWrapW
#ifdef POST_IE5_BETA
#define CallMsgFilterWrap           CallMsgFilterWrapW
#endif
#define CallWindowProcWrap          CallWindowProcWrapW
#define CharLowerWrap               CharLowerWrapW
#define CharLowerBuffWrap           CharLowerBuffWrapW
#define CharNextWrap                CharNextWrapW
#define CharPrevWrap                CharPrevWrapW
#define CharToOemWrap               CharToOemWrapW
#define CharUpperWrap               CharUpperWrapW
#define CharUpperBuffWrap           CharUpperBuffWrapW
#define CompareStringWrap           CompareStringWrapW
#define CopyAcceleratorTableWrap    CopyAcceleratorTableWrapW
#define CreateAcceleratorTableWrap  CreateAcceleratorTableWrapW
#define CreateDCWrap                CreateDCWrapW
#define CreateDirectoryWrap         CreateDirectoryWrapW
#define CreateEventWrap             CreateEventWrapW
#define CreateFontWrap              CreateFontWrapW
#define CreateFileWrap              CreateFileWrapW
#define CreateFontIndirectWrap      CreateFontIndirectWrapW
#define CreateICWrap                CreateICWrapW
#define CreateMetaFileWrap          CreateMetaFileWrapW
#define CreateMutexWrap             CreateMutexWrapW
#define CreateSemaphoreWrap         CreateSemaphoreWrapW
#define CreateWindowExWrap          CreateWindowExWrapW
#define DefWindowProcWrap           DefWindowProcWrapW
#define DeleteFileWrap              DeleteFileWrapW
#define DispatchMessageWrap         DispatchMessageWrapW
#define DrawTextExWrap              DrawTextExWrapW
#define DrawTextWrap                DrawTextWrapW
#define EnumFontFamiliesWrap        EnumFontFamiliesWrapW
#define EnumFontFamiliesExWrap      EnumFontFamiliesExWrapW
#define EnumResourceNamesWrap       EnumResourceNamesWrapW
#define ExpandEnvironmentStringsWrap ExpandEnvironmentStringsWrapW
#define ExtractIconExWrap           ExtractIconExWrapW
#define ExtTextOutWrap              ExtTextOutW
#define FindFirstFileWrap           FindFirstFileWrapW
#define FindNextFileWrap            FindNextFileWrapW
#define FindResourceWrap            FindResourceWrapW
#define FindWindowWrap              FindWindowWrapW
#define FindWindowExWrap            FindWindowExWrapW
#define FormatMessageWrap           FormatMessageWrapW
#define GetClassInfoWrap            GetClassInfoWrapW
#define GetClassInfoExWrap          GetClassInfoExWrapW
#define GetClassLongWrap            GetClassLongWrapW
#define GetClassNameWrap            GetClassNameWrapW
#define GetClipboardFormatNameWrap  GetClipboardFormatNameWrapW
#define GetCurrentDirectoryWrap     GetCurrentDirectoryWrapW
#define GetDlgItemTextWrap          GetDlgItemTextWrapW
#define GetFileAttributesWrap       GetFileAttributesWrapW
#define GetFullPathNameWrap         GetFullPathNameWrapW
#define GetLocaleInfoWrap           GetLocaleInfoWrapW
#define GetMenuItemInfoWrap         GetMenuItemInfoWrapW
#define GetMenuStringWrap           GetMenuStringWrapW
#define GetMessageWrap              GetMessageWrapW
#define GetModuleFileNameWrap       GetModuleFileNameWrapW
#define GetNumberFormatWrap         GetNumberFormatWrapW
#define GetSystemDirectoryWrap      GetSystemDirectoryWrapW
#define GetEnvironmentVariableWrap  GetEnvironmentVariableWrapW
#define GetModuleHandleWrap         GetModuleHandleWrapW
#define GetObjectWrap               GetObjectWrapW
#define GetPrivateProfileIntWrap    GetPrivateProfileIntWrapW
#define GetProfileStringWrap        GetProfileStringWrapW
#define GetPrivateProfileStringWrap GetPrivateProfileStringWrapW
#define WritePrivateProfileStringWrap WritePrivateProfileStringWrapW
#define GetPropWrap                 GetPropWrapW
#define GetStringTypeExWrap         GetStringTypeExWrapW
#define GetTempFileNameWrap         GetTempFileNameWrapW
#define GetTempPathWrap             GetTempPathWrapW
#define GetTextExtentPoint32Wrap    GetTextExtentPoint32WrapW
#define GetTextFaceWrap             GetTextFaceWrapW
#define GetTextMetricsWrap          GetTextMetricsWrapW
#define GetTimeFormatWrap           GetTimeFormatWrapW
#define GetDateFormatWrap           GetDateFormatWrapW
#define GetUserNameWrap             GetUserNameWrapW
#define GetWindowLongWrap           GetWindowLongWrapW
#define GetWindowTextWrap           GetWindowTextWrapW
#define GetWindowTextLengthWrap     GetWindowTextLengthWrapW
#define GetWindowsDirectoryWrap     GetWindowsDirectoryWrapW
#define InsertMenuItemWrap          InsertMenuItemWrapW
#define InsertMenuWrap              InsertMenuWrapW
#define IsBadStringPtrWrap          IsBadStringPtrWrapW
#define IsDialogMessageWrap         IsDialogMessageWrapW
#define LoadAcceleratorsWrap        LoadAcceleratorsWrapW
#define LoadBitmapWrap              LoadBitmapWrapW
#define LoadCursorWrap              LoadCursorWrapW
#define LoadIconWrap                LoadIconWrapW
#define LoadImageWrap               LoadImageWrapW
#define LoadLibraryWrap             LoadLibraryWrapW
#define LoadLibraryExWrap           LoadLibraryExWrapW
#define LoadMenuWrap                LoadMenuWrapW
#define LoadStringWrap              LoadStringWrapW
#define MessageBoxIndirectWrap      MessageBoxIndirectWrapW
#define MessageBoxWrap              MessageBoxWrapW
#define ModifyMenuWrap              ModifyMenuWrapW
#define GetCharWidth32Wrap          GetCharWidth32WrapW
#define GetCharacterPlacementWrap   GetCharacterPlacementWrapW
#define CopyFileWrap                CopyFileWrapW
#define MoveFileWrap                MoveFileWrapW
#define OemToCharWrap               OemToCharWrapW
#define OutputDebugStringWrap       OutputDebugStringWrapW
#define PeekMessageWrap             PeekMessageWrapW
#define PostMessageWrap             PostMessageWrapW
#define PostThreadMessageWrap       PostThreadMessageWrapW
#define RegCreateKeyWrap            RegCreateKeyWrapW
#define RegCreateKeyExWrap          RegCreateKeyExWrapW
#define RegDeleteKeyWrap            RegDeleteKeyWrapW
#define RegDeleteValueWrap          RegDeleteValueWrapW
#define RegEnumKeyWrap              RegEnumKeyWrapW
#define RegEnumKeyExWrap            RegEnumKeyExWrapW
#define RegOpenKeyWrap              RegOpenKeyWrapW
#define RegOpenKeyExWrap            RegOpenKeyExWrapW
#define RegQueryInfoKeyWrap         RegQueryInfoKeyWrapW
#define RegQueryValueWrap           RegQueryValueWrapW
#define RegQueryValueExWrap         RegQueryValueExWrapW
#define RegSetValueWrap             RegSetValueWrapW
#define RegSetValueExWrap           RegSetValueExWrapW
#define RegisterClassWrap           RegisterClassWrapW
#define RegisterClassExWrap         RegisterClassExWrapW
#define RegisterClipboardFormatWrap RegisterClipboardFormatWrapW
#define RegisterWindowMessageWrap   RegisterWindowMessageWrapW
#define RemovePropWrap              RemovePropWrapW
#define SearchPathWrap              SearchPathWrapW
#define SendDlgItemMessageWrap      SendDlgItemMessageWrapW
#define SendMessageWrap             SendMessageWrapW
#define SendMessageTimeoutWrap      SendMessageTimeoutWrapW
#define SetCurrentDirectoryWrap     SetCurrentDirectoryWrapW
#define SetDlgItemTextWrap          SetDlgItemTextWrapW
#define SetMenuItemInfoWrap         SetMenuItemInfoWrapW
#define SetPropWrap                 SetPropWrapW
#define SetFileAttributesWrap       SetFileAttributesWrapW
#define SetWindowLongWrap           SetWindowLongWrapW
#define SetWindowsHookExWrap        SetWindowsHookExWrapW
#define SHBrowseForFolderWrap       SHBrowseForFolderWrapW
#define ShellExecuteExWrap          ShellExecuteExWrapW
#define SHFileOperationWrap         SHFileOperationWrapW
#define SHGetFileInfoWrap           SHGetFileInfoWrapW
#define SHGetPathFromIDListWrap     SHGetPathFromIDListWrapW
#define StartDocWrap                StartDocWrapW
#define SystemParametersInfoWrap    SystemParametersInfoWrapW
#define TranslateAcceleratorWrap    TranslateAcceleratorWrapW
#define UnregisterClassWrap         UnregisterClassWrapW
#define VkKeyScanWrap               VkKeyScanWrapW
#define WinHelpWrap                 WinHelpWrapW
#define WNetRestoreConnectionWrap   WNetRestoreConnectionWrapW
#define WNetGetLastErrorWrap        WNetGetLastErrorWrapW
#define wvsprintfWrap               wvsprintfWrapW
#define CreateFontWrap              CreateFontWrapW
#define DrawTextExWrap              DrawTextExWrapW
#define GetMenuItemInfoWrap         GetMenuItemInfoWrapW
#define SetMenuItemInfoWrap         SetMenuItemInfoWrapW
#define InsertMenuItemWrap          InsertMenuItemWrapW
#define DragQueryFileWrap           DragQueryFileWrapW

#else

#define IsCharAlphaWrap             IsCharAlphaA
#define IsCharUpperWrap             IsCharUpperA
#define IsCharLowerWrap             IsCharLowerA
#define IsCharAlphaNumericWrap      IsCharAlphaNumericA
#define AppendMenuWrap              AppendMenuA
#ifdef POST_IE5_BETA
#define CallMsgFilterWrap           CallMsgFilterA
#endif
#define CallWindowProcWrap          CallWindowProcA
#define CharLowerWrap               CharLowerA
#define CharLowerBuffWrap           CharLowerBuffA
#define CharNextWrap                CharNextA
#define CharPrevWrap                CharPrevA
#define CharToOemWrap               CharToOemA
#define CharUpperWrap               CharUpperA
#define CharUpperBuffWrap           CharUpperBuffA
#define CompareStringWrap           CompareStringA
#define CopyAcceleratorTableWrap    CopyAcceleratorTableA
#define CreateAcceleratorTableWrap  CreateAcceleratorTableA
#define CreateDCWrap                CreateDCA
#define CreateDirectoryWrap         CreateDirectoryA
#define CreateEventWrap             CreateEventA
#define CreateFontWrap              CreateFontA
#define CreateFileWrap              CreateFileA
#define CreateFontIndirectWrap      CreateFontIndirectA
#define CreateICWrap                CreateICA
#define CreateMetaFileWrap          CreateMetaFileA
#define CreateMutexWrap             CreateMutexA
#define CreateSemaphoreWrap         CreateSemaphoreA
#define CreateWindowExWrap          CreateWindowExA
#define DefWindowProcWrap           DefWindowProcA
#define DeleteFileWrap              DeleteFileA
#define DispatchMessageWrap         DispatchMessageA
#define DrawTextExWrap              DrawTextExA
#define DrawTextWrap                DrawTextA
#define EnumFontFamiliesWrap        EnumFontFamiliesA
#define EnumFontFamiliesExWrap      EnumFontFamiliesExA
#define EnumResourceNamesWrap       EnumResourceNamesA
#define ExpandEnvironmentStringsWrap ExpandEnvironmentStringsA
#define ExtractIconExWrap           ExtractIconExA
#define ExtTextOutWrap              ExtTextOutA
#define FindFirstFileWrap           FindFirstFileA
#define FindResourceWrap            FindResourceA
#define FindNextFileWrap            FindNextFileA
#define FindWindowWrap              FindWindowA
#define FindWindowExWrap            FindWindowExA
#define FormatMessageWrap           FormatMessageA
#define GetClassInfoWrap            GetClassInfoA
#define GetClassInfoExWrap          GetClassInfoExA
#define GetClassLongWrap            GetClassLongA
#define GetClassNameWrap            GetClassNameA
#define GetClipboardFormatNameWrap  GetClipboardFormatNameA
#define GetCurrentDirectoryWrap     GetCurrentDirectoryA
#define GetDlgItemTextWrap          GetDlgItemTextA
#define GetFileAttributesWrap       GetFileAttributesA
#define GetFullPathNameWrap         GetFullPathNameA
#define GetLocaleInfoWrap           GetLocaleInfoA
#define GetMenuItemInfoWrap         GetMenuItemInfoA
#define GetMenuStringWrap           GetMenuStringA
#define GetMessageWrap              GetMessageA
#define GetModuleFileNameWrap       GetModuleFileNameA
#define GetNumberFormatWrap         GetNumberFormatA
#define GetPrivateProfileStringWrap GetPrivateProfileStringA
#define WritePrivateProfileStringWrap WritePrivateProfileStringA
#define GetSystemDirectoryWrap      GetSystemDirectoryA
#define GetEnvironmentVariableWrap  GetEnvironmentVariableA
#define SearchPathWrap              SearchPathA
#define GetModuleHandleWrap         GetModuleHandleA
#define GetObjectWrap               GetObjectA
#define GetPrivateProfileIntWrap    GetPrivateProfileIntA
#define GetProfileStringWrap        GetProfileStringA
#define GetPropWrap                 GetPropA
#define GetStringTypeExWrap         GetStringTypeExA
#define GetTempFileNameWrap         GetTempFileNameA
#define GetTempPathWrap             GetTempPathA
#define GetTextExtentPoint32Wrap    GetTextExtentPoint32A
#define GetTextFaceWrap             GetTextFaceA
#define GetTextMetricsWrap          GetTextMetricsA
#define GetTimeFormatWrap           GetTimeFormatA
#define GetDateFormatWrap           GetDateFormatA
#define GetUserNameWrap             GetUserNameA
#define GetWindowLongWrap           GetWindowLongA
#define GetWindowTextWrap           GetWindowTextA
#define GetWindowTextLengthWrap     GetWindowTextLengthA
#define GetWindowsDirectoryWrap     GetWindowsDirectoryA
#define InsertMenuItemWrap          InsertMenuItemA
#define InsertMenuWrap              InsertMenuA
#define IsBadStringPtrWrap          IsBadStringPtrA
#define IsDialogMessageWrap         IsDialogMessageA
#define LoadAcceleratorsWrap        LoadAcceleratorsA
#define LoadBitmapWrap              LoadBitmapA
#define LoadCursorWrap              LoadCursorA
#define LoadIconWrap                LoadIconA
#define LoadImageWrap               LoadImageWrapA
#define LoadLibraryWrap             LoadLibraryA
#define LoadLibraryExWrap           LoadLibraryExA
#define LoadMenuWrap                LoadMenuA
#define LoadStringWrap              LoadStringA
#define MessageBoxIndirectWrap      MessageBoxIndirectA
#define MessageBoxWrap              MessageBoxA
#define ModifyMenuWrap              ModifyMenuA
#define GetCharWidth32Wrap          GetCharWidth32A
#define GetCharacterPlacementWrap   GetCharacterPlacementA
#define CopyFileWrap                CopyFileA
#define MoveFileWrap                MoveFileA
#define OemToCharWrap               OemToCharA
#define OutputDebugStringWrap       OutputDebugStringA
#define PeekMessageWrap             PeekMessageA
#define PostMessageWrap             PostMessageA
#define PostThreadMessageWrap       PostThreadMessageA
#define RegCreateKeyWrap            RegCreateKeyA
#define RegCreateKeyExWrap          RegCreateKeyExA
#define RegDeleteKeyWrap            RegDeleteKeyA
#define RegDeleteValueWrap          RegDeleteValueA
#define RegEnumKeyWrap              RegEnumKeyA
#define RegEnumKeyExWrap            RegEnumKeyExA
#define RegOpenKeyWrap              RegOpenKeyA
#define RegOpenKeyExWrap            RegOpenKeyExA
#define RegQueryInfoKeyWrap         RegQueryInfoKeyA
#define RegQueryValueWrap           RegQueryValueA
#define RegQueryValueExWrap         RegQueryValueExA
#define RegSetValueWrap             RegSetValueA
#define RegSetValueExWrap           RegSetValueExA
#define RegisterClassWrap           RegisterClassA
#define RegisterClassExWrap         RegisterClassExA
#define RegisterClipboardFormatWrap RegisterClipboardFormatA
#define RegisterWindowMessageWrap   RegisterWindowMessageA
#define RemovePropWrap              RemovePropA
#define SendDlgItemMessageWrap      SendDlgItemMessageA
#define SendMessageWrap             SendMessageA
#define SendMessageTimeoutWrap      SendMessageTimeoutA
#define SetCurrentDirectoryWrap     SetCurrentDirectoryA
#define SetDlgItemTextWrap          SetDlgItemTextA
#define SetMenuItemInfoWrap         SetMenuItemInfoA
#define SetPropWrap                 SetPropA
#define SetWindowLongWrap           SetWindowLongA
#define SHBrowseForFolderWrap       SHBrowseForFolderA
#define ShellExecuteExWrap          ShellExecuteExA
#define SHFileOperationWrap         SHFileOperationA
#define SHGetFileInfoWrap           SHGetFileInfoA
#define SHGetPathFromIDListWrap     SHGetPathFromIDListA
#define SetFileAttributesWrap       SetFileAttributesA
#define SetWindowsHookExWrap        SetWindowsHookExA
#define StartDocWrap                StartDocA
#define SystemParametersInfoWrap    SystemParametersInfoA
#define TranslateAcceleratorWrap    TranslateAcceleratorA
#define UnregisterClassWrap         UnregisterClassA
#define VkKeyScanWrap               VkKeyScanA
#define WinHelpWrap                 WinHelpA
#define WNetRestoreConnectionWrap   WNetRestoreConnectionA
#define WNetGetLastErrorWrap        WNetGetLastErrorA
#define wvsprintfWrap               wvsprintfA
#define CreateFontWrap              CreateFontA
#define DrawTextExWrap              DrawTextExA
#define GetMenuItemInfoWrap         GetMenuItemInfoA
#define SetMenuItemInfoWrap         SetMenuItemInfoA
#define InsertMenuItemWrap          InsertMenuItemA
#define DragQueryFileWrap           DragQueryFileA
#endif

#endif // (_WIN32_IE >= 0x0500) && !defined(NO_SHLWAPI_UNITHUNK)

#if defined(UNIX) && defined(NO_SHLWAPI_UNITHUNK)
#define SHFlushSFCacheWrap()

#ifdef UNICODE
#define IsCharAlphaWrapW            IsCharAlphaW
#define IsCharUpperWrapW            IsCharUpperW
#define IsCharLowerWrapW            IsCharLowerW
#define IsCharAlphaNumericWrapW     IsCharAlphaNumericW
#define AppendMenuWrapW             AppendMenuW
#ifdef POST_IE5_BETA
#define CallMsgFilterWrapW          CallMsgFilterW
#endif
#define CallWindowProcWrapW         CallWindowProcW
#define CharLowerWrapW              CharLowerW
#define CharLowerBuffWrapW          CharLowerBuffW
#define CharNextWrapW               CharNextW
#define CharPrevWrapW               CharPrevW
#define CharToOemWrapW              CharToOemW
#define CharUpperWrapW              CharUpperW
#define CharUpperBuffWrapW          CharUpperBuffW
#define CompareStringWrapW          CompareStringW
#define CopyAcceleratorTableWrapW   CopyAcceleratorTableW
#define CreateAcceleratorTableWrapW CreateAcceleratorTableW
#define CreateDCWrapW               CreateDCW
#define CreateDirectoryWrapW        CreateDirectoryW
#define CreateEventWrapW            CreateEventW
#define CreateFontWrapW             CreateFontW
#define CreateFileWrapW             CreateFileW
#define CreateFontIndirectWrapW     CreateFontIndirectW
#define CreateICWrapW               CreateICW
#define CreateMetaFileWrapW         CreateMetaFileW
#define CreateMutexWrapW            CreateMutexW
#define CreateSemaphoreWrapW        CreateSemaphoreW
#define CreateWindowExWrapW         CreateWindowExW
#define DefWindowProcWrapW          DefWindowProcW
#define DeleteFileWrapW             DeleteFileW
#define DispatchMessageWrapW        DispatchMessageW
#define DrawTextExWrapW             DrawTextExW
#define DrawTextWrapW               DrawTextW
#define EnumFontFamiliesWrapW       EnumFontFamiliesW
#define EnumFontFamiliesExWrapW     EnumFontFamiliesExW
#define EnumResourceNamesWrapW      EnumResourceNamesW
#define ExpandEnvironmentStringsWrapW ExpandEnvironmentStringsW
#define ExtractIconExWrapW          ExtractIconExW
#define ExtTextOutWrapW             ExtTextOutW
#define FindFirstFileWrapW          FindFirstFileW
#define FindNextFileWrapW           FindNextFileW
#define FindResourceWrapW           FindResourceW
#define FindWindowWrapW             FindWindowW
#define FindWindowExWrapW           FindWindowExW
#define FormatMessageWrapW          FormatMessageW
#define GetClassInfoWrapW           GetClassInfoW
#define GetClassInfoExWrapW         GetClassInfoExW
#define GetClassLongWrapW           GetClassLongW
#define GetClassNameWrapW           GetClassNameW
#define GetClipboardFormatNameWrapW GetClipboardFormatNameW
#define GetCurrentDirectoryWrapW    GetCurrentDirectoryW
#define GetDlgItemTextWrapW         GetDlgItemTextW
#define GetFileAttributesWrapW      GetFileAttributesW
#define GetFullPathNameWrapW        GetFullPathNameW
#define GetLocaleInfoWrapW          GetLocaleInfoW
#define GetMenuStringWrapW          GetMenuStringW
#define GetMessageWrapW             GetMessageW
#define GetModuleFileNameWrapW      GetModuleFileNameW
#define GetNumberFormatWrapW        GetNumberFormatW
#define GetSystemDirectoryWrapW     GetSystemDirectoryW
#define GetModuleHandleWrapW        GetModuleHandleW
#define GetObjectWrapW              GetObjectW
#define GetPrivateProfileIntWrapW   GetPrivateProfileIntW
#define GetProfileStringWrapW       GetProfileStringW
#define GetPrivateProfileStringWrapW GetPrivateProfileStringW
#define WritePrivateProfileStringWrapW WritePrivateProfileStringW
#define GetPropWrapW                GetPropW
#define GetStringTypeExWrapW        GetStringTypeExW
#define GetTempFileNameWrapW        GetTempFileNameW
#define GetTempPathWrapW            GetTempPathW
#define GetTextExtentPoint32WrapW   GetTextExtentPoint32W
#define GetTextFaceWrapW            GetTextFaceW
#define GetTextMetricsWrapW         GetTextMetricsW
#define GetTimeFormatWrapW          GetTimeFormatW
#define GetDateFormatWrapW          GetDateFormatW
#define GetUserNameWrapW            GetUserNameW
#define GetWindowLongWrapW          GetWindowLongW
#define GetWindowTextWrapW          GetWindowTextW
#define GetWindowTextLengthWrapW    GetWindowTextLengthW
#define GetWindowsDirectoryWrapW    GetWindowsDirectoryW
#define InsertMenuItemWrapW         InsertMenuItemW
#define InsertMenuWrapW             InsertMenuW
#define IsBadStringPtrWrapW         IsBadStringPtrW
#define IsDialogMessageWrapW        IsDialogMessageW
#define LoadAcceleratorsWrapW       LoadAcceleratorsW
#define LoadBitmapWrapW             LoadBitmapW
#define LoadCursorWrapW             LoadCursorW
#define LoadIconWrapW               LoadIconW
#define LoadImageWrapW              LoadImageW
#define LoadLibraryWrapW            LoadLibraryW
#define LoadLibraryExWrapW          LoadLibraryExW
#define LoadMenuWrapW               LoadMenuW
#define LoadStringWrapW             LoadStringW
#define MessageBoxIndirectWrapW     MessageBoxIndirectW
#define MessageBoxWrapW             MessageBoxW
#define ModifyMenuWrapW             ModifyMenuW
#define GetCharWidth32WrapW         GetCharWidth32W
#define GetCharacterPlacementWrapW  GetCharacterPlacementW
#define CopyFileWrapW               CopyFileW
#define MoveFileWrapW               MoveFileW
#define OemToCharWrapW              OemToCharW
#define OutputDebugStringWrapW      OutputDebugStringW
#define PeekMessageWrapW            PeekMessageW
#define PostMessageWrapW            PostMessageW
#define PostThreadMessageWrapW      PostThreadMessageW
#define RegCreateKeyWrapW           RegCreateKeyW
#define RegCreateKeyExWrapW         RegCreateKeyExW
#define RegDeleteKeyWrapW           RegDeleteKeyW
#define RegDeleteValueWrapW         RegDeleteValueW
#define RegEnumKeyWrapW             RegEnumKeyW
#define RegEnumKeyExWrapW           RegEnumKeyExW
#define RegOpenKeyWrapW             RegOpenKeyW
#define RegOpenKeyExWrapW           RegOpenKeyExW
#define RegQueryInfoKeyWrapW        RegQueryInfoKeyW
#define RegQueryValueWrapW          RegQueryValueW
#define RegQueryValueExWrapW        RegQueryValueExW
#define RegSetValueWrapW            RegSetValueW
#define RegSetValueExWrapW          RegSetValueExW
#define RegisterClassWrapW          RegisterClassW
#define RegisterClassExWrapW        RegisterClassExW
#define RegisterClipboardFormatWrapWRegisterClipboardFormatW
#define RegisterWindowMessageWrapW  RegisterWindowMessageW
#define RemovePropWrapW             RemovePropW
#define SearchPathWrapW             SearchPathW
#define SendDlgItemMessageWrapW     SendDlgItemMessageW
#define SendMessageWrapW            SendMessageW
#define SetCurrentDirectoryWrapW    SetCurrentDirectoryW
#define SetDlgItemTextWrapW         SetDlgItemTextW
#define SetMenuItemInfoWrapW        SetMenuItemInfoW
#define SetPropWrapW                SetPropW
#define SetFileAttributesWrapW      SetFileAttributesW
#define SetWindowLongWrapW          SetWindowLongW
#define SetWindowsHookExWrapW       SetWindowsHookExW
#define SHBrowseForFolderWrapW      SHBrowseForFolderW
#define ShellExecuteExWrapW         ShellExecuteExW
#define SHFileOperationWrapW        SHFileOperationW
#define SHGetFileInfoWrapW          SHGetFileInfoW
#define SHGetPathFromIDListWrapW    SHGetPathFromIDListW
#define StartDocWrapW               StartDocW
#define SystemParametersInfoWrapW   SystemParametersInfoW
#define TranslateAcceleratorWrapW   TranslateAcceleratorW
#define UnregisterClassWrapW        UnregisterClassW
#define VkKeyScanWrapW              VkKeyScanW
#define WinHelpWrapW                WinHelpW
#define WNetRestoreConnectionWrapW  WNetRestoreConnectionW
#define WNetGetLastErrorWrapW       WNetGetLastErrorW
#define wvsprintfWrapW              wvsprintfW
#define CreateFontWrapW             CreateFontW
#define DrawTextExWrapW             DrawTextExW
#define SetMenuItemInfoWrapW        SetMenuItemInfoW
#define InsertMenuItemWrapW         InsertMenuItemW
#define DragQueryFileWrapW          DragQueryFileW

#define IsCharAlphaWrap             IsCharAlphaW
#define IsCharUpperWrap             IsCharUpperW
#define IsCharLowerWrap             IsCharLowerW
#define IsCharAlphaNumericWrap      IsCharAlphaNumericW
#define AppendMenuWrap              AppendMenuW
#ifdef POST_IE5_BETA
#define CallMsgFilterWrap           CallMsgFilterW
#endif
#define CallWindowProcWrap          CallWindowProcW
#define CharLowerWrap               CharLowerW
#define CharLowerBuffWrap           CharLowerBuffW
#define CharNextWrap                CharNextW
#define CharPrevWrap                CharPrevW
#define CharToOemWrap               CharToOemW
#define CharUpperWrap               CharUpperW
#define CharUpperBuffWrap           CharUpperBuffW
#define CompareStringWrap           CompareStringW
#define CopyAcceleratorTableWrap    CopyAcceleratorTableW
#define CreateAcceleratorTableWrap  CreateAcceleratorTableW
#define CreateDCWrap                CreateDCW
#define CreateDirectoryWrap         CreateDirectoryW
#define CreateEventWrap             CreateEventW
#define CreateFontWrap              CreateFontW
#define CreateFileWrap              CreateFileW
#define CreateFontIndirectWrap      CreateFontIndirectW
#define CreateICWrap                CreateICW
#define CreateMetaFileWrap          CreateMetaFileW
#define CreateMutexWrap             CreateMutexW
#define CreateSemaphoreWrap         CreateSemaphoreW
#define CreateWindowExWrap          CreateWindowExW
#define DefWindowProcWrap           DefWindowProcW
#define DeleteFileWrap              DeleteFileW
#define DispatchMessageWrap         DispatchMessageW
#define DrawTextExWrap              DrawTextExW
#define DrawTextWrap                DrawTextW
#define EnumFontFamiliesWrap        EnumFontFamiliesW
#define EnumFontFamiliesExWrap      EnumFontFamiliesExW
#define EnumResourceNamesWrap       EnumResourceNamesW
#define ExpandEnvironmentStringsWrap ExpandEnvironmentStringsW
#define ExtractIconExWrap           ExtractIconExW
#define ExtTextOutWrap              ExtTextOutW
#define FindFirstFileWrap           FindFirstFileW
#define FindNextFileWrap            FindNextFileW
#define FindResourceWrap            FindResourceW
#define FindWindowWrap              FindWindowW
#define FindWindowExWrap            FindWindowExW
#define FormatMessageWrap           FormatMessageW
#define GetClassInfoWrap            GetClassInfoW
#define GetClassInfoExWrap          GetClassInfoExW
#define GetClassLongWrap            GetClassLongW
#define GetClassNameWrap            GetClassNameW
#define GetClipboardFormatNameWrap  GetClipboardFormatNameW
#define GetCurrentDirectoryWrap     GetCurrentDirectoryW
#define GetDlgItemTextWrap          GetDlgItemTextW
#define GetFileAttributesWrap       GetFileAttributesW
#define GetFullPathNameWrap         GetFullPathNameW
#define GetLocaleInfoWrap           GetLocaleInfoW
#define GetMenuItemInfoWrap         GetMenuItemInfoWrapW
#define GetMenuStringWrap           GetMenuStringW
#define GetMessageWrap              GetMessageW
#define GetModuleFileNameWrap       GetModuleFileNameW
#define GetNumberFormatWrap         GetNumberFormatW
#define GetSystemDirectoryWrap      GetSystemDirectoryW
#define GetModuleHandleWrap         GetModuleHandleW
#define GetObjectWrap               GetObjectW
#define GetPrivateProfileIntWrap    GetPrivateProfileIntW
#define GetProfileStringWrap        GetProfileStringW
#define GetPrivateProfileStringWrap GetPrivateProfileStringW
#define WritePrivateProfileStringWrap WritePrivateProfileStringW
#define GetPropWrap                 GetPropW
#define GetStringTypeExWrap         GetStringTypeExW
#define GetTempFileNameWrap         GetTempFileNameW
#define GetTempPathWrap             GetTempPathW
#define GetTextExtentPoint32Wrap    GetTextExtentPoint32W
#define GetTextFaceWrap             GetTextFaceW
#define GetTextMetricsWrap          GetTextMetricsW
#define GetTimeFormatWrap           GetTimeFormatW
#define GetDateFormatWrap           GetDateFormatW
#define GetUserNameWrap             GetUserNameW
#define GetWindowLongWrap           GetWindowLongW
#define GetWindowTextWrap           GetWindowTextW
#define GetWindowTextLengthWrap     GetWindowTextLengthW
#define GetWindowsDirectoryWrap     GetWindowsDirectoryW
#define InsertMenuItemWrap          InsertMenuItemW
#define InsertMenuWrap              InsertMenuW
#define IsBadStringPtrWrap          IsBadStringPtrW
#define IsDialogMessageWrap         IsDialogMessageW
#define LoadAcceleratorsWrap        LoadAcceleratorsW
#define LoadBitmapWrap              LoadBitmapW
#define LoadCursorWrap              LoadCursorW
#define LoadIconWrap                LoadIconW
#define LoadImageWrap               LoadImageW
#define LoadLibraryWrap             LoadLibraryW
#define LoadLibraryExWrap           LoadLibraryExW
#define LoadMenuWrap                LoadMenuW
#define LoadStringWrap              LoadStringW
#define MessageBoxIndirectWrap      MessageBoxIndirectW
#define MessageBoxWrap              MessageBoxW
#define ModifyMenuWrap              ModifyMenuW
#define GetCharWidth32Wrap          GetCharWidth32W
#define GetCharacterPlacementWrap   GetCharacterPlacementW
#define CopyFileWrap                CopyFileW
#define MoveFileWrap                MoveFileW
#define OemToCharWrap               OemToCharW
#define OutputDebugStringWrap       OutputDebugStringW
#define PeekMessageWrap             PeekMessageW
#define PostMessageWrap             PostMessageW
#define PostThreadMessageWrap       PostThreadMessageW
#define RegCreateKeyWrap            RegCreateKeyW
#define RegCreateKeyExWrap          RegCreateKeyExW
#define RegDeleteKeyWrap            RegDeleteKeyW
#define RegDeleteValueWrap          RegDeleteValueW
#define RegEnumKeyWrap              RegEnumKeyW
#define RegEnumKeyExWrap            RegEnumKeyExW
#define RegOpenKeyWrap              RegOpenKeyW
#define RegOpenKeyExWrap            RegOpenKeyExW
#define RegQueryInfoKeyWrap         RegQueryInfoKeyW
#define RegQueryValueWrap           RegQueryValueW
#define RegQueryValueExWrap         RegQueryValueExW
#define RegSetValueWrap             RegSetValueW
#define RegSetValueExWrap           RegSetValueExW
#define RegisterClassWrap           RegisterClassW
#define RegisterClassExWrap         RegisterClassExW
#define RegisterClipboardFormatWrap RegisterClipboardFormatW
#define RegisterWindowMessageWrap   RegisterWindowMessageW
#define RemovePropWrap              RemovePropW
#define SearchPathWrap              SearchPathW
#define SendDlgItemMessageWrap      SendDlgItemMessageW
#define SendMessageWrap             SendMessageW
#define SetCurrentDirectoryWrap     SetCurrentDirectoryW
#define SetDlgItemTextWrap          SetDlgItemTextW
#define SetMenuItemInfoWrap         SetMenuItemInfoW
#define SetPropWrap                 SetPropW
#define SetFileAttributesWrap       SetFileAttributesW
#define SetWindowLongWrap           SetWindowLongW
#define SetWindowsHookExWrap        SetWindowsHookExW
#define SHBrowseForFolderWrap       SHBrowseForFolderW
#define ShellExecuteExWrap          ShellExecuteExW
#define SHFileOperationWrap         SHFileOperationW
#define SHGetFileInfoWrap           SHGetFileInfoW
#define SHGetPathFromIDListWrap     SHGetPathFromIDListW
#define StartDocWrap                StartDocW
#define SystemParametersInfoWrap    SystemParametersInfoW
#define TranslateAcceleratorWrap    TranslateAcceleratorW
#define UnregisterClassWrap         UnregisterClassW
#define VkKeyScanWrap               VkKeyScanW
#define WinHelpWrap                 WinHelpW
#define WNetRestoreConnectionWrap   WNetRestoreConnectionW
#define WNetGetLastErrorWrap        WNetGetLastErrorW
#define wvsprintfWrap               wvsprintfW
#define CreateFontWrap              CreateFontW
#define DrawTextExWrap              DrawTextExW
#define GetMenuItemInfoWrap         GetMenuItemInfoWrapW
#define SetMenuItemInfoWrap         SetMenuItemInfoW
#define InsertMenuItemWrap          InsertMenuItemW
#define DragQueryFileWrap           DragQueryFileW

#else

#define IsCharAlphaWrap             IsCharAlphaA
#define IsCharUpperWrap             IsCharUpperA
#define IsCharLowerWrap             IsCharLowerA
#define IsCharAlphaNumericWrap      IsCharAlphaNumericA
#define AppendMenuWrap              AppendMenuA
#ifdef POST_IE5_BETA
#define CallMsgFilterWrap           CallMsgFilterA
#endif
#define CallWindowProcWrap          CallWindowProcA
#define CharLowerWrap               CharLowerA
#define CharLowerBuffWrap           CharLowerBuffA
#define CharNextWrap                CharNextA
#define CharPrevWrap                CharPrevA
#define CharToOemWrap               CharToOemA
#define CharUpperWrap               CharUpperA
#define CharUpperBuffWrap           CharUpperBuffA
#define CompareStringWrap           CompareStringA
#define CopyAcceleratorTableWrap    CopyAcceleratorTableA
#define CreateAcceleratorTableWrap  CreateAcceleratorTableA
#define CreateDCWrap                CreateDCA
#define CreateDirectoryWrap         CreateDirectoryA
#define CreateEventWrap             CreateEventA
#define CreateFontWrap              CreateFontA
#define CreateFileWrap              CreateFileA
#define CreateFontIndirectWrap      CreateFontIndirectA
#define CreateICWrap                CreateICA
#define CreateMetaFileWrap          CreateMetaFileA
#define CreateMutexWrap             CreateMutexA
#define CreateSemaphoreWrap         CreateSemaphoreA
#define CreateWindowExWrap          CreateWindowExA
#define DefWindowProcWrap           DefWindowProcA
#define DeleteFileWrap              DeleteFileA
#define DispatchMessageWrap         DispatchMessageA
#define DrawTextExWrap              DrawTextExA
#define DrawTextWrap                DrawTextA
#define EnumFontFamiliesWrap        EnumFontFamiliesA
#define EnumFontFamiliesExWrap      EnumFontFamiliesExA
#define EnumResourceNamesWrap       EnumResourceNamesA
#define ExpandEnvironmentStringsWrap ExpandEnvironmentStringsA
#define ExtractIconExWrap           ExtractIconExA
#define ExtTextOutWrap              ExtTextOutA
#define FindFirstFileWrap           FindFirstFileA
#define FindResourceWrap            FindResourceA
#define FindNextFileWrap            FindNextFileA
#define FindWindowWrap              FindWindowA
#define FindWindowExWrap            FindWindowExA
#define FormatMessageWrap           FormatMessageA
#define GetClassInfoWrap            GetClassInfoA
#define GetClassInfoExWrap          GetClassInfoExA
#define GetClassLongWrap            GetClassLongA
#define GetClassNameWrap            GetClassNameA
#define GetClipboardFormatNameWrap  GetClipboardFormatNameA
#define GetCurrentDirectoryWrap     GetCurrentDirectoryA
#define GetDlgItemTextWrap          GetDlgItemTextA
#define GetFileAttributesWrap       GetFileAttributesA
#define GetFullPathNameWrap         GetFullPathNameA
#define GetLocaleInfoWrap           GetLocaleInfoA
#define GetMenuItemInfoWrap         GetMenuItemInfoA
#define GetMenuStringWrap           GetMenuStringA
#define GetMessageWrap              GetMessageA
#define GetModuleFileNameWrap       GetModuleFileNameA
#define GetNumberFormatWrap         GetNumberFormatA
#define GetPrivateProfileStringWrap GetPrivateProfileStringA
#define WritePrivateProfileStringWrap WritePrivateProfileStringA
#define GetSystemDirectoryWrap      GetSystemDirectoryA
#define SearchPathWrap              SearchPathA
#define GetModuleHandleWrap         GetModuleHandleA
#define GetObjectWrap               GetObjectA
#define GetPrivateProfileIntWrap    GetPrivateProfileIntA
#define GetProfileStringWrap        GetProfileStringA
#define GetPropWrap                 GetPropA
#define GetStringTypeExWrap         GetStringTypeExA
#define GetTempFileNameWrap         GetTempFileNameA
#define GetTempPathWrap             GetTempPathA
#define GetTextExtentPoint32Wrap    GetTextExtentPoint32A
#define GetTextFaceWrap             GetTextFaceA
#define GetTextMetricsWrap          GetTextMetricsA
#define GetTimeFormatWrap           GetTimeFormatA
#define GetDateFormatWrap           GetDateFormatA
#define GetUserNameWrap             GetUserNameA
#define GetWindowLongWrap           GetWindowLongA
#define GetWindowTextWrap           GetWindowTextA
#define GetWindowTextLengthWrap     GetWindowTextLengthA
#define GetWindowsDirectoryWrap     GetWindowsDirectoryA
#define InsertMenuItemWrap          InsertMenuItemA
#define InsertMenuWrap              InsertMenuA
#define IsBadStringPtrWrap          IsBadStringPtrA
#define IsDialogMessageWrap         IsDialogMessageA
#define LoadAcceleratorsWrap        LoadAcceleratorsA
#define LoadBitmapWrap              LoadBitmapA
#define LoadCursorWrap              LoadCursorA
#define LoadIconWrap                LoadIconA
#define LoadImageWrap               LoadImageWrapA
#define LoadLibraryWrap             LoadLibraryA
#define LoadLibraryExWrap           LoadLibraryExA
#define LoadMenuWrap                LoadMenuA
#define LoadStringWrap              LoadStringA
#define MessageBoxIndirectWrap      MessageBoxIndirectA
#define MessageBoxWrap              MessageBoxA
#define ModifyMenuWrap              ModifyMenuA
#define GetCharWidth32Wrap          GetCharWidth32A
#define GetCharacterPlacementWrap   GetCharacterPlacementA
#define CopyFileWrap                CopyFileA
#define MoveFileWrap                MoveFileA
#define OemToCharWrap               OemToCharA
#define OutputDebugStringWrap       OutputDebugStringA
#define PeekMessageWrap             PeekMessageA
#define PostMessageWrap             PostMessageA
#define PostThreadMessageWrap       PostThreadMessageA
#define RegCreateKeyWrap            RegCreateKeyA
#define RegCreateKeyExWrap          RegCreateKeyExA
#define RegDeleteKeyWrap            RegDeleteKeyA
#define RegDeleteValueWrap          RegDeleteValueA
#define RegEnumKeyWrap              RegEnumKeyA
#define RegEnumKeyExWrap            RegEnumKeyExA
#define RegOpenKeyWrap              RegOpenKeyA
#define RegOpenKeyExWrap            RegOpenKeyExA
#define RegQueryInfoKeyWrap         RegQueryInfoKeyA
#define RegQueryValueWrap           RegQueryValueA
#define RegQueryValueExWrap         RegQueryValueExA
#define RegSetValueWrap             RegSetValueA
#define RegSetValueExWrap           RegSetValueExA
#define RegisterClassWrap           RegisterClassA
#define RegisterClassExWrap         RegisterClassExA
#define RegisterClipboardFormatWrap RegisterClipboardFormatA
#define RegisterWindowMessageWrap   RegisterWindowMessageA
#define RemovePropWrap              RemovePropA
#define SendDlgItemMessageWrap      SendDlgItemMessageA
#define SendMessageWrap             SendMessageA
#define SetCurrentDirectoryWrap     SetCurrentDirectoryA
#define SetDlgItemTextWrap          SetDlgItemTextA
#define SetMenuItemInfoWrap         SetMenuItemInfoA
#define SetPropWrap                 SetPropA
#define SetWindowLongWrap           SetWindowLongA
#define SHBrowseForFolderWrap       SHBrowseForFolderA
#define ShellExecuteExWrap          ShellExecuteExA
#define SHFileOperationWrap         SHFileOperationA
#define SHGetFileInfoWrap           SHGetFileInfoA
#define SHGetPathFromIDListWrap     SHGetPathFromIDListA
#define SetFileAttributesWrap       SetFileAttributesA
#define SetWindowsHookExWrap        SetWindowsHookExA
#define StartDocWrap                StartDocA
#define SystemParametersInfoWrap    SystemParametersInfoA
#define TranslateAcceleratorWrap    TranslateAcceleratorA
#define UnregisterClassWrap         UnregisterClassA
#define VkKeyScanWrap               VkKeyScanA
#define WinHelpWrap                 WinHelpA
#define WNetRestoreConnectionWrap   WNetRestoreConnectionA
#define WNetGetLastErrorWrap        WNetGetLastErrorA
#define wvsprintfWrap               wvsprintfA
#define CreateFontWrap              CreateFontA
#define DrawTextExWrap              DrawTextExA
#define GetMenuItemInfoWrap         GetMenuItemInfoA
#define SetMenuItemInfoWrap         SetMenuItemInfoA
#define InsertMenuItemWrap          InsertMenuItemA
#define DragQueryFileWrap           DragQueryFileA
#endif
#endif // defined(UNIX) && defined(NO_SHLWAPI_UNITHUNK)

// Some functions are used to wrap unicode win95 functions AND to provide ML wrappers,
// so they are needed unless BOTH NO_SHLWAPI_UNITHUNG and NO_SHLWAPI_MLUI are defined
//
#if (_WIN32_IE >= 0x0500) && (!defined(NO_SHLWAPI_UNITHUNK) || !defined(NO_SHLWAPI_MLUI))

LWSTDAPI_(HWND)
CreateDialogIndirectParamWrapW(
        HINSTANCE       hInstance,
        LPCDLGTEMPLATEW hDialogTemplate,
        HWND            hWndParent,
        DLGPROC         lpDialogFunc,
        LPARAM          dwInitParam);

LWSTDAPI_(HWND)
CreateDialogParamWrapW(
        HINSTANCE   hInstance,
        LPCWSTR     lpTemplateName,
        HWND        hWndParent,
        DLGPROC     lpDialogFunc,
        LPARAM      dwInitParam);

LWSTDAPI_(INT_PTR)
DialogBoxIndirectParamWrapW(
        HINSTANCE       hInstance,
        LPCDLGTEMPLATEW hDialogTemplate,
        HWND            hWndParent,
        DLGPROC         lpDialogFunc,
        LPARAM          dwInitParam);

LWSTDAPI_(INT_PTR)
DialogBoxParamWrapW(
        HINSTANCE   hInstance,
        LPCWSTR     lpszTemplate,
        HWND        hWndParent,
        DLGPROC     lpDialogFunc,
        LPARAM      dwInitParam);

LWSTDAPI_(BOOL) SetWindowTextWrapW(HWND hWnd, LPCWSTR lpString);


LWSTDAPI_(BOOL) DeleteMenuWrap(HMENU hMenu, UINT uPosition, UINT uFlags);

LWSTDAPI_(BOOL) DestroyMenuWrap(HMENU hMenu);

#ifdef UNICODE

#define CreateDialogIndirectParamWrap CreateDialogIndirectParamWrapW
#define CreateDialogParamWrap       CreateDialogParamWrapW
#define DialogBoxIndirectParamWrap  DialogBoxIndirectParamWrapW
#define DialogBoxParamWrap          DialogBoxParamWrapW
#define SetWindowTextWrap           SetWindowTextWrapW

#else

#define CreateDialogIndirectParamWrap CreateDialogIndirectParamA
#define CreateDialogParamWrap       CreateDialogParamA
#define DialogBoxIndirectParamWrap  DialogBoxIndirectParamA
#define DialogBoxParamWrap          DialogBoxParamA
#define SetWindowTextWrap           SetWindowTextA

#endif // UNICODE

#endif // (_WIN32_IE >= 0x0500) && !defined(NO_SHLWAPI_UNITHUNK) && !defined (NO_SHLWAPI_MLUI)


//=============== Thread Pool Services ===================================

#if (_WIN32_IE >= 0x0500) && !defined(NO_SHLWAPI_TPS)

//
// SHLWAPIP versions of KERNEL32 Thread Pool Services APIs
//

typedef void (NTAPI * WAITORTIMERCALLBACKFUNC)(void *, BOOLEAN);
typedef void (NTAPI * WORKERCALLBACKFUNC)(void *); // BUGBUG - why declare this?
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK;

LWSTDAPI_(HANDLE)
SHRegisterWaitForSingleObject(
    IN HANDLE hObject,
    IN WAITORTIMERCALLBACKFUNC pfnCallback,
    IN LPVOID pContext,
    IN DWORD dwMilliseconds,
    IN LPCSTR lpszLibrary OPTIONAL,
    IN DWORD dwFlags
    );

//
// flags for SHRegisterWaitForSingleObject (keep separate from other TPS flags)
//

//
// SRWSO_NOREMOVE - if set, the handle is not to be removed from the list once
// signalled. Intended for use with auto-reset events that the caller wants to
// keep until unregistered
//

#define SRWSO_NOREMOVE      0x00000100

#define SRWSO_VALID_FLAGS   (SRWSO_NOREMOVE)

#define SRWSO_INVALID_FLAGS (~SRWSO_VALID_FLAGS)

LWSTDAPI_(BOOL)
SHUnregisterWait(
    IN HANDLE hWait
    );

typedef struct {
    DWORD dwStructSize;
    DWORD dwMinimumWorkerThreads;
    DWORD dwMaximumWorkerThreads;
    DWORD dwMaximumWorkerQueueDepth;
    DWORD dwWorkerThreadIdleTimeout;
    DWORD dwWorkerThreadCreationDelta;
    DWORD dwMinimumIoWorkerThreads;
    DWORD dwMaximumIoWorkerThreads;
    DWORD dwMaximumIoWorkerQueueDepth;
    DWORD dwIoWorkerThreadCreationDelta;
} SH_THREAD_POOL_LIMITS, *PSH_THREAD_POOL_LIMITS;

LWSTDAPI_(BOOL)
SHSetThreadPoolLimits(
    IN PSH_THREAD_POOL_LIMITS pLimits
    );

LWSTDAPI_(BOOL)
SHTerminateThreadPool(
    VOID
    );

LWSTDAPI_(BOOL)
SHQueueUserWorkItem(
    IN LPTHREAD_START_ROUTINE pfnCallback,
    IN LPVOID pContext,
    IN LONG lPriority,
    IN DWORD_PTR dwTag,
    OUT DWORD_PTR * pdwId OPTIONAL,
    IN LPCSTR pszModule OPTIONAL,
    IN DWORD dwFlags
    );

LWSTDAPI_(DWORD)
SHCancelUserWorkItems(
    IN DWORD_PTR dwTagOrId,
    IN BOOL bTag
    );

LWSTDAPI_(HANDLE)
SHCreateTimerQueue(
    VOID
    );

LWSTDAPI_(BOOL)
SHDeleteTimerQueue(
    IN HANDLE hQueue
    );

LWSTDAPI_(HANDLE)
SHSetTimerQueueTimer(
    IN HANDLE hQueue,
    IN WAITORTIMERCALLBACK pfnCallback,
    IN LPVOID pContext,
    IN DWORD dwDueTime,
    IN DWORD dwPeriod,
    IN LPCSTR lpszLibrary OPTIONAL,
    IN DWORD dwFlags
    );

LWSTDAPI_(BOOL)
SHChangeTimerQueueTimer(
    IN HANDLE hQueue,
    IN HANDLE hTimer,
    IN DWORD dwDueTime,
    IN DWORD dwPeriod
    );

LWSTDAPI_(BOOL)
SHCancelTimerQueueTimer(
    IN HANDLE hQueue,
    IN HANDLE hTimer
    );

//
// Thread Pool Services flags
//

//
// TPS_EXECUTEIO - execute in I/O thread (via APC). Default is non-IO thread
//

#define TPS_EXECUTEIO       0x00000001

//
// TPS_TAGGEDITEM - the dwTag parameter is meaningful
//

#define TPS_TAGGEDITEM      0x00000002

//
// TPS_DEMANDTHREAD - always create a new thread if none currently available.
// Used in situations where immediate response required
//

#define TPS_DEMANDTHREAD    0x00000004

//
// TPS_LONGEXECTIME - the work item will take relatively long time to execute.
// Used as management hint to TPS
//

#define TPS_LONGEXECTIME    0x00000008

//
// TPS_RESERVED_FLAGS - mask of bits reserved for internal use
//

#define TPS_RESERVED_FLAGS  0xFF000000

#define TPS_VALID_FLAGS     (TPS_EXECUTEIO      \
                            | TPS_TAGGEDITEM    \
                            | TPS_DEMANDTHREAD  \
                            | TPS_LONGEXECTIME  \
                            )
#define TPS_INVALID_FLAGS   (~TPS_VALID_FLAGS)

#endif // (_WIN32_IE >= 0x0500) && !defined(NO_SHLWAPI_TPS)


//
// Private MIME helper functions used by shdocvw & shell32
//
#if (_WIN32_IE >= 0x0500)

LWSTDAPI_(BOOL) GetMIMETypeSubKeyA(LPCSTR pszMIMEType, LPSTR pszBuf, UINT cchBuf);
LWSTDAPI_(BOOL) GetMIMETypeSubKeyW(LPCWSTR pszMIMEType, LPWSTR pszBuf, UINT cchBuf);

LWSTDAPI_(BOOL) RegisterMIMETypeForExtensionA(LPCSTR pcszExtension, LPCSTR pcszMIMEContentType);
LWSTDAPI_(BOOL) RegisterMIMETypeForExtensionW(LPCWSTR pcszExtension, LPCWSTR pcszMIMEContentType);

LWSTDAPI_(BOOL) UnregisterMIMETypeForExtensionA(LPCSTR pcszExtension);
LWSTDAPI_(BOOL) UnregisterMIMETypeForExtensionW(LPCWSTR pcszExtension);

LWSTDAPI_(BOOL) RegisterExtensionForMIMETypeA(LPCSTR pcszExtension, LPCSTR pcszMIMEContentType);
LWSTDAPI_(BOOL) RegisterExtensionForMIMETypeW(LPCWSTR pcszExtension, LPCWSTR pcszMIMEContentType);

LWSTDAPI_(BOOL) UnregisterExtensionForMIMETypeA(LPCSTR pcszMIMEContentType);
LWSTDAPI_(BOOL) UnregisterExtensionForMIMETypeW(LPCWSTR pcszMIMEContentType);

LWSTDAPI_(BOOL) MIME_GetExtensionA(LPCSTR pcszMIMEType, LPSTR pszExtensionBuf, UINT ucExtensionBufLen);
LWSTDAPI_(BOOL) MIME_GetExtensionW(LPCWSTR pcszMIMEType, LPWSTR pszExtensionBuf, UINT ucExtensionBufLen);

#ifdef UNICODE
#define GetMIMETypeSubKey               GetMIMETypeSubKeyW
#define RegisterMIMETypeForExtension    RegisterMIMETypeForExtensionW
#define UnregisterMIMETypeForExtension  UnregisterMIMETypeForExtensionW
#define RegisterExtensionForMIMEType    RegisterExtensionForMIMETypeW
#define UnregisterExtensionForMIMEType  UnregisterExtensionForMIMETypeW
#define MIME_GetExtension               MIME_GetExtensionW
#else
#define GetMIMETypeSubKey               GetMIMETypeSubKeyA
#define RegisterMIMETypeForExtension    RegisterMIMETypeForExtensionA
#define UnregisterMIMETypeForExtension  UnregisterMIMETypeForExtensionA
#define RegisterExtensionForMIMEType    RegisterExtensionForMIMETypeA
#define UnregisterExtensionForMIMEType  UnregisterExtensionForMIMETypeA
#define MIME_GetExtension               MIME_GetExtensionA
#endif

// Options for SHGetMachineInfo

//
//  Note that GMI_DOCKSTATE is unreliable for ACPI laptops.
//
#define GMI_DOCKSTATE           0x0000
    // Return values for SHGetMachineInfo(GMI_DOCKSTATE)
    #define GMID_NOTDOCKABLE         0  // Cannot be docked
    #define GMID_UNDOCKED            1  // Is undocked
    #define GMID_DOCKED              2  // Is docked

//
//  GMI_BATTERYSTATE reports on the presence and status of non-UPS
//  batteries.
//
#define GMI_BATTERYSTATE        0x0001
    // Return value for SHGetMachineInfo(GMI_BATTERYSTATE) is a bitmask
    #define GMIB_HASBATTERY          0x0001 // Can run on batteries
    #define GMIB_ONBATTERY           0x0002 // Is now on batteries

//
//  WARNING!  DANGER!  EVIL!
//
//  GMI_LAPTOP is not perfect.  It can be fooled by particular hardware
//  configurations.  You are much better off asking specifically why you
//  care about laptops and use one of the above GMI values instead.  For
//  example, if you want to scale back some intensive operation so you
//  don't drain the battery, use GMI_BATTERYSTATE instead.
//
#define GMI_LAPTOP              0x0002  // Returns nonzero if might be a laptop

#if (_WIN32_IE >= 0x0501)

//
//  GMI_TSCLIENT tells you whether you are running as a Terminal Server
//  client and should disable your animations.
//
#define GMI_TSCLIENT            0x0003  // Returns nonzero if TS client

#endif // (_WIN32_IE >= 0x0501)

LWSTDAPI_(DWORD_PTR) SHGetMachineInfo(UINT gmi);

// support InterlockedCompareExchange() on Win95

LWSTDAPI_(void *) SHInterlockedCompareExchange(void **ppDest, void *pExch, void *pComp);

#if !defined(_X86_)
// Win95 doesn't run on Alpha/UNIX so we can use the OS function directly
// Use a #define instead of a forwarder because it's an intrinsic on most
// compilers.
#define SHInterlockedCompareExchange InterlockedCompareExchangePointer
#endif

LWSTDAPI_(BOOL) SHMirrorIcon(HICON* phiconSmall, HICON* phiconLarge);


#endif // (_WIN32_IE >= 0x0500)


//  Raw Accelerator Table API
//
//  Allows an accelerator table grep without having to invoke ::TranslateAccelerator.
//  Useful for dealing with parent-child window accelerator conflicts.
//

//  HANDLE SHLoadRawAccelerators( HINSTANCE hInst, LPCTSTR lpTableName );
//  Loads the raw accelerator table.
//  hInst       Module instance containing the accelerator resource.
//  lpTableName Names the accelerator table resource to load.

//  The return value is a handle that can be passed to a SHQueryRawAcceleratorXXX function.
//  When the handle is no longer required, it should be freed with LocalFree().
LWSTDAPI_(HANDLE) SHLoadRawAccelerators   ( HINSTANCE hInst, LPCTSTR lpTableName );

//  BOOL SHQueryRawAccelerator   ( HANDLE hcaAcc, IN BYTE fVirtMask, IN BYTE fVirt, IN WPARAM wKey, OUT OPTIONAL UINT* puCmdID );
//  Queries the raw accelererator table for the specified key
//  hcaAcc      Handle returned from SHLoadRawAccelerators().
//  fVirtMask   Relevant accelerator flags (any combo of FALT|FCONTROL|FNOINVERT|FSHIFT|FVIRTKEY)
//  fVirt       Accelerator flags to test (any combo of FALT|FCONTROL|FNOINVERT|FSHIFT|FVIRTKEY).
//  wKey        Accelerator key.  This can either be a virtual key (FVIRTKEY) or an ASCII char code.
//  puCmdID     Optional address to receive command identifier for the accelerator entry if
//              the key is in the table.
//  Returns nonzero if the key is in the accelerator table; otherwise 0.
LWSTDAPI_(BOOL)   SHQueryRawAccelerator   ( HANDLE hcaAcc, IN BYTE fVirtMask, IN BYTE fVirt, IN WPARAM wKey, OUT OPTIONAL UINT* puCmdID );

//  BOOL SHQueryRawAcceleratorMsg( HANDLE hcaAcc, MSG* pmsg, OUT OPTIONAL UINT* puCmdID );
//  Determines whether the specified message is an accelerator message mapping to
//  an entry in the raw accelerator table.
//  hcaAcc      Handle returned from SHLoadRawAccelerators().
//  pmsg        Address of the message to test.
//  puCmdID     Optional address to receive command identifier for the accelerator entry if
//              the message maps to an accelerator in the table.
//  Returns nonzero if the message is a WM_KEYUP or WM_KEYDOWN and the key is in
//  the accelerator table; otherwise 0.
LWSTDAPI_(BOOL)   SHQueryRawAcceleratorMsg( HANDLE hcaAcc, MSG* pmsg, OUT OPTIONAL UINT* puCmdID );
//
//

LWSTDAPI_(BOOL) SHBoolSystemParametersInfo(UINT uiAction, DWORD *pdwParam);

LWSTDAPI_(BOOL) SHAreIconsEqual(HICON hIcon1, HICON hIcon2);

//
//====== End Internal functions  ===============================================
//
#endif // NO_SHLWAPI_INTERNAL

#ifdef NOTYET       // BUGBUG (scotth): once this is implemented, make this public
// SHGetCommonResourceID
//
// (use MAKEINTRESOURCE on the following IDs)

// These values are indexes into an internal table.  Be careful.
#define SHGCR_BITMAP_WINDOWS_LOGO   MAKEINTRESOURCE(1)
#define SHGCR_AVI_FLASHLIGHT        MAKEINTRESOURCE(2)
#define SHGCR_AVI_FINDFILE          MAKEINTRESOURCE(3)
#define SHGCR_AVI_FINDCOMPUTER      MAKEINTRESOURCE(4)
#define SHGCR_AVI_FILEMOVE          MAKEINTRESOURCE(5)
#define SHGCR_AVI_FILECOPY          MAKEINTRESOURCE(6)
#define SHGCR_AVI_FILEDELETE        MAKEINTRESOURCE(7)
#define SHGCR_AVI_EMPTYWASTEBASKET  MAKEINTRESOURCE(8)
#define SHGCR_AVI_FILEREALDELETE    MAKEINTRESOURCE(9)      // Bypass Recycle Bin
#define SHGCR_AVI_DOWNLOAD          MAKEINTRESOURCE(10)

LWSTDAPI SHGetCommonResourceIDA(IN LPCSTR pszID, IN DWORD dwRes, OUT HMODULE * phmod, OUT UINT * pnID);
LWSTDAPI SHGetCommonResourceIDA(IN LPCSTR pszID, IN DWORD dwRes, OUT HMODULE * phmod, OUT UINT * pnID);

#ifdef UNICODE
#define SHGetCommonResourceID   SHGetCommonResourceIDW
#else
#define SHGetCommonResourceID   SHGetCommonResourceIDW
#endif
#endif // NOTYET
    // dwFlags is really for alignment purposes
#if (_WIN32_IE >= 0x0501)
//
// ======== SHGetAppCompatFlags ================================================
//

//===========================================================================
// Shell Application Compatability flags

// SHGetAppCompatFlags flags
#define ACF_NONE               0x00000000
#define ACF_CONTEXTMENU        0x00000001
#define ACF_CORELINTERNETENUM  0x00000004 // corel suite 8 has this same problem as suite 7 but does not have context menu one so need new bit
#define ACF_OLDCREATEVIEWWND   0x00000004 // PowerDesk relies on CreateViewWindow returning S_OK
#define ACF_WIN95DEFVIEW       0x00000004   // for apps that depend on win95 defview behavior
#define ACF_DOCOBJECT          0x00000002
#define ACF_FLUSHNOWAITALWAYS  0x00000001
#define ACF_MYCOMPUTERFIRST    0x00000008 // MyComp must be first item on the desktop
#define ACF_OLDREGITEMGDN      0x00000010 // Win95-compatible GetDisplayNameOf on regitems
#define ACF_LOADCOLUMNHANDLER  0x00000040 // Dont delay load column handler.
#define ACF_ANSI               0x00000080 // For Apps that Pass in ANSI Strings
#define ACF_STRIPFOLDERBIT     0x00000100 // nuke the folder GAO in file dialog (for folder shortcuts, zip & cab files)
#define ACF_WIN95SHLEXEC       0x00000200 // dont use DDEWAIT when thunking to ShellExecEx()
#define ACF_STAROFFICE5PRINTER 0x00000400 // special return values from printer folder GAO
#define ACF_NOVALIDATEFSIDS    0x00000800 // FS pidls should not be validated.
#define ACF_FILEOPENNEEDSEXT   0x00001000 // Need to show extensioin in the name box of the open file common dialog
#define ACF_WIN95BINDTOOBJECT  0x00002000 // Win95 BindToObject behavior dependencies
#define ACF_IGNOREENUMRESET    0x00004000 // App relies on IEnumIDList::Reset returning E_NOTIMPL
#define ACF_ANSIDISPLAYNAMES   0x00010000 // calling process requires the ISF::GDN in ansi
#define ACF_FILEOPENBOGUSCTRLID 0x00020000 // Requires that the toolbar in fileopen have ctrl ID == ID_OK
#define ACF_FORCELFNIDLIST     0x00040000 // forces no AltName in the FS pidls (for apps that read directly from the pidl)
#define ACF_APPISOFFICE        0x01000000 // calling app is office (95, 97, 2000, ++)
#define ACF_KNOWPERPROCESS     0x80000000 // We know the per process flags already.

                                // The flags that are per-process
#define ACF_PERPROCESSFLAGS    (ACF_CONTEXTMENU | ACF_CORELINTERNETENUM | ACF_OLDCREATEVIEWWND | ACF_WIN95DEFVIEW | \
                                ACF_DOCOBJECT | ACF_FLUSHNOWAITALWAYS | ACF_MYCOMPUTERFIRST | ACF_OLDREGITEMGDN | \
                                ACF_LOADCOLUMNHANDLER | ACF_ANSI | ACF_WIN95SHLEXEC | ACF_STAROFFICE5PRINTER | \
                                ACF_NOVALIDATEFSIDS | ACF_FILEOPENNEEDSEXT | ACF_WIN95BINDTOOBJECT | \
                                ACF_IGNOREENUMRESET | ACF_ANSIDISPLAYNAMES | ACF_FILEOPENBOGUSCTRLID | ACF_FORCELFNIDLIST)

                                // Flags that are per caller
#define ACF_PERCALLFLAGS        (ACF_APPISOFFICE | ACF_STRIPFOLDERBIT)


LWSTDAPI_(DWORD) SHGetAppCompatFlags (DWORD dwFlagsNeeded);

enum {
    OBJCOMPATF_OTNEEDSSFCACHE          = 0x00000001,
    OBJCOMPATF_NO_WEBVIEW              = 0x00000002,
    OBJCOMPATF_UNBINDABLE              = 0x00000004,
    OBJCOMPATF_PINDLL                  = 0x00000008,
    OBJCOMPATF_NEEDSFILESYSANCESTOR    = 0x00000010,
    OBJCOMPATF_NOTAFILESYSTEM          = 0x00000020,
    OBJCOMPATF_CTXMENU_NOVERBS         = 0x00000040,
    OBJCOMPATF_CTXMENU_LIMITEDQI       = 0x00000080,
    OBJCOMPATF_COCREATESHELLFOLDERONLY = 0x00000100,
    OBJCOMPATF_NEEDSSTORAGEANCESTOR    = 0x00000200,
    OBJCOMPATF_NOLEGACYWEBVIEW         = 0x00000400,
    OBJCOMPATF_BLOCKSHELLSERVICEOBJECT    = 0x00000800,
} ;

typedef DWORD OBJCOMPATFLAGS;

LWSTDAPI_(OBJCOMPATFLAGS) SHGetObjectCompatFlags(IUnknown *punk, const CLSID *pclsid);

#endif // (_WIN32_IE >= 0x0501)

#if (_WIN32_IE >= 0x0560)
LWSTDAPI_(UINT) GetUIVersion();
#endif // (_WIN32_IE >= 0x0560)


#ifdef __cplusplus
}
#endif

#ifdef _WIN32
#include <poppack.h>
#endif

#endif

#endif  // _INC_SHLWAPIP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\shpriv.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for shpriv.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __shpriv_h__
#define __shpriv_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICustomIconManager_FWD_DEFINED__
#define __ICustomIconManager_FWD_DEFINED__
typedef interface ICustomIconManager ICustomIconManager;
#endif 	/* __ICustomIconManager_FWD_DEFINED__ */


#ifndef __IImageListPersistStream_FWD_DEFINED__
#define __IImageListPersistStream_FWD_DEFINED__
typedef interface IImageListPersistStream IImageListPersistStream;
#endif 	/* __IImageListPersistStream_FWD_DEFINED__ */


#ifndef __IImageListPriv_FWD_DEFINED__
#define __IImageListPriv_FWD_DEFINED__
typedef interface IImageListPriv IImageListPriv;
#endif 	/* __IImageListPriv_FWD_DEFINED__ */


#ifndef __IMarkupCallback_FWD_DEFINED__
#define __IMarkupCallback_FWD_DEFINED__
typedef interface IMarkupCallback IMarkupCallback;
#endif 	/* __IMarkupCallback_FWD_DEFINED__ */


#ifndef __IControlMarkup_FWD_DEFINED__
#define __IControlMarkup_FWD_DEFINED__
typedef interface IControlMarkup IControlMarkup;
#endif 	/* __IControlMarkup_FWD_DEFINED__ */


#ifndef __IThemeUIPages_FWD_DEFINED__
#define __IThemeUIPages_FWD_DEFINED__
typedef interface IThemeUIPages IThemeUIPages;
#endif 	/* __IThemeUIPages_FWD_DEFINED__ */


#ifndef __IAdvancedDialog_FWD_DEFINED__
#define __IAdvancedDialog_FWD_DEFINED__
typedef interface IAdvancedDialog IAdvancedDialog;
#endif 	/* __IAdvancedDialog_FWD_DEFINED__ */


#ifndef __IBasePropPage_FWD_DEFINED__
#define __IBasePropPage_FWD_DEFINED__
typedef interface IBasePropPage IBasePropPage;
#endif 	/* __IBasePropPage_FWD_DEFINED__ */


#ifndef __IPreviewSystemMetrics_FWD_DEFINED__
#define __IPreviewSystemMetrics_FWD_DEFINED__
typedef interface IPreviewSystemMetrics IPreviewSystemMetrics;
#endif 	/* __IPreviewSystemMetrics_FWD_DEFINED__ */


#ifndef __IAssocHandler_FWD_DEFINED__
#define __IAssocHandler_FWD_DEFINED__
typedef interface IAssocHandler IAssocHandler;
#endif 	/* __IAssocHandler_FWD_DEFINED__ */


#ifndef __IEnumAssocHandlers_FWD_DEFINED__
#define __IEnumAssocHandlers_FWD_DEFINED__
typedef interface IEnumAssocHandlers IEnumAssocHandlers;
#endif 	/* __IEnumAssocHandlers_FWD_DEFINED__ */


#ifndef __IHWDevice_FWD_DEFINED__
#define __IHWDevice_FWD_DEFINED__
typedef interface IHWDevice IHWDevice;
#endif 	/* __IHWDevice_FWD_DEFINED__ */


#ifndef __IHWDeviceCustomProperties_FWD_DEFINED__
#define __IHWDeviceCustomProperties_FWD_DEFINED__
typedef interface IHWDeviceCustomProperties IHWDeviceCustomProperties;
#endif 	/* __IHWDeviceCustomProperties_FWD_DEFINED__ */


#ifndef __IEnumAutoplayHandler_FWD_DEFINED__
#define __IEnumAutoplayHandler_FWD_DEFINED__
typedef interface IEnumAutoplayHandler IEnumAutoplayHandler;
#endif 	/* __IEnumAutoplayHandler_FWD_DEFINED__ */


#ifndef __IAutoplayHandler_FWD_DEFINED__
#define __IAutoplayHandler_FWD_DEFINED__
typedef interface IAutoplayHandler IAutoplayHandler;
#endif 	/* __IAutoplayHandler_FWD_DEFINED__ */


#ifndef __IAutoplayHandlerProperties_FWD_DEFINED__
#define __IAutoplayHandlerProperties_FWD_DEFINED__
typedef interface IAutoplayHandlerProperties IAutoplayHandlerProperties;
#endif 	/* __IAutoplayHandlerProperties_FWD_DEFINED__ */


#ifndef __IHardwareDeviceCallback_FWD_DEFINED__
#define __IHardwareDeviceCallback_FWD_DEFINED__
typedef interface IHardwareDeviceCallback IHardwareDeviceCallback;
#endif 	/* __IHardwareDeviceCallback_FWD_DEFINED__ */


#ifndef __IHardwareDevicesEnum_FWD_DEFINED__
#define __IHardwareDevicesEnum_FWD_DEFINED__
typedef interface IHardwareDevicesEnum IHardwareDevicesEnum;
#endif 	/* __IHardwareDevicesEnum_FWD_DEFINED__ */


#ifndef __IHardwareDevicesVolumesEnum_FWD_DEFINED__
#define __IHardwareDevicesVolumesEnum_FWD_DEFINED__
typedef interface IHardwareDevicesVolumesEnum IHardwareDevicesVolumesEnum;
#endif 	/* __IHardwareDevicesVolumesEnum_FWD_DEFINED__ */


#ifndef __IHardwareDevicesMountPointsEnum_FWD_DEFINED__
#define __IHardwareDevicesMountPointsEnum_FWD_DEFINED__
typedef interface IHardwareDevicesMountPointsEnum IHardwareDevicesMountPointsEnum;
#endif 	/* __IHardwareDevicesMountPointsEnum_FWD_DEFINED__ */


#ifndef __IHardwareDevices_FWD_DEFINED__
#define __IHardwareDevices_FWD_DEFINED__
typedef interface IHardwareDevices IHardwareDevices;
#endif 	/* __IHardwareDevices_FWD_DEFINED__ */


#ifndef __IStartMenuPin_FWD_DEFINED__
#define __IStartMenuPin_FWD_DEFINED__
typedef interface IStartMenuPin IStartMenuPin;
#endif 	/* __IStartMenuPin_FWD_DEFINED__ */


#ifndef __IDefCategoryProvider_FWD_DEFINED__
#define __IDefCategoryProvider_FWD_DEFINED__
typedef interface IDefCategoryProvider IDefCategoryProvider;
#endif 	/* __IDefCategoryProvider_FWD_DEFINED__ */


#ifndef __IInitAccessible_FWD_DEFINED__
#define __IInitAccessible_FWD_DEFINED__
typedef interface IInitAccessible IInitAccessible;
#endif 	/* __IInitAccessible_FWD_DEFINED__ */


#ifndef __IInitTrackPopupBar_FWD_DEFINED__
#define __IInitTrackPopupBar_FWD_DEFINED__
typedef interface IInitTrackPopupBar IInitTrackPopupBar;
#endif 	/* __IInitTrackPopupBar_FWD_DEFINED__ */


#ifndef __ICompositeFolder_FWD_DEFINED__
#define __ICompositeFolder_FWD_DEFINED__
typedef interface ICompositeFolder ICompositeFolder;
#endif 	/* __ICompositeFolder_FWD_DEFINED__ */


#ifndef __IEnumShellReminder_FWD_DEFINED__
#define __IEnumShellReminder_FWD_DEFINED__
typedef interface IEnumShellReminder IEnumShellReminder;
#endif 	/* __IEnumShellReminder_FWD_DEFINED__ */


#ifndef __IShellReminderManager_FWD_DEFINED__
#define __IShellReminderManager_FWD_DEFINED__
typedef interface IShellReminderManager IShellReminderManager;
#endif 	/* __IShellReminderManager_FWD_DEFINED__ */


#ifndef __IDeskBandEx_FWD_DEFINED__
#define __IDeskBandEx_FWD_DEFINED__
typedef interface IDeskBandEx IDeskBandEx;
#endif 	/* __IDeskBandEx_FWD_DEFINED__ */


#ifndef __INotificationCB_FWD_DEFINED__
#define __INotificationCB_FWD_DEFINED__
typedef interface INotificationCB INotificationCB;
#endif 	/* __INotificationCB_FWD_DEFINED__ */


#ifndef __ITrayNotify_FWD_DEFINED__
#define __ITrayNotify_FWD_DEFINED__
typedef interface ITrayNotify ITrayNotify;
#endif 	/* __ITrayNotify_FWD_DEFINED__ */


#ifndef __IMagic_FWD_DEFINED__
#define __IMagic_FWD_DEFINED__
typedef interface IMagic IMagic;
#endif 	/* __IMagic_FWD_DEFINED__ */


#ifndef __IResourceMap_FWD_DEFINED__
#define __IResourceMap_FWD_DEFINED__
typedef interface IResourceMap IResourceMap;
#endif 	/* __IResourceMap_FWD_DEFINED__ */


#ifndef __IHomeNetworkWizard_FWD_DEFINED__
#define __IHomeNetworkWizard_FWD_DEFINED__
typedef interface IHomeNetworkWizard IHomeNetworkWizard;
#endif 	/* __IHomeNetworkWizard_FWD_DEFINED__ */


#ifndef __IEnumShellItems_FWD_DEFINED__
#define __IEnumShellItems_FWD_DEFINED__
typedef interface IEnumShellItems IEnumShellItems;
#endif 	/* __IEnumShellItems_FWD_DEFINED__ */


#ifndef __IParentAndItem_FWD_DEFINED__
#define __IParentAndItem_FWD_DEFINED__
typedef interface IParentAndItem IParentAndItem;
#endif 	/* __IParentAndItem_FWD_DEFINED__ */


#ifndef __IShellItemArray_FWD_DEFINED__
#define __IShellItemArray_FWD_DEFINED__
typedef interface IShellItemArray IShellItemArray;
#endif 	/* __IShellItemArray_FWD_DEFINED__ */


#ifndef __IItemHandler_FWD_DEFINED__
#define __IItemHandler_FWD_DEFINED__
typedef interface IItemHandler IItemHandler;
#endif 	/* __IItemHandler_FWD_DEFINED__ */


#ifndef __IShellFolderNames_FWD_DEFINED__
#define __IShellFolderNames_FWD_DEFINED__
typedef interface IShellFolderNames IShellFolderNames;
#endif 	/* __IShellFolderNames_FWD_DEFINED__ */


#ifndef __IFolderItemsView_FWD_DEFINED__
#define __IFolderItemsView_FWD_DEFINED__
typedef interface IFolderItemsView IFolderItemsView;
#endif 	/* __IFolderItemsView_FWD_DEFINED__ */


#ifndef __ILocalCopy_FWD_DEFINED__
#define __ILocalCopy_FWD_DEFINED__
typedef interface ILocalCopy ILocalCopy;
#endif 	/* __ILocalCopy_FWD_DEFINED__ */


#ifndef __IDefViewFrame3_FWD_DEFINED__
#define __IDefViewFrame3_FWD_DEFINED__
typedef interface IDefViewFrame3 IDefViewFrame3;
#endif 	/* __IDefViewFrame3_FWD_DEFINED__ */


#ifndef __IDisplaySettings_FWD_DEFINED__
#define __IDisplaySettings_FWD_DEFINED__
typedef interface IDisplaySettings IDisplaySettings;
#endif 	/* __IDisplaySettings_FWD_DEFINED__ */


#ifndef __IScreenResFixer_FWD_DEFINED__
#define __IScreenResFixer_FWD_DEFINED__
typedef interface IScreenResFixer IScreenResFixer;
#endif 	/* __IScreenResFixer_FWD_DEFINED__ */


#ifndef __IShellTreeWalkerCallBack_FWD_DEFINED__
#define __IShellTreeWalkerCallBack_FWD_DEFINED__
typedef interface IShellTreeWalkerCallBack IShellTreeWalkerCallBack;
#endif 	/* __IShellTreeWalkerCallBack_FWD_DEFINED__ */


#ifndef __IShellTreeWalker_FWD_DEFINED__
#define __IShellTreeWalker_FWD_DEFINED__
typedef interface IShellTreeWalker IShellTreeWalker;
#endif 	/* __IShellTreeWalker_FWD_DEFINED__ */


#ifndef __IUIElement_FWD_DEFINED__
#define __IUIElement_FWD_DEFINED__
typedef interface IUIElement IUIElement;
#endif 	/* __IUIElement_FWD_DEFINED__ */


#ifndef __IUICommand_FWD_DEFINED__
#define __IUICommand_FWD_DEFINED__
typedef interface IUICommand IUICommand;
#endif 	/* __IUICommand_FWD_DEFINED__ */


#ifndef __IEnumUICommand_FWD_DEFINED__
#define __IEnumUICommand_FWD_DEFINED__
typedef interface IEnumUICommand IEnumUICommand;
#endif 	/* __IEnumUICommand_FWD_DEFINED__ */


#ifndef __IUICommandTarget_FWD_DEFINED__
#define __IUICommandTarget_FWD_DEFINED__
typedef interface IUICommandTarget IUICommandTarget;
#endif 	/* __IUICommandTarget_FWD_DEFINED__ */


#ifndef __IFileSystemStorage_FWD_DEFINED__
#define __IFileSystemStorage_FWD_DEFINED__
typedef interface IFileSystemStorage IFileSystemStorage;
#endif 	/* __IFileSystemStorage_FWD_DEFINED__ */


#ifndef __IDynamicStorage_FWD_DEFINED__
#define __IDynamicStorage_FWD_DEFINED__
typedef interface IDynamicStorage IDynamicStorage;
#endif 	/* __IDynamicStorage_FWD_DEFINED__ */


#ifndef __ITransferAdviseSink_FWD_DEFINED__
#define __ITransferAdviseSink_FWD_DEFINED__
typedef interface ITransferAdviseSink ITransferAdviseSink;
#endif 	/* __ITransferAdviseSink_FWD_DEFINED__ */


#ifndef __ITransferDest_FWD_DEFINED__
#define __ITransferDest_FWD_DEFINED__
typedef interface ITransferDest ITransferDest;
#endif 	/* __ITransferDest_FWD_DEFINED__ */


#ifndef __IStorageProcessor_FWD_DEFINED__
#define __IStorageProcessor_FWD_DEFINED__
typedef interface IStorageProcessor IStorageProcessor;
#endif 	/* __IStorageProcessor_FWD_DEFINED__ */


#ifndef __ITransferConfirmation_FWD_DEFINED__
#define __ITransferConfirmation_FWD_DEFINED__
typedef interface ITransferConfirmation ITransferConfirmation;
#endif 	/* __ITransferConfirmation_FWD_DEFINED__ */


#ifndef __ICDBurnPriv_FWD_DEFINED__
#define __ICDBurnPriv_FWD_DEFINED__
typedef interface ICDBurnPriv ICDBurnPriv;
#endif 	/* __ICDBurnPriv_FWD_DEFINED__ */


#ifndef __IDriveFolderExt_FWD_DEFINED__
#define __IDriveFolderExt_FWD_DEFINED__
typedef interface IDriveFolderExt IDriveFolderExt;
#endif 	/* __IDriveFolderExt_FWD_DEFINED__ */


#ifndef __ICustomizeInfoTip_FWD_DEFINED__
#define __ICustomizeInfoTip_FWD_DEFINED__
typedef interface ICustomizeInfoTip ICustomizeInfoTip;
#endif 	/* __ICustomizeInfoTip_FWD_DEFINED__ */


#ifndef __IFadeTask_FWD_DEFINED__
#define __IFadeTask_FWD_DEFINED__
typedef interface IFadeTask IFadeTask;
#endif 	/* __IFadeTask_FWD_DEFINED__ */


#ifndef __ISetFolderEnumRestriction_FWD_DEFINED__
#define __ISetFolderEnumRestriction_FWD_DEFINED__
typedef interface ISetFolderEnumRestriction ISetFolderEnumRestriction;
#endif 	/* __ISetFolderEnumRestriction_FWD_DEFINED__ */


#ifndef __IObjectWithRegistryKey_FWD_DEFINED__
#define __IObjectWithRegistryKey_FWD_DEFINED__
typedef interface IObjectWithRegistryKey IObjectWithRegistryKey;
#endif 	/* __IObjectWithRegistryKey_FWD_DEFINED__ */


#ifndef __IQuerySource_FWD_DEFINED__
#define __IQuerySource_FWD_DEFINED__
typedef interface IQuerySource IQuerySource;
#endif 	/* __IQuerySource_FWD_DEFINED__ */


#ifndef __IPersistString2_FWD_DEFINED__
#define __IPersistString2_FWD_DEFINED__
typedef interface IPersistString2 IPersistString2;
#endif 	/* __IPersistString2_FWD_DEFINED__ */


#ifndef __IObjectWithQuerySource_FWD_DEFINED__
#define __IObjectWithQuerySource_FWD_DEFINED__
typedef interface IObjectWithQuerySource IObjectWithQuerySource;
#endif 	/* __IObjectWithQuerySource_FWD_DEFINED__ */


#ifndef __IAssociationElement_FWD_DEFINED__
#define __IAssociationElement_FWD_DEFINED__
typedef interface IAssociationElement IAssociationElement;
#endif 	/* __IAssociationElement_FWD_DEFINED__ */


#ifndef __IEnumAssociationElements_FWD_DEFINED__
#define __IEnumAssociationElements_FWD_DEFINED__
typedef interface IEnumAssociationElements IEnumAssociationElements;
#endif 	/* __IEnumAssociationElements_FWD_DEFINED__ */


#ifndef __IAssociationArrayInitialize_FWD_DEFINED__
#define __IAssociationArrayInitialize_FWD_DEFINED__
typedef interface IAssociationArrayInitialize IAssociationArrayInitialize;
#endif 	/* __IAssociationArrayInitialize_FWD_DEFINED__ */


#ifndef __IAssociationArray_FWD_DEFINED__
#define __IAssociationArray_FWD_DEFINED__
typedef interface IAssociationArray IAssociationArray;
#endif 	/* __IAssociationArray_FWD_DEFINED__ */


#ifndef __IAlphaThumbnailExtractor_FWD_DEFINED__
#define __IAlphaThumbnailExtractor_FWD_DEFINED__
typedef interface IAlphaThumbnailExtractor IAlphaThumbnailExtractor;
#endif 	/* __IAlphaThumbnailExtractor_FWD_DEFINED__ */


#ifndef __IQueryPropertyFlags_FWD_DEFINED__
#define __IQueryPropertyFlags_FWD_DEFINED__
typedef interface IQueryPropertyFlags IQueryPropertyFlags;
#endif 	/* __IQueryPropertyFlags_FWD_DEFINED__ */


#ifndef __HWEventSettings_FWD_DEFINED__
#define __HWEventSettings_FWD_DEFINED__

#ifdef __cplusplus
typedef class HWEventSettings HWEventSettings;
#else
typedef struct HWEventSettings HWEventSettings;
#endif /* __cplusplus */

#endif 	/* __HWEventSettings_FWD_DEFINED__ */


#ifndef __AutoplayHandlerProperties_FWD_DEFINED__
#define __AutoplayHandlerProperties_FWD_DEFINED__

#ifdef __cplusplus
typedef class AutoplayHandlerProperties AutoplayHandlerProperties;
#else
typedef struct AutoplayHandlerProperties AutoplayHandlerProperties;
#endif /* __cplusplus */

#endif 	/* __AutoplayHandlerProperties_FWD_DEFINED__ */


#ifndef __HWDevice_FWD_DEFINED__
#define __HWDevice_FWD_DEFINED__

#ifdef __cplusplus
typedef class HWDevice HWDevice;
#else
typedef struct HWDevice HWDevice;
#endif /* __cplusplus */

#endif 	/* __HWDevice_FWD_DEFINED__ */


#ifndef __HardwareDevices_FWD_DEFINED__
#define __HardwareDevices_FWD_DEFINED__

#ifdef __cplusplus
typedef class HardwareDevices HardwareDevices;
#else
typedef struct HardwareDevices HardwareDevices;
#endif /* __cplusplus */

#endif 	/* __HardwareDevices_FWD_DEFINED__ */


#ifndef __HWDeviceCustomProperties_FWD_DEFINED__
#define __HWDeviceCustomProperties_FWD_DEFINED__

#ifdef __cplusplus
typedef class HWDeviceCustomProperties HWDeviceCustomProperties;
#else
typedef struct HWDeviceCustomProperties HWDeviceCustomProperties;
#endif /* __cplusplus */

#endif 	/* __HWDeviceCustomProperties_FWD_DEFINED__ */


#ifndef __DefCategoryProvider_FWD_DEFINED__
#define __DefCategoryProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class DefCategoryProvider DefCategoryProvider;
#else
typedef struct DefCategoryProvider DefCategoryProvider;
#endif /* __cplusplus */

#endif 	/* __DefCategoryProvider_FWD_DEFINED__ */


#ifndef __VersionColProvider_FWD_DEFINED__
#define __VersionColProvider_FWD_DEFINED__

#ifdef __cplusplus
typedef class VersionColProvider VersionColProvider;
#else
typedef struct VersionColProvider VersionColProvider;
#endif /* __cplusplus */

#endif 	/* __VersionColProvider_FWD_DEFINED__ */


#ifndef __ThemeUIPages_FWD_DEFINED__
#define __ThemeUIPages_FWD_DEFINED__

#ifdef __cplusplus
typedef class ThemeUIPages ThemeUIPages;
#else
typedef struct ThemeUIPages ThemeUIPages;
#endif /* __cplusplus */

#endif 	/* __ThemeUIPages_FWD_DEFINED__ */


#ifndef __ScreenSaverPage_FWD_DEFINED__
#define __ScreenSaverPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScreenSaverPage ScreenSaverPage;
#else
typedef struct ScreenSaverPage ScreenSaverPage;
#endif /* __cplusplus */

#endif 	/* __ScreenSaverPage_FWD_DEFINED__ */


#ifndef __ScreenResFixer_FWD_DEFINED__
#define __ScreenResFixer_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScreenResFixer ScreenResFixer;
#else
typedef struct ScreenResFixer ScreenResFixer;
#endif /* __cplusplus */

#endif 	/* __ScreenResFixer_FWD_DEFINED__ */


#ifndef __SettingsPage_FWD_DEFINED__
#define __SettingsPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class SettingsPage SettingsPage;
#else
typedef struct SettingsPage SettingsPage;
#endif /* __cplusplus */

#endif 	/* __SettingsPage_FWD_DEFINED__ */


#ifndef __DisplaySettings_FWD_DEFINED__
#define __DisplaySettings_FWD_DEFINED__

#ifdef __cplusplus
typedef class DisplaySettings DisplaySettings;
#else
typedef struct DisplaySettings DisplaySettings;
#endif /* __cplusplus */

#endif 	/* __DisplaySettings_FWD_DEFINED__ */


#ifndef __VideoThumbnail_FWD_DEFINED__
#define __VideoThumbnail_FWD_DEFINED__

#ifdef __cplusplus
typedef class VideoThumbnail VideoThumbnail;
#else
typedef struct VideoThumbnail VideoThumbnail;
#endif /* __cplusplus */

#endif 	/* __VideoThumbnail_FWD_DEFINED__ */


#ifndef __StartMenuPin_FWD_DEFINED__
#define __StartMenuPin_FWD_DEFINED__

#ifdef __cplusplus
typedef class StartMenuPin StartMenuPin;
#else
typedef struct StartMenuPin StartMenuPin;
#endif /* __cplusplus */

#endif 	/* __StartMenuPin_FWD_DEFINED__ */


#ifndef __ClientExtractIcon_FWD_DEFINED__
#define __ClientExtractIcon_FWD_DEFINED__

#ifdef __cplusplus
typedef class ClientExtractIcon ClientExtractIcon;
#else
typedef struct ClientExtractIcon ClientExtractIcon;
#endif /* __cplusplus */

#endif 	/* __ClientExtractIcon_FWD_DEFINED__ */


#ifndef __MediaDeviceFolder_FWD_DEFINED__
#define __MediaDeviceFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class MediaDeviceFolder MediaDeviceFolder;
#else
typedef struct MediaDeviceFolder MediaDeviceFolder;
#endif /* __cplusplus */

#endif 	/* __MediaDeviceFolder_FWD_DEFINED__ */


#ifndef __CDBurnFolder_FWD_DEFINED__
#define __CDBurnFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class CDBurnFolder CDBurnFolder;
#else
typedef struct CDBurnFolder CDBurnFolder;
#endif /* __cplusplus */

#endif 	/* __CDBurnFolder_FWD_DEFINED__ */


#ifndef __BurnAudioCDExtension_FWD_DEFINED__
#define __BurnAudioCDExtension_FWD_DEFINED__

#ifdef __cplusplus
typedef class BurnAudioCDExtension BurnAudioCDExtension;
#else
typedef struct BurnAudioCDExtension BurnAudioCDExtension;
#endif /* __cplusplus */

#endif 	/* __BurnAudioCDExtension_FWD_DEFINED__ */


#ifndef __Accessible_FWD_DEFINED__
#define __Accessible_FWD_DEFINED__

#ifdef __cplusplus
typedef class Accessible Accessible;
#else
typedef struct Accessible Accessible;
#endif /* __cplusplus */

#endif 	/* __Accessible_FWD_DEFINED__ */


#ifndef __TrackPopupBar_FWD_DEFINED__
#define __TrackPopupBar_FWD_DEFINED__

#ifdef __cplusplus
typedef class TrackPopupBar TrackPopupBar;
#else
typedef struct TrackPopupBar TrackPopupBar;
#endif /* __cplusplus */

#endif 	/* __TrackPopupBar_FWD_DEFINED__ */


#ifndef __SharedDocuments_FWD_DEFINED__
#define __SharedDocuments_FWD_DEFINED__

#ifdef __cplusplus
typedef class SharedDocuments SharedDocuments;
#else
typedef struct SharedDocuments SharedDocuments;
#endif /* __cplusplus */

#endif 	/* __SharedDocuments_FWD_DEFINED__ */


#ifndef __PostBootReminder_FWD_DEFINED__
#define __PostBootReminder_FWD_DEFINED__

#ifdef __cplusplus
typedef class PostBootReminder PostBootReminder;
#else
typedef struct PostBootReminder PostBootReminder;
#endif /* __cplusplus */

#endif 	/* __PostBootReminder_FWD_DEFINED__ */


#ifndef __AudioMediaProperties_FWD_DEFINED__
#define __AudioMediaProperties_FWD_DEFINED__

#ifdef __cplusplus
typedef class AudioMediaProperties AudioMediaProperties;
#else
typedef struct AudioMediaProperties AudioMediaProperties;
#endif /* __cplusplus */

#endif 	/* __AudioMediaProperties_FWD_DEFINED__ */


#ifndef __VideoMediaProperties_FWD_DEFINED__
#define __VideoMediaProperties_FWD_DEFINED__

#ifdef __cplusplus
typedef class VideoMediaProperties VideoMediaProperties;
#else
typedef struct VideoMediaProperties VideoMediaProperties;
#endif /* __cplusplus */

#endif 	/* __VideoMediaProperties_FWD_DEFINED__ */


#ifndef __AVWavProperties_FWD_DEFINED__
#define __AVWavProperties_FWD_DEFINED__

#ifdef __cplusplus
typedef class AVWavProperties AVWavProperties;
#else
typedef struct AVWavProperties AVWavProperties;
#endif /* __cplusplus */

#endif 	/* __AVWavProperties_FWD_DEFINED__ */


#ifndef __AVAviProperties_FWD_DEFINED__
#define __AVAviProperties_FWD_DEFINED__

#ifdef __cplusplus
typedef class AVAviProperties AVAviProperties;
#else
typedef struct AVAviProperties AVAviProperties;
#endif /* __cplusplus */

#endif 	/* __AVAviProperties_FWD_DEFINED__ */


#ifndef __AVMidiProperties_FWD_DEFINED__
#define __AVMidiProperties_FWD_DEFINED__

#ifdef __cplusplus
typedef class AVMidiProperties AVMidiProperties;
#else
typedef struct AVMidiProperties AVMidiProperties;
#endif /* __cplusplus */

#endif 	/* __AVMidiProperties_FWD_DEFINED__ */


#ifndef __TrayNotify_FWD_DEFINED__
#define __TrayNotify_FWD_DEFINED__

#ifdef __cplusplus
typedef class TrayNotify TrayNotify;
#else
typedef struct TrayNotify TrayNotify;
#endif /* __cplusplus */

#endif 	/* __TrayNotify_FWD_DEFINED__ */


#ifndef __CompositeFolder_FWD_DEFINED__
#define __CompositeFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class CompositeFolder CompositeFolder;
#else
typedef struct CompositeFolder CompositeFolder;
#endif /* __cplusplus */

#endif 	/* __CompositeFolder_FWD_DEFINED__ */


#ifndef __DynamicStorage_FWD_DEFINED__
#define __DynamicStorage_FWD_DEFINED__

#ifdef __cplusplus
typedef class DynamicStorage DynamicStorage;
#else
typedef struct DynamicStorage DynamicStorage;
#endif /* __cplusplus */

#endif 	/* __DynamicStorage_FWD_DEFINED__ */


#ifndef __Magic_FWD_DEFINED__
#define __Magic_FWD_DEFINED__

#ifdef __cplusplus
typedef class Magic Magic;
#else
typedef struct Magic Magic;
#endif /* __cplusplus */

#endif 	/* __Magic_FWD_DEFINED__ */


#ifndef __HomeNetworkWizard_FWD_DEFINED__
#define __HomeNetworkWizard_FWD_DEFINED__

#ifdef __cplusplus
typedef class HomeNetworkWizard HomeNetworkWizard;
#else
typedef struct HomeNetworkWizard HomeNetworkWizard;
#endif /* __cplusplus */

#endif 	/* __HomeNetworkWizard_FWD_DEFINED__ */


#ifndef __StartMenuFolder_FWD_DEFINED__
#define __StartMenuFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class StartMenuFolder StartMenuFolder;
#else
typedef struct StartMenuFolder StartMenuFolder;
#endif /* __cplusplus */

#endif 	/* __StartMenuFolder_FWD_DEFINED__ */


#ifndef __ProgramsFolder_FWD_DEFINED__
#define __ProgramsFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class ProgramsFolder ProgramsFolder;
#else
typedef struct ProgramsFolder ProgramsFolder;
#endif /* __cplusplus */

#endif 	/* __ProgramsFolder_FWD_DEFINED__ */


#ifndef __MoreDocumentsFolder_FWD_DEFINED__
#define __MoreDocumentsFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class MoreDocumentsFolder MoreDocumentsFolder;
#else
typedef struct MoreDocumentsFolder MoreDocumentsFolder;
#endif /* __cplusplus */

#endif 	/* __MoreDocumentsFolder_FWD_DEFINED__ */


#ifndef __LocalCopyHelper_FWD_DEFINED__
#define __LocalCopyHelper_FWD_DEFINED__

#ifdef __cplusplus
typedef class LocalCopyHelper LocalCopyHelper;
#else
typedef struct LocalCopyHelper LocalCopyHelper;
#endif /* __cplusplus */

#endif 	/* __LocalCopyHelper_FWD_DEFINED__ */


#ifndef __ShellItem_FWD_DEFINED__
#define __ShellItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellItem ShellItem;
#else
typedef struct ShellItem ShellItem;
#endif /* __cplusplus */

#endif 	/* __ShellItem_FWD_DEFINED__ */


#ifndef __WirelessDevices_FWD_DEFINED__
#define __WirelessDevices_FWD_DEFINED__

#ifdef __cplusplus
typedef class WirelessDevices WirelessDevices;
#else
typedef struct WirelessDevices WirelessDevices;
#endif /* __cplusplus */

#endif 	/* __WirelessDevices_FWD_DEFINED__ */


#ifndef __FolderCustomize_FWD_DEFINED__
#define __FolderCustomize_FWD_DEFINED__

#ifdef __cplusplus
typedef class FolderCustomize FolderCustomize;
#else
typedef struct FolderCustomize FolderCustomize;
#endif /* __cplusplus */

#endif 	/* __FolderCustomize_FWD_DEFINED__ */


#ifndef __WorkgroupNetCrawler_FWD_DEFINED__
#define __WorkgroupNetCrawler_FWD_DEFINED__

#ifdef __cplusplus
typedef class WorkgroupNetCrawler WorkgroupNetCrawler;
#else
typedef struct WorkgroupNetCrawler WorkgroupNetCrawler;
#endif /* __cplusplus */

#endif 	/* __WorkgroupNetCrawler_FWD_DEFINED__ */


#ifndef __WebDocsNetCrawler_FWD_DEFINED__
#define __WebDocsNetCrawler_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebDocsNetCrawler WebDocsNetCrawler;
#else
typedef struct WebDocsNetCrawler WebDocsNetCrawler;
#endif /* __cplusplus */

#endif 	/* __WebDocsNetCrawler_FWD_DEFINED__ */


#ifndef __PublishedShareNetCrawler_FWD_DEFINED__
#define __PublishedShareNetCrawler_FWD_DEFINED__

#ifdef __cplusplus
typedef class PublishedShareNetCrawler PublishedShareNetCrawler;
#else
typedef struct PublishedShareNetCrawler PublishedShareNetCrawler;
#endif /* __cplusplus */

#endif 	/* __PublishedShareNetCrawler_FWD_DEFINED__ */


#ifndef __ImagePropertyHandler_FWD_DEFINED__
#define __ImagePropertyHandler_FWD_DEFINED__

#ifdef __cplusplus
typedef class ImagePropertyHandler ImagePropertyHandler;
#else
typedef struct ImagePropertyHandler ImagePropertyHandler;
#endif /* __cplusplus */

#endif 	/* __ImagePropertyHandler_FWD_DEFINED__ */


#ifndef __WebViewRegTreeItem_FWD_DEFINED__
#define __WebViewRegTreeItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class WebViewRegTreeItem WebViewRegTreeItem;
#else
typedef struct WebViewRegTreeItem WebViewRegTreeItem;
#endif /* __cplusplus */

#endif 	/* __WebViewRegTreeItem_FWD_DEFINED__ */


#ifndef __ThemesRegTreeItem_FWD_DEFINED__
#define __ThemesRegTreeItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class ThemesRegTreeItem ThemesRegTreeItem;
#else
typedef struct ThemesRegTreeItem ThemesRegTreeItem;
#endif /* __cplusplus */

#endif 	/* __ThemesRegTreeItem_FWD_DEFINED__ */


#ifndef __CShellTreeWalker_FWD_DEFINED__
#define __CShellTreeWalker_FWD_DEFINED__

#ifdef __cplusplus
typedef class CShellTreeWalker CShellTreeWalker;
#else
typedef struct CShellTreeWalker CShellTreeWalker;
#endif /* __cplusplus */

#endif 	/* __CShellTreeWalker_FWD_DEFINED__ */


#ifndef __StorageProcessor_FWD_DEFINED__
#define __StorageProcessor_FWD_DEFINED__

#ifdef __cplusplus
typedef class StorageProcessor StorageProcessor;
#else
typedef struct StorageProcessor StorageProcessor;
#endif /* __cplusplus */

#endif 	/* __StorageProcessor_FWD_DEFINED__ */


#ifndef __TransferConfirmationUI_FWD_DEFINED__
#define __TransferConfirmationUI_FWD_DEFINED__

#ifdef __cplusplus
typedef class TransferConfirmationUI TransferConfirmationUI;
#else
typedef struct TransferConfirmationUI TransferConfirmationUI;
#endif /* __cplusplus */

#endif 	/* __TransferConfirmationUI_FWD_DEFINED__ */


#ifndef __ShellAutoplay_FWD_DEFINED__
#define __ShellAutoplay_FWD_DEFINED__

#ifdef __cplusplus
typedef class ShellAutoplay ShellAutoplay;
#else
typedef struct ShellAutoplay ShellAutoplay;
#endif /* __cplusplus */

#endif 	/* __ShellAutoplay_FWD_DEFINED__ */


#ifndef __PrintPhotosDropTarget_FWD_DEFINED__
#define __PrintPhotosDropTarget_FWD_DEFINED__

#ifdef __cplusplus
typedef class PrintPhotosDropTarget PrintPhotosDropTarget;
#else
typedef struct PrintPhotosDropTarget PrintPhotosDropTarget;
#endif /* __cplusplus */

#endif 	/* __PrintPhotosDropTarget_FWD_DEFINED__ */


#ifndef __OrganizeFolder_FWD_DEFINED__
#define __OrganizeFolder_FWD_DEFINED__

#ifdef __cplusplus
typedef class OrganizeFolder OrganizeFolder;
#else
typedef struct OrganizeFolder OrganizeFolder;
#endif /* __cplusplus */

#endif 	/* __OrganizeFolder_FWD_DEFINED__ */


#ifndef __FadeTask_FWD_DEFINED__
#define __FadeTask_FWD_DEFINED__

#ifdef __cplusplus
typedef class FadeTask FadeTask;
#else
typedef struct FadeTask FadeTask;
#endif /* __cplusplus */

#endif 	/* __FadeTask_FWD_DEFINED__ */


#ifndef __AssocShellElement_FWD_DEFINED__
#define __AssocShellElement_FWD_DEFINED__

#ifdef __cplusplus
typedef class AssocShellElement AssocShellElement;
#else
typedef struct AssocShellElement AssocShellElement;
#endif /* __cplusplus */

#endif 	/* __AssocShellElement_FWD_DEFINED__ */


#ifndef __AssocProgidElement_FWD_DEFINED__
#define __AssocProgidElement_FWD_DEFINED__

#ifdef __cplusplus
typedef class AssocProgidElement AssocProgidElement;
#else
typedef struct AssocProgidElement AssocProgidElement;
#endif /* __cplusplus */

#endif 	/* __AssocProgidElement_FWD_DEFINED__ */


#ifndef __AssocClsidElement_FWD_DEFINED__
#define __AssocClsidElement_FWD_DEFINED__

#ifdef __cplusplus
typedef class AssocClsidElement AssocClsidElement;
#else
typedef struct AssocClsidElement AssocClsidElement;
#endif /* __cplusplus */

#endif 	/* __AssocClsidElement_FWD_DEFINED__ */


#ifndef __AssocSystemElement_FWD_DEFINED__
#define __AssocSystemElement_FWD_DEFINED__

#ifdef __cplusplus
typedef class AssocSystemElement AssocSystemElement;
#else
typedef struct AssocSystemElement AssocSystemElement;
#endif /* __cplusplus */

#endif 	/* __AssocSystemElement_FWD_DEFINED__ */


#ifndef __AssocPerceivedElement_FWD_DEFINED__
#define __AssocPerceivedElement_FWD_DEFINED__

#ifdef __cplusplus
typedef class AssocPerceivedElement AssocPerceivedElement;
#else
typedef struct AssocPerceivedElement AssocPerceivedElement;
#endif /* __cplusplus */

#endif 	/* __AssocPerceivedElement_FWD_DEFINED__ */


#ifndef __AssocApplicationElement_FWD_DEFINED__
#define __AssocApplicationElement_FWD_DEFINED__

#ifdef __cplusplus
typedef class AssocApplicationElement AssocApplicationElement;
#else
typedef struct AssocApplicationElement AssocApplicationElement;
#endif /* __cplusplus */

#endif 	/* __AssocApplicationElement_FWD_DEFINED__ */


#ifndef __AssocFolderElement_FWD_DEFINED__
#define __AssocFolderElement_FWD_DEFINED__

#ifdef __cplusplus
typedef class AssocFolderElement AssocFolderElement;
#else
typedef struct AssocFolderElement AssocFolderElement;
#endif /* __cplusplus */

#endif 	/* __AssocFolderElement_FWD_DEFINED__ */


#ifndef __AssocStarElement_FWD_DEFINED__
#define __AssocStarElement_FWD_DEFINED__

#ifdef __cplusplus
typedef class AssocStarElement AssocStarElement;
#else
typedef struct AssocStarElement AssocStarElement;
#endif /* __cplusplus */

#endif 	/* __AssocStarElement_FWD_DEFINED__ */


#ifndef __AssocClientElement_FWD_DEFINED__
#define __AssocClientElement_FWD_DEFINED__

#ifdef __cplusplus
typedef class AssocClientElement AssocClientElement;
#else
typedef struct AssocClientElement AssocClientElement;
#endif /* __cplusplus */

#endif 	/* __AssocClientElement_FWD_DEFINED__ */


#ifndef __AutoPlayVerb_FWD_DEFINED__
#define __AutoPlayVerb_FWD_DEFINED__

#ifdef __cplusplus
typedef class AutoPlayVerb AutoPlayVerb;
#else
typedef struct AutoPlayVerb AutoPlayVerb;
#endif /* __cplusplus */

#endif 	/* __AutoPlayVerb_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "shtypes.h"
#include "shobjidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_shpriv_0000 */
/* [local] */ 


#include <pshpack8.h>
#include <poppack.h>


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0000_v0_0_s_ifspec;

#ifndef __ICustomIconManager_INTERFACE_DEFINED__
#define __ICustomIconManager_INTERFACE_DEFINED__

/* interface ICustomIconManager */
/* [object][uuid][helpstring] */ 


EXTERN_C const IID IID_ICustomIconManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7E23D323-36D6-4eb2-A654-387832868EA3")
    ICustomIconManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIcon( 
            /* [string][in] */ LPCWSTR pszIconPath,
            /* [in] */ int iIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIcon( 
            /* [size_is][out] */ LPWSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ int *piIconIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIconHandle( 
            /* [out] */ HICON *phIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultIcon( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICustomIconManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICustomIconManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICustomIconManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICustomIconManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetIcon )( 
            ICustomIconManager * This,
            /* [string][in] */ LPCWSTR pszIconPath,
            /* [in] */ int iIcon);
        
        HRESULT ( STDMETHODCALLTYPE *GetIcon )( 
            ICustomIconManager * This,
            /* [size_is][out] */ LPWSTR pszIconPath,
            /* [in] */ int cch,
            /* [out] */ int *piIconIndex);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIconHandle )( 
            ICustomIconManager * This,
            /* [out] */ HICON *phIcon);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultIcon )( 
            ICustomIconManager * This);
        
        END_INTERFACE
    } ICustomIconManagerVtbl;

    interface ICustomIconManager
    {
        CONST_VTBL struct ICustomIconManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICustomIconManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICustomIconManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICustomIconManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICustomIconManager_SetIcon(This,pszIconPath,iIcon)	\
    (This)->lpVtbl -> SetIcon(This,pszIconPath,iIcon)

#define ICustomIconManager_GetIcon(This,pszIconPath,cch,piIconIndex)	\
    (This)->lpVtbl -> GetIcon(This,pszIconPath,cch,piIconIndex)

#define ICustomIconManager_GetDefaultIconHandle(This,phIcon)	\
    (This)->lpVtbl -> GetDefaultIconHandle(This,phIcon)

#define ICustomIconManager_SetDefaultIcon(This)	\
    (This)->lpVtbl -> SetDefaultIcon(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICustomIconManager_SetIcon_Proxy( 
    ICustomIconManager * This,
    /* [string][in] */ LPCWSTR pszIconPath,
    /* [in] */ int iIcon);


void __RPC_STUB ICustomIconManager_SetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICustomIconManager_GetIcon_Proxy( 
    ICustomIconManager * This,
    /* [size_is][out] */ LPWSTR pszIconPath,
    /* [in] */ int cch,
    /* [out] */ int *piIconIndex);


void __RPC_STUB ICustomIconManager_GetIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICustomIconManager_GetDefaultIconHandle_Proxy( 
    ICustomIconManager * This,
    /* [out] */ HICON *phIcon);


void __RPC_STUB ICustomIconManager_GetDefaultIconHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICustomIconManager_SetDefaultIcon_Proxy( 
    ICustomIconManager * This);


void __RPC_STUB ICustomIconManager_SetDefaultIcon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICustomIconManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0262 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tagBNSTATE
    {	BNS_NORMAL	= 0,
	BNS_BEGIN_NAVIGATE	= 1,
	BNS_NAVIGATE	= 2
    } 	BNSTATE;

#ifdef MIDL_PASS
typedef DWORD RGBQUAD;

#endif


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0262_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0262_v0_0_s_ifspec;

#ifndef __IImageListPersistStream_INTERFACE_DEFINED__
#define __IImageListPersistStream_INTERFACE_DEFINED__

/* interface IImageListPersistStream */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IImageListPersistStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4D4BE85C-9BF6-4218-999A-8EA489F08EF7")
    IImageListPersistStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadEx( 
            DWORD dwFlags,
            IStream *pstm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveEx( 
            DWORD dwFlags,
            IStream *pstm) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageListPersistStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImageListPersistStream * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImageListPersistStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImageListPersistStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadEx )( 
            IImageListPersistStream * This,
            DWORD dwFlags,
            IStream *pstm);
        
        HRESULT ( STDMETHODCALLTYPE *SaveEx )( 
            IImageListPersistStream * This,
            DWORD dwFlags,
            IStream *pstm);
        
        END_INTERFACE
    } IImageListPersistStreamVtbl;

    interface IImageListPersistStream
    {
        CONST_VTBL struct IImageListPersistStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageListPersistStream_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageListPersistStream_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageListPersistStream_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageListPersistStream_LoadEx(This,dwFlags,pstm)	\
    (This)->lpVtbl -> LoadEx(This,dwFlags,pstm)

#define IImageListPersistStream_SaveEx(This,dwFlags,pstm)	\
    (This)->lpVtbl -> SaveEx(This,dwFlags,pstm)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImageListPersistStream_LoadEx_Proxy( 
    IImageListPersistStream * This,
    DWORD dwFlags,
    IStream *pstm);


void __RPC_STUB IImageListPersistStream_LoadEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageListPersistStream_SaveEx_Proxy( 
    IImageListPersistStream * This,
    DWORD dwFlags,
    IStream *pstm);


void __RPC_STUB IImageListPersistStream_SaveEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageListPersistStream_INTERFACE_DEFINED__ */


#ifndef __IImageListPriv_INTERFACE_DEFINED__
#define __IImageListPriv_INTERFACE_DEFINED__

/* interface IImageListPriv */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IImageListPriv;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E94CC23B-0916-4ba6-93F4-AA52B5355EE8")
    IImageListPriv : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            UINT flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            UINT *pflags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetColorTable( 
            int start,
            int len,
            RGBQUAD *prgb,
            int *pi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrivateGoo( 
            HBITMAP *hbmp,
            HDC *hdc,
            HBITMAP *hbmpMask,
            HDC *hdcMask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMirror( 
            REFIID riid,
            PVOID *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyDitherImage( 
            WORD iDst,
            int xDst,
            int yDst,
            IUnknown *punk,
            int iSrc,
            UINT fStyle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IImageListPrivVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IImageListPriv * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IImageListPriv * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IImageListPriv * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetFlags )( 
            IImageListPriv * This,
            UINT flags);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IImageListPriv * This,
            UINT *pflags);
        
        HRESULT ( STDMETHODCALLTYPE *SetColorTable )( 
            IImageListPriv * This,
            int start,
            int len,
            RGBQUAD *prgb,
            int *pi);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrivateGoo )( 
            IImageListPriv * This,
            HBITMAP *hbmp,
            HDC *hdc,
            HBITMAP *hbmpMask,
            HDC *hdcMask);
        
        HRESULT ( STDMETHODCALLTYPE *GetMirror )( 
            IImageListPriv * This,
            REFIID riid,
            PVOID *ppv);
        
        HRESULT ( STDMETHODCALLTYPE *CopyDitherImage )( 
            IImageListPriv * This,
            WORD iDst,
            int xDst,
            int yDst,
            IUnknown *punk,
            int iSrc,
            UINT fStyle);
        
        END_INTERFACE
    } IImageListPrivVtbl;

    interface IImageListPriv
    {
        CONST_VTBL struct IImageListPrivVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IImageListPriv_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IImageListPriv_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IImageListPriv_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IImageListPriv_SetFlags(This,flags)	\
    (This)->lpVtbl -> SetFlags(This,flags)

#define IImageListPriv_GetFlags(This,pflags)	\
    (This)->lpVtbl -> GetFlags(This,pflags)

#define IImageListPriv_SetColorTable(This,start,len,prgb,pi)	\
    (This)->lpVtbl -> SetColorTable(This,start,len,prgb,pi)

#define IImageListPriv_GetPrivateGoo(This,hbmp,hdc,hbmpMask,hdcMask)	\
    (This)->lpVtbl -> GetPrivateGoo(This,hbmp,hdc,hbmpMask,hdcMask)

#define IImageListPriv_GetMirror(This,riid,ppv)	\
    (This)->lpVtbl -> GetMirror(This,riid,ppv)

#define IImageListPriv_CopyDitherImage(This,iDst,xDst,yDst,punk,iSrc,fStyle)	\
    (This)->lpVtbl -> CopyDitherImage(This,iDst,xDst,yDst,punk,iSrc,fStyle)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IImageListPriv_SetFlags_Proxy( 
    IImageListPriv * This,
    UINT flags);


void __RPC_STUB IImageListPriv_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageListPriv_GetFlags_Proxy( 
    IImageListPriv * This,
    UINT *pflags);


void __RPC_STUB IImageListPriv_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageListPriv_SetColorTable_Proxy( 
    IImageListPriv * This,
    int start,
    int len,
    RGBQUAD *prgb,
    int *pi);


void __RPC_STUB IImageListPriv_SetColorTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageListPriv_GetPrivateGoo_Proxy( 
    IImageListPriv * This,
    HBITMAP *hbmp,
    HDC *hdc,
    HBITMAP *hbmpMask,
    HDC *hdcMask);


void __RPC_STUB IImageListPriv_GetPrivateGoo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageListPriv_GetMirror_Proxy( 
    IImageListPriv * This,
    REFIID riid,
    PVOID *ppv);


void __RPC_STUB IImageListPriv_GetMirror_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IImageListPriv_CopyDitherImage_Proxy( 
    IImageListPriv * This,
    WORD iDst,
    int xDst,
    int yDst,
    IUnknown *punk,
    int iSrc,
    UINT fStyle);


void __RPC_STUB IImageListPriv_CopyDitherImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IImageListPriv_INTERFACE_DEFINED__ */


#ifndef __IMarkupCallback_INTERFACE_DEFINED__
#define __IMarkupCallback_INTERFACE_DEFINED__

/* interface IMarkupCallback */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IMarkupCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("01e13875-2e58-4671-be46-59945432be6e")
    IMarkupCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            UINT uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            int nCode,
            int iLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InvalidateRect( 
            RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnCustomDraw( 
            DWORD dwDrawStage,
            HDC hdc,
            const RECT *prc,
            DWORD dwItemSpec,
            UINT uItemState,
            LRESULT *pdwResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMarkupCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMarkupCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMarkupCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMarkupCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IMarkupCallback * This,
            UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IMarkupCallback * This,
            int nCode,
            int iLink);
        
        HRESULT ( STDMETHODCALLTYPE *InvalidateRect )( 
            IMarkupCallback * This,
            RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *OnCustomDraw )( 
            IMarkupCallback * This,
            DWORD dwDrawStage,
            HDC hdc,
            const RECT *prc,
            DWORD dwItemSpec,
            UINT uItemState,
            LRESULT *pdwResult);
        
        END_INTERFACE
    } IMarkupCallbackVtbl;

    interface IMarkupCallback
    {
        CONST_VTBL struct IMarkupCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMarkupCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMarkupCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMarkupCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMarkupCallback_GetState(This,uState)	\
    (This)->lpVtbl -> GetState(This,uState)

#define IMarkupCallback_Notify(This,nCode,iLink)	\
    (This)->lpVtbl -> Notify(This,nCode,iLink)

#define IMarkupCallback_InvalidateRect(This,prc)	\
    (This)->lpVtbl -> InvalidateRect(This,prc)

#define IMarkupCallback_OnCustomDraw(This,dwDrawStage,hdc,prc,dwItemSpec,uItemState,pdwResult)	\
    (This)->lpVtbl -> OnCustomDraw(This,dwDrawStage,hdc,prc,dwItemSpec,uItemState,pdwResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMarkupCallback_GetState_Proxy( 
    IMarkupCallback * This,
    UINT uState);


void __RPC_STUB IMarkupCallback_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupCallback_Notify_Proxy( 
    IMarkupCallback * This,
    int nCode,
    int iLink);


void __RPC_STUB IMarkupCallback_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupCallback_InvalidateRect_Proxy( 
    IMarkupCallback * This,
    RECT *prc);


void __RPC_STUB IMarkupCallback_InvalidateRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMarkupCallback_OnCustomDraw_Proxy( 
    IMarkupCallback * This,
    DWORD dwDrawStage,
    HDC hdc,
    const RECT *prc,
    DWORD dwItemSpec,
    UINT uItemState,
    LRESULT *pdwResult);


void __RPC_STUB IMarkupCallback_OnCustomDraw_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMarkupCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0265 */
/* [local] */ 

#define MARKUPSIZE_CALCWIDTH         0   // calculates width without restriction
#define MARKUPSIZE_CALCHEIGHT        1   // prc->right contains max width
#define MARKUPLINKTEXT_URL           0   // get the URL
#define MARKUPLINKTEXT_ID            1   // get the id text associated with the url
#define MARKUPLINKTEXT_TEXT          2   // get the plain text associated with the url
#define MARKUPSTATE_FOCUSED          0x00000001
#define MARKUPSTATE_ENABLED          0x00000002
#define MARKUPSTATE_VISITED          0x00000004
#define MARKUPSTATE_ALLOWMARKUP      0x80000000
#define MARKUPMESSAGE_KEYEXECUTE     0
#define MARKUPMESSAGE_CLICKEXECUTE   1
#define MARKUPMESSAGE_WANTFOCUS      2
typedef HANDLE HTHEME;



extern RPC_IF_HANDLE __MIDL_itf_shpriv_0265_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0265_v0_0_s_ifspec;

#ifndef __IControlMarkup_INTERFACE_DEFINED__
#define __IControlMarkup_INTERFACE_DEFINED__

/* interface IControlMarkup */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IControlMarkup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50cf8c58-029d-41bf-b8dd-4ce4f95d9257")
    IControlMarkup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCallback( 
            IUnknown *punk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallback( 
            REFIID riid,
            /* [iid_is][out] */ void **ppvUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFonts( 
            HFONT hFont,
            HFONT hFontUnderline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFonts( 
            HFONT *phFont,
            HFONT *phFontUnderline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetText( 
            LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetText( 
            BOOL bRaw,
            LPWSTR pwszText,
            DWORD *pdwCch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinkText( 
            int iLink,
            UINT uMarkupLinkText,
            LPCWSTR pwszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLinkText( 
            int iLink,
            UINT uMarkupLinkText,
            LPWSTR pwszText,
            DWORD *pdwCch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRenderFlags( 
            UINT uDT) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRenderFlags( 
            UINT *puDT,
            HTHEME *phTheme,
            int *piPartId,
            int *piStateIdNormal,
            int *piStateIdLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThemeRenderFlags( 
            UINT uDT,
            HTHEME hTheme,
            int iPartId,
            int iStateIdNormal,
            int iStateIdLink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetState( 
            int iLink,
            UINT uStateMask,
            UINT *puState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetState( 
            int iLink,
            UINT uStateMask,
            UINT uState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DrawText( 
            HDC hdcClient,
            LPCRECT prcClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLinkCursor( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CalcIdealSize( 
            HDC hdc,
            UINT uMarkUpCalc,
            RECT *prc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KillFocus( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsTabbable( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnButtonDown( 
            POINT pt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnButtonUp( 
            POINT pt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnKeyDown( 
            UINT uVitKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HitTest( 
            POINT pt,
            UINT *pidLink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IControlMarkupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IControlMarkup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IControlMarkup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCallback )( 
            IControlMarkup * This,
            IUnknown *punk);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallback )( 
            IControlMarkup * This,
            REFIID riid,
            /* [iid_is][out] */ void **ppvUnk);
        
        HRESULT ( STDMETHODCALLTYPE *SetFonts )( 
            IControlMarkup * This,
            HFONT hFont,
            HFONT hFontUnderline);
        
        HRESULT ( STDMETHODCALLTYPE *GetFonts )( 
            IControlMarkup * This,
            HFONT *phFont,
            HFONT *phFontUnderline);
        
        HRESULT ( STDMETHODCALLTYPE *SetText )( 
            IControlMarkup * This,
            LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *GetText )( 
            IControlMarkup * This,
            BOOL bRaw,
            LPWSTR pwszText,
            DWORD *pdwCch);
        
        HRESULT ( STDMETHODCALLTYPE *SetLinkText )( 
            IControlMarkup * This,
            int iLink,
            UINT uMarkupLinkText,
            LPCWSTR pwszText);
        
        HRESULT ( STDMETHODCALLTYPE *GetLinkText )( 
            IControlMarkup * This,
            int iLink,
            UINT uMarkupLinkText,
            LPWSTR pwszText,
            DWORD *pdwCch);
        
        HRESULT ( STDMETHODCALLTYPE *SetRenderFlags )( 
            IControlMarkup * This,
            UINT uDT);
        
        HRESULT ( STDMETHODCALLTYPE *GetRenderFlags )( 
            IControlMarkup * This,
            UINT *puDT,
            HTHEME *phTheme,
            int *piPartId,
            int *piStateIdNormal,
            int *piStateIdLink);
        
        HRESULT ( STDMETHODCALLTYPE *SetThemeRenderFlags )( 
            IControlMarkup * This,
            UINT uDT,
            HTHEME hTheme,
            int iPartId,
            int iStateIdNormal,
            int iStateIdLink);
        
        HRESULT ( STDMETHODCALLTYPE *GetState )( 
            IControlMarkup * This,
            int iLink,
            UINT uStateMask,
            UINT *puState);
        
        HRESULT ( STDMETHODCALLTYPE *SetState )( 
            IControlMarkup * This,
            int iLink,
            UINT uStateMask,
            UINT uState);
        
        HRESULT ( STDMETHODCALLTYPE *DrawText )( 
            IControlMarkup * This,
            HDC hdcClient,
            LPCRECT prcClient);
        
        HRESULT ( STDMETHODCALLTYPE *SetLinkCursor )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *CalcIdealSize )( 
            IControlMarkup * This,
            HDC hdc,
            UINT uMarkUpCalc,
            RECT *prc);
        
        HRESULT ( STDMETHODCALLTYPE *SetFocus )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *KillFocus )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsTabbable )( 
            IControlMarkup * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnButtonDown )( 
            IControlMarkup * This,
            POINT pt);
        
        HRESULT ( STDMETHODCALLTYPE *OnButtonUp )( 
            IControlMarkup * This,
            POINT pt);
        
        HRESULT ( STDMETHODCALLTYPE *OnKeyDown )( 
            IControlMarkup * This,
            UINT uVitKey);
        
        HRESULT ( STDMETHODCALLTYPE *HitTest )( 
            IControlMarkup * This,
            POINT pt,
            UINT *pidLink);
        
        END_INTERFACE
    } IControlMarkupVtbl;

    interface IControlMarkup
    {
        CONST_VTBL struct IControlMarkupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IControlMarkup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IControlMarkup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IControlMarkup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IControlMarkup_SetCallback(This,punk)	\
    (This)->lpVtbl -> SetCallback(This,punk)

#define IControlMarkup_GetCallback(This,riid,ppvUnk)	\
    (This)->lpVtbl -> GetCallback(This,riid,ppvUnk)

#define IControlMarkup_SetFonts(This,hFont,hFontUnderline)	\
    (This)->lpVtbl -> SetFonts(This,hFont,hFontUnderline)

#define IControlMarkup_GetFonts(This,phFont,phFontUnderline)	\
    (This)->lpVtbl -> GetFonts(This,phFont,phFontUnderline)

#define IControlMarkup_SetText(This,pwszText)	\
    (This)->lpVtbl -> SetText(This,pwszText)

#define IControlMarkup_GetText(This,bRaw,pwszText,pdwCch)	\
    (This)->lpVtbl -> GetText(This,bRaw,pwszText,pdwCch)

#define IControlMarkup_SetLinkText(This,iLink,uMarkupLinkText,pwszText)	\
    (This)->lpVtbl -> SetLinkText(This,iLink,uMarkupLinkText,pwszText)

#define IControlMarkup_GetLinkText(This,iLink,uMarkupLinkText,pwszText,pdwCch)	\
    (This)->lpVtbl -> GetLinkText(This,iLink,uMarkupLinkText,pwszText,pdwCch)

#define IControlMarkup_SetRenderFlags(This,uDT)	\
    (This)->lpVtbl -> SetRenderFlags(This,uDT)

#define IControlMarkup_GetRenderFlags(This,puDT,phTheme,piPartId,piStateIdNormal,piStateIdLink)	\
    (This)->lpVtbl -> GetRenderFlags(This,puDT,phTheme,piPartId,piStateIdNormal,piStateIdLink)

#define IControlMarkup_SetThemeRenderFlags(This,uDT,hTheme,iPartId,iStateIdNormal,iStateIdLink)	\
    (This)->lpVtbl -> SetThemeRenderFlags(This,uDT,hTheme,iPartId,iStateIdNormal,iStateIdLink)

#define IControlMarkup_GetState(This,iLink,uStateMask,puState)	\
    (This)->lpVtbl -> GetState(This,iLink,uStateMask,puState)

#define IControlMarkup_SetState(This,iLink,uStateMask,uState)	\
    (This)->lpVtbl -> SetState(This,iLink,uStateMask,uState)

#define IControlMarkup_DrawText(This,hdcClient,prcClient)	\
    (This)->lpVtbl -> DrawText(This,hdcClient,prcClient)

#define IControlMarkup_SetLinkCursor(This)	\
    (This)->lpVtbl -> SetLinkCursor(This)

#define IControlMarkup_CalcIdealSize(This,hdc,uMarkUpCalc,prc)	\
    (This)->lpVtbl -> CalcIdealSize(This,hdc,uMarkUpCalc,prc)

#define IControlMarkup_SetFocus(This)	\
    (This)->lpVtbl -> SetFocus(This)

#define IControlMarkup_KillFocus(This)	\
    (This)->lpVtbl -> KillFocus(This)

#define IControlMarkup_IsTabbable(This)	\
    (This)->lpVtbl -> IsTabbable(This)

#define IControlMarkup_OnButtonDown(This,pt)	\
    (This)->lpVtbl -> OnButtonDown(This,pt)

#define IControlMarkup_OnButtonUp(This,pt)	\
    (This)->lpVtbl -> OnButtonUp(This,pt)

#define IControlMarkup_OnKeyDown(This,uVitKey)	\
    (This)->lpVtbl -> OnKeyDown(This,uVitKey)

#define IControlMarkup_HitTest(This,pt,pidLink)	\
    (This)->lpVtbl -> HitTest(This,pt,pidLink)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IControlMarkup_SetCallback_Proxy( 
    IControlMarkup * This,
    IUnknown *punk);


void __RPC_STUB IControlMarkup_SetCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_GetCallback_Proxy( 
    IControlMarkup * This,
    REFIID riid,
    /* [iid_is][out] */ void **ppvUnk);


void __RPC_STUB IControlMarkup_GetCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_SetFonts_Proxy( 
    IControlMarkup * This,
    HFONT hFont,
    HFONT hFontUnderline);


void __RPC_STUB IControlMarkup_SetFonts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_GetFonts_Proxy( 
    IControlMarkup * This,
    HFONT *phFont,
    HFONT *phFontUnderline);


void __RPC_STUB IControlMarkup_GetFonts_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_SetText_Proxy( 
    IControlMarkup * This,
    LPCWSTR pwszText);


void __RPC_STUB IControlMarkup_SetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_GetText_Proxy( 
    IControlMarkup * This,
    BOOL bRaw,
    LPWSTR pwszText,
    DWORD *pdwCch);


void __RPC_STUB IControlMarkup_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_SetLinkText_Proxy( 
    IControlMarkup * This,
    int iLink,
    UINT uMarkupLinkText,
    LPCWSTR pwszText);


void __RPC_STUB IControlMarkup_SetLinkText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_GetLinkText_Proxy( 
    IControlMarkup * This,
    int iLink,
    UINT uMarkupLinkText,
    LPWSTR pwszText,
    DWORD *pdwCch);


void __RPC_STUB IControlMarkup_GetLinkText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_SetRenderFlags_Proxy( 
    IControlMarkup * This,
    UINT uDT);


void __RPC_STUB IControlMarkup_SetRenderFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_GetRenderFlags_Proxy( 
    IControlMarkup * This,
    UINT *puDT,
    HTHEME *phTheme,
    int *piPartId,
    int *piStateIdNormal,
    int *piStateIdLink);


void __RPC_STUB IControlMarkup_GetRenderFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_SetThemeRenderFlags_Proxy( 
    IControlMarkup * This,
    UINT uDT,
    HTHEME hTheme,
    int iPartId,
    int iStateIdNormal,
    int iStateIdLink);


void __RPC_STUB IControlMarkup_SetThemeRenderFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_GetState_Proxy( 
    IControlMarkup * This,
    int iLink,
    UINT uStateMask,
    UINT *puState);


void __RPC_STUB IControlMarkup_GetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_SetState_Proxy( 
    IControlMarkup * This,
    int iLink,
    UINT uStateMask,
    UINT uState);


void __RPC_STUB IControlMarkup_SetState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_DrawText_Proxy( 
    IControlMarkup * This,
    HDC hdcClient,
    LPCRECT prcClient);


void __RPC_STUB IControlMarkup_DrawText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_SetLinkCursor_Proxy( 
    IControlMarkup * This);


void __RPC_STUB IControlMarkup_SetLinkCursor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_CalcIdealSize_Proxy( 
    IControlMarkup * This,
    HDC hdc,
    UINT uMarkUpCalc,
    RECT *prc);


void __RPC_STUB IControlMarkup_CalcIdealSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_SetFocus_Proxy( 
    IControlMarkup * This);


void __RPC_STUB IControlMarkup_SetFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_KillFocus_Proxy( 
    IControlMarkup * This);


void __RPC_STUB IControlMarkup_KillFocus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_IsTabbable_Proxy( 
    IControlMarkup * This);


void __RPC_STUB IControlMarkup_IsTabbable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_OnButtonDown_Proxy( 
    IControlMarkup * This,
    POINT pt);


void __RPC_STUB IControlMarkup_OnButtonDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_OnButtonUp_Proxy( 
    IControlMarkup * This,
    POINT pt);


void __RPC_STUB IControlMarkup_OnButtonUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_OnKeyDown_Proxy( 
    IControlMarkup * This,
    UINT uVitKey);


void __RPC_STUB IControlMarkup_OnKeyDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IControlMarkup_HitTest_Proxy( 
    IControlMarkup * This,
    POINT pt,
    UINT *pidLink);


void __RPC_STUB IControlMarkup_HitTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IControlMarkup_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0266 */
/* [local] */ 



#if _WIN32_IE >= 0x0600
// INTERFACE: IThemeUIPages
// DESCRIPTION:
// This interface is used by all the pages in the Display Control Panel.  They allow the
// base pages (Theme, Background, ScreenSaver, Appearance, and Settings) to specify that
// they want to add pages to the Advanced Display Properties dialog. (Theme Settings, 
// Appearance, Web, and Effects)
// DisplayAdvancedDialog() will open the adv dialog.  When this object opens the dialog,
// it will add the appropriate pages, check when anyone's state gets dirty,
// and then merge the state from the advanced pages back into the base pages.
// This object will see if the IAdvancedDialog pages get dirty, and if one is and the
// user clicked OK instead of CANCEL, then it will use IAdvancedDialog::OnClose()
// to let the IAdvancedDialog object merge it's state into IBasePropPage.
// This object is used to allow desk.cpl, shell32.dll, and ThemeUI.dll control the dialog.
// 
// This object may implement IEnumUnknown to allow callers to access the list of IBasePropPage
// objects.  IPersist::GetClassID() should be used to identify one IBasePropPage object
// from another.  This is also true for IAdvancedDialog objects.
// 
// AddPage: This is used by desk.cpl to ask ThemeUI for the pages it wants to add to the base dlg.
//          This allows the pages to be put in a specific order.
// AddAdvancedPage: This is used by shell32.dll's Background tab to let ThemeUI know
//          that it wants to add a page to the advanced dialog (the Web tab).
// DisplayAdvancedDialog: This is used by any of the base pages to open the advanced page.
// ApplyPressed: Each page in the base dialog needs to call this method when they receive
//               PSN_APPLY.  This will allow the IThemeUIPages to notify every object
//               that the state should be applied, even if their dlgproc was never activated.
// 
// Values for nPageID in IThemeUIPages::AddPage()
#define PAGE_DISPLAY_THEMES        0
#define PAGE_DISPLAY_APPEARANCE    1
#define PAGE_DISPLAY_SETTINGS      2
// 
// Values for dwFlags in IThemeUIPages::ApplyPressed()
#define TUIAP_NONE                 0x00000000
#define TUIAP_CLOSE_DIALOG         0x00000001
#define TUIAP_WAITFORAPPLY         0x00000002
// Values for dwEM in IThemeUIPages::SetExecMode()
#define EM_NORMAL            0x00000001
#define EM_SETUP             0x00000002
#define EM_DETECT            0x00000003
#define EM_INVALID_MODE      0x00000004


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0266_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0266_v0_0_s_ifspec;

#ifndef __IThemeUIPages_INTERFACE_DEFINED__
#define __IThemeUIPages_INTERFACE_DEFINED__

/* interface IThemeUIPages */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IThemeUIPages;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7bba4934-ac4b-471c-a3e7-252c5ff3e8dd")
    IThemeUIPages : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddPage( 
            /* [in] */ LPFNSVADDPROPSHEETPAGE pfnAddPage,
            /* [in] */ LPARAM lParam,
            /* [in] */ long nPageID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddBasePage( 
            /* [in] */ IBasePropPage *pBasePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyPressed( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBasePagesEnum( 
            /* [out] */ IEnumUnknown **ppEnumUnknown) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdatePreview( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddFakeSettingsPage( 
            /* [in] */ LPVOID pVoid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExecMode( 
            /* [in] */ DWORD dwEM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExecMode( 
            /* [out] */ DWORD *pdwEM) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadMonitorBitmap( 
            /* [in] */ BOOL fFillDesktop,
            /* [out] */ HBITMAP *phbmMon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisplaySaveSettings( 
            /* [in] */ PVOID pContext,
            /* [in] */ HWND hwnd,
            /* [out] */ int *piRet) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IThemeUIPagesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IThemeUIPages * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IThemeUIPages * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IThemeUIPages * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPage )( 
            IThemeUIPages * This,
            /* [in] */ LPFNSVADDPROPSHEETPAGE pfnAddPage,
            /* [in] */ LPARAM lParam,
            /* [in] */ long nPageID);
        
        HRESULT ( STDMETHODCALLTYPE *AddBasePage )( 
            IThemeUIPages * This,
            /* [in] */ IBasePropPage *pBasePage);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyPressed )( 
            IThemeUIPages * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetBasePagesEnum )( 
            IThemeUIPages * This,
            /* [out] */ IEnumUnknown **ppEnumUnknown);
        
        HRESULT ( STDMETHODCALLTYPE *UpdatePreview )( 
            IThemeUIPages * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *AddFakeSettingsPage )( 
            IThemeUIPages * This,
            /* [in] */ LPVOID pVoid);
        
        HRESULT ( STDMETHODCALLTYPE *SetExecMode )( 
            IThemeUIPages * This,
            /* [in] */ DWORD dwEM);
        
        HRESULT ( STDMETHODCALLTYPE *GetExecMode )( 
            IThemeUIPages * This,
            /* [out] */ DWORD *pdwEM);
        
        HRESULT ( STDMETHODCALLTYPE *LoadMonitorBitmap )( 
            IThemeUIPages * This,
            /* [in] */ BOOL fFillDesktop,
            /* [out] */ HBITMAP *phbmMon);
        
        HRESULT ( STDMETHODCALLTYPE *DisplaySaveSettings )( 
            IThemeUIPages * This,
            /* [in] */ PVOID pContext,
            /* [in] */ HWND hwnd,
            /* [out] */ int *piRet);
        
        END_INTERFACE
    } IThemeUIPagesVtbl;

    interface IThemeUIPages
    {
        CONST_VTBL struct IThemeUIPagesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IThemeUIPages_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IThemeUIPages_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IThemeUIPages_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IThemeUIPages_AddPage(This,pfnAddPage,lParam,nPageID)	\
    (This)->lpVtbl -> AddPage(This,pfnAddPage,lParam,nPageID)

#define IThemeUIPages_AddBasePage(This,pBasePage)	\
    (This)->lpVtbl -> AddBasePage(This,pBasePage)

#define IThemeUIPages_ApplyPressed(This,dwFlags)	\
    (This)->lpVtbl -> ApplyPressed(This,dwFlags)

#define IThemeUIPages_GetBasePagesEnum(This,ppEnumUnknown)	\
    (This)->lpVtbl -> GetBasePagesEnum(This,ppEnumUnknown)

#define IThemeUIPages_UpdatePreview(This,dwFlags)	\
    (This)->lpVtbl -> UpdatePreview(This,dwFlags)

#define IThemeUIPages_AddFakeSettingsPage(This,pVoid)	\
    (This)->lpVtbl -> AddFakeSettingsPage(This,pVoid)

#define IThemeUIPages_SetExecMode(This,dwEM)	\
    (This)->lpVtbl -> SetExecMode(This,dwEM)

#define IThemeUIPages_GetExecMode(This,pdwEM)	\
    (This)->lpVtbl -> GetExecMode(This,pdwEM)

#define IThemeUIPages_LoadMonitorBitmap(This,fFillDesktop,phbmMon)	\
    (This)->lpVtbl -> LoadMonitorBitmap(This,fFillDesktop,phbmMon)

#define IThemeUIPages_DisplaySaveSettings(This,pContext,hwnd,piRet)	\
    (This)->lpVtbl -> DisplaySaveSettings(This,pContext,hwnd,piRet)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IThemeUIPages_AddPage_Proxy( 
    IThemeUIPages * This,
    /* [in] */ LPFNSVADDPROPSHEETPAGE pfnAddPage,
    /* [in] */ LPARAM lParam,
    /* [in] */ long nPageID);


void __RPC_STUB IThemeUIPages_AddPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThemeUIPages_AddBasePage_Proxy( 
    IThemeUIPages * This,
    /* [in] */ IBasePropPage *pBasePage);


void __RPC_STUB IThemeUIPages_AddBasePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThemeUIPages_ApplyPressed_Proxy( 
    IThemeUIPages * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IThemeUIPages_ApplyPressed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThemeUIPages_GetBasePagesEnum_Proxy( 
    IThemeUIPages * This,
    /* [out] */ IEnumUnknown **ppEnumUnknown);


void __RPC_STUB IThemeUIPages_GetBasePagesEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThemeUIPages_UpdatePreview_Proxy( 
    IThemeUIPages * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IThemeUIPages_UpdatePreview_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThemeUIPages_AddFakeSettingsPage_Proxy( 
    IThemeUIPages * This,
    /* [in] */ LPVOID pVoid);


void __RPC_STUB IThemeUIPages_AddFakeSettingsPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThemeUIPages_SetExecMode_Proxy( 
    IThemeUIPages * This,
    /* [in] */ DWORD dwEM);


void __RPC_STUB IThemeUIPages_SetExecMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThemeUIPages_GetExecMode_Proxy( 
    IThemeUIPages * This,
    /* [out] */ DWORD *pdwEM);


void __RPC_STUB IThemeUIPages_GetExecMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThemeUIPages_LoadMonitorBitmap_Proxy( 
    IThemeUIPages * This,
    /* [in] */ BOOL fFillDesktop,
    /* [out] */ HBITMAP *phbmMon);


void __RPC_STUB IThemeUIPages_LoadMonitorBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IThemeUIPages_DisplaySaveSettings_Proxy( 
    IThemeUIPages * This,
    /* [in] */ PVOID pContext,
    /* [in] */ HWND hwnd,
    /* [out] */ int *piRet);


void __RPC_STUB IThemeUIPages_DisplaySaveSettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IThemeUIPages_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0267 */
/* [local] */ 

// INTERFACE: IAdvancedDialog
// DESCRIPTION:
// 
// DisplayAdvancedDialog: Display the Advanced Dialog.
//          hwndParent: Parent the dialog on this hwnd.
//          pBasePage: Load the state from this propertybag.  Save the state here if OK is pressed.
//          pfEnableApply: Tell the parent dialog if they should enable the Apply button.


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0267_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0267_v0_0_s_ifspec;

#ifndef __IAdvancedDialog_INTERFACE_DEFINED__
#define __IAdvancedDialog_INTERFACE_DEFINED__

/* interface IAdvancedDialog */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IAdvancedDialog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9DD92CA7-BF27-4fcb-AE95-1EAC48FC254D")
    IAdvancedDialog : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DisplayAdvancedDialog( 
            /* [in] */ HWND hwndParent,
            /* [in] */ IPropertyBag *pBasePage,
            /* [in] */ BOOL *pfEnableApply) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAdvancedDialogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAdvancedDialog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAdvancedDialog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAdvancedDialog * This);
        
        HRESULT ( STDMETHODCALLTYPE *DisplayAdvancedDialog )( 
            IAdvancedDialog * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ IPropertyBag *pBasePage,
            /* [in] */ BOOL *pfEnableApply);
        
        END_INTERFACE
    } IAdvancedDialogVtbl;

    interface IAdvancedDialog
    {
        CONST_VTBL struct IAdvancedDialogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAdvancedDialog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAdvancedDialog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAdvancedDialog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAdvancedDialog_DisplayAdvancedDialog(This,hwndParent,pBasePage,pfEnableApply)	\
    (This)->lpVtbl -> DisplayAdvancedDialog(This,hwndParent,pBasePage,pfEnableApply)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAdvancedDialog_DisplayAdvancedDialog_Proxy( 
    IAdvancedDialog * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ IPropertyBag *pBasePage,
    /* [in] */ BOOL *pfEnableApply);


void __RPC_STUB IAdvancedDialog_DisplayAdvancedDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAdvancedDialog_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0268 */
/* [local] */ 

// INTERFACE: IBasePropPage
// DESCRIPTION:
//     This interface is implemented by IShellPropSheetExt objects which want to add pages to
// the advanced dialog.  When one of the base dialog pages clicks on a button that
// should open the advanced dialog, IThemeUIPages::DisplayAdvancedDialog() will call
// each object's IBasePropPage::GetAdvancedPage() method.  The base page will then
// create an IAdvancedDialog object to add the advanced pages and track the state.  If the
// advanced dlg clicks OK, then the state should move back into the IBasePropPage
// object, via IAdvancedDialog::OnClose(, pBasePropPage).  Then the base dlg object can
// persist the state when the dialog receives an OK or APPLY command.
// This object may want to implement IObjectWithSite so it can get a IUnknown pointer to
// the IThemeUIPages object.  This will allow this object's base pages to open the
// advanced dialog via IBasePropPage::GetAdvancedPage().
// 
// GetAdvancedPage: The callee will create the IAdvancedDialog object and return it.
//          Note that the state may be dirty if the user already opened and closed the
//          advanced dialog without clicking Apply.
// OnClose: The page will be called when the base dialog is closing.  This will allow
//          the object to persist it's state.
typedef /* [helpstring] */ 
enum tagPropPageOnApply
    {	PPOAACTION_CANCEL	= 0,
	PPOAACTION_OK	= PPOAACTION_CANCEL + 1,
	PPOAACTION_APPLY	= PPOAACTION_OK + 1
    } 	PROPPAGEONAPPLY;



extern RPC_IF_HANDLE __MIDL_itf_shpriv_0268_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0268_v0_0_s_ifspec;

#ifndef __IBasePropPage_INTERFACE_DEFINED__
#define __IBasePropPage_INTERFACE_DEFINED__

/* interface IBasePropPage */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IBasePropPage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B34E525B-9EB4-433b-8E0F-019C4F21D7E7")
    IBasePropPage : public IShellPropSheetExt
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAdvancedDialog( 
            /* [out] */ IAdvancedDialog **ppAdvDialog) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnApply( 
            /* [in] */ PROPPAGEONAPPLY oaAction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBasePropPageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IBasePropPage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IBasePropPage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IBasePropPage * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddPages )( 
            IBasePropPage * This,
            /* [in] */ LPFNSVADDPROPSHEETPAGE pfnAddPage,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *ReplacePage )( 
            IBasePropPage * This,
            /* [in] */ EXPPS uPageID,
            /* [in] */ LPFNSVADDPROPSHEETPAGE pfnReplaceWith,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *GetAdvancedDialog )( 
            IBasePropPage * This,
            /* [out] */ IAdvancedDialog **ppAdvDialog);
        
        HRESULT ( STDMETHODCALLTYPE *OnApply )( 
            IBasePropPage * This,
            /* [in] */ PROPPAGEONAPPLY oaAction);
        
        END_INTERFACE
    } IBasePropPageVtbl;

    interface IBasePropPage
    {
        CONST_VTBL struct IBasePropPageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBasePropPage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IBasePropPage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IBasePropPage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IBasePropPage_AddPages(This,pfnAddPage,lParam)	\
    (This)->lpVtbl -> AddPages(This,pfnAddPage,lParam)

#define IBasePropPage_ReplacePage(This,uPageID,pfnReplaceWith,lParam)	\
    (This)->lpVtbl -> ReplacePage(This,uPageID,pfnReplaceWith,lParam)


#define IBasePropPage_GetAdvancedDialog(This,ppAdvDialog)	\
    (This)->lpVtbl -> GetAdvancedDialog(This,ppAdvDialog)

#define IBasePropPage_OnApply(This,oaAction)	\
    (This)->lpVtbl -> OnApply(This,oaAction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IBasePropPage_GetAdvancedDialog_Proxy( 
    IBasePropPage * This,
    /* [out] */ IAdvancedDialog **ppAdvDialog);


void __RPC_STUB IBasePropPage_GetAdvancedDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IBasePropPage_OnApply_Proxy( 
    IBasePropPage * This,
    /* [in] */ PROPPAGEONAPPLY oaAction);


void __RPC_STUB IBasePropPage_OnApply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IBasePropPage_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0269 */
/* [local] */ 

// INTERFACE: IPreviewSystemMetrics
// DESCRIPTION:
// This object will allow the negociation with a preview of the system metrics.


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0269_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0269_v0_0_s_ifspec;

#ifndef __IPreviewSystemMetrics_INTERFACE_DEFINED__
#define __IPreviewSystemMetrics_INTERFACE_DEFINED__

/* interface IPreviewSystemMetrics */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IPreviewSystemMetrics;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FC0A77D2-2ADF-4ede-A885-523A3A74A145")
    IPreviewSystemMetrics : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RefreshColors( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateDPIchange( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateCharsetChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeskSetCurrentScheme( 
            /* [string][in] */ LPCWSTR pwzSchemeName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPreviewSystemMetricsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPreviewSystemMetrics * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPreviewSystemMetrics * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPreviewSystemMetrics * This);
        
        HRESULT ( STDMETHODCALLTYPE *RefreshColors )( 
            IPreviewSystemMetrics * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateDPIchange )( 
            IPreviewSystemMetrics * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateCharsetChanges )( 
            IPreviewSystemMetrics * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeskSetCurrentScheme )( 
            IPreviewSystemMetrics * This,
            /* [string][in] */ LPCWSTR pwzSchemeName);
        
        END_INTERFACE
    } IPreviewSystemMetricsVtbl;

    interface IPreviewSystemMetrics
    {
        CONST_VTBL struct IPreviewSystemMetricsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPreviewSystemMetrics_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPreviewSystemMetrics_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPreviewSystemMetrics_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPreviewSystemMetrics_RefreshColors(This)	\
    (This)->lpVtbl -> RefreshColors(This)

#define IPreviewSystemMetrics_UpdateDPIchange(This)	\
    (This)->lpVtbl -> UpdateDPIchange(This)

#define IPreviewSystemMetrics_UpdateCharsetChanges(This)	\
    (This)->lpVtbl -> UpdateCharsetChanges(This)

#define IPreviewSystemMetrics_DeskSetCurrentScheme(This,pwzSchemeName)	\
    (This)->lpVtbl -> DeskSetCurrentScheme(This,pwzSchemeName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPreviewSystemMetrics_RefreshColors_Proxy( 
    IPreviewSystemMetrics * This);


void __RPC_STUB IPreviewSystemMetrics_RefreshColors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPreviewSystemMetrics_UpdateDPIchange_Proxy( 
    IPreviewSystemMetrics * This);


void __RPC_STUB IPreviewSystemMetrics_UpdateDPIchange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPreviewSystemMetrics_UpdateCharsetChanges_Proxy( 
    IPreviewSystemMetrics * This);


void __RPC_STUB IPreviewSystemMetrics_UpdateCharsetChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPreviewSystemMetrics_DeskSetCurrentScheme_Proxy( 
    IPreviewSystemMetrics * This,
    /* [string][in] */ LPCWSTR pwzSchemeName);


void __RPC_STUB IPreviewSystemMetrics_DeskSetCurrentScheme_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPreviewSystemMetrics_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0270 */
/* [local] */ 

#define SZ_PBPROP_SCREENSAVER_PATH           TEXT("ScreenSaver_Path")
#define SZ_PBPROP_BACKGROUND_PATH            TEXT("Background_Path")
#define SZ_PBPROP_BACKGROUNDSRC_PATH         TEXT("BackgroundSrc_Path")                    // The source path of the background.  This is before it was converted to a .bmp.
#define SZ_PBPROP_BACKGROUND_TILE            TEXT("Background_TILE")                       // VT_UI4 with WPSTYLE_ flags from WALLPAPEROPT in IActiveDesktop::SetWallpaperOptions()
#define SZ_PBPROP_VISUALSTYLE_PATH           TEXT("VisualStyle_Path")                      // VT_BSTR with the visual style path (.mstheme file)
#define SZ_PBPROP_VISUALSTYLE_COLOR          TEXT("VisualStyle_Color")                     // VT_BSTR with the visual style Color Style
#define SZ_PBPROP_VISUALSTYLE_SIZE           TEXT("VisualStyle_Size")                      // VT_BSTR with the visual style size
#define SZ_PBPROP_SYSTEM_METRICS             TEXT("SystemMetrics")                         // VT_BYREF byref pointer to SYSTEMMETRICSALL
#define SZ_PBPROP_PREVIEW1                   TEXT("Preview1")                              // VT_UNKNOWN to object w/IThemePreview
#define SZ_PBPROP_PREVIEW2                   TEXT("Preview2")                              // VT_UNKNOWN to object w/IThemePreview
#define SZ_PBPROP_PREVIEW3                   TEXT("Preview3")                              // VT_UNKNOWN to object w/IThemePreview
#define SZ_PBPROP_CUSTOMIZE_THEME            TEXT("Theme_CustomizeTheme")                  // VT_EMPTY. Used to indicate that the theme settings have changed
#define SZ_PBPROP_WEBCOMPONENTS              TEXT("WebComponents")                         // VT_UNKNOWN. Get or Set the IActiveDesktop interface containing the ActiveDesktop components
#define SZ_PBPROP_OPENADVANCEDDLG            TEXT("OpenAdvancedDialog")                    // VT_BOOL. Tells the IPropertyBag to open the Advanced dialog when opening.  If read, this indicates if the base dialog should go away when the Adv dlg closes.
#define SZ_PBPROP_BACKGROUND_COLOR           TEXT("BackgroundColor")                       // VT_UI4. Get or set the COLORREF (RGB) color for the background system metric.
#define SZ_PBPROP_THEME_LAUNCHTHEME          TEXT("ThemeLaunchTheme")                      // VT_LPWSTR. This will be the path to the .theme file to open.
#define SZ_PBPROP_APPEARANCE_LAUNCHMSTHEME   TEXT("AppearanceLaunchMSTheme")               // VT_LPWSTR. This will be the path to the .mstheme file to open.
#define SZ_PBPROP_PREOPEN                    TEXT("PreOpen")                               // VARIANT is NULL. This is sent right before the dialog opens.
#define SZ_PBPROP_DPI_MODIFIED_VALUE         TEXT("Settings_DPIModifiedValue")             // VT_I4 specifying the currently modified DPI
#define SZ_PBPROP_DPI_APPLIED_VALUE          TEXT("Settings_DPIAppliedValue")              // VT_I4 specifying the currently applied DPI
// Display Control Panel flags to specify an opening page.
// You can launch "rundll32.exe shell32.dll,Control_RunDLL desk.cpl ,@Settings" 
// which will launch the Display CPL to the Settings tab.
// These names are canonical so they will work on all languages.  The tab order
// will change when admin policies are applied or when the OS revs the UI and
// these names will always work.
#define SZ_DISPLAYCPL_OPENTO_THEMES            TEXT("Themes")              // Themes tab
#define SZ_DISPLAYCPL_OPENTO_DESKTOP           TEXT("Desktop")             // Desktop tab
#define SZ_DISPLAYCPL_OPENTO_SCREENSAVER       TEXT("ScreenSaver")         // Screen Saver tab
#define SZ_DISPLAYCPL_OPENTO_APPEARANCE        TEXT("Appearance")          // Appearance tab
#define SZ_DISPLAYCPL_OPENTO_SETTINGS          TEXT("Settings")            // Settings tab
#endif // _WIN32_IE >= 0x0600


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0270_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0270_v0_0_s_ifspec;

#ifndef __IAssocHandler_INTERFACE_DEFINED__
#define __IAssocHandler_INTERFACE_DEFINED__

/* interface IAssocHandler */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IAssocHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("973810ad-9599-4b88-9e4d-6ee98c9552da")
    IAssocHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out][string] */ LPWSTR *ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUIName( 
            /* [out][string] */ LPWSTR *ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIconLocation( 
            /* [out][string] */ LPWSTR *ppszPath,
            int *pIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRecommended( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MakeDefault( 
            /* [string][in] */ LPCWSTR pszDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exec( 
            /* [in] */ HWND hwnd,
            /* [string][in] */ LPCWSTR pszFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ void *pici,
            /* [string][in] */ LPCWSTR pszFile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssocHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssocHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssocHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssocHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IAssocHandler * This,
            /* [out][string] */ LPWSTR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *GetUIName )( 
            IAssocHandler * This,
            /* [out][string] */ LPWSTR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *GetIconLocation )( 
            IAssocHandler * This,
            /* [out][string] */ LPWSTR *ppszPath,
            int *pIndex);
        
        HRESULT ( STDMETHODCALLTYPE *IsRecommended )( 
            IAssocHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *MakeDefault )( 
            IAssocHandler * This,
            /* [string][in] */ LPCWSTR pszDescription);
        
        HRESULT ( STDMETHODCALLTYPE *Exec )( 
            IAssocHandler * This,
            /* [in] */ HWND hwnd,
            /* [string][in] */ LPCWSTR pszFile);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IAssocHandler * This,
            /* [in] */ void *pici,
            /* [string][in] */ LPCWSTR pszFile);
        
        END_INTERFACE
    } IAssocHandlerVtbl;

    interface IAssocHandler
    {
        CONST_VTBL struct IAssocHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssocHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssocHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssocHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssocHandler_GetName(This,ppsz)	\
    (This)->lpVtbl -> GetName(This,ppsz)

#define IAssocHandler_GetUIName(This,ppsz)	\
    (This)->lpVtbl -> GetUIName(This,ppsz)

#define IAssocHandler_GetIconLocation(This,ppszPath,pIndex)	\
    (This)->lpVtbl -> GetIconLocation(This,ppszPath,pIndex)

#define IAssocHandler_IsRecommended(This)	\
    (This)->lpVtbl -> IsRecommended(This)

#define IAssocHandler_MakeDefault(This,pszDescription)	\
    (This)->lpVtbl -> MakeDefault(This,pszDescription)

#define IAssocHandler_Exec(This,hwnd,pszFile)	\
    (This)->lpVtbl -> Exec(This,hwnd,pszFile)

#define IAssocHandler_Invoke(This,pici,pszFile)	\
    (This)->lpVtbl -> Invoke(This,pici,pszFile)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssocHandler_GetName_Proxy( 
    IAssocHandler * This,
    /* [out][string] */ LPWSTR *ppsz);


void __RPC_STUB IAssocHandler_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssocHandler_GetUIName_Proxy( 
    IAssocHandler * This,
    /* [out][string] */ LPWSTR *ppsz);


void __RPC_STUB IAssocHandler_GetUIName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssocHandler_GetIconLocation_Proxy( 
    IAssocHandler * This,
    /* [out][string] */ LPWSTR *ppszPath,
    int *pIndex);


void __RPC_STUB IAssocHandler_GetIconLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssocHandler_IsRecommended_Proxy( 
    IAssocHandler * This);


void __RPC_STUB IAssocHandler_IsRecommended_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssocHandler_MakeDefault_Proxy( 
    IAssocHandler * This,
    /* [string][in] */ LPCWSTR pszDescription);


void __RPC_STUB IAssocHandler_MakeDefault_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssocHandler_Exec_Proxy( 
    IAssocHandler * This,
    /* [in] */ HWND hwnd,
    /* [string][in] */ LPCWSTR pszFile);


void __RPC_STUB IAssocHandler_Exec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssocHandler_Invoke_Proxy( 
    IAssocHandler * This,
    /* [in] */ void *pici,
    /* [string][in] */ LPCWSTR pszFile);


void __RPC_STUB IAssocHandler_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssocHandler_INTERFACE_DEFINED__ */


#ifndef __IEnumAssocHandlers_INTERFACE_DEFINED__
#define __IEnumAssocHandlers_INTERFACE_DEFINED__

/* interface IEnumAssocHandlers */
/* [local][unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IEnumAssocHandlers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("973810ae-9599-4b88-9e4d-6ee98c9552da")
    IEnumAssocHandlers : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IAssocHandler **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAssocHandlersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumAssocHandlers * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumAssocHandlers * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumAssocHandlers * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumAssocHandlers * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IAssocHandler **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } IEnumAssocHandlersVtbl;

    interface IEnumAssocHandlers
    {
        CONST_VTBL struct IEnumAssocHandlersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAssocHandlers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumAssocHandlers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumAssocHandlers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumAssocHandlers_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumAssocHandlers_Next_Proxy( 
    IEnumAssocHandlers * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IAssocHandler **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumAssocHandlers_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumAssocHandlers_INTERFACE_DEFINED__ */


#ifndef __IHWDevice_INTERFACE_DEFINED__
#define __IHWDevice_INTERFACE_DEFINED__

/* interface IHWDevice */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHWDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("99BC7510-0A96-43fa-8BB1-C928A0302EFB")
    IHWDevice : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [string][in] */ LPCWSTR pszDeviceID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AutoplayHandler( 
            /* [string][in] */ LPCWSTR pszEventType,
            /* [string][in] */ LPCWSTR pszHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHWDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHWDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHWDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHWDevice * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IHWDevice * This,
            /* [string][in] */ LPCWSTR pszDeviceID);
        
        HRESULT ( STDMETHODCALLTYPE *AutoplayHandler )( 
            IHWDevice * This,
            /* [string][in] */ LPCWSTR pszEventType,
            /* [string][in] */ LPCWSTR pszHandler);
        
        END_INTERFACE
    } IHWDeviceVtbl;

    interface IHWDevice
    {
        CONST_VTBL struct IHWDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHWDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHWDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHWDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHWDevice_Init(This,pszDeviceID)	\
    (This)->lpVtbl -> Init(This,pszDeviceID)

#define IHWDevice_AutoplayHandler(This,pszEventType,pszHandler)	\
    (This)->lpVtbl -> AutoplayHandler(This,pszEventType,pszHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHWDevice_Init_Proxy( 
    IHWDevice * This,
    /* [string][in] */ LPCWSTR pszDeviceID);


void __RPC_STUB IHWDevice_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHWDevice_AutoplayHandler_Proxy( 
    IHWDevice * This,
    /* [string][in] */ LPCWSTR pszEventType,
    /* [string][in] */ LPCWSTR pszHandler);


void __RPC_STUB IHWDevice_AutoplayHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHWDevice_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0273 */
/* [local] */ 

#define HWDEVCUSTOMPROP_USEVOLUMEPROCESSING      0x00000001


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0273_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0273_v0_0_s_ifspec;

#ifndef __IHWDeviceCustomProperties_INTERFACE_DEFINED__
#define __IHWDeviceCustomProperties_INTERFACE_DEFINED__

/* interface IHWDeviceCustomProperties */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHWDeviceCustomProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("77D5D69C-D6CE-4026-B625-26964EEC733F")
    IHWDeviceCustomProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitFromDeviceID( 
            /* [string][in] */ LPCWSTR pszDeviceID,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitFromDevNode( 
            /* [string][in] */ LPCWSTR pszDevNode,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDWORDProperty( 
            /* [string][in] */ LPCWSTR pszPropName,
            /* [out] */ DWORD *pdwProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringProperty( 
            /* [string][in] */ LPCWSTR pszPropName,
            /* [string][out] */ LPWSTR *ppszProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMultiStringProperty( 
            /* [string][in] */ LPCWSTR pszPropName,
            /* [in] */ BOOL fMergeMultiSz,
            /* [out] */ WORD_BLOB **ppblob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBlobProperty( 
            /* [string][in] */ LPCWSTR pszPropName,
            /* [out] */ BYTE_BLOB **ppblob) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHWDeviceCustomPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHWDeviceCustomProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHWDeviceCustomProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHWDeviceCustomProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitFromDeviceID )( 
            IHWDeviceCustomProperties * This,
            /* [string][in] */ LPCWSTR pszDeviceID,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *InitFromDevNode )( 
            IHWDeviceCustomProperties * This,
            /* [string][in] */ LPCWSTR pszDevNode,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDWORDProperty )( 
            IHWDeviceCustomProperties * This,
            /* [string][in] */ LPCWSTR pszPropName,
            /* [out] */ DWORD *pdwProp);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringProperty )( 
            IHWDeviceCustomProperties * This,
            /* [string][in] */ LPCWSTR pszPropName,
            /* [string][out] */ LPWSTR *ppszProp);
        
        HRESULT ( STDMETHODCALLTYPE *GetMultiStringProperty )( 
            IHWDeviceCustomProperties * This,
            /* [string][in] */ LPCWSTR pszPropName,
            /* [in] */ BOOL fMergeMultiSz,
            /* [out] */ WORD_BLOB **ppblob);
        
        HRESULT ( STDMETHODCALLTYPE *GetBlobProperty )( 
            IHWDeviceCustomProperties * This,
            /* [string][in] */ LPCWSTR pszPropName,
            /* [out] */ BYTE_BLOB **ppblob);
        
        END_INTERFACE
    } IHWDeviceCustomPropertiesVtbl;

    interface IHWDeviceCustomProperties
    {
        CONST_VTBL struct IHWDeviceCustomPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHWDeviceCustomProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHWDeviceCustomProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHWDeviceCustomProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHWDeviceCustomProperties_InitFromDeviceID(This,pszDeviceID,dwFlags)	\
    (This)->lpVtbl -> InitFromDeviceID(This,pszDeviceID,dwFlags)

#define IHWDeviceCustomProperties_InitFromDevNode(This,pszDevNode,dwFlags)	\
    (This)->lpVtbl -> InitFromDevNode(This,pszDevNode,dwFlags)

#define IHWDeviceCustomProperties_GetDWORDProperty(This,pszPropName,pdwProp)	\
    (This)->lpVtbl -> GetDWORDProperty(This,pszPropName,pdwProp)

#define IHWDeviceCustomProperties_GetStringProperty(This,pszPropName,ppszProp)	\
    (This)->lpVtbl -> GetStringProperty(This,pszPropName,ppszProp)

#define IHWDeviceCustomProperties_GetMultiStringProperty(This,pszPropName,fMergeMultiSz,ppblob)	\
    (This)->lpVtbl -> GetMultiStringProperty(This,pszPropName,fMergeMultiSz,ppblob)

#define IHWDeviceCustomProperties_GetBlobProperty(This,pszPropName,ppblob)	\
    (This)->lpVtbl -> GetBlobProperty(This,pszPropName,ppblob)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHWDeviceCustomProperties_InitFromDeviceID_Proxy( 
    IHWDeviceCustomProperties * This,
    /* [string][in] */ LPCWSTR pszDeviceID,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IHWDeviceCustomProperties_InitFromDeviceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHWDeviceCustomProperties_InitFromDevNode_Proxy( 
    IHWDeviceCustomProperties * This,
    /* [string][in] */ LPCWSTR pszDevNode,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IHWDeviceCustomProperties_InitFromDevNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHWDeviceCustomProperties_GetDWORDProperty_Proxy( 
    IHWDeviceCustomProperties * This,
    /* [string][in] */ LPCWSTR pszPropName,
    /* [out] */ DWORD *pdwProp);


void __RPC_STUB IHWDeviceCustomProperties_GetDWORDProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHWDeviceCustomProperties_GetStringProperty_Proxy( 
    IHWDeviceCustomProperties * This,
    /* [string][in] */ LPCWSTR pszPropName,
    /* [string][out] */ LPWSTR *ppszProp);


void __RPC_STUB IHWDeviceCustomProperties_GetStringProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHWDeviceCustomProperties_GetMultiStringProperty_Proxy( 
    IHWDeviceCustomProperties * This,
    /* [string][in] */ LPCWSTR pszPropName,
    /* [in] */ BOOL fMergeMultiSz,
    /* [out] */ WORD_BLOB **ppblob);


void __RPC_STUB IHWDeviceCustomProperties_GetMultiStringProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHWDeviceCustomProperties_GetBlobProperty_Proxy( 
    IHWDeviceCustomProperties * This,
    /* [string][in] */ LPCWSTR pszPropName,
    /* [out] */ BYTE_BLOB **ppblob);


void __RPC_STUB IHWDeviceCustomProperties_GetBlobProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHWDeviceCustomProperties_INTERFACE_DEFINED__ */


#ifndef __IEnumAutoplayHandler_INTERFACE_DEFINED__
#define __IEnumAutoplayHandler_INTERFACE_DEFINED__

/* interface IEnumAutoplayHandler */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumAutoplayHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66057ABA-FFDB-4077-998E-7F131C3F8157")
    IEnumAutoplayHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [string][out] */ LPWSTR *ppszHandler,
            /* [string][out] */ LPWSTR *ppszAction,
            /* [string][out] */ LPWSTR *ppszProvider,
            /* [string][out] */ LPWSTR *ppszIconLocation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAutoplayHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumAutoplayHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumAutoplayHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumAutoplayHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumAutoplayHandler * This,
            /* [string][out] */ LPWSTR *ppszHandler,
            /* [string][out] */ LPWSTR *ppszAction,
            /* [string][out] */ LPWSTR *ppszProvider,
            /* [string][out] */ LPWSTR *ppszIconLocation);
        
        END_INTERFACE
    } IEnumAutoplayHandlerVtbl;

    interface IEnumAutoplayHandler
    {
        CONST_VTBL struct IEnumAutoplayHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAutoplayHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumAutoplayHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumAutoplayHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumAutoplayHandler_Next(This,ppszHandler,ppszAction,ppszProvider,ppszIconLocation)	\
    (This)->lpVtbl -> Next(This,ppszHandler,ppszAction,ppszProvider,ppszIconLocation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumAutoplayHandler_Next_Proxy( 
    IEnumAutoplayHandler * This,
    /* [string][out] */ LPWSTR *ppszHandler,
    /* [string][out] */ LPWSTR *ppszAction,
    /* [string][out] */ LPWSTR *ppszProvider,
    /* [string][out] */ LPWSTR *ppszIconLocation);


void __RPC_STUB IEnumAutoplayHandler_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumAutoplayHandler_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0275 */
/* [local] */ 

#define HANDLERDEFAULT_USERCHOSENDEFAULT                0x00000002
#define HANDLERDEFAULT_EVENTHANDLERDEFAULT              0x00000004
#define HANDLERDEFAULT_MORERECENTHANDLERSINSTALLED      0x00000008
#define HANDLERDEFAULT_DEFAULTSAREDIFFERENT             0x00000010
#define HANDLERDEFAULT_MAKERETURNVALUE(a) MAKE_HRESULT(0, FACILITY_ITF, (a))
#define HANDLERDEFAULT_GETFLAGS(a) HRESULT_CODE((a))


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0275_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0275_v0_0_s_ifspec;

#ifndef __IAutoplayHandler_INTERFACE_DEFINED__
#define __IAutoplayHandler_INTERFACE_DEFINED__

/* interface IAutoplayHandler */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAutoplayHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("335E9E5D-37FC-4d73-8BA8-FD4E16B28134")
    IAutoplayHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [string][in] */ LPCWSTR pszDeviceID,
            /* [string][in] */ LPCWSTR pszEventType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitWithContent( 
            /* [string][in] */ LPCWSTR pszDeviceID,
            /* [string][in] */ LPCWSTR pszEventType,
            /* [string][in] */ LPCWSTR pszContentTypeHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumHandlers( 
            /* [out] */ IEnumAutoplayHandler **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultHandler( 
            /* [string][out] */ LPWSTR *ppszHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultHandler( 
            /* [string][in] */ LPCWSTR pszHandler) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutoplayHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAutoplayHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAutoplayHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAutoplayHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IAutoplayHandler * This,
            /* [string][in] */ LPCWSTR pszDeviceID,
            /* [string][in] */ LPCWSTR pszEventType);
        
        HRESULT ( STDMETHODCALLTYPE *InitWithContent )( 
            IAutoplayHandler * This,
            /* [string][in] */ LPCWSTR pszDeviceID,
            /* [string][in] */ LPCWSTR pszEventType,
            /* [string][in] */ LPCWSTR pszContentTypeHandler);
        
        HRESULT ( STDMETHODCALLTYPE *EnumHandlers )( 
            IAutoplayHandler * This,
            /* [out] */ IEnumAutoplayHandler **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultHandler )( 
            IAutoplayHandler * This,
            /* [string][out] */ LPWSTR *ppszHandler);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultHandler )( 
            IAutoplayHandler * This,
            /* [string][in] */ LPCWSTR pszHandler);
        
        END_INTERFACE
    } IAutoplayHandlerVtbl;

    interface IAutoplayHandler
    {
        CONST_VTBL struct IAutoplayHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutoplayHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAutoplayHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAutoplayHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAutoplayHandler_Init(This,pszDeviceID,pszEventType)	\
    (This)->lpVtbl -> Init(This,pszDeviceID,pszEventType)

#define IAutoplayHandler_InitWithContent(This,pszDeviceID,pszEventType,pszContentTypeHandler)	\
    (This)->lpVtbl -> InitWithContent(This,pszDeviceID,pszEventType,pszContentTypeHandler)

#define IAutoplayHandler_EnumHandlers(This,ppenum)	\
    (This)->lpVtbl -> EnumHandlers(This,ppenum)

#define IAutoplayHandler_GetDefaultHandler(This,ppszHandler)	\
    (This)->lpVtbl -> GetDefaultHandler(This,ppszHandler)

#define IAutoplayHandler_SetDefaultHandler(This,pszHandler)	\
    (This)->lpVtbl -> SetDefaultHandler(This,pszHandler)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAutoplayHandler_Init_Proxy( 
    IAutoplayHandler * This,
    /* [string][in] */ LPCWSTR pszDeviceID,
    /* [string][in] */ LPCWSTR pszEventType);


void __RPC_STUB IAutoplayHandler_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAutoplayHandler_InitWithContent_Proxy( 
    IAutoplayHandler * This,
    /* [string][in] */ LPCWSTR pszDeviceID,
    /* [string][in] */ LPCWSTR pszEventType,
    /* [string][in] */ LPCWSTR pszContentTypeHandler);


void __RPC_STUB IAutoplayHandler_InitWithContent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAutoplayHandler_EnumHandlers_Proxy( 
    IAutoplayHandler * This,
    /* [out] */ IEnumAutoplayHandler **ppenum);


void __RPC_STUB IAutoplayHandler_EnumHandlers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAutoplayHandler_GetDefaultHandler_Proxy( 
    IAutoplayHandler * This,
    /* [string][out] */ LPWSTR *ppszHandler);


void __RPC_STUB IAutoplayHandler_GetDefaultHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAutoplayHandler_SetDefaultHandler_Proxy( 
    IAutoplayHandler * This,
    /* [string][in] */ LPCWSTR pszHandler);


void __RPC_STUB IAutoplayHandler_SetDefaultHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAutoplayHandler_INTERFACE_DEFINED__ */


#ifndef __IAutoplayHandlerProperties_INTERFACE_DEFINED__
#define __IAutoplayHandlerProperties_INTERFACE_DEFINED__

/* interface IAutoplayHandlerProperties */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IAutoplayHandlerProperties;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("557730F6-41FA-4d11-B9FD-F88AB155347F")
    IAutoplayHandlerProperties : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [string][in] */ LPCWSTR pszHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInvokeProgIDAndVerb( 
            /* [string][out] */ LPWSTR *ppszInvokeProgID,
            /* [string][out] */ LPWSTR *ppszInvokeVerb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAutoplayHandlerPropertiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAutoplayHandlerProperties * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAutoplayHandlerProperties * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAutoplayHandlerProperties * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IAutoplayHandlerProperties * This,
            /* [string][in] */ LPCWSTR pszHandler);
        
        HRESULT ( STDMETHODCALLTYPE *GetInvokeProgIDAndVerb )( 
            IAutoplayHandlerProperties * This,
            /* [string][out] */ LPWSTR *ppszInvokeProgID,
            /* [string][out] */ LPWSTR *ppszInvokeVerb);
        
        END_INTERFACE
    } IAutoplayHandlerPropertiesVtbl;

    interface IAutoplayHandlerProperties
    {
        CONST_VTBL struct IAutoplayHandlerPropertiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAutoplayHandlerProperties_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAutoplayHandlerProperties_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAutoplayHandlerProperties_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAutoplayHandlerProperties_Init(This,pszHandler)	\
    (This)->lpVtbl -> Init(This,pszHandler)

#define IAutoplayHandlerProperties_GetInvokeProgIDAndVerb(This,ppszInvokeProgID,ppszInvokeVerb)	\
    (This)->lpVtbl -> GetInvokeProgIDAndVerb(This,ppszInvokeProgID,ppszInvokeVerb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAutoplayHandlerProperties_Init_Proxy( 
    IAutoplayHandlerProperties * This,
    /* [string][in] */ LPCWSTR pszHandler);


void __RPC_STUB IAutoplayHandlerProperties_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAutoplayHandlerProperties_GetInvokeProgIDAndVerb_Proxy( 
    IAutoplayHandlerProperties * This,
    /* [string][out] */ LPWSTR *ppszInvokeProgID,
    /* [string][out] */ LPWSTR *ppszInvokeVerb);


void __RPC_STUB IAutoplayHandlerProperties_GetInvokeProgIDAndVerb_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAutoplayHandlerProperties_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0277 */
/* [local] */ 

#include <pshpack8.h>
typedef struct tagVOLUMEINFO
    {
    DWORD dwState;
    LPWSTR pszDeviceIDVolume;
    LPWSTR pszVolumeGUID;
    DWORD dwVolumeFlags;
    DWORD dwDriveType;
    DWORD dwDriveCapability;
    LPWSTR pszLabel;
    LPWSTR pszFileSystem;
    DWORD dwFileSystemFlags;
    DWORD dwMaxFileNameLen;
    DWORD dwRootAttributes;
    DWORD dwSerialNumber;
    DWORD dwDriveState;
    DWORD dwMediaState;
    DWORD dwMediaCap;
    LPWSTR pszAutorunIconLocation;
    LPWSTR pszAutorunLabel;
    LPWSTR pszIconLocationFromService;
    LPWSTR pszNoMediaIconLocationFromService;
    LPWSTR pszLabelFromService;
    } 	VOLUMEINFO;

typedef struct tagVOLUMEINFO2
    {
    DWORD cbSize;
    WCHAR szDeviceIDVolume[ 200 ];
    WCHAR szVolumeGUID[ 50 ];
    WCHAR szLabel[ 33 ];
    WCHAR szFileSystem[ 30 ];
    DWORD dwState;
    DWORD dwVolumeFlags;
    DWORD dwDriveType;
    DWORD dwDriveCapability;
    DWORD dwFileSystemFlags;
    DWORD dwMaxFileNameLen;
    DWORD dwRootAttributes;
    DWORD dwSerialNumber;
    DWORD dwDriveState;
    DWORD dwMediaState;
    DWORD dwMediaCap;
    DWORD oAutorunIconLocation;
    DWORD oAutorunLabel;
    DWORD oIconLocationFromService;
    DWORD oNoMediaIconLocationFromService;
    DWORD oLabelFromService;
    WCHAR szOptionalStrings[ 1 ];
    } 	VOLUMEINFO2;

typedef struct tagHWDEVICEINFO
    {
    DWORD cbSize;
    WCHAR szDeviceIntfID[ 200 ];
    GUID guidInterface;
    DWORD dwState;
    DWORD dwDeviceFlags;
    } 	HWDEVICEINFO;

#define SHHARDWAREEVENT_VOLUMEARRIVED            0x00000001
#define SHHARDWAREEVENT_VOLUMEUPDATED            0x00000002
#define SHHARDWAREEVENT_VOLUMEREMOVED            0x00000004
#define SHHARDWAREEVENT_MOUNTPOINTARRIVED        0x00000008
#define SHHARDWAREEVENT_MOUNTPOINTREMOVED        0x00000010
#define SHHARDWAREEVENT_DEVICEARRIVED            0x00000020
#define SHHARDWAREEVENT_DEVICEUPDATED            0x00000040
#define SHHARDWAREEVENT_DEVICEREMOVED            0x00000080
#define SHHARDWAREEVENT_VOLUMEMOUNTED            0x00000100
#define SHHARDWAREEVENT_VOLUMEDISMOUNTED         0x00000200
#define SHHARDWAREEVENT_MOUNTDEVICEARRIVED       0x00000020 // is really DEVICEARRIVED
#define SHHARDWAREEVENT_MOUNTDEVICEUPDATED       0x00000040 // is really DEVICEUPDATED
#define SHHARDWAREEVENT_MOUNTDEVICEREMOVED       0x00000080 // is really DEVICEREMOVED
#define MAX_FILESYSNAME         30
#define MAX_LABEL_NTFS           32  // not including the NULL
#define MAX_LABEL               MAX_LABEL_NTFS + 1
#define MAX_ICONLOCATION           MAX_PATH + 12 // + 12 for comma and index
#define MAX_VOLUMEINFO2 (sizeof(VOLUMEINFO2) + (4 * MAX_ICONLOCATION + 1 * MAX_LABEL) * sizeof(WCHAR))
typedef struct tagSHHARDWAREEVENT
    {
    DWORD cbSize;
    DWORD dwEvent;
    BYTE rgbPayLoad[ 1 ];
    } 	SHHARDWAREEVENT;

typedef struct tagMTPTADDED
    {
    WCHAR szMountPoint[ 260 ];
    WCHAR szDeviceIDVolume[ 200 ];
    } 	MTPTADDED;

#include <poppack.h>
#define HWDMS_PRESENT                                 0x10000000
#define HWDMS_FORMATTED                               0x20000000
#define HWDMC_WRITECAPABILITY_SUPPORTDETECTION        0x00000001
#define HWDMC_CDROM                                   0x00000002
#define HWDMC_CDRECORDABLE                            0x00000004
#define HWDMC_CDREWRITABLE                            0x00000008
#define HWDMC_DVDROM                                  0x00000010
#define HWDMC_DVDRECORDABLE                           0x00000020
#define HWDMC_DVDREWRITABLE                           0x00000040
#define HWDMC_DVDRAM                                  0x00000080
#define HWDMC_ANALOGAUDIOOUT                          0x00000100
#define HWDMC_RANDOMWRITE                             0x00001000
#define HWDMC_HASAUTORUNINF                           0x00002000
#define HWDMC_HASAUTORUNCOMMAND                       0x00004000
#define HWDMC_HASDESKTOPINI                           0x00008000
#define HWDMC_HASDVDMOVIE                             0x00010000
#define HWDMC_HASAUDIOTRACKS                          0x00020000
#define HWDMC_HASDATATRACKS                           0x00040000
#define HWDMC_HASAUDIOTRACKS_UNDETERMINED             0x00080000
#define HWDMC_HASDATATRACKS_UNDETERMINED              0x00100000
#define HWDMC_HASUSEAUTOPLAY                          0x00200000
#define HWDMC_CDTYPEMASK                              (HWDMC_CDROM | HWDMC_CDRECORDABLE | HWDMC_CDREWRITABLE | HWDMC_DVDROM | HWDMC_DVDRECORDABLE | HWDMC_DVDREWRITABLE | HWDMC_DVDRAM)
#define HWDDC_CAPABILITY_SUPPORTDETECTION             HWDMC_WRITECAPABILITY_SUPPORTDETECTION 
#define HWDDC_CDROM                                   HWDMC_CDROM                            
#define HWDDC_CDRECORDABLE                            HWDMC_CDRECORDABLE                     
#define HWDDC_CDREWRITABLE                            HWDMC_CDREWRITABLE                     
#define HWDDC_DVDROM                                  HWDMC_DVDROM                           
#define HWDDC_DVDRECORDABLE                           HWDMC_DVDRECORDABLE                    
#define HWDDC_DVDREWRITABLE                           HWDMC_DVDREWRITABLE                    
#define HWDDC_DVDRAM                                  HWDMC_DVDRAM                           
#define HWDDC_ANALOGAUDIOOUT                          HWDMC_ANALOGAUDIOOUT                   
#define HWDDC_RANDOMWRITE                             HWDMC_RANDOMWRITE
#define HWDDC_NOSOFTEJECT                             0x00002000
#define HWDDC_FLOPPYSOFTEJECT                         0x00004000
#define HWDDC_REMOVABLEDEVICE                         0x00008000
#define HWDDC_CDTYPEMASK                              HWDMC_CDTYPEMASK
#define HWDVF_STATE_SUPPORTNOTIFICATION               0x00000001
#define HWDVF_STATE_ACCESSDENIED                      0x00000002
#define HWDVF_STATE_DISMOUNTED                        0x00000004
#define HWDVF_STATE_HASAUTOPLAYHANDLER                0x00000008
#define HWDVF_STATE_DONOTSNIFFCONTENT                 0x00000010
#define HWDVF_STATE_JUSTDOCKED                        0x00000020
#define HWDTS_FLOPPY35                                0x00000001
#define HWDTS_FLOPPY525                               0x00000002
#define HWDTS_REMOVABLEDISK                           0x00000004
#define HWDTS_FIXEDDISK                               0x00000008
#define HWDTS_CDROM                                   0x00000010
#define HWDDF_HASDEVICEHANDLER                        0x00000001
#define HWDDF_HASDEVICEHANDLER_UNDETERMINED           0x00000002
#define HWDDF_REMOVABLEDEVICE                         0x00000004
#define HWDDF_REMOVABLEDEVICE_UNDETERMINED            0x00000008


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0277_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0277_v0_0_s_ifspec;

#ifndef __IHardwareDeviceCallback_INTERFACE_DEFINED__
#define __IHardwareDeviceCallback_INTERFACE_DEFINED__

/* interface IHardwareDeviceCallback */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHardwareDeviceCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("99B732C2-9B7B-4145-83A4-C45DF791FD99")
    IHardwareDeviceCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE VolumeAddedOrUpdated( 
            /* [in] */ BOOL fAdded,
            /* [in] */ VOLUMEINFO *pvolinfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VolumeRemoved( 
            /* [string][in] */ LPCWSTR pszDeviceIDVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MountPointAdded( 
            /* [string][in] */ LPCWSTR pszMountPoint,
            /* [string][in] */ LPCWSTR pszDeviceIDVolume) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MountPointRemoved( 
            /* [string][in] */ LPCWSTR pszMountPoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeviceAdded( 
            /* [string][in] */ LPCWSTR pszDeviceID,
            /* [in] */ GUID guidDeviceID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeviceUpdated( 
            /* [string][in] */ LPCWSTR pszDeviceID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeviceRemoved( 
            /* [string][in] */ LPCWSTR pszDeviceID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHardwareDeviceCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHardwareDeviceCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHardwareDeviceCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHardwareDeviceCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *VolumeAddedOrUpdated )( 
            IHardwareDeviceCallback * This,
            /* [in] */ BOOL fAdded,
            /* [in] */ VOLUMEINFO *pvolinfo);
        
        HRESULT ( STDMETHODCALLTYPE *VolumeRemoved )( 
            IHardwareDeviceCallback * This,
            /* [string][in] */ LPCWSTR pszDeviceIDVolume);
        
        HRESULT ( STDMETHODCALLTYPE *MountPointAdded )( 
            IHardwareDeviceCallback * This,
            /* [string][in] */ LPCWSTR pszMountPoint,
            /* [string][in] */ LPCWSTR pszDeviceIDVolume);
        
        HRESULT ( STDMETHODCALLTYPE *MountPointRemoved )( 
            IHardwareDeviceCallback * This,
            /* [string][in] */ LPCWSTR pszMountPoint);
        
        HRESULT ( STDMETHODCALLTYPE *DeviceAdded )( 
            IHardwareDeviceCallback * This,
            /* [string][in] */ LPCWSTR pszDeviceID,
            /* [in] */ GUID guidDeviceID);
        
        HRESULT ( STDMETHODCALLTYPE *DeviceUpdated )( 
            IHardwareDeviceCallback * This,
            /* [string][in] */ LPCWSTR pszDeviceID);
        
        HRESULT ( STDMETHODCALLTYPE *DeviceRemoved )( 
            IHardwareDeviceCallback * This,
            /* [string][in] */ LPCWSTR pszDeviceID);
        
        END_INTERFACE
    } IHardwareDeviceCallbackVtbl;

    interface IHardwareDeviceCallback
    {
        CONST_VTBL struct IHardwareDeviceCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHardwareDeviceCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHardwareDeviceCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHardwareDeviceCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHardwareDeviceCallback_VolumeAddedOrUpdated(This,fAdded,pvolinfo)	\
    (This)->lpVtbl -> VolumeAddedOrUpdated(This,fAdded,pvolinfo)

#define IHardwareDeviceCallback_VolumeRemoved(This,pszDeviceIDVolume)	\
    (This)->lpVtbl -> VolumeRemoved(This,pszDeviceIDVolume)

#define IHardwareDeviceCallback_MountPointAdded(This,pszMountPoint,pszDeviceIDVolume)	\
    (This)->lpVtbl -> MountPointAdded(This,pszMountPoint,pszDeviceIDVolume)

#define IHardwareDeviceCallback_MountPointRemoved(This,pszMountPoint)	\
    (This)->lpVtbl -> MountPointRemoved(This,pszMountPoint)

#define IHardwareDeviceCallback_DeviceAdded(This,pszDeviceID,guidDeviceID)	\
    (This)->lpVtbl -> DeviceAdded(This,pszDeviceID,guidDeviceID)

#define IHardwareDeviceCallback_DeviceUpdated(This,pszDeviceID)	\
    (This)->lpVtbl -> DeviceUpdated(This,pszDeviceID)

#define IHardwareDeviceCallback_DeviceRemoved(This,pszDeviceID)	\
    (This)->lpVtbl -> DeviceRemoved(This,pszDeviceID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHardwareDeviceCallback_VolumeAddedOrUpdated_Proxy( 
    IHardwareDeviceCallback * This,
    /* [in] */ BOOL fAdded,
    /* [in] */ VOLUMEINFO *pvolinfo);


void __RPC_STUB IHardwareDeviceCallback_VolumeAddedOrUpdated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHardwareDeviceCallback_VolumeRemoved_Proxy( 
    IHardwareDeviceCallback * This,
    /* [string][in] */ LPCWSTR pszDeviceIDVolume);


void __RPC_STUB IHardwareDeviceCallback_VolumeRemoved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHardwareDeviceCallback_MountPointAdded_Proxy( 
    IHardwareDeviceCallback * This,
    /* [string][in] */ LPCWSTR pszMountPoint,
    /* [string][in] */ LPCWSTR pszDeviceIDVolume);


void __RPC_STUB IHardwareDeviceCallback_MountPointAdded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHardwareDeviceCallback_MountPointRemoved_Proxy( 
    IHardwareDeviceCallback * This,
    /* [string][in] */ LPCWSTR pszMountPoint);


void __RPC_STUB IHardwareDeviceCallback_MountPointRemoved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHardwareDeviceCallback_DeviceAdded_Proxy( 
    IHardwareDeviceCallback * This,
    /* [string][in] */ LPCWSTR pszDeviceID,
    /* [in] */ GUID guidDeviceID);


void __RPC_STUB IHardwareDeviceCallback_DeviceAdded_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHardwareDeviceCallback_DeviceUpdated_Proxy( 
    IHardwareDeviceCallback * This,
    /* [string][in] */ LPCWSTR pszDeviceID);


void __RPC_STUB IHardwareDeviceCallback_DeviceUpdated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHardwareDeviceCallback_DeviceRemoved_Proxy( 
    IHardwareDeviceCallback * This,
    /* [string][in] */ LPCWSTR pszDeviceID);


void __RPC_STUB IHardwareDeviceCallback_DeviceRemoved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHardwareDeviceCallback_INTERFACE_DEFINED__ */


#ifndef __IHardwareDevicesEnum_INTERFACE_DEFINED__
#define __IHardwareDevicesEnum_INTERFACE_DEFINED__

/* interface IHardwareDevicesEnum */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHardwareDevicesEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("553A4A55-681C-440e-B109-597B9219CFB2")
    IHardwareDevicesEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [string][out] */ LPWSTR *ppszDeviceID,
            /* [out] */ GUID *pguidDeviceID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHardwareDevicesEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHardwareDevicesEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHardwareDevicesEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHardwareDevicesEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IHardwareDevicesEnum * This,
            /* [string][out] */ LPWSTR *ppszDeviceID,
            /* [out] */ GUID *pguidDeviceID);
        
        END_INTERFACE
    } IHardwareDevicesEnumVtbl;

    interface IHardwareDevicesEnum
    {
        CONST_VTBL struct IHardwareDevicesEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHardwareDevicesEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHardwareDevicesEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHardwareDevicesEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHardwareDevicesEnum_Next(This,ppszDeviceID,pguidDeviceID)	\
    (This)->lpVtbl -> Next(This,ppszDeviceID,pguidDeviceID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHardwareDevicesEnum_Next_Proxy( 
    IHardwareDevicesEnum * This,
    /* [string][out] */ LPWSTR *ppszDeviceID,
    /* [out] */ GUID *pguidDeviceID);


void __RPC_STUB IHardwareDevicesEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHardwareDevicesEnum_INTERFACE_DEFINED__ */


#ifndef __IHardwareDevicesVolumesEnum_INTERFACE_DEFINED__
#define __IHardwareDevicesVolumesEnum_INTERFACE_DEFINED__

/* interface IHardwareDevicesVolumesEnum */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHardwareDevicesVolumesEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3342BDE1-50AF-4c5d-9A19-DABD01848DAE")
    IHardwareDevicesVolumesEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [out] */ VOLUMEINFO *pvolinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHardwareDevicesVolumesEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHardwareDevicesVolumesEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHardwareDevicesVolumesEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHardwareDevicesVolumesEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IHardwareDevicesVolumesEnum * This,
            /* [out] */ VOLUMEINFO *pvolinfo);
        
        END_INTERFACE
    } IHardwareDevicesVolumesEnumVtbl;

    interface IHardwareDevicesVolumesEnum
    {
        CONST_VTBL struct IHardwareDevicesVolumesEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHardwareDevicesVolumesEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHardwareDevicesVolumesEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHardwareDevicesVolumesEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHardwareDevicesVolumesEnum_Next(This,pvolinfo)	\
    (This)->lpVtbl -> Next(This,pvolinfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHardwareDevicesVolumesEnum_Next_Proxy( 
    IHardwareDevicesVolumesEnum * This,
    /* [out] */ VOLUMEINFO *pvolinfo);


void __RPC_STUB IHardwareDevicesVolumesEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHardwareDevicesVolumesEnum_INTERFACE_DEFINED__ */


#ifndef __IHardwareDevicesMountPointsEnum_INTERFACE_DEFINED__
#define __IHardwareDevicesMountPointsEnum_INTERFACE_DEFINED__

/* interface IHardwareDevicesMountPointsEnum */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHardwareDevicesMountPointsEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE93D145-9B4E-480c-8385-1E8119A6F7B2")
    IHardwareDevicesMountPointsEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [string][out] */ LPWSTR *ppszMountPoint,
            /* [string][out] */ LPWSTR *ppszDeviceIDVolume) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHardwareDevicesMountPointsEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHardwareDevicesMountPointsEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHardwareDevicesMountPointsEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHardwareDevicesMountPointsEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IHardwareDevicesMountPointsEnum * This,
            /* [string][out] */ LPWSTR *ppszMountPoint,
            /* [string][out] */ LPWSTR *ppszDeviceIDVolume);
        
        END_INTERFACE
    } IHardwareDevicesMountPointsEnumVtbl;

    interface IHardwareDevicesMountPointsEnum
    {
        CONST_VTBL struct IHardwareDevicesMountPointsEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHardwareDevicesMountPointsEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHardwareDevicesMountPointsEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHardwareDevicesMountPointsEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHardwareDevicesMountPointsEnum_Next(This,ppszMountPoint,ppszDeviceIDVolume)	\
    (This)->lpVtbl -> Next(This,ppszMountPoint,ppszDeviceIDVolume)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHardwareDevicesMountPointsEnum_Next_Proxy( 
    IHardwareDevicesMountPointsEnum * This,
    /* [string][out] */ LPWSTR *ppszMountPoint,
    /* [string][out] */ LPWSTR *ppszDeviceIDVolume);


void __RPC_STUB IHardwareDevicesMountPointsEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHardwareDevicesMountPointsEnum_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0281 */
/* [local] */ 

#define HWDEV_GETCUSTOMPROPERTIES                 0x000000001


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0281_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0281_v0_0_s_ifspec;

#ifndef __IHardwareDevices_INTERFACE_DEFINED__
#define __IHardwareDevices_INTERFACE_DEFINED__

/* interface IHardwareDevices */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHardwareDevices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC271F08-E1DD-49bf-87CC-CD6DCF3F3D9F")
    IHardwareDevices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumVolumes( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IHardwareDevicesVolumesEnum **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMountPoints( 
            /* [out] */ IHardwareDevicesMountPointsEnum **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDevices( 
            /* [out] */ IHardwareDevicesEnum **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ DWORD dwProcessID,
            /* [in] */ ULONG_PTR hThread,
            /* [in] */ ULONG_PTR pfctCallback,
            /* [out] */ DWORD *pdwToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwToken) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHardwareDevicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHardwareDevices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHardwareDevices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHardwareDevices * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumVolumes )( 
            IHardwareDevices * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IHardwareDevicesVolumesEnum **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMountPoints )( 
            IHardwareDevices * This,
            /* [out] */ IHardwareDevicesMountPointsEnum **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDevices )( 
            IHardwareDevices * This,
            /* [out] */ IHardwareDevicesEnum **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IHardwareDevices * This,
            /* [in] */ DWORD dwProcessID,
            /* [in] */ ULONG_PTR hThread,
            /* [in] */ ULONG_PTR pfctCallback,
            /* [out] */ DWORD *pdwToken);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IHardwareDevices * This,
            /* [in] */ DWORD dwToken);
        
        END_INTERFACE
    } IHardwareDevicesVtbl;

    interface IHardwareDevices
    {
        CONST_VTBL struct IHardwareDevicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHardwareDevices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHardwareDevices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHardwareDevices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHardwareDevices_EnumVolumes(This,dwFlags,ppenum)	\
    (This)->lpVtbl -> EnumVolumes(This,dwFlags,ppenum)

#define IHardwareDevices_EnumMountPoints(This,ppenum)	\
    (This)->lpVtbl -> EnumMountPoints(This,ppenum)

#define IHardwareDevices_EnumDevices(This,ppenum)	\
    (This)->lpVtbl -> EnumDevices(This,ppenum)

#define IHardwareDevices_Advise(This,dwProcessID,hThread,pfctCallback,pdwToken)	\
    (This)->lpVtbl -> Advise(This,dwProcessID,hThread,pfctCallback,pdwToken)

#define IHardwareDevices_Unadvise(This,dwToken)	\
    (This)->lpVtbl -> Unadvise(This,dwToken)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHardwareDevices_EnumVolumes_Proxy( 
    IHardwareDevices * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IHardwareDevicesVolumesEnum **ppenum);


void __RPC_STUB IHardwareDevices_EnumVolumes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHardwareDevices_EnumMountPoints_Proxy( 
    IHardwareDevices * This,
    /* [out] */ IHardwareDevicesMountPointsEnum **ppenum);


void __RPC_STUB IHardwareDevices_EnumMountPoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHardwareDevices_EnumDevices_Proxy( 
    IHardwareDevices * This,
    /* [out] */ IHardwareDevicesEnum **ppenum);


void __RPC_STUB IHardwareDevices_EnumDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHardwareDevices_Advise_Proxy( 
    IHardwareDevices * This,
    /* [in] */ DWORD dwProcessID,
    /* [in] */ ULONG_PTR hThread,
    /* [in] */ ULONG_PTR pfctCallback,
    /* [out] */ DWORD *pdwToken);


void __RPC_STUB IHardwareDevices_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHardwareDevices_Unadvise_Proxy( 
    IHardwareDevices * This,
    /* [in] */ DWORD dwToken);


void __RPC_STUB IHardwareDevices_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHardwareDevices_INTERFACE_DEFINED__ */


#ifndef __IStartMenuPin_INTERFACE_DEFINED__
#define __IStartMenuPin_INTERFACE_DEFINED__

/* interface IStartMenuPin */
/* [object][local][uuid] */ 

#define SMPIN_POS(i) (LPCITEMIDLIST)MAKEINTRESOURCE((i)+1)
#define SMPINNABLE_EXEONLY          0x00000001
#define SMPINNABLE_REJECTSLOWMEDIA  0x00000002

EXTERN_C const IID IID_IStartMenuPin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ec35e37a-6579-4f3c-93cd-6e62c4ef7636")
    IStartMenuPin : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumObjects( 
            /* [out] */ IEnumIDList **ppenumIDList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Modify( 
            LPCITEMIDLIST pidlFrom,
            LPCITEMIDLIST pidlTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChangeCount( 
            /* [out] */ ULONG *pulOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsPinnable( 
            /* [in] */ IDataObject *pdto,
            /* [in] */ DWORD dwFlags,
            /* [out][optional] */ LPITEMIDLIST *ppidl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ HWND hwnd,
            DWORD dwFlags,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [out] */ LPITEMIDLIST *ppidlResolved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStartMenuPinVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStartMenuPin * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStartMenuPin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStartMenuPin * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumObjects )( 
            IStartMenuPin * This,
            /* [out] */ IEnumIDList **ppenumIDList);
        
        HRESULT ( STDMETHODCALLTYPE *Modify )( 
            IStartMenuPin * This,
            LPCITEMIDLIST pidlFrom,
            LPCITEMIDLIST pidlTo);
        
        HRESULT ( STDMETHODCALLTYPE *GetChangeCount )( 
            IStartMenuPin * This,
            /* [out] */ ULONG *pulOut);
        
        HRESULT ( STDMETHODCALLTYPE *IsPinnable )( 
            IStartMenuPin * This,
            /* [in] */ IDataObject *pdto,
            /* [in] */ DWORD dwFlags,
            /* [out][optional] */ LPITEMIDLIST *ppidl);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            IStartMenuPin * This,
            /* [in] */ HWND hwnd,
            DWORD dwFlags,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [out] */ LPITEMIDLIST *ppidlResolved);
        
        END_INTERFACE
    } IStartMenuPinVtbl;

    interface IStartMenuPin
    {
        CONST_VTBL struct IStartMenuPinVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStartMenuPin_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStartMenuPin_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStartMenuPin_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStartMenuPin_EnumObjects(This,ppenumIDList)	\
    (This)->lpVtbl -> EnumObjects(This,ppenumIDList)

#define IStartMenuPin_Modify(This,pidlFrom,pidlTo)	\
    (This)->lpVtbl -> Modify(This,pidlFrom,pidlTo)

#define IStartMenuPin_GetChangeCount(This,pulOut)	\
    (This)->lpVtbl -> GetChangeCount(This,pulOut)

#define IStartMenuPin_IsPinnable(This,pdto,dwFlags,ppidl)	\
    (This)->lpVtbl -> IsPinnable(This,pdto,dwFlags,ppidl)

#define IStartMenuPin_Resolve(This,hwnd,dwFlags,pidl,ppidlResolved)	\
    (This)->lpVtbl -> Resolve(This,hwnd,dwFlags,pidl,ppidlResolved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStartMenuPin_EnumObjects_Proxy( 
    IStartMenuPin * This,
    /* [out] */ IEnumIDList **ppenumIDList);


void __RPC_STUB IStartMenuPin_EnumObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStartMenuPin_Modify_Proxy( 
    IStartMenuPin * This,
    LPCITEMIDLIST pidlFrom,
    LPCITEMIDLIST pidlTo);


void __RPC_STUB IStartMenuPin_Modify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStartMenuPin_GetChangeCount_Proxy( 
    IStartMenuPin * This,
    /* [out] */ ULONG *pulOut);


void __RPC_STUB IStartMenuPin_GetChangeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStartMenuPin_IsPinnable_Proxy( 
    IStartMenuPin * This,
    /* [in] */ IDataObject *pdto,
    /* [in] */ DWORD dwFlags,
    /* [out][optional] */ LPITEMIDLIST *ppidl);


void __RPC_STUB IStartMenuPin_IsPinnable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStartMenuPin_Resolve_Proxy( 
    IStartMenuPin * This,
    /* [in] */ HWND hwnd,
    DWORD dwFlags,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [out] */ LPITEMIDLIST *ppidlResolved);


void __RPC_STUB IStartMenuPin_Resolve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStartMenuPin_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0283 */
/* [local] */ 

#if _WIN32_IE >= 0x0600
typedef struct tagCATLIST
    {
    const GUID *pguid;
    const SHCOLUMNID *pscid;
    } 	CATLIST;



extern RPC_IF_HANDLE __MIDL_itf_shpriv_0283_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0283_v0_0_s_ifspec;

#ifndef __IDefCategoryProvider_INTERFACE_DEFINED__
#define __IDefCategoryProvider_INTERFACE_DEFINED__

/* interface IDefCategoryProvider */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IDefCategoryProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("509767BF-AC06-49f8-9E76-8BBC17F0EE93")
    IDefCategoryProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            const GUID *pguid,
            const SHCOLUMNID *pscid,
            const SHCOLUMNID *pscidExclude,
            HKEY hkey,
            const CATLIST *pcl,
            IShellFolder *psf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDefCategoryProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDefCategoryProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDefCategoryProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDefCategoryProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IDefCategoryProvider * This,
            const GUID *pguid,
            const SHCOLUMNID *pscid,
            const SHCOLUMNID *pscidExclude,
            HKEY hkey,
            const CATLIST *pcl,
            IShellFolder *psf);
        
        END_INTERFACE
    } IDefCategoryProviderVtbl;

    interface IDefCategoryProvider
    {
        CONST_VTBL struct IDefCategoryProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDefCategoryProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDefCategoryProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDefCategoryProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDefCategoryProvider_Initialize(This,pguid,pscid,pscidExclude,hkey,pcl,psf)	\
    (This)->lpVtbl -> Initialize(This,pguid,pscid,pscidExclude,hkey,pcl,psf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDefCategoryProvider_Initialize_Proxy( 
    IDefCategoryProvider * This,
    const GUID *pguid,
    const SHCOLUMNID *pscid,
    const SHCOLUMNID *pscidExclude,
    HKEY hkey,
    const CATLIST *pcl,
    IShellFolder *psf);


void __RPC_STUB IDefCategoryProvider_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDefCategoryProvider_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0284 */
/* [local] */ 

#define MB_STATE_TRACK 1
#define MB_STATE_MENU  2
#define MB_STATE_ITEM  4


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0284_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0284_v0_0_s_ifspec;

#ifndef __IInitAccessible_INTERFACE_DEFINED__
#define __IInitAccessible_INTERFACE_DEFINED__

/* interface IInitAccessible */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IInitAccessible;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b6664df7-0c46-460e-ba97-82ed46d0289e")
    IInitAccessible : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitAcc( 
            /* [in] */ int iState,
            /* [in] */ IMenuBand *pmb,
            /* [in] */ int iIndex,
            /* [in] */ HMENU hmenu,
            /* [in] */ WORD wID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitAccessibleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInitAccessible * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInitAccessible * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInitAccessible * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitAcc )( 
            IInitAccessible * This,
            /* [in] */ int iState,
            /* [in] */ IMenuBand *pmb,
            /* [in] */ int iIndex,
            /* [in] */ HMENU hmenu,
            /* [in] */ WORD wID);
        
        END_INTERFACE
    } IInitAccessibleVtbl;

    interface IInitAccessible
    {
        CONST_VTBL struct IInitAccessibleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitAccessible_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInitAccessible_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInitAccessible_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInitAccessible_InitAcc(This,iState,pmb,iIndex,hmenu,wID)	\
    (This)->lpVtbl -> InitAcc(This,iState,pmb,iIndex,hmenu,wID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInitAccessible_InitAcc_Proxy( 
    IInitAccessible * This,
    /* [in] */ int iState,
    /* [in] */ IMenuBand *pmb,
    /* [in] */ int iIndex,
    /* [in] */ HMENU hmenu,
    /* [in] */ WORD wID);


void __RPC_STUB IInitAccessible_InitAcc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInitAccessible_INTERFACE_DEFINED__ */


#ifndef __IInitTrackPopupBar_INTERFACE_DEFINED__
#define __IInitTrackPopupBar_INTERFACE_DEFINED__

/* interface IInitTrackPopupBar */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IInitTrackPopupBar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a7efa30-795c-4167-8676-b78fc5330cc7")
    IInitTrackPopupBar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitTrackPopupBar( 
            /* [in] */ void *pvContext,
            /* [in] */ int iID,
            /* [in] */ HMENU hmenu,
            /* [in] */ HWND hwnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInitTrackPopupBarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInitTrackPopupBar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInitTrackPopupBar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInitTrackPopupBar * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitTrackPopupBar )( 
            IInitTrackPopupBar * This,
            /* [in] */ void *pvContext,
            /* [in] */ int iID,
            /* [in] */ HMENU hmenu,
            /* [in] */ HWND hwnd);
        
        END_INTERFACE
    } IInitTrackPopupBarVtbl;

    interface IInitTrackPopupBar
    {
        CONST_VTBL struct IInitTrackPopupBarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInitTrackPopupBar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInitTrackPopupBar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInitTrackPopupBar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInitTrackPopupBar_InitTrackPopupBar(This,pvContext,iID,hmenu,hwnd)	\
    (This)->lpVtbl -> InitTrackPopupBar(This,pvContext,iID,hmenu,hwnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInitTrackPopupBar_InitTrackPopupBar_Proxy( 
    IInitTrackPopupBar * This,
    /* [in] */ void *pvContext,
    /* [in] */ int iID,
    /* [in] */ HMENU hmenu,
    /* [in] */ HWND hwnd);


void __RPC_STUB IInitTrackPopupBar_InitTrackPopupBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInitTrackPopupBar_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0286 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum _CFITYPE
    {	CFITYPE_CSIDL	= 0,
	CFITYPE_PIDL	= CFITYPE_CSIDL + 1,
	CFITYPE_PATH	= CFITYPE_PIDL + 1
    } 	CFITYPE;

/* [v1_enum] */ 
enum __MIDL___MIDL_itf_shpriv_0286_0001
    {	CFINITF_CHILDREN	= 0,
	CFINITF_FLAT	= 0x1
    } ;
typedef UINT CFINITF;

typedef struct _COMPFOLDERINIT
    {
    UINT uType;
    /* [switch_is][switch_type] */ union 
        {
        /* [case()] */ int csidl;
        /* [case()] */ LPCITEMIDLIST pidl;
        /* [case()][string] */ LPOLESTR pszPath;
        } 	DUMMYUNIONNAME;
    LPOLESTR pszName;
    } 	COMPFOLDERINIT;



extern RPC_IF_HANDLE __MIDL_itf_shpriv_0286_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0286_v0_0_s_ifspec;

#ifndef __ICompositeFolder_INTERFACE_DEFINED__
#define __ICompositeFolder_INTERFACE_DEFINED__

/* interface ICompositeFolder */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_ICompositeFolder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("601ac3dd-786a-4eb0-bf40-ee3521e70bfb")
    ICompositeFolder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitComposite( 
            /* [in] */ WORD wSignature,
            /* [in] */ REFCLSID refclsid,
            /* [in] */ CFINITF flags,
            /* [in] */ ULONG celt,
            /* [size_is][in] */ const COMPFOLDERINIT *rgCFs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToParent( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv,
            /* [out] */ LPITEMIDLIST *ppidlLast) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICompositeFolderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICompositeFolder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICompositeFolder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICompositeFolder * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitComposite )( 
            ICompositeFolder * This,
            /* [in] */ WORD wSignature,
            /* [in] */ REFCLSID refclsid,
            /* [in] */ CFINITF flags,
            /* [in] */ ULONG celt,
            /* [size_is][in] */ const COMPFOLDERINIT *rgCFs);
        
        HRESULT ( STDMETHODCALLTYPE *BindToParent )( 
            ICompositeFolder * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv,
            /* [out] */ LPITEMIDLIST *ppidlLast);
        
        END_INTERFACE
    } ICompositeFolderVtbl;

    interface ICompositeFolder
    {
        CONST_VTBL struct ICompositeFolderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICompositeFolder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICompositeFolder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICompositeFolder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICompositeFolder_InitComposite(This,wSignature,refclsid,flags,celt,rgCFs)	\
    (This)->lpVtbl -> InitComposite(This,wSignature,refclsid,flags,celt,rgCFs)

#define ICompositeFolder_BindToParent(This,pidl,riid,ppv,ppidlLast)	\
    (This)->lpVtbl -> BindToParent(This,pidl,riid,ppv,ppidlLast)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICompositeFolder_InitComposite_Proxy( 
    ICompositeFolder * This,
    /* [in] */ WORD wSignature,
    /* [in] */ REFCLSID refclsid,
    /* [in] */ CFINITF flags,
    /* [in] */ ULONG celt,
    /* [size_is][in] */ const COMPFOLDERINIT *rgCFs);


void __RPC_STUB ICompositeFolder_InitComposite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICompositeFolder_BindToParent_Proxy( 
    ICompositeFolder * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv,
    /* [out] */ LPITEMIDLIST *ppidlLast);


void __RPC_STUB ICompositeFolder_BindToParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICompositeFolder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0287 */
/* [local] */ 

#endif // _WIN32_IE >= 0x0600
#include <pshpack8.h>
typedef struct _tagSHELLREMINDER
    {
    DWORD cbSize;
    LPWSTR pszName;
    LPWSTR pszTitle;
    LPWSTR pszText;
    LPWSTR pszTooltip;
    LPWSTR pszIconResource;
    LPWSTR pszShellExecute;
    GUID *pclsid;
    DWORD dwShowTime;
    DWORD dwRetryInterval;
    DWORD dwRetryCount;
    DWORD dwTypeFlags;
    } 	SHELLREMINDER;

#include <poppack.h>


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0287_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0287_v0_0_s_ifspec;

#ifndef __IEnumShellReminder_INTERFACE_DEFINED__
#define __IEnumShellReminder_INTERFACE_DEFINED__

/* interface IEnumShellReminder */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IEnumShellReminder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6c6d9735-2d86-40e1-b348-08706b9908c0")
    IEnumShellReminder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ SHELLREMINDER **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumShellReminder **ppesr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumShellReminderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumShellReminder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumShellReminder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumShellReminder * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumShellReminder * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ SHELLREMINDER **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumShellReminder * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumShellReminder * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumShellReminder * This,
            /* [out] */ IEnumShellReminder **ppesr);
        
        END_INTERFACE
    } IEnumShellReminderVtbl;

    interface IEnumShellReminder
    {
        CONST_VTBL struct IEnumShellReminderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumShellReminder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumShellReminder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumShellReminder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumShellReminder_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumShellReminder_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumShellReminder_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumShellReminder_Clone(This,ppesr)	\
    (This)->lpVtbl -> Clone(This,ppesr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumShellReminder_Next_Proxy( 
    IEnumShellReminder * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ SHELLREMINDER **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumShellReminder_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumShellReminder_Skip_Proxy( 
    IEnumShellReminder * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumShellReminder_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumShellReminder_Reset_Proxy( 
    IEnumShellReminder * This);


void __RPC_STUB IEnumShellReminder_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumShellReminder_Clone_Proxy( 
    IEnumShellReminder * This,
    /* [out] */ IEnumShellReminder **ppesr);


void __RPC_STUB IEnumShellReminder_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumShellReminder_INTERFACE_DEFINED__ */


#ifndef __IShellReminderManager_INTERFACE_DEFINED__
#define __IShellReminderManager_INTERFACE_DEFINED__

/* interface IShellReminderManager */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IShellReminderManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("968edb91-8a70-4930-8332-5f15838a64f9")
    IShellReminderManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Add( 
            const SHELLREMINDER *psr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            LPCWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enum( 
            IEnumShellReminder **ppesr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellReminderManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellReminderManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellReminderManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellReminderManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IShellReminderManager * This,
            const SHELLREMINDER *psr);
        
        HRESULT ( STDMETHODCALLTYPE *Delete )( 
            IShellReminderManager * This,
            LPCWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE *Enum )( 
            IShellReminderManager * This,
            IEnumShellReminder **ppesr);
        
        END_INTERFACE
    } IShellReminderManagerVtbl;

    interface IShellReminderManager
    {
        CONST_VTBL struct IShellReminderManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellReminderManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellReminderManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellReminderManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellReminderManager_Add(This,psr)	\
    (This)->lpVtbl -> Add(This,psr)

#define IShellReminderManager_Delete(This,pszName)	\
    (This)->lpVtbl -> Delete(This,pszName)

#define IShellReminderManager_Enum(This,ppesr)	\
    (This)->lpVtbl -> Enum(This,ppesr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellReminderManager_Add_Proxy( 
    IShellReminderManager * This,
    const SHELLREMINDER *psr);


void __RPC_STUB IShellReminderManager_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellReminderManager_Delete_Proxy( 
    IShellReminderManager * This,
    LPCWSTR pszName);


void __RPC_STUB IShellReminderManager_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellReminderManager_Enum_Proxy( 
    IShellReminderManager * This,
    IEnumShellReminder **ppesr);


void __RPC_STUB IShellReminderManager_Enum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellReminderManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0289 */
/* [local] */ 

#if _WIN32_IE >= 0x0400


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0289_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0289_v0_0_s_ifspec;

#ifndef __IDeskBandEx_INTERFACE_DEFINED__
#define __IDeskBandEx_INTERFACE_DEFINED__

/* interface IDeskBandEx */
/* [uuid][object] */ 


EXTERN_C const IID IID_IDeskBandEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5dd6b79a-3ab7-49c0-ab82-6b2da7d78d75")
    IDeskBandEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE MoveBand( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeskBandExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeskBandEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeskBandEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeskBandEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *MoveBand )( 
            IDeskBandEx * This);
        
        END_INTERFACE
    } IDeskBandExVtbl;

    interface IDeskBandEx
    {
        CONST_VTBL struct IDeskBandExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeskBandEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDeskBandEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDeskBandEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDeskBandEx_MoveBand(This)	\
    (This)->lpVtbl -> MoveBand(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDeskBandEx_MoveBand_Proxy( 
    IDeskBandEx * This);


void __RPC_STUB IDeskBandEx_MoveBand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDeskBandEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0290 */
/* [local] */ 

#endif // _WIN32_IE >= 0x0400
#include <pshpack8.h>
typedef struct tagNOTIFYITEM
    {
    LPWSTR pszExeName;
    LPWSTR pszIconText;
    HICON hIcon;
    HWND hWnd;
    DWORD dwUserPref;
    UINT uID;
    GUID guidItem;
    } 	NOTIFYITEM;

typedef struct tagNOTIFYITEM *LPNOTIFYITEM;

#include <poppack.h>


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0290_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0290_v0_0_s_ifspec;

#ifndef __INotificationCB_INTERFACE_DEFINED__
#define __INotificationCB_INTERFACE_DEFINED__

/* interface INotificationCB */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INotificationCB;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d782ccba-afb0-43f1-94db-fda3779eaccb")
    INotificationCB : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ DWORD dwMessage,
            /* [in] */ LPNOTIFYITEM pNotifyItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INotificationCBVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INotificationCB * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INotificationCB * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INotificationCB * This);
        
        HRESULT ( STDMETHODCALLTYPE *Notify )( 
            INotificationCB * This,
            /* [in] */ DWORD dwMessage,
            /* [in] */ LPNOTIFYITEM pNotifyItem);
        
        END_INTERFACE
    } INotificationCBVtbl;

    interface INotificationCB
    {
        CONST_VTBL struct INotificationCBVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INotificationCB_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INotificationCB_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INotificationCB_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INotificationCB_Notify(This,dwMessage,pNotifyItem)	\
    (This)->lpVtbl -> Notify(This,dwMessage,pNotifyItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INotificationCB_Notify_Proxy( 
    INotificationCB * This,
    /* [in] */ DWORD dwMessage,
    /* [in] */ LPNOTIFYITEM pNotifyItem);


void __RPC_STUB INotificationCB_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INotificationCB_INTERFACE_DEFINED__ */


#ifndef __ITrayNotify_INTERFACE_DEFINED__
#define __ITrayNotify_INTERFACE_DEFINED__

/* interface ITrayNotify */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITrayNotify;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fb852b2c-6bad-4605-9551-f15f87830935")
    ITrayNotify : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCallback( 
            /* [in] */ INotificationCB *pNotifyCB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPreference( 
            /* [in] */ LPNOTIFYITEM pNotifyItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableAutoTray( 
            /* [in] */ BOOL bTraySetting) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITrayNotifyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITrayNotify * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITrayNotify * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITrayNotify * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterCallback )( 
            ITrayNotify * This,
            /* [in] */ INotificationCB *pNotifyCB);
        
        HRESULT ( STDMETHODCALLTYPE *SetPreference )( 
            ITrayNotify * This,
            /* [in] */ LPNOTIFYITEM pNotifyItem);
        
        HRESULT ( STDMETHODCALLTYPE *EnableAutoTray )( 
            ITrayNotify * This,
            /* [in] */ BOOL bTraySetting);
        
        END_INTERFACE
    } ITrayNotifyVtbl;

    interface ITrayNotify
    {
        CONST_VTBL struct ITrayNotifyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITrayNotify_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITrayNotify_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITrayNotify_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITrayNotify_RegisterCallback(This,pNotifyCB)	\
    (This)->lpVtbl -> RegisterCallback(This,pNotifyCB)

#define ITrayNotify_SetPreference(This,pNotifyItem)	\
    (This)->lpVtbl -> SetPreference(This,pNotifyItem)

#define ITrayNotify_EnableAutoTray(This,bTraySetting)	\
    (This)->lpVtbl -> EnableAutoTray(This,bTraySetting)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITrayNotify_RegisterCallback_Proxy( 
    ITrayNotify * This,
    /* [in] */ INotificationCB *pNotifyCB);


void __RPC_STUB ITrayNotify_RegisterCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITrayNotify_SetPreference_Proxy( 
    ITrayNotify * This,
    /* [in] */ LPNOTIFYITEM pNotifyItem);


void __RPC_STUB ITrayNotify_SetPreference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITrayNotify_EnableAutoTray_Proxy( 
    ITrayNotify * This,
    /* [in] */ BOOL bTraySetting);


void __RPC_STUB ITrayNotify_EnableAutoTray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITrayNotify_INTERFACE_DEFINED__ */


#ifndef __IMagic_INTERFACE_DEFINED__
#define __IMagic_INTERFACE_DEFINED__

/* interface IMagic */
/* [object][local][uuid] */ 


enum __MIDL_IMagic_0001
    {	MAGIC_ALIGN_BOTTOMLEFT	= 0x1,
	MAGIC_ALIGN_BOTTOMRIGHT	= 0x2,
	MAGIC_ALIGN_TOPLEFT	= 0x3,
	MAGIC_ALIGN_TOPRIGHT	= 0x4,
	MAGIC_ALIGN_CENTER	= 0x5
    } ;
typedef DWORD MAGIC_ALIGN;


EXTERN_C const IID IID_IMagic;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3037B6E1-0B58-4c34-AA63-A958D2A4413D")
    IMagic : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Illusion( 
            HMODULE hmod,
            UINT uId,
            UINT cFrames,
            UINT interval,
            MAGIC_ALIGN align,
            RECT rc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BlinkFrom( 
            HDC hdcFrom,
            RECT *rc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BlinkMove( 
            RECT *rc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BlinkTo( 
            HDC hdcTo,
            UINT cFrames) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMagicVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMagic * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMagic * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMagic * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Illusion )( 
            IMagic * This,
            HMODULE hmod,
            UINT uId,
            UINT cFrames,
            UINT interval,
            MAGIC_ALIGN align,
            RECT rc);
        
        HRESULT ( STDMETHODCALLTYPE *BlinkFrom )( 
            IMagic * This,
            HDC hdcFrom,
            RECT *rc);
        
        HRESULT ( STDMETHODCALLTYPE *BlinkMove )( 
            IMagic * This,
            RECT *rc);
        
        HRESULT ( STDMETHODCALLTYPE *BlinkTo )( 
            IMagic * This,
            HDC hdcTo,
            UINT cFrames);
        
        END_INTERFACE
    } IMagicVtbl;

    interface IMagic
    {
        CONST_VTBL struct IMagicVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMagic_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMagic_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMagic_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMagic_Illusion(This,hmod,uId,cFrames,interval,align,rc)	\
    (This)->lpVtbl -> Illusion(This,hmod,uId,cFrames,interval,align,rc)

#define IMagic_BlinkFrom(This,hdcFrom,rc)	\
    (This)->lpVtbl -> BlinkFrom(This,hdcFrom,rc)

#define IMagic_BlinkMove(This,rc)	\
    (This)->lpVtbl -> BlinkMove(This,rc)

#define IMagic_BlinkTo(This,hdcTo,cFrames)	\
    (This)->lpVtbl -> BlinkTo(This,hdcTo,cFrames)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IMagic_Illusion_Proxy( 
    IMagic * This,
    HMODULE hmod,
    UINT uId,
    UINT cFrames,
    UINT interval,
    MAGIC_ALIGN align,
    RECT rc);


void __RPC_STUB IMagic_Illusion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMagic_BlinkFrom_Proxy( 
    IMagic * This,
    HDC hdcFrom,
    RECT *rc);


void __RPC_STUB IMagic_BlinkFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMagic_BlinkMove_Proxy( 
    IMagic * This,
    RECT *rc);


void __RPC_STUB IMagic_BlinkMove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMagic_BlinkTo_Proxy( 
    IMagic * This,
    HDC hdcTo,
    UINT cFrames);


void __RPC_STUB IMagic_BlinkTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMagic_INTERFACE_DEFINED__ */


#ifndef __IResourceMap_INTERFACE_DEFINED__
#define __IResourceMap_INTERFACE_DEFINED__

/* interface IResourceMap */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IResourceMap;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9c50a798-5d90-4130-83da-38da83456711")
    IResourceMap : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE LoadResourceMap( 
            /* [string][in] */ LPCWSTR pszResourceClass,
            /* [string][in] */ LPCWSTR pszID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectResourceScope( 
            /* [string][in] */ LPCWSTR pszResourceType,
            /* [string][in] */ LPCWSTR pszID,
            /* [out][in] */ IXMLDOMNode **ppdnScope) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadString( 
            /* [in] */ IXMLDOMNode *pdnScope,
            /* [string][in] */ LPCWSTR pszID,
            /* [out][in] */ LPWSTR pszBuffer,
            /* [in] */ int cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadBitmap( 
            /* [in] */ IXMLDOMNode *pdnScope,
            /* [string][in] */ LPCWSTR pszID,
            /* [out][in] */ HBITMAP *pbm) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResourceMapVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IResourceMap * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IResourceMap * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IResourceMap * This);
        
        HRESULT ( STDMETHODCALLTYPE *LoadResourceMap )( 
            IResourceMap * This,
            /* [string][in] */ LPCWSTR pszResourceClass,
            /* [string][in] */ LPCWSTR pszID);
        
        HRESULT ( STDMETHODCALLTYPE *SelectResourceScope )( 
            IResourceMap * This,
            /* [string][in] */ LPCWSTR pszResourceType,
            /* [string][in] */ LPCWSTR pszID,
            /* [out][in] */ IXMLDOMNode **ppdnScope);
        
        HRESULT ( STDMETHODCALLTYPE *LoadString )( 
            IResourceMap * This,
            /* [in] */ IXMLDOMNode *pdnScope,
            /* [string][in] */ LPCWSTR pszID,
            /* [out][in] */ LPWSTR pszBuffer,
            /* [in] */ int cch);
        
        HRESULT ( STDMETHODCALLTYPE *LoadBitmap )( 
            IResourceMap * This,
            /* [in] */ IXMLDOMNode *pdnScope,
            /* [string][in] */ LPCWSTR pszID,
            /* [out][in] */ HBITMAP *pbm);
        
        END_INTERFACE
    } IResourceMapVtbl;

    interface IResourceMap
    {
        CONST_VTBL struct IResourceMapVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResourceMap_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResourceMap_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResourceMap_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResourceMap_LoadResourceMap(This,pszResourceClass,pszID)	\
    (This)->lpVtbl -> LoadResourceMap(This,pszResourceClass,pszID)

#define IResourceMap_SelectResourceScope(This,pszResourceType,pszID,ppdnScope)	\
    (This)->lpVtbl -> SelectResourceScope(This,pszResourceType,pszID,ppdnScope)

#define IResourceMap_LoadString(This,pdnScope,pszID,pszBuffer,cch)	\
    (This)->lpVtbl -> LoadString(This,pdnScope,pszID,pszBuffer,cch)

#define IResourceMap_LoadBitmap(This,pdnScope,pszID,pbm)	\
    (This)->lpVtbl -> LoadBitmap(This,pdnScope,pszID,pbm)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IResourceMap_LoadResourceMap_Proxy( 
    IResourceMap * This,
    /* [string][in] */ LPCWSTR pszResourceClass,
    /* [string][in] */ LPCWSTR pszID);


void __RPC_STUB IResourceMap_LoadResourceMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResourceMap_SelectResourceScope_Proxy( 
    IResourceMap * This,
    /* [string][in] */ LPCWSTR pszResourceType,
    /* [string][in] */ LPCWSTR pszID,
    /* [out][in] */ IXMLDOMNode **ppdnScope);


void __RPC_STUB IResourceMap_SelectResourceScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResourceMap_LoadString_Proxy( 
    IResourceMap * This,
    /* [in] */ IXMLDOMNode *pdnScope,
    /* [string][in] */ LPCWSTR pszID,
    /* [out][in] */ LPWSTR pszBuffer,
    /* [in] */ int cch);


void __RPC_STUB IResourceMap_LoadString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IResourceMap_LoadBitmap_Proxy( 
    IResourceMap * This,
    /* [in] */ IXMLDOMNode *pdnScope,
    /* [string][in] */ LPCWSTR pszID,
    /* [out][in] */ HBITMAP *pbm);


void __RPC_STUB IResourceMap_LoadBitmap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResourceMap_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0294 */
/* [local] */ 

#define SID_ResourceMap IID_IResourceMap
#define HNET_SHARECONNECTION     0x00000001
#define HNET_FIREWALLCONNECTION  0x00000002
#define HNET_SHAREPRINTERS       0x00000004
#define HNET_SETCOMPUTERNAME     0x00000008
#define HNET_SETWORKGROUPNAME    0x00000010
#define HNET_SHAREFOLDERS        0x00000020
#define HNET_BRIDGEPRIVATE       0x00000040
#define HNET_ICSCLIENT           0x00000080      // Only on W9x
#define HNET_LOG                 0x80000000      // Output results to a log file before configuring homenet (TODO)


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0294_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0294_v0_0_s_ifspec;

#ifndef __IHomeNetworkWizard_INTERFACE_DEFINED__
#define __IHomeNetworkWizard_INTERFACE_DEFINED__

/* interface IHomeNetworkWizard */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IHomeNetworkWizard;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("543c4fa4-52dd-421a-947a-4d7f92b8860a")
    IHomeNetworkWizard : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ConfigureSilently( 
            LPCWSTR pszPublicConnection,
            DWORD hnetFlags,
            BOOL *pfRebootRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowWizard( 
            HWND hwndParent,
            BOOL *pfRebootRequired) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHomeNetworkWizardVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHomeNetworkWizard * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHomeNetworkWizard * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHomeNetworkWizard * This);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureSilently )( 
            IHomeNetworkWizard * This,
            LPCWSTR pszPublicConnection,
            DWORD hnetFlags,
            BOOL *pfRebootRequired);
        
        HRESULT ( STDMETHODCALLTYPE *ShowWizard )( 
            IHomeNetworkWizard * This,
            HWND hwndParent,
            BOOL *pfRebootRequired);
        
        END_INTERFACE
    } IHomeNetworkWizardVtbl;

    interface IHomeNetworkWizard
    {
        CONST_VTBL struct IHomeNetworkWizardVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHomeNetworkWizard_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHomeNetworkWizard_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHomeNetworkWizard_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHomeNetworkWizard_ConfigureSilently(This,pszPublicConnection,hnetFlags,pfRebootRequired)	\
    (This)->lpVtbl -> ConfigureSilently(This,pszPublicConnection,hnetFlags,pfRebootRequired)

#define IHomeNetworkWizard_ShowWizard(This,hwndParent,pfRebootRequired)	\
    (This)->lpVtbl -> ShowWizard(This,hwndParent,pfRebootRequired)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHomeNetworkWizard_ConfigureSilently_Proxy( 
    IHomeNetworkWizard * This,
    LPCWSTR pszPublicConnection,
    DWORD hnetFlags,
    BOOL *pfRebootRequired);


void __RPC_STUB IHomeNetworkWizard_ConfigureSilently_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHomeNetworkWizard_ShowWizard_Proxy( 
    IHomeNetworkWizard * This,
    HWND hwndParent,
    BOOL *pfRebootRequired);


void __RPC_STUB IHomeNetworkWizard_ShowWizard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHomeNetworkWizard_INTERFACE_DEFINED__ */


#ifndef __IEnumShellItems_INTERFACE_DEFINED__
#define __IEnumShellItems_INTERFACE_DEFINED__

/* interface IEnumShellItems */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IEnumShellItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70629033-e363-4a28-a567-0db78006e6d7")
    IEnumShellItems : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IShellItem **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumShellItems **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumShellItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumShellItems * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumShellItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumShellItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumShellItems * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IShellItem **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumShellItems * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumShellItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumShellItems * This,
            /* [out] */ IEnumShellItems **ppenum);
        
        END_INTERFACE
    } IEnumShellItemsVtbl;

    interface IEnumShellItems
    {
        CONST_VTBL struct IEnumShellItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumShellItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumShellItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumShellItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumShellItems_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumShellItems_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumShellItems_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumShellItems_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumShellItems_Next_Proxy( 
    IEnumShellItems * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IShellItem **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumShellItems_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumShellItems_Skip_Proxy( 
    IEnumShellItems * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumShellItems_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumShellItems_Reset_Proxy( 
    IEnumShellItems * This);


void __RPC_STUB IEnumShellItems_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumShellItems_Clone_Proxy( 
    IEnumShellItems * This,
    /* [out] */ IEnumShellItems **ppenum);


void __RPC_STUB IEnumShellItems_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumShellItems_INTERFACE_DEFINED__ */


#ifndef __IParentAndItem_INTERFACE_DEFINED__
#define __IParentAndItem_INTERFACE_DEFINED__

/* interface IParentAndItem */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IParentAndItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b3a4b685-b685-4805-99d9-5dead2873236")
    IParentAndItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetParentAndItem( 
            /* [in] */ LPCITEMIDLIST pidlParent,
            /* [in] */ IShellFolder *psf,
            /* [in] */ LPCITEMIDLIST pidlChild) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParentAndItem( 
            /* [out] */ LPITEMIDLIST *ppidlParent,
            /* [out] */ IShellFolder **ppsf,
            /* [out] */ LPITEMIDLIST *ppidlChild) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IParentAndItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IParentAndItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IParentAndItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IParentAndItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetParentAndItem )( 
            IParentAndItem * This,
            /* [in] */ LPCITEMIDLIST pidlParent,
            /* [in] */ IShellFolder *psf,
            /* [in] */ LPCITEMIDLIST pidlChild);
        
        HRESULT ( STDMETHODCALLTYPE *GetParentAndItem )( 
            IParentAndItem * This,
            /* [out] */ LPITEMIDLIST *ppidlParent,
            /* [out] */ IShellFolder **ppsf,
            /* [out] */ LPITEMIDLIST *ppidlChild);
        
        END_INTERFACE
    } IParentAndItemVtbl;

    interface IParentAndItem
    {
        CONST_VTBL struct IParentAndItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IParentAndItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IParentAndItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IParentAndItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IParentAndItem_SetParentAndItem(This,pidlParent,psf,pidlChild)	\
    (This)->lpVtbl -> SetParentAndItem(This,pidlParent,psf,pidlChild)

#define IParentAndItem_GetParentAndItem(This,ppidlParent,ppsf,ppidlChild)	\
    (This)->lpVtbl -> GetParentAndItem(This,ppidlParent,ppsf,ppidlChild)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IParentAndItem_SetParentAndItem_Proxy( 
    IParentAndItem * This,
    /* [in] */ LPCITEMIDLIST pidlParent,
    /* [in] */ IShellFolder *psf,
    /* [in] */ LPCITEMIDLIST pidlChild);


void __RPC_STUB IParentAndItem_SetParentAndItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IParentAndItem_GetParentAndItem_Proxy( 
    IParentAndItem * This,
    /* [out] */ LPITEMIDLIST *ppidlParent,
    /* [out] */ IShellFolder **ppsf,
    /* [out] */ LPITEMIDLIST *ppidlChild);


void __RPC_STUB IParentAndItem_GetParentAndItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IParentAndItem_INTERFACE_DEFINED__ */


#ifndef __IShellItemArray_INTERFACE_DEFINED__
#define __IShellItemArray_INTERFACE_DEFINED__

/* interface IShellItemArray */
/* [unique][object][uuid][helpstring] */ 

typedef /* [public][public][v1_enum] */ 
enum __MIDL_IShellItemArray_0001
    {	SIATTRIBFLAGS_AND	= 0x1,
	SIATTRIBFLAGS_OR	= 0x2,
	SIATTRIBFLAGS_APPCOMPAT	= 0x3,
	SIATTRIBFLAGS_MASK	= 0x3
    } 	SIATTRIBFLAGS;


EXTERN_C const IID IID_IShellItemArray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("787F8E92-9837-4011-9F83-7DE593BDC002")
    IShellItemArray : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BindToHandler( 
            /* [in] */ IBindCtx *pbc,
            /* [in] */ REFGUID rbhid,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [in] */ SIATTRIBFLAGS dwAttribFlags,
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ SFGAOF *psfgaoAttribs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ DWORD *pdwNumItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItemAt( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumItems( 
            /* [out] */ IEnumShellItems **ppenumShellItems) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellItemArrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellItemArray * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellItemArray * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellItemArray * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindToHandler )( 
            IShellItemArray * This,
            /* [in] */ IBindCtx *pbc,
            /* [in] */ REFGUID rbhid,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            IShellItemArray * This,
            /* [in] */ SIATTRIBFLAGS dwAttribFlags,
            /* [in] */ SFGAOF sfgaoMask,
            /* [out] */ SFGAOF *psfgaoAttribs);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            IShellItemArray * This,
            /* [out] */ DWORD *pdwNumItems);
        
        HRESULT ( STDMETHODCALLTYPE *GetItemAt )( 
            IShellItemArray * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *EnumItems )( 
            IShellItemArray * This,
            /* [out] */ IEnumShellItems **ppenumShellItems);
        
        END_INTERFACE
    } IShellItemArrayVtbl;

    interface IShellItemArray
    {
        CONST_VTBL struct IShellItemArrayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellItemArray_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellItemArray_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellItemArray_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellItemArray_BindToHandler(This,pbc,rbhid,riid,ppvOut)	\
    (This)->lpVtbl -> BindToHandler(This,pbc,rbhid,riid,ppvOut)

#define IShellItemArray_GetAttributes(This,dwAttribFlags,sfgaoMask,psfgaoAttribs)	\
    (This)->lpVtbl -> GetAttributes(This,dwAttribFlags,sfgaoMask,psfgaoAttribs)

#define IShellItemArray_GetCount(This,pdwNumItems)	\
    (This)->lpVtbl -> GetCount(This,pdwNumItems)

#define IShellItemArray_GetItemAt(This,dwIndex,ppsi)	\
    (This)->lpVtbl -> GetItemAt(This,dwIndex,ppsi)

#define IShellItemArray_EnumItems(This,ppenumShellItems)	\
    (This)->lpVtbl -> EnumItems(This,ppenumShellItems)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellItemArray_BindToHandler_Proxy( 
    IShellItemArray * This,
    /* [in] */ IBindCtx *pbc,
    /* [in] */ REFGUID rbhid,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvOut);


void __RPC_STUB IShellItemArray_BindToHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellItemArray_GetAttributes_Proxy( 
    IShellItemArray * This,
    /* [in] */ SIATTRIBFLAGS dwAttribFlags,
    /* [in] */ SFGAOF sfgaoMask,
    /* [out] */ SFGAOF *psfgaoAttribs);


void __RPC_STUB IShellItemArray_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellItemArray_GetCount_Proxy( 
    IShellItemArray * This,
    /* [out] */ DWORD *pdwNumItems);


void __RPC_STUB IShellItemArray_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellItemArray_GetItemAt_Proxy( 
    IShellItemArray * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ IShellItem **ppsi);


void __RPC_STUB IShellItemArray_GetItemAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellItemArray_EnumItems_Proxy( 
    IShellItemArray * This,
    /* [out] */ IEnumShellItems **ppenumShellItems);


void __RPC_STUB IShellItemArray_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellItemArray_INTERFACE_DEFINED__ */


#ifndef __IItemHandler_INTERFACE_DEFINED__
#define __IItemHandler_INTERFACE_DEFINED__

/* interface IItemHandler */
/* [object][uuid] */ 


EXTERN_C const IID IID_IItemHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("198a5f2d-e19f-49ea-9033-c975e0f376ec")
    IItemHandler : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetItem( 
            IShellItem *psi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetItem( 
            IShellItem **ppsi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IItemHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IItemHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IItemHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IItemHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IItemHandler * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *SetItem )( 
            IItemHandler * This,
            IShellItem *psi);
        
        HRESULT ( STDMETHODCALLTYPE *GetItem )( 
            IItemHandler * This,
            IShellItem **ppsi);
        
        END_INTERFACE
    } IItemHandlerVtbl;

    interface IItemHandler
    {
        CONST_VTBL struct IItemHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IItemHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IItemHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IItemHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IItemHandler_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IItemHandler_SetItem(This,psi)	\
    (This)->lpVtbl -> SetItem(This,psi)

#define IItemHandler_GetItem(This,ppsi)	\
    (This)->lpVtbl -> GetItem(This,ppsi)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IItemHandler_SetItem_Proxy( 
    IItemHandler * This,
    IShellItem *psi);


void __RPC_STUB IItemHandler_SetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IItemHandler_GetItem_Proxy( 
    IItemHandler * This,
    IShellItem **ppsi);


void __RPC_STUB IItemHandler_GetItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IItemHandler_INTERFACE_DEFINED__ */


#ifndef __IShellFolderNames_INTERFACE_DEFINED__
#define __IShellFolderNames_INTERFACE_DEFINED__

/* interface IShellFolderNames */
/* [unique][object][uuid][helpstring] */ 

/* [v1_enum] */ 
enum __MIDL_IShellFolderNames_0001
    {	SIPDNF_FROMEDITING	= 0x1
    } ;
typedef UINT SIPDNF;


EXTERN_C const IID IID_IShellFolderNames;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6cd8f9cc-dfe7-48f2-a60a-3831e26af734")
    IShellFolderNames : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseIncremental( 
            /* [in] */ SIPDNF flags,
            /* [string][in] */ LPCOLESTR pszName,
            /* [in] */ IBindCtx *pbc,
            /* [out] */ LPITEMIDLIST *ppidl,
            /* [out] */ UINT *pcchNext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ SIGDN sigdnName,
            /* [string][out] */ LPOLESTR *ppszName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellFolderNamesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellFolderNames * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellFolderNames * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellFolderNames * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseIncremental )( 
            IShellFolderNames * This,
            /* [in] */ SIPDNF flags,
            /* [string][in] */ LPCOLESTR pszName,
            /* [in] */ IBindCtx *pbc,
            /* [out] */ LPITEMIDLIST *ppidl,
            /* [out] */ UINT *pcchNext);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IShellFolderNames * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ SIGDN sigdnName,
            /* [string][out] */ LPOLESTR *ppszName);
        
        END_INTERFACE
    } IShellFolderNamesVtbl;

    interface IShellFolderNames
    {
        CONST_VTBL struct IShellFolderNamesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellFolderNames_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellFolderNames_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellFolderNames_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellFolderNames_ParseIncremental(This,flags,pszName,pbc,ppidl,pcchNext)	\
    (This)->lpVtbl -> ParseIncremental(This,flags,pszName,pbc,ppidl,pcchNext)

#define IShellFolderNames_GetDisplayName(This,pidl,sigdnName,ppszName)	\
    (This)->lpVtbl -> GetDisplayName(This,pidl,sigdnName,ppszName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellFolderNames_ParseIncremental_Proxy( 
    IShellFolderNames * This,
    /* [in] */ SIPDNF flags,
    /* [string][in] */ LPCOLESTR pszName,
    /* [in] */ IBindCtx *pbc,
    /* [out] */ LPITEMIDLIST *ppidl,
    /* [out] */ UINT *pcchNext);


void __RPC_STUB IShellFolderNames_ParseIncremental_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellFolderNames_GetDisplayName_Proxy( 
    IShellFolderNames * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [in] */ SIGDN sigdnName,
    /* [string][out] */ LPOLESTR *ppszName);


void __RPC_STUB IShellFolderNames_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellFolderNames_INTERFACE_DEFINED__ */


#ifndef __IFolderItemsView_INTERFACE_DEFINED__
#define __IFolderItemsView_INTERFACE_DEFINED__

/* interface IFolderItemsView */
/* [unique][object][uuid][helpstring] */ 


EXTERN_C const IID IID_IFolderItemsView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0be044ca-f8a3-49b8-bdb2-5f5319e9de89")
    IFolderItemsView : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentViewMode( 
            /* [out] */ UINT *pViewMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCurrentViewMode( 
            /* [in] */ UINT ViewMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolder( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFolderItem( 
            /* [out] */ IShellItem **ppsiFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ItemCount( 
            /* [in] */ UINT *pcItems) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumItems( 
            /* [out] */ IEnumShellItems **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectedItemCount( 
            /* [out] */ UINT *pcSelected) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumSelectedItems( 
            /* [out] */ IEnumShellItems **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ int iViewIndex,
            /* [out] */ IShellItem **ppsi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ItemIndex( 
            /* [in] */ IShellItem *psi,
            /* [out] */ int *piViewIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectItem( 
            /* [in] */ int iViewIndex,
            /* [in] */ SVSIF svsif) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SelectionMark( 
            /* [in] */ int *piViewIndex) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFolderItemsViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFolderItemsView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFolderItemsView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFolderItemsView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentViewMode )( 
            IFolderItemsView * This,
            /* [out] */ UINT *pViewMode);
        
        HRESULT ( STDMETHODCALLTYPE *SetCurrentViewMode )( 
            IFolderItemsView * This,
            /* [in] */ UINT ViewMode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolder )( 
            IFolderItemsView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetFolderItem )( 
            IFolderItemsView * This,
            /* [out] */ IShellItem **ppsiFolder);
        
        HRESULT ( STDMETHODCALLTYPE *ItemCount )( 
            IFolderItemsView * This,
            /* [in] */ UINT *pcItems);
        
        HRESULT ( STDMETHODCALLTYPE *EnumItems )( 
            IFolderItemsView * This,
            /* [out] */ IEnumShellItems **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *SelectedItemCount )( 
            IFolderItemsView * This,
            /* [out] */ UINT *pcSelected);
        
        HRESULT ( STDMETHODCALLTYPE *EnumSelectedItems )( 
            IFolderItemsView * This,
            /* [out] */ IEnumShellItems **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *Item )( 
            IFolderItemsView * This,
            /* [in] */ int iViewIndex,
            /* [out] */ IShellItem **ppsi);
        
        HRESULT ( STDMETHODCALLTYPE *ItemIndex )( 
            IFolderItemsView * This,
            /* [in] */ IShellItem *psi,
            /* [out] */ int *piViewIndex);
        
        HRESULT ( STDMETHODCALLTYPE *SelectItem )( 
            IFolderItemsView * This,
            /* [in] */ int iViewIndex,
            /* [in] */ SVSIF svsif);
        
        HRESULT ( STDMETHODCALLTYPE *SelectionMark )( 
            IFolderItemsView * This,
            /* [in] */ int *piViewIndex);
        
        END_INTERFACE
    } IFolderItemsViewVtbl;

    interface IFolderItemsView
    {
        CONST_VTBL struct IFolderItemsViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFolderItemsView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFolderItemsView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFolderItemsView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFolderItemsView_GetCurrentViewMode(This,pViewMode)	\
    (This)->lpVtbl -> GetCurrentViewMode(This,pViewMode)

#define IFolderItemsView_SetCurrentViewMode(This,ViewMode)	\
    (This)->lpVtbl -> SetCurrentViewMode(This,ViewMode)

#define IFolderItemsView_GetFolder(This,riid,ppv)	\
    (This)->lpVtbl -> GetFolder(This,riid,ppv)

#define IFolderItemsView_GetFolderItem(This,ppsiFolder)	\
    (This)->lpVtbl -> GetFolderItem(This,ppsiFolder)

#define IFolderItemsView_ItemCount(This,pcItems)	\
    (This)->lpVtbl -> ItemCount(This,pcItems)

#define IFolderItemsView_EnumItems(This,ppenum)	\
    (This)->lpVtbl -> EnumItems(This,ppenum)

#define IFolderItemsView_SelectedItemCount(This,pcSelected)	\
    (This)->lpVtbl -> SelectedItemCount(This,pcSelected)

#define IFolderItemsView_EnumSelectedItems(This,ppenum)	\
    (This)->lpVtbl -> EnumSelectedItems(This,ppenum)

#define IFolderItemsView_Item(This,iViewIndex,ppsi)	\
    (This)->lpVtbl -> Item(This,iViewIndex,ppsi)

#define IFolderItemsView_ItemIndex(This,psi,piViewIndex)	\
    (This)->lpVtbl -> ItemIndex(This,psi,piViewIndex)

#define IFolderItemsView_SelectItem(This,iViewIndex,svsif)	\
    (This)->lpVtbl -> SelectItem(This,iViewIndex,svsif)

#define IFolderItemsView_SelectionMark(This,piViewIndex)	\
    (This)->lpVtbl -> SelectionMark(This,piViewIndex)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFolderItemsView_GetCurrentViewMode_Proxy( 
    IFolderItemsView * This,
    /* [out] */ UINT *pViewMode);


void __RPC_STUB IFolderItemsView_GetCurrentViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderItemsView_SetCurrentViewMode_Proxy( 
    IFolderItemsView * This,
    /* [in] */ UINT ViewMode);


void __RPC_STUB IFolderItemsView_SetCurrentViewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderItemsView_GetFolder_Proxy( 
    IFolderItemsView * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IFolderItemsView_GetFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderItemsView_GetFolderItem_Proxy( 
    IFolderItemsView * This,
    /* [out] */ IShellItem **ppsiFolder);


void __RPC_STUB IFolderItemsView_GetFolderItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderItemsView_ItemCount_Proxy( 
    IFolderItemsView * This,
    /* [in] */ UINT *pcItems);


void __RPC_STUB IFolderItemsView_ItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderItemsView_EnumItems_Proxy( 
    IFolderItemsView * This,
    /* [out] */ IEnumShellItems **ppenum);


void __RPC_STUB IFolderItemsView_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderItemsView_SelectedItemCount_Proxy( 
    IFolderItemsView * This,
    /* [out] */ UINT *pcSelected);


void __RPC_STUB IFolderItemsView_SelectedItemCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderItemsView_EnumSelectedItems_Proxy( 
    IFolderItemsView * This,
    /* [out] */ IEnumShellItems **ppenum);


void __RPC_STUB IFolderItemsView_EnumSelectedItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderItemsView_Item_Proxy( 
    IFolderItemsView * This,
    /* [in] */ int iViewIndex,
    /* [out] */ IShellItem **ppsi);


void __RPC_STUB IFolderItemsView_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderItemsView_ItemIndex_Proxy( 
    IFolderItemsView * This,
    /* [in] */ IShellItem *psi,
    /* [out] */ int *piViewIndex);


void __RPC_STUB IFolderItemsView_ItemIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderItemsView_SelectItem_Proxy( 
    IFolderItemsView * This,
    /* [in] */ int iViewIndex,
    /* [in] */ SVSIF svsif);


void __RPC_STUB IFolderItemsView_SelectItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFolderItemsView_SelectionMark_Proxy( 
    IFolderItemsView * This,
    /* [in] */ int *piViewIndex);


void __RPC_STUB IFolderItemsView_SelectionMark_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFolderItemsView_INTERFACE_DEFINED__ */


#ifndef __ILocalCopy_INTERFACE_DEFINED__
#define __ILocalCopy_INTERFACE_DEFINED__

/* interface ILocalCopy */
/* [object][uuid][helpstring] */ 


enum __MIDL_ILocalCopy_0001
    {	LCDOWN_READONLY	= 0x1,
	LC_SAVEAS	= 0x2,
	LC_FORCEROUNDTRIP	= 0x10
    } ;
typedef DWORD LCFLAGS;


EXTERN_C const IID IID_ILocalCopy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("679d9e36-f8f9-11d2-8deb-00c04f6837d5")
    ILocalCopy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Download( 
            /* [in] */ LCFLAGS flags,
            /* [in] */ IBindCtx *pbc,
            /* [string][out] */ LPWSTR *ppszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Upload( 
            /* [in] */ LCFLAGS flags,
            /* [in] */ IBindCtx *pbc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocalCopyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILocalCopy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILocalCopy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILocalCopy * This);
        
        HRESULT ( STDMETHODCALLTYPE *Download )( 
            ILocalCopy * This,
            /* [in] */ LCFLAGS flags,
            /* [in] */ IBindCtx *pbc,
            /* [string][out] */ LPWSTR *ppszPath);
        
        HRESULT ( STDMETHODCALLTYPE *Upload )( 
            ILocalCopy * This,
            /* [in] */ LCFLAGS flags,
            /* [in] */ IBindCtx *pbc);
        
        END_INTERFACE
    } ILocalCopyVtbl;

    interface ILocalCopy
    {
        CONST_VTBL struct ILocalCopyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocalCopy_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILocalCopy_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILocalCopy_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILocalCopy_Download(This,flags,pbc,ppszPath)	\
    (This)->lpVtbl -> Download(This,flags,pbc,ppszPath)

#define ILocalCopy_Upload(This,flags,pbc)	\
    (This)->lpVtbl -> Upload(This,flags,pbc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ILocalCopy_Download_Proxy( 
    ILocalCopy * This,
    /* [in] */ LCFLAGS flags,
    /* [in] */ IBindCtx *pbc,
    /* [string][out] */ LPWSTR *ppszPath);


void __RPC_STUB ILocalCopy_Download_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ILocalCopy_Upload_Proxy( 
    ILocalCopy * This,
    /* [in] */ LCFLAGS flags,
    /* [in] */ IBindCtx *pbc);


void __RPC_STUB ILocalCopy_Upload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILocalCopy_INTERFACE_DEFINED__ */


#ifndef __IDefViewFrame3_INTERFACE_DEFINED__
#define __IDefViewFrame3_INTERFACE_DEFINED__

/* interface IDefViewFrame3 */
/* [unique][object][uuid] */ 


EXTERN_C const IID IID_IDefViewFrame3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("985F64F0-D410-4E02-BE22-DA07F2B5C5E1")
    IDefViewFrame3 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetWindowLV( 
            HWND *phwnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowHideListView( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnResizeListView( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseWindowLV( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoRename( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDefViewFrame3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDefViewFrame3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDefViewFrame3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDefViewFrame3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetWindowLV )( 
            IDefViewFrame3 * This,
            HWND *phwnd);
        
        HRESULT ( STDMETHODCALLTYPE *ShowHideListView )( 
            IDefViewFrame3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnResizeListView )( 
            IDefViewFrame3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseWindowLV )( 
            IDefViewFrame3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DoRename )( 
            IDefViewFrame3 * This);
        
        END_INTERFACE
    } IDefViewFrame3Vtbl;

    interface IDefViewFrame3
    {
        CONST_VTBL struct IDefViewFrame3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDefViewFrame3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDefViewFrame3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDefViewFrame3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDefViewFrame3_GetWindowLV(This,phwnd)	\
    (This)->lpVtbl -> GetWindowLV(This,phwnd)

#define IDefViewFrame3_ShowHideListView(This)	\
    (This)->lpVtbl -> ShowHideListView(This)

#define IDefViewFrame3_OnResizeListView(This)	\
    (This)->lpVtbl -> OnResizeListView(This)

#define IDefViewFrame3_ReleaseWindowLV(This)	\
    (This)->lpVtbl -> ReleaseWindowLV(This)

#define IDefViewFrame3_DoRename(This)	\
    (This)->lpVtbl -> DoRename(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDefViewFrame3_GetWindowLV_Proxy( 
    IDefViewFrame3 * This,
    HWND *phwnd);


void __RPC_STUB IDefViewFrame3_GetWindowLV_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefViewFrame3_ShowHideListView_Proxy( 
    IDefViewFrame3 * This);


void __RPC_STUB IDefViewFrame3_ShowHideListView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefViewFrame3_OnResizeListView_Proxy( 
    IDefViewFrame3 * This);


void __RPC_STUB IDefViewFrame3_OnResizeListView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefViewFrame3_ReleaseWindowLV_Proxy( 
    IDefViewFrame3 * This);


void __RPC_STUB IDefViewFrame3_ReleaseWindowLV_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefViewFrame3_DoRename_Proxy( 
    IDefViewFrame3 * This);


void __RPC_STUB IDefViewFrame3_DoRename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDefViewFrame3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0303 */
/* [local] */ 

#define DS_BACKUPDISPLAYCPL  0x00000001


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0303_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0303_v0_0_s_ifspec;

#ifndef __IDisplaySettings_INTERFACE_DEFINED__
#define __IDisplaySettings_INTERFACE_DEFINED__

/* interface IDisplaySettings */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IDisplaySettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("610d76de-7861-4715-9d08-b6e297c3985b")
    IDisplaySettings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMonitor( 
            /* [in] */ DWORD dwMonitor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModeCount( 
            /* [out] */ DWORD *pdwCount,
            /* [in] */ BOOL fOnlyPreferredModes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMode( 
            /* [in] */ DWORD dwMode,
            /* [in] */ BOOL fOnlyPreferredModes,
            /* [out] */ DWORD *pdwWidth,
            /* [out] */ DWORD *pdwHeight,
            /* [out] */ DWORD *pdwColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSelectedMode( 
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight,
            /* [in] */ DWORD dwColor,
            /* [out] */ BOOL *pfApplied,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSelectedMode( 
            /* [out] */ DWORD *pdwWidth,
            /* [out] */ DWORD *pdwHeight,
            /* [out] */ DWORD *pdwColor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttached( 
            /* [out] */ BOOL *pfAttached) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPruningMode( 
            /* [in] */ BOOL fIsPruningOn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPruningMode( 
            /* [out] */ BOOL *pfCanBePruned,
            /* [out] */ BOOL *pfIsPruningReadOnly,
            /* [out] */ BOOL *pfIsPruningOn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDisplaySettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDisplaySettings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDisplaySettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDisplaySettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetMonitor )( 
            IDisplaySettings * This,
            /* [in] */ DWORD dwMonitor);
        
        HRESULT ( STDMETHODCALLTYPE *GetModeCount )( 
            IDisplaySettings * This,
            /* [out] */ DWORD *pdwCount,
            /* [in] */ BOOL fOnlyPreferredModes);
        
        HRESULT ( STDMETHODCALLTYPE *GetMode )( 
            IDisplaySettings * This,
            /* [in] */ DWORD dwMode,
            /* [in] */ BOOL fOnlyPreferredModes,
            /* [out] */ DWORD *pdwWidth,
            /* [out] */ DWORD *pdwHeight,
            /* [out] */ DWORD *pdwColor);
        
        HRESULT ( STDMETHODCALLTYPE *SetSelectedMode )( 
            IDisplaySettings * This,
            /* [in] */ HWND hwnd,
            /* [in] */ DWORD dwWidth,
            /* [in] */ DWORD dwHeight,
            /* [in] */ DWORD dwColor,
            /* [out] */ BOOL *pfApplied,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetSelectedMode )( 
            IDisplaySettings * This,
            /* [out] */ DWORD *pdwWidth,
            /* [out] */ DWORD *pdwHeight,
            /* [out] */ DWORD *pdwColor);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttached )( 
            IDisplaySettings * This,
            /* [out] */ BOOL *pfAttached);
        
        HRESULT ( STDMETHODCALLTYPE *SetPruningMode )( 
            IDisplaySettings * This,
            /* [in] */ BOOL fIsPruningOn);
        
        HRESULT ( STDMETHODCALLTYPE *GetPruningMode )( 
            IDisplaySettings * This,
            /* [out] */ BOOL *pfCanBePruned,
            /* [out] */ BOOL *pfIsPruningReadOnly,
            /* [out] */ BOOL *pfIsPruningOn);
        
        END_INTERFACE
    } IDisplaySettingsVtbl;

    interface IDisplaySettings
    {
        CONST_VTBL struct IDisplaySettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDisplaySettings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDisplaySettings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDisplaySettings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDisplaySettings_SetMonitor(This,dwMonitor)	\
    (This)->lpVtbl -> SetMonitor(This,dwMonitor)

#define IDisplaySettings_GetModeCount(This,pdwCount,fOnlyPreferredModes)	\
    (This)->lpVtbl -> GetModeCount(This,pdwCount,fOnlyPreferredModes)

#define IDisplaySettings_GetMode(This,dwMode,fOnlyPreferredModes,pdwWidth,pdwHeight,pdwColor)	\
    (This)->lpVtbl -> GetMode(This,dwMode,fOnlyPreferredModes,pdwWidth,pdwHeight,pdwColor)

#define IDisplaySettings_SetSelectedMode(This,hwnd,dwWidth,dwHeight,dwColor,pfApplied,dwFlags)	\
    (This)->lpVtbl -> SetSelectedMode(This,hwnd,dwWidth,dwHeight,dwColor,pfApplied,dwFlags)

#define IDisplaySettings_GetSelectedMode(This,pdwWidth,pdwHeight,pdwColor)	\
    (This)->lpVtbl -> GetSelectedMode(This,pdwWidth,pdwHeight,pdwColor)

#define IDisplaySettings_GetAttached(This,pfAttached)	\
    (This)->lpVtbl -> GetAttached(This,pfAttached)

#define IDisplaySettings_SetPruningMode(This,fIsPruningOn)	\
    (This)->lpVtbl -> SetPruningMode(This,fIsPruningOn)

#define IDisplaySettings_GetPruningMode(This,pfCanBePruned,pfIsPruningReadOnly,pfIsPruningOn)	\
    (This)->lpVtbl -> GetPruningMode(This,pfCanBePruned,pfIsPruningReadOnly,pfIsPruningOn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDisplaySettings_SetMonitor_Proxy( 
    IDisplaySettings * This,
    /* [in] */ DWORD dwMonitor);


void __RPC_STUB IDisplaySettings_SetMonitor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDisplaySettings_GetModeCount_Proxy( 
    IDisplaySettings * This,
    /* [out] */ DWORD *pdwCount,
    /* [in] */ BOOL fOnlyPreferredModes);


void __RPC_STUB IDisplaySettings_GetModeCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDisplaySettings_GetMode_Proxy( 
    IDisplaySettings * This,
    /* [in] */ DWORD dwMode,
    /* [in] */ BOOL fOnlyPreferredModes,
    /* [out] */ DWORD *pdwWidth,
    /* [out] */ DWORD *pdwHeight,
    /* [out] */ DWORD *pdwColor);


void __RPC_STUB IDisplaySettings_GetMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDisplaySettings_SetSelectedMode_Proxy( 
    IDisplaySettings * This,
    /* [in] */ HWND hwnd,
    /* [in] */ DWORD dwWidth,
    /* [in] */ DWORD dwHeight,
    /* [in] */ DWORD dwColor,
    /* [out] */ BOOL *pfApplied,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IDisplaySettings_SetSelectedMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDisplaySettings_GetSelectedMode_Proxy( 
    IDisplaySettings * This,
    /* [out] */ DWORD *pdwWidth,
    /* [out] */ DWORD *pdwHeight,
    /* [out] */ DWORD *pdwColor);


void __RPC_STUB IDisplaySettings_GetSelectedMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDisplaySettings_GetAttached_Proxy( 
    IDisplaySettings * This,
    /* [out] */ BOOL *pfAttached);


void __RPC_STUB IDisplaySettings_GetAttached_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDisplaySettings_SetPruningMode_Proxy( 
    IDisplaySettings * This,
    /* [in] */ BOOL fIsPruningOn);


void __RPC_STUB IDisplaySettings_SetPruningMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDisplaySettings_GetPruningMode_Proxy( 
    IDisplaySettings * This,
    /* [out] */ BOOL *pfCanBePruned,
    /* [out] */ BOOL *pfIsPruningReadOnly,
    /* [out] */ BOOL *pfIsPruningOn);


void __RPC_STUB IDisplaySettings_GetPruningMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDisplaySettings_INTERFACE_DEFINED__ */


#ifndef __IScreenResFixer_INTERFACE_DEFINED__
#define __IScreenResFixer_INTERFACE_DEFINED__

/* interface IScreenResFixer */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IScreenResFixer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b80df3d8-82db-4e8d-8097-8c2c0e746470")
    IScreenResFixer : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IScreenResFixerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IScreenResFixer * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IScreenResFixer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IScreenResFixer * This);
        
        END_INTERFACE
    } IScreenResFixerVtbl;

    interface IScreenResFixer
    {
        CONST_VTBL struct IScreenResFixerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScreenResFixer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScreenResFixer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScreenResFixer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IScreenResFixer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0305 */
/* [local] */ 

typedef struct tagTREEWALKERSTATS
    {
    int nFiles;
    int nFolders;
    int nDepth;
    DWORD dwClusterSize;
    ULONGLONG ulTotalSize;
    ULONGLONG ulActualSize;
    } 	TREEWALKERSTATS;



extern RPC_IF_HANDLE __MIDL_itf_shpriv_0305_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0305_v0_0_s_ifspec;

#ifndef __IShellTreeWalkerCallBack_INTERFACE_DEFINED__
#define __IShellTreeWalkerCallBack_INTERFACE_DEFINED__

/* interface IShellTreeWalkerCallBack */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IShellTreeWalkerCallBack;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("95CE8411-7027-11D1-B879-006008059382")
    IShellTreeWalkerCallBack : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FoundFile( 
            /* [string][in] */ LPCWSTR pwszPath,
            /* [in] */ TREEWALKERSTATS *ptws,
            /* [in] */ WIN32_FIND_DATAW *pwfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnterFolder( 
            /* [string][in] */ LPCWSTR pwszPath,
            /* [in] */ TREEWALKERSTATS *ptws,
            /* [in] */ WIN32_FIND_DATAW *pwfd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveFolder( 
            /* [string][in] */ LPCWSTR pwszPath,
            /* [in] */ TREEWALKERSTATS *ptws) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleError( 
            /* [string][in] */ LPCWSTR pwszPath,
            /* [in] */ TREEWALKERSTATS *ptws,
            /* [in] */ HRESULT hrError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellTreeWalkerCallBackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellTreeWalkerCallBack * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellTreeWalkerCallBack * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellTreeWalkerCallBack * This);
        
        HRESULT ( STDMETHODCALLTYPE *FoundFile )( 
            IShellTreeWalkerCallBack * This,
            /* [string][in] */ LPCWSTR pwszPath,
            /* [in] */ TREEWALKERSTATS *ptws,
            /* [in] */ WIN32_FIND_DATAW *pwfd);
        
        HRESULT ( STDMETHODCALLTYPE *EnterFolder )( 
            IShellTreeWalkerCallBack * This,
            /* [string][in] */ LPCWSTR pwszPath,
            /* [in] */ TREEWALKERSTATS *ptws,
            /* [in] */ WIN32_FIND_DATAW *pwfd);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveFolder )( 
            IShellTreeWalkerCallBack * This,
            /* [string][in] */ LPCWSTR pwszPath,
            /* [in] */ TREEWALKERSTATS *ptws);
        
        HRESULT ( STDMETHODCALLTYPE *HandleError )( 
            IShellTreeWalkerCallBack * This,
            /* [string][in] */ LPCWSTR pwszPath,
            /* [in] */ TREEWALKERSTATS *ptws,
            /* [in] */ HRESULT hrError);
        
        END_INTERFACE
    } IShellTreeWalkerCallBackVtbl;

    interface IShellTreeWalkerCallBack
    {
        CONST_VTBL struct IShellTreeWalkerCallBackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellTreeWalkerCallBack_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellTreeWalkerCallBack_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellTreeWalkerCallBack_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellTreeWalkerCallBack_FoundFile(This,pwszPath,ptws,pwfd)	\
    (This)->lpVtbl -> FoundFile(This,pwszPath,ptws,pwfd)

#define IShellTreeWalkerCallBack_EnterFolder(This,pwszPath,ptws,pwfd)	\
    (This)->lpVtbl -> EnterFolder(This,pwszPath,ptws,pwfd)

#define IShellTreeWalkerCallBack_LeaveFolder(This,pwszPath,ptws)	\
    (This)->lpVtbl -> LeaveFolder(This,pwszPath,ptws)

#define IShellTreeWalkerCallBack_HandleError(This,pwszPath,ptws,hrError)	\
    (This)->lpVtbl -> HandleError(This,pwszPath,ptws,hrError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellTreeWalkerCallBack_FoundFile_Proxy( 
    IShellTreeWalkerCallBack * This,
    /* [string][in] */ LPCWSTR pwszPath,
    /* [in] */ TREEWALKERSTATS *ptws,
    /* [in] */ WIN32_FIND_DATAW *pwfd);


void __RPC_STUB IShellTreeWalkerCallBack_FoundFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellTreeWalkerCallBack_EnterFolder_Proxy( 
    IShellTreeWalkerCallBack * This,
    /* [string][in] */ LPCWSTR pwszPath,
    /* [in] */ TREEWALKERSTATS *ptws,
    /* [in] */ WIN32_FIND_DATAW *pwfd);


void __RPC_STUB IShellTreeWalkerCallBack_EnterFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellTreeWalkerCallBack_LeaveFolder_Proxy( 
    IShellTreeWalkerCallBack * This,
    /* [string][in] */ LPCWSTR pwszPath,
    /* [in] */ TREEWALKERSTATS *ptws);


void __RPC_STUB IShellTreeWalkerCallBack_LeaveFolder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IShellTreeWalkerCallBack_HandleError_Proxy( 
    IShellTreeWalkerCallBack * This,
    /* [string][in] */ LPCWSTR pwszPath,
    /* [in] */ TREEWALKERSTATS *ptws,
    /* [in] */ HRESULT hrError);


void __RPC_STUB IShellTreeWalkerCallBack_HandleError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellTreeWalkerCallBack_INTERFACE_DEFINED__ */


#ifndef __IShellTreeWalker_INTERFACE_DEFINED__
#define __IShellTreeWalker_INTERFACE_DEFINED__

/* interface IShellTreeWalker */
/* [object][helpstring][uuid] */ 


enum __MIDL_IShellTreeWalker_0001
    {	WT_FOLDERFIRST	= 0x1,
	WT_MAXDEPTH	= 0x2,
	WT_FOLDERONLY	= 0x4,
	WT_NOTIFYFOLDERENTER	= 0x8,
	WT_NOTIFYFOLDERLEAVE	= 0x10,
	WT_GOINTOREPARSEPOINT	= 0x20,
	WT_EXCLUDEWALKROOT	= 0x40,
	WT_ALL	= 0x7f
    } ;
typedef DWORD STWFLAGS;


EXTERN_C const IID IID_IShellTreeWalker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("95CE8410-7027-11D1-B879-006008059382")
    IShellTreeWalker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WalkTree( 
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ LPCWSTR pwszWalkRoot,
            /* [string][in] */ LPCWSTR pwszWalkSpec,
            /* [in] */ int iMaxPath,
            /* [in] */ IShellTreeWalkerCallBack *pstwcb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IShellTreeWalkerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IShellTreeWalker * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IShellTreeWalker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IShellTreeWalker * This);
        
        HRESULT ( STDMETHODCALLTYPE *WalkTree )( 
            IShellTreeWalker * This,
            /* [in] */ DWORD dwFlags,
            /* [string][in] */ LPCWSTR pwszWalkRoot,
            /* [string][in] */ LPCWSTR pwszWalkSpec,
            /* [in] */ int iMaxPath,
            /* [in] */ IShellTreeWalkerCallBack *pstwcb);
        
        END_INTERFACE
    } IShellTreeWalkerVtbl;

    interface IShellTreeWalker
    {
        CONST_VTBL struct IShellTreeWalkerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IShellTreeWalker_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IShellTreeWalker_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IShellTreeWalker_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IShellTreeWalker_WalkTree(This,dwFlags,pwszWalkRoot,pwszWalkSpec,iMaxPath,pstwcb)	\
    (This)->lpVtbl -> WalkTree(This,dwFlags,pwszWalkRoot,pwszWalkSpec,iMaxPath,pstwcb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IShellTreeWalker_WalkTree_Proxy( 
    IShellTreeWalker * This,
    /* [in] */ DWORD dwFlags,
    /* [string][in] */ LPCWSTR pwszWalkRoot,
    /* [string][in] */ LPCWSTR pwszWalkSpec,
    /* [in] */ int iMaxPath,
    /* [in] */ IShellTreeWalkerCallBack *pstwcb);


void __RPC_STUB IShellTreeWalker_WalkTree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IShellTreeWalker_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0307 */
/* [local] */ 

_inline void FreeIDListArray(LPITEMIDLIST *ppidls, UINT cItems)
{                                        
     UINT i;                             
     for (i = 0; i < cItems; i++)        
     {                                   
         CoTaskMemFree(ppidls[i]);       
     }                                   
     CoTaskMemFree(ppidls);              
}                                        


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0307_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0307_v0_0_s_ifspec;

#ifndef __IUIElement_INTERFACE_DEFINED__
#define __IUIElement_INTERFACE_DEFINED__

/* interface IUIElement */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUIElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EC6FE84F-DC14-4FBB-889F-EA50FE27FE0F")
    IUIElement : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_Name( 
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Icon( 
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Tooltip( 
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszInfotip) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUIElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUIElement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUIElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUIElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IUIElement * This,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *get_Icon )( 
            IUIElement * This,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszIcon);
        
        HRESULT ( STDMETHODCALLTYPE *get_Tooltip )( 
            IUIElement * This,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszInfotip);
        
        END_INTERFACE
    } IUIElementVtbl;

    interface IUIElement
    {
        CONST_VTBL struct IUIElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUIElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUIElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUIElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUIElement_get_Name(This,psiItemArray,ppszName)	\
    (This)->lpVtbl -> get_Name(This,psiItemArray,ppszName)

#define IUIElement_get_Icon(This,psiItemArray,ppszIcon)	\
    (This)->lpVtbl -> get_Icon(This,psiItemArray,ppszIcon)

#define IUIElement_get_Tooltip(This,psiItemArray,ppszInfotip)	\
    (This)->lpVtbl -> get_Tooltip(This,psiItemArray,ppszInfotip)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUIElement_get_Name_Proxy( 
    IUIElement * This,
    /* [in] */ IShellItemArray *psiItemArray,
    /* [string][out] */ LPWSTR *ppszName);


void __RPC_STUB IUIElement_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUIElement_get_Icon_Proxy( 
    IUIElement * This,
    /* [in] */ IShellItemArray *psiItemArray,
    /* [string][out] */ LPWSTR *ppszIcon);


void __RPC_STUB IUIElement_get_Icon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUIElement_get_Tooltip_Proxy( 
    IUIElement * This,
    /* [in] */ IShellItemArray *psiItemArray,
    /* [string][out] */ LPWSTR *ppszInfotip);


void __RPC_STUB IUIElement_get_Tooltip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUIElement_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0308 */
/* [local] */ 

typedef 
enum tagUISTATE
    {	UIS_ENABLED	= 0,
	UIS_DISABLED	= 1,
	UIS_HIDDEN	= 2
    } 	UISTATE;



extern RPC_IF_HANDLE __MIDL_itf_shpriv_0308_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0308_v0_0_s_ifspec;

#ifndef __IUICommand_INTERFACE_DEFINED__
#define __IUICommand_INTERFACE_DEFINED__

/* interface IUICommand */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUICommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4026DFB9-7691-4142-B71C-DCF08EA4DD9C")
    IUICommand : public IUIElement
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_CanonicalName( 
            /* [out] */ GUID *pguidCommandName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_State( 
            /* [in] */ IShellItemArray *psiItemArray,
            /* [in] */ BOOL fOkToBeSlow,
            /* [out] */ UISTATE *puisState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ IShellItemArray *psiItemArray,
            /* [optional][in] */ IBindCtx *pbc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUICommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUICommand * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUICommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUICommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IUICommand * This,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *get_Icon )( 
            IUICommand * This,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszIcon);
        
        HRESULT ( STDMETHODCALLTYPE *get_Tooltip )( 
            IUICommand * This,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszInfotip);
        
        HRESULT ( STDMETHODCALLTYPE *get_CanonicalName )( 
            IUICommand * This,
            /* [out] */ GUID *pguidCommandName);
        
        HRESULT ( STDMETHODCALLTYPE *get_State )( 
            IUICommand * This,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [in] */ BOOL fOkToBeSlow,
            /* [out] */ UISTATE *puisState);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUICommand * This,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [optional][in] */ IBindCtx *pbc);
        
        END_INTERFACE
    } IUICommandVtbl;

    interface IUICommand
    {
        CONST_VTBL struct IUICommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUICommand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUICommand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUICommand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUICommand_get_Name(This,psiItemArray,ppszName)	\
    (This)->lpVtbl -> get_Name(This,psiItemArray,ppszName)

#define IUICommand_get_Icon(This,psiItemArray,ppszIcon)	\
    (This)->lpVtbl -> get_Icon(This,psiItemArray,ppszIcon)

#define IUICommand_get_Tooltip(This,psiItemArray,ppszInfotip)	\
    (This)->lpVtbl -> get_Tooltip(This,psiItemArray,ppszInfotip)


#define IUICommand_get_CanonicalName(This,pguidCommandName)	\
    (This)->lpVtbl -> get_CanonicalName(This,pguidCommandName)

#define IUICommand_get_State(This,psiItemArray,fOkToBeSlow,puisState)	\
    (This)->lpVtbl -> get_State(This,psiItemArray,fOkToBeSlow,puisState)

#define IUICommand_Invoke(This,psiItemArray,pbc)	\
    (This)->lpVtbl -> Invoke(This,psiItemArray,pbc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUICommand_get_CanonicalName_Proxy( 
    IUICommand * This,
    /* [out] */ GUID *pguidCommandName);


void __RPC_STUB IUICommand_get_CanonicalName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUICommand_get_State_Proxy( 
    IUICommand * This,
    /* [in] */ IShellItemArray *psiItemArray,
    /* [in] */ BOOL fOkToBeSlow,
    /* [out] */ UISTATE *puisState);


void __RPC_STUB IUICommand_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUICommand_Invoke_Proxy( 
    IUICommand * This,
    /* [in] */ IShellItemArray *psiItemArray,
    /* [optional][in] */ IBindCtx *pbc);


void __RPC_STUB IUICommand_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUICommand_INTERFACE_DEFINED__ */


#ifndef __IEnumUICommand_INTERFACE_DEFINED__
#define __IEnumUICommand_INTERFACE_DEFINED__

/* interface IEnumUICommand */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IEnumUICommand;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("869447DA-9F84-4E2A-B92D-00642DC8A911")
    IEnumUICommand : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IUICommand **pUICommand,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumUICommand **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumUICommandVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumUICommand * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumUICommand * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumUICommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumUICommand * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IUICommand **pUICommand,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumUICommand * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumUICommand * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumUICommand * This,
            /* [out] */ IEnumUICommand **ppenum);
        
        END_INTERFACE
    } IEnumUICommandVtbl;

    interface IEnumUICommand
    {
        CONST_VTBL struct IEnumUICommandVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumUICommand_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumUICommand_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumUICommand_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumUICommand_Next(This,celt,pUICommand,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,pUICommand,pceltFetched)

#define IEnumUICommand_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumUICommand_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumUICommand_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumUICommand_Next_Proxy( 
    IEnumUICommand * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IUICommand **pUICommand,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumUICommand_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumUICommand_Skip_Proxy( 
    IEnumUICommand * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumUICommand_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumUICommand_Reset_Proxy( 
    IEnumUICommand * This);


void __RPC_STUB IEnumUICommand_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumUICommand_Clone_Proxy( 
    IEnumUICommand * This,
    /* [out] */ IEnumUICommand **ppenum);


void __RPC_STUB IEnumUICommand_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumUICommand_INTERFACE_DEFINED__ */


#ifndef __IUICommandTarget_INTERFACE_DEFINED__
#define __IUICommandTarget_INTERFACE_DEFINED__

/* interface IUICommandTarget */
/* [object][unique][uuid] */ 


EXTERN_C const IID IID_IUICommandTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2CB95001-FC47-4064-89B3-328F2FE60F44")
    IUICommandTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_Name( 
            /* [in] */ REFGUID guidCanonicalName,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Icon( 
            /* [in] */ REFGUID guidCanonicalName,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszIcon) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Tooltip( 
            /* [in] */ REFGUID guidCanonicalName,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszInfotip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_State( 
            /* [in] */ REFGUID guidCanonicalName,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [out] */ UISTATE *puisState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ REFGUID guidCanonicalName,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [optional][in] */ IBindCtx *pbc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUICommandTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IUICommandTarget * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IUICommandTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IUICommandTarget * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            IUICommandTarget * This,
            /* [in] */ REFGUID guidCanonicalName,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszName);
        
        HRESULT ( STDMETHODCALLTYPE *get_Icon )( 
            IUICommandTarget * This,
            /* [in] */ REFGUID guidCanonicalName,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszIcon);
        
        HRESULT ( STDMETHODCALLTYPE *get_Tooltip )( 
            IUICommandTarget * This,
            /* [in] */ REFGUID guidCanonicalName,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [string][out] */ LPWSTR *ppszInfotip);
        
        HRESULT ( STDMETHODCALLTYPE *get_State )( 
            IUICommandTarget * This,
            /* [in] */ REFGUID guidCanonicalName,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [out] */ UISTATE *puisState);
        
        HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IUICommandTarget * This,
            /* [in] */ REFGUID guidCanonicalName,
            /* [in] */ IShellItemArray *psiItemArray,
            /* [optional][in] */ IBindCtx *pbc);
        
        END_INTERFACE
    } IUICommandTargetVtbl;

    interface IUICommandTarget
    {
        CONST_VTBL struct IUICommandTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUICommandTarget_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUICommandTarget_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUICommandTarget_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUICommandTarget_get_Name(This,guidCanonicalName,psiItemArray,ppszName)	\
    (This)->lpVtbl -> get_Name(This,guidCanonicalName,psiItemArray,ppszName)

#define IUICommandTarget_get_Icon(This,guidCanonicalName,psiItemArray,ppszIcon)	\
    (This)->lpVtbl -> get_Icon(This,guidCanonicalName,psiItemArray,ppszIcon)

#define IUICommandTarget_get_Tooltip(This,guidCanonicalName,psiItemArray,ppszInfotip)	\
    (This)->lpVtbl -> get_Tooltip(This,guidCanonicalName,psiItemArray,ppszInfotip)

#define IUICommandTarget_get_State(This,guidCanonicalName,psiItemArray,puisState)	\
    (This)->lpVtbl -> get_State(This,guidCanonicalName,psiItemArray,puisState)

#define IUICommandTarget_Invoke(This,guidCanonicalName,psiItemArray,pbc)	\
    (This)->lpVtbl -> Invoke(This,guidCanonicalName,psiItemArray,pbc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUICommandTarget_get_Name_Proxy( 
    IUICommandTarget * This,
    /* [in] */ REFGUID guidCanonicalName,
    /* [in] */ IShellItemArray *psiItemArray,
    /* [string][out] */ LPWSTR *ppszName);


void __RPC_STUB IUICommandTarget_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUICommandTarget_get_Icon_Proxy( 
    IUICommandTarget * This,
    /* [in] */ REFGUID guidCanonicalName,
    /* [in] */ IShellItemArray *psiItemArray,
    /* [string][out] */ LPWSTR *ppszIcon);


void __RPC_STUB IUICommandTarget_get_Icon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUICommandTarget_get_Tooltip_Proxy( 
    IUICommandTarget * This,
    /* [in] */ REFGUID guidCanonicalName,
    /* [in] */ IShellItemArray *psiItemArray,
    /* [string][out] */ LPWSTR *ppszInfotip);


void __RPC_STUB IUICommandTarget_get_Tooltip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUICommandTarget_get_State_Proxy( 
    IUICommandTarget * This,
    /* [in] */ REFGUID guidCanonicalName,
    /* [in] */ IShellItemArray *psiItemArray,
    /* [out] */ UISTATE *puisState);


void __RPC_STUB IUICommandTarget_get_State_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUICommandTarget_Invoke_Proxy( 
    IUICommandTarget * This,
    /* [in] */ REFGUID guidCanonicalName,
    /* [in] */ IShellItemArray *psiItemArray,
    /* [optional][in] */ IBindCtx *pbc);


void __RPC_STUB IUICommandTarget_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUICommandTarget_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0311 */
/* [local] */ 


typedef GUID STGTRANSCONFIRMATION;

typedef GUID *LPSTGTRANSCONFIRMATION;

typedef struct tagCUSTOMCONFIRMATION
    {
    DWORD cbSize;
    DWORD dwFlags;
    DWORD dwButtons;
    LPWSTR pwszTitle;
    LPWSTR pwszDescription;
    HICON hicon;
    LPWSTR pwszAdvancedDetails;
    } 	CUSTOMCONFIRMATION;

typedef struct tagCUSTOMCONFIRMATION *LPCUSTOMCONFIRMATION;



extern RPC_IF_HANDLE __MIDL_itf_shpriv_0311_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0311_v0_0_s_ifspec;

#ifndef __IFileSystemStorage_INTERFACE_DEFINED__
#define __IFileSystemStorage_INTERFACE_DEFINED__

/* interface IFileSystemStorage */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IFileSystemStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E820910B-1910-404D-AFAF-5D7298B9B28D")
    IFileSystemStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPath( 
            /* [out] */ WCHAR *pszName,
            /* [in] */ DWORD cch) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [string][in] */ const WCHAR *pszName,
            /* [in] */ DWORD dwMask,
            /* [out] */ DWORD *pdwAttribs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSystemStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFileSystemStorage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFileSystemStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFileSystemStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            IFileSystemStorage * This,
            /* [out] */ WCHAR *pszName,
            /* [in] */ DWORD cch);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            IFileSystemStorage * This,
            /* [string][in] */ const WCHAR *pszName,
            /* [in] */ DWORD dwMask,
            /* [out] */ DWORD *pdwAttribs);
        
        END_INTERFACE
    } IFileSystemStorageVtbl;

    interface IFileSystemStorage
    {
        CONST_VTBL struct IFileSystemStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSystemStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFileSystemStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFileSystemStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFileSystemStorage_GetPath(This,pszName,cch)	\
    (This)->lpVtbl -> GetPath(This,pszName,cch)

#define IFileSystemStorage_GetAttributes(This,pszName,dwMask,pdwAttribs)	\
    (This)->lpVtbl -> GetAttributes(This,pszName,dwMask,pdwAttribs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFileSystemStorage_GetPath_Proxy( 
    IFileSystemStorage * This,
    /* [out] */ WCHAR *pszName,
    /* [in] */ DWORD cch);


void __RPC_STUB IFileSystemStorage_GetPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IFileSystemStorage_GetAttributes_Proxy( 
    IFileSystemStorage * This,
    /* [string][in] */ const WCHAR *pszName,
    /* [in] */ DWORD dwMask,
    /* [out] */ DWORD *pdwAttribs);


void __RPC_STUB IFileSystemStorage_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFileSystemStorage_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0312 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tagSTGOP
    {	STGOP_MOVE	= 1,
	STGOP_COPY	= 2,
	STGOP_SYNC	= 3,
	STGOP_DIFF	= 4,
	STGOP_REMOVE	= 5,
	STGOP_RENAME	= 6,
	STGOP_STATS	= 7,
	STGOP_COPY_PREFERHARDLINK	= 8
    } 	STGOP;

typedef /* [v1_enum] */ enum tagSTGOP *LPSTGOP;

typedef /* [v1_enum] */ 
enum tagSTGPROCOPTIONS
    {	STOPT_ROOTONLY	= 0x4,
	STOPT_NOCONFIRMATIONS	= 0x8,
	STOPT_NOPROGRESSUI	= 0x10,
	STOPT_NOSTATS	= 0x20
    } 	STGPROCOPTIONS;

typedef /* [v1_enum] */ enum tagSTGPROCOPTIONS *LPSTGPROCOPTIONS;



extern RPC_IF_HANDLE __MIDL_itf_shpriv_0312_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0312_v0_0_s_ifspec;

#ifndef __IDynamicStorage_INTERFACE_DEFINED__
#define __IDynamicStorage_INTERFACE_DEFINED__

/* interface IDynamicStorage */
/* [object][uuid][helpstring] */ 

typedef /* [public][public][v1_enum] */ 
enum __MIDL_IDynamicStorage_0001
    {	DSTGF_NONE	= 0,
	DSTGF_ALLOWDUP	= 0x1
    } 	DSTGF;


EXTERN_C const IID IID_IDynamicStorage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c7bfc3d0-8939-4d9d-8973-654099329956")
    IDynamicStorage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddIDList( 
            /* [in] */ DWORD cpidl,
            /* [size_is][in] */ LPITEMIDLIST *rgpidl,
            DSTGF dstgf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindToItem( 
            /* [string][in] */ LPCWSTR pwszName,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumItems( 
            /* [out] */ IEnumShellItems **ppesi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDynamicStorageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDynamicStorage * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDynamicStorage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDynamicStorage * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddIDList )( 
            IDynamicStorage * This,
            /* [in] */ DWORD cpidl,
            /* [size_is][in] */ LPITEMIDLIST *rgpidl,
            DSTGF dstgf);
        
        HRESULT ( STDMETHODCALLTYPE *BindToItem )( 
            IDynamicStorage * This,
            /* [string][in] */ LPCWSTR pwszName,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *EnumItems )( 
            IDynamicStorage * This,
            /* [out] */ IEnumShellItems **ppesi);
        
        END_INTERFACE
    } IDynamicStorageVtbl;

    interface IDynamicStorage
    {
        CONST_VTBL struct IDynamicStorageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDynamicStorage_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDynamicStorage_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDynamicStorage_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDynamicStorage_AddIDList(This,cpidl,rgpidl,dstgf)	\
    (This)->lpVtbl -> AddIDList(This,cpidl,rgpidl,dstgf)

#define IDynamicStorage_BindToItem(This,pwszName,riid,ppv)	\
    (This)->lpVtbl -> BindToItem(This,pwszName,riid,ppv)

#define IDynamicStorage_EnumItems(This,ppesi)	\
    (This)->lpVtbl -> EnumItems(This,ppesi)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDynamicStorage_AddIDList_Proxy( 
    IDynamicStorage * This,
    /* [in] */ DWORD cpidl,
    /* [size_is][in] */ LPITEMIDLIST *rgpidl,
    DSTGF dstgf);


void __RPC_STUB IDynamicStorage_AddIDList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDynamicStorage_BindToItem_Proxy( 
    IDynamicStorage * This,
    /* [string][in] */ LPCWSTR pwszName,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IDynamicStorage_BindToItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDynamicStorage_EnumItems_Proxy( 
    IDynamicStorage * This,
    /* [out] */ IEnumShellItems **ppesi);


void __RPC_STUB IDynamicStorage_EnumItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDynamicStorage_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0313 */
/* [local] */ 

#define STRESPONSE_CONTINUE               S_OK
#define STRESPONSE_RENAME                 MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 20)
#define STRESPONSE_SKIP                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 21)
#define STRESPONSE_CANCEL                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 22)
#define STRESPONSE_RETRY                  HRESULT_FROM_WIN32(ERROR_RETRY)


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0313_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0313_v0_0_s_ifspec;

#ifndef __ITransferAdviseSink_INTERFACE_DEFINED__
#define __ITransferAdviseSink_INTERFACE_DEFINED__

/* interface ITransferAdviseSink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ITransferAdviseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D082C196-A2B2-41ff-A5E5-80EFF91B7D79")
    ITransferAdviseSink : public IQueryContinue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PreOperation( 
            /* [in] */ const STGOP op,
            /* [in] */ IShellItem *psiItem,
            /* [in] */ IShellItem *psiDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfirmOperation( 
            /* [in] */ IShellItem *psiItem,
            /* [in] */ IShellItem *psiDest,
            /* [in] */ STGTRANSCONFIRMATION stc,
            /* [unique][in] */ LPCUSTOMCONFIRMATION pcc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OperationProgress( 
            /* [in] */ const STGOP op,
            /* [in] */ IShellItem *psiItem,
            /* [in] */ IShellItem *psiDest,
            /* [in] */ ULONGLONG ulTotal,
            /* [in] */ ULONGLONG ulComplete) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PostOperation( 
            /* [in] */ const STGOP op,
            /* [in] */ IShellItem *psiItem,
            /* [in] */ IShellItem *psiDest,
            /* [in] */ HRESULT hrResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransferAdviseSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransferAdviseSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransferAdviseSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransferAdviseSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryContinue )( 
            ITransferAdviseSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *PreOperation )( 
            ITransferAdviseSink * This,
            /* [in] */ const STGOP op,
            /* [in] */ IShellItem *psiItem,
            /* [in] */ IShellItem *psiDest);
        
        HRESULT ( STDMETHODCALLTYPE *ConfirmOperation )( 
            ITransferAdviseSink * This,
            /* [in] */ IShellItem *psiItem,
            /* [in] */ IShellItem *psiDest,
            /* [in] */ STGTRANSCONFIRMATION stc,
            /* [unique][in] */ LPCUSTOMCONFIRMATION pcc);
        
        HRESULT ( STDMETHODCALLTYPE *OperationProgress )( 
            ITransferAdviseSink * This,
            /* [in] */ const STGOP op,
            /* [in] */ IShellItem *psiItem,
            /* [in] */ IShellItem *psiDest,
            /* [in] */ ULONGLONG ulTotal,
            /* [in] */ ULONGLONG ulComplete);
        
        HRESULT ( STDMETHODCALLTYPE *PostOperation )( 
            ITransferAdviseSink * This,
            /* [in] */ const STGOP op,
            /* [in] */ IShellItem *psiItem,
            /* [in] */ IShellItem *psiDest,
            /* [in] */ HRESULT hrResult);
        
        END_INTERFACE
    } ITransferAdviseSinkVtbl;

    interface ITransferAdviseSink
    {
        CONST_VTBL struct ITransferAdviseSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransferAdviseSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransferAdviseSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransferAdviseSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransferAdviseSink_QueryContinue(This)	\
    (This)->lpVtbl -> QueryContinue(This)


#define ITransferAdviseSink_PreOperation(This,op,psiItem,psiDest)	\
    (This)->lpVtbl -> PreOperation(This,op,psiItem,psiDest)

#define ITransferAdviseSink_ConfirmOperation(This,psiItem,psiDest,stc,pcc)	\
    (This)->lpVtbl -> ConfirmOperation(This,psiItem,psiDest,stc,pcc)

#define ITransferAdviseSink_OperationProgress(This,op,psiItem,psiDest,ulTotal,ulComplete)	\
    (This)->lpVtbl -> OperationProgress(This,op,psiItem,psiDest,ulTotal,ulComplete)

#define ITransferAdviseSink_PostOperation(This,op,psiItem,psiDest,hrResult)	\
    (This)->lpVtbl -> PostOperation(This,op,psiItem,psiDest,hrResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransferAdviseSink_PreOperation_Proxy( 
    ITransferAdviseSink * This,
    /* [in] */ const STGOP op,
    /* [in] */ IShellItem *psiItem,
    /* [in] */ IShellItem *psiDest);


void __RPC_STUB ITransferAdviseSink_PreOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransferAdviseSink_ConfirmOperation_Proxy( 
    ITransferAdviseSink * This,
    /* [in] */ IShellItem *psiItem,
    /* [in] */ IShellItem *psiDest,
    /* [in] */ STGTRANSCONFIRMATION stc,
    /* [unique][in] */ LPCUSTOMCONFIRMATION pcc);


void __RPC_STUB ITransferAdviseSink_ConfirmOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransferAdviseSink_OperationProgress_Proxy( 
    ITransferAdviseSink * This,
    /* [in] */ const STGOP op,
    /* [in] */ IShellItem *psiItem,
    /* [in] */ IShellItem *psiDest,
    /* [in] */ ULONGLONG ulTotal,
    /* [in] */ ULONGLONG ulComplete);


void __RPC_STUB ITransferAdviseSink_OperationProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransferAdviseSink_PostOperation_Proxy( 
    ITransferAdviseSink * This,
    /* [in] */ const STGOP op,
    /* [in] */ IShellItem *psiItem,
    /* [in] */ IShellItem *psiDest,
    /* [in] */ HRESULT hrResult);


void __RPC_STUB ITransferAdviseSink_PostOperation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransferAdviseSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0314 */
/* [local] */ 

#define STGX_MOVE_MOVE           0x00000000
#define STGX_MOVE_COPY           0x00000001
#define STGX_MOVE_ONLYIFEXISTS   0x00000002   // Only perform if target already exists
#define STGX_MOVE_ATOMIC         0x00000004   // Operation must be immediate, all-or-nothing.  If a storage must be walked and each sub-element moved/copied that is not atomic, but if the entire storage can be moved/copied in one step that is atomic.  If a move must be done as a seperate copy and a delete that is not atomic.
#define STGX_MOVE_TESTONLY       0x00000008   // Test whether operation is valid only, do not perform.  Useful in testing for ATOMIC before trying an operation.
#define STGX_MOVE_NORECURSION    0x00000010   // When moving/copying storages, do not move/copy their contents
#define STGX_MOVE_FORCE          0x00001000
#define STGX_MOVE_PREFERHARDLINK 0x00002000   // default to hard linking instead of a full file copy/move
typedef DWORD STGXMOVE;

#define STGX_MODE_READ               0x00000000L
#define STGX_MODE_WRITE              0x00000001L
#define STGX_MODE_READWRITE          0x00000002L
#define STGX_MODE_ACCESSMASK         0x0000000FL
#define STGX_MODE_SHARE_DENY_NONE    0x00000040L
#define STGX_MODE_SHARE_DENY_READ    0x00000030L
#define STGX_MODE_SHARE_DENY_WRITE   0x00000020L
#define STGX_MODE_SHARE_EXCLUSIVE    0x00000010L
#define STGX_MODE_SHAREMASK          0x000000F0L
#define STGX_MODE_OPEN               0x00000100L   // default is to open an existing item and fail if its not there
#define STGX_MODE_CREATE             0x00000200L   // Create a new item.  If an old item has the same name delete it first.
#define STGX_MODE_FAILIFTHERE        0x00000400L   // Use with CREATE. Create a new item but fail if an item with that name already exists.
#define STGX_MODE_OPENEXISTING       0x00000800L   // Use with CREATE. If the item already exists open the item, otherwise create the item.
#define STGX_MODE_CREATIONMASK       0x00000F00L
#define STGX_MODE_FORCE            0x00001000
typedef DWORD STGXMODE;

#define STGX_DESTROY_FORCE               0x00001000
typedef DWORD STGXDESTROY;

typedef /* [v1_enum] */ 
enum tagSTGXTYPE
    {	STGX_TYPE_ANY	= 0L,
	STGX_TYPE_STORAGE	= 0x1L,
	STGX_TYPE_STREAM	= 0x2L
    } 	STGXTYPE;

#define STGX_E_INCORRECTTYPE                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_STORAGE, 0x300) // Tried to open a storage/stream but a stream.storage with the same name already exists
#define STGX_E_NOADVISESINK                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_STORAGE, 0x301) // Needed to confirm something but no advise sink was set
#define STGX_E_CANNOTRECURSE                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_STORAGE, 0x302) // A move or copy of a storage failed to recurse.  The storage itself was copied, but none of its contents were.


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0314_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0314_v0_0_s_ifspec;

#ifndef __ITransferDest_INTERFACE_DEFINED__
#define __ITransferDest_INTERFACE_DEFINED__

/* interface ITransferDest */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ITransferDest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FE3A135-2915-493b-A8EE-3AB21982776C")
    ITransferDest : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ ITransferAdviseSink *pAdvise,
            /* [retval][out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenElement( 
            /* [string][in] */ const WCHAR *pwcsName,
            /* [in] */ STGXMODE grfMode,
            /* [out][in] */ DWORD *pdwType,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateElement( 
            /* [string][in] */ const WCHAR *pwcsName,
            /* [in] */ IShellItem *psiTemplate,
            /* [in] */ STGXMODE grfMode,
            /* [in] */ DWORD dwType,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppunk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveElement( 
            /* [in] */ IShellItem *psiItem,
            /* [string][in] */ WCHAR *pwcsNewName,
            /* [in] */ STGXMOVE grfOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyElement( 
            /* [string][in] */ const WCHAR *pwcsName,
            /* [in] */ STGXDESTROY grfOptions) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransferDestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransferDest * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransferDest * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransferDest * This);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            ITransferDest * This,
            /* [in] */ ITransferAdviseSink *pAdvise,
            /* [retval][out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            ITransferDest * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *OpenElement )( 
            ITransferDest * This,
            /* [string][in] */ const WCHAR *pwcsName,
            /* [in] */ STGXMODE grfMode,
            /* [out][in] */ DWORD *pdwType,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *CreateElement )( 
            ITransferDest * This,
            /* [string][in] */ const WCHAR *pwcsName,
            /* [in] */ IShellItem *psiTemplate,
            /* [in] */ STGXMODE grfMode,
            /* [in] */ DWORD dwType,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppunk);
        
        HRESULT ( STDMETHODCALLTYPE *MoveElement )( 
            ITransferDest * This,
            /* [in] */ IShellItem *psiItem,
            /* [string][in] */ WCHAR *pwcsNewName,
            /* [in] */ STGXMOVE grfOptions);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyElement )( 
            ITransferDest * This,
            /* [string][in] */ const WCHAR *pwcsName,
            /* [in] */ STGXDESTROY grfOptions);
        
        END_INTERFACE
    } ITransferDestVtbl;

    interface ITransferDest
    {
        CONST_VTBL struct ITransferDestVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransferDest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransferDest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransferDest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransferDest_Advise(This,pAdvise,pdwCookie)	\
    (This)->lpVtbl -> Advise(This,pAdvise,pdwCookie)

#define ITransferDest_Unadvise(This,dwCookie)	\
    (This)->lpVtbl -> Unadvise(This,dwCookie)

#define ITransferDest_OpenElement(This,pwcsName,grfMode,pdwType,riid,ppunk)	\
    (This)->lpVtbl -> OpenElement(This,pwcsName,grfMode,pdwType,riid,ppunk)

#define ITransferDest_CreateElement(This,pwcsName,psiTemplate,grfMode,dwType,riid,ppunk)	\
    (This)->lpVtbl -> CreateElement(This,pwcsName,psiTemplate,grfMode,dwType,riid,ppunk)

#define ITransferDest_MoveElement(This,psiItem,pwcsNewName,grfOptions)	\
    (This)->lpVtbl -> MoveElement(This,psiItem,pwcsNewName,grfOptions)

#define ITransferDest_DestroyElement(This,pwcsName,grfOptions)	\
    (This)->lpVtbl -> DestroyElement(This,pwcsName,grfOptions)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransferDest_Advise_Proxy( 
    ITransferDest * This,
    /* [in] */ ITransferAdviseSink *pAdvise,
    /* [retval][out] */ DWORD *pdwCookie);


void __RPC_STUB ITransferDest_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransferDest_Unadvise_Proxy( 
    ITransferDest * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB ITransferDest_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransferDest_OpenElement_Proxy( 
    ITransferDest * This,
    /* [string][in] */ const WCHAR *pwcsName,
    /* [in] */ STGXMODE grfMode,
    /* [out][in] */ DWORD *pdwType,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppunk);


void __RPC_STUB ITransferDest_OpenElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransferDest_CreateElement_Proxy( 
    ITransferDest * This,
    /* [string][in] */ const WCHAR *pwcsName,
    /* [in] */ IShellItem *psiTemplate,
    /* [in] */ STGXMODE grfMode,
    /* [in] */ DWORD dwType,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppunk);


void __RPC_STUB ITransferDest_CreateElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransferDest_MoveElement_Proxy( 
    ITransferDest * This,
    /* [in] */ IShellItem *psiItem,
    /* [string][in] */ WCHAR *pwcsNewName,
    /* [in] */ STGXMOVE grfOptions);


void __RPC_STUB ITransferDest_MoveElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITransferDest_DestroyElement_Proxy( 
    ITransferDest * This,
    /* [string][in] */ const WCHAR *pwcsName,
    /* [in] */ STGXDESTROY grfOptions);


void __RPC_STUB ITransferDest_DestroyElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransferDest_INTERFACE_DEFINED__ */


#ifndef __IStorageProcessor_INTERFACE_DEFINED__
#define __IStorageProcessor_INTERFACE_DEFINED__

/* interface IStorageProcessor */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IStorageProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5AE334C5-06DD-4321-B44F-63B1D23F2E57")
    IStorageProcessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Advise( 
            /* [in] */ ITransferAdviseSink *pAdvise,
            /* [retval][out] */ DWORD *dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Unadvise( 
            /* [in] */ DWORD dwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ IEnumShellItems *penum,
            /* [in] */ IShellItem *psiDest,
            /* [in] */ STGOP dwOperation,
            /* [in] */ DWORD dwOptions) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetProgress( 
            /* [in] */ IActionProgress *pap) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStorageProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStorageProcessor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStorageProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStorageProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Advise )( 
            IStorageProcessor * This,
            /* [in] */ ITransferAdviseSink *pAdvise,
            /* [retval][out] */ DWORD *dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Unadvise )( 
            IStorageProcessor * This,
            /* [in] */ DWORD dwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            IStorageProcessor * This,
            /* [in] */ IEnumShellItems *penum,
            /* [in] */ IShellItem *psiDest,
            /* [in] */ STGOP dwOperation,
            /* [in] */ DWORD dwOptions);
        
        HRESULT ( STDMETHODCALLTYPE *SetProgress )( 
            IStorageProcessor * This,
            /* [in] */ IActionProgress *pap);
        
        END_INTERFACE
    } IStorageProcessorVtbl;

    interface IStorageProcessor
    {
        CONST_VTBL struct IStorageProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStorageProcessor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStorageProcessor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStorageProcessor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStorageProcessor_Advise(This,pAdvise,dwCookie)	\
    (This)->lpVtbl -> Advise(This,pAdvise,dwCookie)

#define IStorageProcessor_Unadvise(This,dwCookie)	\
    (This)->lpVtbl -> Unadvise(This,dwCookie)

#define IStorageProcessor_Run(This,penum,psiDest,dwOperation,dwOptions)	\
    (This)->lpVtbl -> Run(This,penum,psiDest,dwOperation,dwOptions)

#define IStorageProcessor_SetProgress(This,pap)	\
    (This)->lpVtbl -> SetProgress(This,pap)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IStorageProcessor_Advise_Proxy( 
    IStorageProcessor * This,
    /* [in] */ ITransferAdviseSink *pAdvise,
    /* [retval][out] */ DWORD *dwCookie);


void __RPC_STUB IStorageProcessor_Advise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStorageProcessor_Unadvise_Proxy( 
    IStorageProcessor * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IStorageProcessor_Unadvise_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStorageProcessor_Run_Proxy( 
    IStorageProcessor * This,
    /* [in] */ IEnumShellItems *penum,
    /* [in] */ IShellItem *psiDest,
    /* [in] */ STGOP dwOperation,
    /* [in] */ DWORD dwOptions);


void __RPC_STUB IStorageProcessor_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IStorageProcessor_SetProgress_Proxy( 
    IStorageProcessor * This,
    /* [in] */ IActionProgress *pap);


void __RPC_STUB IStorageProcessor_SetProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStorageProcessor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0316 */
/* [local] */ 

#define CCF_SHOW_SOURCE_INFO        0x00000001   // if set, information about the source will be shown. Information will be gotten from IShellFolder if possible, or a STATSTG structure otherwise.
#define CCF_SHOW_DESTINATION_INFO   0x00000002   // If set, information about the destination will be shown. Information will be gotten from IShellFolder if possible, or a STATSTG structure otherwise.
#define CCF_USE_DEFAULT_ICON        0x00000004   // If set, hicon is ignored and a default is selected based on the current operation.
#define CCB_YES_SKIP_CANCEL            1
#define CCB_RENAME_SKIP_CANCEL         2
#define CCB_YES_SKIP_RENAME_CANCEL     3
#define CCB_RETRY_SKIP_CANCEL          4
#define CCB_OK                         5
typedef /* [v1_enum] */ 
enum tagCONFIRMATIONRESPONSE
    {	CONFRES_CONTINUE	= 0,
	CONFRES_SKIP	= 0x1,
	CONFRES_RETRY	= 0x2,
	CONFRES_RENAME	= 0x3,
	CONFRES_CANCEL	= 0x4,
	CONFRES_UNDO	= 0x5
    } 	CONFIRMATIONRESPONSE;

typedef /* [v1_enum] */ enum tagCONFIRMATIONRESPONSE *LPCONFIRMATIONRESPONSE;

typedef struct tagCONFIRMOP
    {
    STGOP dwOperation;
    STGTRANSCONFIRMATION stc;
    CUSTOMCONFIRMATION *pcc;
    UINT cRemaining;
    IShellItem *psiItem;
    IShellItem *psiDest;
    LPCWSTR pwszRenameTo;
    IUnknown *punkSite;
    } 	CONFIRMOP;

typedef struct tagCONFIRMOP *PCONFIRMOP;



extern RPC_IF_HANDLE __MIDL_itf_shpriv_0316_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0316_v0_0_s_ifspec;

#ifndef __ITransferConfirmation_INTERFACE_DEFINED__
#define __ITransferConfirmation_INTERFACE_DEFINED__

/* interface ITransferConfirmation */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ITransferConfirmation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FC45985F-07F8-48E3-894C-7DEE8ED66EE5")
    ITransferConfirmation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Confirm( 
            /* [in] */ CONFIRMOP *pcop,
            /* [out] */ LPCONFIRMATIONRESPONSE pcr,
            /* [out] */ BOOL *pbAll) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITransferConfirmationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITransferConfirmation * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITransferConfirmation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITransferConfirmation * This);
        
        HRESULT ( STDMETHODCALLTYPE *Confirm )( 
            ITransferConfirmation * This,
            /* [in] */ CONFIRMOP *pcop,
            /* [out] */ LPCONFIRMATIONRESPONSE pcr,
            /* [out] */ BOOL *pbAll);
        
        END_INTERFACE
    } ITransferConfirmationVtbl;

    interface ITransferConfirmation
    {
        CONST_VTBL struct ITransferConfirmationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITransferConfirmation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITransferConfirmation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITransferConfirmation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITransferConfirmation_Confirm(This,pcop,pcr,pbAll)	\
    (This)->lpVtbl -> Confirm(This,pcop,pcr,pbAll)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITransferConfirmation_Confirm_Proxy( 
    ITransferConfirmation * This,
    /* [in] */ CONFIRMOP *pcop,
    /* [out] */ LPCONFIRMATIONRESPONSE pcr,
    /* [out] */ BOOL *pbAll);


void __RPC_STUB ITransferConfirmation_Confirm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITransferConfirmation_INTERFACE_DEFINED__ */


#ifndef __ICDBurnPriv_INTERFACE_DEFINED__
#define __ICDBurnPriv_INTERFACE_DEFINED__

/* interface ICDBurnPriv */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ICDBurnPriv;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c3d92d66-68ad-4b2a-86f5-4dfe97fbd2c7")
    ICDBurnPriv : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMediaCapabilities( 
            /* [out] */ DWORD *pdwCaps,
            /* [out] */ BOOL *pfUDF) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContentState( 
            /* [out] */ BOOL *pfStagingHasFiles,
            /* [out] */ BOOL *pfDiscHasFiles) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsWizardUp( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICDBurnPrivVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICDBurnPriv * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICDBurnPriv * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICDBurnPriv * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaCapabilities )( 
            ICDBurnPriv * This,
            /* [out] */ DWORD *pdwCaps,
            /* [out] */ BOOL *pfUDF);
        
        HRESULT ( STDMETHODCALLTYPE *GetContentState )( 
            ICDBurnPriv * This,
            /* [out] */ BOOL *pfStagingHasFiles,
            /* [out] */ BOOL *pfDiscHasFiles);
        
        HRESULT ( STDMETHODCALLTYPE *IsWizardUp )( 
            ICDBurnPriv * This);
        
        END_INTERFACE
    } ICDBurnPrivVtbl;

    interface ICDBurnPriv
    {
        CONST_VTBL struct ICDBurnPrivVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICDBurnPriv_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICDBurnPriv_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICDBurnPriv_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICDBurnPriv_GetMediaCapabilities(This,pdwCaps,pfUDF)	\
    (This)->lpVtbl -> GetMediaCapabilities(This,pdwCaps,pfUDF)

#define ICDBurnPriv_GetContentState(This,pfStagingHasFiles,pfDiscHasFiles)	\
    (This)->lpVtbl -> GetContentState(This,pfStagingHasFiles,pfDiscHasFiles)

#define ICDBurnPriv_IsWizardUp(This)	\
    (This)->lpVtbl -> IsWizardUp(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICDBurnPriv_GetMediaCapabilities_Proxy( 
    ICDBurnPriv * This,
    /* [out] */ DWORD *pdwCaps,
    /* [out] */ BOOL *pfUDF);


void __RPC_STUB ICDBurnPriv_GetMediaCapabilities_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICDBurnPriv_GetContentState_Proxy( 
    ICDBurnPriv * This,
    /* [out] */ BOOL *pfStagingHasFiles,
    /* [out] */ BOOL *pfDiscHasFiles);


void __RPC_STUB ICDBurnPriv_GetContentState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICDBurnPriv_IsWizardUp_Proxy( 
    ICDBurnPriv * This);


void __RPC_STUB ICDBurnPriv_IsWizardUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICDBurnPriv_INTERFACE_DEFINED__ */


#ifndef __IDriveFolderExt_INTERFACE_DEFINED__
#define __IDriveFolderExt_INTERFACE_DEFINED__

/* interface IDriveFolderExt */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_IDriveFolderExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98467961-4f27-4a1f-9629-22b06d0b5ccb")
    IDriveFolderExt : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DriveMatches( 
            /* [in] */ int iDrive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Bind( 
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ IBindCtx *pbc,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSpace( 
            /* [out] */ ULONGLONG *pcbTotal,
            /* [out] */ ULONGLONG *pcbFree) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDriveFolderExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDriveFolderExt * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDriveFolderExt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDriveFolderExt * This);
        
        HRESULT ( STDMETHODCALLTYPE *DriveMatches )( 
            IDriveFolderExt * This,
            /* [in] */ int iDrive);
        
        HRESULT ( STDMETHODCALLTYPE *Bind )( 
            IDriveFolderExt * This,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [in] */ IBindCtx *pbc,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        HRESULT ( STDMETHODCALLTYPE *GetSpace )( 
            IDriveFolderExt * This,
            /* [out] */ ULONGLONG *pcbTotal,
            /* [out] */ ULONGLONG *pcbFree);
        
        END_INTERFACE
    } IDriveFolderExtVtbl;

    interface IDriveFolderExt
    {
        CONST_VTBL struct IDriveFolderExtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDriveFolderExt_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDriveFolderExt_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDriveFolderExt_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDriveFolderExt_DriveMatches(This,iDrive)	\
    (This)->lpVtbl -> DriveMatches(This,iDrive)

#define IDriveFolderExt_Bind(This,pidl,pbc,riid,ppv)	\
    (This)->lpVtbl -> Bind(This,pidl,pbc,riid,ppv)

#define IDriveFolderExt_GetSpace(This,pcbTotal,pcbFree)	\
    (This)->lpVtbl -> GetSpace(This,pcbTotal,pcbFree)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDriveFolderExt_DriveMatches_Proxy( 
    IDriveFolderExt * This,
    /* [in] */ int iDrive);


void __RPC_STUB IDriveFolderExt_DriveMatches_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDriveFolderExt_Bind_Proxy( 
    IDriveFolderExt * This,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [in] */ IBindCtx *pbc,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IDriveFolderExt_Bind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDriveFolderExt_GetSpace_Proxy( 
    IDriveFolderExt * This,
    /* [out] */ ULONGLONG *pcbTotal,
    /* [out] */ ULONGLONG *pcbFree);


void __RPC_STUB IDriveFolderExt_GetSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDriveFolderExt_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0319 */
/* [local] */ 

#if _WIN32_IE >= 0x0600


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0319_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0319_v0_0_s_ifspec;

#ifndef __ICustomizeInfoTip_INTERFACE_DEFINED__
#define __ICustomizeInfoTip_INTERFACE_DEFINED__

/* interface ICustomizeInfoTip */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ICustomizeInfoTip;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("da22171f-70b4-43db-b38f-296741d1494c")
    ICustomizeInfoTip : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetPrefixText( 
            /* [string][in] */ LPCWSTR pszPrefix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetExtraProperties( 
            /* [size_is][in] */ const SHCOLUMNID *pscid,
            /* [in] */ UINT cscid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICustomizeInfoTipVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICustomizeInfoTip * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICustomizeInfoTip * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICustomizeInfoTip * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetPrefixText )( 
            ICustomizeInfoTip * This,
            /* [string][in] */ LPCWSTR pszPrefix);
        
        HRESULT ( STDMETHODCALLTYPE *SetExtraProperties )( 
            ICustomizeInfoTip * This,
            /* [size_is][in] */ const SHCOLUMNID *pscid,
            /* [in] */ UINT cscid);
        
        END_INTERFACE
    } ICustomizeInfoTipVtbl;

    interface ICustomizeInfoTip
    {
        CONST_VTBL struct ICustomizeInfoTipVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICustomizeInfoTip_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICustomizeInfoTip_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICustomizeInfoTip_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICustomizeInfoTip_SetPrefixText(This,pszPrefix)	\
    (This)->lpVtbl -> SetPrefixText(This,pszPrefix)

#define ICustomizeInfoTip_SetExtraProperties(This,pscid,cscid)	\
    (This)->lpVtbl -> SetExtraProperties(This,pscid,cscid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICustomizeInfoTip_SetPrefixText_Proxy( 
    ICustomizeInfoTip * This,
    /* [string][in] */ LPCWSTR pszPrefix);


void __RPC_STUB ICustomizeInfoTip_SetPrefixText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICustomizeInfoTip_SetExtraProperties_Proxy( 
    ICustomizeInfoTip * This,
    /* [size_is][in] */ const SHCOLUMNID *pscid,
    /* [in] */ UINT cscid);


void __RPC_STUB ICustomizeInfoTip_SetExtraProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICustomizeInfoTip_INTERFACE_DEFINED__ */


#ifndef __IFadeTask_INTERFACE_DEFINED__
#define __IFadeTask_INTERFACE_DEFINED__

/* interface IFadeTask */
/* [object][local][helpstring][uuid] */ 


EXTERN_C const IID IID_IFadeTask;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fadb55b4-d382-4fc4-81d7-abb325c7f12a")
    IFadeTask : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FadeRect( 
            /* [in] */ LPCRECT prc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFadeTaskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IFadeTask * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IFadeTask * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IFadeTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *FadeRect )( 
            IFadeTask * This,
            /* [in] */ LPCRECT prc);
        
        END_INTERFACE
    } IFadeTaskVtbl;

    interface IFadeTask
    {
        CONST_VTBL struct IFadeTaskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFadeTask_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IFadeTask_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IFadeTask_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IFadeTask_FadeRect(This,prc)	\
    (This)->lpVtbl -> FadeRect(This,prc)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IFadeTask_FadeRect_Proxy( 
    IFadeTask * This,
    /* [in] */ LPCRECT prc);


void __RPC_STUB IFadeTask_FadeRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IFadeTask_INTERFACE_DEFINED__ */


#ifndef __ISetFolderEnumRestriction_INTERFACE_DEFINED__
#define __ISetFolderEnumRestriction_INTERFACE_DEFINED__

/* interface ISetFolderEnumRestriction */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_ISetFolderEnumRestriction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("76347b91-9846-4ce7-9a57-69b910d16123")
    ISetFolderEnumRestriction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetEnumRestriction( 
            DWORD dwRequired,
            DWORD dwForbidden) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISetFolderEnumRestrictionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISetFolderEnumRestriction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISetFolderEnumRestriction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISetFolderEnumRestriction * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnumRestriction )( 
            ISetFolderEnumRestriction * This,
            DWORD dwRequired,
            DWORD dwForbidden);
        
        END_INTERFACE
    } ISetFolderEnumRestrictionVtbl;

    interface ISetFolderEnumRestriction
    {
        CONST_VTBL struct ISetFolderEnumRestrictionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISetFolderEnumRestriction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISetFolderEnumRestriction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISetFolderEnumRestriction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISetFolderEnumRestriction_SetEnumRestriction(This,dwRequired,dwForbidden)	\
    (This)->lpVtbl -> SetEnumRestriction(This,dwRequired,dwForbidden)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISetFolderEnumRestriction_SetEnumRestriction_Proxy( 
    ISetFolderEnumRestriction * This,
    DWORD dwRequired,
    DWORD dwForbidden);


void __RPC_STUB ISetFolderEnumRestriction_SetEnumRestriction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISetFolderEnumRestriction_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0322 */
/* [local] */ 

#endif // _WIN32_IE >= 0x0600


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0322_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0322_v0_0_s_ifspec;

#ifndef __IObjectWithRegistryKey_INTERFACE_DEFINED__
#define __IObjectWithRegistryKey_INTERFACE_DEFINED__

/* interface IObjectWithRegistryKey */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IObjectWithRegistryKey;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5747C63F-1DE8-423f-980F-00CB07F4C45B")
    IObjectWithRegistryKey : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetKey( 
            /* [in] */ HKEY hk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKey( 
            /* [out] */ HKEY *phk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithRegistryKeyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectWithRegistryKey * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectWithRegistryKey * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectWithRegistryKey * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetKey )( 
            IObjectWithRegistryKey * This,
            /* [in] */ HKEY hk);
        
        HRESULT ( STDMETHODCALLTYPE *GetKey )( 
            IObjectWithRegistryKey * This,
            /* [out] */ HKEY *phk);
        
        END_INTERFACE
    } IObjectWithRegistryKeyVtbl;

    interface IObjectWithRegistryKey
    {
        CONST_VTBL struct IObjectWithRegistryKeyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithRegistryKey_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectWithRegistryKey_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectWithRegistryKey_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectWithRegistryKey_SetKey(This,hk)	\
    (This)->lpVtbl -> SetKey(This,hk)

#define IObjectWithRegistryKey_GetKey(This,phk)	\
    (This)->lpVtbl -> GetKey(This,phk)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectWithRegistryKey_SetKey_Proxy( 
    IObjectWithRegistryKey * This,
    /* [in] */ HKEY hk);


void __RPC_STUB IObjectWithRegistryKey_SetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectWithRegistryKey_GetKey_Proxy( 
    IObjectWithRegistryKey * This,
    /* [out] */ HKEY *phk);


void __RPC_STUB IObjectWithRegistryKey_GetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectWithRegistryKey_INTERFACE_DEFINED__ */


#ifndef __IQuerySource_INTERFACE_DEFINED__
#define __IQuerySource_INTERFACE_DEFINED__

/* interface IQuerySource */
/* [unique][uuid][object] */ 

/* [v1_enum] */ 
enum __MIDL_IQuerySource_0001
    {	QVT_EMPTY	= 0,
	QVT_STRING	= 1,
	QVT_EXPANDABLE_STRING	= 2,
	QVT_BINARY	= 3,
	QVT_DWORD	= 4,
	QVT_MULTI_STRING	= 7
    } ;

EXTERN_C const IID IID_IQuerySource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c7478486-7583-49e7-a6c2-faf8f02bc30e")
    IQuerySource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumValues( 
            /* [out] */ IEnumString **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumSources( 
            /* [out] */ IEnumString **ppenum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryValueString( 
            /* [string][in] */ LPCWSTR pszSubSource,
            /* [string][in] */ LPCWSTR pszValue,
            /* [string][out] */ LPWSTR *ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryValueDword( 
            /* [string][in] */ LPCWSTR pszSubSource,
            /* [string][in] */ LPCWSTR pszValue,
            /* [out] */ DWORD *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryValueExists( 
            /* [string][in] */ LPCWSTR pszSubSource,
            /* [string][in] */ LPCWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryValueDirect( 
            /* [string][in] */ LPCWSTR pszSubSource,
            /* [string][in] */ LPCWSTR pszValue,
            /* [out] */ FLAGGED_BYTE_BLOB **ppblob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenSource( 
            /* [in] */ LPCWSTR pszSubSource,
            /* [in] */ BOOL fCreate,
            /* [out] */ IQuerySource **ppqs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueDirect( 
            /* [string][in] */ LPCWSTR pszSubSource,
            /* [string][in] */ LPCWSTR pszValue,
            /* [in] */ ULONG qvt,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE *pbData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQuerySourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQuerySource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQuerySource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQuerySource * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumValues )( 
            IQuerySource * This,
            /* [out] */ IEnumString **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumSources )( 
            IQuerySource * This,
            /* [out] */ IEnumString **ppenum);
        
        HRESULT ( STDMETHODCALLTYPE *QueryValueString )( 
            IQuerySource * This,
            /* [string][in] */ LPCWSTR pszSubSource,
            /* [string][in] */ LPCWSTR pszValue,
            /* [string][out] */ LPWSTR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *QueryValueDword )( 
            IQuerySource * This,
            /* [string][in] */ LPCWSTR pszSubSource,
            /* [string][in] */ LPCWSTR pszValue,
            /* [out] */ DWORD *pdw);
        
        HRESULT ( STDMETHODCALLTYPE *QueryValueExists )( 
            IQuerySource * This,
            /* [string][in] */ LPCWSTR pszSubSource,
            /* [string][in] */ LPCWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE *QueryValueDirect )( 
            IQuerySource * This,
            /* [string][in] */ LPCWSTR pszSubSource,
            /* [string][in] */ LPCWSTR pszValue,
            /* [out] */ FLAGGED_BYTE_BLOB **ppblob);
        
        HRESULT ( STDMETHODCALLTYPE *OpenSource )( 
            IQuerySource * This,
            /* [in] */ LPCWSTR pszSubSource,
            /* [in] */ BOOL fCreate,
            /* [out] */ IQuerySource **ppqs);
        
        HRESULT ( STDMETHODCALLTYPE *SetValueDirect )( 
            IQuerySource * This,
            /* [string][in] */ LPCWSTR pszSubSource,
            /* [string][in] */ LPCWSTR pszValue,
            /* [in] */ ULONG qvt,
            /* [in] */ DWORD cbData,
            /* [size_is][in] */ BYTE *pbData);
        
        END_INTERFACE
    } IQuerySourceVtbl;

    interface IQuerySource
    {
        CONST_VTBL struct IQuerySourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQuerySource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQuerySource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IQuerySource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IQuerySource_EnumValues(This,ppenum)	\
    (This)->lpVtbl -> EnumValues(This,ppenum)

#define IQuerySource_EnumSources(This,ppenum)	\
    (This)->lpVtbl -> EnumSources(This,ppenum)

#define IQuerySource_QueryValueString(This,pszSubSource,pszValue,ppsz)	\
    (This)->lpVtbl -> QueryValueString(This,pszSubSource,pszValue,ppsz)

#define IQuerySource_QueryValueDword(This,pszSubSource,pszValue,pdw)	\
    (This)->lpVtbl -> QueryValueDword(This,pszSubSource,pszValue,pdw)

#define IQuerySource_QueryValueExists(This,pszSubSource,pszValue)	\
    (This)->lpVtbl -> QueryValueExists(This,pszSubSource,pszValue)

#define IQuerySource_QueryValueDirect(This,pszSubSource,pszValue,ppblob)	\
    (This)->lpVtbl -> QueryValueDirect(This,pszSubSource,pszValue,ppblob)

#define IQuerySource_OpenSource(This,pszSubSource,fCreate,ppqs)	\
    (This)->lpVtbl -> OpenSource(This,pszSubSource,fCreate,ppqs)

#define IQuerySource_SetValueDirect(This,pszSubSource,pszValue,qvt,cbData,pbData)	\
    (This)->lpVtbl -> SetValueDirect(This,pszSubSource,pszValue,qvt,cbData,pbData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IQuerySource_EnumValues_Proxy( 
    IQuerySource * This,
    /* [out] */ IEnumString **ppenum);


void __RPC_STUB IQuerySource_EnumValues_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQuerySource_EnumSources_Proxy( 
    IQuerySource * This,
    /* [out] */ IEnumString **ppenum);


void __RPC_STUB IQuerySource_EnumSources_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQuerySource_QueryValueString_Proxy( 
    IQuerySource * This,
    /* [string][in] */ LPCWSTR pszSubSource,
    /* [string][in] */ LPCWSTR pszValue,
    /* [string][out] */ LPWSTR *ppsz);


void __RPC_STUB IQuerySource_QueryValueString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQuerySource_QueryValueDword_Proxy( 
    IQuerySource * This,
    /* [string][in] */ LPCWSTR pszSubSource,
    /* [string][in] */ LPCWSTR pszValue,
    /* [out] */ DWORD *pdw);


void __RPC_STUB IQuerySource_QueryValueDword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQuerySource_QueryValueExists_Proxy( 
    IQuerySource * This,
    /* [string][in] */ LPCWSTR pszSubSource,
    /* [string][in] */ LPCWSTR pszValue);


void __RPC_STUB IQuerySource_QueryValueExists_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQuerySource_QueryValueDirect_Proxy( 
    IQuerySource * This,
    /* [string][in] */ LPCWSTR pszSubSource,
    /* [string][in] */ LPCWSTR pszValue,
    /* [out] */ FLAGGED_BYTE_BLOB **ppblob);


void __RPC_STUB IQuerySource_QueryValueDirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQuerySource_OpenSource_Proxy( 
    IQuerySource * This,
    /* [in] */ LPCWSTR pszSubSource,
    /* [in] */ BOOL fCreate,
    /* [out] */ IQuerySource **ppqs);


void __RPC_STUB IQuerySource_OpenSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IQuerySource_SetValueDirect_Proxy( 
    IQuerySource * This,
    /* [string][in] */ LPCWSTR pszSubSource,
    /* [string][in] */ LPCWSTR pszValue,
    /* [in] */ ULONG qvt,
    /* [in] */ DWORD cbData,
    /* [size_is][in] */ BYTE *pbData);


void __RPC_STUB IQuerySource_SetValueDirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IQuerySource_INTERFACE_DEFINED__ */


#ifndef __IPersistString2_INTERFACE_DEFINED__
#define __IPersistString2_INTERFACE_DEFINED__

/* interface IPersistString2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IPersistString2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3c44ba76-de0e-4049-b6e4-6b31a5262707")
    IPersistString2 : public IPersist
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetString( 
            /* [string][in] */ LPCWSTR psz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [string][out] */ LPWSTR *ppsz) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPersistString2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPersistString2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPersistString2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPersistString2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassID )( 
            IPersistString2 * This,
            /* [out] */ CLSID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *SetString )( 
            IPersistString2 * This,
            /* [string][in] */ LPCWSTR psz);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            IPersistString2 * This,
            /* [string][out] */ LPWSTR *ppsz);
        
        END_INTERFACE
    } IPersistString2Vtbl;

    interface IPersistString2
    {
        CONST_VTBL struct IPersistString2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPersistString2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPersistString2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPersistString2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPersistString2_GetClassID(This,pClassID)	\
    (This)->lpVtbl -> GetClassID(This,pClassID)


#define IPersistString2_SetString(This,psz)	\
    (This)->lpVtbl -> SetString(This,psz)

#define IPersistString2_GetString(This,ppsz)	\
    (This)->lpVtbl -> GetString(This,ppsz)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPersistString2_SetString_Proxy( 
    IPersistString2 * This,
    /* [string][in] */ LPCWSTR psz);


void __RPC_STUB IPersistString2_SetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPersistString2_GetString_Proxy( 
    IPersistString2 * This,
    /* [string][out] */ LPWSTR *ppsz);


void __RPC_STUB IPersistString2_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPersistString2_INTERFACE_DEFINED__ */


#ifndef __IObjectWithQuerySource_INTERFACE_DEFINED__
#define __IObjectWithQuerySource_INTERFACE_DEFINED__

/* interface IObjectWithQuerySource */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IObjectWithQuerySource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b3dcb623-4280-4eb1-84b3-8d07e84f299a")
    IObjectWithQuerySource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSource( 
            /* [in] */ IQuerySource *pqs) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSource( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectWithQuerySourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectWithQuerySource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectWithQuerySource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectWithQuerySource * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSource )( 
            IObjectWithQuerySource * This,
            /* [in] */ IQuerySource *pqs);
        
        HRESULT ( STDMETHODCALLTYPE *GetSource )( 
            IObjectWithQuerySource * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        END_INTERFACE
    } IObjectWithQuerySourceVtbl;

    interface IObjectWithQuerySource
    {
        CONST_VTBL struct IObjectWithQuerySourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectWithQuerySource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectWithQuerySource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectWithQuerySource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectWithQuerySource_SetSource(This,pqs)	\
    (This)->lpVtbl -> SetSource(This,pqs)

#define IObjectWithQuerySource_GetSource(This,riid,ppv)	\
    (This)->lpVtbl -> GetSource(This,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectWithQuerySource_SetSource_Proxy( 
    IObjectWithQuerySource * This,
    /* [in] */ IQuerySource *pqs);


void __RPC_STUB IObjectWithQuerySource_SetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IObjectWithQuerySource_GetSource_Proxy( 
    IObjectWithQuerySource * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IObjectWithQuerySource_GetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectWithQuerySource_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0326 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum tagASSOCQUERY
    {	AQ_NOTHING	= 0,
	AQS_FRIENDLYTYPENAME	= 0x170000,
	AQS_DEFAULTICON	= 0x70001,
	AQS_CONTENTTYPE	= 0x80070002,
	AQS_CLSID	= 0x70003,
	AQS_PROGID	= 0x70004,
	AQN_NAMED_VALUE	= 0x10f0000,
	AQNS_NAMED_MUI_STRING	= 0x1170001,
	AQNS_SHELLEX_HANDLER	= 0x81070002,
	AQVS_COMMAND	= 0x2070000,
	AQVS_DDECOMMAND	= 0x2070001,
	AQVS_DDEIFEXEC	= 0x2070002,
	AQVS_DDEAPPLICATION	= 0x2070003,
	AQVS_DDETOPIC	= 0x2070004,
	AQV_NOACTIVATEHANDLER	= 0x2060005,
	AQVD_MSIDESCRIPTOR	= 0x2060006,
	AQVS_APPLICATION_PATH	= 0x2010007,
	AQVS_APPLICATION_FRIENDLYNAME	= 0x2170008,
	AQVO_SHELLVERB_DELEGATE	= 0x2200000,
	AQVO_APPLICATION_DELEGATE	= 0x2200001,
	AQF_STRING	= 0x10000,
	AQF_EXISTS	= 0x20000,
	AQF_DIRECT	= 0x40000,
	AQF_DWORD	= 0x80000,
	AQF_MUISTRING	= 0x100000,
	AQF_OBJECT	= 0x200000,
	AQF_CUEIS_UNUSED	= 0,
	AQF_CUEIS_NAME	= 0x1000000,
	AQF_CUEIS_SHELLVERB	= 0x2000000,
	AQF_QUERY_INITCLASS	= 0x80000000
    } 	ASSOCQUERY;



extern RPC_IF_HANDLE __MIDL_itf_shpriv_0326_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0326_v0_0_s_ifspec;

#ifndef __IAssociationElement_INTERFACE_DEFINED__
#define __IAssociationElement_INTERFACE_DEFINED__

/* interface IAssociationElement */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAssociationElement;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e58b1abf-9596-4dba-8997-89dcdef46992")
    IAssociationElement : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryString( 
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [string][out] */ LPWSTR *ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDword( 
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [out] */ DWORD *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryExists( 
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDirect( 
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [out] */ FLAGGED_BYTE_BLOB **ppblob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryObject( 
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssociationElementVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssociationElement * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssociationElement * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssociationElement * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryString )( 
            IAssociationElement * This,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [string][out] */ LPWSTR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDword )( 
            IAssociationElement * This,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [out] */ DWORD *pdw);
        
        HRESULT ( STDMETHODCALLTYPE *QueryExists )( 
            IAssociationElement * This,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDirect )( 
            IAssociationElement * This,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [out] */ FLAGGED_BYTE_BLOB **ppblob);
        
        HRESULT ( STDMETHODCALLTYPE *QueryObject )( 
            IAssociationElement * This,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        END_INTERFACE
    } IAssociationElementVtbl;

    interface IAssociationElement
    {
        CONST_VTBL struct IAssociationElementVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssociationElement_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssociationElement_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssociationElement_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssociationElement_QueryString(This,query,pszCue,ppsz)	\
    (This)->lpVtbl -> QueryString(This,query,pszCue,ppsz)

#define IAssociationElement_QueryDword(This,query,pszCue,pdw)	\
    (This)->lpVtbl -> QueryDword(This,query,pszCue,pdw)

#define IAssociationElement_QueryExists(This,query,pszCue)	\
    (This)->lpVtbl -> QueryExists(This,query,pszCue)

#define IAssociationElement_QueryDirect(This,query,pszCue,ppblob)	\
    (This)->lpVtbl -> QueryDirect(This,query,pszCue,ppblob)

#define IAssociationElement_QueryObject(This,query,pszCue,riid,ppv)	\
    (This)->lpVtbl -> QueryObject(This,query,pszCue,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssociationElement_QueryString_Proxy( 
    IAssociationElement * This,
    /* [in] */ ASSOCQUERY query,
    /* [string][in] */ LPCWSTR pszCue,
    /* [string][out] */ LPWSTR *ppsz);


void __RPC_STUB IAssociationElement_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssociationElement_QueryDword_Proxy( 
    IAssociationElement * This,
    /* [in] */ ASSOCQUERY query,
    /* [string][in] */ LPCWSTR pszCue,
    /* [out] */ DWORD *pdw);


void __RPC_STUB IAssociationElement_QueryDword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssociationElement_QueryExists_Proxy( 
    IAssociationElement * This,
    /* [in] */ ASSOCQUERY query,
    /* [string][in] */ LPCWSTR pszCue);


void __RPC_STUB IAssociationElement_QueryExists_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssociationElement_QueryDirect_Proxy( 
    IAssociationElement * This,
    /* [in] */ ASSOCQUERY query,
    /* [string][in] */ LPCWSTR pszCue,
    /* [out] */ FLAGGED_BYTE_BLOB **ppblob);


void __RPC_STUB IAssociationElement_QueryDirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssociationElement_QueryObject_Proxy( 
    IAssociationElement * This,
    /* [in] */ ASSOCQUERY query,
    /* [string][in] */ LPCWSTR pszCue,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IAssociationElement_QueryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssociationElement_INTERFACE_DEFINED__ */


#ifndef __IEnumAssociationElements_INTERFACE_DEFINED__
#define __IEnumAssociationElements_INTERFACE_DEFINED__

/* interface IEnumAssociationElements */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumAssociationElements;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("a6b0fb57-7523-4439-9425-ebe99823b828")
    IEnumAssociationElements : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IAssociationElement **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumAssociationElements **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumAssociationElementsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumAssociationElements * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumAssociationElements * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumAssociationElements * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumAssociationElements * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IAssociationElement **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumAssociationElements * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumAssociationElements * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumAssociationElements * This,
            /* [out] */ IEnumAssociationElements **ppenum);
        
        END_INTERFACE
    } IEnumAssociationElementsVtbl;

    interface IEnumAssociationElements
    {
        CONST_VTBL struct IEnumAssociationElementsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumAssociationElements_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumAssociationElements_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumAssociationElements_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumAssociationElements_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumAssociationElements_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumAssociationElements_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumAssociationElements_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumAssociationElements_Next_Proxy( 
    IEnumAssociationElements * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IAssociationElement **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumAssociationElements_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAssociationElements_Skip_Proxy( 
    IEnumAssociationElements * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumAssociationElements_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAssociationElements_Reset_Proxy( 
    IEnumAssociationElements * This);


void __RPC_STUB IEnumAssociationElements_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumAssociationElements_Clone_Proxy( 
    IEnumAssociationElements * This,
    /* [out] */ IEnumAssociationElements **ppenum);


void __RPC_STUB IEnumAssociationElements_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumAssociationElements_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0328 */
/* [local] */ 

/* [v1_enum] */ 
enum tagASSOCELEM
    {	ASSOCELEM_DATA	= 0x1,
	ASSOCELEM_USER	= 0x2,
	ASSOCELEM_DEFAULT	= 0x4,
	ASSOCELEM_SYSTEM_EXT	= 0x10,
	ASSOCELEM_SYSTEM_PERCEIVED	= 0x20,
	ASSOCELEM_SYSTEM	= 0x30,
	ASSOCELEM_BASEIS_FOLDER	= 0x100,
	ASSOCELEM_BASEIS_STAR	= 0x200,
	ASSOCELEM_BASE	= 0x300,
	ASSOCELEM_EXTRA	= 0x10000,
	ASSOCELEMF_INCLUDE_SLOW	= 0x80000000,
	ASSOCELEM_MASK_QUERYNORMAL	= 0xffff,
	ASSOCELEM_MASK_ENUMCONTEXTMENU	= -1,
	ASSOCELEM_MASK_ALL	= -1
    } ;
typedef DWORD ASSOCELEM_MASK;



extern RPC_IF_HANDLE __MIDL_itf_shpriv_0328_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0328_v0_0_s_ifspec;

#ifndef __IAssociationArrayInitialize_INTERFACE_DEFINED__
#define __IAssociationArrayInitialize_INTERFACE_DEFINED__

/* interface IAssociationArrayInitialize */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAssociationArrayInitialize;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ee9165bf-a4d9-474b-8236-6735cb7e28b6")
    IAssociationArrayInitialize : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InitClassElements( 
            /* [in] */ ASSOCELEM_MASK maskBase,
            /* [in] */ LPCWSTR pszClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertElements( 
            /* [in] */ ASSOCELEM_MASK mask,
            /* [in] */ IEnumAssociationElements *peae) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterElements( 
            /* [in] */ ASSOCELEM_MASK maskInclude) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssociationArrayInitializeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssociationArrayInitialize * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssociationArrayInitialize * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssociationArrayInitialize * This);
        
        HRESULT ( STDMETHODCALLTYPE *InitClassElements )( 
            IAssociationArrayInitialize * This,
            /* [in] */ ASSOCELEM_MASK maskBase,
            /* [in] */ LPCWSTR pszClass);
        
        HRESULT ( STDMETHODCALLTYPE *InsertElements )( 
            IAssociationArrayInitialize * This,
            /* [in] */ ASSOCELEM_MASK mask,
            /* [in] */ IEnumAssociationElements *peae);
        
        HRESULT ( STDMETHODCALLTYPE *FilterElements )( 
            IAssociationArrayInitialize * This,
            /* [in] */ ASSOCELEM_MASK maskInclude);
        
        END_INTERFACE
    } IAssociationArrayInitializeVtbl;

    interface IAssociationArrayInitialize
    {
        CONST_VTBL struct IAssociationArrayInitializeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssociationArrayInitialize_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssociationArrayInitialize_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssociationArrayInitialize_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssociationArrayInitialize_InitClassElements(This,maskBase,pszClass)	\
    (This)->lpVtbl -> InitClassElements(This,maskBase,pszClass)

#define IAssociationArrayInitialize_InsertElements(This,mask,peae)	\
    (This)->lpVtbl -> InsertElements(This,mask,peae)

#define IAssociationArrayInitialize_FilterElements(This,maskInclude)	\
    (This)->lpVtbl -> FilterElements(This,maskInclude)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssociationArrayInitialize_InitClassElements_Proxy( 
    IAssociationArrayInitialize * This,
    /* [in] */ ASSOCELEM_MASK maskBase,
    /* [in] */ LPCWSTR pszClass);


void __RPC_STUB IAssociationArrayInitialize_InitClassElements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssociationArrayInitialize_InsertElements_Proxy( 
    IAssociationArrayInitialize * This,
    /* [in] */ ASSOCELEM_MASK mask,
    /* [in] */ IEnumAssociationElements *peae);


void __RPC_STUB IAssociationArrayInitialize_InsertElements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssociationArrayInitialize_FilterElements_Proxy( 
    IAssociationArrayInitialize * This,
    /* [in] */ ASSOCELEM_MASK maskInclude);


void __RPC_STUB IAssociationArrayInitialize_FilterElements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssociationArrayInitialize_INTERFACE_DEFINED__ */


#ifndef __IAssociationArray_INTERFACE_DEFINED__
#define __IAssociationArray_INTERFACE_DEFINED__

/* interface IAssociationArray */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IAssociationArray;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3b877e3c-67de-4f9a-b29b-17d0a1521c6a")
    IAssociationArray : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumElements( 
            /* [in] */ ASSOCELEM_MASK mask,
            /* [out] */ IEnumAssociationElements **ppeae) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryString( 
            /* [in] */ ASSOCELEM_MASK mask,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [string][out] */ LPWSTR *ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDword( 
            /* [in] */ ASSOCELEM_MASK mask,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [out] */ DWORD *pdw) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryExists( 
            /* [in] */ ASSOCELEM_MASK mask,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryDirect( 
            /* [in] */ ASSOCELEM_MASK mask,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [out] */ FLAGGED_BYTE_BLOB **ppblob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryObject( 
            /* [in] */ ASSOCELEM_MASK mask,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssociationArrayVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssociationArray * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssociationArray * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssociationArray * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumElements )( 
            IAssociationArray * This,
            /* [in] */ ASSOCELEM_MASK mask,
            /* [out] */ IEnumAssociationElements **ppeae);
        
        HRESULT ( STDMETHODCALLTYPE *QueryString )( 
            IAssociationArray * This,
            /* [in] */ ASSOCELEM_MASK mask,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [string][out] */ LPWSTR *ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDword )( 
            IAssociationArray * This,
            /* [in] */ ASSOCELEM_MASK mask,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [out] */ DWORD *pdw);
        
        HRESULT ( STDMETHODCALLTYPE *QueryExists )( 
            IAssociationArray * This,
            /* [in] */ ASSOCELEM_MASK mask,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue);
        
        HRESULT ( STDMETHODCALLTYPE *QueryDirect )( 
            IAssociationArray * This,
            /* [in] */ ASSOCELEM_MASK mask,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [out] */ FLAGGED_BYTE_BLOB **ppblob);
        
        HRESULT ( STDMETHODCALLTYPE *QueryObject )( 
            IAssociationArray * This,
            /* [in] */ ASSOCELEM_MASK mask,
            /* [in] */ ASSOCQUERY query,
            /* [string][in] */ LPCWSTR pszCue,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        END_INTERFACE
    } IAssociationArrayVtbl;

    interface IAssociationArray
    {
        CONST_VTBL struct IAssociationArrayVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssociationArray_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssociationArray_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssociationArray_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssociationArray_EnumElements(This,mask,ppeae)	\
    (This)->lpVtbl -> EnumElements(This,mask,ppeae)

#define IAssociationArray_QueryString(This,mask,query,pszCue,ppsz)	\
    (This)->lpVtbl -> QueryString(This,mask,query,pszCue,ppsz)

#define IAssociationArray_QueryDword(This,mask,query,pszCue,pdw)	\
    (This)->lpVtbl -> QueryDword(This,mask,query,pszCue,pdw)

#define IAssociationArray_QueryExists(This,mask,query,pszCue)	\
    (This)->lpVtbl -> QueryExists(This,mask,query,pszCue)

#define IAssociationArray_QueryDirect(This,mask,query,pszCue,ppblob)	\
    (This)->lpVtbl -> QueryDirect(This,mask,query,pszCue,ppblob)

#define IAssociationArray_QueryObject(This,mask,query,pszCue,riid,ppv)	\
    (This)->lpVtbl -> QueryObject(This,mask,query,pszCue,riid,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssociationArray_EnumElements_Proxy( 
    IAssociationArray * This,
    /* [in] */ ASSOCELEM_MASK mask,
    /* [out] */ IEnumAssociationElements **ppeae);


void __RPC_STUB IAssociationArray_EnumElements_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssociationArray_QueryString_Proxy( 
    IAssociationArray * This,
    /* [in] */ ASSOCELEM_MASK mask,
    /* [in] */ ASSOCQUERY query,
    /* [string][in] */ LPCWSTR pszCue,
    /* [string][out] */ LPWSTR *ppsz);


void __RPC_STUB IAssociationArray_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssociationArray_QueryDword_Proxy( 
    IAssociationArray * This,
    /* [in] */ ASSOCELEM_MASK mask,
    /* [in] */ ASSOCQUERY query,
    /* [string][in] */ LPCWSTR pszCue,
    /* [out] */ DWORD *pdw);


void __RPC_STUB IAssociationArray_QueryDword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssociationArray_QueryExists_Proxy( 
    IAssociationArray * This,
    /* [in] */ ASSOCELEM_MASK mask,
    /* [in] */ ASSOCQUERY query,
    /* [string][in] */ LPCWSTR pszCue);


void __RPC_STUB IAssociationArray_QueryExists_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssociationArray_QueryDirect_Proxy( 
    IAssociationArray * This,
    /* [in] */ ASSOCELEM_MASK mask,
    /* [in] */ ASSOCQUERY query,
    /* [string][in] */ LPCWSTR pszCue,
    /* [out] */ FLAGGED_BYTE_BLOB **ppblob);


void __RPC_STUB IAssociationArray_QueryDirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssociationArray_QueryObject_Proxy( 
    IAssociationArray * This,
    /* [in] */ ASSOCELEM_MASK mask,
    /* [in] */ ASSOCQUERY query,
    /* [string][in] */ LPCWSTR pszCue,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IAssociationArray_QueryObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssociationArray_INTERFACE_DEFINED__ */


#ifndef __IAlphaThumbnailExtractor_INTERFACE_DEFINED__
#define __IAlphaThumbnailExtractor_INTERFACE_DEFINED__

/* interface IAlphaThumbnailExtractor */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IAlphaThumbnailExtractor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0F97F9D3-A7E2-4db7-A9B4-C540BD4B80A9")
    IAlphaThumbnailExtractor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestAlphaThumbnail( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAlphaThumbnailExtractorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAlphaThumbnailExtractor * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAlphaThumbnailExtractor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAlphaThumbnailExtractor * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestAlphaThumbnail )( 
            IAlphaThumbnailExtractor * This);
        
        END_INTERFACE
    } IAlphaThumbnailExtractorVtbl;

    interface IAlphaThumbnailExtractor
    {
        CONST_VTBL struct IAlphaThumbnailExtractorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAlphaThumbnailExtractor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAlphaThumbnailExtractor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAlphaThumbnailExtractor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAlphaThumbnailExtractor_RequestAlphaThumbnail(This)	\
    (This)->lpVtbl -> RequestAlphaThumbnail(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAlphaThumbnailExtractor_RequestAlphaThumbnail_Proxy( 
    IAlphaThumbnailExtractor * This);


void __RPC_STUB IAlphaThumbnailExtractor_RequestAlphaThumbnail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAlphaThumbnailExtractor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0331 */
/* [local] */ 

#if (_WIN32_IE >= 0x0600)


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0331_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0331_v0_0_s_ifspec;

#ifndef __IQueryPropertyFlags_INTERFACE_DEFINED__
#define __IQueryPropertyFlags_INTERFACE_DEFINED__

/* interface IQueryPropertyFlags */
/* [object][local][uuid] */ 


EXTERN_C const IID IID_IQueryPropertyFlags;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85DCA855-9B96-476d-8F35-7AF1E733CAAE")
    IQueryPropertyFlags : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            const PROPSPEC *pspec,
            SHCOLSTATEF *pcsFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IQueryPropertyFlagsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IQueryPropertyFlags * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IQueryPropertyFlags * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IQueryPropertyFlags * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            IQueryPropertyFlags * This,
            const PROPSPEC *pspec,
            SHCOLSTATEF *pcsFlags);
        
        END_INTERFACE
    } IQueryPropertyFlagsVtbl;

    interface IQueryPropertyFlags
    {
        CONST_VTBL struct IQueryPropertyFlagsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IQueryPropertyFlags_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IQueryPropertyFlags_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IQueryPropertyFlags_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IQueryPropertyFlags_GetFlags(This,pspec,pcsFlags)	\
    (This)->lpVtbl -> GetFlags(This,pspec,pcsFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IQueryPropertyFlags_GetFlags_Proxy( 
    IQueryPropertyFlags * This,
    const PROPSPEC *pspec,
    SHCOLSTATEF *pcsFlags);


void __RPC_STUB IQueryPropertyFlags_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IQueryPropertyFlags_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_shpriv_0332 */
/* [local] */ 

#endif // _WIN32_IE >= 0x0600)


extern RPC_IF_HANDLE __MIDL_itf_shpriv_0332_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_shpriv_0332_v0_0_s_ifspec;


#ifndef __ShellPrivateObjects_LIBRARY_DEFINED__
#define __ShellPrivateObjects_LIBRARY_DEFINED__

/* library ShellPrivateObjects */
/* [uuid] */ 

#define SID_OleControlSite IID_IOleControlSite

EXTERN_C const IID LIBID_ShellPrivateObjects;

EXTERN_C const CLSID CLSID_HWEventSettings;

#ifdef __cplusplus

class DECLSPEC_UUID("5560c070-114e-4e97-929a-7e39f40debc7")
HWEventSettings;
#endif

EXTERN_C const CLSID CLSID_AutoplayHandlerProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("11F6B41F-3BE5-4ce3-AF60-398551797DF6")
AutoplayHandlerProperties;
#endif

EXTERN_C const CLSID CLSID_HWDevice;

#ifdef __cplusplus

class DECLSPEC_UUID("aac41048-53e3-4867-a0aa-5fbceae7e5f5")
HWDevice;
#endif

EXTERN_C const CLSID CLSID_HardwareDevices;

#ifdef __cplusplus

class DECLSPEC_UUID("dd522acc-f821-461a-a407-50b198b896dc")
HardwareDevices;
#endif

EXTERN_C const CLSID CLSID_HWDeviceCustomProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("555F3418-D99E-4e51-800A-6E89CFD8B1D7")
HWDeviceCustomProperties;
#endif

EXTERN_C const CLSID CLSID_DefCategoryProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("B2F2E083-84FE-4a7e-80C3-4B50D10D646E")
DefCategoryProvider;
#endif

EXTERN_C const CLSID CLSID_VersionColProvider;

#ifdef __cplusplus

class DECLSPEC_UUID("66742402-F9B9-11D1-A202-0000F81FEDEE")
VersionColProvider;
#endif

EXTERN_C const CLSID CLSID_ThemeUIPages;

#ifdef __cplusplus

class DECLSPEC_UUID("B12AE898-D056-4378-A844-6D393FE37956")
ThemeUIPages;
#endif

EXTERN_C const CLSID CLSID_ScreenSaverPage;

#ifdef __cplusplus

class DECLSPEC_UUID("ADB9F5A4-E73E-49b8-99B6-2FA317EF9DBC")
ScreenSaverPage;
#endif

EXTERN_C const CLSID CLSID_ScreenResFixer;

#ifdef __cplusplus

class DECLSPEC_UUID("5a3d988e-820d-4aaf-ba87-440081768a17")
ScreenResFixer;
#endif

EXTERN_C const CLSID CLSID_SettingsPage;

#ifdef __cplusplus

class DECLSPEC_UUID("4c892621-6757-4fe0-ad8c-a6301be7fba2")
SettingsPage;
#endif

EXTERN_C const CLSID CLSID_DisplaySettings;

#ifdef __cplusplus

class DECLSPEC_UUID("c79d1575-b8c6-4862-a284-788836518b97")
DisplaySettings;
#endif

EXTERN_C const CLSID CLSID_VideoThumbnail;

#ifdef __cplusplus

class DECLSPEC_UUID("c5a40261-cd64-4ccf-84cb-c394da41d590")
VideoThumbnail;
#endif

EXTERN_C const CLSID CLSID_StartMenuPin;

#ifdef __cplusplus

class DECLSPEC_UUID("a2a9545d-a0c2-42b4-9708-a0b2badd77c8")
StartMenuPin;
#endif

EXTERN_C const CLSID CLSID_ClientExtractIcon;

#ifdef __cplusplus

class DECLSPEC_UUID("25585dc7-4da0-438d-ad04-e42c8d2d64b9")
ClientExtractIcon;
#endif

EXTERN_C const CLSID CLSID_MediaDeviceFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("640167b4-59b0-47a6-b335-a6b3c0695aea")
MediaDeviceFolder;
#endif

EXTERN_C const CLSID CLSID_CDBurnFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("00eebf57-477d-4084-9921-7ab3c2c9459d")
CDBurnFolder;
#endif

EXTERN_C const CLSID CLSID_BurnAudioCDExtension;

#ifdef __cplusplus

class DECLSPEC_UUID("f83cbf45-1c37-4ca1-a78a-28bcb91642ec")
BurnAudioCDExtension;
#endif

EXTERN_C const CLSID CLSID_Accessible;

#ifdef __cplusplus

class DECLSPEC_UUID("7e653215-fa25-46bd-a339-34a2790f3cb7")
Accessible;
#endif

EXTERN_C const CLSID CLSID_TrackPopupBar;

#ifdef __cplusplus

class DECLSPEC_UUID("acf35015-526e-4230-9596-becbe19f0ac9")
TrackPopupBar;
#endif

EXTERN_C const CLSID CLSID_SharedDocuments;

#ifdef __cplusplus

class DECLSPEC_UUID("59031a47-3f72-44a7-89c5-5595fe6b30ee")
SharedDocuments;
#endif

EXTERN_C const CLSID CLSID_PostBootReminder;

#ifdef __cplusplus

class DECLSPEC_UUID("7849596a-48ea-486e-8937-a2a3009f31a9")
PostBootReminder;
#endif

EXTERN_C const CLSID CLSID_AudioMediaProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("875CB1A1-0F29-45de-A1AE-CFB4950D0B78")
AudioMediaProperties;
#endif

EXTERN_C const CLSID CLSID_VideoMediaProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("40C3D757-D6E4-4b49-BB41-0E5BBEA28817")
VideoMediaProperties;
#endif

EXTERN_C const CLSID CLSID_AVWavProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("E4B29F9D-D390-480b-92FD-7DDB47101D71")
AVWavProperties;
#endif

EXTERN_C const CLSID CLSID_AVAviProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("87D62D94-71B3-4b9a-9489-5FE6850DC73E")
AVAviProperties;
#endif

EXTERN_C const CLSID CLSID_AVMidiProperties;

#ifdef __cplusplus

class DECLSPEC_UUID("A6FD9E45-6E44-43f9-8644-08598F5A74D9")
AVMidiProperties;
#endif

EXTERN_C const CLSID CLSID_TrayNotify;

#ifdef __cplusplus

class DECLSPEC_UUID("25dead04-1eac-4911-9e3a-ad0a4ab560fd")
TrayNotify;
#endif

EXTERN_C const CLSID CLSID_CompositeFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("FEF10DED-355E-4e06-9381-9B24D7F7CC88")
CompositeFolder;
#endif

EXTERN_C const CLSID CLSID_DynamicStorage;

#ifdef __cplusplus

class DECLSPEC_UUID("F46316E4-FB1B-46eb-AEDF-9520BFBB916A")
DynamicStorage;
#endif

EXTERN_C const CLSID CLSID_Magic;

#ifdef __cplusplus

class DECLSPEC_UUID("8A037D15-3357-4b1c-90EB-7B40B74FC4B2")
Magic;
#endif

EXTERN_C const CLSID CLSID_HomeNetworkWizard;

#ifdef __cplusplus

class DECLSPEC_UUID("2728520d-1ec8-4c68-a551-316b684c4ea7")
HomeNetworkWizard;
#endif

EXTERN_C const CLSID CLSID_StartMenuFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("48e7caab-b918-4e58-a94d-505519c795dc")
StartMenuFolder;
#endif

EXTERN_C const CLSID CLSID_ProgramsFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("7be9d83c-a729-4d97-b5a7-1b7313c39e0a")
ProgramsFolder;
#endif

EXTERN_C const CLSID CLSID_MoreDocumentsFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("9387ae38-d19b-4de5-baf5-1f7767a1cf04")
MoreDocumentsFolder;
#endif

EXTERN_C const CLSID CLSID_LocalCopyHelper;

#ifdef __cplusplus

class DECLSPEC_UUID("021003e9-aac0-4975-979f-14b5d4e717f8")
LocalCopyHelper;
#endif

EXTERN_C const CLSID CLSID_ShellItem;

#ifdef __cplusplus

class DECLSPEC_UUID("9ac9fbe1-e0a2-4ad6-b4ee-e212013ea917")
ShellItem;
#endif

EXTERN_C const CLSID CLSID_WirelessDevices;

#ifdef __cplusplus

class DECLSPEC_UUID("30dd6b9c-47b7-4df5-94ae-f779aa7eb644")
WirelessDevices;
#endif

EXTERN_C const CLSID CLSID_FolderCustomize;

#ifdef __cplusplus

class DECLSPEC_UUID("ef43ecfe-2ab9-4632-bf21-58909dd177f0")
FolderCustomize;
#endif

EXTERN_C const CLSID CLSID_WorkgroupNetCrawler;

#ifdef __cplusplus

class DECLSPEC_UUID("72b3882f-453a-4633-aac9-8c3dced62aff")
WorkgroupNetCrawler;
#endif

EXTERN_C const CLSID CLSID_WebDocsNetCrawler;

#ifdef __cplusplus

class DECLSPEC_UUID("8a2ecb17-9007-4b9a-b271-7509095c405f")
WebDocsNetCrawler;
#endif

EXTERN_C const CLSID CLSID_PublishedShareNetCrawler;

#ifdef __cplusplus

class DECLSPEC_UUID("24eee191-5491-4dc3-bd03-c0627df6a70c")
PublishedShareNetCrawler;
#endif

EXTERN_C const CLSID CLSID_ImagePropertyHandler;

#ifdef __cplusplus

class DECLSPEC_UUID("eb9b1153-3b57-4e68-959a-a3266bc3d7fe")
ImagePropertyHandler;
#endif

EXTERN_C const CLSID CLSID_WebViewRegTreeItem;

#ifdef __cplusplus

class DECLSPEC_UUID("01E2E7C0-2343-407f-B947-7E132E791D3E")
WebViewRegTreeItem;
#endif

EXTERN_C const CLSID CLSID_ThemesRegTreeItem;

#ifdef __cplusplus

class DECLSPEC_UUID("AABE54D4-6E88-4c46-A6B3-1DF790DD6E0D")
ThemesRegTreeItem;
#endif

EXTERN_C const CLSID CLSID_CShellTreeWalker;

#ifdef __cplusplus

class DECLSPEC_UUID("95CE8412-7027-11D1-B879-006008059382")
CShellTreeWalker;
#endif

EXTERN_C const CLSID CLSID_StorageProcessor;

#ifdef __cplusplus

class DECLSPEC_UUID("6CF8E98C-5DD4-42A2-A948-BFE4CA1DC3EB")
StorageProcessor;
#endif

EXTERN_C const CLSID CLSID_TransferConfirmationUI;

#ifdef __cplusplus

class DECLSPEC_UUID("6B831E4F-A50D-45FC-842F-16CE27595359")
TransferConfirmationUI;
#endif

EXTERN_C const CLSID CLSID_ShellAutoplay;

#ifdef __cplusplus

class DECLSPEC_UUID("995C996E-D918-4a8c-A302-45719A6F4EA7")
ShellAutoplay;
#endif

EXTERN_C const CLSID CLSID_PrintPhotosDropTarget;

#ifdef __cplusplus

class DECLSPEC_UUID("60fd46de-f830-4894-a628-6fa81bc0190d")
PrintPhotosDropTarget;
#endif

EXTERN_C const CLSID CLSID_OrganizeFolder;

#ifdef __cplusplus

class DECLSPEC_UUID("10612e23-7679-4dd9-95b8-8e71c461feb2")
OrganizeFolder;
#endif

EXTERN_C const CLSID CLSID_FadeTask;

#ifdef __cplusplus

class DECLSPEC_UUID("7eb5fbe4-2100-49e6-8593-17e130122f91")
FadeTask;
#endif

EXTERN_C const CLSID CLSID_AssocShellElement;

#ifdef __cplusplus

class DECLSPEC_UUID("c461837f-ea59-494a-b7c6-cd040e37185e")
AssocShellElement;
#endif

EXTERN_C const CLSID CLSID_AssocProgidElement;

#ifdef __cplusplus

class DECLSPEC_UUID("9016d0dd-7c41-46cc-a664-bf22f7cb186a")
AssocProgidElement;
#endif

EXTERN_C const CLSID CLSID_AssocClsidElement;

#ifdef __cplusplus

class DECLSPEC_UUID("57aea081-5ee9-4c27-b218-c4b702964c54")
AssocClsidElement;
#endif

EXTERN_C const CLSID CLSID_AssocSystemElement;

#ifdef __cplusplus

class DECLSPEC_UUID("a6c4baad-4af5-4191-8685-c2c8953a148c")
AssocSystemElement;
#endif

EXTERN_C const CLSID CLSID_AssocPerceivedElement;

#ifdef __cplusplus

class DECLSPEC_UUID("0dc5fb21-b93d-4e3d-bb2f-ce4e36a70601")
AssocPerceivedElement;
#endif

EXTERN_C const CLSID CLSID_AssocApplicationElement;

#ifdef __cplusplus

class DECLSPEC_UUID("0c2bf91b-8746-4fb1-b4d7-7c03f890b168")
AssocApplicationElement;
#endif

EXTERN_C const CLSID CLSID_AssocFolderElement;

#ifdef __cplusplus

class DECLSPEC_UUID("7566df7a-42cc-475d-a025-1205ddf4911f")
AssocFolderElement;
#endif

EXTERN_C const CLSID CLSID_AssocStarElement;

#ifdef __cplusplus

class DECLSPEC_UUID("0633b720-6926-404c-b6b3-923b1a501743")
AssocStarElement;
#endif

EXTERN_C const CLSID CLSID_AssocClientElement;

#ifdef __cplusplus

class DECLSPEC_UUID("3c81e7fa-1f3b-464a-a350-114a25beb2a2")
AssocClientElement;
#endif

EXTERN_C const CLSID CLSID_AutoPlayVerb;

#ifdef __cplusplus

class DECLSPEC_UUID("f26a669a-bcbb-4e37-abf9-7325da15f931")
AutoPlayVerb;
#endif
#endif /* __ShellPrivateObjects_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HICON_UserSize(     unsigned long *, unsigned long            , HICON * ); 
unsigned char * __RPC_USER  HICON_UserMarshal(  unsigned long *, unsigned char *, HICON * ); 
unsigned char * __RPC_USER  HICON_UserUnmarshal(unsigned long *, unsigned char *, HICON * ); 
void                      __RPC_USER  HICON_UserFree(     unsigned long *, HICON * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long *, unsigned long            , HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  unsigned long *, unsigned char *, HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(unsigned long *, unsigned char *, HWND * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long *, HWND * ); 

unsigned long             __RPC_USER  LPCITEMIDLIST_UserSize(     unsigned long *, unsigned long            , LPCITEMIDLIST * ); 
unsigned char * __RPC_USER  LPCITEMIDLIST_UserMarshal(  unsigned long *, unsigned char *, LPCITEMIDLIST * ); 
unsigned char * __RPC_USER  LPCITEMIDLIST_UserUnmarshal(unsigned long *, unsigned char *, LPCITEMIDLIST * ); 
void                      __RPC_USER  LPCITEMIDLIST_UserFree(     unsigned long *, LPCITEMIDLIST * ); 

unsigned long             __RPC_USER  LPITEMIDLIST_UserSize(     unsigned long *, unsigned long            , LPITEMIDLIST * ); 
unsigned char * __RPC_USER  LPITEMIDLIST_UserMarshal(  unsigned long *, unsigned char *, LPITEMIDLIST * ); 
unsigned char * __RPC_USER  LPITEMIDLIST_UserUnmarshal(unsigned long *, unsigned char *, LPITEMIDLIST * ); 
void                      __RPC_USER  LPITEMIDLIST_UserFree(     unsigned long *, LPITEMIDLIST * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\shlobjp.h ===
//***************************************************************************
//  --- SHELLAPI.W SHSEMIP.H SHLOBJ.W SHOBJIDL.IDL SHLDISP.IDL SHPRIV.IDL ---
//                Which header is best for my new API?
//
//  SHLOBJ      - *AVOID NEW USAGE*, PREFER OTHER HEADERS
//              used primarily for legacy compatibility
//
//  SHELLAPI    - ALL NEW SHELL32 EXPORTS public and private
//              used for both public and private exports from shell32
//
//  SHSEMIP     - *AVOID _ALL_ USAGE*, NO EXPORTS, SUPER PRIVATE
//              used for very private shell defines.
//
//  SHOBJIDL    - ALL NEW SHELL PUBLIC INTERFACES
//              primary file for public shell (shell32+) interfaces
//
//  SHLDISP     - ALL NEW SHELL AUTOMATION INTERFACES
//              automation interfaces are always public
//
//  SHPRIV      - ALL NEW SHELL PRIVATE INTERFACES
//              private interfaces used anywhere in the shell
//
//
//  SHLOBJ was originally the file that defined all of shell32's interfaces.
//  it devolved into a dumping ground of public and private APIs and
//  interfaces.  in the effort to better support COM and better API management
//  we are attempting to avoid using shlobj
//***************************************************************************
#ifndef _SHLOBJP_H_
#define _SHLOBJP_H_
#define NO_MONIKER
#include <docobj.h>

#include <shldisp.h>
#include <pshpack1.h>   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

#include <shtypes.h>

#include <shpriv.h>
#include <iepriv.h>

// HMONITOR is already declared in NT 5's windef.h.
#if !defined(HMONITOR_DECLARED) && (WINVER < 0x0500)
DECLARE_HANDLE(HMONITOR);
#define HMONITOR_DECLARED
#endif

#include <tlog.h>

// DOC'ed for DOJ compliance
SHSTDAPI_(void *) SHRealloc(void * pv, SIZE_T cbNew);
SHSTDAPI_(SIZE_T) SHGetSize(void * pv);

// DOC'ed for DOJ compliance
#define CMF_FINDHACK            0x00000080      // This is a hack - we should remove this bit
//
// Private QueryContextMenuFlag passed from DefView
//
#define CMF_DVFILE              0x00010000      // "File" pulldown
#define CMF_ICM3                0x00020000      // QueryContextMenu can assume IContextMenu3 semantics (i.e.,
                                                // will receive WM_INITMENUPOPUP, WM_MEASUREITEM, WM_DRAWITEM,
                                                // and WM_MENUCHAR, via HandleMenuMsg2)
#define CMICEXSIZE_NT4          (SIZEOF(CMINVOKECOMMANDINFOEX) - SIZEOF(POINT))
#define CMIC_MASK_NO_HOOKS      SEE_MASK_NO_HOOKS
#define CMIC_MASK_DATAOBJECT    0x40000000   // lpPara is IDataObject*
#define CMIC_MASK_MODAL         0x80000000

#define CMIC_VALID_SEE_FLAGS    SEE_VALID_CMIC_FLAGS
#include <pshpack8.h>
// the struct below is used for cross-process passing of CMINVOKECOMMANDINFOEX structs
// we store offsets for the strings into ourself and we are win64 safe
typedef struct {
    DWORD cbSize;           // size of the struct
    DWORD fMask;            // any combination of CMIC_MASK_*
    DWORD dwHwnd;           // might be NULL (indicating no owner window)
    int nShow;              // one of SW_ values for ShowWindow() API
    DWORD dwHotKey;
    POINT ptInvoke;         // Point where it's invoked
    DWORD dwVerbW;          // offset from struct to lpVerbW
    DWORD dwParametersW;    // offset from struct to lpParametersW - might be NULL (indicating no parameter)
    DWORD dwDirectoryW;     // offset from struct to lpDirectoryW - might be NULL (indicating no specific directory)
    DWORD dwTitleW;         // offset from struct to lpTitleW - might be NULL (indicating no title)
}ICIX_PERSIST;
#include <poppack.h>

#define CONTEXTMENU_IDCMD_FIRST    1        // minimal QueryContextMenu idCmdFirst value //
#define CONTEXTMENU_IDCMD_LAST     0x7fff   // maximal QueryContextMenu idCmdLast value  //
//----------------------------------------------------------------------------
// Internal helper macro
//----------------------------------------------------------------------------

#define _IOffset(class, itf)         ((UINT_PTR)&(((class *)0)->itf))
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_IOffset(class, itf)))
#define IToClassN(class, itf, pitf)  IToClass(class, itf, pitf)

//
// Helper macro definitions
//
#define S_BOOL(f)   MAKE_SCODE(SEVERITY_SUCCESS, 0, f)

#ifdef DEBUG
#define ReleaseAndAssert(punk) Assert(punk->lpVtbl->Release(punk)==0)
#else
#define ReleaseAndAssert(punk) (punk->lpVtbl->Release(punk))
#endif
//
//  this interface is just the IID.  return back
//  a pointer to the IPersist interface if the object
//  implementation is free threaded.  this is used
//  for performance on free threaded objects.
//
#define IPersistFreeThreadedObject IPersist
//  this interface is just the IID.  return back
//  a pointer to the IDropTarget interface if the
//  object calls DAD_DragLeave/DAD_SetDragImage
//  in its IDropTarget::Drop().
//
#define IDropTargetWithDADSupport IDropTarget
// this is only inherited by CFSFolder_IconOverlayManager, it enumerates through all IconOverlayID's and
// keep their information in an array.
//===========================================================================
//
// IBrowserBand
//
// IBrowserBand::GetObjectBB(REFIID riid, void **ppv)
//  Obtain a service from the web browser.
//
// IBrowserBand::SetBrowserBandInfo(DWORD dwMask, PBROWSERBANDINFO pbbi)
//  Set browser band properties based on members of browserbandinfo struct
//  specified by dwMask.  These properties include title, deskband mode, and
//  current size.
//
//===========================================================================

typedef struct {
    UINT    cbSize;
    DWORD   dwModeFlags;
    BSTR    bstrTitle;
    SIZE    sizeMin;
    SIZE    sizeMax;
    SIZE    sizeCur;
} BROWSERBANDINFO, *PBROWSERBANDINFO;

#define BBIM_MODEFLAGS  0x00000001
#define BBIM_TITLE      0x00000002
#define BBIM_SIZEMIN    0x00000004
#define BBIM_SIZEMAX    0x00000008
#define BBIM_SIZECUR    0x00000010

#undef  INTERFACE
#define INTERFACE  IBrowserBand
DECLARE_INTERFACE_(IBrowserBand, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IBrowserBand methods ***
    STDMETHOD(GetObjectBB)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD(SetBrowserBandInfo)(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi) PURE;
    STDMETHOD(GetBrowserBandInfo)(THIS_ DWORD dwMask, PBROWSERBANDINFO pbbi) PURE;
};
// NT4 Console Server included shell32\shlink.h to get structure
// definitions and mimicked shell32\shlink.c to understand the
// stream format so our stream format is fixed forever. This is
// not bad since it was designed with extension in mind. We need
// to publish (as privately as possible) the file format and
// structures needed to read the file format.
//
// The stream format is a SHELL_LINK_DATA followed by
//   if SLDF_HAS_ID_LIST an ILSaveToStream followed by
//   if SLDF_HAS_LINK_INFO a LINKINFO followed by
//   if SLDF_HAS_NAME a STREAMSTRING followed by
//   if SLDF_RELPATH a STREAMSTRING followed by
//   if SLDF_WORKINGDIR a STREAMSTRING followed by
//   if SLDF_HAS_ARGS a STREAMSTRING followed by
//   if SLDF_HAS_ICON_LOCATION a STREAMSTRING followed by
//   SHWriteDataBlockList list of signature blocks
//
// Where a STREAMSTRING is a USHORT count of characters
// followed by that many (SLDF_UNICODE ? WIDE : ANSI) characters.
//
typedef struct {        // sld
    DWORD       cbSize;                 // signature for this data structure
    CLSID       clsid;                  // our GUID
    DWORD       dwFlags;                // SHELL_LINK_DATA_FLAGS enumeration

    DWORD       dwFileAttributes;
    FILETIME    ftCreationTime;
    FILETIME    ftLastAccessTime;
    FILETIME    ftLastWriteTime;
    DWORD       nFileSizeLow;

    int         iIcon;
    int         iShowCmd;
    WORD        wHotkey;
    WORD        wUnused;
    DWORD       dwRes1;
    DWORD       dwRes2;
} SHELL_LINK_DATA, *LPSHELL_LINK_DATA;
typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
} EXP_HEADER, *LPEXP_HEADER;
typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    BYTE        abTracker[ 1 ];     //
} EXP_TRACKER, *LPEXP_TRACKER;
#define EXP_TRACKER_SIG                0xA0000003   // LPEXP_TRACKER

typedef struct
{
    DWORD       cbSize;             // Size of this extra data block
    DWORD       dwSignature;        // signature of this extra data block
    WCHAR       wszLayerEnvName[64]; // name of shim layer to run with this link (eg "NT4SP5")
} EXP_SHIMLAYER;
#define EXP_SHIMLAYER_SIG              0xA0000008

// NT40 Console Control Panel Applet does a CoCreateInstance(CLSID_CShellLink),
// used the CShellLink definition to get the 'this' pointer, and passed that
// along to some private exports in shell32. This completely prevents us
// from moving the CShellLink implementation to another DLL. (If we do, or an
// ISV takes our stream format and implements a better link by pointing the
// classid to their implementation, the NT40 Console CPA will fault.)
//
// To fix this problem in future revs, CShellLink will support IShellLinkDataList
//   AddDataBlock    adds the data block
//   FindDataBloc    returns a LocalAlloc()d COPY of a data block with the
//                   signature dwSig (NOTE: this is different than SHFindDataBlock)
//   RemoveDataBlock removes a data block with signature dwSig
// Plan is for NT50's Console CPA to use this interface instead.
//

//
// IURLSearchHook Interface is called whenever the browser navigates to a
// non-standard URL. It can be used to redirect the user's request to a
// search engine or a specific web site.
//
// A non-standard URL does not have a protocol prefix (e.g.,
// "www.microsoft.com") and the protocol cannot be easily guessed by
// the browser (e.g., "home.microsoft.com").
//
// The parameters of Translate(..)
//    lpwszSearchURL -- (IN/OUT) Wide char buffer that contains the request
//                      "URL" user typed in as input and the tranlated URL
//                      as output.
//    cchBufferSize  -- (IN) size of lpwszSearchURL
//
// Return Values:
// S_OK         Search handled completely, pszResult has the full URL to
//              browse to.  Stop running any further IURLSearchHooks and
//              pass this URL back to the browser for browsing.
//
// S_FALSE      Query has been preprocessed, pszResult has the result of
//              the preprocess, further search still needed. Go on
//              executing the rest of the IURLSearchHooks.  The
//              preprocessing steps can be:
//
//                      1. replaced certain characters
//                      2. added more hints
//
// E_ABORT      Search handled completely, stop running any further
//              IURLSearchHooks, but NO BROWSING NEEDED as a result,
//              pszResult is a copy of pcszQuery.
//
//              ;BUGBUG: This is not fully implemented, yet, making IURLQualify return this
//              involves too much change.
//
// BUGBUG:: E_ABORT is currently treated as E_FAIL. It requires too much change.
//
// E_FAIL       This Hook was unsuccessful. Search not handled at all,
//              pcszQueryURL has the query string. Please go on running
//              other IURLSearchHooks.
//
// BUGBUG:  There is a potential danger in this Interface, that is people can write
//          very bad SearchHooks, but we (Microsoft) take the blame.

// History:
//  --/--/94 KurtE Created
//
// History:
//  3/4/94 kraigb Created
//

//  CGID_DefView Command Target IDs. used to persist global DefView state

enum
{
    DVID_SETASDEFAULT,          // Set the DefView state of this folder as default for all of the same class
    DVID_RESETDEFAULT           // Reset the DefView state to the default (delete subkeys)
};

// CGID_ShellDocView Command Target IDs. for shell doc view wedge
enum {
    SHDVID_FINALTITLEAVAIL,     // DEAD: variantIn bstr - sent after final OLECMDID_SETTITLE is sent
    SHDVID_MIMECSETMENUOPEN,    // mimecharset menu open commands
    SHDVID_PRINTFRAME,          // print HTML frame
    SHDVID_PUTOFFLINE,          // DEAD: The Offline property has been changed
    SHDVID_PUTSILENT,           // DEAD: The frame's Silent property has been changed
    SHDVID_GOBACK,              // Navigate Back
    SHDVID_GOFORWARD,           // Navigate Forward
    SHDVID_CANGOBACK,           // Is Back Navigation Possible?
    SHDVID_CANGOFORWARD,        // Is Forward Navigation Possible?
    SHDVID_CANACTIVATENOW,      // (down) (PICS) OK to navigate to this view now?
    SHDVID_ACTIVATEMENOW,       // (up) (PICS) Rating checks out, navigate now
    SHDVID_CANSUPPORTPICS,      // (down) variantIn I4: IOleCommandTarget to reply to
    SHDVID_PICSLABELFOUND,      // (up) variantIn bstr: PICS label
    SHDVID_NOMOREPICSLABELS,    // (up) End of document, no more PICS labels coming
    SHDVID_CANDEACTIVATENOW,    // (QS down) (in script/etc) OK to deactivate view now?
    SHDVID_DEACTIVATEMENOW,     // (EXEC up) (in script/etc) out of script, deactivate view now
    SHDVID_NODEACTIVATENOW,     // (EXEC up) (in script/etc) entering script, disable deactivate
    SHDVID_AMBIENTPROPCHANGE,   // variantIn I4: dispid of ambient property that changed
    SHDVID_GETSYSIMAGEINDEX,    // variantOut: image index for current page
    SHDVID_GETPENDINGOBJECT,    // variantOut: IUnknown of pending shellview/docobject
    SHDVID_GETPENDINGURL,       // variantOut: BSTR of URL for pending docobject
    SHDVID_SETPENDINGURL,       // variantIn: BSTR of URL passed to pending docobject
    SHDVID_ISDRAGSOURCE,        // (down) varioutOut I4: non-zero if it's initiated drag&drop
    SHDVID_DOCFAMILYCHARSET,    // variantOut: I4: windows (family) codepage
    SHDVID_DOCCHARSET,          // variantOut: I4: actual (mlang) codepage
    SHDVID_RAISE,               // vaIn:I4:DTRF_*, vaOut:NULL unless DTRF_QUERY
    SHDVID_GETTRANSITION,       // (down) vaIn: I4: TransitionEvent; vaOut BSTR (CLSID), I4 (dwSpeed)
    SHDVID_GETMIMECSETMENU,     // get menu handle for mimecharset
    SHDVID_DOCWRITEABORT,       // Abort binding but activate pending docobject
    SHDVID_SETPRINTSTATUS,      // VariantIn: BOOL, TRUE - Started printing, FALSE - Finished printing
    SHDVID_NAVIGATIONSTATUS,    // QS for tooltip text and Exec when user clicks
    SHDVID_PROGRESSSTATUS,      // QS for tooltip text and Exec when user clicks
    SHDVID_ONLINESTATUS,        // QS for tooltip text and Exec when user clicks
    SHDVID_SSLSTATUS,           // QS for tooltip text and Exec when user clicks
    SHDVID_PRINTSTATUS,         // QS for tooltip text and Exec when user clicks
    SHDVID_ZONESTATUS,          // QS for tooltip text and Exec when user clicks
    SHDVID_ONCODEPAGECHANGE,    // variantIn I4: new specified codepage
    SHDVID_SETSECURELOCK,       // set the secure icon
    SHDVID_SHOWBROWSERBAR,      // show browser bar of clsid guid
    SHDVID_NAVIGATEBB,          // navigate to pidl in browserbar.
    SHDVID_UPDATEOFFLINEDESKTOP,// put the desktop in ON-LINE mode, update and put it back in Offline mode
    SHDVID_PICSBLOCKINGUI,      // (up) In I4: pointer to "ratings nugget" for block API
    SHDVID_ONCOLORSCHANGE,      // (up) sent by mshtml to indicate color set change
    SHDVID_CANDOCOLORSCHANGE,   // (down) used to query if document supports the above
    SHDVID_QUERYMERGEDHELPMENU, // was the help menu micro-merged?
    SHDVID_QUERYOBJECTSHELPMENU,// return the object's help menu
    SHDVID_HELP,                // do help
    SHDVID_UEMLOG,              // set UEM logging vaIn:I4:UEMIND_*, vaOut:NULL
    SHDVID_GETBROWSERBAR,       // get IDeskBand for browser bar of clsid guid
    SHDVID_GETFONTMENU,
    SHDVID_FONTMENUOPEN,
    SHDVID_CLSIDTOIDM,          // get the idm for the given clsid
    SHDVID_GETDOCDIRMENU,       // get menu handle for document direction
    SHDVID_ADDMENUEXTENSIONS,   // Context Menu Extensions
    SHDVID_CLSIDTOMONIKER,      // CLSID to property page resource mapping
    SHDVID_RESETSTATUSBAR,      // set the status bar back to "normal" icon w/out text
    SHDVID_ISBROWSERBARVISIBLE, // is browser bar of clsid guid visible?
    SHDVID_GETOPTIONSHWND,      // gets hwnd for internet options prop sheet (NULL if not open)
    SHDVID_DELEGATEWINDOWOM,    // set policy for whether window OM methods should be delegated.
    SHDVID_PAGEFROMPOSTDATA,    // determines if page was generated by post data
    SHDVID_DISPLAYSCRIPTERRORS, // tells the top docobject host to display his script err dialog
    SHDVID_NAVIGATEBBTOURL,     // Navigate to an URL in browserbar (used in Trident).
    SHDVID_NAVIGATEFROMDOC,     // The document delegated the navigation for a non-html mime-type.
    SHDVID_STARTPICSFORWINDOW,  // (up) variantIn: IUnknown of window that is navigating
                                //      variantOut: bool if pics process started
    SHDVID_CANCELPICSFORWINDOW, // (up) variantIn: IUnknown of window that is no longer navigating
    SHDVID_ISPICSENABLED,       // (up) variantOut: bool
    SHDVID_PICSLABELFOUNDINHTTPHEADER,// (up) variantIn bstr: PICS label
    SHDVID_CHECKINCACHEIFOFFLINE, // Check in cache if offline
    SHDVID_CHECKDONTUPDATETLOG,   // check if the current navigate is already dealing with the travellog correctly
    SHDVID_UPDATEDOCHOSTSTATE,    // Sent from CBaseBrowser2::_UpdateBrowserState to tell the dochost to update its state.
    SHDVID_FIREFILEDOWNLOAD,
    SHDVID_COMPLETEDOCHOSTPASSING,
    SHDVID_NAVSTART,
    SHDVID_SETNAVIGATABLECODEPAGE,
    SHDVID_WINDOWOPEN,
    SHDVID_PRIVACYSTATUS,        // QS for tooltip text and exec when user clicks
    SHDVID_FORWARDSECURELOCK,   // asks CDocObjectHost to forward its security status up to the shell browser
    SHDVID_ISEXPLORERBARVISIBLE, // is any explorer bar visible?
};

// CGID_DocHostCmdPriv Command Target IDs
//
enum
{
    DOCHOST_DOCCANNAVIGATE,     // The document knows how to navigate.
    DOCHOST_NAVIGATION_ERROR,   // Navigation Error
    DOCHOST_DOCHYPERLINK,       // The document is navigating.
    DOCHOST_SENDINGREQUEST,     // The document is sending a request for download. Update the progress bar.
    DOCHOST_FINDINGRESOURCE,    // The document is finding a resource. Update the progress bar.
    DOCHOST_RESETSEARCHINFO,    // Reset search information (after a successful navigation)
    DOCHOST_SETBROWSERINDEX,    // Sets the browser ID to use for TravelLog and frame targeting
    DOCHOST_NOTE_ERROR_PAGE,    // Need to know when we're navigating to an error web page.
    DOCHOST_READYSTATE_INTERACTIVE, // a document on a page is readystate interactive
    DOCHOST_CONTENTDISPOSITIONATTACH // The document needs to be saved.

};

// CGID_SearchBand Command Target IDs.
enum {
    SBID_SEARCH_NEW,            // (re)load the context-appropriate url
    SBID_SEARCH_NEXT,           // cycle between multiple providers
    SBID_SEARCH_CUSTOMIZE,      // navigate to customization url
    SBID_SEARCH_HELP,           // what it says
    SBID_GETPIDL,               // get the search pane's pidl
    SBID_HASPIDL,               // does the search pane have a pidl (i.e, has it navigated)
};

// CGID_MediaBar target ids
enum {
    MBID_PLAY,     // Play an url
    MBID_POPOUT    // Detect state of player
};

enum {
    MB_DOCKED,
    MB_POPOUT
};


//
// Private struct passed as argument to SHDVID_UPDATEDOCHOSTSTATE
//
struct DOCHOSTUPDATEDATA
{
    LPITEMIDLIST    _pidl;
    BOOL            _fIsErrorUrl;
};


//
//  this enum is used by SHDVID_SETSECURELOCK and SBCMDID_SETSECURELOCKICON
//  when adding new values, make sure to add to both SET and SUGGEST, and
//  the code depends on a direct correlation between the level of security
//  and the value of the enum.  so keep new values in the correct order
//
enum {
    SECURELOCK_NOCHANGE        = -1,
    SECURELOCK_SET_UNSECURE    = 0,
    SECURELOCK_SET_MIXED,
    SECURELOCK_SET_SECUREUNKNOWNBIT,
    SECURELOCK_SET_SECURE40BIT,
    SECURELOCK_SET_SECURE56BIT,
    SECURELOCK_SET_FORTEZZA,
    SECURELOCK_SET_SECURE128BIT,
    SECURELOCK_FIRSTSUGGEST,
    SECURELOCK_SUGGEST_UNSECURE = SECURELOCK_FIRSTSUGGEST,
    SECURELOCK_SUGGEST_MIXED,
    SECURELOCK_SUGGEST_SECUREUNKNOWNBIT,
    SECURELOCK_SUGGEST_SECURE40BIT,
    SECURELOCK_SUGGEST_SECURE56BIT,
    SECURELOCK_SUGGEST_FORTEZZA,
    SECURELOCK_SUGGEST_SECURE128BIT,
};

#define FCIDM_DRIVELIST    (FCIDM_BROWSERFIRST + 2) //
#define FCIDM_TREE         (FCIDM_BROWSERFIRST + 3) //
#define FCIDM_TABS         (FCIDM_BROWSERFIRST + 4) //
#define FCIDM_REBAR        (FCIDM_BROWSERFIRST + 5) //
// SBCMDID_SHOWCONTROL

enum {
    SBSC_HIDE = 0,
    SBSC_SHOW = 1,
    SBSC_TOGGLE = 2,
    SBSC_QUERY =  3
};

// SBCMDID_OPTIONS
enum {
        SBO_DEFAULT = 0 ,
        SBO_NOBROWSERPAGES = 1
};

// CGID_Explorer Command Target IDs
enum {
    SBCMDID_ENABLESHOWTREE          = 0,
    SBCMDID_SHOWCONTROL             = 1,        // variant vt_i4 = loword = FCW_* hiword = SBSC_*
    SBCMDID_CANCELNAVIGATION        = 2,        // cancel last navigation
    SBCMDID_MAYSAVECHANGES          = 3,        // about to close and may save changes
    SBCMDID_SETHLINKFRAME           = 4,        // variant vt_i4 = phlinkframe
    SBCMDID_ENABLESTOP              = 5,        // variant vt_bool = fEnable
    SBCMDID_OPTIONS                 = 6,        // the view.options page
    SBCMDID_EXPLORER                = 7,        // are you explorer.exe?
    SBCMDID_ADDTOFAVORITES          = 8,
    SBCMDID_ACTIVEOBJECTMENUS       = 9,
    SBCMDID_MAYSAVEVIEWSTATE        = 10,       // Should we save view stream
    SBCMDID_DOFAVORITESMENU         = 11,       // popup the favorites menu
    SBCMDID_DOMAILMENU              = 12,       // popup the mail menu
    SBCMDID_GETADDRESSBARTEXT       = 13,       // get user-typed text
    SBCMDID_ASYNCNAVIGATION         = 14,       // do an async navigation
    SBCMDID_SEARCHBAROBSOLETE       = 15,       // OBSOLETE beta-1 SEARCHBAR
    SBCMDID_FLUSHOBJECTCACHE        = 16,       // flush object cache
    SBCMDID_CREATESHORTCUT          = 17,       // create a shortcut
    SBCMDID_SETMERGEDWEBMENU        = 18,       // set pre-merged menu for HTML
    SBCMDID_REMOVELOCKICON          = 19,       // Remove lock icon
    SBCMDID_SELECTHISTPIDL          = 20,       // QS:EXEC select history pidl on navigate
    SBCMDID_WRITEHIST               = 21,       // QS only:write history sf on navigate
    SBCMDID_GETHISTPIDL             = 22,       // EXEC gets most recent history pidl
    SBCMDID_REGISTERNSCBAND         = 23,       // EXEC registers NscBand when visible
    SBCMDID_COCREATEDOCUMENT        = 24,       // Create an instance of MSHTML
    SBCMDID_SETSECURELOCKICON       = 25,       // sets the SSL lock icon for the current page
    SBCMDID_INITFILECTXMENU         = 26,       // EXEC,QS: file context menu for band item
    SBCMDID_UNREGISTERNSCBAND       = 27,       // EXEC unregisters NscBand when invisible
    SBCMDID_SEARCHBAR               = 28,       // show/hide/toggle BrowserBar search
    SBCMDID_HISTORYBAR              = 29,       // show/hide/toggle BrowserBar history
    SBCMDID_FAVORITESBAR            = 30,       // show/hide/toggle BrowserBar favorites
#ifdef ENABLE_CHANNELS
    SBCMDID_CHANNELSBAR             = 31,       // show/hide/toggle BrowserBar channels
#endif
    SBCMDID_SENDPAGE                = 32,       // sends the current page via email
    SBCMDID_SENDSHORTCUT            = 33,       // sends a shortcut to current page via email
    SBCMDID_TOOLBAREMPTY            = 34,       // toolbar has nothing visible
    SBCMDID_EXPLORERBAR             = 35,       // show/hide/toggle BrowserBar all folders
    SBCMDID_GETUSERADDRESSBARTEXT   = 36,       // get the exact text the user-entered
    SBCMDID_HISTSFOLDER             = 37,       // EXEC varOut returns cached history IShellFolder
    SBCMDID_UPDATETRAVELLOG         = 38,       // updates the travellog with the current info
    SBCMDID_MIXEDZONE               = 39,       // The current view has mixed zones
    SBCMDID_REPLACELOCATION         = 40,       // replace the current URL with this one.
    SBCMDID_GETPANE                 = 41,       // Browser asks the view for pane ordinal
    SBCMDID_FILERENAME              = 42,       // Browser forwards file->rename to explorer bar
    SBCMDID_FILEDELETE              = 43,       // Browser forwards file->delete to explorer bar
    SBCMDID_FILEPROPERTIES          = 44,       // Browser forwards file->properties to explorer bar
    SBCMDID_IESHORTCUT              = 45,       // Navigates the browser to an .url file
    SBCMDID_GETSHORTCUTPATH         = 46,       // Asks for the path to the shortcut - if it exists
    SBCMDID_DISCUSSIONBAND          = 47,       // show/hide/toggle the Office discussion band
    SBCMDID_SETADDRESSBARFOCUS      = 48,       // Set focus on address bar on WM_ACTIVATE (UNIX)
    SBCMDID_HASADDRESSBARFOCUS      = 49,       // Checks whether address bar has focus (UNIX)
    SBCMDID_MSGBAND                 = 50,       // MsgBand Message (UNIX)
    SBCMDID_ISIEMODEBROWSER         = 51,       // returns S_OK if browser is in IE mode
    SBCMDID_GETTEMPLATEMENU         = 52,       // get handle to template menu
    SBCMDID_GETCURRENTMENU          = 53,       // get handle to current menu
    SBCMDID_ERRORPAGE               = 54,       // informs addressbar mru that this is an error page
    SBCMDID_AUTOSEARCHING           = 55,       // informs addressbar mru that we are trying a new url
    SBCMDID_STARTEDFORINTERNET      = 56,       // return S_OK if window started as IE window, S_FALSE otherwise
    SBCMDID_ISBROWSERACTIVE         = 57,       // return S_OK if the browser is active, S_FALSE otherwise
    SBCMDID_SUGGESTSAVEWINPOS       = 58,       // return S_OK if browser decides to save window position, S_FALSE otherwise
    SBCMDID_CACHEINETZONEICON       = 59,       // Cache/refresh internet zone icons painted by status bar
    SBCMDID_ONVIEWMOVETOTOP         = 60,       // Notification that the view window has moved to HWND_TOP
    SBCMDID_ONCLOSE                 = 61,       // Close notification destined for the dochost.
    SBCMDID_CANCELANDCLOSE          = 62,       // Cancel the async download and close the browser.
    SBCMDID_MEDIABAR                = 63,       // show/hide/toggle MediaBar
};

#define ZONE_UNKNOWN    -1
#define ZONE_MIXED      -2
#define IS_SPECIAL_ZONE(a) (((a) == ZONE_UNKNOWN) || ((a) == ZONE_MIXED))


#if (_WIN32_IE >= 0x0400)
// CGID_AddresseditBox Command Target IDs
enum {
    AECMDID_SAVE                    = 0,        // Ask AddressEditBox to save
};
#endif

#ifdef NONAMELESSUNION
#define NAMELESS_MEMBER(member) DUMMYUNIONNAME.##member
#else
#define NAMELESS_MEMBER(member) member
#endif

#define STRRET_OLESTR  STRRET_WSTR          // same as STRRET_WSTR
#define STRRET_OFFPTR(pidl,lpstrret) ((LPSTR)((LPBYTE)(pidl)+(lpstrret)->NAMELESS_MEMBER(uOffset)))
// DOC'ed for DOJ compliance
SHSTDAPI SHParseShellItem(LPCWSTR psz, IShellItem **ppsi);
SHSTDAPI SIEnumObjects(IShellItem *psi, HWND hwnd, SHCONTF flags, IEnumShellItems **ppenum);
SHSTDAPI SHCreateShellItemArray(LPCITEMIDLIST pidlParent,IShellFolder *psfParent,UINT cidl,
                                        LPCITEMIDLIST *ppidl,IShellItemArray **ppsiItemArray);


#define REGSTR_PATH_INTERNET_EXPLORER   TEXT("\\SOFTWARE\\Microsoft\\Internet Explorer")
#define REGSTR_PATH_IE_MAIN             REGSTR_PATH_INTERNET_EXPLORER TEXT("\\Main")
#define REGSTR_VALUE_USER_AGENT         TEXT("UserAgent")
#define REGSTR_DEFAULT_USER_AGENT       TEXT("Mozilla/2.0 (compatible; MSIE 3.0A; Windows 95)")
                                    //  0x000f
#define CSIDL_PERUSER_TEMP              0x0032        // per user TEMP                      (reserved, not impelemented)
#define CSIDL_9XCOMMAND                 0x0033        // Win9x COMMANDN (dos programs)      (reserved, not impelemented)
#define CSIDL_9XSYSTEM                  0x0034        // Win9x/NT system (not system32)     (reserved, not impelemented)
#define CSIDL_FLAG_DONT_UNEXPAND        0x2000        // combine with CSIDL_ value to avoid unexpanding environment variables
// DOC'ed for DOJ compliance
SHFOLDERAPI SHSetFolderPathA(int csidl, HANDLE hToken, DWORD dwFlags, LPCSTR pszPath);
                                    //  0x000f
#define CSIDL_PERUSER_TEMP              0x0032        // per user TEMP                      (reserved, not impelemented)
#define CSIDL_9XCOMMAND                 0x0033        // Win9x COMMANDN (dos programs)      (reserved, not impelemented)
#define CSIDL_9XSYSTEM                  0x0034        // Win9x/NT system (not system32)     (reserved, not impelemented)
#define CSIDL_FLAG_DONT_UNEXPAND        0x2000        // combine with CSIDL_ value to avoid unexpanding environment variables
// DOC'ed for DOJ compliance
SHFOLDERAPI SHSetFolderPathW(int csidl, HANDLE hToken, DWORD dwFlags, LPCWSTR pszPath);
#ifdef UNICODE
#define SHSetFolderPath  SHSetFolderPathW
#else
#define SHSetFolderPath  SHSetFolderPathA
#endif // !UNICODE

SHSTDAPI_(BOOL) MakeShellURLFromPathA(LPCSTR pszPathIn, LPSTR pszUrl, DWORD dwCch);
SHSTDAPI_(BOOL) MakeShellURLFromPathW(LPCWSTR pszPathIn, LPWSTR pszUrl, DWORD dwCch);
#ifdef UNICODE
#define MakeShellURLFromPath  MakeShellURLFromPathW
#else
#define MakeShellURLFromPath  MakeShellURLFromPathA
#endif // !UNICODE

SHSTDAPI_(BOOL) SHIsTempDisplayMode();

SHSTDAPI_(FILEDESCRIPTOR *) GetFileDescriptor(FILEGROUPDESCRIPTOR *pfgd, BOOL fUnicode, int nIndex, LPTSTR pszName);
SHSTDAPI CopyStreamUI(IStream *pstmSrc, IStream *pstmDest, IProgressDialog *pdlg, ULONGLONG ullMaxBytes);


// DOC'ed for DOJ compliance
// above was doc'ed for DOJ compliance
    // pszTitle can be a resource, but the hinst is assumed to be shell32.dll
    // lpszTitle can be a resource, but the hinst is assumed to be shell32.dll

//-------------------------------------------------------------------------
//
// Shell Service Object
//
//-------------------------------------------------------------------------
// Cmds for CGID_ShellServiceObject
enum {
    SSOCMDID_OPEN        = 2,
    SSOCMDID_CLOSE       = 3,
};


#define CMDID_SAVEASTHICKET     5


//-------------------------------------------------------------------------
// STR_DISPLAY_UI_DURING_BINDING - IBindCtx Key
//-------------------------------------------------------------------------
// If displaying UI during binding is allowed, this parameter
// will be in the IBindCtx so the object binding can get the
// IUnknown* of the site in order to:
// 1. Use the site's hwnd as the parent hwnd of any UI dialogs.
//    This is done via. IOleWindow::GetWindow() or IInternetSecurityMgrSite::GetWindow()
// 2. While the dialog is being displayed, make the site modal
//    This is done via:
//       IOleInPlaceActiveObject::EnableModeless()
//       IOleInPlaceUIWindow::EnableModelessSB()
//       IInternetSecurityMgrSite::EnableModeless()

#define STR_DISPLAY_UI_DURING_BINDING      L"UI During Binding"

// bindctx key, tells an FS folder to ignore the STGM_CREATE flag in ParseDisplayName.
// otherwise it will always succeed, but we need to be able to force it to fail for
// the cd-r drive.
#define STR_DONT_FORCE_CREATE              L"Don't Force Create"

// bindctx key, passed to IShellFolder::ParseDisplayName().  gives netfldr extra
// information it can use to route the parsing of the name we are giving it.
#define STR_PARSE_NETFOLDER_INFO                L"Net Parse Data"

// in the property bag associated with STR_PARSE_NETFOLDER_INFO this string property
// defines the WNetProvider to be used when calling WNetGetResourceInformation.
#define STR_PARSE_NETFOLDER_PROVIDERNAME        L"WNetProvider"


//
// The IShellDetails interface was private in win95 and didnt have a _WIN32_IE guard,
// so it is now in shlobj.h, along with the definition of SHELLDETAILS
//


//-------------------------------------------------------------------------
//
// DELEGATEITEMID structure
//
//
// A Delegate Item ID is a standard SHITEMID with some additional
// fields defined.
//
//-------------------------------------------------------------------------

typedef struct tagDELEGATEITEMID {
    WORD cbSize;                // Size of entire item ID
    WORD wOuter;                // Private data owned by the outer folder
    WORD cbInner;               // Size of delegate's data
    BYTE rgb[1];                // Inner folder's data,
                                //   followed by outer folder's data.
} DELEGATEITEMID;

typedef const UNALIGNED DELEGATEITEMID *PCDELEGATEITEMID;
typedef UNALIGNED DELEGATEITEMID *PDELEGATEITEMID;


//-------------------------------------------------------------------------
//
// IDelegateFolder interface
//
//
// [Member functions]
//
// IDelegateFolder::SetItemAlloc(pm)
//   This function gives the object an IMalloc interface that it
//   should use to alloc and free item IDs.  These IDs are in the
//   form of DELEGATEITEMIDs.
//
//-------------------------------------------------------------------------

#undef INTERFACE
#define INTERFACE IDelegateFolder

DECLARE_INTERFACE_(IDelegateFolder, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDelegateFolder methods ***
    STDMETHOD(SetItemAlloc)(THIS_ IMalloc *pmalloc) PURE;
};

#undef  INTERFACE
#define INTERFACE   IMountedVolume

DECLARE_INTERFACE_(IMountedVolume, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMountedVolume methods ***
    STDMETHOD(Initialize)(THIS_ LPCWSTR pcszHostFolderPath) PURE;
};
//-------------------------------------------------------------------------
// This is the interface for a browser to "subclass" the main File Cabinet
// window.  Note that only the hwnd, message, wParam, and lParam fields of
// the msg structure are used.  The browser window will get a WM_NOTIFY
// message with NULL ID, FCN_MESSAGE as the code, and a pointer to
// FCMSG_NOTIFY as the lParam.
//
//-------------------------------------------------------------------------

#include <pshpack8.h>

typedef struct tagFCMSG_NOTIFY
{
    NMHDR   hdr;
    MSG     msg;
    LRESULT lResult;
} FCMSG_NOTIFY;

#include <poppack.h>        /* Return to byte packing */

#define FCN_MESSAGE (100)


//---------------------------------------------------------------------------
// messages that can be send to the cabinet by other apps
//
// REVIEW: Do we really need to publish any of those?
//---------------------------------------------------------------------------

#define NF_INHERITVIEW 0x0000
#define NF_LOCALVIEW   0x0001

// Change the path of an existing folder.
// wParam:
//      0:              LPARAM is a pidl, handle the message immediately.
//      CSP_REPOST:     LPARAM is a pidl, copy the pidl and handle the
//                      message later.
//      CSP_NOEXECUTE:  if this path is not a folder, fail, don't shell exec
//
//
// lParam: LPITEMIDLIST of path.
//
//
#define CSP_REPOST                  0x0001
#define CSP_INITIATEDBYHLINKFRAME   0x0002
#define CSP_NOEXECUTE               0x0004
#define CSP_NONAVIGATE              0x0008
#define CWM_SETPATH                 (WM_USER + 2)

// lpsv points to the Shell View extension that requested idle processing
// uID is an app define identifier for the processor
// returns: TRUE if there is more idle processing necessary, FALSE if all done
// Note that the idle processor should do one "atomic" operation and return
// as soon as possible.
typedef BOOL (CALLBACK *FCIDLEPROC)(void *lpsv, UINT uID);

// Inform the File Cabinet that you want idle messages.
// This should ONLY be used by File Cabinet extensions.
// wParam: app define UINT (passed to FCIDLEPROC).
// lParam: pointer to an FCIDLEPROC.
// return: TRUE if successful; FALSE otherwise
//
#define CWM_WANTIDLE                (WM_USER + 3)

// get or set the FOLDERSETTINGS for a view
// wParam: BOOL TRUE -> set to view info buffer, FALSE -> get view info buffer
// lParam: LPFOLDERSETTINGS buffer to get or set view info
//
#define CWM_GETSETCURRENTINFO       (WM_USER + 4)
#define FileCabinet_GetSetCurrentInfo(_hwnd, _bSet, _lpfs) \
             SendMessage(_hwnd, CWM_GETSETCURRENTINFO, (WPARAM)(_bSet), (LPARAM)(LPFOLDERSETTINGS)_lpfs)

// selects the specified item in the current view
// wParam: SVSI_* flags
// lParam: LPCITEMIDLIST of the item ID, NULL -> all items
//
#define CWM_SELECTITEM              (WM_USER + 5)
#define FileCabinet_SelectItem(_hwnd, _sel, _item) \
            SendMessage(_hwnd, CWM_SELECTITEM, _sel, (LPARAM)(LPCITEMIDLIST)(_item))

// selects the specified path in the current view
// wParam: SVSI_* flags
// lParam: LPCSTR of the display name
//
#define CWM_SELECTPATH              (WM_USER + 6)
#define FileCabinet_SelectPath(_hwnd, _sel, _path)  \
            SendMessage(_hwnd, CWM_SELECTPATH, _sel, (LPARAM)(LPCSTR)(_path))

// Get the IShellBrowser object associated with an hwndMain
#define CWM_GETISHELLBROWSER        (WM_USER + 7)
#define FileCabinet_GetIShellBrowser(_hwnd)     \
            (IShellBrowser*)SendMessage(_hwnd, CWM_GETISHELLBROWSER, 0, 0L)

//
//  two pidls can have the same path, so we need a compare pidl message
#define CWM_COMPAREPIDL                (WM_USER + 9)
//
//  sent when the global state changes
#define CWM_GLOBALSTATECHANGE           (WM_USER + 10)
#define CWMF_GLOBALSTATE                0x0000
#define CWMF_SECURITY                   0x0001

//  sent to the desktop from a second instance
#define CWM_COMMANDLINE                 (WM_USER + 11)
// global clone your current pidl
#define CWM_CLONEPIDL                   (WM_USER + 12)
// See if the root of the instance is as specified
#define CWM_COMPAREROOT                 (WM_USER + 13)
// Tell desktop our root
#define CWM_SPECIFYCOMPARE              (WM_USER + 14)
// See if the root of the instance matches a hwnd
#define CWM_PERFORMCOMPARE              (WM_USER + 15)
// Forward SHChangeNotify events
#define CWM_FSNOTIFY                    (WM_USER + 16)
// Forward SHChangeRegistration events
#define CWM_CHANGEREGISTRATION          (WM_USER + 17)
// For AddToRecentDocs processing by desktop
#define CWM_ADDTORECENT                 (WM_USER + 18)
// For SHWaitForFile processing by desktopop
#define CWM_WAITOP                      (WM_USER + 19)
// Notify for changes to the fav's folder.
#define CWM_FAV_CHANGE                  (WM_USER + 20)
#define CWM_SHOWDRAGIMAGE               (WM_USER + 21)

#define CWM_SHOWFOLDEROPT               (WM_USER + 22)
#define CWMW_FOLDEROPTIONS      0               // wParam for CWM_SHOWFOLDEROPT
#define CWMW_TASKBAROPTIONS     1               // wParam for CWM_SHOWFOLDEROPT

#define CWM_FSNOTIFYSUSPENDRESUME       (WM_USER + 23)
#define CWM_CREATELOCALSERVER           (WM_USER + 24)
#define CWM_GETSCNWINDOW                (WM_USER + 25)
#define CWM_TASKBARWAKEUP               (WM_USER + 26) // Used to restore tray thread to normal priority in extremely stressed machines
#define CWM_STARTNETCRAWLER             (WM_USER + 27) 

#define CWM_RESERVEDFORCOMDLG_FIRST     (WM_USER + 100)
#define CWM_RESERVEDFORCOMDLG_LAST      (WM_USER + 199)
#define CWM_RESERVEDFORWEBBROWSER_FIRST (WM_USER + 200)
#define CWM_RESERVEDFORWEBBROWSER_LAST  (WM_USER + 299)


//   ;BUGBUG (scotth): fill this in
#define STFRF_NORMAL            DWFRF_NORMAL
#define STFRF_DELETECONFIGDATA  DWFRF_DELETECONFIGDATA

#undef  INTERFACE
#define INTERFACE   IMultiMonitorDockingSite

DECLARE_INTERFACE_(IMultiMonitorDockingSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMultiMonitorDockingSite methods ***
    STDMETHOD(GetMonitor) (THIS_ IUnknown* punkSrc, HMONITOR * phMon) PURE;
    STDMETHOD(RequestMonitor) (THIS_ IUnknown* punkSrc, HMONITOR * phMon) PURE;
    STDMETHOD(SetMonitor) (THIS_ IUnknown* punkSrc, HMONITOR hMonNew, HMONITOR *phMonOld) PURE;
};
#if (_WIN32_IE >= 0x0400)

// Interface used to scale and sharpen images...
// right now, always pass the palette from SHCreateShellPalette on a 256 colour machine...
#undef  INTERFACE
#define INTERFACE   IScaleAndSharpenImage2

DECLARE_INTERFACE_ (IScaleAndSharpenImage2, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IScaleAndSharpenImage methods ***
    STDMETHOD( ScaleSharpen2 ) ( THIS_ BITMAPINFO * pbi,
                                void * pBits,
                                HBITMAP * phBmpThumbnail,
                                const SIZE * prgSize,
                                DWORD dwRecClrDepth,
                                HPALETTE hpal,
                                UINT uiSharpPct,
                                BOOL fOrigSize) PURE;
};

// IImageCache
// Interface for controlling and accessing an imagecache of bitmaps for icons..

// flags for the dwMask member of IMAGECACHEINFO
#define ICIFLAG_LARGE       0x0001
#define ICIFLAG_SMALL       0x0002
#define ICIFLAG_BITMAP      0x0004
#define ICIFLAG_ICON        0x0008
#define ICIFLAG_INDEX       0x0010
#define ICIFLAG_NAME        0x0020
#define ICIFLAG_FLAGS       0x0040
#define ICIFLAG_NOUSAGE     0x0080
#define ICIFLAG_DATESTAMP   0x0100
#define ICIFLAG_MIRROR      0x2000
#if (_WIN32_IE >= 0x0501)
#define ICIFLAG_SYSTEM      0x4000
#endif

typedef struct _tagImageCacheInfo
{
    DWORD        cbSize;
    DWORD        dwMask;
    union
    {
        HBITMAP  hBitmapLarge;
        HICON    hIconLarge;
    };
    HBITMAP      hMaskLarge;
    union
    {
        HBITMAP  hBitmapSmall;
        HICON    hIconSmall;
    };
    HBITMAP      hMaskSmall;
    LPCWSTR      pszName;
    int          iIndex;
    DWORD        dwFlags;
#if (_WIN32_IE >= 0x0500)
    FILETIME     ftDateStamp;
#endif
} IMAGECACHEINFO;

typedef IMAGECACHEINFO * LPIMAGECACHEINFO;
typedef const IMAGECACHEINFO * LPCIMAGECACHEINFO;

#define ICIIFLAG_LARGE          0x0001
#define ICIIFLAG_SMALL          0x0002
#if (_WIN32_IE >= 0x0501)
#define ICIIFLAG_SORTBYUSED     0x0004
#endif

typedef struct _tagImageCacheInitInfo
{
    DWORD cbSize;
    DWORD dwMask;
    HIMAGELIST himlLarge;
    HIMAGELIST himlSmall;
    SIZEL rgSizeLarge;
    SIZEL rgSizeSmall;
    DWORD dwFlags;
    int   iStart;
    int   iGrow;
}IMAGECACHEINITINFO;

typedef IMAGECACHEINITINFO * LPIMAGECACHEINITINFO;

#undef  INTERFACE
#define INTERFACE   IImageCache

DECLARE_INTERFACE_ ( IImageCache, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IImageCache methods ***
    STDMETHOD ( AddImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FindImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FreeImage ) ( THIS_ UINT iImageIndex ) PURE;
    STDMETHOD ( Flush )( THIS_ BOOL fRelease ) PURE;
    STDMETHOD ( ChangeImageInfo ) ( THIS_ UINT IImageIndex, LPCIMAGECACHEINFO pInfo ) PURE;
    STDMETHOD ( GetCacheSize ) ( THIS_ UINT * puSize ) PURE;
    STDMETHOD ( GetUsage ) ( THIS_ UINT uIndex, UINT * puUsage ) PURE;

    STDMETHOD( GetImageList ) ( THIS_ LPIMAGECACHEINITINFO pInfo ) PURE;
};
typedef IImageCache * LPIMAGECACHE;

#if (_WIN32_IE >= 0x0500)

// IImageCache 2

#undef  INTERFACE
#define INTERFACE  IImageCache2

DECLARE_INTERFACE_ ( IImageCache2, IImageCache )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IImageCache methods ***
    STDMETHOD ( AddImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FindImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FreeImage ) ( THIS_ UINT iImageIndex ) PURE;
    STDMETHOD ( Flush )( THIS_ BOOL fRelease ) PURE;
    STDMETHOD ( ChangeImageInfo ) ( THIS_ UINT IImageIndex, LPCIMAGECACHEINFO pInfo ) PURE;
    STDMETHOD ( GetCacheSize ) ( THIS_ UINT * puSize ) PURE;
    STDMETHOD ( GetUsage ) ( THIS_ UINT uIndex, UINT * puUsage ) PURE;

    STDMETHOD( GetImageList ) ( THIS_ LPIMAGECACHEINITINFO pInfo ) PURE;

    // IImageCache2 methods
    STDMETHOD ( DeleteImage ) ( THIS_ UINT iImageIndex ) PURE;
    STDMETHOD ( GetImageInfo ) (THIS_ UINT iImageIndex, LPIMAGECACHEINFO pInfo ) PURE;
};

#endif

#if (_WIN32_IE >= 0x0501)

// These are values returned from IImageCache::GetUsage which correspond
// to the state of the cache entry
#define ICD_USAGE_NOUSAGE (UINT) -1
#define ICD_USAGE_DELETED (UINT) -2
#define ICD_USAGE_SYSTEM  (UINT) -3

// IImageCache 3
#undef  INTERFACE
#define INTERFACE  IImageCache3

DECLARE_INTERFACE_ ( IImageCache3, IImageCache2 )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IImageCache methods ***
    STDMETHOD ( AddImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FindImage ) ( THIS_ LPCIMAGECACHEINFO pInfo, UINT * puIndex ) PURE;
    STDMETHOD ( FreeImage ) ( THIS_ UINT iImageIndex ) PURE;
    STDMETHOD ( Flush )( THIS_ BOOL fRelease ) PURE;
    STDMETHOD ( ChangeImageInfo ) ( THIS_ UINT IImageIndex, LPCIMAGECACHEINFO pInfo ) PURE;
    STDMETHOD ( GetCacheSize ) ( THIS_ UINT * puSize ) PURE;
    STDMETHOD ( GetUsage ) ( THIS_ UINT uIndex, UINT * puUsage ) PURE;

    STDMETHOD ( GetImageList ) ( THIS_ LPIMAGECACHEINITINFO pInfo ) PURE;

    // *** IImageCache2 methods ***
    STDMETHOD ( DeleteImage ) ( THIS_ UINT iImageIndex ) PURE;
    STDMETHOD ( GetImageInfo ) (THIS_ UINT iImageIndex, LPIMAGECACHEINFO pInfo ) PURE;

    // *** IImageCache3 methods ***
    STDMETHOD ( GetImageIndexFromCacheIndex )( UINT iCacheIndex, UINT * puImageIndex ) PURE;
};

#endif

//
// Interface for interacting with the IE splash screen
//

#undef  INTERFACE
#define INTERFACE   ISplashScreen

DECLARE_INTERFACE_( ISplashScreen, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** ISplashScreen methods ***
    STDMETHOD ( Show ) ( THIS_ HINSTANCE hinst, UINT idResHi, UINT idResLow, HWND * phwnd ) PURE;
    STDMETHOD ( Dismiss ) (THIS) PURE;
};

typedef ISplashScreen * LPSPLASHSCREEN;


//
// Interface for Multiple Monitor Configurations
//

#define MD_PRIMARY  0x00000001
#define MD_ATTACHED 0x00000002

#include <pshpack8.h>

typedef struct _MonitorData
{
    DWORD dwSize;
    DWORD dwFlags;
    DWORD dwStatus;
    RECT rcPos;
} MonitorData, * LPMONITORDATA;

#include <poppack.h>        /* Return to byte packing */

#undef  INTERFACE
#define INTERFACE   IMultiMonConfig

DECLARE_INTERFACE_( IMultiMonConfig, IUnknown )
{
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef) ( THIS ) PURE;
    STDMETHOD_(ULONG, Release) ( THIS ) PURE;

    // *** IMultiMonConfig methods ***
    STDMETHOD ( Initialize ) ( THIS_ HWND hwndHost, WNDPROC WndProc, DWORD dwReserved) PURE;
    STDMETHOD ( GetNumberOfMonitors ) (THIS_ int * pCMon, DWORD dwReserved) PURE;
    STDMETHOD ( GetMonitorData) (THIS_ int iMonitor, MonitorData * pmd, DWORD dwReserved) PURE;
    STDMETHOD ( Paint) (THIS_ int iMonitor, DWORD dwReserved) PURE;
};

typedef IMultiMonConfig * LPMULTIMONCONFIG;
#endif // _WIN32_IE > 0x0400

////  IRestrict
// For the pdwRestrictionResult out parameter in IRestrict::IsRestricted() for
// all pguidIDs.
typedef enum
{
    RR_ALLOW  = 1,
    RR_DISALLOW,
    RR_NOCHANGE,
} RESTRICTION_RESULT;

// IRestrict::IsRestricted() dwRestrictAction parameter values for
// the RID_RDeskBars pguidID.
typedef enum
{
    RA_DRAG  = 1,
    RA_DROP,
    RA_ADD,
    RA_CLOSE,
    RA_MOVE,
} RESTRICT_ACTIONS;

#undef INTERFACE
#define INTERFACE IRestrict

DECLARE_INTERFACE_(IRestrict, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRestrict Methods ***
    STDMETHOD(IsRestricted) (THIS_ const GUID * pguidID, DWORD dwRestrictAction, VARIANT * pvarArgs, OUT DWORD * pdwRestrictionResult) PURE;
};


////  IAddressBand
#define OLECMD_REFRESH_TOPMOST     0x00000000
#define OLECMD_REFRESH_ENTIRELIST  0x00000001

#undef INTERFACE
#define INTERFACE IAddressBand

DECLARE_INTERFACE_(IAddressBand, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAddressBand Methods ***
    STDMETHOD(FileSysChange) (THIS_ DWORD dwEvent, LPCITEMIDLIST * ppidl1) PURE;
    STDMETHOD(Refresh) (THIS_ VARIANT * pvarType) PURE;
};

#undef INTERFACE
#define INTERFACE IAddressEditBox

// Init Flags
#define AEB_INIT_DEFAULT     0x00000000
#define AEB_INIT_NOSHELL     0x00000001
#define AEB_INIT_NOWEB       0x00000002
#define AEB_INIT_NOFILE      0x00000004
#define AEB_INIT_AUTOEXEC    0x00000008     // Set if you want the item Navigated/ShellExeced when ENTER occurs.
#define AEB_INIT_SUBCLASS    0x00000010     // If set parent needs to pass HWND events thru IWinEventHandler::OnWinEvent()
#define AEB_INIT_NOASYNC     0x00000020     // Set if you don't want/support async navigation (from a modal dlg for instance)

// Parse Flags for IAddressEditBox::ParseNow()
#define SHURL_FLAGS_NONE        0x00000000
#define SHURL_FLAGS_NOUI        0x00000001      // Don't display any UI.
#define SHURL_FLAGS_NOSNS       0x00000002      // Ignore SHELL URLs. (FILE and Internet URLs still work)
#define SHURL_FLAGS_NOWEB       0x00000004      // Ignore WEB URLs. (Don't successfully parse if not found in shell name space)
#define SHURL_FLAGS_NOPATHSEARCH 0x00000008     // don't search on dos paths or app path
#define SHURL_FLAGS_AUTOCORRECT 0x00000010      // Try to autocorrect WEB URLs

// Exec Flags for IAddressEditBox::Execute()
#define SHURL_EXECFLAGS_NONE        0x00000000
#define SHURL_EXECFLAGS_SEPVDM      0x00000001      // If ShellExec(), set SEE_MASK_FLAG_SEPVDM fMask.
#define SHURL_EXECFLAGS_DONTFORCEIE 0x00000002      // If some browser other than IE is associated with HTML files, allow them to launch.


DECLARE_INTERFACE_(IAddressEditBox, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAddressEditBox Methods ***
    STDMETHOD(Init) (THIS_ HWND hwnd, HWND hwndEditBox, DWORD dwFlags, IUnknown * punkParent) PURE;
    STDMETHOD(SetCurrentDir) (THIS_ LPCOLESTR pwzDir) PURE;
    STDMETHOD(ParseNow) (THIS_ DWORD dwParseFlags) PURE;
    STDMETHOD(Execute) (THIS_ DWORD dwExecFlags) PURE;
    STDMETHOD(Save) (THIS_ DWORD dwReserved) PURE;
};


#if (_WIN32_IE >= 0x0400)


#define ISFB_MASK_ALL            0x0000003F         //
#define ISFB_MASK_INVALID        (~(ISFB_MASK_ALL)) //
//#define ISFB_STATE_NOTITLE       0x00000008 // obsolete! (use cbs::SetBandState)
#define ISFB_STATE_ALL           0x000001FF //

//-------------------------------------------------------------------------
//
// IWinEventHandler interface
//
//   An object that wants to send messages to another object (typically
// a sub-object) QI's for the sub-object's IWinEventHandler interface.
// Once the object determines the hwnd is owned by the sub-object (via
// IsWindowOwner), the object calls OnWinEvent for send the message.
//
//
// [Member functions]
//
// IWinEventHandler::IsWindowOwner(hwnd)
//   Returns S_OK if the hwnd is owned by the object, S_FALSE if not.
//
// IWinEventHandler::OnWinEvent(hwnd, dwMsg, wParam, lParam, plRet)
//   Sends a message to the object.  The Win32 return value (i.e., the
//   value returned by DefWindowProc) is returned in *plRet.  Return
//   S_OK if the message is handled, otherwise S_FALSE.
//
//-------------------------------------------------------------------------


#undef INTERFACE
#define INTERFACE IWinEventHandler

DECLARE_INTERFACE_(IWinEventHandler, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWinEventHandler Methods ***
    STDMETHOD(OnWinEvent) (THIS_ HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres) PURE;
    STDMETHOD(IsWindowOwner) (THIS_ HWND hwnd) PURE;
};



#endif // _WIN32_IE > 0x0400


//==========================================================================
// IExplorerToolbar interfaces
//
//  This is an interface to the shell toolbar which allows shell views
// to add buttons and process.
// See http://ohserv/users/satona/toolbar_extension.htm for spec.
//
//==========================================================================

// Bitmap types
#define BITMAP_NORMAL         0x1
#define BITMAP_HOT            0x2
#define BITMAP_DISABLED       0x3

// Band Visibility Flags
#define VBF_TOOLS               0x00000001
#define VBF_ADDRESS             0x00000002
#define VBF_LINKS               0x00000004
#define VBF_BRAND               0x00000008
#define VBF_MENU                0x00000010

#define VBF_ONELINETEXT         0x00000020
#define VBF_TWOLINESTEXT        0x00000040
#define VBF_NOCUSTOMIZE         0x00000080

#define VBF_EXTERNALBANDS       0xFFFF0000

#define VBF_VALID               (VBF_TOOLS | VBF_ADDRESS | VBF_LINKS | VBF_BRAND | VBF_MENU | VBF_EXTERNALBANDS)

#undef  INTERFACE
#define INTERFACE   IExplorerToolbar

typedef enum {
    ETCMDID_GETBUTTONS          = 0x0001,
    ETCMDID_NEWCOMMANDTARGET    = 0x0002,   // sent to the previous command target when a new one is coming in
#if (_WIN32_IE >= 0x500)
    ETCMDID_RELOADBUTTONS       = 0x0003,   // command target needs to call AddButtons again
#endif
} ENUM_ETCMDID;

DECLARE_INTERFACE_(IExplorerToolbar, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExplorerToolbar methods ***
    STDMETHOD(SetCommandTarget) (THIS_ IUnknown* punkCmdTarget, const GUID* pguidCmdGrp, DWORD dwFlags) PURE;
    STDMETHOD(AddStdBrowserButtons) (THIS) PURE;

    // Wrap of the TB_* messages the messages that are implmented
    // are just the ones to add delete and modify the buttons, and not
    // the ones to manipulate the toolbar.
    STDMETHOD(AddButtons)       (THIS_ const GUID * pguidButtonGroup, UINT nButtons, const TBBUTTON * lpButtons) PURE;
    STDMETHOD(AddString)        (THIS_ const GUID * pguidButtonGroup, HINSTANCE hInst, UINT_PTR uiResID, LRESULT * pOffset) PURE;
    STDMETHOD(GetButton)        (THIS_ const GUID * pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton) PURE;
    STDMETHOD(GetState)         (THIS_ const GUID * pguidButtonGroup, UINT uiCommand, UINT * pfState) PURE;
    STDMETHOD(SetState)         (THIS_ const GUID * pguidButtonGroup, UINT uiCommand, UINT fState) PURE;
    STDMETHOD(AddBitmap)        (THIS_ const GUID * pguidButtonGroup, UINT uiBMPType, UINT uiCount, TBADDBITMAP * ptb,
                                                        LRESULT * pOffset, COLORREF rgbMask) PURE;
    STDMETHOD(GetBitmapSize)    (THIS_ UINT * uiID) PURE;
    STDMETHOD(SendToolbarMsg)   (THIS_ const GUID * pguidButtonGroup, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT * plRes) PURE;

    STDMETHOD(SetImageList) (THIS_ const GUID* pguidCmdGroup, HIMAGELIST himlNormal, HIMAGELIST himlHot, HIMAGELIST himlDisabled) PURE;
    STDMETHOD(ModifyButton)     (THIS_ const GUID * pguidButtonGroup, UINT uiCommand, LPTBBUTTON lpButton) PURE;
};

//==========================================================================
// DefView supports a private service id for extended views.
// DefView's IOleCommandTarget supports the below command group and ids too.
//==========================================================================
// SID_DefView and CGID_DefView are defined in shlguid.w
//
#define DVCMDID_GETTHISDIRPATH 1 // pvaOut = path to this directory (if in filesystem)
#define DVCMDID_GETTHISDIRNAME 2 // pvaOut = friendly name of this directory
#define DVCMDID_GETTEMPLATEDIRNAME 3 // pvaOut = webview template (.htt) dir
#define IS_ADJUSTLISTVIEW       0x80000000
#define IS_INTERNALDUMMYBIT     0x40000000
#define IS_VALIDINTERNALBITS    (IS_ADJUSTLISTVIEW | IS_INTERNALDUMMYBIT)
#define CFSTR_SHELLIDLISTP                  TEXT("Shell IDLData Private")
#define CFSTR_SHELLCOPYDATA                 TEXT("Shell Copy Data")
#define CFSTR_DROPEFFECTFOLDERLIST          TEXT("DropEffectFolderList")
//
// Win 3.1 style HDROP
//
//  Notes: Our API works only if pFiles == sizeof(DROPFILES16)
//
typedef struct _DROPFILES16 {
    WORD pFiles;                // offset to double null list of files
    POINTS pt;                  // drop point (client coords)
    WORD fNC;                   // is it on non client area
                                // and pt is in screen coords
} DROPFILES16, * LPDROPFILES16;

//
// format of CF_SHELLCOPYDATA
//

typedef struct _SHELLCOPYDATA {
    DWORD dwEffect;                 // Intended effect
} SHELLCOPYDATA;

//
// CFSTR_DROPEFFECTFOLDERLIST defines the drop effects to certain folders
// this is applied when dropping to a file system folder.
//

typedef struct {
    DWORD dwDropEffect;
    WCHAR wszPath[MAX_PATH];
} DROPEFFECTFOLDER;

typedef struct {
    DWORD dwDefaultDropEffect;          // default drop effect (==0 for current behaviour)
    INT cFolders;                       // number of folders in the list
    DROPEFFECTFOLDER aFolders[1];
} DROPEFFECTFOLDERLIST;
//------ See shelldll\fsnotify.c for function descriptions. ----------

//
//  Definition of the function type to be called by the notification
//  service when a file the client has registered to monitor changes.
//

// DOC'ed for DOJ compliance:
#define SHCNRF_InterruptLevel      0x0001
#define SHCNRF_ShellLevel          0x0002

// If the caller passes SHCNRF_RecursiveInterrupt (meaning that they want interrupt events on the whole
// subtree), then they must also pass SHCNRF_InterruptLevel flag (duh), and they must be a recursive (eg
// fRecursive == TRUE) type notification.
#define SHCNRF_RecursiveInterrupt  0x1000
#define SHCNRF_ResumeThread        0x2000
#define SHCNRF_CreateSuspended     0x4000
#define SHCNRF_NewDelivery         0x8000

// !! WARNING !!
// If you change/add any new SHCNE_ events, you will need
// to possibly modify the SHCNE_XXXXEVENTS masks that are
// defined below as well.
// NOTE: SHCNE_GLOBALEVENTS are typically used to pass
// non-pidl information (packed into pidl format). We cannot
// extend SHCNE_GLOBALEVENTS and expect clients of the new
// events to work on a down-level shell32. In fact, they
// may very well fault during psfDesktop->CompareIDs.
// So be careful when adding to this bitfield!
//
// Win95 and NT4 and IE4 shipped with 0x0C0581E0L.
// We use this event mask to tell if we need to possibly throw out a SHCNE_UPDATEDIR that was
// generated by the filesystem because we have a more specific event already in our queue.
// NOTE: only non-interrupt events could cause us to throw out a interrupt generated UPDATEDIR event.
#define SHCNE_UPDATEDIR_OVERRIDE_EVENTS 0x00023818L
// This event was defined early on in IE4 for the Theme Switcher to
// notify the shell that a system-wide update needed to happen.
// This has been removed but I don't want to re-use the id just yet...

// BUGBUG (scotth) 6/11/98: can we remove this yet??

//#define SHCNEE_THEMECHANGED       1L  // The theme changed
#define SHCNEE_WININETCHANGED       3L  // dwItem2 contains CACHE_NOTIFY_* bits
#if (_WIN32_IE >= 0x0500)
#define SHCNEE_PROMOTEDITEM         6L  // pidl2 is the pidl of the Promoted item
#define SHCNEE_DEMOTEDITEM          7L  // pidl2 is the pidl of the demoted item
#define SHCNEE_ALIASINUSE           8L  // some alias style folder is now being used
#endif
#if (_WIN32_IE >= 0x0600)
#define SHCNEE_SHORTCUTINVOKE       9L  // an app has been launched via a shortcut
                                        // pidl1 = SHShortcutInvokeAsIDList, pidl2=unused
#define SHCNEE_PINLISTCHANGED      10L  // a change was made to the pin list
                                        // pidl1 = SHChangeDWORDAsIDList, pidl2=unused
#define SHCNEE_USERINFOCHANGED     11L  // A user picture was updated. pidl1 = SHChangeDWORDAsIDList, pidl2=unused
#define SHCNEE_UPDATEFOLDERLOCATION  12L  // a special folder changed pidl1 = {SHChangeDWORDAsIDList, csidlFolder}, pidl2=unused
#endif
// Update types for the UpdateEntryList api
#define SHCNNU_SET        1   // Set the notify list to passed in list
#define SHCNNU_ADD        2   // Add the items to the current list
#define SHCNNU_REMOVE     3   // Remove the items from the current list
#define SHCNF_PRINTJOBA   0x0004        // dwItem1: printer name
                                        // dwItem2: SHCNF_PRINTJOB_DATA
#define SHCNF_PRINTJOBW   0x0007        // dwItem1: printer name
                                        // dwItem2: SHCNF_PRINTJOB_DATA
#define SHCNF_INSTRUMENT  0x0080        // dwItem1: LPSHCNF_INSTRUMENT
#define SHCNF_TRANSLATEDALIAS       0x4000 // for internals to filter on
#define SHCNF_ONLYNOTIFYINTERNALS   0x8000 // only notify internal clients
#ifdef UNICODE
#define SHCNF_PRINTJOB  SHCNF_PRINTJOBW
#else
#define SHCNF_PRINTJOB  SHCNF_PRINTJOBA
#endif

typedef struct tagSHCNF_PRINTJOB_DATA {
    DWORD JobId;
    DWORD Status;
    DWORD TotalPages;
    DWORD Size;
    DWORD PagesPrinted;
} SHCNF_PRINTJOB_DATA, *LPSHCNF_PRINTJOB_DATA;

//
// This is all the INSTRUMENTation stuff...
// make this look like an ITEMIDLIST (uOffset points to 0 uTerm)
#include <pshpack1.h>
typedef struct tagSHCNF_INSTRUMENT {
    USHORT uOffset;
    USHORT uAlign;
    DWORD dwEventType;
    DWORD dwEventStructure;
    SYSTEMTIME st;
    union tagEvents {
        struct tagSTRING {
            TCHAR sz[32];
        } string;
        struct tagHOTKEY {
            WPARAM wParam;
        } hotkey;
        struct tagWNDPROC {
            HWND hwnd;
            UINT uMsg;
            WPARAM wParam;
            LPARAM lParam;
        } wndproc;
        struct tagCOMMAND {
            HWND hwnd;
            UINT idCmd;
        } command;
        struct tagDROP {
            HWND hwnd;
            UINT idCmd;
//          TCHAR sz[32]; // convert pDataObject into something we can log
        } drop;
    } e;
    USHORT uTerm;
} SHCNF_INSTRUMENT_INFO, * LPSHCNF_INSTRUMENT_INFO;
#include <poppack.h>

#define SHCNFI_EVENT_STATECHANGE          0   // dwEventType
#define SHCNFI_EVENT_STRING               1   // e.string
#define SHCNFI_EVENT_HOTKEY               2   // e.hotkey
#define SHCNFI_EVENT_WNDPROC              3   // e.wndproc
#define SHCNFI_EVENT_WNDPROC_HOOK         4   // e.wndproc
#define SHCNFI_EVENT_ONCOMMAND            5   // e.command
#define SHCNFI_EVENT_INVOKECOMMAND        6   // e.command
#define SHCNFI_EVENT_TRACKPOPUPMENU       7   // e.command
#define SHCNFI_EVENT_DROP                 8   // e.drop
#define SHCNFI_EVENT_MAX                  9

#define SHCNFI_STRING_SHOWEXTVIEW         0

#define SHCNFI_STATE_KEYBOARDACTIVE         0   // _KEYBOARDACTIVE or _MOUSEACTIVE
#define SHCNFI_STATE_MOUSEACTIVE            1   // _KEYBOARDACTIVE or _MOUSEACTIVE
#define SHCNFI_STATE_ACCEL_TRAY             2   // _ACCEL_TRAY or _ACCEL_DESKTOP
#define SHCNFI_STATE_ACCEL_DESKTOP          3   // _ACCEL_TRAY or _ACCEL_DESKTOP
#define SHCNFI_STATE_START_DOWN             4   // _START_DOWN or _START_UP
#define SHCNFI_STATE_START_UP               5   // _START_DOWN or _START_UP
#define SHCNFI_STATE_TRAY_CONTEXT           6
#define SHCNFI_STATE_TRAY_CONTEXT_CLOCK     7
#define SHCNFI_STATE_TRAY_CONTEXT_START     8
#define SHCNFI_STATE_DEFVIEWX_ALT_DBLCLK    9
#define SHCNFI_STATE_DEFVIEWX_SHIFT_DBLCLK 10
#define SHCNFI_STATE_DEFVIEWX_DBLCLK       11

#define SHCNFI_GLOBALHOTKEY               0

#define SHCNFI_CABINET_WNDPROC            0
#define SHCNFI_DESKTOP_WNDPROC            1
#define SHCNFI_PROXYDESKTOP_WNDPROC       2
#define SHCNFI_TRAY_WNDPROC               3
#define SHCNFI_DRIVES_WNDPROC             4
#define SHCNFI_ONETREE_WNDPROC            5
#define SHCNFI_MAIN_WNDPROC               6
#define SHCNFI_FOLDEROPTIONS_DLGPROC      7
#define SHCNFI_VIEWOPTIONS_DLGPROC        8
#define SHCNFI_FT_DLGPROC                 9
#define SHCNFI_FTEdit_DLGPROC            10
#define SHCNFI_FTCmd_DLGPROC             11
#define SHCNFI_TASKMAN_DLGPROC           12
#define SHCNFI_TRAYVIEWOPTIONS_DLGPROC   13
#define SHCNFI_INITSTARTMENU_DLGPROC     14
#define SHCNFI_PRINTERQUEUE_DLGPROC      15

#define SHCNFI_CABINET_ONCOMMAND          0
#define SHCNFI_TRAYCOMMAND                1

#define SHCNFI_BITBUCKET_DFM_INVOKE       0
#define SHCNFI_BITBUCKET_FNV_INVOKE       1
#define SHCNFI_BITBUCKET_INVOKE           2
#define SHCNFI_BITBUCKETBG_DFM_INVOKE     3
#define SHCNFI_CONTROLS_DFM_INVOKE        4
#define SHCNFI_CONTROLS_FNV_INVOKE        5
#define SHCNFI_CONTROLSBG_DFM_INVOKE      6
#define SHCNFI_DEFFOLDER_DFM_INVOKE       7
#define SHCNFI_DEFFOLDER_INVOKE           8
#define SHCNFI_FINDEXT_INVOKE             9
#define SHCNFI_DEFFOLDER_FNV_INVOKE      10
#define SHCNFI_DRIVESBG_DFM_INVOKE       11
#define SHCNFI_DRIVES_FNV_INVOKE         12
#define SHCNFI_DRIVES_DFM_INVOKE         13
#define SHCNFI_FOLDERBG_DFM_INVOKE       14
#define SHCNFI_FOLDER_FNV_INVOKE         15
#define SHCNFI_FOLDER_DFM_INVOKE         16
#define SHCNFI_NETWORKBG_DFM_INVOKE      17
#define SHCNFI_NETWORK_FNV_INVOKE        18
#define SHCNFI_NETWORK_DFM_INVOKE        19
#define SHCNFI_NETWORKPRINTER_DFM_INVOKE 20
#define SHCNFI_DESKTOPBG_DFM_INVOKE      21
#define SHCNFI_DESKTOP_DFM_INVOKE        22
#define SHCNFI_DESKTOP_FNV_INVOKE        23
#define SHCNFI_PRINTERS_DFM_INVOKE       24
#define SHCNFI_PRINTERSBG_DFM_INVOKE     25
#define SHCNFI_PRINTERS_FNV_INVOKE       26
#define SHCNFI_DEFVIEWX_INVOKE           27

#define SHCNFI_FOLDER_DROP                0
#define SHCNFI_PRINTQUEUE_DROP            1
#define SHCNFI_DEFVIEWX_TPM               2
#define SHCNFI_DROP_EXE_TPM               3
#define SHCNFI_IDLDT_TPM                  4

#define SHCNFI_DROP_BITBUCKET             0
#define SHCNFI_DROP_PRINTFOLDER           1
#define SHCNFI_DROP_PRINTER               2
#define SHCNFI_DROP_RUN                   3
#define SHCNFI_DROP_SHELLLINK             4
#define SHCNFI_DROP_DRIVES                5
#define SHCNFI_DROP_FS                    6
#define SHCNFI_DROP_EXE                   7
#define SHCNFI_DROP_NETROOT               8
#define SHCNFI_DROP_PRINTQUEUE            9
#define SHCNFI_DROP_BRIEFCASE            10

#ifdef WANT_SHELL_INSTRUMENTATION
#define INSTRUMENT_STATECHANGE(t)                               \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_STATECHANGE;                \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_STRING(t,p)                                  \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_STRING;                     \
    lstrcpyn(s.e.string.sz,(p),ARRAYSIZE(s.e.string.sz));       \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_HOTKEY(t,w)                                  \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_HOTKEY;                     \
    s.e.hotkey.wParam=(w);                                      \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_WNDPROC(t,h,u,w,l)                           \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_WNDPROC;                    \
    s.e.wndproc.hwnd=(h);                                       \
    s.e.wndproc.uMsg=(u);                                       \
    s.e.wndproc.wParam=(w);                                     \
    s.e.wndproc.lParam=(l);                                     \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_WNDPROC_HOOK(h,u,w,l)                        \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=0;                                            \
    s.dwEventStructure=SHCNFI_EVENT_WNDPROC_HOOK;               \
    s.e.wndproc.hwnd=(h);                                       \
    s.e.wndproc.uMsg=(u);                                       \
    s.e.wndproc.wParam=(w);                                     \
    s.e.wndproc.lParam=(l);                                     \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_ONCOMMAND(t,h,u)                             \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_ONCOMMAND;                  \
    s.e.command.hwnd=(h);                                       \
    s.e.command.idCmd=(u);                                      \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_INVOKECOMMAND(t,h,u)                         \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_INVOKECOMMAND;              \
    s.e.command.hwnd=(h);                                       \
    s.e.command.idCmd=(u);                                      \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_TRACKPOPUPMENU(t,h,u)                        \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_TRACKPOPUPMENU;             \
    s.e.command.hwnd=(h);                                       \
    s.e.command.idCmd=(u);                                      \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#define INSTRUMENT_DROP(t,h,u,p)                                \
{                                                               \
    SHCNF_INSTRUMENT_INFO s;                                    \
    s.dwEventType=(t);                                          \
    s.dwEventStructure=SHCNFI_EVENT_DROP;                       \
    s.e.drop.hwnd=(h);                                          \
    s.e.drop.idCmd=(u);                                         \
    SHChangeNotify(SHCNE_INSTRUMENT,SHCNF_INSTRUMENT,&s,NULL);  \
}
#else
#define INSTRUMENT_STATECHANGE(t)
#define INSTRUMENT_STRING(t,p)
#define INSTRUMENT_HOTKEY(t,w)
#define INSTRUMENT_WNDPROC(t,h,u,w,l)
#define INSTRUMENT_WNDPROC_HOOK(h,u,w,l)
#define INSTRUMENT_ONCOMMAND(t,h,u)
#define INSTRUMENT_INVOKECOMMAND(t,h,u)
#define INSTRUMENT_TRACKPOPUPMENU(t,h,u)
#define INSTRUMENT_DROP(t,h,u,p)
#endif //WANT_SHELL_INSTRUMENTATION
//
//
// IQueryCodePage
//
#undef  INTERFACE
#define INTERFACE  IQueryCodePage

DECLARE_INTERFACE_(IQueryCodePage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IQueryCodePage methods ***
    STDMETHOD(GetCodePage)(THIS_ UINT * puiCodePage) PURE;
    STDMETHOD(SetCodePage)(THIS_ UINT uiCodePage) PURE;
} ;
SHSTDAPI_(void) SHWaitOp_Operate(HANDLE hWaitOp, DWORD dwProcId);

// DOC'ed for DOJ compliance:
#if (_WIN32_IE >= 0x0400)
// Use this instead of SHChangeDWORDAsIDList for SHCNEE_ORDERCHANGED
// SHCNEE_PROMOTEDITEM and SHCNEE_DEMOTEDITEM
//
// When filling in the pSender, cast LPVOID directly to INT64.
// Do not cast through DWORD_PTR because that will not sign extend
// properly on Win32.

typedef struct _SHChangeMenuAsIDList {
    USHORT  cb;
    DWORD   dwItem1;        // SHCNEE_EXTENDED_EVENT requires this
    // pSender must appear immediately after dwItem1 for IE5.0 compat
    INT64 pSender;          // address of sender (64-bit for Win64)
    DWORD   dwProcessID;    // pid of sender
    USHORT  cbZero;
} SHChangeMenuAsIDList, * LPSHChangeMenuAsIDList;

// DOC'ed for DOJ Compliance

typedef struct _SHShortcutInvokeAsIDList {
    USHORT  cb;
    DWORD   dwItem1;                    // SHCNEE_EXTENDED_EVENT requires this
    DWORD   dwPid;                      // PID of target application
    WCHAR   szShortcutName[MAX_PATH];   // Path to shortcut
    WCHAR   szTargetName[MAX_PATH];     // Path to target application
    USHORT  cbZero;
} SHShortcutInvokeAsIDList, *LPSHShortcutInvokeAsIDList;
#endif /* _WIN32_IE */
#define SHChangeNotifyHandleEvents() SHChangeNotify(0, SHCNF_FLUSH, NULL, NULL)
// DOC'ed for DOJ compliance
#define SHChangeNotifyRegisterORD 2
// DOC'ed for DOJ compliance
#define SHChangeNotifyDeregisterORD 4

SHSTDAPI_(BOOL) SHChangeNotifyUpdateEntryList(unsigned long ulID, int iUpdateType, int cEntries, SHChangeNotifyEntry *pshcne);

SHSTDAPI_(void)   SHChangeNotifyReceive(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
SHSTDAPI_(BOOL) SHChangeRegistrationReceive(HANDLE hChangeNotification, DWORD dwProcId);
SHSTDAPI_(void) SHChangeNotifyDeregisterWindow(HWND hwnd);
SHSTDAPI_(LRESULT) SHChangeNotifySuspendResumeReceive(WPARAM wParam, LPARAM lParam);
SHSTDAPI_(BOOL) SHChangeNotifySuspendResume(BOOL bSuspend, LPITEMIDLIST pidlSuspend, BOOL bRescursive, DWORD dwReserved);

typedef HANDLE LPSHChangeNotificationLock;

// DOC'ed for DOJ compliance

//  END Internal SHChangeNotify HELPERS

// DOC'ed for DOJ compliance
#ifndef NOOCHOST // {

//
// ====== OCHOST CONTROL ==========================================
//
// The following are all definations of structures, windows messages needed for OCHOST,
// the window control you can use to host an OC.
// To use OCHOST, you must specify the window class as OCHOST_CLASS or "OCHOST"
// -- To Create and initialize OCHOST:
// 1. CreateWindow with window title = the string version of class id or the OC
// 2. CreateWindow with a pointer to the OCHINITSTRUCT structure as the last parameter
//    you must allocate and initialize the OCHINITSTRUCT structure
// 3. CreateWindow with no title and the last param == NULL, then use the OCM_INITIALIZE message
//    or the OCHost_InitOC macro to initialize it.
// 4. Use OCM_QUERYINTERFACE to QI an interface pointer from the OC.
// 5. Simply destroy the window when you exit.

// SHDRC -- Shell Doc Register Classes

typedef struct _SHDRC {
    DWORD cbSize;   // size of this structure in bytes
    DWORD dwFlags;  // SHDRCF_ flags
} SHDRC;

#define SHDRCF_OCHOST   0x0001 // Register the OCHOST_CLASS window
#define SHDRCF_ALL      0x0001 //

SHDOCAPI_(BOOL)     DllRegisterWindowClasses(const SHDRC * pshdrc);
BROWSEUIAPI_(BOOL)  InitOCHostClass(const SHDRC *pshdrc);

#define OCHOST_CLASSA   "OCHost"
#define OCHOST_CLASSW   L"OCHost"

#ifdef UNICODE
#define OCHOST_CLASS    OCHOST_CLASSW
#else
#define OCHOST_CLASS    OCHOST_CLASSA
#endif

// ------------------- Window messages for OC Host --------------------

// IUnknown::QueryInterface the hosted OC
typedef struct _QIMSG {
    const IID * qiid;
    void **ppvObject;
} QIMSG, *LPQIMSG;

// ................. Query Interface Message ..........
#define OCM_QUERYINTERFACE      (WM_USER+0)

#ifdef __cplusplus
inline HRESULT OCHost_QueryInterface(HWND hwndOCH, REFIID riid, void **ppv) \
{ QIMSG qimsg = {&riid, ppv}; \
  return (HRESULT)SNDMSG((hwndOCH), OCM_QUERYINTERFACE, (WPARAM)sizeof(qimsg), (LPARAM)&qimsg); \
}
#else
#define OCHost_QueryInterface(hwndOCH, riid, ppv) \
{ QIMSG qimsg = {&riid, ppv}; \
  SNDMSG((hwndOCH), OCM_QUERYINTERFACE, (WPARAM)sizeof(qimsg), (LPARAM)&qimsg); \
}
#endif


// ------------------- OC Initialization Structure ---------------------
// This is intended to be passed in as the lParam of the OCM_INITOC message
typedef struct _OCHINITSTRUCT {
    UINT cbSize;                    // size of this structure
    CLSID clsidOC;                  // class ID of the OC
    IUnknown * punkOwner;           // owner of OCHOST
} OCHINITSTRUCT, *LPOCHINITSTRUCT;
//--------------------------------------------------------------------

// ................ Initialize and activate the OC ...............
#define OCM_INITIALIZE      (WM_USER+1)
#define OCM_INITOC          OCM_INITIALIZE
#define OCHost_InitOC(hwndOCH, lpOCS) \
  (HRESULT)SNDMSG((hwndOCH), OCM_INITOC, 0, (LPARAM)lpOCS)


// ............... give ochost a parent IUnknown .......
#define OCM_SETOWNER            (WM_USER+2)
#define OCHost_SetOwner(hwndOC, punk) \
  (HRESULT)SNDMSG((hwndOC), OCM_SETOWNER, 0, (LPARAM)(IUnknown*)(punk))

// ............... DoVerb the OC .......
// n.b. iVerb is technically a long, WPARAM might truncate it
#define OCM_DOVERB              (WM_USER+3)
#define OCHost_DoVerb(hwndOC, iVerb, lpMsg) \
  (HRESULT)SNDMSG((hwndOC), OCM_DOVERB, (WPARAM)iVerb, (LPARAM)lpMsg)

//.................Enable/Disable OC event notifications
#define OCM_ENABLEEVENTS       (WM_USER+4)
//  WPARAM: TRUE to enable event notifications, FALSE to disable.
//  returns: TRUE if successful, otherwise FALSE.
//  Event notification is in the form of a WM_NOTIFY with
//  code OCN_OCEVENT and an NMOCEVENT block.

#define OCHost_EnableEvents(hwndOC, bEnable) \
    (BOOL)SNDMSG((hwndOC), OCM_ENABLEEVENTS, (WPARAM)bEnable, 0L)


#define OCM_SETSERVICEPROVIDER (WM_USER+5)
//  LPARAM: IServiceProvider* pSP.
//  This message sets a service provider for SID_OleClientSite delegation.
//  Currently, OCHost will just call this guy with (SID_OleClientSite, IDispatch)
//  and the client-implemented service provider can return an IDispatch to
//  handle ambient properties.
#define OCHost_SetServiceProvider(hwndOC, pSP) \
    (BOOL)SNDMSG((hwndOC), OCM_SETSERVICEPROVIDER, 0L, (LPARAM) pSP)

// ------------------ Window Notify messages from OC Host --------------

#define OCN_FIRST               0x1300
#define OCN_COCREATEINSTANCE    (OCN_FIRST + 1)

typedef struct _OCNCOCREATEMSG {
    NMHDR nmhdr;
    CLSID clsidOC;
    IUnknown ** ppunk;
} OCNCOCREATEMSG, *LPOCNCOCREATEMSG;

// NOTE: return values are defined as the following
// If the handler of OCN_COCREATEINSTANCE Notify message returns OCNCOCREATE_ALREADYCREATED,
// on return the (*ppvObj) is assumed to have the value of the OC's IUnkown pointer
#define OCNCOCREATE_CONTINUE       0
#define OCNCOCREATE_HANDLED       -1


#define OCN_PERSISTINIT         (OCN_FIRST + 2)
// NOTE: return values are defined as the following
// If the handler of OCN_PERSISTINIT Notify message returns OCNPERSIST_ABORT,
// the OCHOST will abort IPersist's initialization.
#define OCNPERSISTINIT_CONTINUE    0
#define OCNPERSISTINIT_HANDLED    -1

// The return value on the following notify messages are ignored.
#define OCN_ACTIVATE            (OCN_FIRST + 3)
#define OCN_DEACTIVATE          (OCN_FIRST + 4)
#define OCN_EXIT                (OCN_FIRST + 5)
#define OCN_ONPOSRECTCHANGE     (OCN_FIRST + 6)

typedef struct _OCNONPOSRECTCHANGEMSG {
    NMHDR nmhdr;
    LPCRECT prcPosRect;
} OCNONPOSRECTCHANGEMSG, *LPOCNONPOSRECTCHANGEMSG;

#define OCN_ONUIACTIVATE        (OCN_FIRST + 7)
typedef struct _OCNONUIACTIVATEMSG {
    NMHDR nmhdr;
    IUnknown *punk;
} OCNONUIACTIVATEMSG, *LPOCNONUIACTIVATEMSG;

#define OCNONUIACTIVATE_HANDLED       -1

#define OCN_ONSETSTATUSTEXT     (OCN_FIRST + 8)
typedef struct _OCNONSETSTATUSTEXT {
    NMHDR nmhdr;
    LPCOLESTR pwszStatusText;
} OCNONSETSTATUSTEXTMSG, *LPOCNONSETSTATUSTEXTMSG;


#define OCN_OCEVENT    (OCN_FIRST + 9)
//  OC event notification block.
//  Recipient should return nonzero if any outbound parameters were modified
//  and should be returned to the ActiveX control object; otherwse zero.
//  NOTE: Structure is not properly aligned. Already shipped so too late to fix
typedef struct tagNMOCEVENT
{
    IN NMHDR           hdr ;
    IN DISPID          dispID ;
    IN IID             iid ;
    IN LCID            lcid ;
    IN WORD            wFlags ;
    IN OUT DISPPARAMS  *pDispParams ;
    OUT VARIANT        *pVarResult ;
    OUT EXCEPINFO      *pExepInfo ;
    OUT UINT           *puArgErr ;
} NMOCEVENT, *PNMOCEVENT, *LPNMOCEVENT ;

#endif // NOOCHOST // }

//
// Access to shdocvw's active session count
//
enum SessionOp {
    SESSION_QUERY = 0,
    SESSION_INCREMENT,
    SESSION_DECREMENT,
        SESSION_INCREMENT_NODEFAULTBROWSERCHECK
};

long SetQueryNetSessionCount(enum SessionOp Op);
SHDOCAPI_(void) IEWriteErrorLog(const EXCEPTION_RECORD* pexr);

//
// Internal APIs Follow.  NOT FOR PUBLIC CONSUMPTION.
//

// Errors shared in the shell

#define E_FILE_NOT_FOUND        MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_FILE_NOT_FOUND)
#define E_PATH_NOT_FOUND        MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN32, ERROR_PATH_NOT_FOUND)


// Useful macros

#define ResultFromShort(i)      MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(i))
#define ShortFromResult(r)      (short)HRESULT_CODE(r)


#if (defined(UNICODE) && !defined(_X86_)) // all non-x86 systems require alignment
#ifndef ALIGNMENT_SCENARIO
#define ALIGNMENT_SCENARIO
#endif
#endif

#ifndef LPNTSTR_DEFINED
#define LPNTSTR_DEFINED
typedef UNALIGNED const WCHAR * LPNCWSTR;
typedef UNALIGNED WCHAR *       LPNWSTR;
#ifdef UNICODE
#define LPNCTSTR        LPNCWSTR
#define LPNTSTR         LPNWSTR
#else
#define LPNCTSTR        LPCSTR
#define LPNTSTR         LPSTR
#endif
#endif // LPNTSTR_DEFINED

#define RFN_FIRST       (0U-510U) // run file dialog notify
#define RFN_LAST        (0U-519U)


//=======================================================================
// String constants for
//  1. Registration database keywords       (prefix STRREG_)
//  2. Exported functions from handler dlls (prefix STREXP_)
//  3. .INI file keywords                   (prefix STRINI_)
//  4. Others                               (prefix STR_)
//=======================================================================
#define STRREG_SHELLUI          TEXT("ShellUIHandler")
#define STRREG_SHELL            TEXT("Shell")
#define STRREG_DEFICON          TEXT("DefaultIcon")
#define STRREG_SHEX             TEXT("shellex")
#define STRREG_SHEX_PROPSHEET   STRREG_SHEX TEXT("\\PropertySheetHandlers")
#define STRREG_SHEX_DDHANDLER   STRREG_SHEX TEXT("\\DragDropHandlers")
#define STRREG_SHEX_MENUHANDLER STRREG_SHEX TEXT("\\ContextMenuHandlers")
#define STRREG_SHEX_COPYHOOK    TEXT("Directory\\") STRREG_SHEX TEXT("\\CopyHookHandlers")
#define STRREG_SHEX_PRNCOPYHOOK TEXT("Printers\\") STRREG_SHEX TEXT("\\CopyHookHandlers")
#define STRREG_STARTMENU TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MenuOrder\\Start Menu")
#define STRREG_STARTMENU2 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MenuOrder\\Start Menu2")
#define STRREG_FAVORITES TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MenuOrder\\Favorites")
#define STRREG_DISCARDABLE      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Discardable")
#define STRREG_POSTSETUP        TEXT("\\PostSetup")

#define STREXP_CANUNLOAD        "DllCanUnloadNow"       // From OLE 2.0

#define STRINI_CLASSINFO        TEXT(".ShellClassInfo")       // secton name
#define STRINI_SHELLUI          TEXT("ShellUIHandler")
#define STRINI_OPENDIRICON      TEXT("OpenDirIcon")
#define STRINI_DIRICON          TEXT("DirIcon")

#define STR_DESKTOPINI          TEXT("desktop.ini")
#define STR_DESKTOPINIA         "desktop.ini"

#define DRIVEID(path)   ((*path - 'A') & 31)

#define PATH_CCH_EXT    64

// DOC'ed for DOJ Compliance

#ifndef NOUSER

typedef struct {
    NMHDR  hdr;
    CHAR   szCmd[MAX_PATH*2];
    DWORD  dwHotKey;
    HMONITOR hMonitor;
} NMVIEWFOLDERA, *LPNMVIEWFOLDERA;
typedef struct {
    NMHDR  hdr;
    WCHAR  szCmd[MAX_PATH*2];
    DWORD  dwHotKey;
    HMONITOR hMonitor;
} NMVIEWFOLDERW, *LPNMVIEWFOLDERW;
#ifdef UNICODE
typedef NMVIEWFOLDERW NMVIEWFOLDER;
typedef LPNMVIEWFOLDERW LPNMVIEWFOLDER;
#else
typedef NMVIEWFOLDERA NMVIEWFOLDER;
typedef LPNMVIEWFOLDERA LPNMVIEWFOLDER;
#endif // UNICODE

#endif

//
//  DDE related APIs
//
SHSTDDOCAPI_(void) ShellDDEInit(BOOL fInit);
SHSTDDOCAPI_(BOOL) DDEHandleViewFolderNotify(IShellBrowser* psb, HWND hwnd, LPNMVIEWFOLDER lpnm);
SHSTDDOCAPI_(LPNMVIEWFOLDER) DDECreatePostNotify(LPNMVIEWFOLDER lpnm);

// DOC'ed for DOJ compliance

SHSTDAPI CIDLData_CreateFromIDArray(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], IDataObject **ppdtobj);
SHSTDAPI SHCreateFileDataObject(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl, IDataObject *pdtInner, IDataObject **pdtobj);


// Common strings
#define STR_DESKTOPCLASS        "Progman"

//
// Storage name of a scrap/bookmark item
//
#define WSTR_SCRAPITEM L"\003ITEM000"

// DOC'ed for DOJ Compliance

#ifdef RFN_FIRST
#define RFN_EXECUTE             (RFN_FIRST - 0)
typedef struct {
    NMHDR hdr;
    LPCSTR   lpszCmd;
    LPCSTR   lpszWorkingDir;
    int nShowCmd;
} NMRUNFILEA, *LPNMRUNFILEA;
typedef struct {
    NMHDR hdr;
    LPCWSTR  lpszCmd;
    LPCWSTR  lpszWorkingDir;
    int nShowCmd;
} NMRUNFILEW, *LPNMRUNFILEW;
#ifdef UNICODE
typedef NMRUNFILEW NMRUNFILE;
typedef LPNMRUNFILEW LPNMRUNFILE;
#else
typedef NMRUNFILEA NMRUNFILE;
typedef LPNMRUNFILEA LPNMRUNFILE;
#endif // UNICODE

#endif

// DOC'ed for DOJ compliance

// Shell create link API
#define SHCL_USETEMPLATE        0x0001
#define SHCL_USEDESKTOP         0x0002
#define SHCL_CONFIRM            0x0004
#define SHCL_MAKEFOLDERSHORTCUT 0x0008
#if (_WIN32_IE >= 0x0600)
#define SHCL_NOUNIQUE           0x0010
#endif // _WIN2_IE >= 0x0600

SHSTDAPI SHCreateLinks(HWND hwnd, LPCTSTR pszDir, IDataObject *pDataObj, UINT fFlags, LPITEMIDLIST* ppidl);

SHSTDAPI SHRegisterDragDrop(HWND hwnd, IDropTarget *pdtgt);
SHSTDAPI SHRevokeDragDrop(HWND hwnd);

// DOC'ed for DOJ compliance

//===========================================================================
// office 9 pluggable UI
//===========================================================================

#define PUI_OFFICE_COMMAND     (WM_USER + 0x901)
#define PLUGUI_CMD_SHUTDOWN    0 // wParam value
#define PLUGUI_CMD_QUERY       1 // wParam value
#define OFFICE_VERSION_9       9 // standardized value to return for Office 9 apps

typedef struct _PLUGUI_INFO
{
    unsigned uMajorVersion : 8; // Used to indicate App's major version number
    unsigned uOleServer : 1;    // BOOL, TRUE if this is an OLE process
    unsigned uUnused : 23;      // not used
} PLUGUI_INFO;

typedef union _PLUGUI_QUERY
{
    UINT uQueryVal;
    PLUGUI_INFO PlugUIInfo;
} PLUGUI_QUERY;

//===========================================================================
// Image dragging API (definitely private)
//===========================================================================

// DOC'ed for DOJ Compliance

//Contains the drag context header.
// Must be pack1 since it's persisted into a stream that travels between
// processes.
typedef struct {
    BOOL  fImage;
    BOOL  fLayered;
    POINT ptOffset;
} DragContextHeader;

#define DAD_InitScrollData(pad) (pad)->bFull = FALSE, (pad)->iNextSample = 0, (pad)->dwLastScroll = 0

// DOC'ed for DOJ Compliance
SHSTDAPI_(BOOL) DAD_DragEnter(HWND hwndTarget);

// DOC'ed for DOJ Compliance
SHSTDAPI_(BOOL) DAD_SetDragImageFromListView(HWND hwndLV, POINT ptOffset);
SHSTDAPI_(void) DAD_InvalidateCursors(void);

//----------------------------------------------------------------------------
// CABINETSTATE holds the global configuration for the Explorer and its cohorts.
//
// Originally the cLength was an 'int', it is now two words, allowing us to
// specify a version number.
//----------------------------------------------------------------------------

// DOC'ed for DOJ Compliance

// RUN FILE RETURN values from notify message
#define RFR_NOTHANDLED 0
#define RFR_SUCCESS 1
#define RFR_FAILURE 2

#define PathGetExtensionORD     158

SHSTDAPI_(LPTSTR) PathGetExtension(LPCTSTR pszPath, LPTSTR pszExtension, int cchExt);

// DOC'ed for DOJ Compliance
SHSTDAPI_(BOOL) PathGetShortName(LPCTSTR pszLongName, LPTSTR pszShortName, UINT cbShortName);
SHSTDAPI_(BOOL) PathGetLongName(LPCTSTR pszShortName, LPTSTR pszLongName, UINT cbLongName);
SHSTDAPI_(BOOL) PathDirectoryExists(LPCTSTR pszDir);
// DOC'ed for DOJ Compliance
SHSTDAPI_(LPTSTR) PathGetNextComponent(LPCTSTR pszPath, LPTSTR pszComponent);

// DOC'ed for DOJ Compliance

SHSTDAPI_(BOOL) PathIsEqualOrSubFolder(LPCTSTR pszFolder, LPCTSTR pszSubFolder);

// DOC'ed for DOJ Compliance

SHSTDAPI_(BOOL) PathIsTemporaryA(LPCSTR pszPath);
SHSTDAPI_(BOOL) PathIsTemporaryW(LPCWSTR pszPath);
#ifdef UNICODE
#define PathIsTemporary  PathIsTemporaryW
#else
#define PathIsTemporary  PathIsTemporaryA
#endif // !UNICODE

// DOC'ed for DOJ Compliance

SHSTDAPI_(int) PathCleanupSpecEx(LPCTSTR pszDir, LPTSTR pszSpec);

// DOC'ed for DOJ Compliance

SHSTDAPI_(BOOL) ParseField(LPCTSTR szData, int n, LPTSTR szBuf, int iBufLen);

// Needed for RunFileDlg
#define RFD_NOBROWSE            0x00000001
#define RFD_NODEFFILE           0x00000002
#define RFD_USEFULLPATHDIR      0x00000004
#define RFD_NOSHOWOPEN          0x00000008
#define RFD_WOW_APP             0x00000010
#define RFD_NOSEPMEMORY_BOX     0x00000020


SHSTDAPI_(int) RunFileDlg(HWND hwnd, HICON hIcon, LPCTSTR pszWorkingDir, LPCTSTR pszTitle,
                          LPCTSTR pszPrompt, DWORD dwFlags);


// DOC'ed for DOJ Compliance
SHSTDAPI_(int) RealDriveTypeFlags(int iDrive, BOOL fOKToHitNet);

// DOC'ed for DOJ compliance

SHSTDAPI_(void) InvalidateDriveType(int iDrive);

// DOC'ed for DOJ Compliance

//
// Constants used for dwNumFmtFlags argument in Int64ToString and LargeIntegerToString.
//
#define NUMFMT_IDIGITS    0x00000001
#define NUMFMT_ILZERO     0x00000002
#define NUMFMT_SGROUPING  0x00000004
#define NUMFMT_SDECIMAL   0x00000008
#define NUMFMT_STHOUSAND  0x00000010
#define NUMFMT_INEGNUMBER 0x00000020
#define NUMFMT_ALL        0xFFFFFFFF

SHSTDAPI_(int) LargeIntegerToString(LARGE_INTEGER *pN, LPTSTR szOutStr, UINT nSize, BOOL bFormat, NUMBERFMT *pFmt, DWORD dwNumFmtFlags);
SHSTDAPI_(int) Int64ToString(_int64 n, LPTSTR szOutStr, UINT nSize, BOOL bFormat, NUMBERFMT *pFmt, DWORD dwNumFmtFlags);

//-------- drive type identification --------------
// iDrive      drive index (0=A, 1=B, ...)
//
#define DRIVE_CDROM     5           // extended DriveType() types
#define DRIVE_RAMDRIVE  6
#define DRIVE_TYPE      0x000F      // type masek
#define DRIVE_SLOW      0x0010      // drive is on a slow link
#define DRIVE_LFN       0x0020      // drive supports LFNs
#define DRIVE_AUTORUN   0x0040      // drive has AutoRun.inf in root.
#define DRIVE_AUDIOCD   0x0080      // drive is a AudioCD
#define DRIVE_AUTOOPEN  0x0100      // should *always* auto open on insert
#define DRIVE_NETUNAVAIL 0x0200     // Network drive that is not available
#define DRIVE_SHELLOPEN  0x0400     // should auto open on insert, if shell has focus
#define DRIVE_SECURITY   0x0800     // Supports ACLs
#define DRIVE_COMPRESSED 0x1000     // Root of volume is compressed
#define DRIVE_ISCOMPRESSIBLE 0x2000 // Drive supports compression (not nescesarrily compressed)
#define DRIVE_DVD       0x4000      // drive is a DVD

#define DriveTypeFlags(iDrive)      DriveType('A' + (iDrive))
#define DriveIsSlow(iDrive)         (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_SLOW)
#define DriveIsLFN(iDrive)          (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_LFN)
#define DriveIsAutoRun(iDrive)      (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_AUTORUN)
#define DriveIsAutoOpen(iDrive)     (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_AUTOOPEN)
#define DriveIsShellOpen(iDrive)    (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_SHELLOPEN)
#define DriveIsAudioCD(iDrive)      (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_AUDIOCD)
#define DriveIsNetUnAvail(iDrive)   (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_NETUNAVAIL)
#define DriveIsSecure(iDrive)       (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_SECURITY)
#define DriveIsCompressed(iDrive)   (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_COMPRESSED)
#define DriveIsCompressible(iDrive) (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_ISCOMPRESSIBLE)
#define DriveIsDVD(iDrive)          (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_DVD)

#define IsCDRomDrive(iDrive)        (RealDriveType(iDrive, FALSE) == DRIVE_CDROM)
#define IsRamDrive(iDrive)          (RealDriveType(iDrive, FALSE) == DRIVE_RAMDRIVE)
#define IsRemovableDrive(iDrive)    (RealDriveType(iDrive, FALSE) == DRIVE_REMOVABLE)
#define IsRemoteDrive(iDrive)       (RealDriveType(iDrive, FALSE) == DRIVE_REMOTE)


//
// For SHCreateDefClassObject
//
typedef HRESULT (CALLBACK *LPFNCREATEINSTANCE)(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);

SHSTDAPI SHCreateDefClassObject(REFIID riid, void **ppv, LPFNCREATEINSTANCE lpfn, UINT *pcRefDll, REFIID riidInstance);

// DOC'ed for DOJ compliance
typedef HANDLE HNRES;           // for SHGetNetResource
SHSTDAPI_(UINT) SHGetNetResource(HNRES hnres, UINT iItem, LPNETRESOURCE pnres, UINT cbMax);
#define SHOP_TYPEMASK    0x00000007	
#define SHOP_MODAL       0x80000000	

SHSTDAPI_(DWORD) SHChkDskDrive(HWND hwnd, UINT drive);

// DOC'ed for DOJ compliance
//====== SEMI-PRIVATE API ===============================
// DOC'ed for DOJ compliance
WINSHELLAPI HPSXA SHCreatePropSheetExtArrayEx( HKEY hKey, LPCTSTR pszSubKey, UINT max_iface, IDataObject * pdo );

//====== SEMI-PRIVATE API ORDINALS ===============================
// This is the list of semi-private ordinals we semi-publish.
#define SHGetNetResourceORD                      69
#define SHObjectPropertiesORD                   178
#define SHAddFromPropSheetExtArrayORD           167
#define SHCreatePropSheetExtArrayORD            168
#define SHDestroyPropSheetExtArrayORD           169
#define SHReplaceFromPropSheetExtArrayORD       170
#define SHCreateDefClassObjectORD                70

#define SHEXP_SHGETNETRESOURCE                  MAKEINTRESOURCE(SHGetNetResourceORD)

#define SHEXP_SHADDFROMPROPSHEETEXTARRAY        MAKEINTRESOURCE(SHAddFromPropSheetExtArrayORD)
#define SHEXP_SHCREATEPROPSHEETEXTARRAY         MAKEINTRESOURCE(SHCreatePropSheetExtArrayORD)
#define SHEXP_SHDESTROYPROPSHEETEXTARRAY        MAKEINTRESOURCE(SHDestroyPropSheetExtArrayORD)
#define SHEXP_SHREPLACEFROMPROPSHEETEXTARRAY    MAKEINTRESOURCE(SHReplaceFromPropSheetExtArrayORD)
#define SHEXP_SHCREATEDEFCLASSOBJECT            MAKEINTRESOURCE(SHCreateDefClassObjectORD)


// This avoids duplicate definition problems in the net\config project
// which defines *some* of its own PIDL utility functions, but depends on
// us for others (ILClone())

// DOC'ed for DOJ Compliance

#ifndef AVOID_NET_CONFIG_DUPLICATES
//===========================================================================
// ITEMIDLIST
//===========================================================================

// flags for ILGetDisplayNameEx
#define ILGDN_FULLNAME  0
#define ILGDN_ITEMONLY  1
#define ILGDN_INFOLDER  2

// DOC'ed for DOJ Compliance

#define ILIsEmpty(pidl)     ((pidl) == NULL || (pidl)->mkid.cb==0)

SHSTDAPI_(LPITEMIDLIST) ILCreate(void);

// DOC'ed for DOJ Compliance

SHSTDAPI_(void)         ILGlobalFree(LPITEMIDLIST pidl);
SHSTDAPI_(BOOL)         ILGetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszName);
SHSTDAPI_(BOOL)         ILGetDisplayNameEx(IShellFolder *psfRoot, LPCITEMIDLIST pidl, LPTSTR pszName, int fType);

// DOC'ed for DOJ Compliance

SHSTDAPI_(LPITEMIDLIST) ILGlobalClone(LPCITEMIDLIST pidl);

// DOC'ed for DOJ Compliance

SHSTDAPI                ILLoadFromFile(HFILE hfile, LPITEMIDLIST *pidl);
SHSTDAPI                ILSaveToFile(HFILE hfile, LPCITEMIDLIST pidl);

// DOC'ed for DOJ Compliance

// helper macros
#define ILCreateFromID(pmkid)   ILAppendID(NULL, pmkid, TRUE)

#endif // AVOID_NET_CONFIG_DUPLICATES

// WARNING: this interface is not supported on the current platform, just downlevel


#undef  INTERFACE
#define INTERFACE   IWebViewOCWinMan
DECLARE_INTERFACE_(IWebViewOCWinMan, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWebViewOCWinMan methods ***
    STDMETHOD(SwapWindow) (THIS_ HWND hwndLV, IWebViewOCWinMan **pocWinMan) PURE;
};

// DOC'ed for DOJ compliance
    // Classic Win95 policy bits.  Do NOT add any more bits in
    // this range.  See the ranges below to add new policies.
    //          |                        |
    //          v                        v
    // Values starting at 4000001 are treated as raw INTs.  New
    // *shell-specific* policies (NOT browser policies) should
    // be added in this range.  Use SHRestricted() with these bits.
    //          |                        |
    //          v                        v
  //--- UNUSED -- USE THIS SPACE ---  0x4000006C to 0x4000006E

// Browser restrictions (parameter for SHRestricted2)
//
// The browser restrictions are divided into two ranges, "explorer restrictions" and
// "infodelivery restrictions".  Explorer restrictions are kept under "Software\\Microsoft\\
// Windows\\CurrentVersion\\Policies\\Explorer," while infodelivery restrictions are kept
// under "Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Restrictions."
//
// **NOTE**: SHRestricted2 assumes each range is continuous.
typedef enum {
    // explorer restrictions
    REST_BROWSER_NONE               = 0x00000000,   // REST_EXPLORER_FIRST
    REST_NOTOOLBARCUSTOMIZE         = 0x00000001,
    REST_NOBANDCUSTOMIZE            = 0x00000002,
    REST_SMALLICONS                 = 0x00000003,
    REST_LOCKICONSIZE               = 0x00000004,
    REST_SPECIFYDEFAULTBUTTONS      = 0x00000005,
    REST_BTN_BACK                   = 0x00000006,
    REST_BTN_FORWARD                = 0x00000007,
    REST_BTN_STOPDOWNLOAD           = 0x00000008,
    REST_BTN_REFRESH                = 0x00000009,
    REST_BTN_HOME                   = 0x0000000A,
    REST_BTN_SEARCH                 = 0x0000000B,
    REST_BTN_HISTORY                = 0x0000000C,
    REST_BTN_FAVORITES              = 0x0000000D,
    REST_BTN_ALLFOLDERS             = 0x0000000E,
    REST_BTN_THEATER                = 0x0000000F,
    REST_BTN_TOOLS                  = 0x00000010,
    REST_BTN_MAIL                   = 0x00000011,
    REST_BTN_FONTS                  = 0x00000012,
    REST_BTN_PRINT                  = 0x00000013,
    REST_BTN_EDIT                   = 0x00000014,
    REST_BTN_DISCUSSIONS            = 0x00000015,
    REST_BTN_CUT                    = 0x00000016,
    REST_BTN_COPY                   = 0x00000017,
    REST_BTN_PASTE                  = 0x00000018,
    REST_BTN_ENCODING               = 0x00000019,
    REST_NoUserAssist               = 0x0000001A,
    REST_NoWindowsUpdate            = 0x0000001B,
    REST_NoExpandedNewMenu          = 0x0000001C,
    REST_NOFILEURL                  = 0x0000001D,
    REST_BTN_PRINTPREVIEW           = 0X0000001E,   
    REST_BTN_MEDIABAR               = 0x0000001F,   // REST_EXPLORER_LAST

    // infodelivery restrictions
    REST_NoChannelUI                = 0x50000001,   // REST_INFO_FIRST
    REST_NoAddingChannels           = 0x50000002,
    REST_NoEditingChannels          = 0x50000003,
    REST_NoRemovingChannels         = 0x50000004,
    REST_NoAddingSubscriptions      = 0x50000005,
    REST_NoEditingSubscriptions     = 0x50000006,
    REST_NoRemovingSubscriptions    = 0x50000007,
    REST_NoChannelLogging           = 0x50000008,
    REST_NoManualUpdates            = 0x50000009,
    REST_NoScheduledUpdates         = 0x5000000A,
    REST_NoUnattendedDialing        = 0x5000000B,
    REST_NoChannelContent           = 0x5000000C,
    REST_NoSubscriptionContent      = 0x5000000D,
    REST_NoEditingScheduleGroups    = 0x5000000E,
    REST_MaxChannelSize             = 0x5000000F,
    REST_MaxSubscriptionSize        = 0x50000010,
    REST_MaxChannelCount            = 0x50000011,
    REST_MaxSubscriptionCount       = 0x50000012,
    REST_MinUpdateInterval          = 0x50000013,
    REST_UpdateExcludeBegin         = 0x50000014,
    REST_UpdateExcludeEnd           = 0x50000015,
    REST_UpdateInNewProcess         = 0x50000016,
    REST_MaxWebcrawlLevels          = 0x50000017,
    REST_MaxChannelLevels           = 0x50000018,
    REST_NoSubscriptionPasswords    = 0x50000019,
    REST_NoBrowserSaveWebComplete   = 0x5000001A,
    REST_NoSearchCustomization      = 0x5000001B,
    REST_NoSplash                   = 0x5000001C,  // REST_INFO_LAST

    // restrictions ported from SP2
    REST_NoFileOpen                 = 0x60000001,  // REST_BROWSER_FIRST
    REST_NoFileNew                  = 0x60000002,
    REST_NoBrowserSaveAs            = 0x60000003,
    REST_NoBrowserOptions           = 0x60000004,
    REST_NoFavorites                = 0x60000005,
    REST_NoSelectDownloadDir        = 0x60000006,
    REST_NoBrowserContextMenu       = 0x60000007,
    REST_NoBrowserClose             = 0x60000008,
    REST_NoOpeninNewWnd             = 0x60000009,
    REST_NoTheaterMode              = 0x6000000A,
    REST_NoFindFiles                = 0x6000000B,
    REST_NoViewSource               = 0x6000000C,
    REST_GoMenu                     = 0x6000000D,
    REST_NoToolbarOptions           = 0x6000000E,

    REST_NoHelpItem_TipOfTheDay     = 0x6000000F,
    REST_NoHelpItem_NetscapeHelp    = 0x60000010,
    REST_NoHelpItem_Tutorial        = 0x60000011,
    REST_NoHelpItem_SendFeedback    = 0x60000012,
    REST_AlwaysPromptWhenDownload   = 0x60000013,

    REST_NoNavButtons               = 0x60000014,
    REST_NoHelpMenu                 = 0x60000015,
    REST_NoBrowserBars              = 0x60000016,
    REST_NoToolBar                  = 0x60000017,
    REST_NoAddressBar               = 0x60000018,
    REST_NoLinksBar                 = 0x60000019,
    REST_NoPrinting                 = 0x60000020,

    REST_No_LaunchMediaBar          = 0x60000021,
    REST_No_MediaBarOnlineContent   = 0x60000022,   // REST_BROWSER_LAST   

} BROWSER_RESTRICTIONS;

#define REST_EXPLORER_FIRST     REST_BROWSER_NONE
#define REST_EXPLORER_LAST      REST_BTN_MEDIABAR

#define REST_INFO_FIRST         REST_NoChannelUI
#define REST_INFO_LAST          REST_NoSplash

#define REST_BROWSER_FIRST      REST_NoFileOpen
#define REST_BROWSER_LAST       REST_No_MediaBarOnlineContent

// codes for REST_BTN policies
#define RESTOPT_BTN_STATE_DEFAULT       0   // must be zero, else break browseui\itbar.cpp assumption
#define RESTOPT_BTN_STATE_VISIBLE       1
#define RESTOPT_BTN_STATE_HIDDEN        2

// REST_INTELLIMENUS
#define RESTOPT_INTELLIMENUS_USER       0
#define RESTOPT_INTELLIMENUS_DISABLED   1       // Match Restriction assumption: 1 == Off
#define RESTOPT_INTELLIMENUS_ENABLED    2


// FTP Exports
STDAPI IsIEDefautlFTPClient(void);
STDAPI MakeIEDefautlFTPClient(void);
STDAPI RestoreFTPClient(void);

SHSTDAPI_(void) SHSettingsChanged(WPARAM wParam, LPARAM lParam);
SHSTDAPI_(BOOL) SHIsBadInterfacePtr(LPCVOID pv, UINT cbVtbl);
// DOC'ed for DOJ Compliance
SHSTDAPI_(void) SHHandleDiskFull(HWND hwnd, int idDrive);

// DOC'ed for DOJ compliance
SHSTDAPI_(BOOL) SHFindComputer(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile);

// DOC'ed for DOJ Compliance

SHSTDAPI_(BOOL) Win32CreateDirectory(LPCTSTR pszPath, SECURITY_ATTRIBUTES *psa);
SHSTDAPI_(BOOL) Win32RemoveDirectory(LPCTSTR pszPath);

// DOC'ed for DOJ Compliance

SHSTDAPI_(void) SHUpdateRecycleBinIcon();

// DOC'ed for DOJ Compliance

SHSTDAPI_(LPITEMIDLIST) SHLogILFromFSIL(LPCITEMIDLIST pidlFS);
SHSTDAPI_(BOOL) StrRetToStrN(LPTSTR szOut, UINT uszOut, STRRET *pStrRet, LPCITEMIDLIST pidl);
SHSTDAPI_(DWORD) SHWaitForFileToOpen(LPCITEMIDLIST pidl, UINT uOptions, DWORD dwtimeout);
SHSTDAPI_(void) SetAppStartingCursor(HWND hwnd, BOOL fSet);
// DOC'ed for DOJ compliance
SHSTDAPI_(void *) SHGetHandlerEntry(LPCTSTR szHandler, LPCSTR szProcName, HINSTANCE *lpModule);

// This is sent to a browser windows letting them know that we have
// opened a folder, i.e. the folder open operation is done.
// Call RegisterWindowMessage to get the ID
#define SH_FILEOPENED     TEXT("ShellFileOpened")

// DOC'ed for DOJ compliance

SHSTDAPI SHCreatePropertyBag(REFIID riid, void **ppv);

SHSTDAPI_(DWORD) SHNetConnectionDialog(HWND hwnd, LPTSTR pszRemoteName, DWORD dwType);

// DOC'ed for DOJ Compliance
SHSTDAPI_(int) SHLookupIconIndexA(LPCSTR pszFile, int iIconIndex, UINT uFlags);
// DOC'ed for DOJ Compliance
SHSTDAPI_(int) SHLookupIconIndexW(LPCWSTR pszFile, int iIconIndex, UINT uFlags);
#ifdef UNICODE
#define SHLookupIconIndex  SHLookupIconIndexW
#else
#define SHLookupIconIndex  SHLookupIconIndexA
#endif // !UNICODE
SHSTDAPI_(UINT) SHExtractIconsA(LPCSTR pszFileName, int nIconIndex, int cxIcon, int cyIcon,
                                HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);
SHSTDAPI_(UINT) SHExtractIconsW(LPCWSTR pszFileName, int nIconIndex, int cxIcon, int cyIcon,
                                HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);
#ifdef UNICODE
#define SHExtractIcons  SHExtractIconsW
#else
#define SHExtractIcons  SHExtractIconsA
#endif // !UNICODE
SHSTDAPI SHGetAssociations(LPCITEMIDLIST pidl, void **ppvQueryAssociations);

#define SHLookupIconIndexAORD   7
#define SHLookupIconIndexWORD   8
#ifdef UNICODE
#define SHLookupIconIndexORD    SHLookupIconIndexWORD
#else
#define SHDefExtractIcon    SHDefExtractIconA
#endif


// BUGBUG (scotth): temporary.  move to shdocvw.
// OpenAsInfo flags
#define OAIF_ALLOW_REGISTRATION     0x00000001      // enable the "always use this file" checkbox (NOTE if you dont pass this, it will be disabled)
#define OAIF_REGISTER_EXT           0x00000002      // do the registration after the user hits "ok"
#define OAIF_EXEC                   0x00000004      // execute file after registering
#define OAIF_FORCE_REGISTRATION     0x00000008      // force the "always use this file" checkbox to be checked (normally, you wont use the OAIF_ALLOW_REGISTRATION wen you pass this)
#define OAIF_ALL                    (OAIF_ALLOW_REGISTRATION | OAIF_REGISTER_EXT | OAIF_EXEC | OAIF_FORCE_REGISTRATION)  //

#include <pshpack8.h>

typedef struct _openasinfo
{
    LPCTSTR pcszFile;           // [in] file name
    LPCTSTR pcszClass;          // [in] file class description.  NULL means
                                //      use pcszFile's extension
    DWORD dwInFlags;            // [in] input flags from OAIF_*

    TCHAR szApp[MAX_PATH];      // [out] application selected
} OPENASINFO, * POPENASINFO;

#include <poppack.h>        /* Return to byte packing */

SHSTDAPI OpenAsDialog(HWND hwnd, POPENASINFO poainfo);

//
// Interface pointer validation
//
#define IsBadInterfacePtr(pitf, ITF)  SHIsBadInterfacePtr(pitf, sizeof(ITF##Vtbl))

//===========================================================================
// Another block of private API
//===========================================================================

// indexes into the shell image lists (Shell_GetImageList) for default images
// If you add to this list, you also need to update II_LASTSYSICON!

#define II_DOCNOASSOC         0  // document (blank page) (not associated)
#define II_DOCUMENT           1  // document (with stuff on the page)
#define II_APPLICATION        2  // application (exe, com, bat)
#define II_FOLDER             3  // folder (plain)
#define II_FOLDEROPEN         4  // folder (open)
#define II_DRIVE525           5
#define II_DRIVE35            6
#define II_DRIVEREMOVE        7
#define II_DRIVEFIXED         8
#define II_DRIVENET           9
#define II_DRIVENETDISABLED  10
#define II_DRIVECD           11
#define II_DRIVERAM          12
#define II_WORLD             13
#define II_NETWORK           14
#define II_SERVER            15
#define II_PRINTER           16
#define II_MYNETWORK         17
#define II_GROUP             18
// Startmenu images.
#define II_STPROGS           19
#define II_STDOCS            20
#define II_STSETNGS          21
#define II_STFIND            22
#define II_STHELP            23
#define II_STRUN             24
#define II_STSUSPEND         25
#define II_STEJECT           26
#define II_STSHUTD           27

#define II_SHARE             28
#define II_LINK              29
#define II_SLOWFILE          30
#define II_RECYCLER          31
#define II_RECYCLERFULL      32
#define II_RNA               33
#define II_DESKTOP           34

// More startmenu image.
#define II_STCPANEL          35
#define II_STSPROGS          36
#define II_STPRNTRS          37
#define II_STFONTS           38
#define II_STTASKBR          39

#define II_CDAUDIO           40
#define II_TREE              41
#define II_STCPROGS          42
#define II_STFAVORITES       43
#define II_STLOGOFF          44
#define II_STFLDRPROP        45
#define II_WINUPDATE         46

#define II_MU_STSECURITY     47
#define II_MU_STDISCONN      48

#ifdef WINNT // hydra specific id
#define II_LASTSYSICON       II_MU_STDISCONN
#else
// Last system image list icon index - used by icon cache manager
#define II_LASTSYSICON       II_WINUPDATE
#endif

// Overlay indexes
#define II_OVERLAYFIRST      II_SHARE
#define II_OVERLAYLAST       II_SLOWFILE

#define II_NDSCONTAINER      72
#define II_SERVERSHARE       73

SHSTDAPI_(BOOL) FileIconInit( BOOL fRestoreCache );

// DOC'ed for DOJ compliance
SHSTDAPI_(void) Shell_SysColorChange(void);
// DOC'ed for DOJ compliance

//
// OLE string
//
SHSTDAPI_(int) OleStrToStrN(LPTSTR, int, LPCOLESTR, int);
SHSTDAPI_(int) StrToOleStrN(LPOLESTR, int, LPCTSTR, int);
SHSTDAPI_(int) OleStrToStr(LPTSTR, LPCOLESTR);
SHSTDAPI_(int) StrToOleStr(LPOLESTR, LPCTSTR);


#define LIPF_ENABLE     0x00000001  // create the object (vs release the object)
#define LIPF_HOLDREF    0x00000002  // hold ref on object after creation (vs release immediately)

typedef struct
{
    CLSID clsid;
    DWORD dwFlags;
} LOADINPROCDATA, *PLOADINPROCDATA;

// Tray CopyData Messages
#define TCDM_APPBAR     0x00000000
#define TCDM_NOTIFY     0x00000001
#define TCDM_LOADINPROC 0x00000002

//
// Private QueryContextMenuFlag passed from Bands
//
#define CMF_BANDCMD      0x00020000     // Install Band Context menu commands

//
// Functions to help the cabinets sync to each other
//  uOptions parameter to SHWaitForFileOpen
//
#define WFFO_WAITTIME 10000L

#define WFFO_ADD        0x0001
#define WFFO_REMOVE     0x0002
#define WFFO_WAIT       0x0004
#define WFFO_SIGNAL     0x0008



//
// NOTES: IShellService is used when we share a service component
//  (which implements a certain interface) among multiple clients
//  (such as IE 3.0 and Explorer). The client always CoCreateInstance
//  it and call SetOwner(this). When the client is going away
//  (typically when the window is closed), it calls SetOwner(NULL)
//  to let the service object releases the reference to the owner
//  object.
//
#undef  INTERFACE
#define INTERFACE   IShellService

DECLARE_INTERFACE_(IShellService, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellService specific methods ***
    STDMETHOD(SetOwner)(THIS_ struct IUnknown* punkOwner) PURE;
};


//
// NOTES: IHistSFPrivate is used when manipulating a history IShellFolder object
//      It includes methods for pointing the shell folder at the correct virtual
//      directory.  QIing for IHistSFPrivate also guarantees the pidl format can
//      safely be delved into to access the INTERNET_CACHE_ENTRY_INFO structure
//
#undef  INTERFACE
#define INTERFACE   IHistSFPrivate

DECLARE_INTERFACE_(IHistSFPrivate, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IHistPrivate specific methods ***
    STDMETHOD(SetCachePrefix)(THIS_ LPCWSTR pszCachePrefix) PURE;
    STDMETHOD(SetDomain)(THIS_ LPCWSTR pszDomain) PURE;
    STDMETHOD(WriteHistory)(THIS_ LPCWSTR pszPrefixedUrl, FILETIME ftExpires, FILETIME ftModified, LPITEMIDLIST * ppidlSelect) PURE;
    STDMETHOD(ClearHistory) (THIS) PURE;
};

//
// NOTES:  IShellFolderViewType lets a shell folder support different "views" on
//      its contents (meaning different hierarchical layouts of its data) with
//      the default "view" being the one the shell folder displays normally.
//      This enumerator returns pidls that are special hidden folders at the
//      top level of the shell folder (which are not otherwise enumerated).
#undef  INTERFACE
#define INTERFACE   IShellFolderViewType
DECLARE_INTERFACE_(IShellFolderViewType, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderViewType Methods ***

    // NOTE: "Views" are seen by the user as hidden folders off the
    //       root (represented by pidls).  Whenever appropriate, the
    //       default view (coming off the root folder) is represented
    //       as the NULL *or* empty pidl.

    // EnumViews:
    //   Return an enumerator which will give out one pidl for every extended view.
    STDMETHOD(EnumViews)(THIS_ ULONG grfFlags, IEnumIDList **ppenum) PURE;

    // GetDefaultViewName:
    //   Return the name of the default view.  The names of the other views
    //   can be retrieved by calling GetDisplayNameOf.
    STDMETHOD(GetDefaultViewName)(THIS_ DWORD  uFlags, LPWSTR *ppwszName)      PURE;
    STDMETHOD(GetViewTypeProperties)(THIS_ LPCITEMIDLIST pidl, DWORD *pdwFlags)  PURE;

    // TranslateViewPidl:
    //   Attempt to take a pidl represented in one heirarchical representation of
    //   the shell folder, and find it in a different representation.
    //   pidl should be relative to the root folder.
    //   Remember to ILFree ppidlOut
    STDMETHOD(TranslateViewPidl)(THIS_ LPCITEMIDLIST pidl, LPCITEMIDLIST pidlView, LPITEMIDLIST *ppidlOut) PURE;
};

#define SFVTFLAG_NOTIFY_CREATE  0x00000001
#define SFVTFLAG_NOTIFY_RESORT  0x00000002

//
// NOTES: IShellFolderSearchableCallback allows the searcher to provide
//          callback routines that moniter the search process
//
#undef  INTERFACE
#define INTERFACE IShellFolderSearchableCallback
DECLARE_INTERFACE_(IShellFolderSearchableCallback, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderSearchableCallback Methods ***

    // NOTE: Caller may pass NULL for pVar or pdwFlags as a legal value
    STDMETHOD(RunBegin)(THIS_ DWORD dwReserved) PURE;
    STDMETHOD(RunEnd)(THIS_ DWORD dwReserved) PURE;
};

//
// NOTES: IShellFolderSearchable allows a shell extension to provide a searchable
//        namespace.
#undef  INTERFACE
#define INTERFACE IShellFolderSearchable
DECLARE_INTERFACE_(IShellFolderSearchable, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderSearchable methods ***

    // FindString -
    //  The returned shell folder's enumerator will have any
    //   search hits for the given search string.
    //  As no flags are currently defined, we suggest you pass
    //    NULL as lpdword
    //  punkOnAsyncSearch will be QI'd for IShellFolderSearchableCallback
    STDMETHOD(FindString)(THIS_ LPCWSTR pwszTarget, DWORD *pdwFlags,
                          IUnknown *punkOnAsyncSearch, LPITEMIDLIST *ppidlOut)   PURE;
    // CancelAsyncSearch -
    //   Begins the process of cancelling  any pending
    //    asynchronous search from this pidl.
    //    When the search is actually cancelled, RunEnd will be called
    //   Returns: S_OK => cancelling, S_FALSE => not running
    STDMETHOD(CancelAsyncSearch) (THIS_ LPCITEMIDLIST pidlSearch, DWORD *pdwFlags) PURE;

    // InvalidateSearch -
    //   Makes this pidl no longer a valid portion of the shell folder
    //    also does some cleanup of any databases used in the search and
    //    will cause the eventual release of the IRunHook callback
    //   May cause async search to be cancelled
    STDMETHOD(InvalidateSearch)  (THIS_ LPCITEMIDLIST pidlSearch, DWORD *pdwFlags) PURE;
};

//
// NOTES: IBandSiteHelper is used to let explorer's BandSite implementation,
//  which aggregates shdocvw's BandSite, provide callback hooks for shdocvw
//  to call.
//
#undef  INTERFACE
#define INTERFACE   IBandSiteHelper

DECLARE_INTERFACE_(IBandSiteHelper, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBandSiteHelper specific methods ***
    STDMETHOD(LoadFromStreamBS)(THIS_ struct IStream* pstm, REFIID riid, void **ppv) PURE;
    STDMETHOD(SaveToStreamBS)(THIS_ struct IUnknown* punk, struct IStream* pstm) PURE;
};

// This private interface is added such that some of the support features that is in
// SHDocvw's Internet explorer frame automation code, that is not part of publicly
// defined interfaces can be used in the Explorer code...
//
// Note: FindCIE4ConnectionPoint was a hack for IE4.  New code should use
//       shlwapi helper functions like IConnectionPoint_Invoke instead.
//

#ifdef __cplusplus
class CIE4ConnectionPoint;
#else
typedef struct CIE4ConnectionPoint CIE4ConnectionPoint;
#endif

#undef  INTERFACE
#define INTERFACE   IExpDispSupport

DECLARE_INTERFACE_(IExpDispSupport, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExpDispSupport specific methods ***
    STDMETHOD(FindCIE4ConnectionPoint)(THIS_ REFIID riid, CIE4ConnectionPoint **ppccp) PURE;
    STDMETHOD(OnTranslateAccelerator)(THIS_ MSG  *pMsg, DWORD grfModifiers) PURE;
    STDMETHOD(OnInvoke)(THIS_ DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams,
                        VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) PURE;
};

//
// This interface is related to the above. It contains functions
// that would only be implemented on the WebBrowserOC version if IExpDispSupport.
//
#undef  INTERFACE
#define INTERFACE   IExpDispSupportOC
DECLARE_INTERFACE_(IExpDispSupportOC, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExpDispSupportOC specific methods ***
    STDMETHOD(OnOnControlInfoChanged)(THIS) PURE;
    STDMETHOD(GetDoVerbMSG)(THIS_ MSG *pMsg) PURE;
};



//===========================================================================
// IConnectionPointCB interface
#undef  INTERFACE
#define INTERFACE  IConnectionPointCB
DECLARE_INTERFACE_(IConnectionPointCB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IConnectionPointCB Methods ***
    STDMETHOD(OnAdvise) (THIS_ REFIID iid, DWORD cSinks, ULONG_PTR dwCookie) PURE;
    STDMETHOD(OnUnadvise) (THIS_ REFIID iid, DWORD cSinks, ULONG_PTR dwCookie) PURE;

};

//===========================================================================
// IDelegateDropTargetCB interface
//
// This interface is used by CDelegateDropTarget implementation in shdocvw
// to generate an IDropTarget implementation that delegates to different
// IDropTarget implementations depending on the point currently over. The
// implementor of IDelegateDropTargetCB can handle feedback, scrolling,
// hit testing, and returning interfaces for ids returned from hit testing.
//
// GetWindows returns the hwnd to lock and the hwnd to scroll (not necesarily
//            the same window, as you often want to lock the parent of the window
//            you want to scroll)
//
// HitTest    should return an id of the object over as well as
//            uptate UI (highlights, etc). if ppt is NULL
//            that means remove any UI as the drag is terminating.
//            this should be able to handle hittesting on points not
//            even inside hwndScroll.
//
// GetObject  returns an interface for an id returned from HitTest
//
// OnDrop     gives the CB a chance to take action on the drop.
//            returning S_FALSE from this function prevents
//            CDelegateDropTarget from calling pdt->Drop(...).
//
#undef  INTERFACE
#define INTERFACE  IDelegateDropTargetCB
DECLARE_INTERFACE_(IDelegateDropTargetCB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDelegateDropTargetCB Methods ***
    STDMETHOD(GetWindows) (THIS_ HWND * phwndLock, HWND * phwndScroll) PURE;
    STDMETHOD(HitTest) (THIS_ LPPOINT ppt, DWORD * pdwId) PURE;
    STDMETHOD(GetObject) (THIS_ DWORD dwId, REFIID riid, void **ppv) PURE;
    STDMETHOD(OnDrop) (THIS_ IDropTarget *pdt, IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect) PURE;

};


#ifdef __COMMCTRL_DA_DEFINED__ // we need HDPAs for this interface
//
// IOrderList - for ordering info in favorites/channels
//
// Typical usage is: GetOrderList, AllocOrderItem, insert into correct
// position, SetOrderList, and then FreeOrderList.
//
typedef struct
{
    LPITEMIDLIST    pidl;       // IDlist for this item
    int             nOrder;     // Ordinal indicating user preference
    DWORD           lParam;     // store custom order info.
} ORDERITEM, * PORDERITEM;

// Values for SortOrderList
#define OI_SORTBYNAME       0
#define OI_SORTBYORDINAL    1
#define OI_MERGEBYNAME      2

#undef  INTERFACE
#define INTERFACE  IOrderList
DECLARE_INTERFACE_(IOrderList, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOrderList Methods ***
    STDMETHOD(GetOrderList)(THIS_ HDPA * phdpa) PURE;
    STDMETHOD(SetOrderList)(THIS_ HDPA hdpa, IShellFolder *psf) PURE;
    STDMETHOD(FreeOrderList)(THIS_ HDPA hdpa) PURE;
    STDMETHOD(SortOrderList)(THIS_ HDPA hdpa, DWORD dw) PURE;
    STDMETHOD(AllocOrderItem)(THIS_ PORDERITEM * ppoi, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(FreeOrderItem)(THIS_ PORDERITEM poi) PURE;
};

#undef  INTERFACE
#define INTERFACE  IOrderList2
DECLARE_INTERFACE_(IOrderList2, IOrderList)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOrderList Methods ***
    STDMETHOD(GetOrderList)(THIS_ HDPA * phdpa) PURE;           // BUGBUG (lamadio): This assumes Favorites Menu
    STDMETHOD(SetOrderList)(THIS_ HDPA hdpa, IShellFolder *psf) PURE; // BUGBUG (lamadio): This assumes Favorites Menu
    STDMETHOD(FreeOrderList)(THIS_ HDPA hdpa) PURE;
    STDMETHOD(SortOrderList)(THIS_ HDPA hdpa, DWORD dw) PURE;
    STDMETHOD(AllocOrderItem)(THIS_ PORDERITEM * ppoi, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(FreeOrderItem)(THIS_ PORDERITEM poi) PURE;

    // *** IOrderList2
    STDMETHOD(LoadFromStream)(THIS_ IStream* pstm, HDPA* phdpa, IShellFolder* psf) PURE;
    STDMETHOD(SaveToStream)(THIS_ IStream* pstm, HDPA hdpa) PURE;
};

#endif


//===========================================================================
// IShellHTMLWindowSupport private COmWindow interface. This should never be exposed.
typedef struct IHTMLElement IHTMLElement;

#undef  INTERFACE
#define INTERFACE  IShellHTMLWindowSupport
DECLARE_INTERFACE_(IShellHTMLWindowSupport, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(ViewReleaseIntelliForms)(THIS) PURE;
    STDMETHOD(ViewReleased)(THIS) PURE;
    STDMETHOD(ViewActivated)(THIS) PURE;
    STDMETHOD(ReadyStateChangedTo)(THIS_ long, IShellView* ) PURE;
    STDMETHOD(CanNavigate)(THIS) PURE;
    STDMETHOD(ActiveElementChanged)(THIS_ IHTMLElement * pHTMLElement) PURE;

};

//===========================================================================
// IShellHTMLWindowSupport2 private COmWindow interface. This should never be exposed.

#undef  INTERFACE
#define INTERFACE  IShellHTMLWindowSupport2
DECLARE_INTERFACE_(IShellHTMLWindowSupport2, IShellHTMLWindowSupport)
{

    STDMETHOD(IsGalleryMeta)(THIS_ BOOL bFlag) PURE;

};


//===========================================================================
// IBandProxy private COmWindow interface. This should never be exposed.
#undef INTERFACE
#define INTERFACE IBandProxy
DECLARE_INTERFACE_(IBandProxy, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBandProxy Methods ***
    STDMETHOD(SetSite) (THIS_ IUnknown* punkSite) PURE;
    STDMETHOD(CreateNewWindow) (THIS_ IUnknown** ppunk) PURE;
    STDMETHOD(GetBrowserWindow) (THIS_ IUnknown** ppunk) PURE;
    STDMETHOD(IsConnected) (THIS) PURE;
    STDMETHOD(NavigateToPIDL) (THIS_ LPCITEMIDLIST pidl) PURE;
    STDMETHOD(NavigateToURL) (THIS_ LPCWSTR wzUrl, VARIANT * Flags) PURE;
};



//===========================================================================
//
// Make it sure that we include ole2x.h and shlobj.h
//
#if defined(__IOleInPlaceSite_FWD_DEFINED__) && defined(FCIDM_SHVIEWFIRST)

#ifdef HLINK_H

#include <pshpack8.h>

typedef struct {
    HWND _hwnd;
    ITravelLog  *_ptl;
    IHlinkFrame *_phlf;
    IWebBrowser2    *_pautoWB2; // use this to reference _pauto's IWebBrowser2 functions
    IExpDispSupport *_pautoEDS; // use this to reference _pauto's IExpDispSupport functions
    IShellService   *_pautoSS;  // use this to reference _pauto's IShellService functions
    int _eSecureLockIcon;
    DWORD _fCreatingViewWindow :1;
    UINT _uActivateState;   // this is the state we should use when we go active..
                            // this is here so that derived classes can set us for UI or non-UI active

    // The following pidl is used in CBaseBrowser2::GetViewStateStream because
    // at that time, neither _pidlCur nor _pidlPending are initialized.
    LPCITEMIDLIST  _pidlNewShellView;

    IOleCommandTarget* _pctView;

    LPITEMIDLIST _pidlCur;
    IShellView *_psv;
    IShellFolder *_psf; // IShellFolder for _psv (used in CVOCBrowser)
    HWND        _hwndView;
    LPWSTR      _pszTitleCur;

    LPITEMIDLIST _pidlPending;
    IShellView *_psvPending;
    IShellFolder *_psfPending;
    HWND        _hwndViewPending;
    LPWSTR      _pszTitlePending;

    BOOL _fIsViewMSHTML;
    BOOL _fPrivacyImpacted;

} BASEBROWSERDATA, *LPBASEBROWSERDATA;
typedef const BASEBROWSERDATA *LPCBASEBROWSERDATA;

#include <poppack.h>

#else
// so (unref'ed) ifaces will compile (?)
typedef LPVOID BASEBROWSERDATA;
typedef LPCVOID *LPBASEBROWSERDATA;     // BUGBUG LPVOID?
typedef LPCVOID *LPCBASEBROWSERDATA;

#endif // hlink_h

typedef struct _travellog * PTRAVELLOG;

#undef  INTERFACE
#define INTERFACE   IBrowserService

DECLARE_INTERFACE_(IBrowserService, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBrowserService specific methods ***
    STDMETHOD(GetParentSite)(THIS_ struct IOleInPlaceSite** ppipsite) PURE;
    STDMETHOD(SetTitle)(THIS_ IShellView* psv, LPCWSTR pszName) PURE;
    STDMETHOD(GetTitle)(THIS_ IShellView* psv, LPWSTR pszName, DWORD cchName) PURE;
    STDMETHOD(GetOleObject)(THIS_ struct IOleObject** ppobjv) PURE;

    // think about this one.. I'm not sure we want to expose this -- Chee
    // BUGBUG:: Yep soon we should have interface instead.
    // My impression is that we won't document this whole interface???
    STDMETHOD(GetTravelLog)(THIS_ ITravelLog** pptl) PURE;

    STDMETHOD(ShowControlWindow)(THIS_ UINT id, BOOL fShow) PURE;
    STDMETHOD(IsControlWindowShown)(THIS_ UINT id, BOOL *pfShown) PURE;
    STDMETHOD(IEGetDisplayName)(THIS_ LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags) PURE;
    STDMETHOD(IEParseDisplayName)(THIS_ UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut) PURE;
    STDMETHOD(DisplayParseError)(THIS_ HRESULT hres, LPCWSTR pwszPath) PURE;
    STDMETHOD(NavigateToPidl)(THIS_ LPCITEMIDLIST pidl, DWORD grfHLNF) PURE;

    STDMETHOD (SetNavigateState)(THIS_ BNSTATE bnstate) PURE;
    STDMETHOD (GetNavigateState) (THIS_ BNSTATE *pbnstate) PURE;

    STDMETHOD (NotifyRedirect) (THIS_ struct IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse) PURE;
    STDMETHOD (UpdateWindowList) (THIS) PURE;

    STDMETHOD (UpdateBackForwardState) (THIS) PURE;

    STDMETHOD(SetFlags)(THIS_ DWORD dwFlags, DWORD dwFlagMask) PURE;
    STDMETHOD(GetFlags)(THIS_ DWORD *pdwFlags) PURE;

    // Tells if it can navigate now or not.
    STDMETHOD (CanNavigateNow) (THIS) PURE;

    STDMETHOD (GetPidl) (THIS_ LPITEMIDLIST *ppidl) PURE;
    STDMETHOD (SetReferrer) (THIS_ LPITEMIDLIST pidl) PURE;
    STDMETHOD_(DWORD, GetBrowserIndex)(THIS) PURE;
    STDMETHOD (GetBrowserByIndex)(THIS_ DWORD dwID, IUnknown **ppunk) PURE;
    STDMETHOD (GetHistoryObject)(THIS_ IOleObject **ppole, IStream **pstm, IBindCtx **ppbc) PURE;
    STDMETHOD (SetHistoryObject)(THIS_ IOleObject *pole, BOOL fIsLocalAnchor) PURE;

    STDMETHOD (CacheOLEServer)(THIS_ IOleObject *pole) PURE;

    STDMETHOD (GetSetCodePage)(THIS_ VARIANT* pvarIn, VARIANT* pvarOut) PURE;
    STDMETHOD (OnHttpEquiv)(THIS_ IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut) PURE;

    STDMETHOD (GetPalette)( THIS_ HPALETTE * hpal ) PURE;

    STDMETHOD (RegisterWindow)(THIS_ BOOL fUnregister, int swc) PURE;

    // Warning!  Do not add any new methods to this interface
    // because IE4 shell32.dll uses it, so changing the interface
    // breaks IE4 interop.
};

#define BSF_REGISTERASDROPTARGET   0x00000001
#define BSF_THEATERMODE            0x00000002
#define BSF_NOLOCALFILEWARNING     0x00000010
#define BSF_UISETBYAUTOMATION      0x00000100
#define BSF_RESIZABLE              0x00000200
#define BSF_CANMAXIMIZE            0x00000400
#define BSF_TOPBROWSER             0x00000800
#define BSF_NAVNOHISTORY           0x00001000
#define BSF_HTMLNAVCANCELED        0x00002000
#define BSF_DONTSHOWNAVCANCELPAGE  0x00004000
#define BSF_SETNAVIGATABLECODEPAGE 0x00008000
#define BSF_DELEGATEDNAVIGATION    0x00010000

#define TRAVELLOG_LOCALANCHOR      0x00000001
#define TRAVELLOG_FORCEUPDATE      0x00000002

#include <pshpack8.h>

typedef struct SToolbarItem {
    IDockingWindow * ptbar;
    BORDERWIDTHS    rcBorderTool;
    LPWSTR          pwszItem;
    BOOL            fShow;
    HMONITOR        hMon;
} TOOLBARITEM, *LPTOOLBARITEM;
#define ITB_VIEW        ((UINT)-1)      // view

#include <poppack.h>   /* Assume byte packing throughout */

struct tagFolderSetData;

// TEMPORARY.  this is so that we don't have to keep writing dummy subs in basesb as we're
// building basesb2
DECLARE_INTERFACE_(IBrowserService2, IBrowserService)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBrowserService specific methods ***
    // TODO: break into 3 sections (outer, inner, and both/inherit)
    STDMETHOD(GetParentSite)(THIS_ struct IOleInPlaceSite** ppipsite) PURE;
    STDMETHOD(SetTitle)(THIS_ IShellView* psv, LPCWSTR pszName) PURE;
    STDMETHOD(GetTitle)(THIS_ IShellView* psv, LPWSTR pszName, DWORD cchName) PURE;
    STDMETHOD(GetOleObject)(THIS_ struct IOleObject** ppobjv) PURE;

    // think about this one.. I'm not sure we want to expose this -- Chee
    // BUGBUG:: Yep soon we should have interface instead.
    // My impression is that we won't document this whole interface???
    STDMETHOD(GetTravelLog)(THIS_ ITravelLog** pptl) PURE;

    STDMETHOD(ShowControlWindow)(THIS_ UINT id, BOOL fShow) PURE;
    STDMETHOD(IsControlWindowShown)(THIS_ UINT id, BOOL *pfShown) PURE;
    STDMETHOD(IEGetDisplayName)(THIS_ LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags) PURE;
    STDMETHOD(IEParseDisplayName)(THIS_ UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut) PURE;
    STDMETHOD(DisplayParseError)(THIS_ HRESULT hres, LPCWSTR pwszPath) PURE;
    STDMETHOD(NavigateToPidl)(THIS_ LPCITEMIDLIST pidl, DWORD grfHLNF) PURE;

    STDMETHOD (SetNavigateState)(THIS_ BNSTATE bnstate) PURE;
    STDMETHOD (GetNavigateState) (THIS_ BNSTATE *pbnstate) PURE;

    STDMETHOD (NotifyRedirect) (THIS_ struct IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse) PURE;
    STDMETHOD (UpdateWindowList) (THIS) PURE;

    STDMETHOD (UpdateBackForwardState) (THIS) PURE;

    STDMETHOD(SetFlags)(THIS_ DWORD dwFlags, DWORD dwFlagMask) PURE;
    STDMETHOD(GetFlags)(THIS_ DWORD *pdwFlags) PURE;

    // Tells if it can navigate now or not.
    STDMETHOD (CanNavigateNow) (THIS) PURE;

    STDMETHOD (GetPidl) (THIS_ LPITEMIDLIST *ppidl) PURE;
    STDMETHOD (SetReferrer) (THIS_ LPITEMIDLIST pidl) PURE;
    STDMETHOD_(DWORD, GetBrowserIndex)(THIS) PURE;
    STDMETHOD (GetBrowserByIndex)(THIS_ DWORD dwID, IUnknown **ppunk) PURE;
    STDMETHOD (GetHistoryObject)(THIS_ IOleObject **ppole, IStream **pstm, IBindCtx **ppbc) PURE;
    STDMETHOD (SetHistoryObject)(THIS_ IOleObject *pole, BOOL fIsLocalAnchor) PURE;

    STDMETHOD (CacheOLEServer)(THIS_ IOleObject *pole) PURE;

    STDMETHOD (GetSetCodePage)(THIS_ VARIANT* pvarIn, VARIANT* pvarOut) PURE;
    STDMETHOD (OnHttpEquiv)(THIS_ IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut) PURE;

    STDMETHOD (GetPalette)( THIS_ HPALETTE * hpal ) PURE;

    STDMETHOD (RegisterWindow)(THIS_ BOOL fUnregister, int swc) PURE;

    // Stuff added for shbrowse->shbrows2 split
    // These remove "friend" functions and classes
    //
    STDMETHOD_(LRESULT, WndProcBS)(THIS_ HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;

    STDMETHOD (SetAsDefFolderSettings)(THIS) PURE;
    STDMETHOD (GetViewRect)(THIS_ RECT * prc) PURE;

    STDMETHOD (OnSize)(THIS_ WPARAM wParam) PURE;
    STDMETHOD (OnCreate)(THIS_ LPCREATESTRUCT pcs) PURE;
    STDMETHOD_(LRESULT, OnCommand)(THIS_ WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD (OnDestroy)(THIS ) PURE;
    STDMETHOD_(LRESULT, OnNotify)(THIS_ NMHDR * pnm) PURE;
    STDMETHOD (OnSetFocus)(THIS ) PURE;
    STDMETHOD (OnFrameWindowActivateBS)(THIS_ BOOL fActive) PURE;

    STDMETHOD (ReleaseShellView)(THIS ) PURE;
    STDMETHOD (ActivatePendingView)(THIS ) PURE;
    STDMETHOD (CreateViewWindow)(THIS_ IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd) PURE;
    STDMETHOD (CreateBrowserPropSheetExt)(THIS_ REFIID riid, void **ppv) PURE;

    // these could be base browser only interfaces
    // they are not overridden by anyone, and perhaps only there for the aggregators to get info from the
    // aggregatee. NOTE: where basesb calls these,
    // it does NOT go through _pbsOuter
    STDMETHOD (GetViewWindow)(THIS_ HWND * phwndView) PURE;
    STDMETHOD (GetBaseBrowserData)(THIS_ LPCBASEBROWSERDATA * pbbd) PURE;
    STDMETHOD_(LPBASEBROWSERDATA, PutBaseBrowserData)(THIS) PURE;
    STDMETHOD (InitializeTravelLog)(THIS_ ITravelLog* ptl, DWORD dw) PURE;
    STDMETHOD (SetTopBrowser)(THIS) PURE;
    STDMETHOD (Offline)(THIS_ int iCmd) PURE;
    STDMETHOD (AllowViewResize)(THIS_ BOOL f) PURE;
    STDMETHOD (SetActivateState)(THIS_ UINT u) PURE;
    STDMETHOD (UpdateSecureLockIcon)(THIS_ int eSecureLock) PURE;
    STDMETHOD (InitializeDownloadManager)(THIS) PURE;
    STDMETHOD (InitializeTransitionSite)(THIS) PURE;
    STDMETHOD (_Initialize)(THIS_ HWND hwnd, IUnknown *pauto) PURE;


    // BEGIN REVIEW:  review names and need of each.
    //
    // this first set could be basebrowser only members.  no one overrides
    // NOTE: where basesb calls these, it does NOT go throug _pbsOuter
    STDMETHOD (_CancelPendingNavigationAsync)(THIS) PURE;
    STDMETHOD (_CancelPendingView)(THIS) PURE;
    STDMETHOD (_MaySaveChanges)(THIS) PURE;
    STDMETHOD (_PauseOrResumeView)(THIS_ BOOL fPaused) PURE;
    STDMETHOD (_DisableModeless)(THIS) PURE;

    // rethink these... are all of these necessary?
    STDMETHOD (_NavigateToPidl)(THIS_ LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags)PURE;
    STDMETHOD (_TryShell2Rename)(THIS_ IShellView* psv, LPCITEMIDLIST pidlNew)PURE;
    STDMETHOD (_SwitchActivationNow)(THIS )PURE;

    // this set is overridden and called thru _pbsOuter (and SUPER:_pbsInner)
    STDMETHOD (_ExecChildren)(THIS_ IUnknown *punkBar, BOOL fBroadcast,
                              const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                              VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)PURE;
    STDMETHOD (_SendChildren)(THIS_ HWND hwndBar, BOOL fBroadcast,
        UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;

    //END REVIEW:

    // querying from the outer.
    STDMETHOD (GetFolderSetData)(THIS_ struct tagFolderSetData* pfsd) PURE;

    // Toolbar stuff is here temporarily. Eventually it will move out
    // of basesb into commonsb, so I'm keeping the underscore "_"
    // Except those noted below, none of these are overridden by
    // outer guys, so no calls are made through _pbsOuter
    STDMETHOD (_OnFocusChange)(THIS_ UINT itb) PURE;
    STDMETHOD (v_ShowHideChildWindows)(THIS_ BOOL fChildOnly) PURE; // NOTE: overridden and called thru _pbsOuter
    STDMETHOD_(UINT,_get_itbLastFocus)(THIS) PURE;
    STDMETHOD (_put_itbLastFocus)(THIS_ UINT itbLastFocus) PURE;
    STDMETHOD (_UIActivateView)(THIS_ UINT uState) PURE;

    // Check the following functions
    STDMETHOD (_GetViewBorderRect)(THIS_ RECT* prc) PURE;
    STDMETHOD (_UpdateViewRectSize)(THIS) PURE;
    STDMETHOD (_ResizeNextBorder)(THIS_ UINT itb) PURE;
    STDMETHOD (_ResizeView)(THIS) PURE;

    STDMETHOD (_GetEffectiveClientArea)(THIS_ LPRECT lprectBorder, HMONITOR hmon) PURE;

    // Desktop needs to override this from commonsb
    STDMETHOD_(IStream*,v_GetViewStream)(THIS_ LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName) PURE;

    // Desktop needs access to these commonsb functions, they are not overridden:
    STDMETHOD_(LRESULT,ForwardViewMsg)(THIS_ UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD (SetAcceleratorMenu)(THIS_ HACCEL hacc) PURE;
    STDMETHOD_(int,_GetToolbarCount)(THIS) PURE;
    STDMETHOD_(LPTOOLBARITEM,_GetToolbarItem)(THIS_ int itb) PURE;
    STDMETHOD (_SaveToolbars)(THIS_ IStream* pstm) PURE;
    STDMETHOD (_LoadToolbars)(THIS_ IStream* pstm) PURE;
    STDMETHOD (_CloseAndReleaseToolbars)(THIS_ BOOL fClose) PURE;
    STDMETHOD (v_MayGetNextToolbarFocus)(THIS_ LPMSG lpMsg, UINT itbNext, int citb, LPTOOLBARITEM * pptbi, HWND * phwnd) PURE;
    STDMETHOD (_ResizeNextBorderHelper)(THIS_ UINT itb, BOOL bUseHmonitor) PURE;
    STDMETHOD_(UINT,_FindTBar)(THIS_ IUnknown* punkSrc) PURE;
    STDMETHOD (_SetFocus)(THIS_ LPTOOLBARITEM ptbi, HWND hwnd, LPMSG lpMsg) PURE;
    STDMETHOD (v_MayTranslateAccelerator)(THIS_ MSG* pmsg) PURE;
    STDMETHOD (_GetBorderDWHelper)(THIS_ IUnknown* punkSrc, LPRECT lprectBorder, BOOL bUseHmonitor) PURE;

    // Shell browser needs to override this from basesb.

    STDMETHOD (v_CheckZoneCrossing)(THIS_ LPCITEMIDLIST pidl) PURE;
};

DECLARE_INTERFACE_(IBrowserService3, IBrowserService2)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBrowserService specific methods ***
    // TODO: break into 3 sections (outer, inner, and both/inherit)
    STDMETHOD(GetParentSite)(THIS_ struct IOleInPlaceSite** ppipsite) PURE;
    STDMETHOD(SetTitle)(THIS_ IShellView* psv, LPCWSTR pszName) PURE;
    STDMETHOD(GetTitle)(THIS_ IShellView* psv, LPWSTR pszName, DWORD cchName) PURE;
    STDMETHOD(GetOleObject)(THIS_ struct IOleObject** ppobjv) PURE;

    // think about this one.. I'm not sure we want to expose this -- Chee
    // BUGBUG:: Yep soon we should have interface instead.
    // My impression is that we won't document this whole interface???
    STDMETHOD(GetTravelLog)(THIS_ ITravelLog** pptl) PURE;

    STDMETHOD(ShowControlWindow)(THIS_ UINT id, BOOL fShow) PURE;
    STDMETHOD(IsControlWindowShown)(THIS_ UINT id, BOOL *pfShown) PURE;
    STDMETHOD(IEGetDisplayName)(THIS_ LPCITEMIDLIST pidl, LPWSTR pwszName, UINT uFlags) PURE;
    STDMETHOD(IEParseDisplayName)(THIS_ UINT uiCP, LPCWSTR pwszPath, LPITEMIDLIST * ppidlOut) PURE;
    STDMETHOD(DisplayParseError)(THIS_ HRESULT hres, LPCWSTR pwszPath) PURE;
    STDMETHOD(NavigateToPidl)(THIS_ LPCITEMIDLIST pidl, DWORD grfHLNF) PURE;

    STDMETHOD (SetNavigateState)(THIS_ BNSTATE bnstate) PURE;
    STDMETHOD (GetNavigateState) (THIS_ BNSTATE *pbnstate) PURE;

    STDMETHOD (NotifyRedirect) (THIS_ struct IShellView* psv, LPCITEMIDLIST pidl, BOOL *pfDidBrowse) PURE;
    STDMETHOD (UpdateWindowList) (THIS) PURE;

    STDMETHOD (UpdateBackForwardState) (THIS) PURE;

    STDMETHOD(SetFlags)(THIS_ DWORD dwFlags, DWORD dwFlagMask) PURE;
    STDMETHOD(GetFlags)(THIS_ DWORD *pdwFlags) PURE;

    // Tells if it can navigate now or not.
    STDMETHOD (CanNavigateNow) (THIS) PURE;

    STDMETHOD (GetPidl) (THIS_ LPITEMIDLIST *ppidl) PURE;
    STDMETHOD (SetReferrer) (THIS_ LPITEMIDLIST pidl) PURE;
    STDMETHOD_(DWORD, GetBrowserIndex)(THIS) PURE;
    STDMETHOD (GetBrowserByIndex)(THIS_ DWORD dwID, IUnknown **ppunk) PURE;
    STDMETHOD (GetHistoryObject)(THIS_ IOleObject **ppole, IStream **pstm, IBindCtx **ppbc) PURE;
    STDMETHOD (SetHistoryObject)(THIS_ IOleObject *pole, BOOL fIsLocalAnchor) PURE;

    STDMETHOD (CacheOLEServer)(THIS_ IOleObject *pole) PURE;

    STDMETHOD (GetSetCodePage)(THIS_ VARIANT* pvarIn, VARIANT* pvarOut) PURE;
    STDMETHOD (OnHttpEquiv)(THIS_ IShellView* psv, BOOL fDone, VARIANT* pvarargIn, VARIANT* pvarargOut) PURE;

    STDMETHOD (GetPalette)( THIS_ HPALETTE * hpal ) PURE;

    STDMETHOD (RegisterWindow)(THIS_ BOOL fUnregister, int swc) PURE;

    // Stuff added for shbrowse->shbrows2 split
    // These remove "friend" functions and classes
    //
    STDMETHOD_(LRESULT, WndProcBS)(THIS_ HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;

    STDMETHOD (SetAsDefFolderSettings)(THIS) PURE;
    STDMETHOD (GetViewRect)(THIS_ RECT * prc) PURE;

    STDMETHOD (OnSize)(THIS_ WPARAM wParam) PURE;
    STDMETHOD (OnCreate)(THIS_ LPCREATESTRUCT pcs) PURE;
    STDMETHOD_(LRESULT, OnCommand)(THIS_ WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD (OnDestroy)(THIS ) PURE;
    STDMETHOD_(LRESULT, OnNotify)(THIS_ NMHDR * pnm) PURE;
    STDMETHOD (OnSetFocus)(THIS ) PURE;
    STDMETHOD (OnFrameWindowActivateBS)(THIS_ BOOL fActive) PURE;

    STDMETHOD (ReleaseShellView)(THIS ) PURE;
    STDMETHOD (ActivatePendingView)(THIS ) PURE;
    STDMETHOD (CreateViewWindow)(THIS_ IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd) PURE;
    STDMETHOD (CreateBrowserPropSheetExt)(THIS_ REFIID riid, void **ppv) PURE;

    // these could be base browser only interfaces
    // they are not overridden by anyone, and perhaps only there for the aggregators to get info from the
    // aggregatee. NOTE: where basesb calls these,
    // it does NOT go through _pbsOuter
    STDMETHOD (GetViewWindow)(THIS_ HWND * phwndView) PURE;
    STDMETHOD (GetBaseBrowserData)(THIS_ LPCBASEBROWSERDATA * pbbd) PURE;
    STDMETHOD_(LPBASEBROWSERDATA, PutBaseBrowserData)(THIS) PURE;
    STDMETHOD (InitializeTravelLog)(THIS_ ITravelLog* ptl, DWORD dw) PURE;
    STDMETHOD (SetTopBrowser)(THIS) PURE;
    STDMETHOD (Offline)(THIS_ int iCmd) PURE;
    STDMETHOD (AllowViewResize)(THIS_ BOOL f) PURE;
    STDMETHOD (SetActivateState)(THIS_ UINT u) PURE;
    STDMETHOD (UpdateSecureLockIcon)(THIS_ int eSecureLock) PURE;
    STDMETHOD (InitializeDownloadManager)(THIS) PURE;
    STDMETHOD (InitializeTransitionSite)(THIS) PURE;
    STDMETHOD (_Initialize)(THIS_ HWND hwnd, IUnknown *pauto) PURE;


    // BEGIN REVIEW:  review names and need of each.
    //
    // this first set could be basebrowser only members.  no one overrides
    // NOTE: where basesb calls these, it does NOT go throug _pbsOuter
    STDMETHOD (_CancelPendingNavigationAsync)(THIS) PURE;
    STDMETHOD (_CancelPendingView)(THIS) PURE;
    STDMETHOD (_MaySaveChanges)(THIS) PURE;
    STDMETHOD (_PauseOrResumeView)(THIS_ BOOL fPaused) PURE;
    STDMETHOD (_DisableModeless)(THIS) PURE;

    // rethink these... are all of these necessary?
    STDMETHOD (_NavigateToPidl)(THIS_ LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags)PURE;
    STDMETHOD (_TryShell2Rename)(THIS_ IShellView* psv, LPCITEMIDLIST pidlNew)PURE;
    STDMETHOD (_SwitchActivationNow)(THIS )PURE;

    // this set is overridden and called thru _pbsOuter (and SUPER:_pbsInner)
    STDMETHOD (_ExecChildren)(THIS_ IUnknown *punkBar, BOOL fBroadcast,
                              const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                              VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)PURE;
    STDMETHOD (_SendChildren)(THIS_ HWND hwndBar, BOOL fBroadcast,
        UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;

    //END REVIEW:

    // querying from the outer.
    STDMETHOD (GetFolderSetData)(THIS_ struct tagFolderSetData* pfsd) PURE;

    // Toolbar stuff is here temporarily. Eventually it will move out
    // of basesb into commonsb, so I'm keeping the underscore "_"
    // Except those noted below, none of these are overridden by
    // outer guys, so no calls are made through _pbsOuter
    STDMETHOD (_OnFocusChange)(THIS_ UINT itb) PURE;
    STDMETHOD (v_ShowHideChildWindows)(THIS_ BOOL fChildOnly) PURE; // NOTE: overridden and called thru _pbsOuter
    STDMETHOD_(UINT,_get_itbLastFocus)(THIS) PURE;
    STDMETHOD (_put_itbLastFocus)(THIS_ UINT itbLastFocus) PURE;
    STDMETHOD (_UIActivateView)(THIS_ UINT uState) PURE;

    // Check the following functions
    STDMETHOD (_GetViewBorderRect)(THIS_ RECT* prc) PURE;
    STDMETHOD (_UpdateViewRectSize)(THIS) PURE;
    STDMETHOD (_ResizeNextBorder)(THIS_ UINT itb) PURE;
    STDMETHOD (_ResizeView)(THIS) PURE;

    STDMETHOD (_GetEffectiveClientArea)(THIS_ LPRECT lprectBorder, HMONITOR hmon) PURE;

    // Desktop needs to override this from commonsb
    STDMETHOD_(IStream*,v_GetViewStream)(THIS_ LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName) PURE;

    // Desktop needs access to these commonsb functions, they are not overridden:
    STDMETHOD_(LRESULT,ForwardViewMsg)(THIS_ UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD (SetAcceleratorMenu)(THIS_ HACCEL hacc) PURE;
    STDMETHOD_(int,_GetToolbarCount)(THIS) PURE;
    STDMETHOD_(LPTOOLBARITEM,_GetToolbarItem)(THIS_ int itb) PURE;
    STDMETHOD (_SaveToolbars)(THIS_ IStream* pstm) PURE;
    STDMETHOD (_LoadToolbars)(THIS_ IStream* pstm) PURE;
    STDMETHOD (_CloseAndReleaseToolbars)(THIS_ BOOL fClose) PURE;
    STDMETHOD (v_MayGetNextToolbarFocus)(THIS_ LPMSG lpMsg, UINT itbNext, int citb, LPTOOLBARITEM * pptbi, HWND * phwnd) PURE;
    STDMETHOD (_ResizeNextBorderHelper)(THIS_ UINT itb, BOOL bUseHmonitor) PURE;
    STDMETHOD_(UINT,_FindTBar)(THIS_ IUnknown* punkSrc) PURE;
    STDMETHOD (_SetFocus)(THIS_ LPTOOLBARITEM ptbi, HWND hwnd, LPMSG lpMsg) PURE;
    STDMETHOD (v_MayTranslateAccelerator)(THIS_ MSG* pmsg) PURE;
    STDMETHOD (_GetBorderDWHelper)(THIS_ IUnknown* punkSrc, LPRECT lprectBorder, BOOL bUseHmonitor) PURE;

    // Shell browser needs to override this from basesb.

    STDMETHOD (v_CheckZoneCrossing)(THIS_ LPCITEMIDLIST pidl) PURE;

    // IBrowserService3
    STDMETHOD (_PositionViewWindow)(THIS_ HWND hwnd, LPRECT prc) PURE; // this was virtual in basesb/shbrowse, but missed this interface!
};

typedef enum
{
    NAVDATA_DONTUPDATETRAVELLOG = 0x00000001,
    NAVDATA_FRAMEWINDOW         = 0x00000002,
    NAVDATA_FRAMECREATION       = 0x00000004,
    NAVDATA_RESTARTLOAD         = 0x00000008,

} ENUMNAVDATA;

typedef struct IHTMLWindow2 IHTMLWindow2;

#undef  INTERFACE
#define INTERFACE    ITridentService

DECLARE_INTERFACE_(ITridentService, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ITridentService specific methods ***
    STDMETHOD(FireBeforeNavigate2)(THIS_
                                   IDispatch * pDispatch,
                                   LPCTSTR     lpszUrl,
                                   DWORD       dwFlags,
                                   LPCTSTR     lpszFrameName,
                                   LPBYTE      pPostData,
                                   DWORD       cbPostData,
                                   LPCTSTR     lpszHeaders,
                                   BOOL        fPlayNavSound,
                                   BOOL      * pfCancel) PURE;
    STDMETHOD(FireNavigateComplete2)(THIS_ IHTMLWindow2 * pHTMLWindow2,
                                     DWORD          dwFlags) PURE;
    STDMETHOD(FireDownloadBegin)(THIS) PURE;
    STDMETHOD(FireDownloadComplete)(THIS) PURE;
    STDMETHOD(FireDocumentComplete)(THIS_
                                    IHTMLWindow2 * pHTMLWindow,
                                    DWORD          dwFlags) PURE;
    STDMETHOD(UpdateDesktopComponent)(THIS_ IHTMLWindow2 * pHTMLWindow) PURE;
    STDMETHOD(GetPendingUrl)(THIS_ BSTR * pbstrPendingUrl) PURE;
    STDMETHOD(ActiveElementChanged)(THIS_ IHTMLElement * pHTMLElement) PURE;
    STDMETHOD(GetUrlSearchComponent)(THIS_ BSTR * pbstrSearch) PURE;
    STDMETHOD(IsErrorUrl)(THIS_ LPCTSTR lpszUrl, BOOL *pfIsError) PURE;
};

#undef  INTERFACE
#define INTERFACE    ITridentService2

DECLARE_INTERFACE_(ITridentService2, ITridentService)
{
    // *** ITridentService2 methods ***
    STDMETHOD(AttachMyPics)(THIS_ void *pDoc2, void **ppMyPics) PURE;
    STDMETHOD_(BOOL,ReleaseMyPics)(THIS_ void *pMyPics) PURE;
    STDMETHOD(IsGalleryMeta)(THIS_ BOOL bFlag, void *pMyPics) PURE;
    STDMETHOD(EmailPicture)(THIS_ BSTR bstrURL) PURE;

    STDMETHOD(FireNavigateError)(THIS_  IHTMLWindow2 * pHTMLWindow2,
                                 BSTR   bstrURL,
                                 BSTR   bstrTargetFrameName,
                                 DWORD  dwStatusCode,
                                 BOOL * pfCancel) PURE;

    STDMETHOD(FirePrintTemplateEvent)(THIS_ IHTMLWindow2 * pHTMLWindow2,
                                      DISPID dispidPrintEvent) PURE;
    STDMETHOD(FireUpdatePageStatus)(THIS_ IHTMLWindow2 * pHTMLWindow2,
                                    DWORD nPage,
                                    BOOL fDone) PURE;
    STDMETHOD(FirePrivacyImpactedStateChange)(THIS_ BOOL bPrivacyImpacted) PURE;
    STDMETHOD(InitAutoImageResize)(THIS) PURE;
    STDMETHOD(UnInitAutoImageResize)(THIS) PURE;
};


#undef  INTERFACE
#define INTERFACE    IWebBrowserPriv

DECLARE_INTERFACE_(IWebBrowserPriv, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWebBrowserPriv specific methods ***
    STDMETHOD(NavigateWithBindCtx)(THIS_ VARIANT *pvarUrl,
                                   VARIANT  *pvarFlags,
                                   VARIANT  *pvarTargetFrameName,
                                   VARIANT  *pvarPostData,
                                   VARIANT  *pvarHeaders,
                                   IBindCtx    * pBindCtx,
                                   BSTR          bstrLocation) PURE;
    STDMETHOD(OnClose)(THIS) PURE;
};

// these MUST be listed in  the same order a c_szPropNames in deskbar.cpp
typedef enum {
    PROPDATA_SIDE = 0,
    PROPDATA_MODE,
    PROPDATA_LEFT,
    PROPDATA_TOP,
    PROPDATA_RIGHT,
    PROPDATA_BOTTOM,
    PROPDATA_DELETEABLE,
    PROPDATA_X,
    PROPDATA_Y,
    PROPDATA_CX,
    PROPDATA_CY,

    PROPDATA_COUNT
} ENUMPROPDATA ;

// PROPDATA_MODE values:
//  (aka. WBM_* -- webbar modes (_eMode))
#define WBM_BOTTOMMOST  ((UINT) 0x0)      // bottommost
#define WBM_TOPMOST     ((UINT) 0x1)      // topmost
#define WBM_FLOATING    ((UINT) 0x2)      // floating
#define WBM_NIL         ((UINT) 0x7)      // nil

#undef  INTERFACE
#define INTERFACE  IDockingBarPropertyBagInit
DECLARE_INTERFACE_(IDockingBarPropertyBagInit, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IDockingBarPropertyBag ***
    STDMETHOD(SetDataDWORD)(THIS_ ENUMPROPDATA e, DWORD dwData) PURE;
} ;

#if (_WIN32_IE) >= 0x0400
//===========================================================================
// IAddressList private COmWindow interface. This should never be exposed.
#undef INTERFACE
#define INTERFACE IAddressList
DECLARE_INTERFACE_(IAddressList, IWinEventHandler)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWinEventHandler Methods ***
    STDMETHOD(OnWinEvent) (THIS_ HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres) PURE;
    STDMETHOD(IsWindowOwner) (THIS_ HWND hwnd) PURE;

    // *** IAddressList Methods ***
    STDMETHOD(Connect) (THIS_ BOOL fConnect, HWND hwnd, IBrowserService* pbs, IBandProxy* pbp, IAutoComplete * pac) PURE;
    STDMETHOD(NavigationComplete) (THIS_ void *pvCShellUrl) PURE;
    STDMETHOD(Refresh) (THIS_ DWORD dwType) PURE;
    STDMETHOD(Load) (THIS) PURE;
    STDMETHOD(Save) (THIS) PURE;
    STDMETHOD(SetToListIndex) (THIS_ int nIndex, void *pvShelLUrl) PURE;
    STDMETHOD(FileSysChangeAL) (THIS_ DWORD dw, LPCITEMIDLIST *ppidl) PURE;
};
#endif


// DOC'ed for DOJ compliance

#endif

//===========================================================================
// IDwnCodePage: This is a private interface to pass codepage info.
#undef INTERFACE
#define INTERFACE IDwnCodePage

DECLARE_INTERFACE_(IDwnCodePage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDwnCodePage Methods ***
    STDMETHOD_(UINT,GetCodePage) (THIS) PURE;
    STDMETHOD(SetCodePage) (THIS_ UINT uiCP) PURE;
};

SHSTDAPI SHDllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);

//===========================================================================

//----------------------------------------------------------------------------
#define IsLFNDriveORD           119
SHSTDAPI_(int) SHOutOfMemoryMessageBox(HWND hwndOwner, LPTSTR pszTitle, UINT fuStyle);
SHSTDAPI_(BOOL) SHWinHelp(HWND hwndMain, LPCTSTR pszHelp, UINT usCommand, ULONG_PTR ulData);

SHSTDAPI_(BOOL) RLBuildListOfPaths(void);

#ifdef WINNT
SHSTDAPI_(BOOL) RegenerateUserEnvironment(void **pPrevEnv, BOOL bSetCurrentEnv);
#endif

#define SHValidateUNCORD        173

// DOC'ed for DOJ compliance

//----------------------------------------------------------------------------
#define OleStrToStrNORD                         78
#define SHCloneSpecialIDListORD                 89
#define SHDllGetClassObjectORD                 128
#define SHLogILFromFSILORD                      95
#define SHMapPIDLToSystemImageListIndexORD      77
#define SHShellFolderView_MessageORD            73
#define Shell_GetImageListsORD                  71
#define SHGetSpecialFolderPathORD              175
#define StrToOleStrNORD                         79

#define ILCloneORD                              18
#define ILCloneFirstORD                         19
#define ILCombineORD                            25
#define ILCreateFromPathORD                     157
#define ILFindChildORD                          24
#define ILFreeORD                               155
#define ILGetNextORD                            153
#define ILGetSizeORD                            152
#define ILIsEqualORD                            21
#define ILRemoveLastIDORD                       17
#define PathAddBackslashORD                     32
#define PathCombineORD                          37
#define PathIsExeORD                            43
#define PathMatchSpecORD                        46
#define SHGetSetSettingsORD                     68
#define SHILCreateFromPathORD                   28

#define SHFreeORD                               195

#define CheckWinIniForAssocsORD                 711

// DOC'ed for DOJ Compliance

#ifndef WINNT
// Always usr TerminateThreadEx.
BOOL APIENTRY TerminateThreadEx(HANDLE hThread, DWORD dwExitCode, BOOL bCleanupFlag);
#define TerminateThread(hThread, dwExitCode) TerminateThreadEx(hThread, dwExitCode, TRUE)
#endif

// DOC'ed for DOJ Compliance
SHSTDAPI SHCreateSessionKey(REGSAM sam, HKEY *phkOut);

// Sortof Gross but if we pass this flag in with STGM_CREATE we will fail if file already exists
// with ERROR_ALREADY_EXISTS
#define CSOF_FAILIFTHERE         0x80000000L


//===========================================================================
// Structure for covert communication
// between shdocvw's CShellBrowser::Exec()
// and shell32's DefView WM_COMMAND handler

// NOTE: this structure is revealed in the KB
// (articles Q252610 and Q216954).  So even though
// it's in a private section, treat it as public.

struct _DFVCMDDATA
{
    HWND        hwnd;               // Browser hwnd
    VARIANTARG  *pva;               // Args passed to Exec()
    DWORD       nCmdIDTranslated;   // Replacement OLECMDID_* value
};
typedef struct _DFVCMDDATA DFVCMDDATA;
typedef struct _DFVCMDDATA *LPDFVCMDDATA;
typedef const struct _DFVCMDDATA *LPCDFVCMDDATA;


SHSTDAPI_(DWORD) SHGetProcessDword(DWORD idProcess, LONG iIndex);
SHSTDAPI_(BOOL)  SHSetShellWindowEx(HWND hwnd, HWND hwndChild);

#define CCH_MENUMAX     80          // DOC: max size of a menu string


// WinEventHandler message ranges
#define MBHM_FIRST          (0x00000001)    // MenuBandHandler
#define MBHM_LAST           (0x000000ff)

#define MSFM_FIRST          (0x00000100)    // MenuShellFolder
#define MSFM_LAST           (0x000001ff)

#define FSFM_FIRST          (0x00000200)    // FileShellFolder
#define FSFM_LAST           (0x000002ff)



//-------------------------------------------------------------------------
//
// SID_SMenuBandHandler
//
//  The menuband calls QueryService(SID_SMenuBandHandler, IID_IWinEventHandler)
//  on its shellfolder.  If the shellfolder supports this service, the
//  menuband will call the event handler on certain menu events.  These
//  events and messages are as follows:
//
//    MBHM_INITMENUPOPUP    sent when a drop-down menu or submenu is
//                          about to become active.
//
//
//   File-system ShellFolder events:
//
//    FSFM_COMMAND          sent when a file-system item is executed
//
//-------------------------------------------------------------------------

typedef struct tagMBINITMENUPOPUP
{
    DWORD           dwMask;     // MBIMP_*
    IShellFolder *  psf;
    LPCITEMIDLIST   pidl;
    HMENU           hmenu;
    int             iPos;
} MBINITMENUPOPUP;

#define MBIMP_HMENU     0x00000001      // hmenu and iPos are set


// Messages sent to the WinEventHandler         wParam      lParam      *plRet
//                                              ------      ------      ---
#define MBHM_INITMENUPOPUP  (MBHM_FIRST+0)  //  0           MBINITMENUPOPUP *


// Messages sent to the WinEventHandler         wParam      lParam      *plRet
//                                              ------      ------      ------
#define FSFM_COMMAND        (FSFM_FIRST+0)  //  cmd ID      pidl


//-------------------------------------------------------------------------
//
// IAugmentedShellFolder interface
//
//   This provides methods to add multiple Shell Folder objects to a
//  single augmented object (CLSID_AugmentedShellFolder), which will
//  enumerate them as if they were in a single namespace.
//
//
// [Member functions]
//
// IAugmentedShellFolder::AddNameSpace(rguidObject, psf, pidl)
//   Add the object represented by the IShellFolder interface to
//   the augmented list.  The rguidObject is used to identify the
//   given object.  It may be NULL.  The optional pidl refers to
//   the location of the psf.
//
// IAugmentedShellFolder::GetNameSpaceID(pidl, rguidOut)
//   This method returns the rguidObject associated with the given
//   pidl.  This is how a caller can identify which namespace the
//   pidl resides, given the list of IShellFolder objects that were
//   added to this augmented object.
//
// IAugmentedShellFolder::QueryNameSpace(dwNameSpaceID, pguidOut, ppsf)
//   Returns the shellfolder and guid associated with the given ID.
//
// IAugmentedShellFolder::EnumNameSpace(uNameSpace, pdwNameSpaceID)
//   Enumerates the namespace shellfolders.  If uNameSpace is -1,
//   pdwNameSpaceID is ignored and this method returns the count of
//   shellfolders in the augmented namespace.  Call this method with
//   uNameSpace starting at 0 to begin enumerating.  Returns S_OK and
//   and namespace ID in *pdwNameSpaceID.
//
//-------------------------------------------------------------------------

//  IAugmentedShellFolder::AddNameSpace flags
enum
{
    ASFF_DEFAULT                   = 0x00000000, // There are no applicable Flags
    ASFF_SORTDOWN                  = 0x00000001, // Sort the items in this ISF to the bottom.
    ASFF_MERGESAMEGUID             = 0x00000002, // Merge only namespaces with the same pguidObjects
    ASFF_COMMON                    = 0x00000004, // this is a "Common" or "All Users" folder
    // the following should all be collapsed to one ASFF_DEFNAMESPACE
    ASFF_DEFNAMESPACE_BINDSTG      = 0x00000100, // The namespace is the default handler for BindToStorage() for merged child items.
    ASFF_DEFNAMESPACE_COMPARE      = 0x00000200, // The namespace is the default handler for CompareIDs() for merged child items.
    ASFF_DEFNAMESPACE_VIEWOBJ      = 0x00000400, // The namespace is the default handler for CreateViewObject() for merged child items.
    ASFF_DEFNAMESPACE_ATTRIB       = 0x00001800, // The namespace is the default handler for GetAttributesOf() for merged child items.
    ASFF_DEFNAMESPACE_DISPLAYNAME  = 0x00001000, // The namespace is the default handler for GetDisplayNameOf(), SetNameOf() and ParseDisplayName() for merged child items.
    ASFF_DEFNAMESPACE_UIOBJ        = 0x00002000, // The namespace is the default handler for GetUIObjectOf() for merged child items.
    ASFF_DEFNAMESPACE_ITEMDATA     = 0x00004000, // The namespace is the default handler for GetItemData() for merged child items.
    ASFF_DEFNAMESPACE_ALL          = 0x0000FF00  // The namespace is the primary handler for all IShellFolder operations on merged child items.
};

enum QUERYNAMESPACEINFO_MASK
{
    ASFQNSI_FLAGS                  = 0x00000001,
    ASFQNSI_FOLDER                 = 0x00000002,
    ASFQNSI_GUID                   = 0x00000004,
    ASFQNSI_PIDL                   = 0x00000008,
};

#include <pshpack8.h>

typedef struct QUERYNAMESPACEINFO
{
    DWORD cbSize;
    DWORD dwMask;
    DWORD dwFlags;              // ASFF_*
    IShellFolder *psf;
    GUID  guidObject;
    LPITEMIDLIST pidl;
} QUERYNAMESPACEINFO;

#include <poppack.h>        /* Return to byte packing */

#undef  INTERFACE
#define INTERFACE   IAugmentedShellFolder

DECLARE_INTERFACE_(IAugmentedShellFolder, IShellFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner,LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IAugmentedShellFolder methods ***
    STDMETHOD(AddNameSpace)     (THIS_ const GUID * pguidObject, IShellFolder * psf,
                                 LPCITEMIDLIST pidl, DWORD dwFlags) PURE;
    STDMETHOD(GetNameSpaceID)   (THIS_ LPCITEMIDLIST pidl, GUID * pguidOut) PURE;
    STDMETHOD(QueryNameSpace)   (THIS_ DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf) PURE;
    STDMETHOD(EnumNameSpace)    (THIS_ DWORD uNameSpace, DWORD * pdwID) PURE;
};

#undef  INTERFACE
#define INTERFACE   IAugmentedShellFolder2

DECLARE_INTERFACE_(IAugmentedShellFolder2, IAugmentedShellFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner, LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl,
                                 ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IAugmentedShellFolder methods ***
    STDMETHOD(AddNameSpace)     (THIS_ const GUID * pguidObject, IShellFolder * psf,
                                 LPCITEMIDLIST pidl, DWORD dwFlags) PURE;
    STDMETHOD(GetNameSpaceID)   (THIS_ LPCITEMIDLIST pidl, GUID * pguidOut) PURE;
    STDMETHOD(QueryNameSpace)   (THIS_ DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf) PURE;
    STDMETHOD(EnumNameSpace)    (THIS_ DWORD uNameSpace, DWORD * pdwID) PURE;

    // *** IAugmentedShellFolder2 methods ***
    STDMETHOD(UnWrapIDList)       (THIS_ LPCITEMIDLIST pidlWrap, LONG cPidls, IShellFolder ** apsf, LPITEMIDLIST * apidlFolder, LPITEMIDLIST * apidlItems, LONG * pcFetched ) PURE ;
};

#undef  INTERFACE
#define INTERFACE   IAugmentedShellFolder3

DECLARE_INTERFACE_(IAugmentedShellFolder3, IAugmentedShellFolder2)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner, LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl,
                                 ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IAugmentedShellFolder methods ***
    STDMETHOD(AddNameSpace)     (THIS_ const GUID * pguidObject, IShellFolder * psf,
                                 LPCITEMIDLIST pidl, DWORD dwFlags) PURE;
    STDMETHOD(GetNameSpaceID)   (THIS_ LPCITEMIDLIST pidl, GUID * pguidOut) PURE;
    STDMETHOD(QueryNameSpace)   (THIS_ DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf) PURE;
    STDMETHOD(EnumNameSpace)    (THIS_ DWORD uNameSpace, DWORD * pdwID) PURE;

    // *** IAugmentedShellFolder2 methods ***
    STDMETHOD(UnWrapIDList)       (THIS_ LPCITEMIDLIST pidlWrap, LONG cPidls, IShellFolder ** apsf, LPITEMIDLIST * apidlFolder, LPITEMIDLIST * apidlItems, LONG * pcFetched ) PURE ;

    // *** IAugmentedShellFolder3 methods ***
    STDMETHOD(QueryNameSpace2)  (THIS_ DWORD dwID, QUERYNAMESPACEINFO *pqnsi) PURE;
};


//-------------------------------------------------------------------------
//
// IProxyShellFolder interface
//
//   This provides methods to set a proxy object which can respond
//  to GetUIObjectOf instead of or in addition to the hosted object
//  the supports IShellFolder.  All other methods are forwarded onto
//  the hosted object.  The CLSID_HostProxyShellFolder object implements
//  this interface.
//
//   The Win95 shell does not support aggregation, so this object
//  must be extra careful that it follows the rules of COM.
//
//   This interface is implemented by an object that wishes to provide
//  more support for GetUIObjectOf on behalf of another object that
//  implements an original IShellFolder.
//
// [Member functions]
//
// IProxyShellFolder::InitHostProxy(psf, pidl, punk, dwFlags)
//   Set the object that implements IProxyShellFolder.  Depending
//   on dwFlags, this object will be called instead of or in addition
//   to the host's method.
//
//      SPF_PRIORITY            - call the proxy's method instead of
//                              the host's method.
//      SPF_SECONDARY           - call the proxy's method only if the
//                              host's method doesn't support it.
//      SPF_INHERIT             - create a new object of this class and
//                              hand it back for BindToObject.
//      SPF_FOLDERPRECEDENCE    - have the proxy give folders priority
//                              over files in a call to CompareIDs.
//      SPF_HAVECALLBACK        - have the proxy call the owner's
//                              IOleCommandTarget on each enumerated
//                              object, for filtering.
//
//   Also sets as the host the given object which fully implements
//   IShellFolder.  pidl refers to the shell folder.
//
// IProxyShellFolder::CloneProxyPSF(riid, ppv)
//   Tells the object to clone itself.  The host proxy will call this
//   whenever IShellFolder::BindToObject is called.
//
// IProxyShellFolder::GetUIObjectOfPSF(hwndOwner, cidl, apidl, riid, prgfInOut, ppv)
//   Called by CLSID_HostProxyShellFolder to allow the proxy object
//   an opportunity to respond.
//
// IProxyShellFolder::CreateViewObjectPSF(hwndOwner, riid, ppv)
//   Called by CLSID_HostProxyShellFolder to allow the proxy object
//   an opportunity to respond.
//
//-------------------------------------------------------------------------

// SetProxyObject flags
#define SPF_PRIORITY            0x00000001       // This is mutually exclusive w/ SPF_SECONDARY
#define SPF_SECONDARY           0x00000002
#define SPF_INHERIT             0x00000004
#define SPF_FOLDERPRECEDENCE    0x00000008
#define SPF_HAVECALLBACK        0x00000010

//For filtering of Pidls
#define PHID_FilterOutPidl  0


#undef  INTERFACE
#define INTERFACE   IProxyShellFolder

DECLARE_INTERFACE_(IProxyShellFolder, IShellFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner, LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl,
                                 ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IProxyShellFolder methods ***
    STDMETHOD(InitHostProxy)     (THIS_ IShellFolder * psf, LPCITEMIDLIST pidl, DWORD dwFlags) PURE;
    STDMETHOD(CloneProxyPSF)     (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD(GetUIObjectOfPSF) (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(CreateViewObjectPSF) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;

};


//-------------------------------------------------------------------------
//
// BUGBUG (scotth): I don't think we're using this anymore.
//
// ISetWinHandler interface
//
// [Member functions]
//
// ISetWinHandler::SetWindow(hwndOwner)
//   Specifies the window owner.  This may be NULL.
//
// ISetWinHandler::SetWinHandler(punk)
//   Gives a pointer to an object which supports IWinEventHandler.  The
//   hwnd will be the window handle set by the SetWindow method.  The
//   handler should return S_OK if the message is handled, otherwise S_FALSE.
//
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   ISetWinHandler

DECLARE_INTERFACE_(ISetWinHandler, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** ISetWinHandler methods ***
    STDMETHOD(SetWindow)        (THIS_ HWND hwndOwner) PURE;
    STDMETHOD(SetWinHandler)    (THIS_ IUnknown * punk) PURE;
};


//-------------------------------------------------------------------------
//
// IMenuShellFolder interface
//
//   This wraps a static HMENU with an IShellFolder interface.
//
//
// [Member functions]
//
// IMenuShellFolder::SetMenu(hmenu)
//   Specifies the hmenu to wrap.  This may be NULL.
//
//   BUGBUG (scotth): does this copy or not?
//
// IMenuShellFolder::GetMenu(phmenu)
//   Returns the current menu in *phmenu.  Returns S_FALSE if no menu is
//   set (*phmenu will be NULL).
//
// IMenuShellFolder::SetWindow(hwndOwner)
//   Specifies the window owner.  This may be NULL.
//
//-------------------------------------------------------------------------

// Messages sent to the WinEventHandler         wParam      lParam      *plRet
//                                              ------      ------      ---
#define MSFM_COMMAND        (MSFM_FIRST+0)  //  cmd ID      0
#define MSFM_ISDROPTARGET   (MSFM_FIRST+1)  //  id          0           1 if yes


#undef  INTERFACE
#define INTERFACE   IMenuShellFolder

DECLARE_INTERFACE_(IMenuShellFolder, IShellFolder)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner, LPBC pbc, LPOLESTR pszDisplayName,
                                 ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)      (THIS_ HWND hwndOwner, DWORD grfFlags, IEnumIDList ** ppenumIDList) PURE;
    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, void **ppv) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl,
                                 ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, void **ppv) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
                                 LPCOLESTR pszName, DWORD uFlags,
                                 LPITEMIDLIST * ppidlOut) PURE;

    // *** IMenuShellFolder methods ***
    STDMETHOD(SetMenu)          (THIS_ HMENU hmenu) PURE;
    STDMETHOD(GetMenu)          (THIS_ HMENU * phmenu) PURE;
    STDMETHOD(SetWindow)        (THIS_ HWND hwndOwner) PURE;
    STDMETHOD(GetWindow)        (THIS_ HWND *phwndOwner) PURE;
    STDMETHOD(GetIDPosition)    (THIS_ LPCITEMIDLIST pidl, int * pnPos) PURE;
};


//-------------------------------------------------------------------------
//
// ITranslateShellChangeNotify interface
//
//   This interface allows an object to translate the pidls that are
// passed to it.
//
// Note:  IE4 had an interface of the same name but with a different IID,
//        so there is no conflict.
//
// [Member functions]
//
// ITranslateShellChangeNotify::TranslateIDs(&lEvent, pidl1, pidl2, ppidlOut1, ppidlOut2)
//   Return converted pidls given the event. it also can change the event if appropriate
//
//-------------------------------------------------------------------------

#undef  INTERFACE
#define INTERFACE   ITranslateShellChangeNotify

DECLARE_INTERFACE_(ITranslateShellChangeNotify, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** ITranslateShellChangeNotify methods ***
    STDMETHOD(TranslateIDs) (THIS_ LONG *plEvent , LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                   LONG *plEvent2, LPITEMIDLIST * ppidlOut1Event2, LPITEMIDLIST * ppidlOut2Event2) PURE;
    STDMETHOD(IsChildID)(THIS_ LPCITEMIDLIST pidlKid, BOOL fImmediate) PURE;
    STDMETHOD(IsEqualID)(THIS_ LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(Register)(THIS_ HWND hwnd, UINT uMsg, long lEvents) PURE;
    STDMETHOD(Unregister)(THIS) PURE;
};

////////////////////////////////////////////////////
//
// IRegTreeOptions
//
typedef enum tagBUTTON_STATES
{
    IDCHECKED,
    IDUNCHECKED,
    IDRADIOON,
    IDRADIOOFF,
    IDUNKNOWN
} BUTTON_STATES;

//
// Avoid conflicts in the windows\shell project
//
#ifndef NO_SHELL_TREE_TYPE
typedef enum tagTREE_TYPE
{
    TREE_CHECKBOX,
    TREE_RADIO,
    TREE_GROUP,
    TREE_UNKNOWN
} TREE_TYPE;
#endif // NO_SHELL_TREE_TYPE

typedef enum tagWALK_TREE_CMD
{
    WALK_TREE_SAVE,
    WALK_TREE_DELETE,
    WALK_TREE_RESTORE,
    WALK_TREE_REFRESH
} WALK_TREE_CMD;


enum REG_CMD
{
    REG_SET,
    REG_GET,
    REG_GETDEFAULT
};

#undef  INTERFACE
#define INTERFACE   IRegTreeOptions

DECLARE_INTERFACE_(IRegTreeOptions, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRegTreeOptions specific methods ***
    STDMETHOD(InitTree)(THIS_ HWND hwndTree, HKEY hkeyRoot, LPCSTR pszRegKey, LPCSTR pszParam) PURE;
    STDMETHOD(WalkTree)(THIS_ WALK_TREE_CMD cmd ) PURE;
    STDMETHOD(ToggleItem)(THIS_ HTREEITEM hti ) PURE;
    STDMETHOD(ShowHelp)(THIS_ HTREEITEM hti , DWORD dwFlags ) PURE;
};



//
// Interface: IShellHotKey
//

#undef  INTERFACE
#define INTERFACE   IShellHotKey

DECLARE_INTERFACE_(IShellHotKey, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellHotKey methods ***
    STDMETHOD(RegisterHotKey)(THIS_ IShellFolder * psf, LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidl) PURE;
};


//
// Interface: ITrayPriv
//
// Purpose: Talks to the new Start Menu code in Shdocvw from explorer.exe
//
// For flags on ShowFolder see inc\IETHREAD.H
//

#undef  INTERFACE
#define INTERFACE   ITrayPriv

DECLARE_INTERFACE_(ITrayPriv, IOleWindow)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** ITrayPriv methods ***
    STDMETHOD(ExecItem)(THIS_ IShellFolder* psf, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(GetFindCM)(THIS_ HMENU hmenu, UINT idFirst, UINT idLast, IContextMenu** ppcmFind) PURE;
    STDMETHOD(GetStaticStartMenu)(THIS_ HMENU* phmenu) PURE;
};

// ITrayPriv2 - new for Whistler
//
// Purpose: Allows Explorer Start Menu object to participate in customdraw.
//
#undef  INTERFACE
#define INTERFACE   ITrayPriv2

DECLARE_INTERFACE_(ITrayPriv2, ITrayPriv)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** ITrayPriv methods ***
    STDMETHOD(ExecItem)(THIS_ IShellFolder* psf, LPCITEMIDLIST pidl) PURE;
    STDMETHOD(GetFindCM)(THIS_ HMENU hmenu, UINT idFirst, UINT idLast, IContextMenu** ppcmFind) PURE;
    STDMETHOD(GetStaticStartMenu)(THIS_ HMENU* phmenu) PURE;

    // *** ITrayPriv2 methods ***
    STDMETHOD(ModifySMInfo)(THIS_ IN LPSMDATA psmd, IN OUT SMINFO *psminfo) PURE;
};


//
// Interface: IFolderShortcutConvert
//
// Purpose: Converts between FolderShortcuts and links
//

#undef  INTERFACE
#define INTERFACE   IFolderShortcutConvert

DECLARE_INTERFACE_(IFolderShortcutConvert, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    //*** IFolderShortcutConvert methods ***
    STDMETHOD(ConvertToLink)(THIS_ LPCOLESTR pszFSPath, DWORD fFlags) PURE;
    STDMETHOD(ConvertToFolderShortcut)(THIS_ LPCOLESTR pszLinkPath, DWORD fFlags) PURE;
};

//
// Interface: IShellFolderTask
//
// Purpose: Initializes a task that does something by enumerating a shellfolder
//

#undef  INTERFACE
#define INTERFACE   IShellFolderTask

DECLARE_INTERFACE_(IShellFolderTask, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IShellFolderTask methods ***
    STDMETHOD(InitTaskSFT)(THIS_ IShellFolder *psfParent, LPITEMIDLIST pidlFull,
                           LONG nMaxRecursionLevel, DWORD dwFlags, DWORD dwTaskPriority) PURE;
};

// Flags for InitTaskSFT
#define ITSFT_RECURSE   0x00000001      // recurse into subfolders


//
// Interface: IStartMenuTask
//
// Purpose: Initializes a task that does something for the start menu
//

#undef  INTERFACE
#define INTERFACE   IStartMenuTask

DECLARE_INTERFACE_(IStartMenuTask, IShellFolderTask)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    // *** IShellFolderTask methods ***
    STDMETHOD(InitTaskSFT)(THIS_ IShellFolder *psfParent, LPITEMIDLIST pidlFull,
                           LONG nMaxRecursionLevel, DWORD dwFlags, DWORD dwTaskPriority) PURE;

    // *** IStartMenuTask methods ***
    STDMETHOD(InitTaskSMT)(THIS_ IShellHotKey * photkey, int iThreadPriority) PURE;
};

//
// Interface: IContextMenuCB
//
// Purpose: A call defview context menu callback object
//

#undef  INTERFACE
#define INTERFACE   IContextMenuCB

DECLARE_INTERFACE_(IContextMenuCB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IContextMenuCB methods ***
    STDMETHOD(CallBack) (THIS_  IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, UINT uMsg,
                                WPARAM wParam, LPARAM lParam) PURE;
};

//
// Possible underline settings for shell icons.
//
enum
{
    ICON_YES,
    ICON_NO,
    ICON_HOVER,
    ICON_IE         // Use IE hyperlink settings
};

//-----------------------------------------------
// IOleCommand Target Command IDs

// CGID_BandHandler
    //  Get the order stream from parent.
#define BHCMDID_GetOrderStream      0x00000001

// CGID_Persist
    // Set the storage key.
#define MCBID_SetKey                0x00000001

// CGID_MenuBandItem
#define MBICMDID_IsVisible          0x00000001

// CGID_MenuBand
#define MBANDCID_REFRESH            0x10000000


//
// Interface: IShellMallocSpy
//
// Purpose: Facilitate IMallocSpy in the shell
//

#undef  INTERFACE
#define INTERFACE  IShellMallocSpy
DECLARE_INTERFACE_(IShellMallocSpy, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IShellMallocSpy methods ***
    STDMETHOD(RegisterSpy) (THIS) PURE;
    STDMETHOD(RevokeSpy) (THIS) PURE;
    STDMETHOD(SetTracking) (THIS_ BOOL bTrack) PURE;
    STDMETHOD(AddToList) (THIS_ void *pv, SIZE_T cb) PURE;
    STDMETHOD(RemoveFromList) (THIS_ void *pv) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchProvider

DECLARE_INTERFACE_(ISearchProvider, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISearchObject methods ***
    STDMETHOD(GetSearchGUID)(THIS_ LPGUID lpGuid) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchItems

DECLARE_INTERFACE_(ISearchItems, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISearchItems methods ***
    //used by CSearchBand
    STDMETHOD(GetDefaultSearchUrl) (THIS_ LPWSTR pwzUrl, UINT cch) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchBandTBHelper50

DECLARE_INTERFACE_(ISearchBandTBHelper50, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISearchBandTBHelper50 methods ***
    // implemented by CSearchBand
    STDMETHOD(AddNextMenuItem) (THIS_ LPCWSTR pwszText, int idItem) PURE;
    STDMETHOD(SetOCCallback) (THIS_ IOleCommandTarget *pOleCmdTarget) PURE;
    STDMETHOD(ResetNextMenu) (THIS) PURE;
};

#undef  INTERFACE
#define INTERFACE   ISearchBandTBHelper

DECLARE_INTERFACE_(ISearchBandTBHelper, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ISearchBandTBHelper methods ***
    // implemented by CSearchBand
    STDMETHOD(AddNextMenuItem) (THIS_ LPCWSTR pwszText, int idItem) PURE;
    STDMETHOD(SetOCCallback) (THIS_ IOleCommandTarget *pOleCmdTarget) PURE;
    STDMETHOD(ResetNextMenu) (THIS) PURE;
    STDMETHOD(NavigateToPidl) (THIS_ LPCITEMIDLIST pidl) PURE;
};

#undef  INTERFACE
#define INTERFACE   IEnumUrlSearch

#include <pshpack8.h>

typedef struct
{
    GUID  guid;
    WCHAR wszName[80];
    WCHAR wszUrl[2048];
} URLSEARCH, *LPURLSEARCH;

#include <poppack.h>        /* Return to byte packing */

DECLARE_INTERFACE_(IEnumUrlSearch, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumUrlSearch methods ***
    STDMETHOD(Next)(THIS_ ULONG celt, LPURLSEARCH rgelt, ULONG *pceltFetched) PURE;
    STDMETHOD(Skip)(THIS_ ULONG celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone)(THIS_ IEnumUrlSearch **ppenum) PURE;
};

#undef  INTERFACE
#define INTERFACE   IFolderSearches

DECLARE_INTERFACE_(IFolderSearches, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IFolderSearches methods ***
    STDMETHOD(EnumSearches) (THIS_ IEnumUrlSearch **ppenum) PURE;
    STDMETHOD(DefaultSearch) (THIS_ GUID *pguid) PURE;
};
#undef  INTERFACE
#define INTERFACE   IUserAssist

typedef struct
{
    DWORD   cbSize;     // SIZEOF
    DWORD   dwMask;     // INOUT requested/given (UEIM_*)
    int     cHit;       // profile count
    DWORD   dwAttrs;    // attributes (UEIA_*)
    FILETIME ftExecute; // Last execute filetime
} UEMINFO, *LPUEMINFO;

#define UEIM_HIT        0x01
#define UEIM_FILETIME   0x02

DECLARE_INTERFACE_(IUserAssist, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IUserAssist methods ***
    STDMETHOD(FireEvent)(THIS_ const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD(QueryEvent)(THIS_ const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui) PURE;
    STDMETHOD(SetEvent)(THIS_ const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui) PURE;
};



// This exists for the Internet Control Panel to be able to toggle who is the
// currently installed handler for FTP for the browser.
DECLARE_INTERFACE_(IFtpInstaller, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)   (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef)    (THIS) PURE;
    STDMETHOD_(ULONG,Release)   (THIS) PURE;

    // *** IFtpInstaller methods ***
    STDMETHOD(IsIEDefautlFTPClient)(THIS) PURE;
    STDMETHOD(RestoreFTPClient)(THIS) PURE;
    STDMETHOD(MakeIEDefautlFTPClient)(THIS) PURE;
};

// DOC'ed for DOJ compliance

#define CLR_MYINVALID 0x8fffffff       // I need to use a special value since CLR_INVALID == CLR_NONE!!!!
#define ISVALIDCOLOR(a) ((a) != CLR_MYINVALID)

// The following are used as indexes into the crCustomColors array.
#define CRID_CUSTOMTEXTBACKGROUND   0
#define CRID_CUSTOMTEXT             1
#define CRID_COLORCOUNT             2

typedef struct _CUSTOMVIEWSDATA
{
    DWORD      cchSizeOfBlock;  // size of lpDataBlock in WCHARs
    LPWSTR     lpDataBlock;     // Pointer to the Strings data block, allocated by the task allocator (SHAlloc)

    // The following are offsets (in WCHARs) to be added to lpDataBlock.
    // If the offset is -1 => That data is not present for this view.
    int        acchOffExtViewUIstr[6]; // ID_EXTVIEWSTRCOUNT was 6, but is no longer used
    COLORREF   crCustomColors[CRID_COLORCOUNT];

    // Once IE4 ships, we can extend this structure by adding new SFVF_ flags
    // in the main structure that say "customviewsdata contains xxx info".

} CUSTOMVIEWSDATA;

//
// Interface for enumerating "external" views for the ShellFolderView
//
typedef struct _SFVVIEWSDATA
{
    // idView specifies the view. Unless specified in pCustomData, look up
    // HKLM\CLSID\Software\Microsoft\Windows\CurrentVersion\ExtShellFolderViews\idView
    // to find the menu name, help text, tt text.
    //
    // the shell's IShellFolderView implementations get these as
    // subkeys of the shellex\ExtShellFolderViews key under the folder's
    // clsid type (or progid type, depending on the IShellFolderView impl).
    //
    // In desktop.ini, these are keys read from the [ExtShellFolderViews]
    // section, in the form of "{idView}" or "{idView}={idExtShellView}"
    //
    GUID idView;    // This is the GUID that specifies the View.

    // idExtShellView specifies the IDefViewExtInit IShellView extension
    // to use for this view.
    //
    // the shell's IShellFolderView implementations get this from
    // the "ISV" value under the shellex\ExtShellFolderViews\{idView}
    // key in the registry.
    //
    // In desktop.ini, this is read from the [ExtShellFolderViews]
    // section, in the form of "{idView}={idExtShellView}"
    //
    GUID idExtShellView; // [optional] This is the GUID for the extended IShellView

    // dwFlags - see the SFVF_ flags below.
    //
    // the shell's IShellFolderView implementations get this from
    // the "Attributes" value under the shellex\ExtShellFolderViews\{idView}
    // key in the registry.
    //
    // In desktop.ini, this is read from the [{idView}] section,
    // from the "Attributes=" line.
    //
    DWORD dwFlags;

    // lParam is passed to IShellView view extensions
    //
    // the shell's IShellFolderView implementations get this from
    // the "lparam" value under the shellex\ExtShellFolderViews\{idView}
    // key in the registry.
    //
    // In desktop.ini, this is read from the [{idView}] section,
    // from the "LParam=" line.
    //
    DWORD lParam;

    // wszMoniker is used to either bind to a docobject extended view,
    // or as the data for an idExtShellView view.
    //
    // the shell's IShellFolderView implementations get this from
    // the "PersistMoniker" value under the shellex\ExtShellFolderViews\{idView}
    // key in the registry.
    //
    // In desktop.ini, this is read from the [{idView}] section,
    // from the "PersistMoniker=" line.
    //
    WCHAR wszMoniker[MAX_PATH];

    // pCustomData overrides/provides menu and other ui options
    // for this view. If a WebViewFolderContents OC appears in the
    // docobject extended view, it pays attention to color and
    // background bitmaps.
    //
    // the shell's IShellFolderView implementations do not fill out this structure.
    //
    // In desktop.ini, this is read from the [{idView}] section,
    // from the "IconArea_Image", "IconArea_TextBackground", and "IconArea_Text".
    //
    CUSTOMVIEWSDATA *pCustomData; //This is valid only if SFVF_CUSTOMIZEDVIEW is set.

} SFVVIEWSDATA;

//
// SFVF_CUSTOMIZEDVIEW - This flag is set only for those views whose
// data are picked up from the Desktop.ini.
//
#define SFVF_CUSTOMIZEDVIEW  0x80000000

//
// SFVF_TREATASNORMAL - This flag is set for those views that wish to
// be treated as normal views, this means they will show up in the file-open/SaveAs
// Dialogs.
//
#define SFVF_TREATASNORMAL   0x40000000

//
// SFVF_NOWEBVIEWFOLDERCONTENTS - This is used to detect those views that
// never host the WebViewFolderContents OC and so cannot toggle on and off,
// ie, they are exclusive views such as Thumbnail View.
//
#define SFVF_NOWEBVIEWFOLDERCONTENTS   0x20000000


#undef  INTERFACE
#define INTERFACE   IEnumSFVViews

DECLARE_INTERFACE_(IEnumSFVViews, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumSFVViews methods ***
    STDMETHOD(Next)  (THIS_ ULONG celt,
                      SFVVIEWSDATA **ppData,
                      ULONG *pceltFetched) PURE;
    STDMETHOD(Skip)  (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSFVViews **ppenum) PURE;
};


#undef  INTERFACE
#define INTERFACE   IPersistString

DECLARE_INTERFACE_(IPersistString, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistString methods ***
    STDMETHOD(Initialize) (THIS_ LPCWSTR pwszInit) PURE;
};

#pragma warning (disable: 4200)
#pragma warning (disable: 4510)
#pragma warning (disable: 4512)
#pragma warning (disable: 4610)
// From sdkinc\platform.h
// We can't simply include that file because it breaks other projects
// that include platform.h.

// DOC'ed for DOJ compliance:
#include <pshpack8.h>

typedef struct _SFVM_SELCHANGE_DATA
{
    UINT uOldState;
    UINT uNewState;
    LPARAM lParamItem;
} SFVM_SELCHANGE_DATA;


typedef struct _COPYHOOKINFO
{
    HWND hwnd;
    DWORD wFunc;
    DWORD wFlags;
    LPCTSTR pszSrcFile;
    DWORD dwSrcAttribs;
    LPCTSTR pszDestFile;
    DWORD dwDestAttribs;
} COPYHOOKINFO;


typedef struct
{
    DWORD bWantWebview;             // in: caller should return template
    DWORD dwOptions;                // out: SFVMQVI_ flags
    WCHAR szWebView[MAX_PATH];      // out: webview template path
} SFVM_VIEWINFO_DATA;

typedef struct
{
    DWORD dwOptions;                // out: SFVMQVI_ flags for the [in,wParam]uViewMode
} SFVM_VIEW_DATA;
// dwOptions control the state of corresponding [in,wParam]uViewMode:
#define SFVMQVI_NORMAL          0x0 // out: let defview decide what to do
#define SFVMQVI_INCLUDE         0x1 // out: force include
#define SFVMQVI_EXCLUDE         0x2 // out: force exclude


typedef struct
{
    FOLDERVIEWMODE    fvm;             // out: view mode
    BOOL              fGroupView;      // out: group view on/off
    UINT              uSortCol;        // out: sort by scid
    int               iSortDirection;  // out: ascending or descending sort
    FOLDERFLAGS       fFlags;          // out: folder flags to set (supports FWF_AUTOARRANGE)
} SFVM_DEFERRED_VIEW_SETTINGS;

typedef struct
{
    WCHAR szWebView[MAX_PATH];      // out: webview template path for [in,wParam]uViewMode
} SFVM_WEBVIEW_TEMPLATE_DATA;

typedef struct _SFVM_CUSTOMVIEWINFO_DATA
{
    COLORREF crCustomColors[CRID_COLORCOUNT];
    WCHAR    szIconAreaImage[MAX_PATH]; // Note: the old struct used INTERNET_MAX_URL_LENGTH, but we only use local cases so this isn't needed
} SFVM_CUSTOMVIEWINFO_DATA;

typedef struct
{
    DWORD dwLayout;         // out: SFVMWLV_ for [in,wParam]uViewMode
    IUnknown* punkPreview;  // out: IUnknown of preview control, if SFVMWVL_PREVIEW specified
} SFVM_WEBVIEW_LAYOUT_DATA;
// dwLayout:
#define SFVMWVL_NORMAL          0           // standard Web View format
#define SFVMWVL_PREVIEW         1           // "preview" Web View format
#define SFVMWVL_DETAILS         2           // standard Web View format with details expanded by default
#define SFVMWVL_ITEMS           0x00000000  // HACK (added for Whistler, remove in BlackComb): item Web View format
#define SFVMWVL_FILES           0x00010000  // HACK (added for Whistler, remove in BlackComb): file Web View format
#define SFVMWVL_NOPRINT         0x00020000  // HACK (added for Whistler, remove in BlackComb): unconditionally hide "Print this file" folder task
#define SFVMWVL_NOPUBLISH       0x00040000  // HACK (added for Whistler, remove in BlackComb): unconditionally hide "Publish this file" folder task
#define SFVMWVL_ORDINAL_MASK    0x0000ffff  // HACK (added for Whistler, remove in BlackComb): overload dwLayout for ordinals and flags
#define SFVMWVL_FLAGS_MASK      0xffff0000  // HACK (added for Whistler, remove in BlackComb): overload dwLayout for ordinals and flags


typedef struct
{
    DWORD           dwFlags;
    IUIElement*     pIntroText;         // can be NULL for no explanatory text
    IUIElement*     pSpecialTaskHeader; // can be NULL for no special task section
    IUIElement*     pFolderTaskHeader;  // if NULL, defview will provide a default folder task section
    IEnumIDList*    penumOtherPlaces;   // if NULL, defview will provide a default Other Places list
} SFVM_WEBVIEW_CONTENT_DATA;
// dwFlags:
#define SFVMWVF_BARRICADE       0x00000001   // this is a barricaded folder
#define SFVMWVF_ENUMTASKS       0x00000002   // Folder uses non-standard tasks.  Will enumerate.
#define SFVMWVF_NOMORETASKS     0x00000004   // No more tasks in enumeration.
#define SFVMWVF_SPECIALTASK     0x00000008   // Used in ENUMTASKSECTION_DATA.dwFlags.
#define SFVMWVF_CONTENTSCHANGE  0x00000010   // Refresh WV content when folder contents change.

typedef struct
{
    IEnumUICommand* penumSpecialTasks;  // can be NULL for no special task section
    IEnumUICommand* penumFolderTasks;   // if NULL, defview will provide a default folder task section
    DWORD           dwUpdateFlags;      // bitmask of the extra special events that we should listen to
} SFVM_WEBVIEW_TASKSECTION_DATA;
// dwUpdateFlags:
#define SFVMWVTSDF_CONTENTSCHANGE 0x00000001

typedef struct
{
    LPCWSTR pszThemeID; // [out] fill with a pointer a string who's lifetime is at least as long as your IShellFolderViewCB object.
} SFVM_WEBVIEW_THEME_DATA;


//
// To replace the standard webview tasks with a set enumerated by the view
// callback, the callback sets the SFVMWVF_ENUMTASKS flag in the dwFlags
// member of SFVM_WEBVIEWCONTENT_DATA.  This causes the shell to send
// SFVM_ENUMWEBVIEWTASKS repeatedly in place of SFVM_GETWEBVIEWCONTENT and
// SFVM_GETWEBVIEWTASKS.  Each time SFVM_ENUMWEBVIEWTASKS is sent,
// the view callback provides a header and task enumerator via a
// SFVM_WEBVIEW_ENUMTASKSECTION_DATA structure.  The message is sent to the
// view repeatedly until the handler sets the SFVMWVF_NOMORETASKS flag
// in SFVM_WEBVIEW_ENUMTASKSECTION_DATA.dwFlags.  The top-down display order
// of task sections is the same as the order in which they are provided by
// the view callback.
//
// The dwFlags member of SFVM_WEBVIEW_ENUMTASKSECTION_DATA supports
// the following values:
//      SFVMWVF_SPECIALTASK   - Use the 'special' task section style.
//                              If not set, use the 'normal' style.
//      SFVMWVF_NOMORETASKS   - Terminate the enumeration.
//
typedef struct
{
    DWORD           dwFlags;   // SFVMWVF_XXXX flags.  See above.
    IUIElement     *pHeader;
    IEnumUICommand *penumTasks;
    int             idBitmap;     // Valid only for SPECIALTASK sections.
    int             idWatermark;  // Valid only for SPECIALTASK sections.
} SFVM_WEBVIEW_ENUMTASKSECTION_DATA;


// WebView Task helper functions provided by shell32
// to help answer SFVM_GETWEBVIEWCONTENT and SFVM_GETWEBVIEWTASKS messages.
//
// The idea here being that you provide task implementations in the static
// functions with a pv parameter that gets passed through to your static functions
// so they can get back to your IShellFolderViewCB object.  These helper
// functions assume that all strings are resources to be loaded out of your DLL.
//
typedef HRESULT (*PFN_get_State)(IUnknown* pv,IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
typedef HRESULT (*PFN_Invoke)(IUnknown* pv,IShellItemArray *psiItemArray, IBindCtx *pbc);
typedef struct {
    const GUID* pguidCanonicalName;
    LPCWSTR pszDllName;
    DWORD   dwTitleIndexNoSelection;
    DWORD   dwTitleIndexFileSelected;
    DWORD   dwTitleIndexFolderSelected;
    DWORD   dwTitleIndexMultiSelected;
    DWORD   dwTooltipIndex;
    DWORD   dwIconIndex;
    PFN_get_State pfn_get_State;
    PFN_Invoke    pfn_Invoke;
} WVTASKITEM;

// Use for tasks that want to be displayed when something is selected, where the UI is independent of the selection
#define WVTI_ENTRY(g, d, t, p, i, s, k) {&(g), (d), (0), (t), (t), (t), (p), (i), (s), (k)}

// Use for tasks that want to be displayed when nothing is selected
#define WVTI_ENTRY_NOSELECTION(g, d, t, p, i, s, k) {&(g), (d), (t), 0, 0, 0, (p), (i), (s), (k)}

// Use for tasks that want to be displayed when a file is selected
#define WVTI_ENTRY_FILE(g, d, t, p, i, s, k) {&(g), (d), (0), (t), (0), (0), (p), (i), (s), (k)}

// Use for tasks that want to be displayed when something is selected, and you want different UI depending on the selection
// Use this one if you want to control the title, but the tooltip is constant:
#define WVTI_ENTRY_TITLE(g, d, t2, t3, t4, p, i, s, k) {&(g), (d), (0), (t2), (t3), (t4), (p), (i), (s), (k)}

// Use this one if you want the same text everywhere:
#define WVTI_ENTRY_ALL(g, d, t, p, i, s, k) {&(g), (d), (t), (t), (t), (t), (p), (i), (s), (k)}

// Use this one if you want to control everything:
#define WVTI_ENTRY_ALL_TITLE(g, d, t1, t2, t3, t4, p, i, s, k) {&(g), (d), (t1), (t2), (t3), (t4), (p), (i), (s), (k)}

// Use this one for a header:
#define WVTI_HEADER(d, t, p) {&(CLSID_NULL), (d), (t), (t), (t), (t), (p), 0, NULL, NULL}

// Use this one for a header that changes with the selection:
#define WVTI_HEADER_ENTRY(d, t1, t2, t3, t4, p) {&(CLSID_NULL), (d), (t1), (t2), (t3), (t4), (p), 0, NULL, NULL}

// Creates an IEnumUICommand over an array of WVTASKITEM structures.
// The enumerator/objects hold a ref on the pv param for the lifetime of the enumerator/objects.
// The pv param gets passed through to the static WVTASKITEM.pfn functions.
//
HRESULT Create_IEnumUICommand(IUnknown *pv, const WVTASKITEM* rgwvti, UINT cwvti, IEnumUICommand**ppenum);

// Creates an IUICommand out of a single WVTASKITEM, never calling the pfn functions
HRESULT Create_IUIElement(const WVTASKITEM* pwvti, IUIElement**ppuie);



// SFVM_GETNOTIFY: The shell will use the pidl returned from this message to synch
//                 change notifies.  Folders in Folder Shortcuts should return pidlTarget
//                 because that is where the change notifies are sent.
//
// DOC'ed for DOJ compliance:
#define SFVM_SELCHANGE             8    // idCmdFirst,nItem   SFVM_SELCHANGE_DATA*
#define SFVM_DRAWITEM              9    // idCmdFirst         DRAWITEMSTRUCT*
#define SFVM_MEASUREITEM          10    // idCmdFirst         MEASUREITEMSTRUCT*
#define SFVM_EXITMENULOOP         11    // -                  -
#define SFVM_PRERELEASE           12    // -                  -
#define SFVM_GETCCHMAX            13    // LPCITEMIDLIST      pcchMax
#define SFVM_FSNOTIFY             14    // LPCITEMIDLIST*     lEvent
// DOC'ed for DOJ compliance:
#define SFVM_WINDOWDESTROY        16    // hwnd               -
#define SFVM_REFRESH              17    // BOOL fPreOrPost    -                         NB: this may be called multiple times in a row
#define SFVM_SETFOCUS             18    // -                  -
#define SFVM_QUERYCOPYHOOK        20    // -                  -
#define SFVM_NOTIFYCOPYHOOK       21    // -                  COPYHOOKINFO*
// DOC'ed for DOJ compliance:
#define SFVM_INSERTITEM           29    // pidl               -
#define SFVM_DELETEITEM           30    // pidl               -
// DOC'ed for DOJ compliance:
#define SFVM_GETWORKINGDIR        33    // uMax               pszDir
#define SFVM_GETCOLSAVESTREAM     34    // flags              IStream **
#define SFVM_SELECTALL            35    // -                  -
// DOC'ed for DOJ compliance:
#define SFVM_SUPPORTSIDENTITY     37    // -                  -                         // NOT USED: must support IShellFolder2
#define SFVM_FOLDERISPARENT       38    // -                  pidlChild
// DOC'ed for DOJ compliance:
#define SFVM_GETVIEWS             40    // SHELLVIEWID*       IEnumSFVViews **
// DOC'ed for DOJ compliance:
#define SFVM_GETITEMIDLIST        42    // iItem              LPITMIDLIST*
#define SFVM_SETITEMIDLIST        43    // iItem              LPITEMIDLIST
#define SFVM_INDEXOFITEMIDLIST    44    // *iItem             LPITEMIDLIST
#define SFVM_ODFINDITEM           45    // *iItem             NM_FINDITEM*
#define SFVM_HWNDMAIN             46    //                    hwndMain
// DOC'ed for DOJ compliance:
#define SFVM_ARRANGE              50    // -                  lParamSort
#define SFVM_QUERYSTANDARDVIEWS   51    // -                  BOOL *                    // NOT USED: must use SFVM_GETVIEWDATA instead
#define SFVM_QUERYREUSEEXTVIEW    52    // -                  BOOL *                    // NOT USED
// DOC'ed for DOJ compliance:
#define SFVM_GETEMPTYTEXT         54    // cchMax             pszText
#define SFVM_GETITEMICONINDEX     55    // iItem              int *piIcon
#define SFVM_DONTCUSTOMIZE        56    // -                  BOOL *pbDontCustomize     // NOT USED
// DOC'ed for DOJ compliance:
#define SFVM_ISOWNERDATA          60    // ISOWNERDATA        BOOL *
#define SFVM_GETODRANGEOBJECT     61    // iWhich             ILVRange **
#define SFVM_ODCACHEHINT          62    // -                  NMLVCACHEHINT *
// DOC'ed for DOJ compliance:
#define SFVM_OVERRIDEITEMCOUNT    64    // -                  UINT*                     // NOT USED: allowed override of actual item count for sizing calculations
#define SFVM_GETHELPTEXTW         65    // idCmd,cchMax       pszText - unicode
#define SFVM_GETTOOLTIPTEXTW      66    // idCmd,cchMax       pszText - unicode
#define SFVM_GETIPERSISTHISTORY   67    //                    IPersistHistory **
#define SFVM_GETANIMATION         68    // HINSTANCE *        WCHAR *
#define SFVM_GETHELPTEXTA         69    // idCmd,cchMax       pszText - ansi
#define SFVM_GETTOOLTIPTEXTA      70    // idCmd,cchMax       pszText - ansi
// The below two messages are only used in ownder data case, i.e. when SFVM_ISOWNERDATA returns TRUE
#define SFVM_GETICONOVERLAY       71    // iItem              int iOverlayIndex
#define SFVM_SETICONOVERLAY       72    // iItem              int * piOverlayIndex
#define SFVM_ALTERDROPEFFECT      73    // DWORD*             IDataObject*
#define SFVM_DELAYWINDOWCREATE    74    // HWND               - posted version of SFVM_WINDOWCREATED, no params
#define SFVM_FORCEWEBVIEW         75    // BOOL*              -
#define SFVM_GETVIEWINFO          76    // fvm.uViewMode      SFVM_VIEWINFO_DATA*          // NOT USED: shipped in Whistler Beta 1 only, remove soon
#define SFVM_GETCUSTOMVIEWINFO    77    // -                  SFVM_CUSTOMVIEWINFO_DATA*
#define SFVM_FOLDERSETTINGSFLAGS  78    // -                  DWORD * (FWF_ flags)
#define SFVM_ENUMERATEDITEMS      79    // UINT celt          LPCITEMIDLIST* rgpidl      // fired once at view creation, before first SFVM_GETVIEWDATA SFVM_GETDEFERREDVIEWSETTINGS
#define SFVM_GETVIEWDATA          80    // fvm.uViewMode      SFVM_VIEW_DATA*
#define SFVM_GETWEBVIEW_TEMPLATE  81    // fvm.uViewMode      SFVM_WEBVIEW_TEMPLATE_DATA*  // NOTE: going away soon
#define SFVM_GETWEBVIEWLAYOUT     82    // fvm.uViewMode      SFVM_WEBVIEW_LAYOUT_DATA*
#define SFVM_GETWEBVIEWCONTENT    83    // -                  SFVM_WEBVIEW_CONTENT_DATA*
#define SFVM_GETWEBVIEWTASKS      84    // -                  SFVM_WEBVIEW_TASKSECTION_DATA*
#define SFVM_GETWEBVIEWTHEME      86    // -                  SFVM_WEBVIEW_THEME_DATA* // HACK for Whistler, will remove when DirectUI goes DLL
#define SFVM_SORTLISTDATA         87    // PFNLVCOMPARE       lParamSort
#define SFVM_GETWEBVIEWBARRICADE  88    // -                  Element* // HACK for Whistler, will remove when DirectUI goes DLL
#define SFVM_ENUMWEBVIEWTASKS     90    // -                  SFVM_WEBVIEW_ENUMTASKSECTION_DATA*
#define SFVM_SETEMPTYTEXT         91    // -                  pszText
#define SFVM_GETDEFERREDVIEWSETTINGS 92 // -                  SFVM_DEFERRED_VIEW_SETTINGS* // set the default view settings

// All of these macros are compatible with HANDLE_MSG in WINDOWSX.H

#define HANDLE_SFVM_MERGEMENU(pv, wP, lP, fn) \
    ((fn)((pv), (QCMINFO*)(lP)))

#define HANDLE_SFVM_INVOKECOMMAND(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP)))

#define HANDLE_SFVM_GETHELPTEXT(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (LPTSTR)(lP)))

#define HANDLE_SFVM_GETTOOLTIPTEXT(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (LPTSTR)(lP)))

#define HANDLE_SFVM_GETBUTTONINFO(pv, wP, lP, fn) \
    ((fn)((pv), (TBINFO*)(lP)))

#define HANDLE_SFVM_GETBUTTONS(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (TBBUTTON*)(lP)))

#define HANDLE_SFVM_INITMENUPOPUP(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (HMENU)(lP)))

#define HANDLE_SFVM_SELCHANGE(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(wP), HIWORD(wP), (SFVM_SELCHANGE_DATA*)(lP)))

#define HANDLE_SFVM_DRAWITEM(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (DRAWITEMSTRUCT*)(lP)))

#define HANDLE_SFVM_MEASUREITEM(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (MEASUREITEMSTRUCT*)(lP)))

#define HANDLE_SFVM_EXITMENULOOP(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_PRERELEASE(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_GETCCHMAX(pv, wP, lP, fn) \
    ((fn)((pv), (LPCITEMIDLIST)(wP), (UINT*)(lP)))

#define HANDLE_SFVM_FSNOTIFY(pv, wP, lP, fn) \
    ((fn)((pv), (LPCITEMIDLIST*)(wP), (lP)))

#define HANDLE_SFVM_WINDOWCREATED(pv, wP, lP, fn) \
    ((fn)((pv), (HWND)(wP)))

#define HANDLE_SFVM_WINDOWDESTROY(pv, wP, lP, fn) \
    ((fn)((pv), (HWND)(wP)))

#define HANDLE_SFVM_REFRESH(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL) wP))

#define HANDLE_SFVM_SETFOCUS(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_QUERYCOPYHOOK(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_NOTIFYCOPYHOOK(pv, wP, lP, fn) \
    ((fn)((pv), (COPYHOOKINFO*)(lP)))

#define HANDLE_SFVM_GETDETAILSOF(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (DETAILSINFO*)(lP)))

#define HANDLE_SFVM_COLUMNCLICK(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP)))

#define HANDLE_SFVM_QUERYFSNOTIFY(pv, wP, lP, fn) \
    ((fn)((pv), (SHChangeNotifyEntry*)(lP)))

#define HANDLE_SFVM_DEFITEMCOUNT(pv, wP, lP, fn) \
    ((fn)((pv), (UINT*)(lP)))

#define HANDLE_SFVM_OVERRIDEITEMCOUNT(pv, wP, lP, fn) \
    ((fn)((pv), (UINT*)(lP)))

#define HANDLE_SFVM_DEFVIEWMODE(pv, wP, lP, fn) \
    ((fn)((pv), (FOLDERVIEWMODE*)(lP)))

#define HANDLE_SFVM_UNMERGEMENU(pv, wP, lP, fn) \
    ((fn)((pv), (HMENU)(lP)))

#define HANDLE_SFVM_INSERTITEM(pv, wP, lP, fn) \
    ((fn)((pv), (LPCITEMIDLIST)(lP)))

#define HANDLE_SFVM_DELETEITEM(pv, wP, lP, fn) \
    ((fn)((pv), (LPCITEMIDLIST)(lP)))

#define HANDLE_SFVM_UPDATESTATUSBAR(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL)(wP)))

#define HANDLE_SFVM_BACKGROUNDENUM(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_GETWORKINGDIR(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (LPTSTR)(lP)))

#define HANDLE_SFVM_GETCOLSAVESTREAM(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (IStream**)(lP)))

#define HANDLE_SFVM_SELECTALL(pv, wP, lP, fn) \
    ((fn)(pv))

#define HANDLE_SFVM_DIDDRAGDROP(pv, wP, lP, fn) \
    ((fn)((pv), (DWORD)(wP), (IDataObject*)(lP)))

#define HANDLE_SFVM_SUPPORTSIDENTITY(pv, wp, lP, fn) \
    ((fn)(pv))    /* Only 1 parameter */

#define HANDLE_SFVM_HWNDMAIN(pv, wP, lP, fn) \
    ((fn)((pv), (HWND)(lP)))

#define HANDLE_SFVM_GETNOTIFY(pv, wP, lP, fn) \
    ((fn)((pv), (LPITEMIDLIST*)(wP), (LONG*)(lP)))

#define HANDLE_SFVM_SETISFV(pv, wP, lP, fn) \
    ((fn)((pv), (IShellFolderView*)(lP)))

#define HANDLE_SFVM_GETVIEWS(pv, wP, lP, fn) \
    ((fn)((pv), (SHELLVIEWID*)(wP), (IEnumSFVViews**)(lP)))

#define HANDLE_SFVM_THISIDLIST(pv, wP, lP, fn) \
    ((fn)((pv), (LPITEMIDLIST*)(lP)))

#define HANDLE_SFVM_GETITEMIDLIST(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (LPITEMIDLIST*)(lP)))

#define HANDLE_SFVM_SETITEMIDLIST(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (LPITEMIDLIST)(lP)))

#define HANDLE_SFVM_INDEXOFITEMIDLIST(pv, wP, lP, fn) \
    ((fn)((pv), (int*)(wP), (LPITEMIDLIST)(lP)))

#define HANDLE_SFVM_ODFINDITEM(pv, wP, lP, fn) \
    ((fn)((pv), (int*)(wP), (NM_FINDITEM*)(lP)))

#define HANDLE_SFVM_ADDPROPERTYPAGES(pv, wP, lP, fn) \
    ((fn)((pv), (SFVM_PROPPAGE_DATA *)(lP)))

#define HANDLE_SFVM_FOLDERISPARENT(pv, wP, lP, fn) \
    ((fn)((pv), (LPITEMIDLIST)(lP)))

#define HANDLE_SFVM_ARRANGE(pv, wP, lP, fn) \
    ((fn)((pv), (LPARAM)(lP)))

#define HANDLE_SFVM_QUERYSTANDARDVIEWS(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL*)(lP)))

#define HANDLE_SFVM_QUERYREUSEEXTVIEW(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL*)(lP)))

#define HANDLE_SFVM_GETEMPTYTEXT(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (LPTSTR)(lP)))

#define HANDLE_SFVM_GETITEMICONINDEX(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (int*)(lP)))

#define HANDLE_SFVM_SIZE(pv, wP, lP, fn) \
    ((fn)((pv), LOWORD(lP), HIWORD(lP)))

#define HANDLE_SFVM_GETZONE(pv, wP, lP, fn) \
    ((fn)((pv), (DWORD *)(lP)))

#define HANDLE_SFVM_GETPANE(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (DWORD *)(lP)))

#define HANDLE_SFVM_ISOWNERDATA(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL*)(lP)))

#define HANDLE_SFVM_GETODRANGEOBJECT(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (ILVRange **)(lP)))

#define HANDLE_SFVM_ODCACHEHINT(pv, wP, lP, fn) \
    ((fn)((pv), (NMLVCACHEHINT*)(lP)))

#define HANDLE_SFVM_GETHELPTOPIC(pv, wP, lP, fn) \
    ((fn)((pv), (SFVM_HELPTOPIC_DATA *)(lP)))

#define HANDLE_SFVM_GETIPERSISTHISTORY(pv, wP, lP, fn) \
    ((fn)((pv), (IPersistHistory **)(lP)))

#define HANDLE_SFVM_SETICONOVERLAY(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (int)(lP)))

#define HANDLE_SFVM_GETICONOVERLAY(pv, wP, lP, fn) \
    ((fn)((pv), (wP), (int *)(lP)))

#define HANDLE_SFVM_ALTERDROPEFFECT(pv, wP, lP, fn) \
    ((fn)((pv), (DWORD *)(wP), (IDataObject *)(lP)))

#define HANDLE_SFVM_DELAYWINDOWCREATE(pv, wP, lP, fn) \
    ((fn)((pv), (HWND)(wP)))

#define HANDLE_SFVM_FORCEWEBVIEW(pv, wP, lP, fn) \
    ((fn)((pv), (BOOL*)(wP)))

#define HANDLE_SFVM_GETVIEWINFO(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (SFVM_VIEWINFO_DATA*)lP))

#define HANDLE_SFVM_GETCUSTOMVIEWINFO(pv, wP, lP, fn) \
    ((fn)((pv), (SFVM_CUSTOMVIEWINFO_DATA*)(lP)))

#define HANDLE_SFVM_FOLDERSETTINGSFLAGS(pv, wP, lP, fn) \
    ((fn)((pv), (DWORD*)(lP)))

#define HANDLE_SFVM_ENUMERATEDITEMS(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (LPCITEMIDLIST*)(lP)))

#define HANDLE_SFVM_GETVIEWDATA(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (SFVM_VIEW_DATA*)lP))

#define HANDLE_SFVM_GETWEBVIEW_TEMPLATE(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (SFVM_WEBVIEW_TEMPLATE_DATA*)(lP)))

#define HANDLE_SFVM_GETWEBVIEWLAYOUT(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (SFVM_WEBVIEW_LAYOUT_DATA*)(lP)))

#define HANDLE_SFVM_GETWEBVIEWCONTENT(pv, wP, lP, fn) \
    ((fn)((pv), (SFVM_WEBVIEW_CONTENT_DATA*)(lP)))

#define HANDLE_SFVM_GETWEBVIEWTASKS(pv, wP, lP, fn) \
    ((fn)((pv), (SFVM_WEBVIEW_TASKSECTION_DATA*)(lP)))

#define HANDLE_SFVM_ENUMWEBVIEWTASKS(pv, wP, lP, fn) \
    ((fn)((pv), (SFVM_WEBVIEW_ENUMTASKSECTION_DATA*)(lP)))

#define HANDLE_SFVM_GETWEBVIEWTHEME(pv, wP, lP, fn) \
    ((fn)((pv), (SFVM_WEBVIEW_THEME_DATA*)(lP)))

#define HANDLE_SFVM_SORTLISTDATA(pv, wP, lP, fn) \
    ((fn)((pv), (PFNLVCOMPARE)(wP), (lP)))

#define HANDLE_SFVM_GETDEFERREDVIEWSETTINGS(pv, wP, lP, fn) \
    ((fn)((pv), (SFVM_DEFERRED_VIEW_SETTINGS*)(lP)))

#define HANDLE_SFVM_SETEMPTYTEXT(pv, wP, lP, fn) \
    ((fn)((pv), (UINT)(wP), (LPCTSTR)(lP)))

//
// Return values for SFVM_GETICONOVERLAY:
// If the icon overlay is not set and you want the shell to set it for you.
// return SFVOVERLAY_UNSET. This will cause the shell to retrieve the overlay and
// send SFVM_SETICONOVERLAY.
// If there is no overlay for this item at all, the correct return value is
// SFVOVERLAY_DEFAULT
// If you return SFVOVERLAY_UNSET every time for SFVM_GETICONOVERLAY, the
// shell will keep setting it indefinitely, so there is a danger of infinite loop
//
#define SFV_ICONOVERLAY_DEFAULT    0
#define SFV_ICONOVERLAY_UNSET      0xFFFFFFFF

//
// What you can return from SFVM_UPDATESTATUSBAR:
//
//  E_NOTIMPL - Message not handled; DefView should manage status bar
//
// Otherwise, update the status bar yourself and return a bitmask of the
// following codes indicating what you want DefView to do for you.
//
#define SFVUSB_HANDLED      0x0000  // Client handled completely - DefView does nothing
#define SFVUSB_INITED       0x0001  // Client initialized parts  - DefView will set text
#define SFVUSB_ALL          0x0001

// IShellFolderView interface for getting the SFV to do things
//

typedef struct _ITEMSPACING
{
    int cxSmall;
    int cySmall;
    int cxLarge;
    int cyLarge;
} ITEMSPACING;


// Define OPtions for SetObjectCount
#define SFVSOC_INVALIDATE_ALL   0x00000001  // Assumed to reset only what is neccessary...
#define SFVSOC_NOSCROLL         LVSICF_NOSCROLL

// defines for IShellFolderView::SelectItems()
#define SFVS_SELECT_NONE        0x0 // unselect all
#define SFVS_SELECT_ALLITEMS    0x1 // select all
#define SFVS_SELECT_INVERT      0x2 // Inver the selection

// defines for IShellFolderView::QuerySupport()
// allows a view to be queried to see if it supports various operations (useful for
// enabling menu items)
#define SFVQS_AUTO_ARRANGE      0x0001
#define SFVQS_ARRANGE_GRID      0x0002
#define SFVQS_SELECT_ALL        0x0004
#define SFVQS_SELECT_NONE       0x0008
#define SFVQS_SELECT_INVERT     0x0010

#undef  INTERFACE
#define INTERFACE   IShellFolderView

DECLARE_INTERFACE_(IShellFolderView, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolderView methods ***
    STDMETHOD(Rearrange) (THIS_ LPARAM lParamSort) PURE;
    STDMETHOD(GetArrangeParam) (THIS_ LPARAM *plParamSort) PURE;
    STDMETHOD(ArrangeGrid) (THIS) PURE;
    STDMETHOD(AutoArrange) (THIS) PURE;
    STDMETHOD(GetAutoArrange) (THIS) PURE;
    STDMETHOD(AddObject) (THIS_ LPITEMIDLIST pidl, UINT *puItem) PURE;
    STDMETHOD(GetObject) (THIS_ LPITEMIDLIST *ppidl, UINT uItem) PURE;
    STDMETHOD(RemoveObject) (THIS_ LPITEMIDLIST pidl, UINT *puItem) PURE;
    STDMETHOD(GetObjectCount) (THIS_ UINT *puCount) PURE;
    STDMETHOD(SetObjectCount) (THIS_ UINT uCount, UINT dwFlags) PURE;
    STDMETHOD(UpdateObject) (THIS_ LPITEMIDLIST pidlOld, LPITEMIDLIST pidlNew, UINT *puItem) PURE;
    STDMETHOD(RefreshObject) (THIS_ LPITEMIDLIST pidl, UINT *puItem) PURE;
    STDMETHOD(SetRedraw) (THIS_ BOOL bRedraw) PURE;
    STDMETHOD(GetSelectedCount) (THIS_ UINT *puSelected) PURE;
    STDMETHOD(GetSelectedObjects) (THIS_ LPCITEMIDLIST **pppidl, UINT *puItems) PURE;
    STDMETHOD(IsDropOnSource) (THIS_ IDropTarget *pDropTarget) PURE;
    STDMETHOD(GetDragPoint) (THIS_ POINT *ppt) PURE;
    STDMETHOD(GetDropPoint) (THIS_ POINT *ppt) PURE;
    STDMETHOD(MoveIcons) (THIS_ IDataObject *pDataObject) PURE;
    STDMETHOD(SetItemPos) (THIS_ LPCITEMIDLIST pidl, POINT *ppt) PURE;
    STDMETHOD(IsBkDropTarget) (THIS_ IDropTarget *pDropTarget) PURE;
    STDMETHOD(SetClipboard) (THIS_ BOOL bMove) PURE;
    STDMETHOD(SetPoints) (THIS_ IDataObject *pDataObject) PURE;
    STDMETHOD(GetItemSpacing) (THIS_ ITEMSPACING *pSpacing) PURE;
    STDMETHOD(SetCallback) (THIS_ IShellFolderViewCB* pNewCB, IShellFolderViewCB** ppOldCB) PURE;
    STDMETHOD(Select) ( THIS_  UINT dwFlags ) PURE;
    STDMETHOD(QuerySupport) (THIS_ UINT * pdwSupport ) PURE;
    STDMETHOD(SetAutomationObject)(THIS_ IDispatch* pdisp) PURE;
} ;

// DOC'ed for DOJ compliance:
#define SHCreateShellFolderViewORD      256

SHSTDAPI_(IShellFolderViewCB*) SHGetShellFolderViewCB(HWND hwndMain);

#define SHGetShellFolderViewCBORD   257

//===========================================================================
// Defview APIs to make name space author lives somewhat easier

// DOC'ed for DOJ compliance

// structure for lParam of DFM_INFOKECOMMANDEX
typedef struct
{
    DWORD  cbSize;

    DWORD  fMask;   // CMIC_MASK_ values for the invoke
    LPARAM lParam;  // same as lParam of DFM_INFOKECOMMAND
    UINT idCmdFirst;
    UINT idDefMax;
    LPCMINVOKECOMMANDINFO pici; // the whole thing so you can re-invoke on a child
} DFMICS, *PDFMICS;

// Note on context menus ranges:
//  Standard Items // DFM_MERGECONTEXTMENU, context menu extensions, DFM_MERGECONTEXTMENU_TOP
//  Separator
//  View Items   // context menu extensions can get here
//  Separator
//  (defcm S_FALSE "default" items, if applicable)
//  Separator
//  Folder Items // context menu extensions can get here
//  Separator
//  Bottom Items // DFM_MERGECONTEXTMENU_BOTTOM

// DOC'ed for DOJ compliance
#define DFM_ADDREF                   3      // 0            0
#define DFM_RELEASE                  4      // 0            0
#define DFM_GETHELPTEXT              5      // idCmd,cchMax pszText -Ansi
#define DFM_WM_MEASUREITEM           6      // ---from the message---
#define DFM_WM_DRAWITEM              7      // ---from the message---
#define DFM_WM_INITMENUPOPUP         8      // ---from the message---
#define DFM_VALIDATECMD              9      // idCmd        0
#define DFM_MERGECONTEXTMENU_TOP     10     // uFlags       LPQCMINFO
#define DFM_GETHELPTEXTW             11     // idCmd,cchMax pszText -Unicode
#define DFM_INVOKECOMMANDEX          12     // idCmd        PDFMICS
#define DFM_MAPCOMMANDNAME           13     // idCmd *      pszCommandName
#define DFM_GETVERBW                 15     // idCmd,cchMax pszText -Unicode
#define DFM_GETVERBA                 16     // idCmd,cchMax pszText -Ansi
#define DFM_MERGECONTEXTMENU_BOTTOM  17     // uFlags       LPQCMINFO


#define DFM_CMD_DELETE          ((UINT)-1)
#define DFM_CMD_MOVE            ((UINT)-2)
#define DFM_CMD_COPY            ((UINT)-3)
#define DFM_CMD_LINK            ((UINT)-4)
#define DFM_CMD_NEWFOLDER       ((UINT)-6)
#define DFM_CMD_PASTE           ((UINT)-7)
#define DFM_CMD_VIEWLIST        ((UINT)-8)
#define DFM_CMD_VIEWDETAILS     ((UINT)-9)
#define DFM_CMD_PASTELINK       ((UINT)-10)
#define DFM_CMD_PASTESPECIAL    ((UINT)-11)
#define DFM_CMD_MODALPROP       ((UINT)-12)
#define DFM_CMD_RENAME          ((UINT)-13)

SHSTDAPI CDefFolderMenu_Create(LPCITEMIDLIST pidlFolder,
                             HWND hwndOwner,
                             UINT cidl, LPCITEMIDLIST * apidl,
                             IShellFolder *psf,
                             LPFNDFMCALLBACK lpfn,
                             HKEY hkeyProgID, HKEY hkeyBaseProgID,
                             IContextMenu ** ppcm);


SHSTDAPI_(void) CDefFolderMenu_MergeMenu(HINSTANCE hinst, UINT idMainMerge, UINT idPopupMerge,
        LPQCMINFO pqcm);
STDAPI_(void) Def_InitFileCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst,
        BOOL bContext);
STDAPI_(void) Def_InitEditCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst,
        IDropTarget *pdtgt, UINT fContext);

// indeces in bitmap strip
#define VIEW_MOVETO     24
#define VIEW_COPYTO     25
#define VIEW_OPTIONS    26

//===========================================================================
// Default IShellView for IShellFolder
//===========================================================================

// Menu ID's
#define SFVIDM_FIRST            (FCIDM_SHVIEWLAST-0x0fff)
#define SFVIDM_LAST             (FCIDM_SHVIEWLAST)

// Hardcoded message values => This range can be used for messages that we
// pass from shdoc401 to shell32
#define SFVIDM_HARDCODED_FIRST  (SFVIDM_LAST-0x0010)
#define SFVIDM_HARDCODED_LAST   (SFVIDM_LAST)

#define SFVIDM_MISC_SETWEBVIEW  (SFVIDM_HARDCODED_FIRST)

// Popup menu ID's used in merging menus
#define SFVIDM_MENU_ARRANGE     (SFVIDM_FIRST + 0x0001)
#define SFVIDM_MENU_VIEW        (SFVIDM_FIRST + 0x0002)
#define SFVIDM_MENU_SELECT      (SFVIDM_FIRST + 0x0003)

#define SHARED_FILE_FIRST               0x0010
#define SHARED_FILE_LINK                (SHARED_FILE_FIRST + 0x0000)
#define SHARED_FILE_DELETE              (SHARED_FILE_FIRST + 0x0001)
#define SHARED_FILE_RENAME              (SHARED_FILE_FIRST + 0x0002)
#define SHARED_FILE_PROPERTIES          (SHARED_FILE_FIRST + 0x0003)

#define SHARED_EDIT_FIRST               0x0018
#define SHARED_EDIT_CUT                 (SHARED_EDIT_FIRST + 0x0000)
#define SHARED_EDIT_COPY                (SHARED_EDIT_FIRST + 0x0001)
#define SHARED_EDIT_PASTE               (SHARED_EDIT_FIRST + 0x0002)
#define SHARED_EDIT_UNDO                (SHARED_EDIT_FIRST + 0x0003)
#define SHARED_EDIT_PASTELINK           (SHARED_EDIT_FIRST + 0x0004)
#define SHARED_EDIT_PASTESPECIAL        (SHARED_EDIT_FIRST + 0x0005)
#define SHARED_EDIT_COPYTO              (SHARED_EDIT_FIRST + 0x0006)
#define SHARED_EDIT_MOVETO              (SHARED_EDIT_FIRST + 0x0007)

#define SFVIDM_FILE_FIRST               (SFVIDM_FIRST + SHARED_FILE_FIRST)
#define SFVIDM_FILE_LINK                (SFVIDM_FIRST + SHARED_FILE_LINK)
#define SFVIDM_FILE_DELETE              (SFVIDM_FIRST + SHARED_FILE_DELETE)
#define SFVIDM_FILE_RENAME              (SFVIDM_FIRST + SHARED_FILE_RENAME)
#define SFVIDM_FILE_PROPERTIES          (SFVIDM_FIRST + SHARED_FILE_PROPERTIES)

#define SFVIDM_EDIT_FIRST               (SFVIDM_FIRST + SHARED_EDIT_FIRST)
#define SFVIDM_EDIT_CUT                 (SFVIDM_FIRST + SHARED_EDIT_CUT)
#define SFVIDM_EDIT_COPY                (SFVIDM_FIRST + SHARED_EDIT_COPY)
#define SFVIDM_EDIT_PASTE               (SFVIDM_FIRST + SHARED_EDIT_PASTE)
#define SFVIDM_EDIT_UNDO                (SFVIDM_FIRST + SHARED_EDIT_UNDO)
#define SFVIDM_EDIT_PASTELINK           (SFVIDM_FIRST + SHARED_EDIT_PASTELINK)
#define SFVIDM_EDIT_PASTESPECIAL        (SFVIDM_FIRST + SHARED_EDIT_PASTESPECIAL)
#define SFVIDM_EDIT_COPYTO              (SFVIDM_FIRST + SHARED_EDIT_COPYTO)
#define SFVIDM_EDIT_MOVETO              (SFVIDM_FIRST + SHARED_EDIT_MOVETO)

#define SFVIDM_SELECT_FIRST             (SFVIDM_FIRST + 0x0020)
#define SFVIDM_SELECT_ALL               (SFVIDM_SELECT_FIRST + 0x0001)
#define SFVIDM_SELECT_INVERT            (SFVIDM_SELECT_FIRST + 0x0002)
#define SFVIDM_DESELECT_ALL             (SFVIDM_SELECT_FIRST + 0x0003)

#define SFVIDM_VIEW_FIRST               (SFVIDM_FIRST + 0x0028)
#define SFVIDM_VIEW_FIRSTVIEW           (SFVIDM_VIEW_FIRST + 1)
#define SFVIDM_VIEW_ICON                (SFVIDM_VIEW_FIRST + 1)
#define SFVIDM_VIEW_SMALLICON           (SFVIDM_VIEW_FIRST + 2)
#define SFVIDM_VIEW_LIST                (SFVIDM_VIEW_FIRST + 3)
#define SFVIDM_VIEW_DETAILS             (SFVIDM_VIEW_FIRST + 4)
#define SFVIDM_VIEW_THUMBNAIL           (SFVIDM_VIEW_FIRST + 5)
#define SFVIDM_VIEW_TILE                (SFVIDM_VIEW_FIRST + 6)
#define SFVIDM_VIEW_THUMBSTRIP          (SFVIDM_VIEW_FIRST + 7)
#define SFVIDM_VIEW_LASTVIEW            (SFVIDM_VIEW_FIRST + 7)

// TileView
// One more for safe keeping
#define SFVIDM_VIEW_OPTIONS             (SFVIDM_VIEW_FIRST + 0x0008)
#define SFVIDM_VIEW_VIEWMENU            (SFVIDM_VIEW_FIRST + 0x0009)
#define SFVIDM_VIEW_CUSTOMWIZARD        (SFVIDM_VIEW_FIRST + 0x000A)
#define SFVIDM_VIEW_COLSETTINGS         (SFVIDM_VIEW_FIRST + 0x000B)

#define SFVIDM_VIEW_EXTFIRST            (SFVIDM_VIEW_FIRST + 0x000C)
#define SFVIDM_VIEW_EXTLAST             (SFVIDM_VIEW_EXTFIRST + 0x0017)
#define SFVIDM_VIEW_SVEXTFIRST          (SFVIDM_VIEW_EXTFIRST)
#define SFVIDM_VIEW_SVEXTLAST           (SFVIDM_VIEW_EXTFIRST + 0x000F)
#define SFVIDM_VIEW_EXTENDEDFIRST       (SFVIDM_VIEW_EXTFIRST + 0x0010)
#define SFVIDM_VIEW_EXTENDEDLAST        (SFVIDM_VIEW_EXTLAST)
// #define SFVIDM_VIEW_THUMBNAIL           (SFVIDM_VIEW_FIRST + 0x0021) defined above


#define SFVIDM_ARRANGE_FIRST            (SFVIDM_FIRST + 0x0050)
#define SFVIDM_ARRANGE_AUTO             (SFVIDM_ARRANGE_FIRST + 0x0001)
#define SFVIDM_ARRANGE_GRID             (SFVIDM_ARRANGE_FIRST + 0x0002)
#define SFVIDM_ARRANGE_DISPLAYICONS     (SFVIDM_ARRANGE_FIRST + 0x0003)
#define SFVIDM_ARRANGE_AUTOGRID         (SFVIDM_ARRANGE_FIRST + 0x0004)

#define SFVIDM_TOOL_FIRST               (SFVIDM_FIRST + 0x0060)
#define SFVIDM_TOOL_CONNECT             (SFVIDM_TOOL_FIRST + 0x0001)
#define SFVIDM_TOOL_DISCONNECT          (SFVIDM_TOOL_FIRST + 0x0002)
#define SFVIDM_TOOL_OPTIONS             (SFVIDM_TOOL_FIRST + 0x0003)
#define SFVIDM_DEBUG_WEBVIEW            (SFVIDM_TOOL_FIRST + 0x0004)

#define SFVIDM_HELP_FIRST               (SFVIDM_FIRST + 0x0070)
#define SFVIDM_HELP_TOPIC               (SFVIDM_HELP_FIRST + 0x0001)

#define SFVIDM_MISC_FIRST               (SFVIDM_FIRST + 0x0100)
#define SFVIDM_MISC_REFRESH             (SFVIDM_MISC_FIRST + 0x0003)
#define SFVIDM_MISC_HARDREFRESH         (SFVIDM_MISC_FIRST + 0x0004)

// Range for the client's additional menus
#define SFVIDM_CLIENT_FIRST             (SFVIDM_FIRST + 0x0200)
#define SFVIDM_CLIENT_LAST              (SFVIDM_FIRST + 0x02ff)

// ---- SFVIDM_UNUSED_FIRST             (SFVIDM_FIRST + 0x0300)

#define SFVIDM_DESKTOP_FIRST            (SFVIDM_FIRST + 0x0400)
#define SFVIDM_DESKTOPHTML_WEBCONTENT   (SFVIDM_DESKTOP_FIRST + 0x0001)
#define SFVIDM_DESKTOPHTML_ICONS        (SFVIDM_DESKTOP_FIRST + 0x0002)
#define SFVIDM_DESKTOPHTML_LOCK         (SFVIDM_DESKTOP_FIRST + 0x0003)
#define SFVIDM_DESKTOPHTML_WIZARD       (SFVIDM_DESKTOP_FIRST + 0x0004)
#define SFVIDM_DESKTOP_LAST             (SFVIDM_FIRST + 0x04ff)

#define SFVIDM_COLUMN_FIRST             (SFVIDM_FIRST + 0x0500)
#define SFVIDM_COLUMN_LAST              (SFVIDM_FIRST + 0x05ff)

#define SFVIDM_GROUPSEP                 (SFVIDM_FIRST + 0x0600)
#define SFVIDM_GROUPBY                  (SFVIDM_FIRST + 0x0601)
#define SFVIDM_GROUPSFIRST              (SFVIDM_FIRST + 0x0602)
#define SFVIDM_GROUPSLAST               (SFVIDM_FIRST + 0x067f)
#define SFVIDM_GROUPSEXTENDEDFIRST      (SFVIDM_FIRST + 0x0680)
#define SFVIDM_GROUPSEXTENDEDLAST       (SFVIDM_FIRST + 0x06ff)


// Range for context menu id's
#define SFVIDM_CONTEXT_FIRST            (SFVIDM_FIRST + 0x0800)
#define SFVIDM_CONTEXT_LAST             (SFVIDM_FIRST + 0x0900)
#define SFVIDM_BACK_CONTEXT_FIRST       (SFVIDM_FIRST + 0x0901)
#define SFVIDM_BACK_CONTEXT_LAST        (SFVIDM_FIRST + 0x09ff)


// DOC'ed for DOJ compliance:

typedef COPYHOOKINFO *LPCOPYHOOKINFO;


//                              uMsg                     wParam         lParam
#define DVM_MERGEMENU           SFVM_MERGEMENU        // uFlags             LPQCMINFO
#define DVM_INVOKECOMMAND       SFVM_INVOKECOMMAND    // idCmd              0
#define DVM_GETHELPTEXT         SFVM_GETHELPTEXT      // idCmd,cchMax       pszText - Ansi
#define DVM_GETTOOLTIPTEXT      SFVM_GETTOOLTIPTEXT   // idCmd,cchMax       pszText
#define DVM_GETBUTTONINFO       SFVM_GETBUTTONINFO    // 0                  LPTBINFO
#define DVM_GETBUTTONS          SFVM_GETBUTTONS       // idCmdFirst,cbtnMax LPTBBUTTON
#define DVM_INITMENUPOPUP       SFVM_INITMENUPOPUP    // idCmdFirst,nIndex  hmenu
#define DVM_SELCHANGE           SFVM_SELCHANGE        // idCmdFirst,nItem   PDVSELCHANGEINFO
#define DVM_DRAWITEM            SFVM_DRAWITEM         // idCmdFirst         pdis
#define DVM_MEASUREITEM         SFVM_MEASUREITEM      // idCmdFirst         pmis
#define DVM_EXITMENULOOP        SFVM_EXITMENULOOP     // -                  -
#define DVM_RELEASE             SFVM_PRERELEASE       // -                  lSelChangeInfo (ShellFolder private)
#define DVM_GETCCHMAX           SFVM_GETCCHMAX        // pidlItem           pcchMax
#define DVM_FSNOTIFY            SFVM_FSNOTIFY         // LPITEMIDLIST*      lEvent
#define DVM_WINDOWCREATED       SFVM_WINDOWCREATED    // hwnd               PDVSELCHANGEINFO
#define DVM_WINDOWDESTROY       SFVM_WINDOWDESTROY    // hwnd               PDVSELCHANGEINFO
#define DVM_REFRESH             SFVM_REFRESH          // -                  lSelChangeInfo
#define DVM_SETFOCUS            SFVM_SETFOCUS         // -                  lSelChangeInfo
#define DVM_KILLFOCUS           19                    // unused
#define DVM_QUERYCOPYHOOK       SFVM_QUERYCOPYHOOK    // -                  -
#define DVM_NOTIFYCOPYHOOK      SFVM_NOTIFYCOPYHOOK   // -                  LPCOPYHOOKINFO
#define DVM_NOTIFY              SFVM_NOTIFY           // idFrom             LPNOTIFY
#define DVM_GETDETAILSOF        SFVM_GETDETAILSOF     // iColumn            PDETAILSINFO
#define DVM_COLUMNCLICK         SFVM_COLUMNCLICK      // iColumn            -
#define DVM_QUERYFSNOTIFY       SFVM_QUERYFSNOTIFY    // -                  FSNotifyEntry *
#define DVM_DEFITEMCOUNT        SFVM_DEFITEMCOUNT     // -                  PINT
#define DVM_DEFVIEWMODE         SFVM_DEFVIEWMODE      // -                  PFOLDERVIEWMODE
#define DVM_UNMERGEMENU         SFVM_UNMERGEMENU      // uFlags
#define DVM_INSERTITEM          SFVM_INSERTITEM       // pidl               PDVSELCHANGEINFO
#define DVM_DELETEITEM          SFVM_DELETEITEM       // pidl               PDVSELCHANGEINFO
#define DVM_UPDATESTATUSBAR     SFVM_UPDATESTATUSBAR  // -                  lSelChangeInfo
#define DVM_BACKGROUNDENUM      SFVM_BACKGROUNDENUM   //
#define DVM_GETWORKINGDIR       SFVM_GETWORKINGDIR    //
#define DVM_GETCOLSAVESTREAM    SFVM_GETCOLSAVESTREAM // flags              IStream **
#define DVM_SELECTALL           SFVM_SELECTALL        //                    lSelChangeInfo
#define DVM_DIDDRAGDROP         SFVM_DIDDRAGDROP      // dwEffect           IDataObject *
#define DVM_SUPPORTSIDENTIFY    SFVM_SUPPORTSIDENTITY // -                  -
#define DVM_FOLDERISPARENT      SFVM_FOLDERISPARENT   // -                  pidlChild

// max length for guid strings
#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

typedef struct _DVSELCHANGEINFO {
    UINT uOldState;
    UINT uNewState;
    LPARAM lParamItem;
    LPARAM* plParam;
} DVSELCHANGEINFO, *PDVSELCHANGEINFO;

// DOC'ed for DOJ compliance:
// DOC'ed for DOJ Compliance

// Get the last sorting parameter given to FolderView
#define SFVM_GETARRANGEPARAM    0x00000002
#define ShellFolderView_GetArrangeParam(_hwnd) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETARRANGEPARAM, 0L)

// DOC'ed for DOJ Compliance

// Gets the count of objects in the view
#define SFVM_GETOBJECTCOUNT         0x00000004
#define ShellFolderView_GetObjectCount(_hwnd) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETOBJECTCOUNT, (LPARAM)0)

// Returns a pointer to the Idlist associated with the specified index
// Returns NULL if at end of list.
#define SFVM_GETOBJECT         0x00000005
#define ShellFolderView_GetObject(_hwnd, _iObject) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETOBJECT, _iObject)

// DOC'ed for DOJ Compliance
// Sets the redraw mode for the window that is displaying the information
#define SFVM_SETREDRAW           0x00000008
#define ShellFolderView_SetRedraw(_hwnd, fRedraw) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_SETREDRAW, (LPARAM)fRedraw)

// DOC'ed for DOJ Compliance

// Checks if the current drop is on the view window
//     lparam is unused
//     return value is TRUE if the current drop is upon the background of the
//         view window, FALSE otherwise
#define SFVM_ISDROPONSOURCE     0x0000000a
#define ShellFolderView_IsDropOnSource(_hwnd, _pdtgt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_ISDROPONSOURCE, (LPARAM)_pdtgt)

// Moves the selected icons in the listview
//     lparam is a pointer to a drop target
//     return value is unused
#define SFVM_MOVEICONS          0x0000000b
#define ShellFolderView_MoveIcons(_hwnd, _pdt) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_MOVEICONS, (LPARAM)(LPDROPTARGET)_pdt)

// Gets the start point of a drag-drop
//     lparam is a pointer to a point
//     return value is unused
#define SFVM_GETDRAGPOINT       0x0000000c
#define ShellFolderView_GetDragPoint(_hwnd, _ppt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETDRAGPOINT, (LPARAM)(LPPOINT)_ppt)

// Gets the end point of a drag-drop
//     lparam is a pointer to a point
//     return value is unused
#define SFVM_GETDROPPOINT       0x0000000d
#define ShellFolderView_GetDropPoint(_hwnd, _ppt) \
        SHShellFolderView_Message(_hwnd, SFVM_GETDROPPOINT, (LPARAM)(LPPOINT)_ppt)

#define ShellFolderView_GetAnchorPoint(_hwnd, _fStart, _ppt) \
        (BOOL)((_fStart) ? ShellFolderView_GetDragPoint(_hwnd, _ppt) : ShellFolderView_GetDropPoint(_hwnd, _ppt))


// DOC'ed for DOJ Compliance

// Determines if a given drop target interface is the one being used for
// the background of the ShellFolderView (as opposed to an object in the
// view)
//     lparam is a pointer to a drop target interface
//     return value is TRUE if it is the background drop target, FALSE otherwise
#define SFVM_ISBKDROPTARGET     0x0000000f
#define ShellFolderView_IsBkDropTarget(_hwnd, _pdptgt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_ISBKDROPTARGET, (LPARAM)(LPDROPTARGET)_pdptgt)


// DOC'ed for DOJ Compliance
//  called by defcm.c when it does a copy/cut

// sets auto arrange
#define SFVM_AUTOARRANGE        0x00000011
#define ShellFolderView_AutoArrange(_hwnd) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_AUTOARRANGE, 0)

// sets snap to grid
#define SFVM_ARRANGEGRID        0x00000012
#define ShellFolderView_ArrangeGrid(_hwnd) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_ARRANGEGRID, 0)

#define SFVM_GETAUTOARRANGE     0x00000013
#define ShellFolderView_GetAutoArrange(_hwnd) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETAUTOARRANGE, 0)

#define SFVM_GETSELECTEDCOUNT     0x00000014
#define ShellFolderView_GetSelectedCount(_hwnd) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDCOUNT, 0)

typedef ITEMSPACING *LPITEMSPACING;

#define SFVM_GETITEMSPACING     0x00000015
#define ShellFolderView_GetItemSpacing(_hwnd, lpis) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETITEMSPACING, (LPARAM)lpis)

// Causes an object to be repainted
#define SFVM_REFRESHOBJECT      0x00000016
#define ShellFolderView_RefreshObject(_hwnd, _ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REFRESHOBJECT, (LPARAM)_ppidl)

// Causes the the whole view to be refreshed
#define ShellFolderView_RefreshAll(_hwnd) \
        (LPARAM)PostMessage(_hwnd, WM_KEYDOWN, (WPARAM)VK_F5, (LPARAM)0);


// DOC'ed for DOJ Compliance

// SVM_SELECTANDPOSITIONITEM lParam
typedef struct
{
        LPCITEMIDLIST pidl;     // relative pidl to the view
        UINT  uSelectFlags;     // select flags
        BOOL fMove; // if true, we should also move it to point pt
        POINT pt;
} SFM_SAP;

// shell view messages
#define SVM_SELECTITEM                  (WM_USER + 1)
#define SVM_SELECTANDPOSITIONITEM       (WM_USER + 5)

#include <poppack.h>        /* Return to byte packing */

//===========================================================================
// CDefShellFolder members (for easy subclassing)
//===========================================================================

// Default implementation (no dependencies to the instance data)
STDMETHODIMP CDefShellFolder_QueryInterface(IShellFolder *psf, REFIID riid, void **ppv);
STDMETHODIMP CDefShellFolder_BindToStorage(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
STDMETHODIMP CDefShellFolder_BindToObject(IShellFolder *psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
STDMETHODIMP CDefShellFolder_GetAttributesOf(IShellFolder *psf, UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfOut);
STDMETHODIMP CDefShellFolder_SetNameOf(IShellFolder *psf, HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD dwReserved, LPITEMIDLIST * ppidlOut);

// File Search APIS
// DOC'ed for DOJ compliance

SHSTDAPI_(void) Control_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow);
SHSTDAPI_(void) Control_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow);
SHSTDAPI_(void) Control_RunDLLAsUserW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow);


// to add 16 bit pages to 32bit things.  hGlobal can be NULL
SHSTDAPI_(UINT) SHAddPages16(HGLOBAL hGlobal, LPCTSTR pszDllEntry, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

// DOC'ed for DOJ compliance

// Access to MSHMTL's ditherer

/* Definition of interface: IIntDitherer */
#undef INTERFACE
#define INTERFACE IIntDitherer

DECLARE_INTERFACE_(IIntDitherer, IUnknown)
{
#ifndef NO_BASEINTERFACE_FUNCS
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    // *** IIntDitherer methods ***
    STDMETHOD(DitherTo8bpp)(THIS_ BYTE * pDestBits, LONG nDestPitch,
                    BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc,
                    RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
                    BYTE * pbDestInvMap,
                    LONG x, LONG y, LONG cx, LONG cy,
                    LONG lDestTrans, LONG lSrcTrans) PURE;
};

#ifdef COBJMACROS


#define IntDitherer_QueryInterface(This,riid,ppvObject) \
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IntDitherer_AddRef(This)    \
    (This)->lpVtbl -> AddRef(This)

#define IntDitherer_Release(This)   \
    (This)->lpVtbl -> Release(This)

#define IntDitherer_DitherTo8bpp(This, pDestBits, nDestPitch, \
                    pSrcBits, nSrcPitch, bfidSrc, \
                    prgbDestColors, prgbSrcColors, \
                    pbDestInvMap, x, y, cx, cy, \
                    lDestTrans, lSrcTrans)  \
    (This)->lpVtbl -> DitherTo8bpp(This, pDestBits, nDestPitch, pSrcBits, nSrcPitch, bfidSrc, \
                    prgbDestColors, prgbSrcColors, pbDestInvMap, x, y, cx, cy, lDestTrans, lSrcTrans)

#endif

//      PID_IS_SCHEME       [VT_UI4]      Scheme value
#define PID_IS_FIRST         2
#define PID_IS_SCHEME        3
#define PID_IS_IDLIST        14
#define PID_IS_LAST          14
//      PID_INTSITE_FLAGS        [VT_UI4]      PIDISF_ flags
//      PID_INTSITE_CONTENTLEN   [VT_UI4]      Content length
//      PID_INTSITE_CONTENTCODE  [VT_UI8]      Content code
//      PID_INTSITE_FRAGMENT     [VT_NULL]     Fragments
#define PID_INTSITE_FIRST         2
#define PID_INTSITE_FRAGMENT      17
#define PID_INTSITE_LAST          21
  //Is URL entered in IE history bucket?
#define PIDISF_HISTORY          0x10000000
// Athena needs this to determine whether to double click or not.
//
// NOTE: if user uninstalls IE4, the Win95 code will
// realize that the size has changed (even though it's not
// in this struct, it is saved) and drop back to default state.
//
// Since we're exporting this so ISVs can get access to our flags,
// let's avoid the need for a thunk and export the beginning section
// of this structure ONLY. Here are the A and W versions for internal use:
//
// DOC'ed for DOJ compliance
    // These were in Win95 //
    // The below were added for IE4 //
    // These must have been an OSR release, as they aren't on \\guilo\slmadd\src\dev\inc16\shsemip.h
    // This was added for IE4
    // If you need a new flag, steal a bit from from fSpareFlags.
    //
    // If you add any fields to this structure, you
    // must also add upgrade code to shell32\util.cpp.
    //
    //
    // If you add any fields to this structure, you
    // must also add upgrade code to shell32\util.cpp.
    //
#define SHELLSTATEVERSION 13 // rev if defaults change but size doesn't //
// And here's the beginning portion for public use:
#define SSF_HIDDENFILEEXTS          0x00000004  //
#define SSF_SORTCOLUMNS             0x00000010  //
#define SSF_FILTER                  0x00010000  //
#define SSF_WEBVIEW                 0x00020000  //
#define SSF_SHOWSUPERHIDDEN         0x00040000  //
#define SSF_SEPPROCESS              0x00080000  //
#define SSF_NONETCRAWLING           0x00100000  //
#define SSF_STARTPANELON            0x00200000  //
#define SSF_SHOWSTARTPAGE           0x00400000  //

// CmdID's for CGID_MENUDESKBAR
#define  MBCID_GETSIDE   1
#define  MBCID_RESIZE    2
#define  MBCID_SETEXPAND 3
#define  MBCID_SETFLAT   4
#define  MBCID_NOBORDER  5

// menubar orientation
#define MENUBAR_LEFT     ABE_LEFT
#define MENUBAR_TOP      ABE_TOP
#define MENUBAR_RIGHT    ABE_RIGHT
#define MENUBAR_BOTTOM   ABE_BOTTOM


//
// Net Access Wizard - called from NetID and WinLogon.
//

#define NAW_NETID              0x00          // called from netid tab
#define NAW_PSDOMAINJOINED     0x02          // post setup (joined domain)
#define NAW_PSDOMAINJOINFAILED 0x03          // post setup (domain joined failed)

STDAPI NetAccessWizard(HWND hwnd, UINT uType, BOOL *pfReboot);
typedef HRESULT (CALLBACK *LPNETACCESSWIZARD)(HWND hwnd, UINT uType, BOOL *pfReboot);

STDAPI ClearAutoLogon(VOID);

//
// Net Places API's called from mpr.
//

typedef enum
{
    NETPLACES_WIZARD_MAPDRIVE = 0,
    NETPLACES_WIZARD_ADDPLACE,
} NETPLACESWIZARDTYPE;

STDAPI_(DWORD)
NetPlacesWizardDoModal(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct,
    NETPLACESWIZARDTYPE npwt,
    BOOL                fIsRoPath
    );

// Definition for the exported function types (for GetProcAddress)
typedef DWORD (STDAPICALLTYPE*NetPlacesWizardDoModal_t)(LPCONNECTDLGSTRUCTW lpConnDlgStruct, NETPLACESWIZARDTYPE npwt, BOOL fIsROPath);

//
// moved here from nettarg.h (shell\inc)
//

// nCmdID
#define CFCID_SETENUMTYPE       0

//nCmdExecOpt
#define CFCOPT_ENUMINCOMING     1
#define CFCOPT_ENUMOUTGOING     2
#define CFCOPT_ENUMALL          3

/****************************************************
 Items to display in the shutdown dialog (dwItems)
 -------------------------------------------------

  These flags can be |'d when passed in. A single
  value will be returned, with NONE indicating an
  error or the user clicked cancel.
  -dsheldon
****************************************************/
#define SHTDN_NONE                      0x000000000
#define SHTDN_LOGOFF                    0x000000001
#define SHTDN_SHUTDOWN                  0x000000002
#define SHTDN_RESTART                   0x000000004
#define SHTDN_RESTART_DOS               0x000000008
#define SHTDN_SLEEP                     0x000000010
#define SHTDN_SLEEP2                    0x000000020
#define SHTDN_HIBERNATE                 0x000000040
#define SHTDN_DISCONNECT                0x000000080

// Shutdown dialog function exported from MSGINA.dll

STDAPI_(DWORD) ShellShutdownDialog(HWND hwndParent, LPCTSTR szUsername, DWORD dwExcludeItems);
typedef DWORD (STDAPICALLTYPE*PFNSHELLSHUTDOWNDIALOG)(HWND hwndParent, LPCTSTR szUsername, DWORD dwExcludeItems);

// Define a clipboard format for a data object to pass a user's SID
// A data object supporting this format is passed to IShellExtInit::Initialize
// before calling IShellPropSheetExt::AddPages.
#define CFSTR_USERPROPPAGESSID TEXT("UserPropertyPagesSid")


// Registry paths where extra IShellPropSheetExt handlers can be put so that
// extended pages are added to the CPL or User Properties
#define REGSTR_USERSANDPASSWORDS_CPL \
/* HKLM\\ */ TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Users and Passwords")
// CLSIDs go in HKLM\Software\Microsoft\Windows\CurrentVersion\Control Panel\Users and Passwords\shellex\PropertySheetHandlers

#define REGSTR_USERPROPERTIES_SHEET \
/* HKLM\\ */ TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Users and Passwords\\User Properties")
// CLSIDs go in HKLM\Software\Microsoft\Windows\CurrentVersion\Control Panel\Users and Passwords\User Properties\shellex\PropertySheetHandlers

//
//  SHFileSysBindToStorage()
//  Wrap of file system IShellFolder::BindToStorage
//
//  pszPath       // storage path
//  grfFileAttrib // optional Win32/64 file attribute bits.  Use 0 to specify default behavior
//  grfMode       // STGM_ mode flags.
//  grfFlags      // BIND_xxx bind flags
//  riid          // storage interface ID
//  **ppv         // outbound storage interface pointer.
//
SHSTDAPI SHFileSysBindToStorage(LPCWSTR pszPath, DWORD grfFileAttrib, DWORD grfMode, DWORD grfFlags, REFIID riid, void **ppv);

// DOC'ed for DOJ compliance

//  SHIsLegacyAnsiProperty()
//
//  Determine whether the property is a legacy ANSI property, and if so,
//  compute a conversion type for the property.
//
//  fmtid,     // property set identifier
//  propid,    // property identifier
//  pvt,       // optional:  if non-null, contains on input the VARTYPE for the property; on output,
               //            the converted type.  (e.g., VT_LPSTR <--> VT_LPWSTR).

SHSTDAPI_(BOOL) SHIsLegacyAnsiProperty( REFFMTID fmtid, PROPID propid, IN OUT OPTIONAL VARTYPE* pvt );


//-------------------------------------------------------------------------//
//  linkwnd.h - declaration of LinkWindow control
//
//  LinkWindow supports HTML-like embedded links in the caption text.
//  (e.g. "<a>Click Here</a> to see something cool"
//
//  An unlimited number of embedded links are supported.   When the user clicks
//  on a link, an WM_NOTIFY - LWN_CLICK notification message is sent to the
//  parent window.   The message data includes the zero-based index
//  (left to right orientation) of the link that was clicked.
//
//  scotthan: author/owner
//  dsheldon: moved this to shlobjp.h. Eventually destined for comctl32.

EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;
EXTERN_C BOOL WINAPI LinkWindow_UnregisterClass( HINSTANCE ) ;

#define INVALID_LINK_INDEX  (-1)
#define MAX_LINKID_TEXT     48
#define LINKWINDOW_CLASS    TEXT("Link Window")

#define LWS_TRANSPARENT 0x0001
#define LWS_HOTTRACK    0x0002

#define LWIF_ITEMINDEX  0x00000001
#define LWIF_STATE      0x00000002
#define LWIF_ITEMID     0x00000004
#define LWIF_URL        0x00000008

#define LWIS_FOCUSED    0x0001
#define LWIS_ENABLED    0x0002
#define LWIS_VISITED    0x0004
#define LWIS_SHELLEXECURL 0x00000008    // If the caller didn't handle the msg (NM_CLICK), then ShellExecute the szURL

//  BUGBUG: we've got to change the following definition to
//  wininet.h::INTERNET_MAX_URL_LENGTH.
//  Currently, this breaks various dependents.
#define LW_MAX_URL_LENGTH   (2048 + 32 + sizeof("://"))

//  LWITEM
typedef struct tagLWITEMA {
    UINT        mask ;
    int         iLink ;
    UINT        state ;
    UINT        stateMask ;
    CHAR        szID[MAX_LINKID_TEXT] ;
    CHAR        szUrl[LW_MAX_URL_LENGTH] ;   //bugbug: INTERNET_MAX_URL_LENGTH
} LWITEMA, *LPLWITEMA;

typedef struct tagLWITEMW {
    UINT        mask ;
    int         iLink ;
    UINT        state ;
    UINT        stateMask ;
    WCHAR       szID[MAX_LINKID_TEXT] ;
    WCHAR       szUrl[LW_MAX_URL_LENGTH] ;  //bugbug: INTERNET_MAX_URL_LENGTH
} LWITEMW, *LPLWITEMW;

//  LWHITTESTINFO
typedef struct tagLWHITTESTINFOA {
    POINT       pt ;
    LWITEMA     item ;
} LWHITTESTINFOA, *LPLWHITTESTINFOA;

//  LWHITTESTINFO
typedef struct tagLWHITTESTINFOW {
    POINT       pt ;
    LWITEMW     item ;
} LWHITTESTINFOW, *LPLWHITTESTINFOW;

//  NMLINKWND
typedef struct tagNMLINKWNDA {
    NMHDR       hdr;
    LWITEMA     item ;
} NMLINKWNDA, *LPNMLINKWNDA;

typedef struct tagNMLINKWNDW {
    NMHDR       hdr;
    LWITEMW     item ;
} NMLINKWNDW, *LPNMLINKWNDW;

#ifdef UNICODE
#define LWITEM          LWITEMW
#define LPLWITEM        LPLWITEMW
#define LWHITTESTINFO   LWHITTESTINFOW
#define LPLWHITTESTINFO LPLWHITTESTINFOW
#define NMLINKWND       NMLINKWNDW
#define LPNMLINKWND     LPNMLINKWNDW
#else //UNICODE
#define LWITEM          LWITEMA
#define LPLWITEM        LPLWITEMA
#define LWHITTESTINFO   LWHITTESTINFOA
#define LPLWHITTESTINFO LPLWHITTESTINFOA
#define NMLINKWND       NMLINKWNDA
#define LPNMLINKWND     LPNMLINKWNDA
#endif //UNICODE

//  LinkWindow notifications
//  NM_CLICK   // wParam: n/a, lParam: LPLWITEM, ret: ignored.

//  LinkWindow messages
#define LWM_HITTEST         (WM_USER+0x300)  // wParam: n/a, lparam: LPLWHITTESTINFO, ret: BOOL
#define LWM_GETIDEALHEIGHT  (WM_USER+0x301)  // wParam: n/a, lparam: n/a, ret: cy
#define LWM_SETITEM        (WM_USER+0x302)  // wParam: n/a, lparam: LWITEM*, ret: BOOL
#define LWM_GETITEM        (WM_USER+0x303)  // wParam: n/a, lparam: LWITEM*, ret: BOOL
//-------------------------------------------------------------------------//


//  INTERNAL: Darwin link tracking for start menu
//     lives in unicpp\startmnu.cpp
#if         _WIN32_IE >= 0x0600
//         Note: SHRegisterDarwinLink takes ownership of pidlFull. fUpdate means: update the Darwin state right away
    SHSTDAPI_(BOOL) SHRegisterDarwinLink(LPITEMIDLIST pidlFull, LPWSTR pszDarwinID, BOOL fUpdate);

    // Use this function to update the Darwin state for all registered Darwin shortcuts.
    SHSTDAPI_(void) SHReValidateDarwinCache();

    SHSTDAPI SHParseDarwinIDFromCacheW(LPWSTR pszDarwinDescriptor, LPWSTR *ppwszOut);
#endif


//
//  GroupButton is a variation of a group box control but supports a link-like
//  caption bar, and optionally, can be buddied to a containee window for
//  auto-positioning behavior.
//
//  scotthan: author/owner

#define GROUPBUTTON_CLASS  TEXT("GroupButton")

EXTERN_C ATOM WINAPI GroupButton_RegisterClass() ;
EXTERN_C BOOL WINAPI GroupButton_UnregisterClass() ;

#include <pshpack8.h>

typedef struct tagGBPLACEMENT
{
    LONG x ;            // in: top left; -1 to ignore
    LONG y ;            // in: top right; -1 to ignore
    LONG cx ;           // in: width to assign; -1 to ignore.
                        //     If cx != -1, cxContain and cxMax are ignored.
    LONG cy ;           // in: height to assign; -1 to ignore.
                        //     If cy != -1, cyContain and cyMax are ignored.
    LONG cxBuddy ;      // in: width of buddy area; -1 to ignore
    LONG cyBuddy ;      // in: height of buddy area; -1 to ignore
    LONG cxBuddyMargin ;// in: width of buddy margin; -1 to ignore
    LONG cyBuddyMargin ;// in: height of buddy margin; -1 to ignore
    RECT rcBuddy ;      // out: new buddy rect in parent coords.
    RECT rcWindow ;     // out: new window rect in parent coords.
    HDWP hdwp ;         // optional in: Non-NULL => DeferWindowPos,
                        //              NULL => SetWindowPos
} GBPLACEMENT, *PGBPLACEMENT, *LPGBPLACEMENT ;
#include <poppack.h>        /* Return to byte packing */

//  Buddy flags
#define GBBF_HRESIZE   0x00000001
#define GBBF_VRESIZE   0x00000002
#define GBBF_HSCROLL   0x00000004
#define GBBF_VSCROLL   0x00000008
#define GBBF_HSLAVE    0x00000010
#define GBBF_VSLAVE    0x00000020

//  Group button messages
#define GBM_FIRST        (WM_USER+0x400) // arbitrary
#define GBM_SETPLACEMENT (GBM_FIRST+0)   // WPARAM: n/a, LPARAM: PGBPLACEMENT, return: BOOL
#define GBM_SETBUDDY     (GBM_FIRST+1)   // WPARAM: HWND hwndBuddy, LPARAM: dwBuddyFlags, return: BOOL
#define GBM_GETBUDDY     (GBM_FIRST+2)   // WPARAM: n/a, LPARAM: n/a, return: HWND
#define GBM_SETDROPSTATE (GBM_FIRST+3)   // WPARAM: BOOL fDropped, LPARAM: n/a, return: BOOL
#define GBM_GETDROPSTATE (GBM_FIRST+4)   // WPARAM: n/a, LPARAM: n/a, return: BOOL fDropped
#define GBM_LAST         GBM_GETDROPSTATE

typedef struct tagGBNQUERYBUDDYSIZE
{
    NMHDR   hdr;
    LONG    cx ;
    LONG    cy ;
} GBNQUERYBUDDYSIZE, *LPGBNQUERYBUDDYSIZE, *PGBNQUERYBUDDYSIZE ;

//  Group button notifications
#define GBN_FIRST               2000U
#define GBN_LAST                2020U
#define GBN_QUERYBUDDYHEIGHT    (GBN_FIRST+0)   // LPARAM: LPGBNQUERYBUDDYSIZE
#define GBN_QUERYBUDDYWIDTH     (GBN_FIRST+1)   // LPARAM: LPGBNQUERYBUDDYSIZE.


// create standard IExtractIcon for file system like things (that does not really exist)
// DOC'ed for DOJ compliance

// Limit Input Mask values:
#define LIM_FLAGS           0x00000001      // dwFlags contains valid data.  Otherwise all default values are used.
#define LIM_FILTER          0x00000002      // pszFilter contains valid data.  At least one of the filter and mask fields must be used.  Both can be used it desired.
#define LIM_HINST           0x00000008      // hinst contains valid data
#define LIM_TITLE           0x00000010      // pszTitle contains valid data.  This data will be shown in bold at the top of any tooltips displayed.
#define LIM_MESSAGE         0x00000020      // pszMessage contains valid data.  This data will be shown in default font below the title if a title is also used.
#define LIM_ICON            0x00000040      // hicon contains valid data.  This icon will be displayed in front of the title if a title is given.
#define LIM_NOTIFY          0x00000080      // hwndNotify contains the window handle that should receive any notification messages.  By default, the parent of hwndEdit recieves notifications.
#define LIM_TIMEOUT         0x00000100      // iTimeout is valid.  Otherwise the default timeout of 10 seconds is used.
#define LIM_TIPWIDTH        0x00000200      // cxTipWidth is valid.  Otherwiser the default is 500 pixels.


// Limit Input Flags values:
#define LIF_INCLUDEFILTER   0x00000000      // default value.  pszFilter is a string of allowable characters.
#define LIF_EXCLUDEFILTER   0x00000001      // pszFilter is a string of excluded characters.
#define LIF_CATEGORYFILTER  0x00000002      // pszFilter is not a pointer, but rather its a bitfield indicating types or characters.  If combined with LIF_EXCLUDEFILTER these are excluded categories, otherwise they are allowed categories.

#define LIF_WARNINGBELOW    0x00000000      // default value.  Balloon tooltips will be shown below the window by default.
#define LIF_WARNINGABOVE    0x00000004      // Ballon tooltips will be shown above the window by default.
#define LIF_WARNINGCENTERED 0x00000008      // Ballon tooltips will be shown pointing to the center of the window.
#define LIF_WARNINGOFF      0x00000010      // no balloon tooltip will be displayed upon invalid input.

#define LIF_FORCEUPPERCASE  0x00000020      // all characters will be converted to upper case.  Cannot be use with LIF_FORCELOWERCASE.
#define LIF_FORCELOWERCASE  0x00000040      // all characters will be converted to lower case.  Cannot be use with LIF_FORCEUPPERCASE.

#define LIF_MEESAGEBEEP     0x00000000      // default value.  A tone will be played to alert the user if they attemp invalid input.
#define LIF_SILENT          0x00000080      // No tone will be played.

#define LIF_NOTIFYONBADCHAR 0x00000100      // a notify message will be sent to hwndNotify when invalid input is attempted.
#define LIF_HIDETIPONVALID  0x00000200      // if the tooltip is displayed, it should be hidden when the next valid character is entered.  By default, the tip remains visible for iTimeOut milliseconds.

#define LIF_PASTESKIP       0x00000000      // default value.  When pasting, skip the bad characters and paste all of the good characters.
#define LIF_PASTESTOP       0x00000400      // When pasting, stop when the first bad character is incountered.  Valid characters in front of this will get pasted.
#define LIF_PASTECANCEL     0x00000800      // When pasting, abort the entire paste if any characters are invalid.

#define LIF_KEEPCLIPBOARD   0x00001000      // When pasting, don't modify the contents of the clipboard when there are invalid characters.  By defualt the clipboard is changed.  How it is changed depends on which LIF_PASTE* flag is used.


// Limit Input Category Filters:
// these flags use the result of GetStringTypeEx with CT_TYPE1:
#define LICF_UPPER          0x00000001      // Uppercase
#define LICF_LOWER          0x00000002      // Lowercase
#define LICF_DIGIT          0x00000004      // Decimal digits
#define LICF_SPACE          0x00000008      // Space characters
#define LICF_PUNCT          0x00000010      // Punctuation
#define LICF_CNTRL          0x00000020      // Control characters
#define LICF_BLANK          0x00000040      // Blank characters
#define LICF_XDIGIT         0x00000080      // Hexadecimal digits
#define LICF_ALPHA          0x00000100      // Any linguistic character: alphabetic, syllabary, or ideographic
// these flags check for a few things that GetStringTypeEx doesn't check
#define LICF_BINARYDIGIT    0x00010000      // 0-1
#define LICF_OCTALDIGIT     0x00020000      // 0-7
#define LICF_ATOZUPPER      0x00100000      // A-Z (use LICF_ALPHA for language independent check)
#define LICF_ATOZLOWER      0x00200000      // a-z (use LICF_ALPHA for language independent check)
#define LICF_ATOZ           (LICF_ATOZUPPER|LICF_ATOZLOWER)     // a-z, A-Z

#include <pshpack8.h>

typedef struct tagLIMITINPUT
{
    DWORD       cbSize;
    DWORD       dwMask;
    DWORD       dwFlags;
    HINSTANCE   hinst;
    LPWSTR      pszFilter;      // pointer to a string, or the ID of a string resource if hinst is also given, or LPSTR_TEXTCALLBACK if the parent window should be notified to provide a string.
    LPWSTR      pszTitle;       // pointer to a string, or the ID of a string resource if hinst is also given, or LPSTR_TEXTCALLBACK if the parent window should be notified to provide a string.
    LPWSTR      pszMessage;     // pointer to a string, or the ID of a string resource if hinst is also given, or LPSTR_TEXTCALLBACK if the parent window should be notified to provide a string.
    HICON       hIcon;          // handle to an icon, or I_ICONCALLBACK if the notify window should be asked to provide an icon.
    HWND        hwndNotify;     // handle to a window to process notify messages
    INT         iTimeout;       // time in milliseconds to display the tooltip
    INT         cxTipWidth;     // max width of the tooltip in pixels.  Defaults to 500.
} LIMITINPUT;


typedef struct tagNMLIDISPINFO
{
    NMHDR       hdr;            // standard notification header structure
    LIMITINPUT  li;             // the mask member indicates which fields must be filled out.
} NMLIDISPINFO, * LPNMLIDISPINFO, NMLIFILTERINFO, * LPNMLIFILTERINFO;

#define LIN_GETDISPINFO     0x01            // notify code sent to retrieve tooltip display info
#define LIN_GETFILTERINFO   0x02            // notify code sent to retrieve filter or mask info

typedef struct tagNMLIBADCHAR
{
    NMHDR       hdr;            // standard notification header structure
    WPARAM      wParam;         // wParam sent in WM_CHAR message
    LPARAM      lParam;         // lParam sent in WM_CHAR message
} NMLIBADCHAR, * LPNMLIBADCHAR;

#define LIN_BADCHAR         0x03            // notify code sent when a character is filtered out

#define I_ICONCALLBACK      ((HICON)-1L)

// Helpers which prevent entry of invalid (as defined by the folder) characters.  Call on LVN_BEGIN_INPUT_EDIT
// doc'ed for DOJ compliance
SHSTDAPI SHLimitInputEditWithFlags(HWND hwndEdit, LIMITINPUT * pil);
SHSTDAPI SHLimitInputEditChars(HWND hwndEdit, LPCWSTR pszValidChars, LPCWSTR pszInvalidChars);
SHSTDAPI SHLimitInputCombo(HWND hwndComboBox, IShellFolder *psf);

// DOC'ed for DOJ Compliance
// DOC'ed for DOJ Compliance

int _cdecl ShellMessageBoxWrapW(HINSTANCE hInst, HWND hWnd, LPCWSTR pszMsg, LPCWSTR pszTitle, UINT fuStyle, ...);

#ifdef UNICODE
#define ShellMessageBoxWrap         ShellMessageBoxWrapW
#else
#define ShellMessageBoxWrap         ShellMessageBoxA
#endif

// Helpers for handling IDataObject stuff - from shell32.dll
// DOC'ed for DOJ compliance
STDAPI SHSimulateDropOnClsid(REFCLSID clsidDrop, IUnknown* punkSite, IDataObject* pdo);

#include <poppack.h>        /* Return to byte packing */
#ifdef __cplusplus
}

#endif  /* __cplusplus */

#include <poppack.h>
#endif // _SHLOBJP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\tlogstg.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for tlogstg.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tlogstg_h__
#define __tlogstg_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITravelLogEntry_FWD_DEFINED__
#define __ITravelLogEntry_FWD_DEFINED__
typedef interface ITravelLogEntry ITravelLogEntry;
#endif 	/* __ITravelLogEntry_FWD_DEFINED__ */


#ifndef __IEnumTravelLogEntry_FWD_DEFINED__
#define __IEnumTravelLogEntry_FWD_DEFINED__
typedef interface IEnumTravelLogEntry IEnumTravelLogEntry;
#endif 	/* __IEnumTravelLogEntry_FWD_DEFINED__ */


#ifndef __ITravelLogStg_FWD_DEFINED__
#define __ITravelLogStg_FWD_DEFINED__
typedef interface ITravelLogStg ITravelLogStg;
#endif 	/* __ITravelLogStg_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "oleidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_tlogstg_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// tlogstg.h
//=--------------------------------------------------------------------------=
// Copyright (c) Microsoft Corporation. All rights reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// ITravelLogStg Interface.

#define SID_STravelLogCursor IID_ITravelLogStg 


extern RPC_IF_HANDLE __MIDL_itf_tlogstg_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tlogstg_0000_v0_0_s_ifspec;

#ifndef __ITravelLogEntry_INTERFACE_DEFINED__
#define __ITravelLogEntry_INTERFACE_DEFINED__

/* interface ITravelLogEntry */
/* [local][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ITravelLogEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7EBFDD87-AD18-11d3-A4C5-00C04F72D6B8")
    ITravelLogEntry : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [out] */ LPOLESTR *ppszTitle) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ LPOLESTR *ppszURL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelLogEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITravelLogEntry * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITravelLogEntry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITravelLogEntry * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTitle )( 
            ITravelLogEntry * This,
            /* [out] */ LPOLESTR *ppszTitle);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetURL )( 
            ITravelLogEntry * This,
            /* [out] */ LPOLESTR *ppszURL);
        
        END_INTERFACE
    } ITravelLogEntryVtbl;

    interface ITravelLogEntry
    {
        CONST_VTBL struct ITravelLogEntryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelLogEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelLogEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelLogEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelLogEntry_GetTitle(This,ppszTitle)	\
    (This)->lpVtbl -> GetTitle(This,ppszTitle)

#define ITravelLogEntry_GetURL(This,ppszURL)	\
    (This)->lpVtbl -> GetURL(This,ppszURL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEntry_GetTitle_Proxy( 
    ITravelLogEntry * This,
    /* [out] */ LPOLESTR *ppszTitle);


void __RPC_STUB ITravelLogEntry_GetTitle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEntry_GetURL_Proxy( 
    ITravelLogEntry * This,
    /* [out] */ LPOLESTR *ppszURL);


void __RPC_STUB ITravelLogEntry_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelLogEntry_INTERFACE_DEFINED__ */


#ifndef __IEnumTravelLogEntry_INTERFACE_DEFINED__
#define __IEnumTravelLogEntry_INTERFACE_DEFINED__

/* interface IEnumTravelLogEntry */
/* [local][helpcontext][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumTravelLogEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7EBFDD85-AD18-11d3-A4C5-00C04F72D6B8")
    IEnumTravelLogEntry : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ ITravelLogEntry **rgElt,
            /* [out] */ ULONG *pcEltFetched) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cElt) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumTravelLogEntry **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumTravelLogEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumTravelLogEntry * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumTravelLogEntry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumTravelLogEntry * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumTravelLogEntry * This,
            /* [in] */ ULONG cElt,
            /* [length_is][size_is][out] */ ITravelLogEntry **rgElt,
            /* [out] */ ULONG *pcEltFetched);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumTravelLogEntry * This,
            /* [in] */ ULONG cElt);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumTravelLogEntry * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumTravelLogEntry * This,
            /* [out] */ IEnumTravelLogEntry **ppEnum);
        
        END_INTERFACE
    } IEnumTravelLogEntryVtbl;

    interface IEnumTravelLogEntry
    {
        CONST_VTBL struct IEnumTravelLogEntryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumTravelLogEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumTravelLogEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumTravelLogEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumTravelLogEntry_Next(This,cElt,rgElt,pcEltFetched)	\
    (This)->lpVtbl -> Next(This,cElt,rgElt,pcEltFetched)

#define IEnumTravelLogEntry_Skip(This,cElt)	\
    (This)->lpVtbl -> Skip(This,cElt)

#define IEnumTravelLogEntry_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumTravelLogEntry_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IEnumTravelLogEntry_Next_Proxy( 
    IEnumTravelLogEntry * This,
    /* [in] */ ULONG cElt,
    /* [length_is][size_is][out] */ ITravelLogEntry **rgElt,
    /* [out] */ ULONG *pcEltFetched);


void __RPC_STUB IEnumTravelLogEntry_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IEnumTravelLogEntry_Skip_Proxy( 
    IEnumTravelLogEntry * This,
    /* [in] */ ULONG cElt);


void __RPC_STUB IEnumTravelLogEntry_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IEnumTravelLogEntry_Reset_Proxy( 
    IEnumTravelLogEntry * This);


void __RPC_STUB IEnumTravelLogEntry_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE IEnumTravelLogEntry_Clone_Proxy( 
    IEnumTravelLogEntry * This,
    /* [out] */ IEnumTravelLogEntry **ppEnum);


void __RPC_STUB IEnumTravelLogEntry_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumTravelLogEntry_INTERFACE_DEFINED__ */


#ifndef __ITravelLogStg_INTERFACE_DEFINED__
#define __ITravelLogStg_INTERFACE_DEFINED__

/* interface ITravelLogStg */
/* [local][unique][object][uuid] */ 


enum __MIDL_ITravelLogStg_0001
    {	TLEF_RELATIVE_INCLUDE_CURRENT	= 0x1,
	TLEF_RELATIVE_BACK	= 0x10,
	TLEF_RELATIVE_FORE	= 0x20,
	TLEF_INCLUDE_UNINVOKEABLE	= 0x40,
	TLEF_ABSOLUTE	= 0x31
    } ;
typedef DWORD TLENUMF;


EXTERN_C const IID IID_ITravelLogStg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7EBFDD80-AD18-11d3-A4C5-00C04F72D6B8")
    ITravelLogStg : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CreateEntry( 
            /* [in] */ LPCOLESTR pszUrl,
            /* [in] */ LPCOLESTR pszTitle,
            /* [in] */ ITravelLogEntry *ptleRelativeTo,
            /* [in] */ BOOL fPrepend,
            /* [out] */ ITravelLogEntry **pptle) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE TravelTo( 
            /* [in] */ ITravelLogEntry *ptle) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE EnumEntries( 
            /* [in] */ TLENUMF flags,
            /* [out] */ IEnumTravelLogEntry **ppenum) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindEntries( 
            /* [in] */ TLENUMF flags,
            /* [in] */ LPCOLESTR pszUrl,
            /* [out] */ IEnumTravelLogEntry **ppenum) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetCount( 
            /* [in] */ TLENUMF flags,
            /* [out] */ DWORD *pcEntries) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE RemoveEntry( 
            /* [in] */ ITravelLogEntry *ptle) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetRelativeEntry( 
            /* [in] */ int iOffset,
            /* [out] */ ITravelLogEntry **ptle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelLogStgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITravelLogStg * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITravelLogStg * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITravelLogStg * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateEntry )( 
            ITravelLogStg * This,
            /* [in] */ LPCOLESTR pszUrl,
            /* [in] */ LPCOLESTR pszTitle,
            /* [in] */ ITravelLogEntry *ptleRelativeTo,
            /* [in] */ BOOL fPrepend,
            /* [out] */ ITravelLogEntry **pptle);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *TravelTo )( 
            ITravelLogStg * This,
            /* [in] */ ITravelLogEntry *ptle);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumEntries )( 
            ITravelLogStg * This,
            /* [in] */ TLENUMF flags,
            /* [out] */ IEnumTravelLogEntry **ppenum);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindEntries )( 
            ITravelLogStg * This,
            /* [in] */ TLENUMF flags,
            /* [in] */ LPCOLESTR pszUrl,
            /* [out] */ IEnumTravelLogEntry **ppenum);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ITravelLogStg * This,
            /* [in] */ TLENUMF flags,
            /* [out] */ DWORD *pcEntries);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveEntry )( 
            ITravelLogStg * This,
            /* [in] */ ITravelLogEntry *ptle);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRelativeEntry )( 
            ITravelLogStg * This,
            /* [in] */ int iOffset,
            /* [out] */ ITravelLogEntry **ptle);
        
        END_INTERFACE
    } ITravelLogStgVtbl;

    interface ITravelLogStg
    {
        CONST_VTBL struct ITravelLogStgVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelLogStg_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelLogStg_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelLogStg_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelLogStg_CreateEntry(This,pszUrl,pszTitle,ptleRelativeTo,fPrepend,pptle)	\
    (This)->lpVtbl -> CreateEntry(This,pszUrl,pszTitle,ptleRelativeTo,fPrepend,pptle)

#define ITravelLogStg_TravelTo(This,ptle)	\
    (This)->lpVtbl -> TravelTo(This,ptle)

#define ITravelLogStg_EnumEntries(This,flags,ppenum)	\
    (This)->lpVtbl -> EnumEntries(This,flags,ppenum)

#define ITravelLogStg_FindEntries(This,flags,pszUrl,ppenum)	\
    (This)->lpVtbl -> FindEntries(This,flags,pszUrl,ppenum)

#define ITravelLogStg_GetCount(This,flags,pcEntries)	\
    (This)->lpVtbl -> GetCount(This,flags,pcEntries)

#define ITravelLogStg_RemoveEntry(This,ptle)	\
    (This)->lpVtbl -> RemoveEntry(This,ptle)

#define ITravelLogStg_GetRelativeEntry(This,iOffset,ptle)	\
    (This)->lpVtbl -> GetRelativeEntry(This,iOffset,ptle)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_CreateEntry_Proxy( 
    ITravelLogStg * This,
    /* [in] */ LPCOLESTR pszUrl,
    /* [in] */ LPCOLESTR pszTitle,
    /* [in] */ ITravelLogEntry *ptleRelativeTo,
    /* [in] */ BOOL fPrepend,
    /* [out] */ ITravelLogEntry **pptle);


void __RPC_STUB ITravelLogStg_CreateEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_TravelTo_Proxy( 
    ITravelLogStg * This,
    /* [in] */ ITravelLogEntry *ptle);


void __RPC_STUB ITravelLogStg_TravelTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_EnumEntries_Proxy( 
    ITravelLogStg * This,
    /* [in] */ TLENUMF flags,
    /* [out] */ IEnumTravelLogEntry **ppenum);


void __RPC_STUB ITravelLogStg_EnumEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_FindEntries_Proxy( 
    ITravelLogStg * This,
    /* [in] */ TLENUMF flags,
    /* [in] */ LPCOLESTR pszUrl,
    /* [out] */ IEnumTravelLogEntry **ppenum);


void __RPC_STUB ITravelLogStg_FindEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_GetCount_Proxy( 
    ITravelLogStg * This,
    /* [in] */ TLENUMF flags,
    /* [out] */ DWORD *pcEntries);


void __RPC_STUB ITravelLogStg_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_RemoveEntry_Proxy( 
    ITravelLogStg * This,
    /* [in] */ ITravelLogEntry *ptle);


void __RPC_STUB ITravelLogStg_RemoveEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogStg_GetRelativeEntry_Proxy( 
    ITravelLogStg * This,
    /* [in] */ int iOffset,
    /* [out] */ ITravelLogEntry **ptle);


void __RPC_STUB ITravelLogStg_GetRelativeEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelLogStg_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\systrayp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       SYSTRAY.H
*
*  VERSION:     2.1
*
*  AUTHOR:      Tracy Sharpe / RAL
*
*  DATE:        20 Feb 1994
*
*  Public definitions of the system tray applet (battery meter, PCMCIA, etc).
*
********************************************************************************
*
*  CHANGE LOG:
*
*  DATE        REV DESCRIPTION
*  ----------- --- -------------------------------------------------------------
*  20 Feb 1994 TCS Original implementation.
*  11/8/94     RAL Converted to systray
*  10/23/95    Shawnb Unicode enabled
*
*******************************************************************************/

#ifndef _INC_SYSTRAY
#define _INC_SYSTRAY

#define SYSTRAY_CLASSNAME          TEXT ("SystemTray_Main")

//  Private tray icon notification message sent to the BatteryMeter window.
#define STWM_NOTIFYPOWER                (WM_USER + 201)
#define STWM_NOTIFYPCMCIA               (WM_USER + 202)
#define STWM_NOTIFYVOLUME               (WM_USER + 203)
#define STWM_NOTIFYSTICKYKEYS           (WM_USER + 204)
#define STWM_NOTIFYMOUSEKEYS            (WM_USER + 205)
#define STWM_NOTIFYFILTERKEYS           (WM_USER + 206)
#define STWM_NOTIFYCSC                  (WM_USER + 207)
#define STWM_NOTIFYUSBUI                (WM_USER + 208)

//  Private tray icon notification messages sent to the BatteryMeter window.
#define STWM_ENABLESERVICE              (WM_USER + 220)
#define STWM_GETSTATE                   (WM_USER + 221)

#define STSERVICE_POWER                 1
#define STSERVICE_PCMCIA                2
#define STSERVICE_VOLUME                4
#define STSERVICE_CSC                   8
#define STSERVICE_USBUI                 16
#define STSERVICE_ALL                   31   // Internal

//
//  Flags for the PCMCIA registry entry
//
#define PCMCIA_REGFLAG_NOWARN           1

//      Prototypes
_inline BOOL SysTray_EnableService(int idSTService, BOOL fEnable)
{
	HWND hwndST = FindWindow(SYSTRAY_CLASSNAME, NULL);
	if (hwndST) 
	{
		SendMessage(hwndST, STWM_ENABLESERVICE, idSTService, fEnable);
		return TRUE;
	}
	else
	{
		if (fEnable) 
		{
			static const TCHAR szOPEN[]     = TEXT ("open");
			static const TCHAR szFILE[]     = TEXT ("SYSTRAY.EXE");
			static const TCHAR szFORMAT[]   = TEXT ("%i");
			TCHAR       szPARAMS[10];
			HINSTANCE   hInst;
      
			wsprintf (szPARAMS, szFORMAT, idSTService);

			hInst = ShellExecute (NULL, szOPEN, szFILE,
								  szPARAMS, NULL, SW_SHOWNOACTIVATE);
			if (hInst <= (HINSTANCE)32)
				return FALSE;
		}
		return TRUE;
	} 
} // End SysTray_EnableService


_inline BOOL SysTray_IsServiceEnabled(WPARAM idSTService)
{
   HWND hwndST = FindWindow(SYSTRAY_CLASSNAME, NULL);
   if (hwndST) 
   {
      return((BOOL)SendMessage(hwndST, STWM_GETSTATE, idSTService, 0));
   } 
   else 
   {
      return (FALSE);
   }
} // End SysTray_IsServiceEnabled


#endif // _INC_SYSTRAY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\tlog.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for tlog.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tlog_h__
#define __tlog_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITravelEntry_FWD_DEFINED__
#define __ITravelEntry_FWD_DEFINED__
typedef interface ITravelEntry ITravelEntry;
#endif 	/* __ITravelEntry_FWD_DEFINED__ */


#ifndef __ITravelLog_FWD_DEFINED__
#define __ITravelLog_FWD_DEFINED__
typedef interface ITravelLog ITravelLog;
#endif 	/* __ITravelLog_FWD_DEFINED__ */


#ifndef __ITravelLogEx_FWD_DEFINED__
#define __ITravelLogEx_FWD_DEFINED__
typedef interface ITravelLogEx ITravelLogEx;
#endif 	/* __ITravelLogEx_FWD_DEFINED__ */


#ifndef __ITravelLogClient_FWD_DEFINED__
#define __ITravelLogClient_FWD_DEFINED__
typedef interface ITravelLogClient ITravelLogClient;
#endif 	/* __ITravelLogClient_FWD_DEFINED__ */


#ifndef __ITravelLogClient2_FWD_DEFINED__
#define __ITravelLogClient2_FWD_DEFINED__
typedef interface ITravelLogClient2 ITravelLogClient2;
#endif 	/* __ITravelLogClient2_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"
#include "shtypes.h"
#include "tlogstg.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_tlog_0000 */
/* [local] */ 

#define TLOG_BACK  -1
#define TLOG_FORE   1

#define TLMENUF_INCLUDECURRENT      0x00000001
#define TLMENUF_CHECKCURRENT        (TLMENUF_INCLUDECURRENT | 0x00000002)
#define TLMENUF_BACK                0x00000010  // Default
#define TLMENUF_FORE                0x00000020
#define TLMENUF_BACKANDFORTH        (TLMENUF_BACK | TLMENUF_FORE | TLMENUF_INCLUDECURRENT)

typedef struct _WINDOWDATA
    {
    DWORD dwWindowID;
    UINT uiCP;
    LPITEMIDLIST pidl;
    /* [string] */ LPOLESTR lpszUrl;
    /* [string] */ LPOLESTR lpszUrlLocation;
    /* [string] */ LPOLESTR lpszTitle;
    IStream *pStream;
    } 	WINDOWDATA;

typedef WINDOWDATA *LPWINDOWDATA;

typedef const WINDOWDATA *LPCWINDOWDATA;



extern RPC_IF_HANDLE __MIDL_itf_tlog_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tlog_0000_v0_0_s_ifspec;

#ifndef __ITravelEntry_INTERFACE_DEFINED__
#define __ITravelEntry_INTERFACE_DEFINED__

/* interface ITravelEntry */
/* [helpcontext][helpstring][hidden][local][object][uuid] */ 


EXTERN_C const IID IID_ITravelEntry;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F46EDB3B-BC2F-11d0-9412-00AA00A3EBD3")
    ITravelEntry : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Invoke( 
            /* [in] */ IUnknown *punk) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ IUnknown *punk,
            /* [in] */ BOOL fIsLocalAnchor) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetPidl( 
            /* [out] */ LPITEMIDLIST *ppidl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelEntryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITravelEntry * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITravelEntry * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITravelEntry * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ITravelEntry * This,
            /* [in] */ IUnknown *punk);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Update )( 
            ITravelEntry * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ BOOL fIsLocalAnchor);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPidl )( 
            ITravelEntry * This,
            /* [out] */ LPITEMIDLIST *ppidl);
        
        END_INTERFACE
    } ITravelEntryVtbl;

    interface ITravelEntry
    {
        CONST_VTBL struct ITravelEntryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelEntry_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelEntry_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelEntry_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelEntry_Invoke(This,punk)	\
    (This)->lpVtbl -> Invoke(This,punk)

#define ITravelEntry_Update(This,punk,fIsLocalAnchor)	\
    (This)->lpVtbl -> Update(This,punk,fIsLocalAnchor)

#define ITravelEntry_GetPidl(This,ppidl)	\
    (This)->lpVtbl -> GetPidl(This,ppidl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelEntry_Invoke_Proxy( 
    ITravelEntry * This,
    /* [in] */ IUnknown *punk);


void __RPC_STUB ITravelEntry_Invoke_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelEntry_Update_Proxy( 
    ITravelEntry * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ BOOL fIsLocalAnchor);


void __RPC_STUB ITravelEntry_Update_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelEntry_GetPidl_Proxy( 
    ITravelEntry * This,
    /* [out] */ LPITEMIDLIST *ppidl);


void __RPC_STUB ITravelEntry_GetPidl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelEntry_INTERFACE_DEFINED__ */


#ifndef __ITravelLog_INTERFACE_DEFINED__
#define __ITravelLog_INTERFACE_DEFINED__

/* interface ITravelLog */
/* [helpcontext][helpstring][hidden][local][object][uuid] */ 


EXTERN_C const IID IID_ITravelLog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("66A9CB08-4802-11d2-A561-00A0C92DBFE8")
    ITravelLog : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE AddEntry( 
            /* [in] */ IUnknown *punk,
            /* [in] */ BOOL fIsLocalAnchor) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE UpdateEntry( 
            /* [in] */ IUnknown *punk,
            /* [in] */ BOOL fIsLocalAnchor) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE UpdateExternal( 
            /* [in] */ IUnknown *punk,
            /* [in] */ IUnknown *punkHLBrowseContext) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Travel( 
            /* [in] */ IUnknown *punk,
            /* [in] */ int iOffset) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetTravelEntry( 
            /* [in] */ IUnknown *punk,
            /* [in] */ int iOffset,
            /* [out] */ ITravelEntry **ppte) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindTravelEntry( 
            /* [in] */ IUnknown *punk,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [out] */ ITravelEntry **ppte) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetToolTipText( 
            /* [in] */ IUnknown *punk,
            /* [in] */ int iOffset,
            /* [in] */ int idsTemplate,
            /* [size_is][out] */ LPWSTR pwzText,
            /* [in] */ DWORD cchText) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE InsertMenuEntries( 
            /* [in] */ IUnknown *punk,
            /* [in] */ HMENU hmenu,
            /* [in] */ int nPos,
            /* [in] */ int idFirst,
            /* [in] */ int idLast,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ ITravelLog **pptl) = 0;
        
        virtual /* [helpcontext][helpstring] */ DWORD STDMETHODCALLTYPE CountEntries( 
            /* [in] */ IUnknown *punk) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE Revert( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelLogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITravelLog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITravelLog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITravelLog * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddEntry )( 
            ITravelLog * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ BOOL fIsLocalAnchor);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *UpdateEntry )( 
            ITravelLog * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ BOOL fIsLocalAnchor);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *UpdateExternal )( 
            ITravelLog * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ IUnknown *punkHLBrowseContext);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Travel )( 
            ITravelLog * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ int iOffset);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTravelEntry )( 
            ITravelLog * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ int iOffset,
            /* [out] */ ITravelEntry **ppte);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindTravelEntry )( 
            ITravelLog * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ LPCITEMIDLIST pidl,
            /* [out] */ ITravelEntry **ppte);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetToolTipText )( 
            ITravelLog * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ int iOffset,
            /* [in] */ int idsTemplate,
            /* [size_is][out] */ LPWSTR pwzText,
            /* [in] */ DWORD cchText);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *InsertMenuEntries )( 
            ITravelLog * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ HMENU hmenu,
            /* [in] */ int nPos,
            /* [in] */ int idFirst,
            /* [in] */ int idLast,
            /* [in] */ DWORD dwFlags);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ITravelLog * This,
            /* [out] */ ITravelLog **pptl);
        
        /* [helpcontext][helpstring] */ DWORD ( STDMETHODCALLTYPE *CountEntries )( 
            ITravelLog * This,
            /* [in] */ IUnknown *punk);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *Revert )( 
            ITravelLog * This);
        
        END_INTERFACE
    } ITravelLogVtbl;

    interface ITravelLog
    {
        CONST_VTBL struct ITravelLogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelLog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelLog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelLog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelLog_AddEntry(This,punk,fIsLocalAnchor)	\
    (This)->lpVtbl -> AddEntry(This,punk,fIsLocalAnchor)

#define ITravelLog_UpdateEntry(This,punk,fIsLocalAnchor)	\
    (This)->lpVtbl -> UpdateEntry(This,punk,fIsLocalAnchor)

#define ITravelLog_UpdateExternal(This,punk,punkHLBrowseContext)	\
    (This)->lpVtbl -> UpdateExternal(This,punk,punkHLBrowseContext)

#define ITravelLog_Travel(This,punk,iOffset)	\
    (This)->lpVtbl -> Travel(This,punk,iOffset)

#define ITravelLog_GetTravelEntry(This,punk,iOffset,ppte)	\
    (This)->lpVtbl -> GetTravelEntry(This,punk,iOffset,ppte)

#define ITravelLog_FindTravelEntry(This,punk,pidl,ppte)	\
    (This)->lpVtbl -> FindTravelEntry(This,punk,pidl,ppte)

#define ITravelLog_GetToolTipText(This,punk,iOffset,idsTemplate,pwzText,cchText)	\
    (This)->lpVtbl -> GetToolTipText(This,punk,iOffset,idsTemplate,pwzText,cchText)

#define ITravelLog_InsertMenuEntries(This,punk,hmenu,nPos,idFirst,idLast,dwFlags)	\
    (This)->lpVtbl -> InsertMenuEntries(This,punk,hmenu,nPos,idFirst,idLast,dwFlags)

#define ITravelLog_Clone(This,pptl)	\
    (This)->lpVtbl -> Clone(This,pptl)

#define ITravelLog_CountEntries(This,punk)	\
    (This)->lpVtbl -> CountEntries(This,punk)

#define ITravelLog_Revert(This)	\
    (This)->lpVtbl -> Revert(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLog_AddEntry_Proxy( 
    ITravelLog * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ BOOL fIsLocalAnchor);


void __RPC_STUB ITravelLog_AddEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLog_UpdateEntry_Proxy( 
    ITravelLog * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ BOOL fIsLocalAnchor);


void __RPC_STUB ITravelLog_UpdateEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLog_UpdateExternal_Proxy( 
    ITravelLog * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ IUnknown *punkHLBrowseContext);


void __RPC_STUB ITravelLog_UpdateExternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLog_Travel_Proxy( 
    ITravelLog * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ int iOffset);


void __RPC_STUB ITravelLog_Travel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLog_GetTravelEntry_Proxy( 
    ITravelLog * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ int iOffset,
    /* [out] */ ITravelEntry **ppte);


void __RPC_STUB ITravelLog_GetTravelEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLog_FindTravelEntry_Proxy( 
    ITravelLog * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ LPCITEMIDLIST pidl,
    /* [out] */ ITravelEntry **ppte);


void __RPC_STUB ITravelLog_FindTravelEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLog_GetToolTipText_Proxy( 
    ITravelLog * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ int iOffset,
    /* [in] */ int idsTemplate,
    /* [size_is][out] */ LPWSTR pwzText,
    /* [in] */ DWORD cchText);


void __RPC_STUB ITravelLog_GetToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLog_InsertMenuEntries_Proxy( 
    ITravelLog * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ HMENU hmenu,
    /* [in] */ int nPos,
    /* [in] */ int idFirst,
    /* [in] */ int idLast,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITravelLog_InsertMenuEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLog_Clone_Proxy( 
    ITravelLog * This,
    /* [out] */ ITravelLog **pptl);


void __RPC_STUB ITravelLog_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ DWORD STDMETHODCALLTYPE ITravelLog_CountEntries_Proxy( 
    ITravelLog * This,
    /* [in] */ IUnknown *punk);


void __RPC_STUB ITravelLog_CountEntries_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLog_Revert_Proxy( 
    ITravelLog * This);


void __RPC_STUB ITravelLog_Revert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelLog_INTERFACE_DEFINED__ */


#ifndef __ITravelLogEx_INTERFACE_DEFINED__
#define __ITravelLogEx_INTERFACE_DEFINED__

/* interface ITravelLogEx */
/* [helpcontext][helpstring][hidden][local][object][uuid] */ 


EXTERN_C const IID IID_ITravelLogEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f679-98b5-11cf-bb82-00aa00bdce0b")
    ITravelLogEx : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindTravelEntryWithUrl( 
            /* [in] */ IUnknown *punk,
            /* [in] */ UINT uiCP,
            /* [in] */ LPOLESTR pszUrl,
            /* [out] */ ITravelEntry **ppte) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE TravelToUrl( 
            /* [in] */ IUnknown *punk,
            /* [in] */ UINT uiCP,
            /* [in] */ LPOLESTR pszUrl) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE DeleteIndexEntry( 
            /* [in] */ IUnknown *punk,
            /* [in] */ int index) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE DeleteUrlEntry( 
            /* [in] */ IUnknown *punk,
            /* [in] */ UINT uiCP,
            /* [in] */ LPOLESTR pszUrl) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CountEntryNodes( 
            /* [in] */ IUnknown *punk,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwCount) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE CreateEnumEntry( 
            /* [in] */ IUnknown *punk,
            /* [out] */ IEnumTravelLogEntry **ppEnum,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE DeleteEntry( 
            /* [in] */ IUnknown *punk,
            /* [in] */ ITravelLogEntry *pte) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE InsertEntry( 
            /* [in] */ IUnknown *punkBrowser,
            /* [in] */ ITravelLogEntry *pteRelativeTo,
            /* [in] */ BOOL fPrepend,
            /* [in] */ IUnknown *punkTLClient,
            /* [in] */ ITravelLogEntry **ppEntry) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE TravelToEntry( 
            /* [in] */ IUnknown *punkBrowser,
            /* [in] */ ITravelLogEntry *pteDestination) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelLogExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITravelLogEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITravelLogEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITravelLogEx * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindTravelEntryWithUrl )( 
            ITravelLogEx * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ UINT uiCP,
            /* [in] */ LPOLESTR pszUrl,
            /* [out] */ ITravelEntry **ppte);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *TravelToUrl )( 
            ITravelLogEx * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ UINT uiCP,
            /* [in] */ LPOLESTR pszUrl);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteIndexEntry )( 
            ITravelLogEx * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ int index);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteUrlEntry )( 
            ITravelLogEx * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ UINT uiCP,
            /* [in] */ LPOLESTR pszUrl);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *CountEntryNodes )( 
            ITravelLogEx * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ DWORD dwFlags,
            /* [out] */ DWORD *pdwCount);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateEnumEntry )( 
            ITravelLogEx * This,
            /* [in] */ IUnknown *punk,
            /* [out] */ IEnumTravelLogEntry **ppEnum,
            /* [in] */ DWORD dwFlags);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteEntry )( 
            ITravelLogEx * This,
            /* [in] */ IUnknown *punk,
            /* [in] */ ITravelLogEntry *pte);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *InsertEntry )( 
            ITravelLogEx * This,
            /* [in] */ IUnknown *punkBrowser,
            /* [in] */ ITravelLogEntry *pteRelativeTo,
            /* [in] */ BOOL fPrepend,
            /* [in] */ IUnknown *punkTLClient,
            /* [in] */ ITravelLogEntry **ppEntry);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *TravelToEntry )( 
            ITravelLogEx * This,
            /* [in] */ IUnknown *punkBrowser,
            /* [in] */ ITravelLogEntry *pteDestination);
        
        END_INTERFACE
    } ITravelLogExVtbl;

    interface ITravelLogEx
    {
        CONST_VTBL struct ITravelLogExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelLogEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelLogEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelLogEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelLogEx_FindTravelEntryWithUrl(This,punk,uiCP,pszUrl,ppte)	\
    (This)->lpVtbl -> FindTravelEntryWithUrl(This,punk,uiCP,pszUrl,ppte)

#define ITravelLogEx_TravelToUrl(This,punk,uiCP,pszUrl)	\
    (This)->lpVtbl -> TravelToUrl(This,punk,uiCP,pszUrl)

#define ITravelLogEx_DeleteIndexEntry(This,punk,index)	\
    (This)->lpVtbl -> DeleteIndexEntry(This,punk,index)

#define ITravelLogEx_DeleteUrlEntry(This,punk,uiCP,pszUrl)	\
    (This)->lpVtbl -> DeleteUrlEntry(This,punk,uiCP,pszUrl)

#define ITravelLogEx_CountEntryNodes(This,punk,dwFlags,pdwCount)	\
    (This)->lpVtbl -> CountEntryNodes(This,punk,dwFlags,pdwCount)

#define ITravelLogEx_CreateEnumEntry(This,punk,ppEnum,dwFlags)	\
    (This)->lpVtbl -> CreateEnumEntry(This,punk,ppEnum,dwFlags)

#define ITravelLogEx_DeleteEntry(This,punk,pte)	\
    (This)->lpVtbl -> DeleteEntry(This,punk,pte)

#define ITravelLogEx_InsertEntry(This,punkBrowser,pteRelativeTo,fPrepend,punkTLClient,ppEntry)	\
    (This)->lpVtbl -> InsertEntry(This,punkBrowser,pteRelativeTo,fPrepend,punkTLClient,ppEntry)

#define ITravelLogEx_TravelToEntry(This,punkBrowser,pteDestination)	\
    (This)->lpVtbl -> TravelToEntry(This,punkBrowser,pteDestination)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_FindTravelEntryWithUrl_Proxy( 
    ITravelLogEx * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ UINT uiCP,
    /* [in] */ LPOLESTR pszUrl,
    /* [out] */ ITravelEntry **ppte);


void __RPC_STUB ITravelLogEx_FindTravelEntryWithUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_TravelToUrl_Proxy( 
    ITravelLogEx * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ UINT uiCP,
    /* [in] */ LPOLESTR pszUrl);


void __RPC_STUB ITravelLogEx_TravelToUrl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_DeleteIndexEntry_Proxy( 
    ITravelLogEx * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ int index);


void __RPC_STUB ITravelLogEx_DeleteIndexEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_DeleteUrlEntry_Proxy( 
    ITravelLogEx * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ UINT uiCP,
    /* [in] */ LPOLESTR pszUrl);


void __RPC_STUB ITravelLogEx_DeleteUrlEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_CountEntryNodes_Proxy( 
    ITravelLogEx * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ DWORD dwFlags,
    /* [out] */ DWORD *pdwCount);


void __RPC_STUB ITravelLogEx_CountEntryNodes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_CreateEnumEntry_Proxy( 
    ITravelLogEx * This,
    /* [in] */ IUnknown *punk,
    /* [out] */ IEnumTravelLogEntry **ppEnum,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ITravelLogEx_CreateEnumEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_DeleteEntry_Proxy( 
    ITravelLogEx * This,
    /* [in] */ IUnknown *punk,
    /* [in] */ ITravelLogEntry *pte);


void __RPC_STUB ITravelLogEx_DeleteEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_InsertEntry_Proxy( 
    ITravelLogEx * This,
    /* [in] */ IUnknown *punkBrowser,
    /* [in] */ ITravelLogEntry *pteRelativeTo,
    /* [in] */ BOOL fPrepend,
    /* [in] */ IUnknown *punkTLClient,
    /* [in] */ ITravelLogEntry **ppEntry);


void __RPC_STUB ITravelLogEx_InsertEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogEx_TravelToEntry_Proxy( 
    ITravelLogEx * This,
    /* [in] */ IUnknown *punkBrowser,
    /* [in] */ ITravelLogEntry *pteDestination);


void __RPC_STUB ITravelLogEx_TravelToEntry_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelLogEx_INTERFACE_DEFINED__ */


#ifndef __ITravelLogClient_INTERFACE_DEFINED__
#define __ITravelLogClient_INTERFACE_DEFINED__

/* interface ITravelLogClient */
/* [helpcontext][helpstring][hidden][local][object][uuid] */ 


EXTERN_C const IID IID_ITravelLogClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3050f67A-98b5-11cf-bb82-00aa00bdce0b")
    ITravelLogClient : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE FindWindowByIndex( 
            /* [in] */ DWORD dwID,
            /* [out] */ IUnknown **ppunk) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetWindowData( 
            /* [out][in] */ LPWINDOWDATA pWinData) = 0;
        
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE LoadHistoryPosition( 
            /* [in] */ LPOLESTR pszUrlLocation,
            /* [in] */ DWORD dwPosition) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelLogClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITravelLogClient * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITravelLogClient * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITravelLogClient * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *FindWindowByIndex )( 
            ITravelLogClient * This,
            /* [in] */ DWORD dwID,
            /* [out] */ IUnknown **ppunk);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetWindowData )( 
            ITravelLogClient * This,
            /* [out][in] */ LPWINDOWDATA pWinData);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *LoadHistoryPosition )( 
            ITravelLogClient * This,
            /* [in] */ LPOLESTR pszUrlLocation,
            /* [in] */ DWORD dwPosition);
        
        END_INTERFACE
    } ITravelLogClientVtbl;

    interface ITravelLogClient
    {
        CONST_VTBL struct ITravelLogClientVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelLogClient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelLogClient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelLogClient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelLogClient_FindWindowByIndex(This,dwID,ppunk)	\
    (This)->lpVtbl -> FindWindowByIndex(This,dwID,ppunk)

#define ITravelLogClient_GetWindowData(This,pWinData)	\
    (This)->lpVtbl -> GetWindowData(This,pWinData)

#define ITravelLogClient_LoadHistoryPosition(This,pszUrlLocation,dwPosition)	\
    (This)->lpVtbl -> LoadHistoryPosition(This,pszUrlLocation,dwPosition)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogClient_FindWindowByIndex_Proxy( 
    ITravelLogClient * This,
    /* [in] */ DWORD dwID,
    /* [out] */ IUnknown **ppunk);


void __RPC_STUB ITravelLogClient_FindWindowByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogClient_GetWindowData_Proxy( 
    ITravelLogClient * This,
    /* [out][in] */ LPWINDOWDATA pWinData);


void __RPC_STUB ITravelLogClient_GetWindowData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogClient_LoadHistoryPosition_Proxy( 
    ITravelLogClient * This,
    /* [in] */ LPOLESTR pszUrlLocation,
    /* [in] */ DWORD dwPosition);


void __RPC_STUB ITravelLogClient_LoadHistoryPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelLogClient_INTERFACE_DEFINED__ */


#ifndef __ITravelLogClient2_INTERFACE_DEFINED__
#define __ITravelLogClient2_INTERFACE_DEFINED__

/* interface ITravelLogClient2 */
/* [helpcontext][helpstring][hidden][local][object][uuid] */ 


EXTERN_C const IID IID_ITravelLogClient2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0AD364CE-ADCB-11d3-8269-00805FC732C0")
    ITravelLogClient2 : public IUnknown
    {
    public:
        virtual /* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE GetDummyWindowData( 
            /* [in] */ LPWSTR pszUrl,
            /* [in] */ LPWSTR pszTitle,
            /* [out][in] */ LPWINDOWDATA pWinData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITravelLogClient2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITravelLogClient2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITravelLogClient2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITravelLogClient2 * This);
        
        /* [helpcontext][helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDummyWindowData )( 
            ITravelLogClient2 * This,
            /* [in] */ LPWSTR pszUrl,
            /* [in] */ LPWSTR pszTitle,
            /* [out][in] */ LPWINDOWDATA pWinData);
        
        END_INTERFACE
    } ITravelLogClient2Vtbl;

    interface ITravelLogClient2
    {
        CONST_VTBL struct ITravelLogClient2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITravelLogClient2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITravelLogClient2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITravelLogClient2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITravelLogClient2_GetDummyWindowData(This,pszUrl,pszTitle,pWinData)	\
    (This)->lpVtbl -> GetDummyWindowData(This,pszUrl,pszTitle,pWinData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpcontext][helpstring] */ HRESULT STDMETHODCALLTYPE ITravelLogClient2_GetDummyWindowData_Proxy( 
    ITravelLogClient2 * This,
    /* [in] */ LPWSTR pszUrl,
    /* [in] */ LPWSTR pszTitle,
    /* [out][in] */ LPWINDOWDATA pWinData);


void __RPC_STUB ITravelLogClient2_GetDummyWindowData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITravelLogClient2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\synceng.h ===
/*
 * Copyright (c) 1995-1998, Microsoft Corporation
 *
 * synceng.h - File synchronization engine API description.
 */


#ifndef __SYNCENG_H__
#define __SYNCENG_H__


#ifdef __cplusplus
extern "C" {                     /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* Define API decoration for direct import of DLL functions. */

#ifdef _SYNCENG_
#define SYNCENGAPI
#else
#define SYNCENGAPI         DECLSPEC_IMPORT
#endif


/* Macros
 *********/

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif


/* Types
 ********/

/* return codes */

typedef enum _twinresult
{
   TR_SUCCESS,
   TR_RH_LOAD_FAILED,
   TR_SRC_OPEN_FAILED,
   TR_SRC_READ_FAILED,
   TR_DEST_OPEN_FAILED,
   TR_DEST_WRITE_FAILED,
   TR_ABORT,
   TR_UNAVAILABLE_VOLUME,
   TR_OUT_OF_MEMORY,
   TR_FILE_CHANGED,
   TR_DUPLICATE_TWIN,
   TR_DELETED_TWIN,
   TR_HAS_FOLDER_TWIN_SRC,
   TR_INVALID_PARAMETER,
   TR_REENTERED,
   TR_SAME_FOLDER,
   TR_SUBTREE_CYCLE_FOUND,
   TR_NO_MERGE_HANDLER,
   TR_MERGE_INCOMPLETE,
   TR_TOO_DIFFERENT,
   TR_BRIEFCASE_LOCKED,
   TR_BRIEFCASE_OPEN_FAILED,
   TR_BRIEFCASE_READ_FAILED,
   TR_BRIEFCASE_WRITE_FAILED,
   TR_CORRUPT_BRIEFCASE,
   TR_NEWER_BRIEFCASE,
   TR_NO_MORE
}
TWINRESULT;
DECLARE_STANDARD_TYPES(TWINRESULT);

/* handles */

DECLARE_HANDLE(HBRFCASE);
DECLARE_STANDARD_TYPES(HBRFCASE);

DECLARE_HANDLE(HBRFCASEITER);
DECLARE_STANDARD_TYPES(HBRFCASEITER);

DECLARE_HANDLE(HTWIN);
DECLARE_STANDARD_TYPES(HTWIN);

DECLARE_HANDLE(HOBJECTTWIN);
DECLARE_STANDARD_TYPES(HOBJECTTWIN);

DECLARE_HANDLE(HFOLDERTWIN);
DECLARE_STANDARD_TYPES(HFOLDERTWIN);

DECLARE_HANDLE(HTWINFAMILY);
DECLARE_STANDARD_TYPES(HTWINFAMILY);

DECLARE_HANDLE(HTWINLIST);
DECLARE_STANDARD_TYPES(HTWINLIST);

DECLARE_HANDLE(HVOLUMEID);
DECLARE_STANDARD_TYPES(HVOLUMEID);

/* OpenBriefcase() flags */

typedef enum _openbriefcaseflags
{
   OB_FL_OPEN_DATABASE           = 0x0001,
   OB_FL_TRANSLATE_DB_FOLDER     = 0x0002,
   OB_FL_ALLOW_UI                = 0x0004,
   OB_FL_LIST_DATABASE           = 0x0008,
   ALL_OB_FLAGS                  = (OB_FL_OPEN_DATABASE |
                                    OB_FL_TRANSLATE_DB_FOLDER |
                                    OB_FL_ALLOW_UI |
                                    OB_FL_LIST_DATABASE)
}
OPENBRIEFCASEFLAGS;

/* open briefcase information returned by GetOpenBriefcaseInfo() */

typedef struct _openbrfcaseinfo
{
   ULONG ulSize;
   DWORD dwFlags;
   HWND hwndOwner;
   HVOLUMEID hvid;
   TCHAR rgchDatabasePath[MAX_PATH];
}
OPENBRFCASEINFO;
DECLARE_STANDARD_TYPES(OPENBRFCASEINFO);

/*
 * briefcase information returned by FindFirstBriefcase() and
 * FindNextBriefcase()
 */

typedef struct _brfcaseinfo
{
   ULONG ulSize;
   TCHAR rgchDatabasePath[MAX_PATH];
}
BRFCASEINFO;
DECLARE_STANDARD_TYPES(BRFCASEINFO);

/* new object twin */

typedef struct _newobjecttwin
{
   ULONG ulSize;
   LPCTSTR pcszFolder1;
   LPCTSTR pcszFolder2;
   LPCTSTR pcszName;
}
NEWOBJECTTWIN;
DECLARE_STANDARD_TYPES(NEWOBJECTTWIN);

/* NEWFOLDERTWIN flags */

typedef enum _newfoldertwinflags
{
   NFT_FL_SUBTREE                = 0x0001,
   ALL_NFT_FLAGS                 = NFT_FL_SUBTREE
}
NEWFOLDERTWINFLAGS;

/* new folder twin */

typedef struct _newfoldertwin
{
   ULONG ulSize;
   LPCTSTR pcszFolder1;
   LPCTSTR pcszFolder2;
   LPCTSTR pcszName;
   DWORD dwAttributes;
   DWORD dwFlags;
}
NEWFOLDERTWIN;
DECLARE_STANDARD_TYPES(NEWFOLDERTWIN);

#ifndef _COMPARISONRESULT_DEFINED_

/* comparison results */

typedef enum _comparisonresult
{
   CR_FIRST_SMALLER              = -1,
   CR_EQUAL                      = 0,
   CR_FIRST_LARGER               = +1
}
COMPARISONRESULT;
DECLARE_STANDARD_TYPES(COMPARISONRESULT);

#define _COMPARISONRESULT_DEFINED_

#endif

/* file stamp conditions */

typedef enum _filestampcondition
{
   FS_COND_UNAVAILABLE,
   FS_COND_DOES_NOT_EXIST,
   FS_COND_EXISTS
}
FILESTAMPCONDITION;
DECLARE_STANDARD_TYPES(FILESTAMPCONDITION);

/* file stamp */

typedef struct _filestamp
{
   FILESTAMPCONDITION fscond;
   FILETIME ftMod;
   DWORD dwcbLowLength;
   DWORD dwcbHighLength;
   FILETIME ftModLocal;
}
FILESTAMP;
DECLARE_STANDARD_TYPES(FILESTAMP);

/* volume description flags */

typedef enum _volumedescflags
{
   /* dwSerialNumber is valid. */

   VD_FL_SERIAL_NUMBER_VALID  = 0x0001,

   /* rgchVolumeLabel is valid. */

   VD_FL_VOLUME_LABEL_VALID   = 0x0002,

   /* rgchNetResource is valid. */

   VD_FL_NET_RESOURCE_VALID   = 0x0004,

   /* flag combinations */

   ALL_VD_FLAGS               = (VD_FL_SERIAL_NUMBER_VALID |
                                 VD_FL_VOLUME_LABEL_VALID |
                                 VD_FL_NET_RESOURCE_VALID)
}
VOLUMEDESCFLAGS;

/* volume description */

typedef struct _volumedesc
{
   ULONG ulSize;
   DWORD dwFlags;
   DWORD dwSerialNumber;
   TCHAR rgchVolumeLabel[MAX_PATH];
   TCHAR rgchNetResource[MAX_PATH];
}
VOLUMEDESC;
DECLARE_STANDARD_TYPES(VOLUMEDESC);

/* RECNODE states */

typedef enum _recnodestate
{
   RNS_NEVER_RECONCILED,
   RNS_UNAVAILABLE,
   RNS_DOES_NOT_EXIST,
   RNS_DELETED,
   RNS_NOT_RECONCILED,
   RNS_UP_TO_DATE,
   RNS_CHANGED
}
RECNODESTATE;
DECLARE_STANDARD_TYPES(RECNODESTATE);

/* RECNODE actions */

typedef enum _recnodeaction
{
   RNA_NOTHING,
   RNA_COPY_FROM_ME,
   RNA_COPY_TO_ME,
   RNA_MERGE_ME,
   RNA_DELETE_ME
}
RECNODEACTION;
DECLARE_STANDARD_TYPES(RECNODEACTION);

/* RECNODE flags */

typedef enum _recnodeflags
{
   RN_FL_FROM_OBJECT_TWIN        = 0x0001,
   RN_FL_FROM_FOLDER_TWIN        = 0x0002,
   RN_FL_DELETION_SUGGESTED      = 0x0004,
   ALL_RECNODE_FLAGS             = (RN_FL_FROM_OBJECT_TWIN |
                                    RN_FL_FROM_FOLDER_TWIN |
                                    RN_FL_DELETION_SUGGESTED)
}
RECNODEFLAGS;

/* reconciliation node */

typedef struct _recnode
{
   struct _recnode *prnNext;
   HVOLUMEID hvid;
   LPCTSTR pcszFolder;
   HOBJECTTWIN hObjectTwin;
   struct _recitem *priParent;
   FILESTAMP fsLast;
   FILESTAMP fsCurrent;
   RECNODESTATE rnstate;
   RECNODEACTION rnaction;
   DWORD dwFlags;
   DWORD dwUser;
}
RECNODE;
DECLARE_STANDARD_TYPES(RECNODE);

/* RECITEM actions */

typedef enum _recitemaction
{
   RIA_NOTHING,
   RIA_DELETE,
   RIA_COPY,
   RIA_MERGE,
   RIA_BROKEN_MERGE
}
RECITEMACTION;
DECLARE_STANDARD_TYPES(RECITEMACTION);

/* reconciliation item */

typedef struct _recitem
{
   struct _recitem *priNext;
   LPCTSTR pcszName;
   HTWINFAMILY hTwinFamily;
   ULONG ulcNodes;
   PRECNODE prnFirst;
   RECITEMACTION riaction;
   DWORD dwUser;
}
RECITEM;
DECLARE_STANDARD_TYPES(RECITEM);

/* reconciliation list */

typedef struct _reclist
{
   ULONG ulcItems;
   PRECITEM priFirst;
   HBRFCASE hbr;
}
RECLIST;
DECLARE_STANDARD_TYPES(RECLIST);

/* ReconcileItem() flags */

typedef enum _reconcileitemflags
{
   RI_FL_ALLOW_UI                = 0x0001,
   RI_FL_FEEDBACK_WINDOW_VALID   = 0x0002,
   ALL_RI_FLAGS                  = (RI_FL_ALLOW_UI |
                                    RI_FL_FEEDBACK_WINDOW_VALID)
}
RECONCILEITEMFLAGS;

/* reconciliation status update information */

typedef struct _recstatusupdate
{
   ULONG ulProgress;
   ULONG ulScale;
}
RECSTATUSUPDATE;
DECLARE_STANDARD_TYPES(RECSTATUSUPDATE);

/* CREATERECLISTPROC messages */

typedef enum _createreclistprocmsg
{
   CRLS_BEGIN_CREATE_REC_LIST,
   CRLS_DELTA_CREATE_REC_LIST,
   CRLS_END_CREATE_REC_LIST
}
CREATERECLISTPROCMSG;
DECLARE_STANDARD_TYPES(CREATERECLISTPROCMSG);

/* CreateRecList() status callback function */

typedef BOOL (CALLBACK *CREATERECLISTPROC)(CREATERECLISTPROCMSG, LPARAM, LPARAM);

/* RECSTATUSPROC messages */

typedef enum _recstatusprocmsg
{
   RS_BEGIN_COPY,
   RS_DELTA_COPY,
   RS_END_COPY,
   RS_BEGIN_MERGE,
   RS_DELTA_MERGE,
   RS_END_MERGE,
   RS_BEGIN_DELETE,
   RS_DELTA_DELETE,
   RS_END_DELETE
}
RECSTATUSPROCMSG;
DECLARE_STANDARD_TYPES(RECSTATUSPROCMSG);

/* ReconcileItem() status callback function */

typedef BOOL (CALLBACK *RECSTATUSPROC)(RECSTATUSPROCMSG, LPARAM, LPARAM);

/* FOLDERTWIN flags */

typedef enum _foldertwinflags
{
   FT_FL_SUBTREE                 = 0x0001,
   ALL_FT_FLAGS                  = FT_FL_SUBTREE
}
FOLDERTWINFLAGS;

/* folder twin */

typedef struct _foldertwin
{
   const struct _foldertwin *pcftNext;
   HFOLDERTWIN hftSrc;
   HVOLUMEID hvidSrc;
   LPCTSTR pcszSrcFolder;
   HFOLDERTWIN hftOther;
   HVOLUMEID hvidOther;
   LPCTSTR pcszOtherFolder;
   LPCTSTR pcszName;
   DWORD dwFlags;
   DWORD dwUser;
}
FOLDERTWIN;
DECLARE_STANDARD_TYPES(FOLDERTWIN);

/* folder twin list */

typedef struct _foldertwinlist
{
   ULONG ulcItems;
   PCFOLDERTWIN pcftFirst;
   HBRFCASE hbr;
}
FOLDERTWINLIST;
DECLARE_STANDARD_TYPES(FOLDERTWINLIST);

/* FOLDERTWIN status codes */

typedef enum _foldertwinstatus
{
   FTS_DO_NOTHING,
   FTS_DO_SOMETHING,
   FTS_UNAVAILABLE
}
FOLDERTWINSTATUS;
DECLARE_STANDARD_TYPES(FOLDERTWINSTATUS);


/* Prototypes
 *************/

/* briefcase interface */

SYNCENGAPI TWINRESULT WINAPI OpenBriefcase(LPCTSTR, DWORD, HWND, PHBRFCASE);
SYNCENGAPI TWINRESULT WINAPI SaveBriefcase(HBRFCASE);
SYNCENGAPI TWINRESULT WINAPI CloseBriefcase(HBRFCASE);
SYNCENGAPI TWINRESULT WINAPI DeleteBriefcase(LPCTSTR);
SYNCENGAPI TWINRESULT WINAPI GetOpenBriefcaseInfo(HBRFCASE, POPENBRFCASEINFO);
SYNCENGAPI TWINRESULT WINAPI ClearBriefcaseCache(HBRFCASE);
SYNCENGAPI TWINRESULT WINAPI FindFirstBriefcase(PHBRFCASEITER, PBRFCASEINFO);
SYNCENGAPI TWINRESULT WINAPI FindNextBriefcase(HBRFCASEITER, PBRFCASEINFO);
SYNCENGAPI TWINRESULT WINAPI FindBriefcaseClose(HBRFCASEITER);

/* twin interface */

SYNCENGAPI TWINRESULT WINAPI AddObjectTwin(HBRFCASE, PCNEWOBJECTTWIN, PHTWINFAMILY);
SYNCENGAPI TWINRESULT WINAPI AddFolderTwin(HBRFCASE, PCNEWFOLDERTWIN, PHFOLDERTWIN);
SYNCENGAPI TWINRESULT WINAPI ReleaseTwinHandle(HTWIN);
SYNCENGAPI TWINRESULT WINAPI DeleteTwin(HTWIN);
SYNCENGAPI TWINRESULT WINAPI GetObjectTwinHandle(HBRFCASE, LPCTSTR, LPCTSTR, PHOBJECTTWIN);
SYNCENGAPI TWINRESULT WINAPI IsFolderTwin(HBRFCASE, LPCTSTR, PBOOL);
SYNCENGAPI TWINRESULT WINAPI CreateFolderTwinList(HBRFCASE, LPCTSTR, PFOLDERTWINLIST *);
SYNCENGAPI TWINRESULT WINAPI DestroyFolderTwinList(PFOLDERTWINLIST);
SYNCENGAPI TWINRESULT WINAPI IsOrphanObjectTwin(HOBJECTTWIN, PBOOL);
SYNCENGAPI TWINRESULT WINAPI CountSourceFolderTwins(HOBJECTTWIN, PULONG);
SYNCENGAPI TWINRESULT WINAPI AnyTwins(HBRFCASE, PBOOL);

/* twin list interface */

SYNCENGAPI TWINRESULT WINAPI CreateTwinList(HBRFCASE, PHTWINLIST);
SYNCENGAPI TWINRESULT WINAPI DestroyTwinList(HTWINLIST);
SYNCENGAPI TWINRESULT WINAPI AddTwinToTwinList(HTWINLIST, HTWIN);
SYNCENGAPI TWINRESULT WINAPI AddAllTwinsToTwinList(HTWINLIST);
SYNCENGAPI TWINRESULT WINAPI RemoveTwinFromTwinList(HTWINLIST, HTWIN);
SYNCENGAPI TWINRESULT WINAPI RemoveAllTwinsFromTwinList(HTWINLIST);

/* reconciliation list interface */

SYNCENGAPI TWINRESULT WINAPI CreateRecList(HTWINLIST, CREATERECLISTPROC, LPARAM, PRECLIST *);
SYNCENGAPI TWINRESULT WINAPI DestroyRecList(PRECLIST);
SYNCENGAPI TWINRESULT WINAPI ReconcileItem(PCRECITEM, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
SYNCENGAPI TWINRESULT WINAPI BeginReconciliation(HBRFCASE);
SYNCENGAPI TWINRESULT WINAPI EndReconciliation(HBRFCASE);
SYNCENGAPI TWINRESULT WINAPI GetFolderTwinStatus(HFOLDERTWIN, CREATERECLISTPROC, LPARAM, PFOLDERTWINSTATUS);

/* file stamp interface */

SYNCENGAPI TWINRESULT WINAPI GetFileStamp(LPCTSTR, PFILESTAMP);
SYNCENGAPI TWINRESULT WINAPI CompareFileStamps(PCFILESTAMP, PCFILESTAMP, PCOMPARISONRESULT);

/* volume ID interface */

SYNCENGAPI TWINRESULT WINAPI IsPathOnVolume(LPCTSTR, HVOLUMEID, PBOOL);
SYNCENGAPI TWINRESULT WINAPI GetVolumeDescription(HVOLUMEID, PVOLUMEDESC);


#ifdef __cplusplus
}                                /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __SYNCENG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\internal\shell\inc\uastrfnc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//  File:       uastrfnc.h
//
//  Contents:   Unaligned UNICODE lstr functions for MIPS, PPC, ALPHA, ...
//
//  Classes:
//
//  Functions:
//
//;begin_internal
//  History:    1-11-95   davepl   Created
//;end_internal
//
//--------------------------------------------------------------------------

// NOTE: This file assumes it is included from shellprv.h

#ifndef _UASTRFNC_H_
#define _UASTRFNC_H_

#ifdef __cplusplus
extern "C" {
#endif

// If we are running on a platform that requires aligned data, we need
// to provide custom string functions that can deal with unaligned
// strings.  On other platforms, these call directly to the normal string
// functions.

#ifndef _X86_
#define ALIGNMENT_MACHINE
#endif

#ifdef ALIGNMENT_MACHINE

#define IS_ALIGNED(p)   (((ULONG_PTR)(p) & (sizeof(*(p))-1) )==0)

UNALIGNED WCHAR * ualstrcpynW(UNALIGNED WCHAR * lpString1,
    		  	      UNALIGNED const WCHAR * lpString2,
    			      int iMaxLength);

int 		  ualstrcmpiW (UNALIGNED const WCHAR * dst,
			       UNALIGNED const WCHAR * src);

int 		  ualstrcmpW  (UNALIGNED const WCHAR * src,
			       UNALIGNED const WCHAR * dst);

size_t 		  ualstrlenW  (UNALIGNED const WCHAR * wcs);

UNALIGNED WCHAR * ualstrcpyW  (UNALIGNED WCHAR * dst,
			       UNALIGNED const WCHAR * src);


#else

#define ualstrcpynW StrCpyNW     // lstrcpynW is stubbed out on Windows 95
#define ualstrcmpiW StrCmpIW     // lstrcmpiW is stubbed out on Windows 95
#define ualstrcmpW  StrCmpW      // lstrcmpW is stubbed out on Wi