*************************************************************************/

HRESULT EXTERNAL
CDIDev_NotifyCreateEffect(PDD this, struct CDIEff *pdeff)
{
    HRESULT hres;

    AssertF(!CDIDev_InCrit(this));

    CDIDev_EnterCrit(this);
    hres = GPA_Append(&this->gpaEff, pdeff);

    CDIDev_LeaveCrit(this);

    /*
     *  Note that we must leave the device critical section
     *  before talking to the effect, in order to preserve
     *  the synchronization hierarchy.
     */
    if (SUCCEEDED(hres)) {
        Common_Hold(pdeff);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | NotifyDestroyEffect |
 *
 *          Remove the effect pointer from the list of effects that
 *          have been created by the device.
 *
 *          The device critical section must not be owned by the
 *          calling thread.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   IN struct CDIEff * | pdeff |
 *
 *          The effect pointer to remove.
 *
 *  @returns
 *
 *          Returns a COM error code on failure.
 *
 *          On success, returns the number of items left in the GPA.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CDIDev_NotifyDestroyEffect(PDD this, struct CDIEff *pdeff)
{
    HRESULT hres;

    AssertF(!CDIDev_InCrit(this));

    CDIDev_EnterCrit(this);
    hres = GPA_DeletePtr(&this->gpaEff, pdeff);

    CDIDev_LeaveCrit(this);

    /*
     *  Note that we must leave the device critical section
     *  before talking to the effect, in order to preserve
     *  the synchronization hierarchy.
     *
     *  Note that there you might think there's a deadlock here if
     *  effect A notifies us, and we in turn try to unhold
     *  effect B.  But that won't happen, because we only
     *  unhold the effect that notified us.
     */
    if (SUCCEEDED(hres)) {
        Common_Unhold(pdeff);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | FindEffectGUID |
 *
 *          Look for an effect <t GUID>; if found, fetch associated
 *          information.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   REFGUID | rguid |
 *
 *          Effect <t GUID> to locate.
 *
 *  @parm   PEFFECTMAPINFO | pemi |
 *
 *          Receives associated information for the effect.
 *          We must return a copy instead of a pointer, because
 *          the original might disappear suddenly if the
 *          device gets <mf CDIDev::Reset>().
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:  Out of memory.
 *
 *          <c DIERR_DEVICENOTREG> = <c REGDB_E_CLASSNOTREG>:
 *          The effect is not supported by the device.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_FindEffectGUID_(PDD this, REFGUID rguid, PEFFECTMAPINFO pemi,
                       LPCSTR s_szProc, int iarg)
{
    UINT iemi;
    HRESULT hres;

  D(iarg);

    CDIDev_EnterCrit(this);

    for (iemi = 0; iemi < this->cemi; iemi++) {
        if (IsEqualGUID(rguid, &this->rgemi[iemi].guid)) {
            *pemi = this->rgemi[iemi];
            hres = S_OK;
            goto found;
        }
    }

    RPF("%s: Effect not supported by device", s_szProc);
    hres = DIERR_DEVICENOTREG;      /* Effect not found */

found:;

    CDIDev_LeaveCrit(this);

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIDev | GetEffectInfoHelper |
 *
 *          Transfer information from an
 *          <t EFFECTMAPINFO> to a <t DIEFFECTINFOW>.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   LPDIEFFECTINFOW | pdeiW |
 *
 *          Destination.
 *
 *  @parm   PCEFFECTMAPINFO | pemi |
 *
 *          Source.
 *
 *****************************************************************************/

void INTERNAL
CDIDev_GetEffectInfoHelper(PDD this, LPDIEFFECTINFOW pdeiW,
                           PCEFFECTMAPINFO pemi)
{
    AssertF(pdeiW->dwSize == cbX(*pdeiW));

    pdeiW->guid            = pemi->guid;
    pdeiW->dwEffType       = pemi->attr.dwEffType;
    pdeiW->dwStaticParams  = pemi->attr.dwStaticParams;
    pdeiW->dwDynamicParams = pemi->attr.dwDynamicParams;
    CAssertF(cbX(pdeiW->tszName) == cbX(pemi->wszName));
    CopyMemory(pdeiW->tszName, pemi->wszName, cbX(pemi->wszName));
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | EnumEffects |
 *
 *          Enumerates all of the effects supported by the force
 *          feedback system on the device.  The enumerated GUIDs
 *          may represent predefined effects as well as effects
 *          peculiar to the device manufacturer.
 *
 *          An application
 *          can use the <e DIEFFECTINFO.dwEffType> field of the
 *          <t DIEFFECTINFO> structure to obtain general
 *          information about the effect, such as its type and
 *          which envelope and condition parameters are supported
 *          by the effect.
 *
 *          In order to exploit an effect to its fullest,
 *          you must contact the device manufacturer to obtain
 *          information on the semantics of the effect and its
 *          effect-specific parameters.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPDIENUMEFFECTSCALLBACK | lpCallback |
 *
 *          Points to an application-defined callback function.
 *          For more information, see the description of the
 *          <f DIEnumEffectsProc> callback function.
 *
 *  @parm   LPVOID | pvRef |
 *
 *          Specifies a 32-bit application-defined
 *          value to be passed to the callback function.  This value
 *          may be any 32-bit value; it is prototyped as an <t LPVOID>
 *          for convenience.
 *
 *  @parm   DWORD | dwEffType |
 *
 *          Effect type filter.  If <c DIEFT_ALL>, then all
 *          effect types are
 *          enumerated.  Otherwise, it is a <c DIEFT_*> value,
 *          indicating the device type that should be enumerated.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p fl> parameter contains invalid flags, or the callback
 *          procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumEffectsProc |
 *
 *          An application-defined callback function that receives
 *          device effects as a result of a call to the
 *          <om IDirectInputDevice8::EnumEffects> method.
 *
 *  @parm   IN LPCDIEFFECTINFO | pdei |
 *
 *          A <t DIEFFECTINFO> structure that describes the enumerated
 *          effect.
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputDevice8::EnumEffects> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *//**************************************************************************
 *
 *      In DEBUG/RDEBUG, if the callback returns a bogus value, raise
 *      a validation exception.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_EnumEffectsW
    (PV pddW, LPDIENUMEFFECTSCALLBACKW pecW, PV pvRef, DWORD dwEffType)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8W::EnumEffects,
               (_ "pppx", pddW, pecW, pvRef, dwEffType));

    if (SUCCEEDED(hres = hresPvW(pddW)) &&
        SUCCEEDED(hres = hresFullValidPfn(pecW, 1)) &&
        SUCCEEDED(hres = hresFullValidFl(dwEffType, DIEFT_ENUMVALID, 3))) {

        PDD this = _thisPvNm(pddW, ddW);
        PEFFECTMAPINFO rgemi;
        UINT iemi, cemi;


        /*
         *  We need to make a private copy of the GUID list,
         *  because somebody else might suddenly Reset() the
         *  device and mess up everything.
         *
         *  Indeed, it might've been Reset() during this comment!
         *  That's why we need to create the private copy
         *  while under the critical section.
         */

        CDIDev_EnterCrit(this);

        cemi = this->cemi;
        hres = AllocCbPpv(cbCxX(this->cemi, EFFECTMAPINFO), &rgemi);

        if (SUCCEEDED(hres)) {
            if (this->cemi) {
                CopyMemory(rgemi, this->rgemi,
                           cbCxX(this->cemi, EFFECTMAPINFO));
            }
        }

        CDIDev_LeaveCrit(this);

        if (SUCCEEDED(hres)) {
            for (iemi = 0; iemi < cemi; iemi++) {
                PEFFECTMAPINFO pemi = &rgemi[iemi];
                if (fLimpFF(dwEffType,
                            dwEffType == LOBYTE(pemi->attr.dwEffType))) {
                    BOOL fRc;
                    DIEFFECTINFOW deiW;

                    deiW.dwSize = cbX(deiW);
                    CDIDev_GetEffectInfoHelper(this, &deiW, pemi);

                    fRc = Callback(pecW, &deiW, pvRef);

                    switch (fRc) {
                    case DIENUM_STOP: goto enumdoneok;
                    case DIENUM_CONTINUE: break;
                    default:
                        RPF("%s: Invalid return value from callback",
                            s_szProc);
                        ValidationException();
                        break;
                    }
                }
            }

        enumdoneok:;

            FreePpv(&rgemi);
            hres = S_OK;

        }

    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8A | EnumEffectsCallbackA |
 *
 *          Custom callback that wraps
 *          <mf IDirectInputDevice8::EnumObjects> which
 *          translates the UNICODE string to an ANSI string.
 *
 *  @parm   IN LPCDIEFFECTINFOA | pdoiA |
 *
 *          Structure to be translated to ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Pointer to <t struct ENUMEFFECTSINFO> which describes
 *          the original callback.
 *
 *  @returns
 *
 *          Returns whatever the original callback returned.
 *
 *****************************************************************************/

typedef struct ENUMEFFECTSINFO {
    LPDIENUMEFFECTSCALLBACKA pecA;
    PV pvRef;
} ENUMEFFECTSINFO, *PENUMEFFECTSINFO;

BOOL CALLBACK
CDIDev_EnumEffectsCallbackA(LPCDIEFFECTINFOW pdeiW, PV pvRef)
{
    PENUMEFFECTSINFO peei = pvRef;
    BOOL fRc;
    DIEFFECTINFOA deiA;
    EnterProc(CDIObj_EnumObjectsCallbackA,
              (_ "GxWp", &pdeiW->guid,
                         &pdeiW->dwEffType,
                          pdeiW->tszName, pvRef));

    deiA.dwSize = cbX(deiA);
    EffectInfoWToA(&deiA, pdeiW);

    fRc = peei->pecA(&deiA, peei->pvRef);

    ExitProcX(fRc);
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8A | EnumEffects |
 *
 *          Enumerate the effects available on a device, in ANSI.
 *          See <mf IDirectInputDevice8::EnumEffects> for more information.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN LPDIENUMEFFECTSCALLBACKA | lpCallback |
 *
 *          Same as <mf IDirectInputDevice8W::EnumObjects>, except in ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Same as <mf IDirectInputDevice8W::EnumObjects>.
 *
 *  @parm   IN DWORD | fl |
 *
 *          Same as <mf IDirectInputDevice8W::EnumObjects>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_EnumEffectsA
    (PV pddA, LPDIENUMEFFECTSCALLBACKA pecA, PV pvRef, DWORD dwEffType)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8A::EnumEffects,
               (_ "pppx", pddA, pecA, pvRef, dwEffType));

    /*
     *  EnumEffectsW will validate the rest.
     */
    if (SUCCEEDED(hres = hresPvA(pddA)) &&
        SUCCEEDED(hres = hresFullValidPfn(pecA, 1))) {
        ENUMEFFECTSINFO eei = { pecA, pvRef };
        PDD this = _thisPvNm(pddA, ddA);

        hres = CDIDev_EnumEffectsW(&this->ddW, CDIDev_EnumEffectsCallbackA,
                                   &eei, dwEffType);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | GetEffectInfo |
 *
 *          Obtains information about an effect.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIEFFECTINFO | pdei |
 *
 *          Receives information about the effect.
 *          The caller "must" initialize the <e DIEFFECTINFO.dwSize>
 *          field before calling this method.
 *
 *  @parm   REFGUID | rguid |
 *
 *          Identifies the effect for which information is being requested.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_DEVICENOTREG>: The effect GUID does not exist
 *          on the current device.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetEffectInfoW(PV pddW, LPDIEFFECTINFOW pdeiW, REFGUID rguid)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8W::GetEffectInfo,
               (_ "ppG", pddW, pdeiW, rguid));

    if (SUCCEEDED(hres = hresPvW(pddW)) &&
        SUCCEEDED(hres = hresFullValidWritePxCb(pdeiW,
                                                DIEFFECTINFOW, 1))) {
        PDD this = _thisPvNm(pddW, ddW);
        EFFECTMAPINFO emi;

        if (SUCCEEDED(hres = CDIDev_FindEffectGUID(this, rguid, &emi, 2))) {

            CDIDev_GetEffectInfoHelper(this, pdeiW, &emi);
            hres = S_OK;
        }

        if (FAILED(hres)) {
            ScrambleBuf(&pdeiW->guid,
                cbX(DIEFFECTINFOW) - FIELD_OFFSET(DIEFFECTINFOW, guid));
        }
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8A | GetEffectInfo |
 *
 *          ANSI version of same.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   OUT LPDIEFFECTINFO | pdei |
 *
 *          Receives information about the effect.
 *          The caller "must" initialize the <e DIEFFECTINFO.dwSize>
 *          field before calling this method.
 *
 *  @parm   REFGUID | rguid |
 *
 *          Identifies the effect for which information is being requested.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_DEVICENOTREG>: The effect GUID does not exist
 *          on the current device.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetEffectInfoA(PV pddA, LPDIEFFECTINFOA pdeiA, REFGUID rguid)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8A::GetEffectInfo,
               (_ "ppG", pddA, pdeiA, rguid));

    if (SUCCEEDED(hres = hresPvA(pddA)) &&
        SUCCEEDED(hres = hresFullValidWritePxCb(pdeiA,
                                                DIEFFECTINFOA, 1))) {
        PDD this = _thisPvNm(pddA, ddA);
        DIEFFECTINFOW deiW;

        deiW.dwSize = cbX(deiW);

        hres = CDIDev_GetEffectInfoW(&this->ddW, &deiW, rguid);

        if (SUCCEEDED(hres)) {
            EffectInfoWToA(pdeiA, &deiW);
            hres = S_OK;
        } else {
            ScrambleBuf(&pdeiA->guid,
                cbX(DIEFFECTINFOA) - FIELD_OFFSET(DIEFFECTINFOA, guid));
        }
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | GetForceFeedbackState |
 *
 *          Retrieves the state of the device's force feedback system.
 *          The device must be acquired for this method to succeed.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   LPDWORD | pdwOut |
 *
 *          Receives a <t DWORD> of flags which describe the current
 *          state of the device's force feedback system.
 *
 *          The value is a combination of zero or more <c DIGFFS_*>
 *          flags.
 *
 *          Note that future versions of DirectInput may define
 *          additional flags.  Applications should ignore any flags
 *          that are not currently defined.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p pdwOut> parameter is not a valid pointer.
 *
 *          <c DIERR_INPUTLOST>: Acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetForceFeedbackState(PV pdd, LPDWORD pdwOut _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::GetForceFeedbackState, (_ "p", pdd));

    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = hresFullValidPcbOut(pdwOut, cbX(*pdwOut), 1))) {
        PDD this = _thisPv(pdd);

        /*
         *  I just know people aren't going to check the error code,
         *  so don't let them see garbage.
         */
        *pdwOut = 0;

        hres = CDIDev_CreateEffectDriver(this);

        if (SUCCEEDED(hres)) {
            DIDEVICESTATE ds;

            CDIDev_EnterCrit(this);

            /*
             *  Note that it isn't necessary to check
             *  CDIDev_IsExclAcquired(), because the effect shepherd
             *  will deny us access to a device we don't own.
             *
             *  ISSUE-2001/03/29-timgill Need to handle DIERR_INPUTLOST case
             */

            ds.dwSize = cbX(ds);
            /*
             *  Prefix raises a warning (mb:34564) that this->pes could 
             *  be NULL however CDIDev_CreateEffectDriver only succeeds 
             *  if it is not.
             */
            hres = this->pes->lpVtbl->
                        GetForceFeedbackState(this->pes, &this->sh, &ds);

            /*
             *  We put as many flags in matching places in
             *  DISFFC_* and DIGFFS_* because I just know
             *  app writers are going to mess it up.
             */
            if (SUCCEEDED(hres)) {

                CAssertF(DISFFC_RESET           == DIGFFS_EMPTY);
                CAssertF(DISFFC_STOPALL         == DIGFFS_STOPPED);
                CAssertF(DISFFC_PAUSE           == DIGFFS_PAUSED);
                CAssertF(DISFFC_SETACTUATORSON  == DIGFFS_ACTUATORSON);
                CAssertF(DISFFC_SETACTUATORSOFF == DIGFFS_ACTUATORSOFF);

                *pdwOut = ds.dwState;
                hres = S_OK;
            }

            CDIDev_LeaveCrit(this);

        }
        ScrambleBit(pdwOut, DIGFFS_RANDOM);

    }

    /*
     *  Can't use ExitOleProcPpv here because pdwOut might have
     *  DIFFS_RANDOM set in it, even on error.
     */
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | SendForceFeedbackCommand |
 *
 *          Sends a command to the the device's force feedback system.
 *          The device must be acquired for this method to succeed.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   DWORD | dwCommand |
 *
 *          One of the <c DISFFC_*> values indicating
 *          the command to send.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p dwFlags> parameter is invalid.
 *
 *          <c DIERR_INPUTLOST>: Acquisition has been lost.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

HRESULT INLINE
CDIDev_SendForceFeedbackCommand_IsValidCommand(DWORD dwCmd)
{
    HRESULT hres;
 RD(static char s_szProc[] = "IDirectInputDevice8::SendForceFeedbackCommand");

    /*
     *  dwCmd must not be zero (therefore at least one bit set).
     *  !(dwCmd & (dwCmd - 1)) checks that at most one bit is set.
     *  (dwCmd & ~DISFFC_VALID) checks that no bad bits are set.
     */
    if (dwCmd && !(dwCmd & ~DISFFC_VALID) && !(dwCmd & (dwCmd - 1))) {

        hres = S_OK;

    } else {
        RPF("ERROR %s: arg %d: invalid command", s_szProc, 1);
        hres = E_INVALIDARG;
    }
    return hres;
}

STDMETHODIMP
CDIDev_SendForceFeedbackCommand(PV pdd, DWORD dwCmd _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::SendForceFeedbackCommand,
               (_ "px", pdd, dwCmd));

    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = CDIDev_SendForceFeedbackCommand_IsValidCommand
                                                                (dwCmd))) {
        PDD this = _thisPv(pdd);

        hres = CDIDev_CreateEffectDriver(this);

        if (SUCCEEDED(hres)) {

            CDIDev_EnterCrit(this);

            /*
             *  Note that it isn't necessary to check
             *  CDIDev_IsExclAcquired(), because the effect shepherd
             *  will deny us access to a device we don't own.
             *
             *  ISSUE-2001/03/29-timgill Need to handle DIERR_INPUTLOST case
             */

            /*
             *  Prefix raises a warning (mb:34564) that this->pes could 
             *  be NULL however CDIDev_CreateEffectDriver only succeeds 
             *  if it is not.
             */
            hres = this->pes->lpVtbl->
                        SendForceFeedbackCommand(this->pes,
                                                 &this->sh, dwCmd);

            if (SUCCEEDED(hres) && (dwCmd & DISFFC_RESET)) {
                /*
                 *  Re-establish the gain after a reset.
                 */
                CDIDev_RefreshGain(this);
            }

            CDIDev_LeaveCrit(this);

        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputDevice8 | EnumCreatedEffectObjects |
 *
 *          Enumerates all of the currently created effect objects for
 *          this device.  Effect objects created via
 *          <mf IDirectInputDevice::CreateEffect>
 *          are enumerated.
 *
 *          Note that results will be unpredictable if you destroy
 *          or create an effect object while an enumeration is in progress.
 *          The sole exception is that the callback function itself
 *          <f DIEnumCreatedEffectObjectsProc> is permitted to
 *          <mf IDirectInputEffect::Release> the effect that it is
 *          passed as its first parameter.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @parm   IN LPDIENUMCREATEDEFFECTOBJECTSCALLBACK | lpCallback |
 *
 *          Callback function.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Reference data (context) for callback.
 *
 *  @parm   IN DWORD | fl |
 *
 *          No flags are currently defined.  This parameter must be 0.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p fl> parameter contains invalid flags, or the callback
 *          procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumCreatedEffectObjectsProc |
 *
 *          An application-defined callback function that receives
 *          IDirectInputEffect effect objects as a result of a call to the
 *          <om IDirectInputDevice8::EnumCreatedEffects> method.
 *
 *  @parm   LPDIRECTINPUTEFFECT | peff |
 *
 *          A pointer to an effect object that has been created.
 *
 *  @parm   LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputDevice8::EnumCreatedEffectObjects> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_EnumCreatedEffectObjects(PV pdd,
                          LPDIENUMCREATEDEFFECTOBJECTSCALLBACK pec,
                          LPVOID pvRef, DWORD fl _THAT)

{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::EnumCreatedEffects,
               (_ "ppx", pdd, pec, fl));

    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = hresFullValidPfn(pec, 1)) &&
        SUCCEEDED(hres = hresFullValidFl(fl, DIECEFL_VALID, 3))) {
        PDD this = _thisPv(pdd);
        GPA gpaEff;

        CDIDev_EnterCrit(this);

        /*
         *  We must snapshot the list to make sure we don't run
         *  with a stale handle later.  Actually, we also need
         *  to Hold the guys as we transfer them across so they
         *  won't vanish until we're ready.
         *
         *  Note: It is important that we Hold and not AddRef,
         *  because AddRef will talk to the controlling unknown,
         *  which is not safe to do while holding a critical
         *  section.
         */

        hres = GPA_Clone(&gpaEff, &this->gpaEff);

        if (SUCCEEDED(hres)) {
            int ipv;

            for (ipv = 0; ipv < gpaEff.cpv; ipv++) {
                Common_Hold(gpaEff.rgpv[ipv]);
            }
        }

        CDIDev_LeaveCrit(this);

        if (SUCCEEDED(hres)) {
            int ipv;

            for (ipv = 0; ipv < gpaEff.cpv; ipv++) {
                BOOL fRc;

                fRc = Callback(pec, gpaEff.rgpv[ipv], pvRef);

                switch (fRc) {
                case DIENUM_STOP: goto enumdoneok;
                case DIENUM_CONTINUE: break;
                default:
                    RPF("%s: Invalid return value from callback", s_szProc);
                    ValidationException();
                    break;
                }

            }

        enumdoneok:;

            for (ipv = 0; ipv < gpaEff.cpv; ipv++) {
                Common_Unhold(gpaEff.rgpv[ipv]);
            }

            GPA_Term(&gpaEff);
        }

        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | GetLoad |
 *
 *          Retrieve the memory load setting for the device.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   LPDWORD | pdwLoad |
 *
 *          Receives memory load.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_GetLoad(PDD this, LPDWORD pdwOut)
{
    HRESULT hres;
    EnterProc(CDIDev_GetLoad, (_ "p", this));

    hres = CDIDev_CreateEffectDriver(this);

    if (SUCCEEDED(hres)) {
        DIDEVICESTATE ds;

        CDIDev_EnterCrit(this);

        /*
         *  Note that it isn't necessary to check
         *  CDIDev_IsExclAcquired(), because the effect shepherd
         *  will deny us access to a device we don't own.
         *
         *  ISSUE-2001/03/29-timgill Need to handle DIERR_INPUTLOST case
         */

        ds.dwSize = cbX(ds);
        /*
         *  Prefix raises a warning (mb:34564) that this->pes could 
         *  be NULL however CDIDev_CreateEffectDriver only succeeds 
         *  if it is not.
         */
        hres = this->pes->lpVtbl->
                    GetForceFeedbackState(this->pes, &this->sh, &ds);

        *pdwOut = ds.dwLoad;

        CDIDev_LeaveCrit(this);

    }

    /*
     *  Can't use ExitOleProcPpv here because pdwOut is garbage on error.
     */
    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | Escape |
 *
 *          Send a hardware-specific command to the driver.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Pointer to a <t DIEFFESCAPE> structure which describes
 *          the command to be sent.  On success, the
 *          <e DIEFFESCAPE.cbOutBuffer> field contains the number
 *          of bytes of the output buffer actually used.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_Escape(PV pdd, LPDIEFFESCAPE pesc _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInputDevice8::Escape, (_ "p", pdd));

    if (SUCCEEDED(hres = hresPvT(pdd)) &&
        SUCCEEDED(hres = hresFullValidPesc(pesc, 1))) {
        PDD this = _thisPv(pdd);

        AssertF(this->sh.dwEffect == 0);

        hres = CDIDev_CreateEffectDriver(this);

        if (SUCCEEDED(hres)) {

            CDIDev_EnterCrit(this);

            /*
             *  Note that it isn't necessary to check
             *  CDIDev_IsExclAcquired(), because the effect shepherd
             *  will deny us access to a device we don't own.
             *
             *  ISSUE-2001/03/29-timgill Need to handle DIERR_INPUTLOST case
             */

            /*
             *  Prefix raises a warning (mb:34564) that this->pes could 
             *  be NULL however CDIDev_CreateEffectDriver only succeeds 
             *  if it is not.
             */
            hres = IDirectInputEffectShepherd_DeviceEscape(
                                    this->pes, &this->sh, pesc);

            CDIDev_LeaveCrit(this);

        }

    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | RefreshGain |
 *
 *          Set the device gain setting appropriately.
 *
 *          The device shepherd will take care of muxing in the
 *          global gain.
 *
 *  @cwrap  PDD | this
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED>: The device is acquired,
 *          but not exclusively, or the device is not acquired
 *          at all.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The device
 *          does not support force feedback.
 *
 *****************************************************************************/

STDMETHODIMP
CDIDev_RefreshGain(PDD this)
{
    HRESULT hres;

    AssertF(CDIDev_InCrit(this));

    if (this->pes) {
        hres = this->pes->lpVtbl->SetGain(this->pes, &this->sh, this->dwGain);
    } else {
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDIDev | SnapOneEffect |
 *
 *          Read one force feedback effect key and record the
 *          information stored therein.  We also tally the
 *          flag into the <e CDIDev.didcFF> so we can return
 *          the global flags from <mf IDirectInputDevice::GetCapabilities>.
 *
 *          The <e CDIDev.rgemi> field already points to a
 *          preallocated array
 *          of <t EFFECTMAPINFO> structures, and
 *          the <e CDIDev.cemi> field contains the number
 *          of entries in that array which are already in use.
 *
 *  @cwrap  PDD | this
 *
 *  @parm   HKEY | hkEffects |
 *
 *          The registry key containing the effects.
 *
 *  @parm   DWORD | iKey |
 *
 *          Index number of the subkey.
 *
 *  @returns
 *
 *          None.
 *
 *          If the specified subkey is damaged, it is skipped.
 *
 *****************************************************************************/

void INTERNAL
CDIDev_SnapOneEffect(PDD this, HKEY hkEffects, DWORD ihk)
{
    TCHAR tszGuid[ctchGuid];
    LONG lRc;
    PEFFECTMAPINFO pemi;

    /*
     *  Make sure that DIEFT_* and DIDC_* agree where they overlap.
     */
    CAssertF(DIEFT_FORCEFEEDBACK      == DIDC_FORCEFEEDBACK);
    CAssertF(DIEFT_FFATTACK           == DIDC_FFATTACK);
    CAssertF(DIEFT_FFFADE             == DIDC_FFFADE);
    CAssertF(DIEFT_SATURATION         == DIDC_SATURATION);
    CAssertF(DIEFT_POSNEGCOEFFICIENTS == DIDC_POSNEGCOEFFICIENTS);
    CAssertF(DIEFT_POSNEGSATURATION   == DIDC_POSNEGSATURATION);

    pemi = &this->rgemi[this->cemi];

    /*
     *  First get the GUID for the effect.
     */
    lRc = RegEnumKey(hkEffects, ihk, tszGuid, cA(tszGuid));

    if (lRc == ERROR_SUCCESS &&
        ParseGUID(&pemi->guid, tszGuid)) {
        HKEY hk;

        /*
         *  Note that we don't need to check for duplicates.
         *  The registry itself does not allow two keys to have
         *  the same name.
         */

        lRc = RegOpenKeyEx(hkEffects, tszGuid, 0, KEY_QUERY_VALUE, &hk);
        if (lRc == ERROR_SUCCESS) {

            DWORD cb;

            cb = cbX(pemi->wszName);
            lRc = RegQueryStringValueW(hk, 0, pemi->wszName, &cb);
            if (lRc == ERROR_SUCCESS) {
                HRESULT hres;
                hres = JoyReg_GetValue(hk, TEXT("Attributes"), REG_BINARY,
                                       &pemi->attr, cbX(pemi->attr));
                if (SUCCEEDED(hres) &&
                    (pemi->attr.dwCoords & DIEFF_COORDMASK)) {

                    this->didcFF |= (pemi->attr.dwEffType & DIEFT_VALIDFLAGS);
                    this->cemi++;

                }
            }

            RegCloseKey(hk);
        }
    }
 }

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIDev | InitFF |
 *
 *          Initialize the force-feedback portion of the device.
 *
 *          Collect the force feedback attributes.
 *
 *          Snapshot the list of force feedback effects.
 *
 *  @cwrap  LPDIRECTINPUTDEVICE | lpDirectInputDevice
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:  Out of memory.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>:  The device
 *          does not support force feedback.
 *
 *****************************************************************************/
STDMETHODIMP
CDIDev_InitFF(PDD this)
{
    HKEY hkFF;
    HRESULT hres;
    EnterProcI(CDIDev_InitFF, (_ "p", this));

    AssertF(this->didcFF == 0);

    hres = this->pdcb->lpVtbl->GetFFConfigKey(this->pdcb,
                             KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                             &hkFF);

    if( hres == S_FALSE )
    {
        /*
         *  Try causing the driver to be loaded so that it can initialize 
         *  the effects in the registry before we proceed.
         * 
         *   Need to exercise caution here. A driver that expects to use this
         *   functionality cannot call into Dinput query for device attributes.
         *   Can result in endless loop where we call the driver and the driver
         *   calls us back
         */
        hres = CDIDev_CreateEffectDriver(this);
        if( SUCCEEDED( hres ) )
        {
            hres = this->pdcb->lpVtbl->GetFFConfigKey(this->pdcb,
                                     KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                     &hkFF);
            if( hres == S_FALSE )
            {
                hres = E_FAIL;
            }
        }
    }

    if (SUCCEEDED(hres)) {
        DWORD chk;
        HKEY hkEffects;
        LONG lRc;
        
        AssertF( hkFF );

        lRc = JoyReg_GetValue(hkFF, TEXT("Attributes"),
                              REG_BINARY, &this->ffattr, cbX(this->ffattr));
        if (lRc != S_OK) {
            ZeroX(this->ffattr);
        }

        lRc = RegOpenKeyEx(hkFF, TEXT("Effects"), 0,
                           KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                           &hkEffects);
        if (lRc == ERROR_SUCCESS) {
            lRc = RegQueryInfoKey(hkEffects, 0, 0, 0, &chk,
                                  0, 0, 0, 0, 0, 0, 0);
            if (lRc == ERROR_SUCCESS) {
                hres = AllocCbPpv(cbCxX(chk, EFFECTMAPINFO),
                                        &this->rgemi);
                if (SUCCEEDED(hres)) {
                    DWORD ihk;

                    this->cemi = 0;
                    for (ihk = 0; ihk < chk; ihk++) {

                        CDIDev_SnapOneEffect(this, hkEffects, ihk);

                    }
                    this->didcFF &= DIDC_FFFLAGS;

                    /*
                     *  Note that we mark DIDC_FORCEFEEDBACK only if
                     *  we actually find any effects.
                     */
                    if (this->cemi) {
                        this->didcFF |= DIDC_FORCEFEEDBACK;
                    }

                    hres = S_OK;
                } else {
                    RPF("Warning: Insufficient memory for force feedback");
                }

            } else {
                hres = E_FAIL;
            }
            RegCloseKey(hkEffects);

        } else {
            hres = E_NOTIMPL;
        }

        RegCloseKey(hkFF);
    }

    ExitBenignOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\didenum.c ===
/*****************************************************************************
 *
 *  DIDEnum.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The IDirectInput device enumerator.
 *
 *      We don't bother making this an honest OLE enumerator because
 *      there's no point.  There's no way to access it from the outside.
 *
 *  Contents:
 *
 *      CDIDEnum_New
 *      CDIDEnum_Next
 *      CDIDEnum_Release
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDEnum


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct _CDIDEnum |
 *
 *          Records the state of a device enumeration.  Note that this
 *          is not free-threaded.
 *
 *  @field  PDIW | pdiW |
 *
 *          The <i IDirectInputW> object that owns the enumeration.
 *
 *  @field  DWORD | dwDevType |
 *
 *          Device type filter.
 *
 *  @field  DWORD | edfl |
 *
 *          Enumeration flags.
 *
 *  @field  int | idosdStatic |
 *
 *          The next static device to enumerate.  Static devices live
 *          in <c c_rgdosdStatic>.
 *
 *  @field  DWORD | dwVer |
 *
 *          Version of DirectX we are emulating.
 *
 *          If we are emulating DirectX 3.0 or less, then don't
 *          reveal joysticks.
 *
 *  @field  int | idosdDynamic |
 *
 *          The next dynamic device to enumerate.  Dyanmic devices
 *          are kept in the <e CDIDEnum.rgdosdDynamic> array.  They
 *          are snapshotted into the enumeration structure to avoid
 *          race conditions if a device comes or goes while we are
 *          in the middle of an enumeration.
 *
 *  @field  PHIDDEVICELIST | phdl |
 *
 *          List of HID devices to be returned by the enumeration.
 *
 *****************************************************************************/

    typedef struct _CDIDEnum
    {
    
        D(DWORD dwSig;)
        PDIW pdiW;
        DWORD dwDevType;
        DWORD edfl;
        int idosdStatic;
        DWORD dwVer;
        int idosdDynamic;
        PHIDDEVICELIST phdl;
        PDIDW pdidW;
    } DENUM, *PDENUM, **PPDENUM;

    #define CDIDENUM_SIGNATURE  0x4D554E45          /* "ENUM" */

    #define AssertPde(pde)          AssertF((pde)->dwSig == CDIDENUM_SIGNATURE)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTSTATICDATA | c_rgdosdStatic[] |
 *
 *          Right now, the list of device is static and hard-coded.
 *          Eventually, we'll
 *          use plug and play to enumerate devices of class "input" and
 *          get information from their config/software keys.
 *
 *****************************************************************************/

    #pragma BEGIN_CONST_DATA

/*
 *  Our array of static joystick instance guids.
 *
 */
GUID rgGUID_Joystick[cJoyMax] = {
    {   0x6F1D2B70,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B71,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B72,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B73,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B74,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B75,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B76,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B77,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B78,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B79,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7A,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7B,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7C,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7D,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7E,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
    {   0x6F1D2B7F,0xD5A0,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00},
};

    #if cJoyMax != 16
        #error rgGUID_Joystick supports only 16 joysticks.
    #endif

/*
 *  Note that we recycle the SysMouse GUID as the instance GUID too,
 *  since there will never be more than one system mouse installed in
 *  the system.  Similarly for SysKeyboard.
 */

DIOBJECTSTATICDATA c_rgdosdStatic[] = {
    {   &GUID_SysMouse,     DI8DEVTYPE_MOUSE,    CMouse_New,},
    {   &GUID_SysMouseEm,   DI8DEVTYPE_MOUSE,    CMouse_New,},
    {   &GUID_SysMouseEm2,  DI8DEVTYPE_MOUSE,    CMouse_New,},
    {   &GUID_SysKeyboard,  DI8DEVTYPE_KEYBOARD, CKbd_New,},
    {   &GUID_SysKeyboardEm,   DI8DEVTYPE_KEYBOARD, CKbd_New,},
    {   &GUID_SysKeyboardEm2,  DI8DEVTYPE_KEYBOARD, CKbd_New,},

    #ifndef WINNT
    /*
     * On WINNT all joysticks are HID devices.
     * So it is pointless to include predefined
     * Joystick GUIDs
     */
        #define MAKEJOY(n)                                                  \
    {   &rgGUID_Joystick[n],DI8DEVCLASS_GAMECTRL, CJoy_New,           }
        MAKEJOY( 0),
    MAKEJOY( 1),
    MAKEJOY( 2),
    MAKEJOY( 3),
    MAKEJOY( 4),
    MAKEJOY( 5),
    MAKEJOY( 6),
    MAKEJOY( 7),
    MAKEJOY( 8),
    MAKEJOY( 9),
    MAKEJOY(10),
    MAKEJOY(11),
    MAKEJOY(12),
    MAKEJOY(13),
    MAKEJOY(14),
    MAKEJOY(15),

        #undef MAKEJOY
    #endif

};

    #pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFindInstanceGUID |
 *
 *          Locates information given an instance GUID.
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          The instance GUID to be located.
 *
 *  @parm   OUT CREATEDCB * | pcdcb |
 *
 *          Receives pointer to the <f CreateDcb> function for the object.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    hresFindInstanceGUID_(PCGUID pguid, CREATEDCB *pcdcb,
                          LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    EnterProcS(hresFindInstance, (_ "G", pguid));

    if(SUCCEEDED(hres = hresFullValidGuid(pguid, iarg)))
    {
        int idosd;

        /*
         *  First try the list of static devices.  Since this
         *  list never changes, we don't need to protect it
         *  with a critical section.
         */
        for(idosd = 0; idosd < cA(c_rgdosdStatic); idosd++)
        {
            if(IsEqualGUID(pguid, c_rgdosdStatic[idosd].rguidInstance))
            {
                *pcdcb = c_rgdosdStatic[idosd].CreateDcb;
                goto done;
            }
        }

        /*
         *  So it wasn't one of the static devices.  See if it's
         *  one of the dynamic HID devices we've already found.
         */
        hres = hresFindHIDInstanceGUID(pguid, pcdcb);
        if(FAILED(hres))
        {

            /*
             *  Not on our list of dynamic HID devices.
             *  Re-enumerate them and try again.  Maybe it was
             *  for a device that we recently added.
             */
            DIHid_BuildHidList(TRUE);
            hres = hresFindHIDInstanceGUID(pguid, pcdcb);
        }

        if(FAILED(hres))
        {
        #ifdef WINNT
            /*
             *  NT Bug#351951.
             *  If they are directly asking for one of the predefined joystick 
             *  IDs then see if we have a device mapped to that ID.  If so,
             *  pretend they asked for that GUID instead.
             */

            /*
             *  Weakly Assert the range of predefined static joystick instance GUIDs
             */
            AssertF( ( rgGUID_Joystick[0].Data1 & 0x0f ) == 0 );
            AssertF( ( rgGUID_Joystick[0x0f].Data1 & 0x0f ) == 0x0f );

            /*
             *  Check the GUID is the same as the first static one ignoring LS 4 bits
             */
            if( ( (pguid->Data1 & 0xf0) == (rgGUID_Joystick[0].Data1 & 0xf0) )
              && !memcmp( ((PBYTE)&rgGUID_Joystick)+1, ((PBYTE)pguid)+1, sizeof(*pguid) - 1 ) )
            {
                RPF("%s: Using predefined instance GUIDs is bad and should not work!", s_szProc);
                if( phdiFindJoyId( pguid->Data1 & 0x0f ) )
                {
                    *pcdcb = CHid_New;
                    hres = S_OK;
                }
                else
                {
                    *pcdcb = 0;
                    hres = DIERR_DEVICENOTREG;
                }
            }
            else
            {
                RPF("%s: Warning: GUID is not installed in this system", s_szProc);
                *pcdcb = 0;
                hres = DIERR_DEVICENOTREG;
            }
        #else
            RPF("%s: Warning: GUID is not installed in this system", s_szProc);
            *pcdcb = 0;
            hres = DIERR_DEVICENOTREG;
        #endif
        }
    }

    done:;
    ExitOleProcPpv(pcdcb);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIDEnum_Release |
 *
 *          Free the enumeration object and its associated resources.
 *
 *  @parm   CDIDEnum * | pde |
 *
 *          The enumeration state to be released.
 *
 *****************************************************************************/

void EXTERNAL
    CDIDEnum_Release(PDENUM pde)
{
    EnterProcI(CDIDEnum_Release, (_ "p", pde));

    AssertPde(pde);

    /*
     *  First, release any last enumerated device
     */
    if( pde->pdidW )
    {
        OLE_Release(pde->pdidW);
    }
    OLE_Release(pde->pdiW);
    FreePpv(&pde->phdl);
    FreePv(pde);

}



    #define S_SKIP      hresUs(2)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresIsDeviceTypeMatch |
 *
 *          Test if a device type matches the filter.
 *
 *  @parm   BYTE | bFilter |
 *
 *          The device type or class to filter by.
 *
 *  @parm   BYTE | bDevType |
 *
 *          The device type to be tested.
 *
 *  @returns
 *
 *          Returns <c S_OK> if the device matches the filter 
 *          or <c S_SKIP> if it does not.
 *
 *****************************************************************************/

HRESULT hresIsDeviceTypeMatch
( 
    BYTE bFilter,
    BYTE bDevType
)
{
    HRESULT hres;

    AssertF( bDevType >= DI8DEVTYPE_MIN );
    AssertF( bDevType < DI8DEVTYPE_MAX );

    if( ( bFilter == 0 )
     || ( bFilter == bDevType ) )
    
    {
        hres = S_OK;
    }
    else 
    {
        hres = S_SKIP;
        switch( bFilter )
        {
        case DI8DEVCLASS_DEVICE:
            if( bDevType == DI8DEVTYPE_DEVICE )
            {
                hres = S_OK;
            }
            break;
        case DI8DEVCLASS_POINTER:
            if( ( bDevType == DI8DEVTYPE_MOUSE )
             || ( bDevType == DI8DEVTYPE_SCREENPOINTER ) )
            {
                hres = S_OK;
            }
            break;
        case DI8DEVCLASS_KEYBOARD:
            if( bDevType == DI8DEVTYPE_KEYBOARD )
            {
                hres = S_OK;
            }
            break;
        case DI8DEVCLASS_GAMECTRL:
            if( (( bDevType >= DI8DEVTYPE_GAMEMIN )
              && ( bDevType < DI8DEVTYPE_GAMEMAX )) ||
                ( bDevType == DI8DEVTYPE_SCREENPOINTER ) ||  /* Windows bug 385284 (jacklin) - DI8DEVCLASS_GAMECTRL should   */
                ( bDevType == DI8DEVTYPE_SUPPLEMENTAL ) )    /* include DI8DEVTYPE_SCREENPOINTER and DI8DEVTYPE_SUPPLEMENTAL */
            {
                hres = S_OK;
            }
            break;
        }
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDEnum_Next |
 *
 *          Return the next device.
 *
 *          Note that this is not the same as the OLE <mf IEnumXxx::Next>
 *          function.  Not that it'd be hard to convert over; it's just
 *          not needed yet.
 *
 *  @parm   CDIDEnum * | pde |
 *
 *          Maintains enumeration state.
 *
 *  @parm   LPGUID | pguid |
 *
 *          Receives the enumerated GUID.
 *
 *  @parm   LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Receives device attributes.
 *
 *  @returns
 *
 *          Returns <c S_OK> if the object was successfully obtained,
 *          or <c S_FALSE> if there aren't any more objects.
 *
 *          Warning! <f CDIObj_EnumDevicesW> assumes that this function
 *          cannot fail.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDEnum_Next(PDENUM pde, LPDIDEVICEINSTANCEW pddiW)
{
    HRESULT hres;
    EnterProcI(CDIDEnum_Next, (_ "p", pde));

    AssertPde(pde);

    AssertF(pddiW->dwSize == cbX(*pddiW));


    /*
     *  Keep going until something works.
     */
    do
    {
        PDIOBJECTSTATICDATA pdosd;

        /*
         *  Release any previously enumerated or looked at device
         */
        if( pde->pdidW )
        {
            OLE_Release(pde->pdidW);
            pde->pdidW = NULL;
        }

        /*
         *  Pull one from the static list first.
         *  If that is empty, then pull from the dynamic list.
         *  If that is empty, then we're done.
         */
        if(pde->idosdStatic < cA(c_rgdosdStatic))
        {
            pdosd = &c_rgdosdStatic[pde->idosdStatic++];
        } else if(pde->phdl && pde->idosdDynamic < pde->phdl->chdi)
        {
            pdosd = &pde->phdl->rghdi[pde->idosdDynamic].osd;
            pdosd->rguidInstance = &pde->phdl->rghdi[pde->idosdDynamic].guid;
            pde->idosdDynamic++;
        } else
        {
            hres = S_FALSE;
            goto done;
        }

        /*
         *  ISSUE-2001/03/03-MarcAnd Filtered device enumerations are slow
         *  Since DI8DEVTYPEs can be generated on the fly and can be 
         *  overridden we can no longer filter before creating the device.
         *  This is badness.  Ideally, we need to add the WinMM and system 
         *  devices to our dynamic device list, tidy that info up and add 
         *  all the info we need to that list.
         */
        if( 1 ) 
        {

            hres = IDirectInput_CreateDevice(pde->pdiW, pdosd->rguidInstance,
                                             (PV)&pde->pdidW, 0);
            if(SUCCEEDED(hres))
            {
                if(CDIObj_TestDeviceFlags(pde->pdidW, pde->edfl) == S_OK)
                {
                    pddiW->dwSize = cbX(*pddiW);
                    hres = IDirectInputDevice_GetDeviceInfo(pde->pdidW, pddiW);

                    if( SUCCEEDED( hres ) )
                    {
                        AssertF( IsEqualGUID(pdosd->rguidInstance, &pddiW->guidInstance) );

                        hres = hresIsDeviceTypeMatch( GET_DIDEVICE_TYPE(pde->dwDevType), GET_DIDEVICE_TYPE(pddiW->dwDevType) );
                    }

                } else
                {
                    hres = S_SKIP;
                }
            } else
            {
                hres = S_SKIP;
            }
        } else
        {
            hres = S_SKIP;
        }
    } while(hres == S_SKIP);

    done:;

    AssertF(hres == S_OK || hres == S_FALSE);

    ScrambleBit(&pddiW->dwDevType, DIDEVTYPE_RANDOM);

    return hres;
}


STDMETHODIMP
    CDIDEnum_InternalNext(PDENUM pde, LPDIDEVICEINSTANCEW pddiW, LPDIRECTINPUTDEVICE8W *ppdid8W)
{
    HRESULT hres;
    EnterProcI(CDIDEnum_Next, (_ "p", pde));

    AssertPde(pde);

    AssertF(pddiW->dwSize == cbX(*pddiW));


    /*
     *  Keep going until something works.
     */
    do
    {
        PDIOBJECTSTATICDATA pdosd;

        /*
         *  Release any previously enumerated or looked at device
         */
        if( pde->pdidW )
        {
            OLE_Release(pde->pdidW);
            pde->pdidW = NULL;
        }

        /*
         *  Pull one from the static list first.
         *  If that is empty, then pull from the dynamic list.
         *  If that is empty, then we're done.
         */
        if(pde->idosdStatic < cA(c_rgdosdStatic))
        {
            pdosd = &c_rgdosdStatic[pde->idosdStatic++];
        } else if(pde->phdl && pde->idosdDynamic < pde->phdl->chdi)
        {
            pdosd = &pde->phdl->rghdi[pde->idosdDynamic].osd;
            pdosd->rguidInstance = &pde->phdl->rghdi[pde->idosdDynamic].guid;
            pde->idosdDynamic++;
        } else
        {
            hres = S_FALSE;
            goto done;
        }

        hres = IDirectInput_CreateDevice(pde->pdiW, pdosd->rguidInstance,
                                         (PV)&pde->pdidW, 0);
        if(SUCCEEDED(hres))
        {
            if(CDIObj_TestDeviceFlags(pde->pdidW, pde->edfl) == S_OK)
            {

                pddiW->dwSize = cbX(*pddiW);
                hres = IDirectInputDevice_GetDeviceInfo(pde->pdidW, pddiW);
                *ppdid8W = (LPDIRECTINPUTDEVICE8W)pde->pdidW;

                AssertF(fLimpFF(SUCCEEDED(hres),
                                IsEqualGUID(pdosd->rguidInstance,
                                            &pddiW->guidInstance)));

                /*
                 *  Do filtering here (see ISSUE in CDIDEnum_Next for why)
                 */
                hres = hresIsDeviceTypeMatch( GET_DIDEVICE_TYPE(pde->dwDevType), GET_DIDEVICE_TYPE(pddiW->dwDevType) );

            } else
            {
                hres = S_SKIP;
            }
        } else
        {
            hres = S_SKIP;
        }
    } while(hres == S_SKIP);

    done:;

    AssertF(hres == S_OK || hres == S_FALSE);

    ScrambleBit(&pddiW->dwDevType, DIDEVTYPE_RANDOM);

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIDEnum_New |
 *
 *          Create an enumeration object.
 *
 *          The enumeration object snapshots the system device state
 *          and farms them out one at a time.
 *
 *  @parm   PDIW | pdiW |
 *
 *          Parent <i IDirectInputW> we piggyback off of for device
 *          creation.
 *
 *  @field  DWORD | dwDevType |
 *
 *          Device type filter.
 *
 *  @field  DWORD | edfl |
 *
 *          Enumeration flags.
 *
 *  @field  DWORD | dwVer |
 *
 *          Version of DirectX we are emulating.
 *
 *          This should always be DirectX 8.0.
 *
 *  @parm   CDIDEnum ** | ppde |
 *
 *          Receives the enumeration object.
 *
 *  @returns
 *
 *          Returns <c S_OK> on success or an error code on failure.
 *
 *****************************************************************************/

STDMETHODIMP
    CDIDEnum_New(PDIW pdiW, DWORD dwDevType, DWORD edfl, DWORD dwVer, PPDENUM ppde)
{
    HRESULT hres;
    EnterProcI(CDIDEnum_New, (_ "pxx", pdiW, dwDevType, edfl));

    /*
     *  Refresh the HID device list so the enumeration is fresh.
     */
    DIHid_BuildHidList(TRUE);

    hres = AllocCbPpv(cbX(CDIDEnum), ppde);
    if(SUCCEEDED(hres))
    {
        PDENUM pde = *ppde;

        D(pde->dwSig = CDIDENUM_SIGNATURE);
        pde->pdiW = pdiW;
        pde->dwDevType = dwDevType;
        pde->edfl = edfl;
        pde->dwVer = dwVer;
        /*
         *  Make sure last enumerated device pointer is cleared
         */
        pde->pdidW = NULL;
        AssertF(pde->idosdStatic == 0);

        /*
         *  If enumerating only HID devices, then skip over all
         *  the static (non-HID) devices.  This is important so
         *  we don't go into infinite recursion death with WINMM.DLL,
         *  which does an enumeration to find HID joysticks
         *  in the first place.
         */
        if(pde->dwDevType & DIDEVTYPE_HID)
        {
            pde->idosdStatic = cA(c_rgdosdStatic);
        }

        AssertF(pde->idosdDynamic == 0);

        /*
         *  Clone the device list.  This must be done under the
         *  critical section to avoid races.
         */
        DllEnterCrit();
        if(g_phdl)
        {
            hres = AllocCbPpv(cbHdlChdi(g_phdl->chdi), &pde->phdl);
            if(SUCCEEDED(hres))
            {
                CopyMemory(pde->phdl, g_phdl, cbHdlChdi(g_phdl->chdi));
                SquirtSqflPtszV(sqfl, TEXT("%S: Have %d HID devices"),
                                s_szProc, pde->phdl->chdi);
                hres = S_OK;
            }
        } else
        {
            hres = S_OK;
        }
        DllLeaveCrit();

        if(SUCCEEDED(hres))
        {
            OLE_AddRef(pde->pdiW);
            hres = S_OK;
        }

    }

    ExitOleProcPpv(ppde);
    return hres;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dieffj.c ===
/*****************************************************************************
 *
 *  DIEffJ.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Dummy effect driver for joystick.
 *
 *  Contents:
 *
 *      CJoyEff_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef DEMONSTRATION_FFDRIVER

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoyEff

/****************************************************************************
 *
 *  @doc    DDK
 *
 *  @topic  DirectInput force feedback effect drivers |
 *
 *          DirectInput instantiates the force feedback effect driver
 *          by creating the object named by the CLSID stored in the
 *          OEMForceFeedback registry subkey of the joystick type
 *          key.
 *
 *          Note, however, that since applications using DirectInput
 *          need not load OLE, the effect driver should be careful
 *          not to rely on OLE-specific behavior.
 *          For example, applications using DirectInput cannot be
 *          relied upon to call <f CoFreeUnusedLibraries>.
 *          DirectInput will perform the standard COM operations to
 *          instantiate the effect driver object.  The only visible
 *          effect this should have on the implementation of the
 *          effect driver is as follows:
 *
 *          When DirectInput has released the last effect driver
 *          object, it will manually perform a <f FreeLibrary> of
 *          the effect driver DLL.  Consequently, if the effect
 *          driver DLL creates additional resources that are not
 *          associated with the effect driver object, it should
 *          manually <f LoadLibrary> itself to artificially
 *          increase its DLL reference count, thereby preventing
 *          the <f FreeLibrary> from DirectInput from unloading
 *          the DLL prematurely.
 *
 *          In particular, if the effect driver DLL creates a worker
 *          thread, the effect driver must perform this artificial
 *          <f LoadLibrary> for as long as the worker thread exists.
 *          When the worker thread is no longer needed (for example, upon
 *          notification from the last effect driver object as it
 *          is being destroyed), the worker thread should call
 *          <f FreeLibraryAndExitThread> to decrement the DLL reference
 *          count and terminate the thread.
 *
 *          All magnitude and gain values used by DirectInput
 *          are uniform and linear across the range.  Any
 *          nonlinearity in the physical device must be
 *          handled by the device driver so that the application
 *          sees a linear device.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CJoyEff_New!
 *
 *****************************************************************************/

Primary_Interface(CJoyEff, IDirectInputEffectDriver);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct JEFFECT |
 *
 *          Dummy structure that records information about an effect.
 *
 *  @field  DWORD | tmDuration |
 *
 *          Putative duration for effect.
 *
 *  @field  DWORD | tmStart |
 *
 *          Time the effect started, or zero if not playing.
 *
 *  @field  BOOL | fInUse |
 *
 *          Nonzero if this effect is allocated.
 *
 *****************************************************************************/

typedef struct JEFFECT {
    DWORD   tmDuration;
    DWORD   tmStart;
    BOOL    fInUse;
} JEFFECT, *PJEFFECT;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CJoyEff |
 *
 *          A dummy <i IDirectInputEffectDriver> object for the
 *          generic joystick.
 *
 *  @field  IDirectInputEffectDriver | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  BOOL | fCritInited:1 |
 *
 *          Set if the critical section has been initialized.
 *
 *  @field  DWORD | state |
 *
 *          The current device state.
 *
 *  @field  LONG | cCrit |
 *
 *          Number of times the critical section has been taken.
 *          Used only in XDEBUG to check whether the caller is
 *          releasing the object while another method is using it.
 *
 *  @field  DWORD | thidCrit |
 *
 *          The thread that is currently in the critical section.
 *          Used only in DEBUG for internal consistency checking.
 *
 *  @field  CRITICAL_SECTION | crst |
 *
 *          Object critical section.  Must be taken when accessing
 *          volatile member variables.
 *
 *  @field  JEFFECT | rgjeff[cjeffMax] |
 *
 *          Information for each effect.
 *
 *****************************************************************************/

#define cjeffMax        8           /* Up to 8 simultaneous effects */

typedef struct CJoyEff {

    /* Supported interfaces */
    IDirectInputEffectDriver ded;

    BOOL fCritInited;

    DWORD state;
    DWORD dwGain;

   RD(LONG cCrit;)
    D(DWORD thidCrit;)
    CRITICAL_SECTION crst;

    JEFFECT rgjeff[cjeffMax];

} CJoyEff, DJE, *PDJE;

typedef IDirectInputEffectDriver DED, *PDED;

#define ThisClass CJoyEff
#define ThisInterface IDirectInputEffectDriver
#define riidExpected &IID_IDirectInputEffectDriver

/*****************************************************************************
 *
 *      CJoyEff::QueryInterface   (from IUnknown)
 *      CJoyEff::AddRef           (from IUnknown)
 *      CJoyEff::Release          (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyEff | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyEff | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CJoyEff)
Default_AddRef(CJoyEff)
Default_Release(CJoyEff)

#else

#define CJoyEff_QueryInterface      Common_QueryInterface
#define CJoyEff_AddRef              Common_AddRef
#define CJoyEff_Release             Common_Release

#endif

#define CJoyEff_QIHelper            Common_QIHelper
#define CJoyEff_AppFinalize         Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CJoyEff_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CJoyEff_Finalize(PV pvObj)
{
    PDJE this = pvObj;

    if (this->fCritInited) {
        DeleteCriticalSection(&this->crst);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoyEff | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @cwrap  PDJE | this
 *
 *****************************************************************************/

void EXTERNAL
CJoyEff_EnterCrit(PDJE this)
{
    EnterCriticalSection(&this->crst);
  D(this->thidCrit = GetCurrentThreadId());
 RD(InterlockedIncrement(&this->cCrit));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoyEff | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *  @cwrap  PDJE | this
 *
 *****************************************************************************/

void EXTERNAL
CJoyEff_LeaveCrit(PDJE this)
{
#ifdef XDEBUG
    AssertF(this->cCrit);
    AssertF(this->thidCrit == GetCurrentThreadId());
    if (InterlockedDecrement(&this->cCrit) == 0) {
      D(this->thidCrit = 0);
    }
#endif
    LeaveCriticalSection(&this->crst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOL | CJoyEff | InCrit |
 *
 *          Nonzero if we are in the critical section.
 *
 *****************************************************************************/

#ifdef DEBUG

BOOL INTERNAL
CJoyEff_InCrit(PDJE this)
{
    return this->cCrit && this->thidCrit == GetCurrentThreadId();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyEff | IsValidId |
 *
 *          Determine whether the effect pseudo-handle is valid.
 *          If so, returns a pointer to the <t JEFFECT>.
 *
 *  @cwrap  PDJE | this
 *
 *  @parm   DWORD | dwId |
 *
 *          Putative ID number.
 *
 *  @parm   PJEFFECT * | ppjeff |
 *
 *          Receives pointer to the <t JEFFECT> on success.
 *
 *****************************************************************************/

HRESULT INTERNAL
CJoyEff_IsValidId(PDJE this, DWORD dwId, PJEFFECT *ppjeff)
{
    HRESULT hres;

    AssertF(CJoyEff_InCrit(this));

    if (dwId) {
        PJEFFECT pjeff = &this->rgjeff[dwId - 1];
        if (pjeff->fInUse) {
            *ppjeff = pjeff;
            hres = S_OK;
        } else {
            hres = E_HANDLE;
        }
    } else {
        hres = E_HANDLE;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | DeviceID |
 *
 *          Inform the driver of the identity of the device.
 *
 *          For example, if a device driver is passed
 *          <p dwExternalID> = 2 and <p dwInteralID> = 1,
 *          then this means that unit 1 on the device
 *          corresponds to joystick ID number 2.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwDirectInputVersion |
 *
 *          The version of DirectInput that loaded the
 *          effect driver.
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The joystick ID number being used.
 *          The Windows joystick subsystem allocates external IDs.
 *
 *          If the <p lpHIDInfo> field is non-<c NULL> then this
 *          parameter should be ignored.
 *
 *  @parm   DWORD | fBegin |
 *
 *          Nonzero if access to the device is beginning.
 *          Zero if the access to the device is ending.
 *
 *  @parm   DWORD | dwInternalID |
 *
 *          Internal joystick id.  The device driver manages
 *          internal IDs.
 *
 *          If the <p lpHIDInfo> field is non-<c NULL> then this
 *          parameter should be ignored.
 *
 *  @parm   LPVOID | lpHIDInfo |
 *
 *          If the underlying device is not a HID device, then this
 *          parameter is <c NULL>.
 *
 *          If the underlying device is a HID device, then this
 *          parameter points to a <t DIHIDFFINITINFO> structure
 *          which informs the driver of HID information.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_DeviceID(PDED pded, DWORD dwDIVer, DWORD dwExternalID, DWORD fBegin,
                 DWORD dwInternalID, LPVOID pvReserved)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::DeviceID,
               (_ "pxuuu", pded, dwDIVer, dwExternalID, fBegin, dwInternalID));

    this = _thisPvNm(pded, ded);

    dwDIVer;
    dwExternalID;
    fBegin;
    dwInternalID;
    pvReserved;

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | Escape |
 *
 *          Escape to the driver.  This method is called
 *          in response to an application invoking the
 *          <mf IDirectInputDevice8::Escape> method.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The joystick ID number being used.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          If the application invoked the
 *          <mf IDirectInputEffect::Escape> method, then
 *          <p dwEffect> contains the handle (returned by
 *          <mf IDirectInputEffectDriver::DownloadEffect>)
 *          of the effect at which the command is directed.
 *
 *          If the application invoked the
 *          <mf IDirectInputDevice8::Escape> method, then
 *          <p dwEffect> is zero.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Pointer to a <t DIEFFESCAPE> structure which describes
 *          the command to be sent.  On success, the
 *          <e DIEFFESCAPE.cbOutBuffer> field contains the number
 *          of bytes of the output buffer actually used.
 *
 *          DirectInput has already validated that the
 *          <e DIEFFESCAPE.lpvOutBuffer> and
 *          <e DIEFFESCAPE.lpvInBuffer> and fields
 *          point to valid memory.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_Escape(PDED pded, DWORD dwId, DWORD dwEffect, LPDIEFFESCAPE pesc)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::Escape,
               (_ "puxx", pded, dwId, dwEffect, pesc->dwCommand));

    this = _thisPvNm(pded, ded);

    dwId;
    dwEffect;
    pesc;

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | SetGain |
 *
 *          Set the overall device gain.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The joystick ID number being used.
 *
 *  @parm   DWORD | dwGain |
 *
 *          The new gain value.
 *
 *          If the value is out of range for the device, the device
 *          should use the nearest supported value and return
 *          <c DI_TRUNCATED>.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_SetGain(PDED pded, DWORD dwId, DWORD dwGain)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::SetGain,
               (_ "puu", pded, dwId, dwGain));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    this->dwGain = dwGain;

    CJoyEff_LeaveCrit(this);

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | SendForceFeedbackCommand |
 *
 *          Send a command to the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwCommand |
 *
 *          Command, one of the <c DISFFC_*> values.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_SendForceFeedbackCommand(PDED pded, DWORD dwId, DWORD dwCmd)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::SendForceFeedbackCommand,
               (_ "pux", pded, dwId, dwCmd));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    dwCmd;

    this->state = dwCmd;

    /*
     *  On a reset, all effects are destroyed.
     */
    if (dwCmd & DISFFC_RESET) {
        DWORD ijeff;

        for (ijeff = 0; ijeff < cjeffMax; ijeff++) {
            this->rgjeff[ijeff].fInUse = FALSE;
        }

    }

    CJoyEff_LeaveCrit(this);

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | GetForceFeedbackState |
 *
 *          Retrieve the force feedback state for the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   LPDEVICESTATE | pds |
 *
 *          Receives device state.
 *
 *          DirectInput will set the <e DIDEVICESTATE.dwSize> field
 *          to sizeof(DIDEVICESTATE) before calling this method.
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_GetForceFeedbackState(PDED pded, DWORD dwId, LPDIDEVICESTATE pds)
{
    PDJE this;
    HRESULT hres;
    DWORD ijeff, cjeff, cjeffPlaying;
    EnterProcI(IDirectInputEffectDriver::Joy::GetForceFeedbackState,
               (_ "pup", pded, dwId, pds));

    this = _thisPvNm(pded, ded);

    dwId;
    pds;

    if (pds->dwSize == cbX(*pds)) {
        CJoyEff_EnterCrit(this);

        /*
         *  Count how many effects are in use, and return it as a percentage.
         */
        cjeff = cjeffPlaying = 0;
        for (ijeff = 0; ijeff < cjeffMax; ijeff++) {
            PJEFFECT pjeff = &this->rgjeff[ijeff];
            if (pjeff->fInUse) {
                cjeff++;
                if (pjeff->tmStart &&
                    GetTickCount() - pjeff->tmStart < pjeff->tmDuration) {
                    cjeffPlaying++;
                }
            }
        }

        pds->dwLoad = MulDiv(100, cjeff, cjeffMax);

        /*
         *  If there are no effects downloaded, then we are empty.
         */
        pds->dwState = 0;

        if (cjeff == 0) {
            pds->dwState |= DIGFFS_EMPTY;
        } else

        /*
         *  If there are no effects playing, then we are stopped.
         */
        if (cjeffPlaying == 0) {
            pds->dwState |= DIGFFS_STOPPED;
        }

        /*
         *  Actuators are always on (dumb fake hardware)
         */
        pds->dwState |= DIGFFS_ACTUATORSON;

        CJoyEff_LeaveCrit(this);
        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | DownloadEffect |
 *
 *          Send an effect to the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffectId |
 *
 *          Internal identifier for the effect, taken from
 *          the <t DIEFFECTATTRIBUTES> structure for the effect
 *          as stored in the registry.
 *
 *  @parm   IN OUT LPDWORD | pdwEffect |
 *
 *          On entry, contains the handle of the effect being
 *          downloaded.  If the value is zero, then a new effect
 *          is downloaded.  If the value is nonzero, then an
 *          existing effect is modified.
 *
 *          On exit, contains the new effect handle.
 *
 *          On failure, set to zero if the effect is lost,
 *          or left alone if the effect is still valid with
 *          its old parameters.
 *
 *          Note that zero is never a valid effect handle.
 *
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The new parameters for the effect.  The axis and button
 *          values have been converted to object identifiers
 *          as follows:
 *
 *          - One type specifier:
 *          <c DIDFT_RELAXIS>,
 *          <c DIDFT_ABSAXIS>,
 *          <c DIDFT_PSHBUTTON>,
 *          <c DIDFT_TGLBUTTON>,
 *          <c DIDFT_POV>.
 *
 *          - One instance specifier:
 *          <c DIDFT_MAKEINSTANCE>(n).
 *
 *          Other bits are reserved and should be ignored.
 *
 *          For example, the value 0x0200104 corresponds to
 *          the type specifier <c DIDFT_PSHBUTTON> and
 *          the instance specifier <c DIDFT_MAKEINSTANCE>(1),
 *          which together indicate that the effect should
 *          be associated with button 1.  Axes, buttons, and POVs
 *          are each numbered starting from zero.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIEP_*> flags specifying which
 *          portions of the effect information has changed from
 *          the effect already on the device.
 *
 *          This information is passed to drivers to allow for
 *          optimization of effect modification.  If an effect
 *          is being modified, a driver may be able to update
 *          the effect <y in situ> and transmit to the device
 *          only the information that has changed.
 *
 *          Drivers are not, however, required to implement this
 *          optimization.  All fields in the <t DIEFFECT> structure
 *          pointed to by the <p peff> parameter are valid, and
 *          a driver may choose simply to update all parameters of
 *          the effect at each download.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          This implies that 0 is never a valid effect handle value.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_DownloadEffect(PDED pded, DWORD dwId, DWORD dwEffectId,
                       LPDWORD pdwEffect, LPCDIEFFECT peff, DWORD fl)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::DownloadEffect,
               (_ "puxxpx", pded, dwId, dwEffectId, *pdwEffect, peff, fl));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    fl;

    if (dwEffectId == 1) {

        PJEFFECT pjeff;
        DWORD dwGain;

        /*
         *  Parameter validation goes here, if any.
         *
         *  Envelope parameter is ignored.
         */

        if (peff->cAxes == 0) {     /* Zero axes?  Nice try */
            hres = E_INVALIDARG;
            goto done;
        }

        /*
         *  Pin above-nominal values to DI_FFNOMINALMAX because
         *  we don't support overgain.
         */
        dwGain = min(peff->dwGain, DI_FFNOMINALMAX);

        /*
         *  We do not support triggers.
         */
        if (peff->dwTriggerButton != DIEB_NOTRIGGER) {
            hres = E_NOTIMPL;
            goto done;
        }

        /*
         *  If no downloading in effect, then we're done.
         */
        if (fl & DIEP_NODOWNLOAD) {
            hres = S_OK;
            goto done;
        }

        if (*pdwEffect) {
            hres = CJoyEff_IsValidId(this, *pdwEffect, &pjeff);
            if (FAILED(hres)) {
                goto done;
            }
        } else {
            DWORD ijeff;

            for (ijeff = 0; ijeff < cjeffMax; ijeff++) {
                if (!this->rgjeff[ijeff].fInUse) {
                    this->rgjeff[ijeff].fInUse = TRUE;
                    pjeff = &this->rgjeff[ijeff];
                    goto haveEffect;
                }
            }
            hres = DIERR_DEVICEFULL;
            goto done;
        }

    haveEffect:;

        SquirtSqflPtszV(sqfl, TEXT("dwFlags=%08x"), peff->dwFlags);
        SquirtSqflPtszV(sqfl, TEXT("cAxes=%d"), peff->cAxes);
        for (fl = 0; fl < peff->cAxes; fl++) {
            SquirtSqflPtszV(sqfl, TEXT(" Axis%2d=%08x Direction=%5d"),
                            fl, peff->rgdwAxes[fl],
                                peff->rglDirection[fl]);
        }

        SquirtSqflPtszV(sqfl, TEXT("dwTrigger=%08x"), peff->dwTriggerButton);

        pjeff->tmDuration = peff->dwDuration / 1000;

        *pdwEffect = (DWORD)(pjeff - this->rgjeff) + 1;		//we are sure this cast will not cause problem
        hres = S_OK;

    } else {
        hres = E_NOTIMPL;
    }

done:;
    CJoyEff_LeaveCrit(this);

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | DestroyEffect |
 *
 *          Remove an effect from the device.
 *
 *          If the effect is playing, the driver should stop it
 *          before unloading it.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be destroyed.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_DestroyEffect(PDED pded, DWORD dwId, DWORD dwEffect)
{
    PDJE this;
    PJEFFECT pjeff;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::DestroyEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);
    dwId;

    hres = CJoyEff_IsValidId(this, dwEffect, &pjeff);
    if (SUCCEEDED(hres)) {
        pjeff->fInUse = 0;
    }

    CJoyEff_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | StartEffect |
 *
 *          Begin playback of an effect.
 *
 *          If the effect is already playing, then it is restarted
 *          from the beginning.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be played.
 *
 *  @parm   DWORD | dwMode |
 *
 *          How the effect is to affect other effects.
 *
 *          This parameter consists of zero or more
 *          <c DIES_*> flags.  Note, however, that the driver
 *          will never receive the <c DIES_NODOWNLOAD> flag;
 *          the <c DIES_NODOWNLOAD> flag is managed by
 *          DirectInput and not the driver.
 *
 *  @parm   DWORD | dwCount |
 *
 *          Number of times the effect is to be played.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_StartEffect(PDED pded, DWORD dwId, DWORD dwEffect,
                    DWORD dwMode, DWORD dwCount)
{
    PDJE this;
    PJEFFECT pjeff;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::StartEffect,
               (_ "puxxu", pded, dwId, dwEffect, dwMode, dwCount));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    hres = CJoyEff_IsValidId(this, dwEffect, &pjeff);
    if (SUCCEEDED(hres)) {
        if (pjeff->tmStart) {
            if (GetTickCount() - pjeff->tmStart < pjeff->tmDuration) {
                /* Already playing */
                hres = hresLe(ERROR_BUSY);
            } else {
                pjeff->tmStart = GetTickCount();
                hres = S_OK;
            }
        } else {
            pjeff->tmStart = GetTickCount();
            hres = S_OK;
        }
    }

    CJoyEff_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | StopEffect |
 *
 *          Halt playback of an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be stopped.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_StopEffect(PDED pded, DWORD dwId, DWORD dwEffect)
{
    PDJE this;
    PJEFFECT pjeff;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::StopEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    hres = CJoyEff_IsValidId(this, dwEffect, &pjeff);
    if (SUCCEEDED(hres)) {
        if (pjeff->tmStart) {
            if (GetTickCount() - pjeff->tmStart < pjeff->tmDuration) {
                /* It is still playing; stop it */
                hres = S_OK;
            } else {
                hres = S_FALSE;         /* It already stopped on its own */
            }
            pjeff->tmStart = 0;
        } else {
            hres = S_FALSE;         /* It was never started */
        }
    }

    CJoyEff_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | GetEffectStatus |
 *
 *          Obtain information about an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be queried.
 *
 *  @parm   LPDWORD | pdwStatus |
 *
 *          Receives the effect status.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_GetEffectStatus(PDED pded, DWORD dwId, DWORD dwEffect,
                        LPDWORD pdwStatus)
{
    PDJE this;
    PJEFFECT pjeff;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::StopEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    CJoyEff_EnterCrit(this);

    dwId;
    hres = CJoyEff_IsValidId(this, dwEffect, &pjeff);
    if (SUCCEEDED(hres)) {
        DWORD dwStatus;

        dwStatus = 0;
        if (pjeff->tmStart &&
            GetTickCount() - pjeff->tmStart < pjeff->tmDuration) {
            dwStatus |= DEV_STS_EFFECT_RUNNING;
        }
        *pdwStatus = dwStatus;
        hres = S_OK;
    }

    CJoyEff_LeaveCrit(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | GetVersions |
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   LPDIDRIVERVERSIONS | pvers |
 *
 *          A structure which should be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *          DirectInput will set the <e DIDRIVERVERSIONS.dwSize> field
 *          to sizeof(DIDRIVERVERSIONS) before calling this method.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_GetVersions(PDED pded, LPDIDRIVERVERSIONS pvers)
{
    PDJE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::GetVersions, (_ "pux", pded));

    this = _thisPvNm(pded, ded);

    /*
     *  Returning E_NOTIMPL causes DirectInput to ask the VxD for the same
     *  information.
     */
    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *      CJoyEff_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
CJoyEff_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::Joy::<constructor>,
               (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CJoyEff, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv if multiple interfaces supported */
        PDJE this = _thisPvNm(*ppvObj, ded);

        /*
         *  The critical section must be the very first thing we do,
         *  because only Finalize checks for its existence.
         *
         *  (We might be finalized without being initialized if the user
         *  passed a bogus interface to CJoyEff_New.)
         */
        this->fCritInited = fInitializeCriticalSection(&this->crst);
        if( !this->fCritInited )
        {
            Common_Unhold(this);
            *ppvObj = NULL;
            hres = E_OUTOFMEMORY;
        }
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CJoyEff_Signature        0x4645454B      /* "JEFF" */

Interface_Template_Begin(CJoyEff)
    Primary_Interface_Template(CJoyEff, IDirectInputEffectDriver)
Interface_Template_End(CJoyEff)

Primary_Interface_Begin(CJoyEff, IDirectInputEffectDriver)
    CJoyEff_DeviceID,
    CJoyEff_GetVersions,
    CJoyEff_Escape,
    CJoyEff_SetGain,
    CJoyEff_SendForceFeedbackCommand,
    CJoyEff_GetForceFeedbackState,
    CJoyEff_DownloadEffect,
    CJoyEff_DestroyEffect,
    CJoyEff_StartEffect,
    CJoyEff_StopEffect,
    CJoyEff_GetEffectStatus,
Primary_Interface_End(CJoyEff, IDirectInputEffectDriver)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diemm.c ===
/*****************************************************************************
 *
 *  DIEmM.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Emulation module for mouse.
 *
 *  Contents:
 *
 *      CEm_Mouse_CreateInstance
 *      CEm_Mouse_InitButtons
 *      CEm_LL_MseHook
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEm

/*****************************************************************************
 *
 *          Mouse globals
 *
 *****************************************************************************/

STDMETHODIMP CEm_Mouse_Acquire(PEM this, BOOL fAcquire);

DIMOUSESTATE_INT s_msEd;

ED s_edMouse = {
    &s_msEd,
    0,
    CEm_Mouse_Acquire,
    -1,
    cbX(DIMOUSESTATE_INT),
    0x0,
};

/*****************************************************************************
 *
 *      The algorithm for applying acceleration is:
 *
 *      dxC = dxR
 *      if A >= 1 and abs(dxR) > T1 then
 *          dxC = dxR * 2
 *          if A >= 2 and abs(dxR) > Thres2 then
 *              dxC = dxR * 4
 *          end if
 *      end if
 *
 *      where
 *          dxR is the raw mouse motion
 *          dxC is the cooked mouse motion
 *          A   is the acceleration
 *          T1  is the first threshold
 *          T2  is the second threshold
 *
 *      Repeat for dy instead of dx.
 *
 *      We can optimize this by simply setting the thresholds to MAXLONG
 *      if they are disabled; that way, abs(dx) will never exceed it.
 *
 *      The result is the following piecewise linear function:
 *
 *      if  0 < abs(dxR) <= T1:         dxC = dxR
 *      if T1 < abs(dxR) <= T2:         dxC = dxR * 2
 *      if T2 < abs(dxR):               dxC = dxR * 4
 *
 *      If you graph this function, you'll see that it's discontinuous!
 *
 *      The inverse mapping of this function is what concerns us.
 *      It looks like this:
 *
 *      if      0 < abs(dxC) <= T1:         dxR = dxC
 *      if T1 * 2 < abs(dxC) <= T2 * 2:     dxR = dxC / 2
 *      if T2 * 4 < abs(dxC):               dxR = dxC / 4
 *
 *      Notice that there are gaps in the graph, so we can fill them in
 *      any way we want, as long as it isn't blatantly *wrong*.  (In the
 *      case where we are using emulation, it is possible to get relative
 *      mouse motions that live in the "impossible" limbo zone due to
 *      clipping.)
 *
 *      if      0 < abs(dxC) <= T1:         dxR = dxC
 *      if T1     < abs(dxC) <= T2 * 2:     dxR = dxC / 2
 *      if T2 * 2 < abs(dxC):               dxR = dxC / 4
 *
 *      Therefore:          (you knew the punch line was coming)
 *
 *      s_rgiMouseThresh[0] = T1 (or MAXLONG)
 *      s_rgiMouseThresh[1] = T2 * 2 (or MAXLONG)
 *
 *
 *****************************************************************************/

static int s_rgiMouseThresh[2];

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_Mouse_OnMouseChange |
 *
 *          The mouse acceleration changed.  Go recompute the
 *          unacceleration variables.
 *
 *****************************************************************************/

void EXTERNAL
CEm_Mouse_OnMouseChange(void)
{
    int rgi[3];             /* Mouse acceleration information */

    /*
     *  See the huge comment block at the definition of
     *  s_rgiMouseThresh for an explanation of the math
     *  that is happening here.
     *
     *  If acceleration is enabled at all...
     */

    if (SystemParametersInfo(SPI_GETMOUSE, 0, &rgi, 0) && rgi[2]) {
        s_rgiMouseThresh[0] = rgi[0];

        if (rgi[2] >= 2) {
            s_rgiMouseThresh[1] = rgi[1] * 2;

        } else {        /* Disable level 2 acceleration */
            s_rgiMouseThresh[1] = MAXLONG;
        }

    } else {            /* Disable all acceleration */
        s_rgiMouseThresh[0] = MAXLONG;
    }

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_OnMouseChange: ")
                          TEXT("New accelerations %d / %d"),
                          s_rgiMouseThresh[0], s_rgiMouseThresh[1]);

}

/*****************************************************************************
 *
 *          Mouse emulation
 *
 *          Mouse emulation is done by subclassing the window that
 *          captured the mouse.  We then do the following things:
 *
 *          (1) Hide the cursor for the entire vwi.
 *
 *          (2) Capture the mouse.
 *
 *          (3) Clip the cursor to the window.  (If we let the cursor
 *              leave our window, then it messes up capture.)
 *
 *          (4) Keep re-centering the mouse whenever it moves.
 *
 *          (5) Release the capture on WM_SYSCOMMAND so we don't
 *              mess up menus, Alt+F4, etc.
 *
 *          If we are using NT low-level hooks then mouse emulation
 *          is done by spinning a thread to service ll hook
 *          notifications. The victim window is not subclassed.
 *
 *****************************************************************************/

#define dxMinMouse  10
#define dyMinMouse  10

typedef struct MOUSEEMULATIONINFO {
    POINT   ptCenter;               /* Center of client rectangle (screen coords) */
    POINT   ptCenterCli;            /* Center of client rectangle (client coords) */
    LPARAM  lpCenter;               /* ptCenter in the form of an LPARAM */

    BOOL    fInitialized:1;         /* Have we gotten started? */
    BOOL    fNeedExit:1;            /* Should we leave now? */
    BOOL    fExiting:1;             /* Are we trying to leave already? */
    BOOL    fCaptured:1;            /* Have we captured the mouse? */
    BOOL    fHidden:1;              /* Have we hidden the mouse? */
    BOOL    fClipped:1;             /* Have we clipped the mouse? */

    RECT    rcClip;                 /* ClipCursor rectangle */

} MOUSEEMULATIONINFO, *PMOUSEEMULATIONINFO;

LRESULT CALLBACK
CEm_Mouse_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                       UINT_PTR uid, ULONG_PTR dwRef);

/*****************************************************************************
 *
 *          CEm_Mouse_InitCoords
 *
 *
 *****************************************************************************/

BOOL INTERNAL
CEm_Mouse_InitCoords(HWND hwnd, PMOUSEEMULATIONINFO this)
{
    RECT rcClient;
    RECT rcDesk;

    GetClientRect(hwnd, &rcClient);
    MapWindowPoints(hwnd, 0, (LPPOINT)&rcClient, 2);

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_InitCoords: Client (%d,%d)-(%d,%d)"),
                    rcClient.left,
                    rcClient.top,
                    rcClient.right,
                    rcClient.bottom);

    /*
     *  Clip this with the screen, in case the window extends
     *  off-screen.
     *
     *  Someday: This will need to change when we get multiple monitors.
     */
    GetWindowRect(GetDesktopWindow(), &rcDesk);

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_InitCoords: Desk (%d,%d)-(%d,%d)"),
                    rcDesk.left,
                    rcDesk.top,
                    rcDesk.right,
                    rcDesk.bottom);

    IntersectRect(&this->rcClip, &rcDesk, &rcClient);

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_InitCoords: Clip (%d,%d)-(%d,%d)"),
                    this->rcClip.left,
                    this->rcClip.top,
                    this->rcClip.right,
                    this->rcClip.bottom);

    this->ptCenter.x = (this->rcClip.left + this->rcClip.right) >> 1;
    this->ptCenter.y = (this->rcClip.top + this->rcClip.bottom) >> 1;

    this->ptCenterCli.x = this->ptCenter.x - rcClient.left;
    this->ptCenterCli.y = this->ptCenter.y - rcClient.top;

    this->lpCenter = MAKELPARAM(this->ptCenterCli.x, this->ptCenterCli.y);

    SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_InitCoords: lpCenter (%d, %d)"),
                    MAKEPOINTS(this->lpCenter).x,
                    MAKEPOINTS(this->lpCenter).y);

    return this->rcClip.bottom - this->rcClip.top > dyMinMouse &&
           this->rcClip.right - this->rcClip.left > dxMinMouse;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_Mouse_OnSettingChange |
 *
 *          If the mouse acceleration changed, then update our globals
 *          so we can unaccelerate the mouse properly.
 *
 *  @parm   WPARAM | wp |
 *
 *          SystemParametersInfo value.
 *
 *  @parm   LPARAM | lp |
 *
 *          Name of section that changed.
 *
 *****************************************************************************/

void INTERNAL
CEm_Mouse_OnSettingChange(WPARAM wp, LPARAM lp)
{
    /*
     *  If wp is nonzero, then it is an SPI value.
     *
     *  If wp is zero, then be paranoid if lp == 0 or lp = "windows".
     */
    switch (wp) {

    case 0:                 /* wp == 0; must test lp */
        if (lp == 0) {
            CEm_Mouse_OnMouseChange();
        } else if (lstrcmpi((LPTSTR)lp, TEXT("windows")) == 0) {
            CEm_Mouse_OnMouseChange();
        }
        break;

    case SPI_SETMOUSE:
        CEm_Mouse_OnMouseChange();
        break;

    default:
        /* Some other SPI */
        break;
    }

}

/*****************************************************************************
 *
 *          CEm_Mouse_Subclass_OnNull
 *
 *          WM_NULL is a nudge message that makes us reconsider our
 *          place in the world.
 *
 *          We need this special signal because you cannot call
 *          SetCapture() or ReleaseCapture() from the wrong thread.
 *
 *****************************************************************************/

void INTERNAL
CEm_Mouse_Subclass_OnNull(HWND hwnd, PMOUSEEMULATIONINFO this)
{
    /*
     *  Initialize me if I haven't been already.
     */
    if (!this->fInitialized) {

        this->fInitialized = 1;

        if (!this->fCaptured) {
            this->fCaptured = 1;
            SetCapture(hwnd);
        }

        if (!this->fHidden) {
            this->fHidden = 1;
            SquirtSqflPtszV(sqflCursor,
                            TEXT("CEm_Mouse_Subclass: Hiding mouse"));
            ShowCursor(0);
        }

        /*
         *  Remove any clipping we performed so our math
         *  comes out right again.
         */
        if (this->fClipped) {
            this->fClipped = 0;
            ClipCursor(0);
        }

        /*
         *  (Re)compute mouse acceleration information.
         */
        CEm_Mouse_OnMouseChange();

        if (CEm_Mouse_InitCoords(hwnd, this)) {

            /*
             *  Force the LBUTTON up during the recentering move.
             *
             *  Otherwise, if the user activates the app by clicking
             *  the title bar, USER sees the cursor move while the
             *  left button is down on the title bar and moves the
             *  window.  Oops.
             *
             *  We don't bother forcing the mouse back down after we
             *  have recentered.  I can't figure out how, and it's
             *  not worth it.
             *
             */
            if (GetAsyncKeyState(VK_LBUTTON) < 0) {
                mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);
            }

            SetCursorPos(this->ptCenter.x, this->ptCenter.y);

            this->fClipped = 1;
            ClipCursor(&this->rcClip);

        } else {                    /* Can't emulate; window too small */
            this->fNeedExit = 1;
        }

    }

    if (this->fNeedExit && !this->fExiting) {

        /*
         *  Must do this first!  ReleaseCapture() will re-enter us,
         *  and if we continued onward, we'd end up partying on freed
         *  memory.
         */
        this->fExiting = 1;

        if (this->fCaptured) {
            ReleaseCapture();
        }
        if (this->fHidden) {
            SquirtSqflPtszV(sqflCursor,
                            TEXT("CEm_Mouse_Subclass: Showing mouse"));
            ShowCursor(1);
        }

        if (this->fClipped) {
            ClipCursor(0);
        }

        CEm_ForceDeviceUnacquire(&s_edMouse, FDUFL_NORMAL);

		// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_Subclass %p unhook"), hwnd);
        ConfirmF(RemoveWindowSubclass(hwnd, CEm_Mouse_SubclassProc, 0));
        FreePv(this);

    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_Mouse_RemoveAccel |
 *
 *          Remove any acceleration from the mouse motion.
 *
 *          See the huge comment block at s_rgiMouseThresh
 *          for an explanation of what we are doing.
 *
 *  @parm   int | dx |
 *
 *          Change in coordinate, either dx or dy.
 *
 *****************************************************************************/

int INTERNAL
CEm_Mouse_RemoveAccel(int dx)
{
    int x = abs(dx);
    if (x > s_rgiMouseThresh[0]) {
        dx /= 2;
        if (x > s_rgiMouseThresh[1]) {
            dx /= 2;
        }
    }
    return dx;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | CEm_Mouse_AddState |
 *
 *          Add a mouse state change.
 *
 *          The mouse coordinates are relative, not absolute.
 *
 *  @parm   LPDIMOUSESTATE_INT | pms |
 *
 *          New mouse state, except that coordinates are relative.
 *
 *  @parm   DWORD | tm |
 *
 *          Time the state change was generated.
 *
 *****************************************************************************/

void EXTERNAL
CEm_Mouse_AddState(LPDIMOUSESTATE_INT pms, DWORD tm)
{

    /* Sanity check: Make sure the device has been initialized */
    if( s_edMouse.pDevType ) 
    {
        pms->lX = s_msEd.lX + pms->lX;
        pms->lY = s_msEd.lY + pms->lY;

        /*
         *  HACK!
         *
         *  Memphis and NT5 USER both mess up the case where the presence
         *  of a wheel mouse changes dynamically.  So if we do not have
         *  a wheel in our data format, then don't record it.
         *
         *  The consequence of this is that we will not see any more
         *  buttons or wheels than were present when we queried the number
         *  of buttons in the first place.
         */

         /* If we use Subclassing, the movement of wheel can't be accumulated. 
          * Otherwise, you will see the number keep increasing. Fix bug: 182774.
          * However, if we use low level hook, we need the code. Fix bug: 238987
          */

#ifdef USE_SLOW_LL_HOOKS
       if (s_edMouse.pDevType[DIMOFS_Z]) {
           pms->lZ = s_msEd.lZ + pms->lZ;
       }
#endif

        CEm_AddState(&s_edMouse, pms, tm);
    }
}

/*****************************************************************************
 *
 *          Mouse window subclass procedure
 *
 *****************************************************************************/

#ifndef WM_MOUSEWHEEL
#define WM_MOUSEWHEEL   (WM_MOUSELAST + 1)
#endif

#define WM_SETACQUIRE   WM_USER
#define WM_QUITSELF     (WM_USER+1)

LRESULT CALLBACK
CEm_Mouse_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                       UINT_PTR uid, ULONG_PTR dwRef)
{
    PMOUSEEMULATIONINFO this = (PMOUSEEMULATIONINFO)dwRef;
    DIMOUSESTATE_INT ms;
	static BOOL  fWheelScrolling = FALSE;

    switch (wm) {

    case WM_NCDESTROY:
        SquirtSqflPtszV(sqfl, TEXT("CEm_Subclass: window destroyed while acquired"));
        goto unhook;

    case WM_CAPTURECHANGED:
        /*
         *  "An application should not attempt to set the mouse capture
         *   in response to [WM_CAPTURECHANGED]."
         *
         *  So we just unhook.
         */
        SquirtSqflPtszV(sqfl, TEXT("CEm_Subclass: %04x lost to %04x"),
                        hwnd, lp);
        goto unhook;

    case WM_SYSCOMMAND:
        /*
         *  We've got to unhook because WM_SYSCOMMAND will punt if
         *  the mouse is captured.  Otherwise, you couldn't type Alt+F4
         *  to exit the app, which is kind of a bummer.
         */

    unhook:;
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_Acquire: %p ")
                              TEXT("exiting because of %04x"), hwnd, wm);
        this->fNeedExit = 1;
        CEm_Mouse_Subclass_OnNull(hwnd, this);
        break;

    case WM_NULL:
        CEm_Mouse_Subclass_OnNull(hwnd, this);
        break;

    /*
     *  Note that we use WM_WINDOWPOSCHANGED and not WM_SIZE, because
     *  an application which doesn't send WM_WINDOWPOSCHANGED to
     *  DefWindowProc will will never receive a WM_SIZE message.
     *
     *  We need to start over to handle the new screen dimensions,
     *  recenter the mouse, and possibly abandon the operation if
     *  things don't look right.
     */
    case WM_WINDOWPOSCHANGED:
    case WM_DISPLAYCHANGE:
        this->fInitialized = 0;
        CEm_Mouse_Subclass_OnNull(hwnd, this);
        break;

    /*
     *  The mouse acceleration may have changed.
     */
    case WM_SETTINGCHANGE:
        CEm_Mouse_OnSettingChange(wp, lp);
        break;

    case WM_MOUSEWHEEL:
        SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_SubclassProc: (%d,%d,%d)"),
                        MAKEPOINTS(lp).x, MAKEPOINTS(lp).y, (short)HIWORD(wp));

        ms.lZ = (short)HIWORD(wp);
        fWheelScrolling = TRUE;

        goto lparam;

    case WM_MOUSEMOVE:
    case WM_LBUTTONDOWN:
    case WM_LBUTTONUP:
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
    case WM_RBUTTONDBLCLK:
    case WM_MBUTTONDOWN:
    case WM_MBUTTONUP:
    case WM_MBUTTONDBLCLK:
  #if defined(WINNT) && (_WIN32_WINNT >= 0x0500)
    case WM_XBUTTONDOWN:
    case WM_XBUTTONUP:
    case WM_XBUTTONDBLCLK:
  #endif

        SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_SubclassProc: (%d,%d)"),
                        MAKEPOINTS(lp).x, MAKEPOINTS(lp).y);

        ms.lZ = 0;
    lparam:;

        /*
         *  Don't move the cursor if it hasn't moved.
         *  Otherwise, we recurse ourselves to death.
         *
         *  In fact, if the cursor hasn't moved, ignore this
         *  motion and do only buttons.  Otherwise, you get
         *  into the situation where we end up reacting to
         *  our own recentering.  (D'oh!)
         */
        ms.lX = 0;
        ms.lY = 0;

        if (lp != this->lpCenter && !fWheelScrolling ) {
            SetCursorPos(this->ptCenter.x, this->ptCenter.y);
            ms.lX = MAKEPOINTS(lp).x - this->ptCenterCli.x;
            ms.lY = MAKEPOINTS(lp).y - this->ptCenterCli.y;
        }

        fWheelScrolling = FALSE;

        /*
         *  Note that these return unswapped mouse button data.
         *  Arguably a bug, but it's documented, so it's now a
         *  feature.
         */
        #define GetButton(n) ((GetAsyncKeyState(n) & 0x8000) >> 8)
        ms.rgbButtons[0] = GetButton(VK_LBUTTON);
        ms.rgbButtons[1] = GetButton(VK_RBUTTON);
        ms.rgbButtons[2] = GetButton(VK_MBUTTON);
    #if defined(WINNT) && (_WIN32_WINNT >= 0x0500)
        ms.rgbButtons[3] = GetButton(VK_XBUTTON1);
        ms.rgbButtons[4] = GetButton(VK_XBUTTON2);
    #else
        ms.rgbButtons[3] = 0;
        ms.rgbButtons[4] = 0;
    #endif        
        ms.rgbButtons[5] = 0;
        ms.rgbButtons[6] = 0;
        ms.rgbButtons[7] = 0;

        #undef GetButton

        /*
         *  Note that we cannot unaccelerate the mouse when using
         *  mouse capture, because we don't know what sort of
         *  coalescing USER has done for us.
         */

        CEm_Mouse_AddState(&ms, GetMessageTime());

        return 0;

    }

    return DefSubclassProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Mouse_Subclass_Acquire |
 *
 *          Acquire/unacquire a mouse via subclassing.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *  @parm   BOOL | fAcquire |
 *
 *          Whether the device is being acquired or unacquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Mouse_Subclass_Acquire(PEM this, BOOL fAcquire)
{
    HRESULT hres;
    EnterProc(CEm_Mouse_Subclass_Acquire, (_ "pu", this, fAcquire));

    AssertF(this->dwSignature == CEM_SIGNATURE);

    if (fAcquire) {                 /* Install the hook */
        if (this->vi.hwnd && (this->vi.fl & VIFL_CAPTURED)) {
            PMOUSEEMULATIONINFO pmei;
            /*
             *  Prefix considers this memory leaked (mb:34652) because we 
             *  don't save the pointer here.  The memory is freed when the 
             *  hook is removed so this is not really a problem.
             */
            hres = AllocCbPpv(cbX(MOUSEEMULATIONINFO), &pmei);
            if (SUCCEEDED(hres)) {
                if (SetWindowSubclass(this->vi.hwnd,
                                      CEm_Mouse_SubclassProc, 0,
                                      (ULONG_PTR)pmei)) {
                    /* Nudge it */
                    SendNotifyMessage(this->vi.hwnd, WM_NULL, 0, 0L);
                    hres = S_OK;
                } else {
                    // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
					SquirtSqflPtszV(sqfl,
                                    TEXT("Mouse::Acquire: ")
                                    TEXT("Window %p is not valid"),
                                    this->vi.hwnd);
                    FreePv(pmei);
                    hres = E_INVALIDARG;
                }
            }

        } else {
            RPF("Mouse::Acquire: Non-exclusive mode not supported");
            hres = E_FAIL;
        }
    } else {                        /* Remove the hook */
        PMOUSEEMULATIONINFO pmei;
        if (GetWindowSubclass(this->vi.hwnd, CEm_Mouse_SubclassProc,
                              0, (PULONG_PTR)&pmei)) {
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl, TEXT("CEm_Mouse_Acquire: ")
                                  TEXT("Telling %p to exit"), this->vi.hwnd);
            pmei->fNeedExit = 1;
            SendNotifyMessage(this->vi.hwnd, WM_NULL, 0, 0L);
        } else {                    /* Window was already unhooked */
        }
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Mouse_Acquire |
 *
 *          Acquire/unacquire a mouse.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *          Whether the device is being acquired or unacquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Mouse_Acquire(PEM this, BOOL fAcquire)
{
    HRESULT hres;
    EnterProc(CEm_Mouse_Acquire, (_ "pu", this, fAcquire));

    AssertF(this->dwSignature == CEM_SIGNATURE);

#ifdef USE_SLOW_LL_HOOKS
    AssertF(DIGETEMFL(this->vi.fl) == DIEMFL_MOUSE ||
            DIGETEMFL(this->vi.fl) == DIEMFL_MOUSE2);

    if (this->vi.fl & DIMAKEEMFL(DIEMFL_MOUSE)) {
        /* 
         *  This used to use the subclass technique for exclusive mode 
         *  even if low-level hooks were available because low-level 
         *  hooks turn out to be even slower that subclassing.  However, 
         *  subclassing is not transparent as it uses SetCapture which 
         *  causes Accellerator translation to be disabled for the app
         *  which would be a more serious regression from Win9x than 
         *  performance being even worse than we thought.
         */
        AssertF(g_fUseLLHooks);
        hres = CEm_LL_Acquire(this, fAcquire, this->vi.fl, LLTS_MSE);
        if( SUCCEEDED(hres) ) {
            if( fAcquire && this->vi.fl & VIFL_CAPTURED ) {
                if( !this->fHidden ) {
                    ShowCursor(0);
                    this->fHidden = TRUE;
                }
            } else {
                if( this->fHidden ) {
                    ShowCursor(1);
                    this->fHidden = FALSE;
                }
            }
        }
    } else {
        hres = CEm_Mouse_Subclass_Acquire(this, fAcquire);
    }
#else
    AssertF(DIGETEMFL(this->vi.fl) == DIEMFL_MOUSE2);
    hres = CEm_Mouse_Subclass_Acquire(this, fAcquire);
#endif

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Mouse_CreateInstance |
 *
 *          Create a mouse thing.  Also record what emulation
 *          level we ended up with so the caller knows.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_Mouse_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    HRESULT hres;

#ifdef USE_SLOW_LL_HOOKS
    /*
     *  Note carefully the test.  It handles the cases where
     *
     *  0.  The app did not ask for emulation, so we give it the
     *      best we can.  (dwEmulation == 0)
     *  1.  The app explicitly asked for emulation 1.
     *      (dwEmulation == DIEMFL_MOUSE)
     *  2.  The app explicitly asked for emulation 2.
     *      (dwEmulation == DIEMFL_MOUSE2)
     *  3.  The registry explicitly asked for both emulation modes.
     *      (dwEmulation == DIEMFL_MOUSE | DIEMFL_MOUSE2)
     *      Give it the best we can.  (I.e., same as case 0.)
     *
     *  All platforms support emulation 2.  Not all platforms support
     *  emulation 1.  If we want emulation 1 but can't get it, then
     *  we fall back on emulation 2.
     */

    /*
     *  First, if we don't have support for emulation 1, then clearly
     *  we have to use emulation 2.
     */
    
    if (!g_fUseLLHooks 
#ifdef DEBUG
        || (g_flEmulation & DIEMFL_MOUSE2)
#endif
    ) {
        pdevf->dwEmulation = DIEMFL_MOUSE2;
    } else

    /*
     *  Otherwise, we have to choose between 1 and 2.  The only case
     *  where we choose 2 is if 2 is explicitly requested.
     */
    if (pdevf->dwEmulation == DIEMFL_MOUSE2) {
        /* Do nothing */
    } else

    /*
     *  All other cases get 1.
     */
    {
        pdevf->dwEmulation = DIEMFL_MOUSE;
    }

    /*
     *  Assert that we never give emulation 1 when it doesn't exist.
     */
    AssertF(fLimpFF(pdevf->dwEmulation & DIEMFL_MOUSE, g_fUseLLHooks));
#else
    /*
     *  We are being compiled for "emulation 2 only", so that simplifies
     *  matters immensely.
     */
    pdevf->dwEmulation = DIEMFL_MOUSE2;
#endif

    hres = CEm_CreateInstance(pdevf, ppviOut, &s_edMouse);

    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Mouse_InitButtons |
 *
 *          Initialize the mouse button state in preparation for
 *          acquisition.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The button states.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_Mouse_InitButtons(PVXDDWORDDATA pvdd)
{
    /* Do this only when nothing is yet acquired */
    if (s_edMouse.cAcquire < 0) {
       *(LPDWORD)&s_msEd.rgbButtons = pvdd->dw;

        /* randomly initializing axes as well as mouse buttons
           X and Y are not buttons 
           Randomize initial values of X and Y */
        while( !s_msEd.lX )
        {
            s_msEd.lX = GetTickCount();
            s_msEd.lY = (s_msEd.lX << 16) | (s_msEd.lX >> 16);
            s_msEd.lX = s_msEd.lY * (DWORD)((UINT_PTR)&pvdd);
        }
    }
    return S_OK;
}

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CEm_LL_MseHook |
 *
 *          Low-level mouse hook filter.
 *
 *  @parm   int | nCode |
 *
 *          Notification code.
 *
 *  @parm   WPARAM | wp |
 *
 *          WM_* mouse message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Mouse message information.
 *
 *  @returns
 *
 *          Always chains to the next hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
CEm_LL_MseHook(int nCode, WPARAM wp, LPARAM lp)
{
    PLLTHREADSTATE plts;

    if (nCode == HC_ACTION) {
        DIMOUSESTATE_INT ms;
        POINT pt;
        PMSLLHOOKSTRUCT pllhs = (PV)lp;

        /*
         *  We are called only on mouse messages, so we may as
         *  well prepare ourselves up front.
         *
         *  Note! that we *cannot* use GetAsyncKeyState on the
         *  buttons, because the buttons haven't been pressed yet!
         *  Instead, we must update the button state based on the
         *  received message.
         */

        ms.lX = 0;
        ms.lY = 0;
        ms.lZ = 0;

        memcpy(ms.rgbButtons, s_msEd.rgbButtons, cbX(ms.rgbButtons));

        /*
         *
         *  Annoying!  We receive swapped buttons, so we need to
         *  unswap them.  I mark this as `annoying' because
         *  GetAsyncKeyState returns unswapped buttons, so sometimes
         *  I do and sometimes I don't.  But it isn't `*wrong*'
         *  because it is the right thing.  Arguably, GetAsyncKeyState
         *  is the one that is broken.
         */

        if (GetSystemMetrics(SM_SWAPBUTTON)) {

            /*
             *  Assert that the left and right button messages
             *  run in parallel.
             */

            CAssertF(WM_RBUTTONDOWN - WM_LBUTTONDOWN     ==
                     WM_RBUTTONDBLCLK - WM_LBUTTONDBLCLK &&
                     WM_RBUTTONDBLCLK - WM_LBUTTONDBLCLK ==
                     WM_RBUTTONUP     - WM_LBUTTONUP);

            switch (wp) {

            case WM_LBUTTONDOWN:
            case WM_LBUTTONDBLCLK:
            case WM_LBUTTONUP:
                wp = (wp - WM_LBUTTONUP) + WM_RBUTTONUP;
                break;

            case WM_RBUTTONDOWN:
            case WM_RBUTTONDBLCLK:
            case WM_RBUTTONUP:
                wp = (wp - WM_RBUTTONUP) + WM_LBUTTONUP;
                break;

            }
        }

        switch (wp) {           /* wp = message number */

        case WM_MOUSEWHEEL:
            SquirtSqflPtszV(sqfl, TEXT("CEm_LL_MseHook: (%d,%d,%d)"),
                            pllhs->pt.x,
                            pllhs->pt.y,
                            pllhs->mouseData);

            ms.lZ = (short int)HIWORD(pllhs->mouseData);
            goto lparam;

        case WM_LBUTTONDOWN:
        case WM_LBUTTONDBLCLK:
            ms.rgbButtons[0] = 0x80;
            goto move;

        case WM_LBUTTONUP:
            ms.rgbButtons[0] = 0x00;
            goto move;

        case WM_RBUTTONDOWN:
        case WM_RBUTTONDBLCLK:
            ms.rgbButtons[1] = 0x80;
            goto move;

        case WM_RBUTTONUP:
            ms.rgbButtons[1] = 0x00;
            goto move;

        case WM_MBUTTONDOWN:
        case WM_MBUTTONDBLCLK:
            ms.rgbButtons[2] = 0x80;
            goto move;

        case WM_MBUTTONUP:
            ms.rgbButtons[2] = 0x00;
            goto move;

    #if defined(WINNT) && (_WIN32_WINNT >= 0x0500)
        case WM_XBUTTONDOWN:
        case WM_XBUTTONDBLCLK:
            /*
             * Using switch can be easily extended to support more buttons.
             */
            switch ( HIWORD(pllhs->mouseData) ) {
            	case XBUTTON1:
            	    ms.rgbButtons[3] = 0x80;
            	    break;

            	case XBUTTON2:
            	    ms.rgbButtons[4] = 0x80;
            	    break;

                /*
                 * When we support more than 5 buttons, take care of them.
            	case XBUTTON3:
            	    ms.rgbButtons[5] = 0x80;
            	    break;

            	case XBUTTON4:
            	    ms.rgbButtons[6] = 0x80;
            	    break;

            	case XBUTTON5:
            	    ms.rgbButtons[7] = 0x80;
            	    break;
                 */
            }
            
            goto move;

        case WM_XBUTTONUP:
            /*
             * Using switch can be easily extended to support more buttons.
             */
            switch ( HIWORD(pllhs->mouseData) ) {
            	case XBUTTON1:
            	    ms.rgbButtons[3] = 0x00;
            	    break;

            	case XBUTTON2:
            	    ms.rgbButtons[4] = 0x00;
            	    break;
                /*
                 * When we support more than 5 buttons, take care of them.
            	case XBUTTON3:
            	    ms.rgbButtons[5] = 0x00;
            	    break;

            	case XBUTTON4:
            	    ms.rgbButtons[6] = 0x00;
            	    break;

            	case XBUTTON5:
            	    ms.rgbButtons[7] = 0x00;
            	    break;
                 */
            }
            goto move;
    #endif

        case WM_MOUSEMOVE:
            SquirtSqflPtszV(sqfl, TEXT("CEm_LL_MseHook: (%d,%d)"),
                            pllhs->pt.x, pllhs->pt.y);

        move:;

        lparam:;

            GetCursorPos(&pt);

            ms.lX = CEm_Mouse_RemoveAccel(pllhs->pt.x - pt.x);
            ms.lY = CEm_Mouse_RemoveAccel(pllhs->pt.y - pt.y);

            CEm_Mouse_AddState(&ms, GetTickCount());

        }

    }

    /*
     *  Eat the message by returning non-zero if at least one client 
     *  is exclusive.
     */

    plts = g_plts;
    if (plts) {
        LRESULT rc;

        rc = CallNextHookEx(plts->rglhs[LLTS_MSE].hhk, nCode, wp, lp);
        if (!plts->rglhs[LLTS_MSE].cExcl) {
            return rc;
        }
    } else {
        /*
         *  This can happen if a message gets posted to the hook after 
         *  releasing the last acquire but before we completely unhook.
         */
        RPF( "DINPUT: Mouse hook not passed on to next hook" );
    }

    return 1;
}


#endif  /* USE_SLOW_LL_HOOKS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diexcl.c ===
/*****************************************************************************
 *
 *  DIExcl.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Management and negotiation of exclusive access.
 *
 *  Contents:
 *
 *      Excl_Acquire
 *      Excl_Unacquire
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflExcl

#pragma BEGIN_CONST_DATA

#ifndef WINNT
TCHAR c_tszVxd[] = TEXT("\\\\.\\DINPUT.VXD");
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SHAREDOBJECT |
 *
 *          Each object that can be taken exclusively receives one of
 *          these structures.  This structure is shared across processes,
 *          so you must protect access with the global DLL mutex.
 *
 *          You would think that we could just use a named semaphore.
 *          Well, that won't work because if the app crashes, nobody
 *          will release the semaphore token and the device will be
 *          unavailable forever.
 *
 *          And we can't use a named mutex because mutexes are tracked
 *          on a per-thread basis, but device acquisition is maintained
 *          on a per-process basis.
 *
 *          So instead we have to roll our own "process-level mutex".
 *
 *          To conserve memory, we dump all our tiny <t SHAREDOBJECT>
 *          structures into a single page.  This means that we cannot
 *          support more than about 4000 / sizeof(SHAREDOBJECT) =
 *          140 devices simultaneously acquired exclusively.
 *
 *          Since USB maxes out at 64 devices, we've got plenty of room.
 *
 *          WARNING!  This structure may not change between DEBUG and
 *          RETAIL.  Otherwise, you have problems if one DirectInput
 *          app is using DEBUG and another is using RETAIL.
 *
 *  @field  GUID | guid |
 *
 *          The identifier for the device that is acquired exclusively.
 *
 *  @field  HWND | hwndOwner |
 *
 *          The window handle associated with the device that has
 *          obtained exclusive access.
 *
 *  @field  DWORD | pidOwner |
 *
 *          The process ID of the owner window.  This is used as a
 *          cross-check against <f hwndOwner> in case the application
 *          which is the owner suddenly crashes.
 *
 *  @field  DWORD | discl |
 *
 *          Cooperative level with which the device was acquired.
 *          We care about foreground-ness so that
 *          we can steal acquisition from a window that
 *          has stopped responding.
 *
 *****************************************************************************/

typedef struct SHAREDOBJECT
{
    GUID    guid;
    HWND    hwndOwner;
    DWORD   pidOwner;
    DWORD   discl;
} SHAREDOBJECT, *PSHAREDOBJECT;

typedef const SHAREDOBJECT *PCSHAREDOBJECT;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @define csoMax | (cbShared - cbX(SHAREDOBJECTHEADER)) / cbX(SHAREDOBJECT) |
 *
 *          The maximum number of simultaneously acquired devices.
 *
 *****************************************************************************/

    #define cbShared    4096
    #define csoMax ((cbShared - cbX(SHAREDOBJECTHEADER)) / cbX(SHAREDOBJECT))

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SHAREDOBJECTPAGE |
 *
 *          A header followed by an array of shared objects.
 *
 *          The header must be first.  <c g_soh> relies on it.
 *
 *  @field  SHAREDOBJECTHEADER | soh |
 *
 *          The header.
 *
 *  @field  SHAREDOBJECT | rgso[csoMax] |
 *
 *          Array of shared object structures.
 *
 *****************************************************************************/

typedef struct SHAREDOBJECTPAGE
{
    SHAREDOBJECTHEADER soh;
    SHAREDOBJECT rgso[csoMax];
} SHAREDOBJECTPAGE, *PSHAREDOBJECTPAGE;

void INLINE
    CheckSharedObjectPageSize(void)
{
    CAssertF(cbX(SHAREDOBJECTPAGE) <= cbShared);
    CAssertF(cbX(SHAREDOBJECTPAGE) + cbX(SHAREDOBJECT) > cbShared);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSHAREDOBJECT | Excl_FindGuid |
 *
 *          Locate a GUID in the shared object array.
 *
 *          The shared global mutex must already be taken.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to locate.
 *
 *  @returns
 *
 *          A pointer to the entry, or 0 if not found.
 *
 *
 *****************************************************************************/

PSHAREDOBJECT INTERNAL
    Excl_FindGuid(PCGUID pguid)
{
    PSHAREDOBJECTPAGE psop;
    PSHAREDOBJECT pso, psoMax;
    DWORD Data1;
    EnterProcI(Excl_FindGuid, (_ "G", pguid));

    psop = g_psop;
    Data1 = pguid->Data1;

    AssertF(g_psop);
    for(pso = &psop->rgso[0], psoMax = &psop->rgso[psop->soh.cso];
       pso < psoMax; pso++)
    {
        if(pso->guid.Data1 == Data1 && IsEqualGUID(pguid, &pso->guid))
        {
            goto done;
        }
    }

    pso = 0;

    done:;
    ExitProcX((UINT_PTR)pso);
    return pso;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Excl_CanStealPso |
 *
 *          Determine whether the <t SHAREDOBJECT> is self-consistent
 *          and represents an instance which validly holds the
 *          exclusive acquisition.  If so, then it cannot be stolen.
 *          Else, it is dead and can be stolen.
 *
 *  @parm   PCSHAREDOBJECT | pso |
 *
 *          The <t SHAREDOBJECT> structure to validate.
 *
 *  @returns
 *
 *          <c S_OK> if acquisition can be stolen, or
 *          <c DIERR_OTHERAPPHASPRIO> if acquisition is validly
 *          held by another instance.
 *
 *****************************************************************************/

STDMETHODIMP
    Excl_CanStealPso(PCSHAREDOBJECT pso)
{
    HRESULT hres = S_OK;

    /*
     *  The window handle should be valid and still refer to the pid.
     */
    if(GetWindowPid(pso->hwndOwner) == pso->pidOwner)
    {

        if( pso->discl & DISCL_FOREGROUND  )
        {
            if( GetForegroundWindow() != pso->hwndOwner)
            {
                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
				RPF("Acquire: can't steal Pso because it belongs to another app. (current hwnd=0x%p)",
                    pso->hwndOwner);
                hres = DIERR_OTHERAPPHASPRIO;
            } else
            {
                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
				RPF("Acquire: Current owner hwnd=0x%p has priority; "
                    "stealing", pso->hwndOwner);
                hres = S_OK;
            }
        }
    } else
    {
        /*
         *  App died.  Can steal.
         */
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		RPF("Acquire: Previous owner pid=0x%p mysteriously died; "
            "stealing", pso->pidOwner);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Excl_Acquire |
 *
 *          Attempt to acquire the device exclusively.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to acquire.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle with which to associate the device.
 *
 *  @parm   DWORD | discl |
 *
 *          Flags describing cooperative level.
 *          We are interested only in devices acquired exclusively.
 *
 *  @returns
 *
 *          S_OK on success, or
 *
 *          DIERR_OTHERAPPHASPRIO
 *          hresLe(ERROR_INVALID_WINDOW_HANDLE)
 *
 *
 *****************************************************************************/

STDMETHODIMP
    Excl_Acquire(PCGUID pguid, HWND hwnd, DWORD discl)
{
    HRESULT hres;

    AssertF(g_psop);
    if(discl & DISCL_EXCLUSIVE)
    {

        /*
         *  Window must be owned by this process.
         */
        if(GetWindowPid(hwnd) == GetCurrentProcessId())
        {

            PSHAREDOBJECT pso;

            WaitForSingleObject(g_hmtxGlobal, INFINITE);

            pso = Excl_FindGuid(pguid);

            /*
             *  If we found a match, then it might be a sharing violation.
             */
            if(pso)
            {
                hres = Excl_CanStealPso(pso);
            } else
            {
                /*
                 *  Allocate a slot for it.
                 */
                if(g_psop->soh.cso < csoMax)
                {
                    pso = &g_psop->rgso[g_psop->soh.cso++];
                    pso->guid = *pguid;
                    hres = S_OK;
                } else
                {
                    //ISSUE-2001/03/29-timgill hard limit on number of exclusive devices
                    //Can be annoying
                    RPF("Too many devices acquired exclusively");
                    hres = E_FAIL;
                }
            }

            if(SUCCEEDED(hres))
            {

                pso->hwndOwner = hwnd;
                pso->pidOwner = GetCurrentProcessId();
                pso->discl = discl;

                hres = S_OK;
            }

            ReleaseMutex(g_hmtxGlobal);
        } else
        {
            hres = hresLe(ERROR_INVALID_WINDOW_HANDLE);
        }
    } else
    {
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Excl_Unacquire |
 *
 *          Undo the effects of an acquire.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to acquire.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle with which to associate the device.
 *
 *  @parm   DWORD | discl |
 *
 *          Flags describing cooperative level.
 *          We are interested only in devices acquired exclusively.
 *
 *****************************************************************************/

void EXTERNAL
    Excl_Unacquire(PCGUID pguid, HWND hwnd, DWORD discl)
{

    AssertF(g_psop);
    if(discl & DISCL_EXCLUSIVE)
    {

        PSHAREDOBJECT pso;

        WaitForSingleObject(g_hmtxGlobal, INFINITE);

        pso = Excl_FindGuid(pguid);

        /*
         *  Make sure it's really ours.
         */
        if(pso && pso->hwndOwner == hwnd &&
           pso->pidOwner == GetCurrentProcessId())
        {

            /*
             *  Delete the entry and close up the gap.
             */

            *pso = g_psop->rgso[--g_psop->soh.cso];

        }

        ReleaseMutex(g_hmtxGlobal);

    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Excl_Init |
 *
 *          Initialize the exclusive device manager.
 *
 *  @returns
 *
 *          <c S_OK> if all is well.
 *
 *          <c E_FAIL> if something is horribly wrong.
 *
 *****************************************************************************/

STDMETHODIMP
    Excl_Init(void)
{
    HRESULT hres;
    TCHAR tszName[ctchNameGuid];

    DllEnterCrit();


    /*
     *  Create the global mutex used to gate access to shared memory.
     */

    if(g_hmtxGlobal == 0)
    {

        NameFromGUID(tszName, &IID_IDirectInputW);
        g_hmtxGlobal = CreateMutex(0, TRUE, tszName);

        if(g_hmtxGlobal)
        {
			/*
			 * If we need to do smth only once, we can do:
			 * if ( GetLastError() != ERROR_ALREADY_EXISTS )
			 * {
			 *		do our stuff
			 *	}
			 */
            
            g_flEmulation = RegQueryDIDword(NULL, REGSTR_VAL_EMULATION, 0);

#ifndef WINNT
            /*
             *  We have to open the VxD while we own the global mutex in order 
             *  to avoid a race condition that occurs when two processes try 
             *  to open a VxD at the same time.  See DInput VxD for details.
             */
            if (_OpenVxDHandle)
            {
                /*
                 *  CreateFile on a \\.\ name does not check the dwCreationDisposition 
                 *  parameter but BoundsChecker does so use a valid value.
                 */
                g_hVxD = CreateFile(c_tszVxd, 0, 0, 0, OPEN_EXISTING, FILE_FLAG_DELETE_ON_CLOSE, 0);

                if( g_hVxD != INVALID_HANDLE_VALUE )
                {
                    LONG lGranularity;

                    /*
                     *  If we can't get the sequence number (weird), then set it
                     *  back to NULL so it will point at the shared memory
                     *  block just like on NT.
                     */
                    if (FAILED(IoctlHw(IOCTL_GETSEQUENCEPTR, 0, 0,
                                       &g_pdwSequence, cbX(g_pdwSequence))))
                    {
                        g_pdwSequence = 0;
                    }

                    if (SUCCEEDED(IoctlHw(IOCTL_MOUSE_GETWHEEL, 0, 0,
                                          &lGranularity, cbX(lGranularity))))
                    {
                        g_lWheelGranularity = lGranularity;
                    }
                } 
                else
                {
                    RPF( "ERROR: Cannot load %s", &c_tszVxd[4] );
                }
            }
#endif
 
            /*
             *  We defer ExtDll work until now, because it is not safe to
             *  call LoadLibrary during PROCESS_ATTACH.
             *
             *  We also steal g_hmtxGlobal to protect us from doing it twice.
             */
            ExtDll_Init();


            ReleaseMutex(g_hmtxGlobal);

        } 
        else
        {
            RPF("Cannot create shared semaphore %s", tszName);
            hres = E_FAIL;
            goto fail;
        }

    }

    /*
     *  Create the shared memory.
     *
     *  Warning!  The file mapping handle must be kept alive
     *  so its name stays alive.  NT destroys the file mapping
     *  object when you close the handle; as a result, the
     *  name goes away with it and another instance of
     *  DirectInput fails to find it.
     */

    if(g_psop == 0)
    {

        NameFromGUID(tszName, &IID_IDirectInputDeviceW);

        g_hfm = CreateFileMapping(INVALID_HANDLE_VALUE, 0,
                                  PAGE_READWRITE, 0,
                                  cbShared, tszName);

        if(g_hfm)
        {
            g_psop = MapViewOfFile(g_hfm, FILE_MAP_WRITE | FILE_MAP_READ,
                                   0, 0, 0);
            if(g_psop)
            {

            } else
            {
                RPF("Cannot map shared memory block %s", tszName);
                hres = E_FAIL;
                goto fail;
            }

        } else
        {
            RPF("Cannot create shared memory block %s", tszName);
            hres = E_FAIL;
            goto fail;
        }
    }

    /*
     *  Create the global mutex used to gate access to joystick info.
     */

    if(g_hmtxJoy == 0)
    {
        NameFromGUID(tszName, &IID_IDirectInputDevice2A);
        g_hmtxJoy = CreateMutex(0, 0, tszName);

        if(g_hmtxJoy)
        {

        } else
        {
            RPF("Cannot create shared semaphore %s", tszName);
            hres = E_FAIL;
            goto fail;
        }
    
    
        /* 
         * We shall steal the joystick Mutex to build the Bus list
         * for the first time. 
         * It is very unlikely that the list will change. ( PCMCIA cards ! )
         * And when it does change we can expect the joyConfig interface will
         * be pinged.     
         */
        DIBus_BuildList(FALSE);
    }


    /*
     *  If we don't have a global sequence number from the driver,
     *  then use the one in the shared memory block instead.
     */
    if(g_pdwSequence == 0)
    {
        g_pdwSequence = &g_psoh->dwSequence;
    }
    
    hres = S_OK;

fail:;
    DllLeaveCrit();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | Excl_UniqueGuidInteger |
 *
 *          Generate a unique number used by DICreateGuid to make sure
 *          that we don't generate two pseudoGUIDs with the same value.
 *
 *  @returns
 *
 *          An integer that has not been returned by this function
 *          yet.
 *
 *****************************************************************************/

LONG EXTERNAL
    Excl_UniqueGuidInteger(void)
{
    LONG lRc;

    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    lRc = ++g_psop->soh.cguid;

    ReleaseMutex(g_hmtxGlobal);

    return lRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | Excl_GetConfigChangedTime |
 *
 *          Retrieves tmConfigChanged in g_psop->soh. 
 *
 *  @returns
 *
 *          tmConfigChanged
 *****************************************************************************/

DWORD EXTERNAL
    Excl_GetConfigChangedTime()
{
    DWORD dwRc;

    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    dwRc = g_psop->soh.tmConfigChanged;

    ReleaseMutex(g_hmtxGlobal);

    return dwRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | Excl_SetConfigChangedTime |
 *
 *          Sets tmConfigChanged in g_psop->soh. 
 *
 *  @returns
 *
 *          void
 *****************************************************************************/

void EXTERNAL
    Excl_SetConfigChangedTime(DWORD tm)
{
    AssertF(g_hmtxGlobal);

    WaitForSingleObject(g_hmtxGlobal, INFINITE);

    AssertF(g_psop);
    g_psop->soh.tmConfigChanged = tm;

    ReleaseMutex(g_hmtxGlobal);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diemk.c ===
/*****************************************************************************
 *
 *  DIEmK.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Emulation module for keyboard.
 *
 *  Contents:
 *
 *      CEm_Kbd_CreateInstance
 *      CEm_Kbd_InitKeys
 *      CEm_LL_KbdHook
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEm

/*****************************************************************************
 *
 *          Keyboard emulation
 *
 *****************************************************************************/

STDMETHODIMP CEm_Kbd_Acquire(PEM this, BOOL fAcquire);

static BYTE s_rgbKbd[DIKBD_CKEYS];
HHOOK g_hhkKbd;
LPBYTE g_pbKbdXlat;

ED s_edKbd = {
    &s_rgbKbd,
    0,
    CEm_Kbd_Acquire,
    -1,
    cbX(s_rgbKbd),
    0x0,
};

static BOOL s_fFarEastKbd;
static BOOL fKbdCaptured;
static BOOL fNoWinKey;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CEm_Kbd_KeyboardHook |
 *
 *          Thread-specific keyboard hook filter.
 *
 *          Note that we need only one of these, since only the foreground
 *          window will require a hook.
 *
 *  @parm   int | nCode |
 *
 *          Notification code.
 *
 *  @parm   WPARAM | wp |
 *
 *          VK_* code.
 *
 *  @parm   LPARAM | lp |
 *
 *          Key message information.
 *
 *  @returns
 *
 *          Always chains to the next hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
CEm_Kbd_KeyboardHook(int nCode, WPARAM wp, LPARAM lp)
{
    BYTE bScan = 0x0;
    BYTE bAction;
    LRESULT lr;
    
    if (nCode == HC_ACTION || nCode == HC_NOREMOVE) {
        bScan = LOBYTE(HIWORD(lp));
        
        if (HIWORD(lp) & KF_EXTENDED) {
            bScan |= 0x80;
        }
        if (HIWORD(lp) & KF_UP) {
            bAction = 0;
        } else {
            bAction = 0x80;
        }

        bScan = g_pbKbdXlat[bScan];

        if( s_fFarEastKbd )
        {
            /*
             *  Manually toggle these keys on make, ignore break
             */
            if( ( bScan == DIK_KANA ) 
              ||( bScan == DIK_KANJI ) 
              ||( bScan == DIK_CAPITAL ) )
            {
                if( bAction )
                {
                    bAction = s_rgbKbd[bScan] ^ 0x80;
                }
                else
                {
                    goto KbdHook_Skip;
                }
            }
        }

       CEm_AddEvent(&s_edKbd, bAction, bScan, GetMessageTime());
KbdHook_Skip:;
    }

    lr = CallNextHookEx(g_hhkKbd, nCode, wp, lp);

    if( fKbdCaptured ) {
        // test Alt+Tab
        if( ((HIWORD(lp) & KF_ALTDOWN) && (bScan == 0x0F))
            || ((bScan == 0x38 || bScan == 0xb8) && bAction == 0)
        ) {
        } else {
            return TRUE;
        }
    } else if (fNoWinKey) {
        //If left_Winkey or right_WinKey pressed. We really should use virtual keys
        // if we could, but unfortunately no virtual key info is available.
        if( bScan == 0xdb || bScan == 0xdc ) {
            return TRUE;
        }
    }

    return lr;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Kbd_Hook_Acquire |
 *
 *          Acquire/unacquire a keyboard via a thread hook.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *  @parm   BOOL | fAcquire |
 *
 *          Whether the device is being acquired or unacquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Kbd_Hook_Acquire(PEM this, BOOL fAcquire)
{
    HRESULT hres;
    EnterProc(CEm_Kbd_Hook_Acquire, (_ "pu", this, fAcquire));

    AssertF(this->dwSignature == CEM_SIGNATURE);

    DllEnterCrit();
    if (fAcquire) {                 /* Install the hook */
        if (this->vi.hwnd) {
            if (!g_hhkKbd) {
                g_hhkKbd = SetWindowsHookEx(WH_KEYBOARD,
                                CEm_Kbd_KeyboardHook, g_hinst,
                                GetWindowThreadProcessId(this->vi.hwnd, 0));
                hres = S_OK;
            }
			else
				hres = E_FAIL;  //already hooked
        } else {
            RPF("Kbd::Acquire: Background mode not supported");
            hres = E_FAIL;
        }
    } else {                        /* Remove the hook */
        UnhookWindowsHookEx(g_hhkKbd);
        g_hhkKbd = 0;
        hres = S_OK;
    }

    DllLeaveCrit();

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Kbd_Acquire |
 *
 *          Acquire/unacquire a keyboard in a manner consistent with the
 *          emulation level.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Kbd_Acquire(PEM this, BOOL fAcquire)
{
    HRESULT hres;
    EnterProc(CEm_Kbd_Acquire, (_ "pu", this, fAcquire));

    AssertF(this->dwSignature == CEM_SIGNATURE);

    fKbdCaptured = FALSE;
    fNoWinKey = FALSE;
    if( fAcquire ) {
       if( this->vi.fl & VIFL_CAPTURED ) {
           fKbdCaptured = TRUE;
       } else if( this->vi.fl & VIFL_NOWINKEY ) {
           fNoWinKey = TRUE;
       }
    }

#ifdef USE_SLOW_LL_HOOKS
    AssertF(DIGETEMFL(this->vi.fl) == DIEMFL_KBD ||
            DIGETEMFL(this->vi.fl) == DIEMFL_KBD2);

    if (this->vi.fl & DIMAKEEMFL(DIEMFL_KBD)) {
        AssertF(g_fUseLLHooks);
        hres = CEm_LL_Acquire(this, fAcquire, this->vi.fl, LLTS_KBD);
    } else {
        hres = CEm_Kbd_Hook_Acquire(this, fAcquire);
    }
#else
    AssertF(DIGETEMFL(this->vi.fl) == DIEMFL_KBD2);
    hres = CEm_Kbd_Hook_Acquire(this, fAcquire);
#endif

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Kbd_CreateInstance |
 *
 *          Create a keyboard thing.  Also record what emulation
 *          level we ended up with so the caller knows.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.  The
 *          <e VXDDEVICEFORMAT.dwEmulation> field is updated to specify
 *          exactly what emulation we ended up with.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_Kbd_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    LPBYTE pbKbdXlat;

#ifdef WINNT
    /* 
     * In Win2K/WinXP, for legacy free machine, GetKeyboardType will return
     * unreliable result for non-PS2 keyboard. We will use the first time result
     * from GetKeyboardType (for GUID_SysKeyboard) which is also used by Generic 
     * Input to do translation.
     * Related Windows bug: 363700.
     */
    if( !g_pbKbdXlat ) {
#endif        
        pbKbdXlat = (LPBYTE)pdevf->dwExtra;
        if (!pbKbdXlat) {
            pbKbdXlat = pvFindResource(g_hinst, IDDATA_KBD_PCENH, RT_RCDATA);
        }

        AssertF(pbKbdXlat);
        AssertF(fLimpFF(g_pbKbdXlat, g_pbKbdXlat == pbKbdXlat));
        g_pbKbdXlat = pbKbdXlat;
#ifdef WINNT
    }
#endif

#ifdef USE_SLOW_LL_HOOKS
    /*
     *  Note carefully the test.  It handles the cases where
     *
     *  0.  The app did not ask for emulation, so we give it the
     *      best we can.  (dwEmulation == 0)
     *  1.  The app explicitly asked for emulation 1.
     *      (dwEmulation == DIEMFL_KBD)
     *  2.  The app explicitly asked for emulation 2.
     *      (dwEmulation == DIEMFL_KBD2)
     *  3.  The registry explicitly asked for both emulation modes.
     *      (dwEmulation == DIEMFL_KBD | DIEMFL_KBD2)
     *      Give it the best we can.  (I.e., same as case 0.)
     *
     *  All platforms support emulation 2.  Not all platforms support
     *  emulation 1.  If we want emulation 1 but can't get it, then
     *  we fall back on emulation 2.
     */

    /*
     *  First, if we don't have support for emulation 1, then clearly
     *  we have to use emulation 2.
     */
    
    if (!g_fUseLLHooks 
#ifdef DEBUG
        || (g_flEmulation & DIEMFL_KBD2)
#endif
    ) {
        pdevf->dwEmulation = DIEMFL_KBD2;
    } else

    /*
     *  Otherwise, we have to choose between 1 and 2.  The only case
     *  where we choose 2 is if 2 is explicitly requested.
     */
    if (pdevf->dwEmulation == DIEMFL_KBD2) {
        /* Do nothing */
    } else

    /*
     *  All other cases get 1.
     */
    {
        pdevf->dwEmulation = DIEMFL_KBD;
    }

    /*
     *  Assert that we never give emulation 1 when it doesn't exist.
     */
    AssertF(fLimpFF(pdevf->dwEmulation & DIEMFL_KBD, g_fUseLLHooks));

    /*
     *  Assert that exactly one emulation flag is selected.
     */
    AssertF(pdevf->dwEmulation == DIEMFL_KBD ||
            pdevf->dwEmulation == DIEMFL_KBD2);
#else
    /*
     *  We are being compiled for "emulation 2 only", so that simplifies
     *  matters immensely.
     */
    pdevf->dwEmulation = DIEMFL_KBD2;
#endif

    return CEm_CreateInstance(pdevf, ppviOut, &s_edKbd);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Kbd_InitKeys |
 *
 *          Initialize pieces of the keyboard state in preparation for
 *          acquisition.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The states of the <c VK_KANA> and <c VK_CAPITAL> keys.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_Kbd_InitKeys(PVXDDWORDDATA pvdd)
{

    /* Do this only when not acquired */
    if (s_edKbd.cAcquire < 0) {
        ZeroX(s_rgbKbd);
        if (pvdd->dw & 1) {
            s_rgbKbd[DIK_KANA] = 0x80;
        }
        if (pvdd->dw & 2) {
            s_rgbKbd[DIK_CAPITAL] = 0x80;
        }
        if (pvdd->dw & 8) {
            s_rgbKbd[DIK_KANJI] = 0x80;
        }
        s_fFarEastKbd = ((pvdd->dw & 16)) != 0;
    }

    return S_OK;
}

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CEm_LL_KbdHook |
 *
 *          Low-level keyboard hook filter.
 *
 *  @parm   int | nCode |
 *
 *          Notification code.
 *
 *  @parm   WPARAM | wp |
 *
 *          WM_* keyboard message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Key message information.
 *
 *  @returns
 *
 *          Always chains to the next hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
CEm_LL_KbdHook(int nCode, WPARAM wp, LPARAM lp)
{
    PLLTHREADSTATE plts;
    PKBDLLHOOKSTRUCT pllhs = (PV)lp;

    if (nCode == HC_ACTION) {
        BYTE bScan = 0x0;
        BYTE bAction;
      D(DWORD tmStart = GetTickCount());

        wp;                         /* We don't care what the msg is */

        bScan = (BYTE)pllhs->scanCode;

        if( !bScan )
        {
            /* 
             *  ISSUE-2001/03/29-timgill  Special case for non-standard VK codes
             *  The bonus keys on some USB keyboards have zero scan code and 
             *  the extended key flag is clear.
             *  Get the scan code by mapping the VK, then map the 
             *  scan code back, if it is the same as the original VK assume 
             *  the scan code is not extended otherwise assume it is.
             *  This is no where near full proof and only works at all 
             *  because non-extended scan codes are matched first so extended 
             *  scan codes normally fail to translate back.
             */
            bScan = (BYTE)MapVirtualKey( pllhs->vkCode, 0 );
            if( MapVirtualKey( bScan, 3 ) != pllhs->vkCode )
            {
                bScan |= 0x80;
            }
        }
        else if (pllhs->flags & LLKHF_EXTENDED) {
            bScan |= 0x80;
        }

        if (pllhs->flags & LLKHF_UP) {
            bAction = 0;
        } else {
            bAction = 0x80;
        }

        bScan = g_pbKbdXlat[bScan];
        if( s_fFarEastKbd )
        {
            /*
             *  Manually toggle these keys on make, ignore break
             */
            if( ( bScan == DIK_KANA ) 
              ||( bScan == DIK_KANJI ) 
              ||( bScan == DIK_CAPITAL ) )
            {
                if( bAction )
                {
                    bAction = s_rgbKbd[bScan] ^ 0x80;
                }
                else
                {
                  D(SquirtSqflPtszV(sqflTrace | sqfl,
                                    TEXT("KBD! vk=%02x, scan=%02x, fl=%08x, tm=%08x")
                                    TEXT(" being skipped"),
                                    pllhs->vkCode, pllhs->scanCode, pllhs->flags,
                                    pllhs->time );)
                    goto LLKbdHook_Skip;
                }
            }
        }

        CEm_AddEvent(&s_edKbd, bAction, bScan, GetTickCount());

      D(SquirtSqflPtszV(sqflTrace | sqfl,
                        TEXT("KBD! vk=%02x, scan=%02x, fl=%08x, tm=%08x, ")
                        TEXT("in=%08x, out=%08x"),
                        pllhs->vkCode, pllhs->scanCode, pllhs->flags,
                        pllhs->time, tmStart, GetTickCount()));
LLKbdHook_Skip:;

    }

    /*
     *  ISSUE-2001/03/29-timgill  Need method for detecting Ctrl-Alt-Del
     *  If Ctrl+Alt+Del, then force global unacquire!
     *  Need to re-sync Ctrl, Alt, and Del on next keypress.
     *  Unfortunately, there is no way to find out if Ctrl+Alt+Del
     *  has been pressed...
     */

    plts = g_plts;
    if (plts) {
        LRESULT lr;

        lr = CallNextHookEx(plts->rglhs[LLTS_KBD].hhk, nCode, wp, lp);

        if( fKbdCaptured ) {
            if( ((pllhs->flags & LLKHF_ALTDOWN) && (pllhs->vkCode == VK_TAB)) ||
                ((pllhs->flags & LLKHF_UP) && (pllhs->vkCode == VK_LMENU || pllhs->vkCode == VK_RMENU))
            ) {
                return lr;
            } else {
                return TRUE;
            }
        } else if (fNoWinKey) {
            if( pllhs->vkCode == VK_LWIN || pllhs->vkCode == VK_RWIN ) {
                return TRUE;
            } else {
                return lr;
            }
        } else {
            return lr;
        }
    } else {
        /*
         *  This can happen if a message gets posted to the hook after 
         *  releasing the last acquire but before we completely unhook.
         */
        RPF( "DINPUT: Keyboard hook not passed on to next hook" );
        return 1;
    }

}

#endif  /* USE_SLOW_LL_HOOKS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diem.c ===
/*****************************************************************************
 *
 *  DIEm.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      DirectInput VxD emulation layer.  (I.e., do the things that
 *      dinput.vxd normally does.)  You may find large chunks of this
 *      code familiar:  It's exactly the same thing that happens in
 *      the VxD.
 *
 *  Contents:
 *
 *      CEm_AcquireInstance
 *      CEm_UnacquireInstance
 *      CEm_SetBufferSize
 *      CEm_DestroyInstance
 *      CEm_SetDataFormat
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEm

#define ThisClass CEm

#define CEM_SIGNATURE       0x4D4D4545      /* "EEMM" */

PEM g_pemFirst;

#ifdef WORKER_THREAD

PLLTHREADSTATE g_plts;      /* The currently active input thread */

#ifdef USE_WM_INPUT
  BOOL  g_fFromKbdMse;
#endif

#endif  /* WORKER_THREAD */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_FreeInstance |
 *
 *          It's really gone now.
 *
 *  @parm   PEM | this |
 *
 *          The victim.
 *
 *****************************************************************************/

void EXTERNAL
CEm_FreeInstance(PEM this)
{
    PEM *ppem;
    EnterProc(CEm_FreeInstance, (_ "p", this));

    AssertF(this->dwSignature == CEM_SIGNATURE);
    AssertF(this->cRef == 0);

    /*
     *  It is the owner's responsibility to unacquire before releasing.
     */
    AssertF(!(this->vi.fl & VIFL_ACQUIRED));

    /*
     *  If this device has a reference to a hook, then remove
     *  the reference.
     */
#ifdef WORKER_THREAD
    if (this->fWorkerThread) {
        PLLTHREADSTATE  plts;
        DWORD           idThread;

        /*
         *  Protect test and access of g_plts with DLLCrit
         */
        DllEnterCrit();
        plts = g_plts;

        if (plts ) {
            AssertF(plts->cRef);

            /*
             *  Note that we need to keep the thread ID because
             *  the InterlockedDecrement might cause us to lose
             *  the object.
             *
             *  Note that this opens a race condition where the
             *  thread might decide to kill itself before we
             *  post it the nudge message.  That's okay, because
             *  even if the thread ID gets recycled, the message
             *  that appears is a dummy WM_NULL message that
             *  causes no harm.
             */

            idThread = plts->idThread;      /* Must save before we dec */
            if( InterlockedDecrement(&plts->cRef) == 0 ) {
                g_plts = 0;
            }
        }

        DllLeaveCrit();

        if( plts )
        {
            NudgeWorkerThread(idThread);
        }
    }
#endif

    /*
     *  Unlink the node from the master list.
     */
    DllEnterCrit();
    for (ppem = &g_pemFirst; *ppem; ppem = &(*ppem)->pemNext) {
        AssertF((*ppem)->dwSignature == CEM_SIGNATURE);
        if (*ppem == this) {
            *ppem = (*ppem)->pemNext;
            break;
        }
    }
    AssertF(ppem);
    DllLeaveCrit();

    FreePpv(&this->rgdwDf);
    FreePpv(&this->vi.pBuffer);

    if( InterlockedDecrement(&this->ped->cRef) == 0x0 )
    {
        FreePpv(&this->ped->pDevType);
    }

    D(this->dwSignature++);

    FreePv(this);

    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_CreateInstance |
 *
 *          Create a device thing.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *  @parm   PED | ped |
 *
 *          Descriptor.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut, PED ped)
{
    HRESULT hres;
    EnterProc(CEm_CreateInstance, (_ "pp", pdevf, ped));

    AssertF(pdevf->cbData == ped->cbData);

    CAssertF(FIELD_OFFSET(CEm, vi) == 0);

    hres = AllocCbPpv(cbX(CEm), ppviOut);
    if (SUCCEEDED(hres)) {
        PEM pem = (PV)*ppviOut;

      D(pem->dwSignature = CEM_SIGNATURE);
        pem->dwExtra = pdevf->dwExtra;
        pem->ped = ped;
        pem->cAcquire = -1;
        /*
         *  Make sure these functions are inverses.
         */
        AssertF(DIGETEMFL(DIMAKEEMFL(pdevf->dwEmulation)) ==
                                     pdevf->dwEmulation);

        pem->vi.fl = VIFL_EMULATED | DIMAKEEMFL(pdevf->dwEmulation);
        pem->vi.pState = ped->pState;
        CEm_AddRef(pem);

        DllEnterCrit();
        /*
         *  Build the devtype array.  This consists of one dword
         *  for each byte in the data format.
         *
         *  Someday: Do the button thing too.
         */
        if (ped->pDevType == 0) {
            hres = ReallocCbPpv(cbCdw(pdevf->cbData), &ped->pDevType);
            if (SUCCEEDED(hres)) {
                UINT iobj;

                /*
                 *  If HID is messed up, we will end up with
                 *  entries whose dwType is zero (because HID
                 *  said they existed, but when we went around
                 *  enumerating, they never showed up).
                 *
                 *  And don't put no-data items into the array!
                 */
                for (iobj = 0; iobj < pdevf->cObj; iobj++) {
                    if (pdevf->rgodf[iobj].dwType &&
                        !(pdevf->rgodf[iobj].dwType & DIDFT_NODATA)) {
                        ped->pDevType[pdevf->rgodf[iobj].dwOfs] =
                                      pdevf->rgodf[iobj].dwType;
                    }
                }
            }
        } else {
            hres = S_OK;
        }

        if (SUCCEEDED(hres)) {
            /*
             *  Link this node into the list.  This must be done
             *  under the critical section.
             */
             pem->pemNext = g_pemFirst;
             g_pemFirst = pem;

             InterlockedIncrement(&ped->cRef);

            *ppviOut = &pem->vi;
        } else {
            FreePpv(ppviOut);
        }
        DllLeaveCrit();
    }

    ExitOleProcPpv(ppviOut);
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CEm_NextSequence |
 *
 *          Increment the sequence number wherever it may be.
 *
 *****************************************************************************/

DWORD INTERNAL
CEm_NextSequence(void)
{
    /*
     *  Stashing the value into a local tells the compiler that
     *  the value can be cached.  Otherwise, the compiler has
     *  to assume that InterlockedIncrement can modify g_pdwSequence
     *  so it keeps reloading it.
     */
    LPDWORD pdwSequence = g_pdwSequence;

    AssertF(pdwSequence);

    /*
     *  Increment through zero.
     */
    if (InterlockedIncrement((LPLONG)pdwSequence) == 0) {
        InterlockedIncrement((LPLONG)pdwSequence);
    }

    return *pdwSequence;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PEM | CEm_BufferEvent |
 *
 *          Add a single event to the device, returning the next device
 *          on the global list.
 *
 *          This routine is entered with the global critical section
 *          taken exactly once.
 *
 *****************************************************************************/

PEM INTERNAL
CEm_BufferEvent(PEM pem, DWORD dwData, DWORD dwOfs, DWORD tm, DWORD dwSeq)
{
    PEM pemNext;

    /*
     *  We must release the global critical section in order to take
     *  the device critical section.
     */
    CEm_AddRef(pem);                /* Make sure it doesn't vanish */

    DllLeaveCrit();
    AssertF(!InCrit());

    /*
     * ---Windows Bug 238305---
     * Run the buffering code in __try block so that if an
     * input is receive after the device is released, we can
     * catch the AV and clean up from there.
     */
    __try
    {
        CDIDev_EnterCrit(pem->vi.pdd);

        AssertF(dwOfs < pem->ped->cbData);
        AssertF(pem->rgdwDf);

        /*
         *  If the user cares about the object...
         */
        if (pem->rgdwDf[dwOfs] != 0xFFFFFFFF) {
            LPDIDEVICEOBJECTDATA_DX3 pdod = pem->vi.pHead;

            /*
             *  Set the node value.
             */

            pdod->dwOfs       = pem->rgdwDf[dwOfs];
            pdod->dwData      = dwData;
            pdod->dwTimeStamp = tm;
            pdod->dwSequence  = dwSeq;

            /*
             *  Append the node to the list if there is room.
             *  Note that we rely above on the fact that the list is
             *  never totally full.
             */
            pdod++;

            AssertF(pdod <= pem->vi.pEnd);

            if (pdod >= pem->vi.pEnd) {
                pdod = pem->vi.pBuffer;
            }

            /*
             * always keep the new data
             */
            pem->vi.pHead = pdod;

            if (pdod == pem->vi.pTail) {
                if (!pem->vi.fOverflow) {
                    RPF("Buffer overflow; discard old data");
                }

                pem->vi.pTail++;
                if (pem->vi.pTail == pem->vi.pEnd) {
                    pem->vi.pTail = pem->vi.pBuffer;
                }

                pem->vi.fOverflow = 1;
            }

        }

        CDIDev_LeaveCrit(pem->vi.pdd);
    }
    /*
     * If we get an AV, most likely input is received after the device has
     * been released.  In this case, we clean up the thread and exit as
     * soon as possible.
     */
    __except( GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
              EXCEPTION_EXECUTE_HANDLER :
              EXCEPTION_CONTINUE_SEARCH )
    {
        /* Do nothing here, so we clean up the thread and exit below. */
        RPF("CEm_BufferEvent: Access Violation catched! Most likely the device has been released");
    }

    DllEnterCrit();
    pemNext = pem->pemNext;
    AssertF(fLimpFF(pemNext, pemNext->dwSignature == CEM_SIGNATURE));
    CEm_Release(pem);
    return pemNext;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | CEm_ContinueEvent |
 *
 *          Add a single event to the queues of all acquired devices
 *          of the indicated type.
 *
 *  @returns
 *
 *          TRUE if someone is interested in this data (even if they are not 
 *          buffered).
 *
 *****************************************************************************/

BOOL EXTERNAL
CEm_ContinueEvent(PED ped, DWORD dwData, DWORD dwOfs, DWORD tm, DWORD dwSeq)
{
    DWORD ddwData;                  /* delta in dwData */
    BOOL  fRtn = FALSE;

    AssertF(!InCrit());

    /* Sanity check: Make sure the ped has been initialized */
    if (ped->pDevType) {
        PEM pem, pemNext;

        if (ped->pDevType[dwOfs] & DIDFT_DWORDOBJS) {
            DWORD UNALIGNED *pdw = pvAddPvCb(ped->pState, dwOfs);
            if (*pdw != dwData) {
                if (ped->pDevType[dwOfs] & DIDFT_POV ) {
                    ddwData = dwData;   /* Don't do deltas for POV */
                } else {
                    ddwData = dwData - *pdw;
                }
                *pdw = dwData;
            } else {
                goto nop;
            }
        } else {
            LPBYTE pb = pvAddPvCb(ped->pState, dwOfs);

            AssertF((dwData & ~0x80) == 0);

            if (*pb != (BYTE)dwData) {
                *pb = (BYTE)dwData;
                ddwData = dwData;       /* Don't do deltas for buttons */
                /* Someday: Button sequences go here */
            } else {
                goto nop;
            }
        }

        AssertF(!InCrit());         /* You can never be too paranoid */

        DllEnterCrit();
        for (pem = g_pemFirst; pem; pem = pemNext) {
            AssertF(pem->dwSignature == CEM_SIGNATURE);
            if ((pem->vi.fl & (VIFL_ACQUIRED|VIFL_INITIALIZE)) && pem->ped == ped) {

                if (pem->vi.pBuffer) {
                    if( pem->vi.fl & VIFL_RELATIVE )
                    {
                        pemNext = CEm_BufferEvent(pem, ddwData, dwOfs, tm, dwSeq);
                    }
                    else
                    {
                        pemNext = CEm_BufferEvent(pem, dwData, dwOfs, tm, dwSeq);
                    }
                    AssertF(fLimpFF(pemNext,
                                    pemNext->dwSignature == CEM_SIGNATURE));
                } else {
                    pemNext = pem->pemNext;
                    AssertF(fLimpFF(pemNext,
                                    pemNext->dwSignature == CEM_SIGNATURE));
                }
                /*
                 *  It would be easy to avoid setting the event if nothing 
                 *  was buffered but somebody would rely on getting them 
                 *  without setting a buffer.
                 */
                fRtn = TRUE;
            } else {
                pemNext = pem->pemNext;
                AssertF(fLimpFF(pemNext,
                                pemNext->dwSignature == CEM_SIGNATURE));
            }
        }
        DllLeaveCrit();
    }

nop:;
    return fRtn;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CEm_AddEvent |
 *
 *          Increment the DirectInput sequence number, then
 *          add a single event to the queues of all acquired devices
 *          of the indicated type.
 *
 *  @parm   PED | ped |
 *
 *          Device which is adding the event.
 *
 *  @parm   DWORD | dwData |
 *
 *          The event data.
 *
 *  @parm   DWORD | dwOfs |
 *
 *          Device data format-relative offset for <p dwData>.
 *
 *  @parm   DWORD | tm |
 *
 *          Time the event was generated.
 *
 *  @returns
 *
 *          Returns the sequence number added, so that it may be
 *          continued.
 *
 *****************************************************************************/

DWORD EXTERNAL
CEm_AddEvent(PED ped, DWORD dwData, DWORD dwOfs, DWORD tm)
{
    PEM pem, pemNext;

    DWORD dwSeq = CEm_NextSequence();

    AssertF(!InCrit());         /* You can never be too paranoid */

    if( CEm_ContinueEvent(ped, dwData, dwOfs, tm, dwSeq) )
    {
        DllEnterCrit();
        for (pem = g_pemFirst; pem; pem = pemNext) {
            AssertF(pem->dwSignature == CEM_SIGNATURE);
            if ((pem->vi.fl & VIFL_ACQUIRED) && pem->ped == ped) {
                CDIDev_SetNotifyEvent(pem->vi.pdd);
            }
            pemNext = pem->pemNext;
            AssertF(fLimpFF(pemNext,
                            pemNext->dwSignature == CEM_SIGNATURE));
        }
        DllLeaveCrit();
    }

    return dwSeq;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_AddState |
 *
 *          Record a brand new device state.
 *
 *  @parm   PED | ped |
 *
 *          Device which has changed state.
 *
 *  @parm   DWORD | dwData |
 *
 *          The value to record.
 *
 *  @parm   DWORD | tm |
 *
 *          Time the state change was generated.
 *
 *****************************************************************************/

void EXTERNAL
CEm_AddState(PED ped, LPVOID pvData, DWORD tm)
{
    DWORD dwSeq = CEm_NextSequence();

    /* Sanity check: Make sure the ped has been initialized */
    if (ped->pDevType) {
        DWORD dwOfs;
        BOOL  fEvent = FALSE;

        /*
         *  Note, it is too late to improve performance by only doing events 
         *  if somebody is listening.
         */
        dwOfs = 0;
        while (dwOfs < ped->cbData) {
            /*
             *  There shouldn't be any no-data items.
             */
            AssertF(!(ped->pDevType[dwOfs] & DIDFT_NODATA));

            if (ped->pDevType[dwOfs] & DIDFT_DWORDOBJS) {
                DWORD UNALIGNED *pdw = pvAddPvCb(pvData, dwOfs);
                if( CEm_ContinueEvent(ped, *pdw, dwOfs, tm, dwSeq) ){
                    fEvent = TRUE;
                }
                dwOfs += cbX(DWORD);
            } else {
                LPBYTE pb = pvAddPvCb(pvData, dwOfs);
                if( CEm_ContinueEvent(ped, *pb, dwOfs, tm, dwSeq) ) {
                    fEvent = TRUE;
                }
                dwOfs++;
            }
        }

        if( fEvent ) {
            PEM pem, pemNext;

            AssertF(!InCrit());         /* You can never be too paranoid */
    
            DllEnterCrit();
            for (pem = g_pemFirst; pem; pem = pemNext) {
                AssertF(pem->dwSignature == CEM_SIGNATURE);
                if ((pem->vi.fl & VIFL_ACQUIRED) && pem->ped == ped) {
                    CDIDev_SetNotifyEvent(pem->vi.pdd);
                }
                pemNext = pem->pemNext;
                AssertF(fLimpFF(pemNext,
                                pemNext->dwSignature == CEM_SIGNATURE));
            }
            DllLeaveCrit();
        }

    }
}

#if 0
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_InputLost |
 *
 *          Remove global hooks because something weird happened.
 *
 *          We don't need to do anything because our hooks are local.
 *
 *****************************************************************************/

HRESULT INLINE
CEm_InputLost(LPVOID pvIn, LPVOID pvOut)
{
    return S_OK;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_UnacquirePem |
 *
 *          Unacquire the device in the device-specific way.
 *
 *  @parm   PEM | pem |
 *
 *          Information about the gizmo being mangled.
 *
 *  @parm   UINT | fdufl |
 *
 *          Assorted flags describing why we are being unacquired.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_UnacquirePem(PEM this, UINT fdufl)
{
    HRESULT hres;
#ifdef DEBUG
    EnterProcR(CEm_UnacquirePem, (_ "px", this, fdufl));
#else
    EnterProcR(IDirectInputDevice8::Unacquire, (_ "p", this));
#endif

    AssertF(this->dwSignature == CEM_SIGNATURE);

    AssertF((fdufl & ~FDUFL_UNPLUGGED) == 0);
    CAssertF(FDUFL_UNPLUGGED == VIFL_UNPLUGGED);

    if (this->vi.fl & VIFL_ACQUIRED) {
        this->vi.fl &= ~VIFL_ACQUIRED;
        this->vi.fl |= fdufl;
        if (InterlockedDecrement(&this->cAcquire) < 0) {
            InterlockedDecrement(&this->ped->cAcquire);
            hres = this->ped->Acquire(this, 0);
        } else {
            SquirtSqflPtszV(sqfl, TEXT("%S: Still acquired %d"),
                            s_szProc, this->cAcquire);
            hres = S_OK;
        }
    } else {
        SquirtSqflPtszV(sqfl, TEXT("%S: Not acquired %d"),
                        s_szProc, this->cAcquire);
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_ForceDeviceUnacquire |
 *
 *          Force all users of a device to unacquire.
 *
 *  @parm   PEM | pem |
 *
 *          Information about the gizmo being mangled.
 *
 *  @parm   UINT | fdufl |
 *
 *          Assorted flags describing why we are being unacquired.
 *
 *****************************************************************************/

void EXTERNAL
CEm_ForceDeviceUnacquire(PED ped, UINT fdufl)
{
    PEM pem, pemNext;

    AssertF((fdufl & ~FDUFL_UNPLUGGED) == 0);

    AssertF(!DllInCrit());

    DllEnterCrit();
    for (pem = g_pemFirst; pem; pem = pemNext) {
        AssertF(pem->dwSignature == CEM_SIGNATURE);
        if (pem->ped == ped && (pem->vi.fl & VIFL_ACQUIRED)) {
            CEm_AddRef(pem);
            DllLeaveCrit();
            CEm_UnacquirePem(pem, fdufl);

            CDIDev_SetForcedUnacquiredFlag(pem->vi.pdd);
            /*
             *  Since this happens only when the device is acquired,
             *  we don't need to worry about the notify event changing
             *  asynchronously.
             */
            CDIDev_SetNotifyEvent(pem->vi.pdd);
            DllEnterCrit();
            pemNext = pem->pemNext;
            AssertF(pem->dwSignature == CEM_SIGNATURE);
            CEm_Release(pem);
        } else {
            pemNext = pem->pemNext;
            AssertF(pem->dwSignature == CEM_SIGNATURE);
        }
    }
    DllLeaveCrit();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_DestroyInstance |
 *
 *          Clean up an instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CEm_DestroyInstance(PVXDINSTANCE *ppvi)
{
    HRESULT hres;
    PEM this = _thisPvNm(*ppvi, vi);
    EnterProc(CEm_DestroyInstance, (_ "p", *ppvi));

    AssertF(this->dwSignature == CEM_SIGNATURE);
    AssertF((PV)this == (PV)*ppvi);

    if (this) {
        CEm_Release(this);
    }
    hres = S_OK;

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_SetDataFormat |
 *
 *          Record the application data format in the device so that
 *          we can translate it for buffering purposes.
 *
 *  @parm   PVXDDATAFORMAT | pvdf |
 *
 *          Information about the gizmo being mangled.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_SetDataFormat(PVXDDATAFORMAT pvdf)
{
    HRESULT hres;
    PEM this = _thisPvNm(pvdf->pvi, vi);
    EnterProc(CEm_SetDataFormat, (_ "p", pvdf->pvi));

    AssertF(this->dwSignature == CEM_SIGNATURE);
    hres = ReallocCbPpv( cbCdw(pvdf->cbData), &this->rgdwDf);
    if (SUCCEEDED(hres)) {
        AssertF(pvdf->cbData == this->ped->cbData);
        memcpy(this->rgdwDf, pvdf->pDfOfs, cbCdw(pvdf->cbData) );
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_AcquireInstance |
 *
 *          Acquire the device in the device-specific way.
 *
 *  @parm   PVXDINSTANCE * | ppvi |
 *
 *          The instance to acquire.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_AcquireInstance(PVXDINSTANCE *ppvi)
{
    HRESULT hres;
    PEM this = _thisPvNm(*ppvi, vi);
#ifdef DEBUG
    EnterProc(CEm_AcquireInstance, (_ "p", *ppvi));
#else
    EnterProcR(IDirectInputDevice8::Acquire, (_ "p", *ppvi));
#endif

    AssertF(this->dwSignature == CEM_SIGNATURE);
    this->vi.fl |= VIFL_ACQUIRED;
    if (InterlockedIncrement(&this->cAcquire) == 0) {
        InterlockedIncrement(&this->ped->cAcquire);
        hres = this->ped->Acquire(this, 1);
        if (FAILED(hres)) {
            this->vi.fl &= ~VIFL_ACQUIRED;
            InterlockedDecrement(&this->cAcquire);
        }
    } else {
        SquirtSqflPtszV(sqfl, TEXT("%S: Already acquired %d"),
                        s_szProc, this->cAcquire);
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_UnacquireInstance |
 *
 *          Unacquire the device in the device-specific way.
 *
 *  @parm   PVXDINSTANCE * | ppvi |
 *
 *          Information about the gizmo being mangled.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_UnacquireInstance(PVXDINSTANCE *ppvi)
{
    HRESULT hres;
    PEM this = _thisPvNm(*ppvi, vi);
    EnterProc(CEm_UnacquireInstance, (_ "p", *ppvi));

    hres = CEm_UnacquirePem(this, FDUFL_NORMAL);

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_SetBufferSize |
 *
 *          Allocate a buffer of the appropriate size.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The <p dwData> is the buffer size.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_SetBufferSize(PVXDDWORDDATA pvdd)
{
    HRESULT hres;
    PEM this = _thisPvNm(pvdd->pvi, vi);
    EnterProc(CEm_SetBufferSize, (_ "px", pvdd->pvi, pvdd->dw));

    AssertF(this->dwSignature == CEM_SIGNATURE);

    hres = ReallocCbPpv(cbCxX(pvdd->dw, DIDEVICEOBJECTDATA),
                        &this->vi.pBuffer);
    if (SUCCEEDED(hres)) {
        this->vi.pHead = this->vi.pBuffer;
        this->vi.pTail = this->vi.pBuffer;
        this->vi.pEnd  = &this->vi.pBuffer[pvdd->dw];
    }

    ExitOleProc();
    return hres;
}

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @struct LLHOOKINFO |
 *
 *          Information about how to install a low-level hook.
 *
 *  @field  int | idHook |
 *
 *          The Windows hook identifier.
 *
 *  @field  HOOKPROC | hp |
 *
 *          The hook procedure itself.
 *
 *****************************************************************************/

typedef struct LLHOOKINFO {

    int      idHook;
    HOOKPROC hp;

} LLHOOKINFO, *PLLHOOKINFO;
typedef const LLHOOKINFO *PCLLHOOKINFO;

#pragma BEGIN_CONST_DATA

const LLHOOKINFO c_rgllhi[] = {
    {   WH_KEYBOARD_LL, CEm_LL_KbdHook },   /* LLTS_KBD */
    {   WH_MOUSE_LL,    CEm_LL_MseHook },   /* LLTS_MSE */
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_LL_SyncHook |
 *
 *          Install or remove a hook as needed.
 *
 *  @parm   UINT | ilts |
 *
 *          Which hook is being handled?
 *
 *  @parm   PLLTHREADSTATE | plts |
 *
 *          Thread hook state containing hook information to synchronize.
 *
 *****************************************************************************/

void INTERNAL
CEm_LL_SyncHook(PLLTHREADSTATE plts, UINT ilts)
{
    PLLHOOKSTATE plhs = &plts->rglhs[ilts];

    if (!fLeqvFF(plhs->cHook, plhs->hhk)) {
        if (plhs->hhk) {
            UnhookWindowsHookEx(plhs->hhk);
            plhs->hhk = 0;
        } else {
            PCLLHOOKINFO pllhi = &c_rgllhi[ilts];
            plhs->hhk = SetWindowsHookEx(pllhi->idHook, pllhi->hp, g_hinst, 0);
        }
    }

}

#endif /* USE_SLOW_LL_HOOKS */

#ifdef WORKER_THREAD

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | FakeMsgWaitForMultipleObjectsEx |
 *
 *          Stub function which emulates
 *          <f MsgWaitForMultipleObjectsEx>
 *          on platforms that do not support it.
 *
 *          Such platforms (namely, Windows 95) do not support HID
 *          and therefore the inability to go into an alertable
 *          wait state constitutes no loss of amenity.
 *
 *  @parm   DWORD | nCount |
 *
 *          Number of handles in handle array.
 *
 *  @parm   LPHANDLE | pHandles |
 *
 *          Pointer to an object-handle array.
 *
 *  @parm   DWORD | ms |
 *
 *          Time-out interval in milliseconds.
 *
 *  @parm   DWORD | dwWakeMask |
 *
 *          Type of input events to wait for.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Wait flags.
 *
 *  @returns
 *
 *          Same as <f MsgWaitForMultipleObjectsEx>.
 *
 *****************************************************************************/

DWORD WINAPI
FakeMsgWaitForMultipleObjectsEx(
    DWORD nCount,
    LPHANDLE pHandles,
    DWORD ms,
    DWORD dwWakeMask,
    DWORD dwFlags)
{
    /*
     *  We merely call the normal MsgWaitForMultipleObjects because
     *  the only way we can get here is on a platform that doesn't
     *  support HID.
     */
    return MsgWaitForMultipleObjects(nCount, pHandles,
                                     dwFlags & MWMO_WAITALL, ms, dwWakeMask);
}

#ifdef WINNT
// On win2k non-exclusive mode user thinks the Dinput thread is hung.
// In order to fix this we set a TimerEvent and wake up every so 
// often and execute the FakeTimerProc. This keeps user happy and
// keeps dinput thread from being marked as hung and we can get 
// events to our low level hooks
VOID CALLBACK FakeTimerProc(
  HWND hwnd,         // handle to window
  UINT uMsg,         // WM_TIMER message
  UINT_PTR idEvent,  // timer identifier
  DWORD dwTime       // current system time
)
{
}
#endif

#ifdef USE_WM_INPUT

#pragma BEGIN_CONST_DATA
TCHAR c_szEmClassName[] = TEXT("DIEmWin");
#pragma END_CONST_DATA

/****************************************************************************
 *
 *      CEm_WndProc
 *
 *      Window procedure for simple sample.
 *
 ****************************************************************************/

LRESULT CALLBACK
CEm_WndProc( HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam )
{
    switch (msg) {
    //case WM_INPUT:
    //    RPF("in WM_INPUT message");
    //    break;

    default:
        break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

HWND 
CEm_InitWindow(void)
{
    HWND hwnd;
    WNDCLASS wc;
    static BOOL fFirstTime = TRUE;

    if( fFirstTime ) {
        wc.hCursor        = LoadCursor(0, IDC_ARROW);
        wc.hIcon          = LoadIcon(NULL, MAKEINTRESOURCE(IDI_APPLICATION));
        wc.lpszMenuName   = NULL;
        wc.lpszClassName  = c_szEmClassName;
        wc.hbrBackground  = 0;
        wc.hInstance      = g_hinst;
        wc.style          = 0;
        wc.lpfnWndProc    = CEm_WndProc;
        wc.cbClsExtra     = 0;
        wc.cbWndExtra     = 0;

        if (!RegisterClass(&wc)) {
            return NULL;
        }

        fFirstTime = FALSE;
    }
    
    hwnd = CreateWindow(
                    c_szEmClassName,                     // Class name
                    TEXT("DIEmWin"),                     // Caption
                    WS_OVERLAPPEDWINDOW,                 // Style
                    -1, -1,                              // Position
                    1, 1,                                // Size
                    NULL,                                //parent
                    NULL,                                // No menu
                    g_hinst,                             // inst handle
                    0                                    // no params
                    );

    if( !hwnd ) {
        RPF("CreateWindow failed.");
    }

    return hwnd;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   VOID | CEm_LL_ThreadProc |
 *
 *          The thread that manages our low-level hooks.
 *
 *          ThreadProcs are prototyped to return a DWORD but since the return
 *          would follow some form of ExitThread, it will never be reached so
 *          this function is declared to return VOID and cast.
 *
 *          When we get started, and whenever we receive any message
 *          whatsoever, re-check to see which hooks should be installed
 *          and re-synchronize ourselves with them.
 *
 *          Note that restarting can be slow, since it happens only
 *          when we get nudged by a client.
 *
 *  @parm   PLLTHREADSTATE | plts |
 *
 *          The thread state to use.
 *
 *****************************************************************************/

VOID INTERNAL
CEm_LL_ThreadProc(PLLTHREADSTATE plts)
{
    MSG msg;
    DWORD dwRc;
  #ifdef USE_WM_INPUT
    HWND hwnd = NULL;
  #endif

    AssertF(plts->idThread == GetCurrentThreadId());
    SquirtSqflPtszV(sqflLl, TEXT("CEm_LL_ThreadProc: Thread started"));

  #ifdef USE_SLOW_LL_HOOKS
    /*
     *  Refresh the mouse acceleration values.
     *
     *  ISSUE-2001/03/29-timgill Need a window to listen for WM_SETTINGCHANGE
     *  We need to create a window to listen for
     *  WM_SETTINGCHANGE so we can refresh the mouse acceleration
     *  as needed.
     */
    CEm_Mouse_OnMouseChange();
  #endif

    /*
     *  Create ourselves a queue before we go into our "hey what happened
     *  before I got here?" phase.  The thread that created us is waiting on
     *  the thread event, holding DLLCrit, so let it go as soon as the queue
     *  is ready.  We create the queue by calling a function that requires a
     *  queue.  We use this very simple one.
     */
    GetInputState();

  #ifdef WINNT
    // Look at comment block in FakeTimerProc
    SetTimer(NULL, 0, 2 * 1000 /*2 seconds*/, FakeTimerProc);
  #endif
 
    SetEvent(plts->hEvent);

  #ifdef USE_WM_INPUT
    ResetEvent(g_hEventThread);
  
    if( g_fRawInput ) {
        hwnd = CEm_InitWindow();
    
        if (!hwnd) {
            g_fRawInput = FALSE;
        }
    }

    g_hwndThread = hwnd;

    // Tell CEm_LL_Acquire that windows has been created.
    SetEvent( g_hEventAcquire );

    if( g_fFromKbdMse ) {
        DWORD rc;
        rc = WaitForSingleObject(g_hEventThread, INFINITE);
        g_fFromKbdMse = FALSE;
    }
  #endif
  
#ifdef USE_SLOW_LL_HOOKS
    /*
     *  Note carefully that we sync the hooks before entering our
     *  fake GetMessage loop.  This is necessary to avoid the race
     *  condition when CEm_LL_Acquire posts us a thread message
     *  before our thread gets a queue.  By sync'ing the hooks
     *  first, we do what the lost message would've had us do
     *  anyway.
     *  ISSUE-2001/03/29-timgill  Following branch should be no longer necessary
     *  This is should not be needed now that CEm_GetWorkerThread waits for
     *  this thread to respond before continuing on to post any messages.
     */
#endif /* USE_SLOW_LL_HOOKS */
    
    do {

      #ifdef USE_SLOW_LL_HOOKS
        if( !g_fRawInput ) {
            CEm_LL_SyncHook(plts, LLTS_KBD);
            CEm_LL_SyncHook(plts, LLTS_MSE);
        }
      #endif

        /*
         *  We can wake up for three reasons.
         *
         *  1.  We received an APC due to an I/o completion.
         *      Just go back to sleep.
         *
         *  2.  We need to call Peek/GetMessage so that
         *      USER can dispatch a low-level hook or SendMessage.
         *      Go into a PeekMessage loop to let that happen.
         *
         *  3.  A message got posted to us.
         *      Go into a PeekMessage loop to process it.
         */

        do {
            dwRc = _MsgWaitForMultipleObjectsEx(0, 0, INFINITE, QS_ALLINPUT,
                                                MWMO_ALERTABLE);
        } while (dwRc == WAIT_IO_COMPLETION);

        while (PeekMessage(&msg, 0, 0, 0, PM_REMOVE)) {
            if (msg.hwnd == 0 && msg.message == WM_NULL && msg.lParam) 
            {
                /*
                 *  See if maybe the lParam is a valid PEM that we're
                 *  processing.
                 */
                PEM pem = (PEM)msg.lParam;

                if( pem && pem == plts->pemCheck  )
                {
                    AssertF(GPA_FindPtr(&plts->gpaHid, pem));

                    CEm_HID_Sync(plts, pem);
                    plts->pemCheck = NULL;

                    SetEvent(plts->hEvent);
                  
                  #ifdef USE_WM_INPUT
                    if( g_fRawInput ) {
                        SetEvent(g_hEventHid);
                    }
                  #endif

                    continue;
                }
            }
          #ifdef USE_WM_INPUT
            else if ( g_fRawInput && msg.message == WM_INPUT && 
                      (msg.wParam == RIM_INPUT || msg.wParam == RIM_INPUTSINK) )
            {
                CDIRaw_OnInput(&msg);
            }
          #endif

            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }

    } while (plts->cRef);

#ifdef USE_SLOW_LL_HOOKS
    /*
     *  Remove our hooks before we go.
     *
     *  It is possible that there was a huge flurry of disconnects,
     *  causing us to notice that our refcount disappeared before
     *  we got a chance to remove the hooks in our message loop.
     */

    AssertF(plts->rglhs[LLTS_KBD].cHook == 0);
    AssertF(plts->rglhs[LLTS_KBD].cExcl == 0);
    AssertF(plts->rglhs[LLTS_MSE].cHook == 0);
    AssertF(plts->rglhs[LLTS_MSE].cExcl == 0);

    if( !g_fRawInput ) {
        if (plts->rglhs[LLTS_KBD].hhk) {
            UnhookWindowsHookEx(plts->rglhs[LLTS_KBD].hhk);
        }

        if (plts->rglhs[LLTS_MSE].hhk) {
            UnhookWindowsHookEx(plts->rglhs[LLTS_MSE].hhk);
        }
    }
#endif /* USE_SLOW_LL_HOOKS */

  #ifdef USE_WM_INPUT
    if( g_hwndThread ) {
        DestroyWindow( g_hwndThread );
        g_hwndThread = NULL;
    }

    ResetEvent( g_hEventAcquire );
    ResetEvent( g_hEventHid );
  #endif

    if( plts->gpaHid.rgpv ) {
        FreePpv(&plts->gpaHid.rgpv);
    }

    if( plts->hEvent ) {
        CloseHandle( plts->hEvent );
    }

    if( plts->hThread) {
        CloseHandle(plts->hThread);
    }

    FreePpv( &plts );

    SquirtSqflPtszV(sqflLl, TEXT("CEm_LL_ThreadProc: Thread terminating"));

    FreeLibraryAndExitThread(g_hinst, 0);
    /*NOTREACHED*/
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_GetWorkerThread |
 *
 *          Piggyback off the existing worker thread if possible;
 *          else create a new one.
 *
 *  @parm   PEM | pem |
 *
 *          Emulation state which requires a worker thread.
 *
 *  @parm   PLLTHREADSTATE * | pplts |
 *
 *          Receives thread state for worker thread.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_GetWorkerThread(PEM pem, PLLTHREADSTATE *pplts)
{
    PLLTHREADSTATE plts;
    HRESULT hres;

    DllEnterCrit();

    /*
     *  Normally, we can piggyback off the one we already have.
     */
    plts = g_plts;

    /*
     *  If we already have a ref to a worker thread, then use it.
     */
    if (pem->fWorkerThread) {

        /*
         *  The reference we created when we created the worker thread
         *  ensures that g_plts is valid.
         */
        AssertF(plts);
        AssertF(plts->cRef);
        if (plts) {
            hres = S_OK;
        } else {
            AssertF(0);                 /* Can't happen */
            hres = E_FAIL;
        }
    } else

    if (plts) {
        /*
         *  Create a reference to the existing thread.
         */
        pem->fWorkerThread = TRUE;
        InterlockedIncrement(&plts->cRef);
        hres = S_OK;
    } else {

        /*
         *  There is no worker thread (or it is irretrievably
         *  on its way out) so create a new one.
         */
        hres = AllocCbPpv(cbX(LLTHREADSTATE), &plts);
        if (SUCCEEDED(hres)) {
            DWORD dwRc = 0;
            TCHAR tsz[MAX_PATH];

            /*
             *  Assume the worst unless we find otherwise
             */
            hres = E_FAIL;

            if( GetModuleFileName(g_hinst, tsz, cA(tsz))
             && ( LoadLibrary(tsz) == g_hinst ) )
            {

                /*
                 *  Must set up everything to avoid racing with
                 *  the incoming thread.
                 */
                g_plts = plts;
                InterlockedIncrement(&plts->cRef);
                plts->hEvent = CreateEvent(0x0, 0, 0, 0x0);
                if( plts->hEvent )
                {
                    plts->hThread= CreateThread(0, 0, (LPTHREAD_START_ROUTINE)CEm_LL_ThreadProc, plts,
                                               0, &plts->idThread);
                    if( plts->hThread )
                    {
                        /*
                         *  Boost our priority to make sure we
                         *  can handle the messages.
                         *
                         *  RaymondC commented this out saying that it does not
                         *  help but we're hoping that it may on Win2k.
                         */
                        SetThreadPriority(plts->hThread, THREAD_PRIORITY_HIGHEST);

                        /*
                         *  Wait for the thread to signal that it is up and running
                         *  or for it to terminate.
                         *  This means that we don't have to consider the
                         *  possibility that the thread is not yet running in
                         *  NotifyWorkerThreadPem so we know a failure there is
                         *  terminal and don't retry.
                         *
                         *  Assert that the handle fields make a two handle array.
                         */
                        CAssertF( FIELD_OFFSET( LLTHREADSTATE, hThread) + sizeof(plts->hThread)
                               == FIELD_OFFSET( LLTHREADSTATE, hEvent) );

                        /*
                         *  According to a comment in CEm_LL_ThreadProc Win95 may
                         *  fail with an invalid parameter error, so if it does,
                         *  keep trying.  (Assume no valid case will occur.)
                         *
                         *  ISSUE-2001/03/29-timgill  Need to minimise waits while holding sync. objects
                         *  Waiting whilst holding DLLCrit is bad.
                         */
                        do
                        {
                            dwRc = WaitForMultipleObjects( 2, &plts->hThread, FALSE, INFINITE);
                        } while ( ( dwRc == WAIT_FAILED ) && ( GetLastError() == ERROR_INVALID_PARAMETER ) );

                        if( dwRc == WAIT_OBJECT_0 ) {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("CEm_GetWorkerThread: Created Thread terminated on first wait") );
                        } else {
                            pem->fWorkerThread = TRUE;
                            hres = S_OK;
                            if( dwRc != WAIT_OBJECT_0 + 1 )
                            {
                                /*
                                 *  This would be a bad thing if it ever happened
                                 *  but we have to assume that the thread is still
                                 *  running so we return a success anyway.
                                 */
                                SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("CEm_GetWorkerThread: First wait returned 0x%08x with LastError %d"),
                                    dwRc, GetLastError() );
                            }
                        }
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("CEm_GetWorkerThread: CreateThread failed with error %d"),
                            GetLastError() );
                    }
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("CEm_GetWorkerThread: CreateEvent failed with error %d"),
                        GetLastError() );
                }


                if( FAILED( hres ) )
                {
                    if( plts->hEvent ) {
                        CloseHandle( plts->hEvent );
                    }
                    FreeLibrary(g_hinst);
                }

            }
            else
            {
                RPF( "CEm_GetWorkerThread: failed to LoadLibrary( self ), le = %d", GetLastError() );
            }

            if( FAILED( hres ) )
            {
                FreePv(plts);
                g_plts = 0;
            }
        }
    }

    DllLeaveCrit();

    *pplts = plts;
    return hres;
}

#endif /* WORKER_THREAD */

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_LL_Acquire |
 *
 *          Acquire/unacquire a mouse or keyboard via low-level hooks.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *  @parm   BOOL | fAcquire |
 *
 *          Whether the device is being acquired or unacquired.
 *
 *  @parm   ULONG | fl |
 *
 *          Flags in VXDINSTANCE (vi.fl).
 *
 *  @parm   UINT | ilts |
 *
 *          LLTS_KBD or LLTS_MSE, depending on which is happening.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_LL_Acquire(PEM this, BOOL fAcquire, ULONG fl, UINT ilts)
{
    PLLTHREADSTATE plts;
    BOOL fExclusive = fl & VIFL_CAPTURED;
    BOOL fNoWinkey = fl & VIFL_NOWINKEY;
    HRESULT hres = S_OK;

    EnterProc(CEm_LL_Acquire, (_ "puuu", this, fAcquire, fExclusive, ilts));

    AssertF(this->dwSignature == CEM_SIGNATURE);
    AssertF(ilts==LLTS_KBD || ilts==LLTS_MSE);

  #ifdef USE_WM_INPUT
    g_fFromKbdMse = fAcquire ? TRUE : FALSE;
    ResetEvent( g_hEventAcquire );
  #endif  

    hres = CEm_GetWorkerThread(this, &plts);

    if (SUCCEEDED(hres)) {
        AssertF( plts->rglhs[ilts].cHook >= plts->rglhs[ilts].cExcl );

      #ifdef USE_WM_INPUT
        if( g_fRawInput && !g_hwndThread) {
            DWORD dwRc;
            dwRc = WaitForSingleObject(g_hEventAcquire, INFINITE);
        }
      #endif
        
        if (fAcquire) {
            InterlockedIncrement(&plts->rglhs[ilts].cHook);

            if (fExclusive) {
                InterlockedIncrement(&plts->rglhs[ilts].cExcl);
            }

          #ifdef USE_WM_INPUT
            if( g_hwndThread ) {
                if( fExclusive ) {
                    hres = CDIRaw_RegisterRawInputDevice(1-ilts, DIRAW_EXCL, g_hwndThread);
                } 
                else if( fNoWinkey ) {
                    AssertF( ilts == 0 );
                    if( ilts == 0 ) {
                        hres = CDIRaw_RegisterRawInputDevice(1-ilts, DIRAW_NOHOTKEYS, g_hwndThread);
                    } else {
                        hres = E_FAIL;
                    }
                } 
                else {
                    hres = CDIRaw_RegisterRawInputDevice(1-ilts, DIRAW_NONEXCL, g_hwndThread);
                }

                if(FAILED(hres)) {
                    hres = S_FALSE;
                    g_fRawInput = FALSE;
                    RPF("CEm_LL_Acquire: RegisterRawInput failed. LL will be used.");
                }
            }
          #endif
          
        } else {                        /* Remove the hook */
            AssertF(plts->cRef);

            if (fExclusive) {
                InterlockedDecrement(&plts->rglhs[ilts].cExcl);
            }

            InterlockedDecrement(&plts->rglhs[ilts].cHook);

          #ifdef USE_WM_INPUT
            if( g_fRawInput ) {
                CDIRaw_UnregisterRawInputDevice(1-ilts, g_hwndThread);
                
                if( plts->rglhs[ilts].cHook ) {
                    CDIRaw_RegisterRawInputDevice(1-ilts, 0, g_hwndThread);
                }
            }
          #endif
        }

        NudgeWorkerThread(plts->idThread);
    
      #ifdef USE_WM_INPUT
        // tell CEm_LL_ThreadProc that acquire finished.
        SetEvent( g_hEventThread );
      #endif

    }

    ExitOleProc();
    return hres;
}

#endif  /* USE_SLOW_LL_HOOKS */

/*****************************************************************************
 *
 *          Joystick emulation
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Joy_Acquire |
 *
 *          Acquire a joystick.  Nothing happens.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CEm_Joy_Acquire(PEM this, BOOL fAcquire)
{
    AssertF(this->dwSignature == CEM_SIGNATURE);
    return S_OK;
}

/*****************************************************************************
 *
 *          Joystick globals
 *
 *          Since we don't use joystick emulation by default, we allocate
 *          the emulation variables dynamically so we don't blow a page
 *          of memory on them.
 *
 *****************************************************************************/

typedef struct JOYEMVARS {
    ED rged[cJoyMax];
    DIJOYSTATE2 rgjs2[cJoyMax];
} JOYEMVARS, *PJOYEMVARS;

static PJOYEMVARS s_pjev;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Joy_CreateInstance |
 *
 *          Create a joystick thing.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *****************************************************************************/

#define OBJAT(T, v) (*(T *)(v))
#define PUN(T, v)   OBJAT(T, &(v))

HRESULT INTERNAL
CEm_Joy_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    HRESULT hres;

    DllEnterCrit();
    if (s_pjev == 0) {
        DWORD uiJoy;

        hres = AllocCbPpv(cbX(JOYEMVARS), &s_pjev);
        if (SUCCEEDED(hres)) {
            for (uiJoy = 0; uiJoy < cJoyMax; uiJoy++) {
                PUN(PV, s_pjev->rged[uiJoy].pState) = &s_pjev->rgjs2[uiJoy];
                s_pjev->rged[uiJoy].Acquire = CEm_Joy_Acquire;
                s_pjev->rged[uiJoy].cbData = cbX(s_pjev->rgjs2[uiJoy]);
                s_pjev->rged[uiJoy].cRef   = 0x0;
            }
        }
    } else {
        hres = S_OK;
    }
    DllLeaveCrit();

    if (SUCCEEDED(hres)) {
        hres = CEm_CreateInstance(pdevf, ppviOut,
                                  &s_pjev->rged[pdevf->dwExtra]);
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_Joy_Ping |
 *
 *          Read data from the joystick.
 *
 *  @parm   PVXDINSTANCE * | ppvi |
 *
 *          Information about the gizmo being mangled.
 *
 *****************************************************************************/

HRESULT INTERNAL
CEm_Joy_Ping(PVXDINSTANCE *ppvi)
{
    HRESULT hres;
    JOYINFOEX ji;
    MMRESULT mmrc;
    PEM this = _thisPvNm(*ppvi, vi);

    AssertF(this->dwSignature == CEM_SIGNATURE);
    ji.dwSize = cbX(ji);
    ji.dwFlags = JOY_RETURNALL + JOY_RETURNRAWDATA;
    ji.dwPOV = JOY_POVCENTERED;         /* joyGetPosEx forgets to set this */

    mmrc = joyGetPosEx((DWORD)(UINT_PTR)this->dwExtra, &ji);
    if (mmrc == JOYERR_NOERROR) {
        DIJOYSTATE2 js;
        UINT uiButtons;

        ZeroX(js);                      /* Wipe out the bogus things */

        js.lX = ji.dwXpos;
        js.lY = ji.dwYpos;
        js.lZ = ji.dwZpos;
        js.lRz = ji.dwRpos;
        js.rglSlider[0] = ji.dwUpos;
        js.rglSlider[1] = ji.dwVpos;
        js.rgdwPOV[0] = ji.dwPOV;
        js.rgdwPOV[1] = JOY_POVCENTERED;
        js.rgdwPOV[2] = JOY_POVCENTERED;
        js.rgdwPOV[3] = JOY_POVCENTERED;

        for (uiButtons = 0; uiButtons < 32; uiButtons++) {
            if (ji.dwButtons & (1 << uiButtons)) {
                js.rgbButtons[uiButtons] = 0x80;
            }
        }

        CEm_AddState(&s_pjev->rged[this->dwExtra], &js, GetTickCount());

        hres = S_OK;
    } else {
        /*
         *  dinput.dll forces the device unacquired here
         *  in DX8 we just return an error
         */
        hres = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,
                                            ERROR_DEV_NOT_EXIST);
    }

    return hres;
}


HRESULT EXTERNAL
NotifyWorkerThreadPem(DWORD idThread, PEM pem)
{
    PLLTHREADSTATE plts;
    HRESULT hres;

    hres = CEm_GetWorkerThread(pem, &plts);

    if( SUCCEEDED(hres) )
    {
        AssertF(plts->idThread == idThread);

        hres = NudgeWorkerThreadPem( plts, pem );
    }
    return hres;
}


HRESULT EXTERNAL
NudgeWorkerThreadPem( PLLTHREADSTATE plts, PEM pem )
{
    HRESULT hres = S_FALSE;

    plts->pemCheck = pem;

    if( !PostWorkerMessage(plts->idThread, pem))
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
                        TEXT("NudgeWorkerThreadPem: PostThreadMessage Failed with error %d"),
                        GetLastError() );
    }
    else if( pem )
    {
        DWORD dwRc;

        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("NudgeWorkerThreadPem: PostThreadMessage SUCCEEDED, waiting for event ... "));


        /*
         *  According to a comment in CEm_LL_ThreadProc Win95 may
         *  fail with an invalid parameter error, so if it does,
         *  keep trying.  (Assume no valid case will occur.)
         */
        do
        {
            dwRc = WaitForMultipleObjects( 2, &plts->hThread, FALSE, INFINITE);
        } while ( ( dwRc == WAIT_FAILED ) && ( GetLastError() == ERROR_INVALID_PARAMETER ) );

        switch( dwRc )
        {
        case WAIT_OBJECT_0:
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("NotifyWorkerThreadPem: Not expecting response from dead worker thread") );
            break;
        case WAIT_OBJECT_0 + 1:
            /*
             *  The worker thread responded OK
             */
            hres = S_OK;
            AssertF(plts->pemCheck == NULL );
            break;
        default:
            SquirtSqflPtszV(sqfl | sqflError,
                TEXT("NotifyWorkerThreadPem: WaitForMultipleObjects returned 0x%08x with LastError %d"),
                dwRc, GetLastError() );
            hres = E_FAIL;
            break;
        }

    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diem.h ===
/*****************************************************************************
 *
 *  DIEm.h
 *
 *  Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      DirectInput internal header file for emulation.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CEd |
 *
 *          Emulation descriptor.  One of these is created for each
 *          device.  It is never destroyed, so the variable must
 *          be a global variable or memory allocated inside a
 *          container that will eventually be destroyed.
 *
 *          ISSUE-2001/03/29-timgill  Need a better destructor function
 *
 *  @field  LPVOID const | pState |
 *
 *          State buffer that everybody parties into.
 *
 *          It too is never destroyed, so once again it should be
 *          a global variable or live inside something else that
 *          will be destroyed.
 *
 *  @field  LPDWORD const | pDevType |
 *
 *          Array of device type descriptors, indexed by data format
 *          offset.  Used to determine whether a particular piece of
 *          data belongs to an axis, button, or POV.
 *
 *  @field  EMULATIONPROC | Acquire |
 *
 *          Callback function for acquisition and loss thereof.
 *          It is called once when the first client acquires,
 *          and again when the last app unacquires.  It is not
 *          informed of nested acquisition.
 *
 *  @field  LONG | cAcquire |
 *
 *          Number of times the device emulation has been acquired (minus one). 
 *
 *  @field  DWORD | cbData |
 *
 *          Size of the device data type.  In other words, size of
 *          <p pState> in bytes.
 *
 *****************************************************************************/

typedef STDMETHOD(EMULATIONPROC)(struct CEm *, BOOL fAcquire);

typedef struct CEd {

    LPVOID const    pState;
    LPDWORD const   pDevType;
    EMULATIONPROC   Acquire;
    LONG            cAcquire;
    DWORD           cbData;
    ULONG           cRef;
} CEd, ED, *PED;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CEm |
 *
 *          Emulation state information.
 *
 *  @field  VXDINSTANCE | vi |
 *
 *          Information shared with parent device.
 *
 *  @field  PEM | pemNext |
 *
 *          Next item in linked list of all active device instances.
 *
 *  @field  LPDWORD | rgdwDf |
 *
 *          Array of items (one for each byte in the device
 *          data format).  This maps each device data format byte
 *          into an application device data offset, or -1 if the
 *          application doesn't care about the corresponding object.
 *
 *  @field  ULONG_PTR  | dwExtra |
 *
 *          Extra information passed in the <t VXDDEVICEFORMAT>
 *          when the device was created.  This is used by each
 *          particular device to encode additional instance infomation.
 *
 *  @field  PED | ped |
 *
 *          The device that owns this instance.  Multiple instances
 *          of the same device share the same <e CEm.ped>.
 *
 *  @field  LONG | cRef |
 *
 *          Reference count.
 *
 *
 *  @field  LONG | cAcquire |
 *
 *          Number of times the device instance has been acquired (minus one). 
 *
 *
 *  @field  BOOL | fWorkerThread |
 *
 *          This is used by low-level hooks and HID devices, which
 *          require a worker thread to collect the data.
 *          This is not cheap, so
 *          instead, we spin up the thread on the first acquire, and
 *          on the unacquire, we keep the thread around so that the next
 *          acquire is fast.  When the last object is released, we finally
 *          kill the thread.
 *
 *****************************************************************************/

typedef struct CEm {

    VXDINSTANCE vi;             /* This must be first */
    struct CEm *pemNext;
    LPDWORD rgdwDf;
    ULONG_PTR   dwExtra;
    PED     ped;
    LONG    cAcquire;
    LONG    cRef;
#ifdef WORKER_THREAD
    BOOL    fWorkerThread;
#endif
#ifdef DEBUG
    DWORD   dwSignature;
#endif
    BOOL    fHidden;
} CEm, EM, *PEM;

#define CEM_SIGNATURE       0x4D4D4545      /* "EEMM" */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PEM | pemFromPvi |
 *
 *          Given an interior pointer to a <t VXDINSTANCE>, retrieve
 *          a pointer to the parent <t CEm>.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The pointer to convert.
 *
 *****************************************************************************/

PEM INLINE
pemFromPvi(PVXDINSTANCE pvi)
{
    return pvSubPvCb(pvi, FIELD_OFFSET(CEm, vi));
}

/*****************************************************************************
 *
 *          NT low-level hook support
 *
 *          Low-level hooks live on a separate thread which we spin
 *          up when first requested and take down when the last
 *          DirectInput device that used a thread has been destroyed.
 *
 *          If we wanted, we could destroy the thread when the
 *          device is unacquired (rather than when the device is
 *          destroyed), but we cache the thread instead, because
 *          a device that once has been acquired will probably be
 *          acquired again.
 *
 *          To prevent race conditions from crashing us, we addref
 *          our DLL when the thread exists and have the thread
 *          perform a FreeLibrary as its final act.
 *
 *          Note that this helper thread is also used by the HID data
 *          collector.
 *
 *****************************************************************************/

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct LLHOOKSTATE |
 *
 *          Low-level hook information about a single hook.
 *
 *  @field  int | cHook |
 *
 *          Number of times the hook has been requested.  If zero,
 *          then there should be no hook.  All modifications to
 *          this field must be interlocked to avoid race conditions
 *          when two threads try to hook or unhook simultaneously.
 *
 *  @field  int | cExcl |
 *
 *          Number of times the hook has been requested in an exclusive 
 *          mode.  This value should always be less than or equal to the 
 *          cHook value.  All modifications to this field must be 
 *          interlocked to avoid race conditions when two threads try to 
 *          hook or unhook simultaneously.
 *
 *  @field  HHOOK | hhk |
 *
 *          The actual hook, if it is installed.  Only the hook thread
 *          touches this field, so it does not need to be protected.
 *
 *  @field  BOOLEAN | fExcluded |
 *
 *          Flag to indicate whether or not exclusivity has been applied.  
 *          Only the hook thread touches this field, so it does not need to 
 *          be protected.
 *
 *****************************************************************************/

typedef struct LLHOOKSTATE {

    int     cHook;
    int     cExcl;
    HHOOK   hhk;
    BOOLEAN fExcluded;
} LLHOOKSTATE, *PLLHOOKSTATE;

LRESULT CALLBACK CEm_LL_KbdHook(int nCode, WPARAM wp, LPARAM lp);
LRESULT CALLBACK CEm_LL_MseHook(int nCode, WPARAM wp, LPARAM lp);

#endif  /* USE_SLOW_LL_HOOKS */

#ifdef WORKER_THREAD

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct LLTHREADSTATE |
 *
 *          Low-level hook state for a thread.  Note that this is
 *          a dynamically
 *          allocated structure instead of a static.  This avoids various
 *          race conditions where, for example, somebody terminates the
 *          worker thread and somebody else starts it up before the
 *          worker thread is completely gone.
 *
 *          A pointer to the hThread is passed as the pointer to an array 
 *          of two handles in calls to WaitForMultipleObject so hEvent must 
 *          follow it directly.
 *
 *  @field  DWORD | idThread |
 *
 *          The ID of the worker thread.
 *
 *  @field  LONG | cRef |
 *
 *          Thread reference count.  The thread kills itself when this
 *          drops to zero.
 *
 *  @field  LLHOOKSTATE | rglhs[2] |
 *
 *          Hook states, indexed by LLTS_* values.
 *
 *          These are used only if low-level hooks are enabled.
 *
 *  @field  HANDLE | hThread |
 *
 *          The handle (from the create) of the worker thread.
 *
 *          This is used only if HID support is enabled.
 *
 *  @field  HANDLE | hEvent |
 *
 *          The handle to the event used to synchronize with the worker thread.
 *
 *          This is used only if HID support is enabled.
 *
 *  @field  GPA | gpaHid |
 *
 *          Pointer array of HID devices which are acquired.
 *
 *          This is used only if HID support is enabled.
 *
 *  @field  PEM | pemCheck |
 *
 *          Pointer to Emulation state information.
 *
 *          This is used only if HID support is enabled.
 *
 *****************************************************************************/

#define LLTS_KBD    0
#define LLTS_MSE    1
#define LLTS_MAX    2

typedef struct LLTHREADSTATE {
    DWORD       idThread;
    LONG        cRef;
#ifdef USE_SLOW_LL_HOOKS
    LLHOOKSTATE rglhs[LLTS_MAX];
#endif
    HANDLE      hThread;    /* MUST be followed by hEvent, see above */
    HANDLE      hEvent;     /* MUST follow hThread, see above */
    GPA         gpaHid;
    PEM         pemCheck;
} LLTHREADSTATE, *PLLTHREADSTATE;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @topic  Communicating with the worker thread |
 *
 *          Communication with the worker thread is performed via
 *          <c WM_NULL> messages.  Extra care must be taken to make
 *          sure that someone isn't randomly sending messages to us.
 *
 *          We use the <c WM_NULL> message because there are race
 *          windows where we might post a message to a thread after
 *          it is gone.  During this window, the thread ID might get
 *          recycled, and we end up posting the message to some random
 *          thread that isn't ours.  By using the <c WM_NULL> message,
 *          we are safe in knowing that the target thread won't barf
 *          on the unexpected message.
 *
 *          The <t WPARAM> of the <c WM_NULL> is the magic value
 *          <c WT_WPARAM>.
 *
 *          The <t LPARAM> of the <c WM_NULL> is either a pointer
 *          to the <t CEm> that needs to be refreshed or is
 *          zero if we merely want to check our bearings.
 *
 *****************************************************************************/

#define WT_WPARAM       0

#define PostWorkerMessage(thid, lp)                                     \
        PostThreadMessage(thid, WM_NULL, WT_WPARAM, (LPARAM)(lp))       \

#define NudgeWorkerThread(thid)                                         \
        PostThreadMessage(thid, WM_NULL, WT_WPARAM, (LPARAM)NULL)

HRESULT EXTERNAL NudgeWorkerThreadPem( PLLTHREADSTATE plts, PEM pem );

HRESULT EXTERNAL NotifyWorkerThreadPem(DWORD idThread, PEM pem);

STDMETHODIMP CEm_GetWorkerThread(PEM pem, PLLTHREADSTATE *pplts);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global PLLTHREADSTATE | g_plts |
 *
 *          The thread state of the currently-active thread.
 *
 *          This variable needs to be externally accessible
 *          because you can't pass instance data to a windows
 *          hook function.  (Whose idea was that?)
 *
 *****************************************************************************/

extern PLLTHREADSTATE g_plts;

void EXTERNAL CEm_Mouse_OnMouseChange(void);

#endif  /* WORKER_THREAD */

/*
 *  Private helper functions in diem.c
 */

#define FDUFL_NORMAL       0x0000           /* Nothing unusual */
#define FDUFL_UNPLUGGED    VIFL_UNPLUGGED   /* Device disconnected */

void  EXTERNAL CEm_ForceDeviceUnacquire(PED ped, UINT fdufl);
void  EXTERNAL CEm_AddState(PED ped, LPVOID pvData, DWORD tm);
DWORD EXTERNAL CEm_AddEvent(PED ped, DWORD dwData, DWORD dwOfs, DWORD tm);
BOOL  EXTERNAL CEm_ContinueEvent(PED ped, DWORD dwData, DWORD dwOfs, DWORD tm, DWORD dwSeq);

STDMETHODIMP CEm_LL_Acquire(PEM this, BOOL fAcquire, ULONG fl, UINT ilts);

HRESULT EXTERNAL
CEm_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut, PED ped);

void EXTERNAL CEm_FreeInstance(PEM this);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_AddRef |
 *
 *          Bump the reference count because we're doing something with it.
 *
 *  @parm   PEM | this |
 *
 *          The victim.
 *
 *****************************************************************************/

void INLINE
CEm_AddRef(PEM this)
{
    AssertF(this->dwSignature == CEM_SIGNATURE);
    InterlockedIncrement(&this->cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_Release |
 *
 *          Drop the reference count and blow it away if it's gone.
 *
 *  @parm   PEM | this |
 *
 *          The victim.
 *
 *****************************************************************************/

void INLINE
CEm_Release(PEM this)
{
    AssertF(this->dwSignature == CEM_SIGNATURE);
    if (InterlockedDecrement(&this->cRef) == 0) {
        CEm_FreeInstance(this);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dieshep.c ===
/*****************************************************************************
 *
 *  DIEShep.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The IDirectInputEffectDriver shepherd.
 *
 *      The shepherd does the annoying work of babysitting the
 *      external IDirectInputDriver.
 *
 *      It makes sure nobody parties on bad handles.
 *
 *      It handles cross-process (or even intra-process) effect
 *      management.
 *
 *      It caches the joystick ID so you don't have to.
 *
 *  Contents:
 *
 *      CEShep_New
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEShep

#pragma BEGIN_CONST_DATA


/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

  Primary_Interface(CEShep, IDirectInputEffectShepherd);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CEShep |
 *
 *          The <i IDirectInputEffectShepherd> object, which
 *          babysits an <i IDirectInputEffectDriver>.
 *
 *  @field  IDirectInputEffectShepherd | des |
 *
 *          DirectInputEffectShepherd object (containing vtbl).
 *
 *  @field  IDirectInputEffectDriver * | pdrv |
 *
 *          Delegated effect driver interface.
 *
 *  @field  UINT | idJoy |
 *
 *          Joystick identification number.
 *
 *  @field  HINSTANCE | hinst |
 *
 *          The instance handle of the DLL that contains the effect
 *          driver.
 *
 *****************************************************************************/

typedef struct CEShep {

    /* Supported interfaces */
    IDirectInputEffectShepherd des;

    IDirectInputEffectDriver *pdrv;

    UINT        idJoy;
    HINSTANCE   hinst;

} CEShep, ES, *PES;

typedef IDirectInputEffectShepherd DES, *PDES;
#define ThisClass CEShep
#define ThisInterface IDirectInputEffectShepherd

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *//**************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *//**************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | QIHelper |
 *
 *          We don't have any dynamic interfaces and simply forward
 *          to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *//**************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CEShep)
Default_AddRef(CEShep)
Default_Release(CEShep)

#else

#define CEShep_QueryInterface   Common_QueryInterface
#define CEShep_AddRef           Common_AddRef
#define CEShep_Release          Common_Release

#endif

#define CEShep_QIHelper         Common_QIHelper
#define CEShep_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEShep_Finalize |
 *
 *          Clean up our instance data.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CEShep_Finalize(PV pvObj)
{
    PES this = pvObj;

    Invoke_Release(&this->pdrv);

    if (this->hinst) {
        FreeLibrary(this->hinst);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CEShep | UnlockDevice |
 *
 *          Unlock the joystick table after we are finished messing
 *          with the device.
 *
 *****************************************************************************/

void INLINE
CEShep_UnlockDevice(void)
{
    ReleaseMutex(g_hmtxJoy);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEShep | LockDevice |
 *
 *          Validate that the the device access token is still valid.
 *
 *          If so, then take the joystick mutex to prevent someone
 *          from dorking with the device while we're using it.
 *          Call <f CEShep_UnlockDevice> when done.
 *
 *          If not, then try to steal ownership if requested.
 *
 *          Else, fail.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Handle to lock.
 *
 *  @parm   DWORD | dwAccess |
 *
 *          If <c DISFFC_FORCERESET>, then force ownership of the device.
 *          This is done as part of device acquisition to kick out the
 *          previous owner.
 *
 *          Otherwise, if the device belongs to somebody else, then
 *          leave it alone.
 *
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c DIERR_NOTEXCLUSIVEACQUIRED> if the lock failed.
 *          Note that
 *          <mf IDirectInputEffectDevice2::SetForceFeedbackState>
 *          and
 *          <mf IDirectInputEffectDevice2::GetForceFeedbackState>
 *          are particularly keen on this error code.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_LockDevice(PES this, PSHEPHANDLE psh, DWORD dwAccess)
{
    HRESULT hres;
    EnterProc(CEShep_LockDevice, (_ "puu", this, psh->dwTag, dwAccess));

    WaitForSingleObject(g_hmtxJoy, INFINITE);

    /*
     *  Note that DISFFC_FORCERESET allows unconditional access.
     *  DISFFC_FORCERESET is used when we perform the initial reset
     *  after acquiring, so we can legitimately steal the device
     *  from the previous owner.
     */
    if (dwAccess & DISFFC_FORCERESET) {
        hres = S_OK;
    } else if (g_psoh->rggjs[this->idJoy].dwTag == psh->dwTag) {
        hres = S_OK;
    } else {
        ReleaseMutex(g_hmtxJoy);
        hres = DIERR_NOTEXCLUSIVEACQUIRED;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CEShep | UnlockEffect |
 *
 *          Unlock the joystick table after we are finished messing
 *          with an effect.
 *
 *****************************************************************************/

void INLINE
CEShep_UnlockEffect(void)
{
    ReleaseMutex(g_hmtxJoy);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEShep | LockEffect |
 *
 *          Validate that the the effect handle is still valid.
 *
 *          If so, then take the joystick mutex to prevent someone
 *          from dorking with the device while we're using the handle.
 *          Call <f CEShep_UnlockEffect> when done.
 *
 *          If not, then set the effect handle to zero to indicate
 *          that it's bogus.  The
 *          <mf IDirectInputEffectShepherd::DownloadEffect>
 *          method relies on the zero-ness.
 *          It is also asserted in <i IDirectInputEffect> to make
 *          sure we don't accidentally leave effects on the device
 *          when we leave.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Handle to lock.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c DIERR_NOTDOWNLOADED> if the lock failed.
 *          Note that
 *          <mf IDirectInputEffectShepherd::DownloadEffect> and
 *          <mf IDirectInputEffectShepherd::DestroyEffect> assume
 *          that this is the only possible error code.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_LockEffect(PES this, PSHEPHANDLE psh)
{
    HRESULT hres;
    EnterProc(CEShep_LockEffect, (_ "pux", this, psh->dwTag, psh->dwEffect));

    WaitForSingleObject(g_hmtxJoy, INFINITE);

    if (g_psoh->rggjs[this->idJoy].dwTag == psh->dwTag && psh->dwEffect) {
        hres = S_OK;
    } else {
        psh->dwEffect = 0;
        ReleaseMutex(g_hmtxJoy);
        hres = DIERR_NOTDOWNLOADED;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | DeviceID |
 *
 *          Inform the driver of the identity of the device.
 *
 *          For example, if a device driver is passed
 *          <p dwExternalID> = 2 and <p dwInteralID> = 1,
 *          then this means that unit 1 on the device
 *          corresponds to joystick ID number 2.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The joystick ID number being used.
 *          The Windows joystick subsystem allocates external IDs.
 *
 *  @parm   DWORD | fBegin |
 *
 *          Nonzero if access to the device is begining.
 *          Zero if the access to the device is ending.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Reserved for future use (HID).
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_DeviceID(PDES pdes, DWORD dwExternalID, DWORD fBegin, LPVOID pvReserved)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::DeviceID,
               (_ "puu", pdes, dwExternalID, fBegin));

    this = _thisPvNm(pdes, des);

    AssertF(dwExternalID < cJoyMax);

    if (dwExternalID < cJoyMax) {
        VXDINITPARMS vip;

        /*
         *  If this device has never been used before,
         *  go grab its global gain.
         */
        WaitForSingleObject(g_hmtxJoy, INFINITE);

        if (g_psoh->rggjs[dwExternalID].dwTag == 0) {
            DIJOYCONFIG cfg;

            g_psoh->rggjs[dwExternalID].dwTag = 1;

            hres = JoyReg_GetConfig(dwExternalID, &cfg, DIJC_GAIN);
            if (SUCCEEDED(hres)) {
                SquirtSqflPtszV(sqfl,
                                TEXT("Joystick %d global gain = %d"),
                                     dwExternalID, cfg.dwGain);
                g_psoh->rggjs[dwExternalID].dwCplGain = cfg.dwGain;
            } else {
                g_psoh->rggjs[dwExternalID].dwCplGain = DI_FFNOMINALMAX;
            }

            /*
             *  Set to DI_FFNOMINALMAX until we learn better.
             */
            g_psoh->rggjs[dwExternalID].dwDevGain = DI_FFNOMINALMAX;

        }

        ReleaseMutex(g_hmtxJoy);

        /*
         *  Ask the HEL for the internal ID.
         */
        hres = Hel_Joy_GetInitParms(dwExternalID, &vip);

        if (SUCCEEDED(hres)) {
            this->idJoy = dwExternalID;
            hres = this->pdrv->lpVtbl->DeviceID(this->pdrv,
                                                DIRECTINPUT_VERSION,
                                                dwExternalID,
                                                fBegin, vip.dwId,
                                                pvReserved);
        }
    } else {
        hres = E_FAIL;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | Escape |
 *
 *          Escape to the driver.  This method is called
 *          in response to an application invoking the
 *          <mf IDirectInputEffect::Escape> method.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect at which the command is directed.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Command block.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c DIERR_NOTDOWNLOADED> if the effect is not downloaded.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_Escape(PDES pdes, PSHEPHANDLE psh, LPDIEFFESCAPE pesc)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::Escape,
               (_ "puxx", pdes, psh->dwTag, psh->dwEffect, pesc->dwCommand));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        if (psh->dwEffect) {
            hres = this->pdrv->lpVtbl->Escape(this->pdrv, this->idJoy,
                                              psh->dwEffect, pesc);
        } else {
            hres = DIERR_NOTDOWNLOADED;
        }
        CEShep_UnlockEffect();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | DeviceEscape |
 *
 *          Escape to the driver.  This method is called
 *          in response to an application invoking the
 *          <mf IDirectInputDevice8::Escape> method.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the ownership of the device.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Command block.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_DeviceEscape(PDES pdes, PSHEPHANDLE psh, LPDIEFFESCAPE pesc)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::DeviceEscape,
               (_ "pux", pdes, psh->dwTag, pesc->dwCommand));

    this = _thisPvNm(pdes, des);

    AssertF(psh->dwEffect == 0);

    WaitForSingleObject(g_hmtxJoy, INFINITE);

    if (g_psoh->rggjs[this->idJoy].dwTag == psh->dwTag) {
        hres = this->pdrv->lpVtbl->Escape(this->pdrv, this->idJoy,
                                          0, pesc);
    } else {
        hres = DIERR_NOTEXCLUSIVEACQUIRED;
    }

    ReleaseMutex(g_hmtxJoy);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEShep | SetPhysGain |
 *
 *          Set the physical gain based on the global gain
 *          and the local gain.
 *
 *          The caller must already have the global joystick lock.
 *
 *
 *  @cwrap  PES | this
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_SetPhysGain(PES this)
{
    HRESULT hres;

    hres = this->pdrv->lpVtbl->SetGain(
                 this->pdrv, this->idJoy,
                 MulDiv(g_psoh->rggjs[this->idJoy].dwDevGain,
                        g_psoh->rggjs[this->idJoy].dwCplGain,
                        DI_FFNOMINALMAX));
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | SetGlobalGain |
 *
 *          Set the global gain.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwCplGain |
 *
 *          The new global gain value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_SetGlobalGain(PDES pdes, DWORD dwCplGain)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::SetGlobalGain,
               (_ "pu", pdes, dwCplGain));

    this = _thisPvNm(pdes, des);

    WaitForSingleObject(g_hmtxJoy, INFINITE);

    g_psoh->rggjs[this->idJoy].dwCplGain = dwCplGain;

    hres = CEShep_SetPhysGain(this);

    ReleaseMutex(g_hmtxJoy);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | SetGain |
 *
 *          Set the overall device gain.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about device ownership.
 *
 *  @parm   DWORD | dwDevGain |
 *
 *          The new local gain value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_SetGain(PDES pdes, PSHEPHANDLE psh, DWORD dwDevGain)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::SetGain,
               (_ "puu", pdes, psh->dwTag, dwDevGain));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockDevice(this, psh, DISFFC_NULL))) {
        g_psoh->rggjs[this->idJoy].dwDevGain = dwDevGain;

        hres = CEShep_SetPhysGain(this);
        CEShep_UnlockDevice();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | SendForceFeedbackCommand |
 *
 *          Send a command to the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about device ownership.
 *
 *  @parm   DWORD | dwCmd |
 *
 *          Command, one of the <c DISFFC_*> values.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_SetForceFeedbackState(PDES pdes, PSHEPHANDLE psh, DWORD dwCmd)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::SetForceFeedbackState,
               (_ "pux", pdes, psh->dwTag, dwCmd));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockDevice(this, psh, dwCmd))) {

        if (dwCmd & DISFFC_FORCERESET) {
            dwCmd &= ~DISFFC_FORCERESET;
            dwCmd |= DISFFC_RESET;
        }

        hres = this->pdrv->lpVtbl->SendForceFeedbackCommand(
                        this->pdrv, this->idJoy, dwCmd);

        if (SUCCEEDED(hres) && (dwCmd & DISFFC_RESET)) {
            psh->dwTag = ++g_psoh->rggjs[this->idJoy].dwTag;
        }
        CEShep_UnlockDevice();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | GetForceFeedbackState |
 *
 *          Retrieve the force feedback state for the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about device ownership.
 *
 *  @parm   LPDIDEVICESTATE | pds |
 *
 *          Receives device state.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_GetForceFeedbackState(PDES pdes, PSHEPHANDLE psh, LPDIDEVICESTATE pds)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::GetForceFeedbackState,
               (_ "pup", pdes, psh->dwTag, pds));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockDevice(this, psh, DISFFC_NULL))) {
        hres = this->pdrv->lpVtbl->GetForceFeedbackState(
                            this->pdrv, this->idJoy, pds);
        CEShep_UnlockDevice();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | DownloadEffect |
 *
 *          Send an effect to the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwEffectId |
 *
 *          Magic cookie dword that identifies the effect.
 *
 *  @parm   IN OUT PSHEPHANDLE | psh |
 *
 *          On entry, contains the handle of the effect being
 *          downloaded.  If the value is zero, then a new effect
 *          is downloaded.  If the value is nonzero, then an
 *          existing effect is modified.
 *
 *          On exit, contains the new effect handle.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The new parameters for the effect.  The axis and button
 *          values have been converted to axis/button indexes.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *          <c S_FALSE> if no change was made.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_DownloadEffect(PDES pdes, DWORD dwEffectId,
                       PSHEPHANDLE psh, LPCDIEFFECT peff, DWORD fl)
{
    PES this;
    HRESULT hres = S_OK;
    EnterProcI(IDirectInputEffectShepherd::DownloadEffect,
               (_ "pxuppx", pdes, dwEffectId, psh->dwTag,
                            psh->dwEffect, peff, fl));

    this = _thisPvNm(pdes, des);

    /*
     *  Downloading an effect is sufficiently different from all
     *  other methods that we do the locking manually.
     */
    WaitForSingleObject(g_hmtxJoy, INFINITE);

    /*
     *  If not downloading, then it doesn't matter whether or not
     *  the tag matches.  However, if the tag doesn't match, then
     *  we must wipe out the download handle because it's dead.
     */
    if (g_psoh->rggjs[this->idJoy].dwTag == psh->dwTag) {
    } else {
        psh->dwEffect = 0;
        if (fl & DIEP_NODOWNLOAD) {     /* It's okay if not downloading */
        } else {
            hres = DIERR_NOTEXCLUSIVEACQUIRED;
            goto done;
        }
    }

    /*
     *  If downloading and creating a new effect,
     *  then all parameters need to be downloaded.
     */
    if (!(fl & DIEP_NODOWNLOAD) && psh->dwEffect == 0) {
        fl |= DIEP_ALLPARAMS;
    }
    if (fl) {
        hres = this->pdrv->lpVtbl->DownloadEffect(
                    this->pdrv, this->idJoy, dwEffectId,
                    &psh->dwEffect, peff, fl);
    } else {
        hres = S_FALSE;
    }

done:;
    ReleaseMutex(g_hmtxJoy);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | DestroyEffect |
 *
 *          Remove an effect from the device.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect to be destroyed.  On exit,
 *          the <e SHEPHANDLE.dwEffect> is zero'd so nobody will use
 *          it any more.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *          <c S_FALSE> if the effect was already destroyed.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_DestroyEffect(PDES pdes, PSHEPHANDLE psh)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::DestroyEffect,
               (_ "pux", pdes, psh->dwTag, psh->dwEffect));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        DWORD dwEffect = psh->dwEffect;
        psh->dwEffect = 0;
        hres = this->pdrv->lpVtbl->DestroyEffect(
                    this->pdrv, this->idJoy, dwEffect);
        CEShep_UnlockEffect();
    } else {
        hres = S_FALSE;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | StartEffect |
 *
 *          Begin playback of an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect to be played.
 *
 *  @parm   DWORD | dwMode |
 *
 *          How the effect is to affect other effects.
 *
 *  @parm   DWORD | dwCount |
 *
 *          Number of times the effect is to be played.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_StartEffect(PDES pdes, PSHEPHANDLE psh, DWORD dwMode, DWORD dwCount)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::StartEffect,
               (_ "puxxu", pdes, psh->dwTag, psh->dwEffect, dwMode, dwCount));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        hres = this->pdrv->lpVtbl->StartEffect(this->pdrv, this->idJoy,
                                               psh->dwEffect, dwMode, dwCount);
        CEShep_UnlockEffect();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | StopEffect |
 *
 *          Halt playback of an effect.
 *
 *          ISSUE-2001/03/29-timgill There is no way to pause an effect
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect to be stopped.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_StopEffect(PDES pdes, PSHEPHANDLE psh)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::StopEffect,
               (_ "pux", pdes, psh->dwTag, psh->dwEffect));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        hres = this->pdrv->lpVtbl->StopEffect(this->pdrv, this->idJoy,
                                              psh->dwEffect);
        CEShep_UnlockEffect();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | GetEffectStatus |
 *
 *          Obtain information about an effect.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   PSHEPHANDLE | psh |
 *
 *          Information about the effect to be queried.
 *
 *  @parm   LPDWORD | pdwStatus |
 *
 *          Receives the effect status.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_GetEffectStatus(PDES pdes, PSHEPHANDLE psh, LPDWORD pdwStatus)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::GetEffectStatus,
               (_ "pux", pdes, psh->dwTag, psh->dwEffect));

    this = _thisPvNm(pdes, des);

    if (SUCCEEDED(hres = CEShep_LockEffect(this, psh))) {
        hres = this->pdrv->lpVtbl->GetEffectStatus(this->pdrv, this->idJoy,
                                                   psh->dwEffect, pdwStatus);
        CEShep_UnlockEffect();
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | GetVersions |
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTSHEPHERD | lpShepherd
 *
 *  @parm   LPDIDRIVERVERSIONS | pvers |
 *
 *          A structure which will be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_GetVersions(PDES pdes, LPDIDRIVERVERSIONS pvers)
{
    PES this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectShepherd::GetVersions, (_ "p", pdes));

    this = _thisPvNm(pdes, des);

    AssertF(pvers->dwSize == cbX(*pvers));

    hres = this->pdrv->lpVtbl->GetVersions(this->pdrv, pvers);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEShep | InitInstance |
 *
 *          Initialize a new instance of
 *          an IDirectInputEffectShepherd object.
 *
 *          If an in-proc OLE server is needed, then load it.
 *
 *          Otherwise, use our private interface that goes down
 *          to our helper driver.
 *
 *  @parm   IN HKEY | hkFF |
 *
 *          Force feedback registry key.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_InitInstance(PES this, HKEY hkFF)
{
    LONG lRc;
    HRESULT hres;
    TCHAR tszClsid[ctchGuid];

    EnterProcI(IDirectInputEffectShepherd::InitInstance, (_ "x", hkFF));

    if( hkFF == 0x0 )
    {
        TCHAR tszName[ctchNameGuid];
        NameFromGUID(tszName, &IID_IDirectInputPIDDriver );
        memcpy(tszClsid, &tszName[ctchNamePrefix], cbX(tszClsid) );
        lRc = ERROR_SUCCESS;
    }else
    {
        lRc = RegQueryString(hkFF, TEXT("CLSID"), tszClsid, cA(tszClsid));
        /*
         *  Prefix warns that tszClsid could be uninitialized through this 
         *  path (mb:35346) however RegQueryString only returns ERROR_SUCCESS 
         *  if a nul terminated string has been read into tszClsid.
         */
    }

    if (lRc == ERROR_SUCCESS) {
        hres = DICoCreateInstance(tszClsid, 0,
                                  &IID_IDirectInputEffectDriver,
                                  &this->pdrv,
                                  &this->hinst);

        /*
         *  If anything went wrong, change the error to
         *  E_NOTIMPL so the app won't see a wacky CoCreateInstance
         *  error code.
         */
        if (FAILED(hres)) {
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("Substituting E_NOTIMPL for FF driver CoCreateInstance error 0x%08x"),
                hres );
            hres = E_NOTIMPL;
        }

    } else {
#ifdef WINNT
        hres = E_NOTIMPL;
#else
        {
            DWORD cb = 0;
            lRc = RegQueryValueEx(hkFF, TEXT("VJoyD"), 0, 0, 0, &cb);
            if (lRc == ERROR_SUCCESS || lRc == ERROR_MORE_DATA) {
                hres = CEffVxd_New(0, &IID_IDirectInputEffectDriver, &this->pdrv);
            } else {
                hres = E_NOTIMPL;
            }
        }
#endif
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputEffectShepherd | New |
 *
 *          Create a new instance of an IDirectInputEffectShepherd object.
 *
 *  @parm   IN HKEY | hkFF |
 *
 *          Force feedback registry key.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CEShep_New(HKEY hkFF, PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IDirectInputEffectShepherd::<constructor>, (_ "G", riid));

    AssertF(g_hmtxJoy);

    hres = Common_NewRiid(CEShep, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv in case of aggregation */
        PES this = _thisPv(*ppvObj);
        if (SUCCEEDED(hres = CEShep_InitInstance(this, hkFF))) {
        } else {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CEShep_Signature        0x50454853      /* "SHEP" */

Interface_Template_Begin(CEShep)
    Primary_Interface_Template(CEShep, IDirectInputEffectShepherd)
Interface_Template_End(CEShep)

Primary_Interface_Begin(CEShep, IDirectInputEffectShepherd)
    CEShep_DeviceID,
    CEShep_GetVersions,
    CEShep_Escape,
    CEShep_DeviceEscape,
    CEShep_SetGain,
    CEShep_SetForceFeedbackState,
    CEShep_GetForceFeedbackState,
    CEShep_DownloadEffect,
    CEShep_DestroyEffect,
    CEShep_StartEffect,
    CEShep_StopEffect,
    CEShep_GetEffectStatus,
    CEShep_SetGlobalGain,
Primary_Interface_End(CEShep, IDirectInputEffectShepherd)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dieffv.c ===
/*****************************************************************************
 *
 *  DIEffV.c
 *
 *  Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Effect driver for VJOYD devices.
 *
 *  Contents:
 *
 *      CEffVxd_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"
#ifndef WINNT


/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflVxdEff

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CEffVxd_New!
 *
 *****************************************************************************/

Primary_Interface(CEffVxd, IDirectInputEffectDriver);

Interface_Template_Begin(CEffVxd)
    Primary_Interface_Template(CEffVxd, IDirectInputEffectDriver)
Interface_Template_End(CEffVxd)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CEffVxd |
 *
 *          An <i IDirectInputEffectDriver> wrapper for VJOYD
 *          joysticks.
 *
 *  @field  IDirectInputEffectDriver | didc |
 *
 *          The object (containing vtbl).
 *
 *****************************************************************************/

typedef struct CEffVxd {

    /* Supported interfaces */
    IDirectInputEffectDriver ded;

} CEffVxd, DVE, *PDVE;

typedef IDirectInputEffectDriver DED, *PDED;

#define ThisClass CEffVxd
#define ThisInterface IDirectInputEffectDriver
#define riidExpected &IID_IDirectInputEffectDriver

/*****************************************************************************
 *
 *      CEffVxd::QueryInterface   (from IUnknown)
 *      CEffVxd::AddRef           (from IUnknown)
 *      CEffVxd::Release          (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | IDirectInputEffectDriver | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/
/*
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | Finalize |
 *
 *          We don't have any instance data, so we can just
 *          forward to <f Common_Finalize>.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CEffVxd)
Default_AddRef(CEffVxd)
Default_Release(CEffVxd)

#else

#define CEffVxd_QueryInterface      Common_QueryInterface
#define CEffVxd_AddRef              Common_AddRef
#define CEffVxd_Release             Common_Release

#endif

#define CEffVxd_QIHelper            Common_QIHelper
#define CEffVxd_AppFinalize         Common_AppFinalize
#define CEffVxd_Finalize            Common_Finalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | DeviceID |
 *
 *          Inform the driver of the identity of the device.
 *          See <mf IDirectInputEffectDriver::DeviceID>
 *          for more information.
 *
 *          Doesn't do anything because VJOYD will already
 *          have told the driver its identity.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwDirectInputVersion |
 *
 *          The version of DirectInput that loaded the
 *          effect driver.
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The joystick ID number being used.
 *          The Windows joystick subsystem allocates external IDs.
 *
 *  @parm   DWORD | fBegin |
 *
 *          Nonzero if access to the device is beginning.
 *          Zero if the access to the device is ending.
 *
 *  @parm   DWORD | dwInternalID |
 *
 *          Internal joystick id.  The device driver manages
 *          internal IDs.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Reserved for future use (HID).
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_DeviceID(PDED pded, DWORD dwDIVer, DWORD dwExternalID, DWORD fBegin,
                 DWORD dwInternalID, LPVOID pvReserved)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::DeviceID,
               (_ "pxuuu", pded, dwDIVer, dwExternalID, fBegin, dwInternalID));

    this = _thisPvNm(pded, ded);

    dwDIVer;
    dwExternalID;
    fBegin;
    dwInternalID;
    pvReserved;

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEffVxd_Ioctl |
 *
 *          Perform an IOCTL to VJOYD.
 *
 *  @parm   DWORD | dwIOCode |
 *
 *          The function to perform.
 *
 *  @parm   PV | pvIn |
 *
 *          Input arguments, the number of which depends on the
 *          function code.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_Ioctl(DWORD dwIOCode, PV pvIn)
{
    HRESULT hres;
    HRESULT hresFF;
    EnterProc(CEffVxD_Ioctl, (_ "u", dwIOCode));

    /*
     *  Once again, we rely on the fact that STDCALL passes
     *  parameters right to left, so our arguments are exactly
     *  in the form of a VXDFFIO structure.
     */
    CAssertF(cbX(VXDFFIO) == cbX(dwIOCode) + cbX(pvIn));
    CAssertF(FIELD_OFFSET(VXDFFIO, dwIOCode) == 0);
    CAssertF(FIELD_OFFSET(VXDFFIO, pvArgs) == cbX(dwIOCode));
    AssertF(cbSubPvPv(&pvIn, &dwIOCode) == cbX(dwIOCode));

    hres = IoctlHw(IOCTL_JOY_FFIO, &dwIOCode, cbX(VXDFFIO),
                   &hresFF, cbX(hresFF));
    if (SUCCEEDED(hres)) {
        hres = hresFF;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | Escape |
 *
 *          Escape to the driver.
 *          See <mf IDirectInputEffectDriver::Escape>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The joystick ID number being used.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect at which the command is directed.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Command block.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_Escape(PDED pded, DWORD dwId, DWORD dwEffect, LPDIEFFESCAPE pesc)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::Escape,
               (_ "puxx", pded, dwId, dwEffect, pesc->dwCommand));

    this = _thisPvNm(pded, ded);

    dwId;
    dwEffect;
    pesc;

    hres = CEffVxd_Ioctl(FFIO_ESCAPE, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | SetGain |
 *
 *          Set the overall device gain.
 *          See <mf IDirectInputEffectDriver::SetGain>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The joystick ID number being used.
 *
 *  @parm   DWORD | dwGain |
 *
 *          The new gain value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          An error code if something is wrong.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_SetGain(PDED pded, DWORD dwId, DWORD dwGain)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::SetGain,
               (_ "puu", pded, dwId, dwGain));

    this = _thisPvNm(pded, ded);

    dwId;
    hres = CEffVxd_Ioctl(FFIO_SETGAIN, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | SetForceFeedbackState |
 *
 *          Change the force feedback state for the device.
 *          See <mf IDirectInputEffectDriver::SetForceFeedbackState>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwState |
 *
 *          New state, one of the <c DEV_*> values.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_SetForceFeedbackState(PDED pded, DWORD dwId, DWORD dwState)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::SetForceFeedbackState,
               (_ "pux", pded, dwId, dwState));

    this = _thisPvNm(pded, ded);

    dwId;
    dwState;

    hres = CEffVxd_Ioctl(FFIO_SETFFSTATE, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | GetForceFeedbackState |
 *
 *          Retrieve the force feedback state for the device.
 *          See <mf IDirectInputEffectDriver::GetForceFeedbackState>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   LPDIDEVICESTATE | pds |
 *
 *          Receives device state.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *  @devnote
 *
 *          Semantics unclear.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_GetForceFeedbackState(PDED pded, DWORD dwId, LPDIDEVICESTATE pds)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::GetForceFeedbackState,
               (_ "pup", pded, dwId, pds));

    this = _thisPvNm(pded, ded);

    dwId;
    pds;

    hres = CEffVxd_Ioctl(FFIO_GETFFSTATE, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | DownloadEffect |
 *
 *          Send an effect to the device.
 *          See <mf IDirectInputEffectDriver::SetGain>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffectId |
 *
 *          Magic cookie dword that identifies the effect.
 *
 *  @parm   IN OUT LPDWORD | pdwEffect |
 *
 *          The effect being modified.
 *
 *  @parm   LPCDIEFFECT | peff |
 *
 *          The new parameters for the effect.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIEP_*> flags.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_DownloadEffect(PDED pded, DWORD dwId, DWORD dwEffectId,
                       LPDWORD pdwEffect, LPCDIEFFECT peff, DWORD fl)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::DownloadEffect,
               (_ "puxxpx", pded, dwId, dwEffectId, *pdwEffect, peff, fl));

    this = _thisPvNm(pded, ded);

    dwEffectId;
    pdwEffect;
    peff;
    fl;

    hres = CEffVxd_Ioctl(FFIO_DOWNLOADEFFECT, &dwId);

    ExitOleProcPpv(pdwEffect);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | DestroyEffect |
 *
 *          Remove an effect from the device.
 *          See <mf IDirectInputEffectDriver::DestroyEffect>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be destroyed.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_DestroyEffect(PDED pded, DWORD dwId, DWORD dwEffect)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::DestroyEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    dwEffect;

    hres = CEffVxd_Ioctl(FFIO_DESTROYEFFECT, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | StartEffect |
 *
 *          Begin playback of an effect.
 *          See <mf IDirectInputEffectDriver::StartEffect>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be played.
 *
 *  @parm   DWORD | dwMode |
 *
 *          How the effect is to affect other effects.
 *
 *  @parm   DWORD | dwCount |
 *
 *          Number of times the effect is to be played.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_StartEffect(PDED pded, DWORD dwId, DWORD dwEffect,
                    DWORD dwMode, DWORD dwCount)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::StartEffect,
               (_ "puxxu", pded, dwId, dwEffect, dwMode, dwCount));

    this = _thisPvNm(pded, ded);

    dwEffect;
    dwMode;
    dwCount;
    hres = CEffVxd_Ioctl(FFIO_STARTEFFECT, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | StopEffect |
 *
 *          Halt playback of an effect.
 *          See <mf IDirectInputEffectDriver::StartEffect>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be stopped.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_StopEffect(PDED pded, DWORD dwId, DWORD dwEffect)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::StopEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    dwEffect;
    hres = CEffVxd_Ioctl(FFIO_STOPEFFECT, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CEffVxd | GetEffectStatus |
 *
 *          Obtain information about an effect.
 *          See <mf IDirectInputEffectDriver::StartEffect>
 *          for more information.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   DWORD | dwId |
 *
 *          The external joystick number being addressed.
 *
 *  @parm   DWORD | dwEffect |
 *
 *          The effect to be queried.
 *
 *  @parm   LPDWORD | pdwStatus |
 *
 *          Receives the effect status.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_GetEffectStatus(PDED pded, DWORD dwId, DWORD dwEffect,
                        LPDWORD pdwStatus)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::StopEffect,
               (_ "pux", pded, dwId, dwEffect));

    this = _thisPvNm(pded, ded);

    dwEffect;
    pdwStatus;
    hres = CEffVxd_Ioctl(FFIO_GETEFFECTSTATUS, &dwId);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    DDK
 *
 *  @method HRESULT | CEffVxd | GetVersions |
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  @cwrap  LPDIRECTINPUTEFFECTDRIVER | lpEffectDriver
 *
 *  @parm   LPDIDRIVERVERSIONS | pvers |
 *
 *          A structure which should be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *          DirectInput will set the <e DIDRIVERVERSIONS.dwSize> field
 *          to sizeof(DIDRIVERVERSIONS) before calling this method.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_GetVersions(PDED pded, LPDIDRIVERVERSIONS pvers)
{
    PDVE this;
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::GetVersions, (_ "pux", pded));

    this = _thisPvNm(pded, ded);

    /*
     *  Returning E_NOTIMPL causes DirectInput to ask the VxD for the same
     *  information.
     */
    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *      CEffVxd_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
CEffVxd_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputEffectDriver::VxD::<constructor>,
               (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CEffVxd, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        PDVE this;
        if (Num_Interfaces(CEffVxd) == 1) {
            this = _thisPvNm(*ppvObj, ded);
        } else {
            this = _thisPv(*ppvObj);
        }

        /* No initialization needed */
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CEffVxd_Signature        0x46454556      /* "VEFF" */

Primary_Interface_Begin(CEffVxd, IDirectInputEffectDriver)
    CEffVxd_DeviceID,
    CEffVxd_GetVersions,
    CEffVxd_Escape,
    CEffVxd_SetGain,
    CEffVxd_SetForceFeedbackState,
    CEffVxd_GetForceFeedbackState,
    CEffVxd_DownloadEffect,
    CEffVxd_DestroyEffect,
    CEffVxd_StartEffect,
    CEffVxd_StopEffect,
    CEffVxd_GetEffectStatus,
Primary_Interface_End(CEffVxd, IDirectInputEffectDriver)

#endif /* ndef WINNT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diemh.c ===
/*****************************************************************************
 *
 *  DIEmH.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Emulation module for HID.  HID is always run at ring 3,
 *      so "emulation" is a bit of a misnomer.
 *
 *  Contents:
 *
 *      CEm_HID_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

    #define sqfl sqflEm


/*****************************************************************************
 *
 *      Forward declarations
 *
 *      CEm_HID_ReadComplete and CEm_HID_IssueRead schedule each other
 *      back and forth.
 *
 *****************************************************************************/

void CALLBACK
    CEm_HID_ReadComplete(DWORD dwError, DWORD cbRead, LPOVERLAPPED po);
/*****************************************************************************
 *
 *          HID "emulation"
 *
 *****************************************************************************/

STDMETHODIMP CEm_HID_Acquire(PEM this, BOOL fAcquire);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | FakeCancelIO |
 *
 *          Stub function which doesn't do anything but
 *          keeps us from crashing.
 *
 *  @parm   HANDLE | h |
 *
 *          The handle whose I/O is supposed to be cancelled.
 *
 *****************************************************************************/

BOOL WINAPI
    FakeCancelIO(HANDLE h)
{
    AssertF(0);
    return FALSE;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | FakeTryEnterCriticalSection |
 *
 *          We use TryEnterCriticalSection in DEBUG to detect deadlock
 *          If the function does not exist, just enter CritSection and report
 *          true. This compromises some debug functionality.           
 *
 *  @parm   LPCRITICAL_SECTION | lpCriticalSection |
 *
 *          Address of Critical Section to be entered. 
 *
 *****************************************************************************/
#ifdef XDEBUG
BOOL WINAPI
    FakeTryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)
{
    EnterCriticalSection(lpCriticalSection);
    return TRUE;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_Hold |
 *
 *          Place a hold on both the parent device and the
 *          emulation structure, so neither will go away while
 *          we aren't paying attention.
 *
 *  @parm   PCHID | this |
 *
 *          The item to be held.
 *
 *****************************************************************************/

void INTERNAL
    CEm_Hid_Hold(PCHID this)
{
    CEm_AddRef(pemFromPvi(this->pvi));
    Common_Hold(this);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_Unhold |
 *
 *          Release the holds we placed via <f CEm_HID_Hold>.
 *
 *  @parm   PCHID | this |
 *
 *          The item to be unheld.
 *
 *****************************************************************************/

void INTERNAL
    CEm_Hid_Unhold(PCHID this)
{
    CEm_Release(pemFromPvi(this->pvi));
    Common_Unhold(this);
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   BOOL | CEm_HID_IssueRead |
 *
 *          Issue another read request.
 *
 *  @parm   PCHID | this |
 *
 *          The device on which the read is to be issued.
 *
 *  @returns
 *
 *          Returns nonzero if the read was successfully issued.
 *
 *****************************************************************************/

BOOL EXTERNAL
    CEm_HID_IssueRead(PCHID this)
{
    BOOL fRc;

    fRc = ReadFileEx(this->hdevEm, this->hriIn.pvReport,
                     this->hriIn.cbReport, &this->o,
                     CEm_HID_ReadComplete);

    if(!fRc)
    {
        /*
         *  Couldn't issue read; force an unacquire.
         *
         *  Unhold the device once, since the read loop is gone.
         */
        // 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("IssueRead: Access to HID device(%p, handle=0x%x) lost le=0x%x!"), 
                        this, this->hdevEm, GetLastError() );

        DllEnterCrit();
        ConfirmF(SUCCEEDED(GPA_DeletePtr(&g_plts->gpaHid, pemFromPvi(this->pvi))));
        DllLeaveCrit();

        CEm_ForceDeviceUnacquire(&this->ed,
                                 (!(this->pvi->fl & VIFL_ACQUIRED)) ? FDUFL_UNPLUGGED : 0);

        CEm_Hid_Unhold(this);

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("Removed HID device(%p) from GPA "), this);
    }
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_PrepareState |
 *
 *          Prepare the staging area for a new device state
 *          by assuming that nothing has changed.
 *
 *  @parm   PCHID | this |
 *
 *          The device on which a read has just completed.
 *
 *****************************************************************************/

void INLINE
    CEm_HID_PrepareState(PCHID this)
{
    /*
     *  Copy over everything...
     */
    CopyMemory(this->pvStage, this->pvPhys, this->cbPhys);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_ReadComplete |
 *
 *          APC function which is called when an I/O has completed.
 *
 *  @parm   DWORD | dwError |
 *
 *          Error code, or zero on success.
 *
 *  @parm   DWORD | cbRead |
 *
 *          Number of bytes actually read.
 *
 *  @parm   LPOVERLAPPED | po |
 *
 *          I/O packet that completed.
 *
 *****************************************************************************/

void CALLBACK
    CEm_HID_ReadComplete(DWORD dwError, DWORD cbRead, LPOVERLAPPED po)
{
    PCHID this = pchidFromPo(po);

    //EnterProc(Cem_HID_ReadComplete, (_"ddp", dwError, cbRead, po ));


    /*
     *  Cannot own any critical sections because CEm_ForceDeviceUnacquire
     *  assumes that no critical sections are taken.
     */
    AssertF(!CDIDev_InCrit(this->pvi->pdd));
    AssertF(!DllInCrit());

    /*
     *  Process the data.
     *
     *  Note: We can get error STATUS_DEVICE_NOT_CONNECTED
     *  or ERROR_READ_FAULT if the device is unplugged.
     */
    if(dwError == 0 &&
       this->o.InternalHigh == this->caps.InputReportByteLength)
    {

        NTSTATUS stat;

        CEm_HID_PrepareState(this);

        stat = CHid_ParseData(this, HidP_Input, &this->hriIn);

        if(SUCCEEDED(stat))
        {
            CEm_AddState(&this->ed, this->pvStage, GetTickCount());
        }

        CEm_HID_IssueRead(this);
    } else
    {

        if(!dwError)
        {
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqflError | sqfl,
                            TEXT("ReadComplete HID(%p) short read! Got %d wanted %d"),
                            this,
                            this->o.InternalHigh,
                            this->caps.InputReportByteLength);

        } else
        {
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqflError | sqfl,
                            TEXT("ReadComplete HID(%p) read failed! error=0x%08x "),
                            this, dwError);
        }

        DllEnterCrit();
        ConfirmF(SUCCEEDED(GPA_DeletePtr(&g_plts->gpaHid, pemFromPvi(this->pvi))));
        DllLeaveCrit();

        CEm_ForceDeviceUnacquire(&this->ed,
                                 (!(this->pvi->fl & VIFL_ACQUIRED)) ? FDUFL_UNPLUGGED : 0);

        CEm_Hid_Unhold(this);
    }

    /*
     *  And wait for more data.
     *  If the read failed, then CEm_HID_IssueRead() will its Reference 
     */
    //    CEm_HID_IssueRead(this);

    //ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CEm_HID_Sync |
 *
 *          Kick off a read or kill the existing one.
 *
 *  @parm   PLLTHREADSTATE | plts |
 *
 *          Thread hook state containing hook information to synchronize.
 *
 *  @parm   PEM | pem |
 *
 *          Who is the poor victim?
 *
 *****************************************************************************/

void EXTERNAL
    CEm_HID_Sync(PLLTHREADSTATE plts, PEM pem)
{
    PCHID this;

    EnterProc(CEm_HID_Sync, (_ "pp", plts, pem ));

    this = pchidFromPem(pem);

    AssertF(GPA_FindPtr(&plts->gpaHid, pem));
    AssertF(this->pvi == &pem->vi);
    AssertF(pem->ped == &this->ed);

    /*
     *  Cannot own any critical sections because CEm_HID_IssueRead
     *  may result in a call to CEm_ForceDeviceUnacquire, which
     *  in turn assumes that no critical sections are taken.
     */
    AssertF(!CDIDev_InCrit(this->pvi->pdd));
    AssertF(!DllInCrit());

    if( pem->vi.fl & VIFL_ACQUIRED )
    {
        AssertF(this->hdevEm == INVALID_HANDLE_VALUE);
        /*
         *  Start reading.
         *
         *  While underneath the device critical section, duplicate
         *  the handle so we can avoid race conditions with the
         *  main thread (when the main thread closes the handle,
         *  we need to keep our private version alive so we can
         *  clean it up nicely).
         */

        /*
         *  Need to look again, in case the device has already
         *  been unacquired before we get a chance to synchronize
         *  with the main thread.  This can happen, for example,
         *  if the app quickly does an Acquire/Unacquire without
         *  an intervening thread switch.
         */
        AssertF(!CDIDev_InCrit(this->pvi->pdd));
        //CDIDev_EnterCrit(this->pvi->pdd);
        if(this->hdev != INVALID_HANDLE_VALUE)
        {
            HANDLE hProcessMe = GetCurrentProcess();
            HANDLE hdevEm;

            if(DuplicateHandle(hProcessMe, this->hdev,
                               hProcessMe, &hdevEm, GENERIC_READ,
                               0, 0))
            {
                this->hdevEm = hdevEm;
            }
        }
        //CDIDev_LeaveCrit(this->pvi->pdd);

        if(this->hdevEm != INVALID_HANDLE_VALUE)
        {
            /*
             *  On Win98, HidD_FlushQueue will fail if the underlying
             *  device is dead.  Whereas on NT, it blindly succeeds.
             *  Therefore, we cannot trust the return value.
             */
            HidD_FlushQueue(this->hdevEm);
        }

        /*
         * Even if we have failed to duplicate the handle
         * we still want to issue the read. A error in read
         * will force the device to be unacquired
         */
        CEm_HID_IssueRead(this);

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT(" StartReading(%p) "),
                        this);
    } else 
    {
        HANDLE hdev;
        /*
         *  Stop reading. There is still another outstanding
         *  hold by the read loop, which will be cleaned up when
         *  the the I/O cancel is received.
         */
        AssertF(this->hdevEm != INVALID_HANDLE_VALUE);

        hdev = this->hdevEm;
        this->hdevEm = INVALID_HANDLE_VALUE;

        if(hdev != INVALID_HANDLE_VALUE)
        {
            /*
             *  We don't need to call CancelIo because we're closing
             *  the handle soon anyway.  Which is good, because Memphis
             *  B#55771 prevents CancelIo from working on read-only
             *  handles (which we are).
             *
             */
            /* Need CancelIo on NT otherwise HID devices appear only on every
             * consecutive plug in 
             */

            _CancelIO(hdev);
            CloseHandle(hdev);
        }

        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT(" StopReading(%p) "),
                        this);
    }

    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_HID_Acquire |
 *
 *          Acquire/unacquire a HID device.
 *
 *  @parm   PEM | pem |
 *
 *          Device being acquired.
 *
 *  @parm   BOOL | fAcquire |
 *
 *          Whether the device is being acquired or unacquired.
 *
 *****************************************************************************/

STDMETHODIMP
    CEm_HID_Acquire(PEM pem, BOOL fAcquire)
{
    HRESULT hres;
    PLLTHREADSTATE plts;
    PCHID pchid;

    EnterProc(CEm_HID_Acquire, (_ "pu", pem, fAcquire));

    AssertF(pem->dwSignature == CEM_SIGNATURE);

    pchid = pchidFromPem(pem);

    if( fAcquire )
    {
        pchid->hdev = CHid_OpenDevicePath(pchid, FILE_FLAG_OVERLAPPED);

        if(pchid->hdev != INVALID_HANDLE_VALUE )
        {
            hres = S_OK;
        } else {
            hres = DIERR_UNPLUGGED;
        }

    } else
    {
        AssertF(pchid->hdev != INVALID_HANDLE_VALUE);

        _CancelIO(pchid->hdev);
        CloseHandle(pchid->hdev);
        pchid->hdev = INVALID_HANDLE_VALUE;

        hres = S_OK;
    }

    if( pchid->IsPolledInput )
    {
        hres = S_OK;
        AssertF(pchid->hdevEm == INVALID_HANDLE_VALUE);

    } else if( SUCCEEDED(hres) )
    {
      #ifdef USE_WM_INPUT
        ResetEvent( g_hEventHid );
      #endif
            
        hres = CEm_GetWorkerThread(pem, &plts);

        if(SUCCEEDED(hres)  )
        {
            if(fAcquire  )
            {  /* Begin the I/O */
                /*
                 *  Must apply the hold before adding to the list
                 *  to avoid a race condition where the worker thread
                 *  unholds the pchid before we can hold it.
                 *
                 *  The rule is that there is a hold to track each copy
                 *  of the device on the gpaHid.
                 */
                CEm_Hid_Hold(pchid);

                /*
                 *  Add ourselves to the busy list, and wake up
                 *  the worker thread to tell him to start paying attention.
                 */

                DllEnterCrit();
                hres = GPA_Append(&plts->gpaHid, pem);
                DllLeaveCrit();

                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("Added HID device(%p) to GPA "), pchid );

                if(FAILED(hres))
                {
                    CEm_Hid_Unhold(pchid);
                }

                NudgeWorkerThreadPem(plts, pem);

              #ifdef USE_WM_INPUT
                if( g_fRawInput ) {
                    DWORD dwRc;
                    dwRc = WaitForSingleObject( g_hEventHid, INFINITE );
                }
              #endif

            } else
            {
                HANDLE hdev;

                hdev = pchid->hdevEm;
                pchid->hdevEm = INVALID_HANDLE_VALUE;

                if(hdev != INVALID_HANDLE_VALUE)
                {
                    _CancelIO(hdev);
                    CloseHandle(hdev);
                }
            }

        }

    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CEm_HID_CreateInstance |
 *
 *          Create a HID thing.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          What the object should look like.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          The answer goes here.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    CEm_HID_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    PCHID pchid = (PCHID)pdevf->dwExtra;
    PED ped = &pchid->ed;

    AssertF(ped->pState == 0);
    AssertF(ped->pDevType == 0);
    *(PPV)&ped->pState = pchid->pvPhys;      /* De-const */
    ped->Acquire = CEm_HID_Acquire;
    ped->cAcquire = -1;
    ped->cbData = pdevf->cbData;
    ped->cRef = 0x0;

    return CEm_CreateInstance(pdevf, ppviOut, &pchid->ed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\digendef.c ===
/*****************************************************************************
 *
 *  DIGenDef.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Default IDirectInputDevice callback.
 *
 *  Contents:
 *
 *      CDefDcb_Acquire
 *      CDefDcb_Unacquire
 *      CDefDcb_GetProperty
 *      CDefDcb_SetProperty
 *      CDefDcb_SetCooperativeLevel
 *      CDefDcb_CookDeviceData
 *      CDefDcb_CreateEffect
 *      CDefDcb_GetFFConfigKey
 *      CDefDcb_SendDeviceData
 *      CDefDcb_Poll
 *      CDefDcb_MapUsage
 *      CDefDcb_GetUsage
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflNil

/*****************************************************************************
 *
 *      Note!  These are generic default functions that all return
 *      E_NOTIMPL.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | Acquire |
 *
 *          Tell the device driver to begin data acquisition.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: The device could not be acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_Acquire(PDICB pdcb)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::Acquire, (_ "p", pdcb));

    hres = S_FALSE;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | Unacquire |
 *
 *          Tell the device driver to stop data acquisition.
 *
 *          It is the caller's responsibility to call this only
 *          when the device has been acquired.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: The device was not acquired.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_Unacquire(PDICB pdcb)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::Unacquire, (_ "p", pdcb));

    hres = S_FALSE;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDefDcb | GetProperty |
 *
 *          Retrieve a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Where to put the property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CDefDcb | SetProperty |
 *
 *          Set a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::SetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | SetEventNotification |
 *
 *          Called by DirectInput to inquire whether the device
 *          supports event notifications.
 *
 *  @parm   IN PDM | this |
 *
 *          The object in question.
 *
 *  @field  HANDLE | h |
 *
 *          The notification handle, if any.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SetEventNotification(PDICB pdcb, HANDLE h)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::DefDcb::SetEventNotification,
               (_ "px", pdcb, h));

    /*
     *  Yes, we support it.  Please do it for me.
     */
    hres = S_FALSE;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefdcb | SetCooperativeLevel |
 *
 *          Notify the device of the cooperative level.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | CookDeviceData |
 *
 *          Manipulate buffered device data.
 *
 *  @parm   DWORD | cdod |
 *
 *          Number of objects to cook; zero is a valid value.
 *
 *  @parm   LPDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of object data to cook.
 *
 *  @returns
 *
 *          <c E_NOTIMPL>: Nothing happened.
 *
 ***************************************************************************/

STDMETHODIMP
CDefDcb_CookDeviceData
(
    PDICB                   pdcb, 
    DWORD                   cdod, 
    LPDIDEVICEOBJECTDATA    rgdod
)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::CookDeviceData,
               (_ "pxp", pdcb, cdod, rgdod));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | CreateEffect |
 *
 *          Create an <i IDirectInputEffectDriver> interface.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD * | ppes |
 *
 *          Receives the shepherd for the effect driver.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Kbd::CreateEffect, (_ "p", pdcb));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | GetFFConfigKey |
 *
 *          Open and return the registry key that contains
 *          force feedback configuration information.
 *
 *  @parm   DWORD | sam |
 *
 *          Security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the registry key.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::GetFFConfigKey,
               (_ "px", pdcb, sam));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | SendDeviceData |
 *
 *          Spew some data to the device.
 *
 *  @parm   DWORD | cbdod |
 *
 *          Size of each object.
 *
 *  @parm   IN LPCDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          Number of items actually sent.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we don't support output.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SendDeviceData(PDICB pdcb, DWORD cbdod, LPCDIDEVICEOBJECTDATA rgdod,
                       LPDWORD pdwInOut, DWORD fl)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::SendDeviceData, (_ "p", pdcb));

    *pdwInOut = 0;
    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | Poll |
 *
 *          Ping down into the driver to get the latest data.
 *
 *  @returns
 *
 *          <c S_FALSE> because nothing is pollable.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_Poll(PDICB pdcb)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::Poll, (_ "p", pdcb));

    hres = S_FALSE;

    ExitOleProcR();
    return hres;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | GetVersions |
 *
 *          Obtain version information about the force feedback
 *          hardware and driver.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: No version
 *          information is available.
 *
 ***************************************************************************/

STDMETHODIMP
CDefDcb_GetVersions(PDICB pdcb, LPDIDRIVERVERSIONS pvers)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::GetVersions, (_ "p", pdcb));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | MapUsage |
 *
 *          Given a usage and usage page (munged into a single
 *          <t DWORD>), find a device object that matches it.
 *
 *  @parm   DWORD | dwUsage |
 *
 *          The usage page and usage combined into a single <t DWORD>
 *          with the <f DIMAKEUSAGEDWORD> macro.
 *
 *  @parm   PINT | piOut |
 *
 *          Receives the object index of the found object, if successful.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we don't support usages.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_MapUsage(PDICB pdcb, DWORD dwUsage, PINT piOut)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::MapUsage, (_ "p", pdcb));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CDefDcb | GetUsage |
 *
 *          Given an object index, return the usage and usage page,
 *          packed into a single <t DWORD>.
 *
 *  @parm   int | iobj |
 *
 *          The object index to convert.
 *
 *  @returns
 *
 *          Zero because we don't support usages.
 *
 *****************************************************************************/

STDMETHODIMP_(DWORD)
CDefDcb_GetUsage(PDICB pdcb, int iobj)
{
    EnterProcI(IDirectInputDeviceCallback::Def::GetUsage, (_ "p", pdcb));

    return 0;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | SetDIData |
 *
 *          Set DirectInput version and AppHack data from CDIDev *.
 *
 *  @parm   DWORD | dwVer |
 *
 *          DirectInput version
 *
 *  @parm   LPVOID | lpdihacks |
 *
 *          AppHack data
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we can't store the data in the device 
 *          specific structure from the default callback.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::SetDIData, (_ "pup", pdcb, dwVer, lpdihacks));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDefDcb | BuildDefaultActionMap |
 *
 *          Generate default mappings for the objects on this device.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInst |
 *
 *          Device instance GUID.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because default mapping has to be done by specific 
 *          device callback.
 *
 *****************************************************************************/

STDMETHODIMP
CDefDcb_BuildDefaultActionMap
(
    PDICB               pdcb, 
    LPDIACTIONFORMATW   paf, 
    DWORD               dwFlags, 
    REFGUID             guidInst
)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Def::BuildDefaultActionMap, 
        (_ "ppxG", pdcb, paf, dwFlags, guidInst));

    hres = E_NOTIMPL;

    ExitOleProcR();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diextdll.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       diextdll.h
 *  Content:    DirectInput internal include file for external DLL access
 *
 ***************************************************************************/

#ifndef _DIEXTDLL_H
#define _DIEXTDLL_H

/*****************************************************************************
 *
 *      diextdll.c - Imports from optional external DLLs
 *
 *      It is very important that HidD_GetHidGuid be the very last one.
 *
 *****************************************************************************/

    #ifdef STATIC_DLLUSAGE
        #define ExtDll_Init()
    #else
void EXTERNAL ExtDll_Init(void);
    #endif
void EXTERNAL ExtDll_Term(void);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct MANUALIMPORT |
 *
 *          Records a single manual import.  If it hasn't
 *          yet been resolved, then the <e MANUALIMPORT.ptsz>
 *          points to the procedure name.  If it has been resolved
 *          successfully, then <e MANUALIMPORT.pfn> points to
 *          the resolved address.  If it has not been resolved
 *          successfully, then <e MANUALIMPORT.pfn> is garbage.
 *
 *  @field  LPCSTR | psz |
 *
 *          Procdure name.  Note that this is always an ANSI string.
 *
 *  @field  FARPROC | pfn |
 *
 *          Procedure address.
 *
 *****************************************************************************/

typedef struct MANUALIMPORT
{
    FARPROC pfn;                    /* Procedure address */
} MANUALIMPORT, *PMANUALIMPORT;

#ifndef STATIC_DLLUSAGE

#ifndef WINNT
/*****************************************************************************
 *
 * CFGMGR32
 *
 *  Note that this must match the CFGMGR32 section in diextdll.c
 *
 *****************************************************************************/

typedef union CFGMGR32
{

    MANUALIMPORT rgmi[6];              /* number of functions we import */

    struct
    {
        CONFIGRET ( WINAPI * _CM_Get_Child)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_Sibling)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  DevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_Parent)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_DevNode_Registry_Property)
        (
        IN  DEVINST     dnDevInst,
        IN  ULONG       ulProperty,
        OUT PULONG      pulRegDataType,   OPTIONAL
        OUT PVOID       Buffer,           OPTIONAL
        IN  OUT PULONG  pulLength,
        IN  ULONG       ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Set_DevNode_Registry_Property)
        (
        IN  DEVINST     dnDevInst,
        IN  ULONG       ulProperty,
        IN  PVOID       Buffer,           OPTIONAL
        IN  ULONG       ulLength,
        IN  ULONG       ulFlags
        );
    
        CONFIGRET( WINAPI * _CM_Get_Device_ID)
        (
         IN  DEVINST  dnDevInst,
         OUT PTCHAR   Buffer,
         IN  ULONG    BufferLen,
         IN  ULONG    ulFlags
        );    

    };

} CFGMGR32, *PFGMGR32;

extern CFGMGR32 g_cfgmgr32;

        #undef CM_Get_Child
        #undef CM_Get_Sibling
        #undef CM_Get_Parent
        #undef CM_Get_DevNode_Registry_Property
        #undef CM_Set_DevNode_Registry_Property
        #undef CM_Get_Device_ID

        #define             CM_Get_Child                       \
        g_cfgmgr32._CM_Get_Child

        #define             CM_Get_Sibling                     \
        g_cfgmgr32._CM_Get_Sibling

        #define             CM_Get_Parent                      \
        g_cfgmgr32._CM_Get_Parent

        #define             CM_Get_DevNode_Registry_Property   \
        g_cfgmgr32._CM_Get_DevNode_Registry_Property

        #define             CM_Set_DevNode_Registry_Property    \
        g_cfgmgr32._CM_Set_DevNode_Registry_Property
        
        #define             CM_Get_Device_ID                    \
        g_cfgmgr32._CM_Get_Device_ID
#endif  //#ifndef WINNT

/*****************************************************************************
 *
 *  SETUPAPI
 *
 *  Note that this must match the SETUPAPI section in diextdll.c
 *
 *****************************************************************************/

typedef union SETUPAPI
{

  #ifdef WINNT
    MANUALIMPORT rgmi[18];              /* number of functions we import */
  #else
    MANUALIMPORT rgmi[12];              /* number of functions we import */
  #endif
    
    struct
    {

        HDEVINFO (WINAPI *_SetupDiGetClassDevs)
        (
        IN LPGUID ClassGuid,  OPTIONAL
        IN LPCTSTR Enumerator, OPTIONAL
        IN HWND   hwndParent, OPTIONAL
        IN DWORD  Flags
        );

        BOOL (WINAPI *_SetupDiDestroyDeviceInfoList)
        (
        IN HDEVINFO DeviceInfoSet
        );

        BOOL (WINAPI *_SetupDiGetDeviceInterfaceDetail)
        (
        IN  HDEVINFO                         DeviceInfoSet,
        IN  PSP_DEVICE_INTERFACE_DATA        pdid,
        OUT PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd,         OPTIONAL
        IN  DWORD                            cbDidd,
        OUT PDWORD                           RequiredSize,  OPTIONAL
        OUT PSP_DEVINFO_DATA                 DeviceInfoData OPTIONAL
        );

        BOOL (WINAPI *_SetupDiEnumDeviceInterfaces)
        (
        IN  HDEVINFO                  DeviceInfoSet,
        IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
        IN  LPGUID                    InterfaceClassGuid,
        IN  DWORD                     MemberIndex,
        OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
        );

        HKEY (WINAPI *_SetupDiCreateDeviceInterfaceRegKey)
        (
        IN HDEVINFO                  hdev,
        IN PSP_DEVICE_INTERFACE_DATA pdid,
        IN DWORD                     Reserved,
        IN REGSAM                    samDesired,
        IN HINF                      InfHandle,           OPTIONAL
        IN PCSTR                     InfSectionName       OPTIONAL
        );

        BOOL (WINAPI *_SetupDiCallClassInstaller)
        (
        IN DI_FUNCTION      InstallFunction,
        IN HDEVINFO         DeviceInfoSet,
        IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
        );

        BOOL (WINAPI *_SetupDiGetDeviceRegistryProperty)
        (
        IN  HDEVINFO         DeviceInfoSet,
        IN  PSP_DEVINFO_DATA DeviceInfoData,
        IN  DWORD            Property,
        OUT PDWORD           PropertyRegDataType, OPTIONAL
        OUT PBYTE            PropertyBuffer,
        IN  DWORD            PropertyBufferSize,
        OUT PDWORD           RequiredSize         OPTIONAL
        );

        BOOL (WINAPI *_SetupDiSetDeviceRegistryProperty)
        (
        IN     HDEVINFO         DeviceInfoSet,
        IN OUT PSP_DEVINFO_DATA DeviceInfoData,
        IN     DWORD            Property,
        IN     CONST BYTE*      PropertyBuffer,
        IN     DWORD            PropertyBufferSize
        );

        BOOL (WINAPI *_SetupDiGetDeviceInstanceId)
        (
        IN  HDEVINFO         DeviceInfoSet,
        IN  PSP_DEVINFO_DATA DeviceInfoData,
        OUT PTSTR            DeviceInstanceId,
        IN  DWORD            DeviceInstanceIdSize,
        OUT PDWORD           RequiredSize          OPTIONAL
        );

        BOOL (WINAPI *_SetupDiOpenDeviceInfo)
        (
        IN  HDEVINFO         DeviceInfoSet,
        IN  LPCTSTR          DeviceInstanceId,
        IN  HWND             hwndParent,       OPTIONAL
        IN  DWORD            OpenFlags,
        OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
        );

        HDEVINFO (WINAPI *_SetupDiCreateDeviceInfoList)
        (
        IN LPGUID ClassGuid, OPTIONAL
        IN HWND   hwndParent OPTIONAL
        );

        HKEY (WINAPI *_SetupDiOpenDevRegKey)
        (
        IN HDEVINFO         DeviceInfoSet,
        IN PSP_DEVINFO_DATA DeviceInfoData,
        IN DWORD            Scope,
        IN DWORD            HwProfile,
        IN DWORD            KeyType,
        IN REGSAM           samDesired
        );
        
      #ifdef WINNT
        CONFIGRET ( WINAPI * _CM_Get_Child)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_Sibling)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  DevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_Parent)
        (
        OUT PDEVINST pdnDevInst,
        IN  DEVINST  dnDevInst,
        IN  ULONG    ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Get_DevNode_Registry_Property)
        (
        IN  DEVINST     dnDevInst,
        IN  ULONG       ulProperty,
        OUT PULONG      pulRegDataType,   OPTIONAL
        OUT PVOID       Buffer,           OPTIONAL
        IN  OUT PULONG  pulLength,
        IN  ULONG       ulFlags
        );

        CONFIGRET ( WINAPI * _CM_Set_DevNode_Registry_Property)
        (
        IN  DEVINST     dnDevInst,
        IN  ULONG       ulProperty,
        IN  PVOID       Buffer,           OPTIONAL
        IN  ULONG       ulLength,
        IN  ULONG       ulFlags
        );
    
        CONFIGRET( WINAPI * _CM_Get_Device_ID)
        (
         IN  DEVINST  dnDevInst,
         OUT PTCHAR   Buffer,
         IN  ULONG    BufferLen,
         IN  ULONG    ulFlags
        );    
        
      #endif

    };
} SETUPAPI, *PSETUPAPI;

extern SETUPAPI g_setupapi;

        #undef SetupDiGetClassDevs
        #undef SetupDiDestroyDeviceInfoList
        #undef SetupDiGetDeviceInterfaceDetail
        #undef SetupDiEnumDeviceInterfaces
        #undef SetupDiCreateDeviceInterfaceRegKey
        #undef SetupDiCallClassInstaller
        #undef SetupDiGetDeviceRegistryProperty
        #undef SetupDiSetDeviceRegistryProperty
        #undef SetupDiGetDeviceInstanceId
        #undef SetupDiOpenDeviceInfo
        #undef SetupDiCreateDeviceInfoList
        #undef SetupDiOpenDevRegKey

        #define             SetupDiGetClassDevs                 \
        g_setupapi._SetupDiGetClassDevs

        #define             SetupDiDestroyDeviceInfoList        \
        g_setupapi._SetupDiDestroyDeviceInfoList

        #define             SetupDiGetDeviceInterfaceDetail     \
        g_setupapi._SetupDiGetDeviceInterfaceDetail

        #define             SetupDiEnumDeviceInterfaces         \
        g_setupapi._SetupDiEnumDeviceInterfaces

        #define             SetupDiCreateDeviceInterfaceRegKey  \
        g_setupapi._SetupDiCreateDeviceInterfaceRegKey

        #define             SetupDiCallClassInstaller           \
        g_setupapi._SetupDiCallClassInstaller

        #define             SetupDiGetDeviceRegistryProperty    \
        g_setupapi._SetupDiGetDeviceRegistryProperty

        #define             SetupDiSetDeviceRegistryProperty    \
        g_setupapi._SetupDiSetDeviceRegistryProperty

        #define             SetupDiGetDeviceInstanceId          \
        g_setupapi._SetupDiGetDeviceInstanceId

        #define             SetupDiOpenDeviceInfo               \
        g_setupapi._SetupDiOpenDeviceInfo

        #define             SetupDiCreateDeviceInfoList         \
        g_setupapi._SetupDiCreateDeviceInfoList

        #define             SetupDiOpenDevRegKey                \
        g_setupapi._SetupDiOpenDevRegKey

      #ifdef WINNT
        #undef CM_Get_Child
        #undef CM_Get_Sibling
        #undef CM_Get_Parent
        #undef CM_Get_DevNode_Registry_Property
        #undef CM_Set_DevNode_Registry_Property
        #undef CM_Get_Device_ID

        #define             CM_Get_Child                        \
        g_setupapi._CM_Get_Child

        #define             CM_Get_Sibling                      \
        g_setupapi._CM_Get_Sibling

        #define             CM_Get_Parent                       \
        g_setupapi._CM_Get_Parent

        #define             CM_Get_DevNode_Registry_Property    \
        g_setupapi._CM_Get_DevNode_Registry_Property

        #define             CM_Set_DevNode_Registry_Property    \
        g_setupapi._CM_Set_DevNode_Registry_Property
        
        #define             CM_Get_Device_ID                   \
        g_setupapi._CM_Get_Device_ID
      #endif

/*****************************************************************************
 *
 *  HIDDLL
 *
 *  Note that this must match the HID section in diextdll.c
 *
 *****************************************************************************/

typedef union HIDDLL
{

    MANUALIMPORT rgmi[22];              /* number of functions we import */

    struct
    {
        void (__stdcall *_HidD_GetHidGuid)
        (
        OUT   LPGUID   HidGuid
        );

        BOOLEAN (__stdcall *_HidD_GetPreparsedData)
        (
        IN    HANDLE                  HidDeviceObject,
        OUT   PHIDP_PREPARSED_DATA  * PreparsedData
        );

        BOOLEAN (__stdcall *_HidD_FreePreparsedData)
        (
        IN    PHIDP_PREPARSED_DATA PreparsedData
        );

        BOOLEAN (__stdcall *_HidD_FlushQueue)
        (
        IN    HANDLE                HidDeviceObject
        );

        BOOLEAN (__stdcall *_HidD_GetAttributes)
        (
        IN  HANDLE              HidDeviceObject,
        OUT PHIDD_ATTRIBUTES    Attributes
        );

        BOOLEAN (__stdcall *_HidD_GetFeature)
        (
        IN    HANDLE   HidDeviceObject,
        OUT   PVOID    ReportBuffer,
        IN    ULONG    ReportBufferLength
        );

        BOOLEAN (__stdcall *_HidD_SetFeature)
        (
        IN    HANDLE   HidDeviceObject,
        IN    PVOID    ReportBuffer,
        IN    ULONG    ReportBufferLength
        );

        BOOLEAN (__stdcall *_HidD_GetProductString)
        (
        IN    HANDLE   HidDeviceObject,
        OUT   PVOID    Buffer,
        IN    ULONG    BufferLength
        );

        BOOLEAN (__stdcall *_HidD_GetInputReport)
        (
        IN    HANDLE   HidDeviceObject,
        OUT   PVOID    ReportBuffer,
        IN    ULONG    ReportBufferLength
        );

        NTSTATUS (__stdcall *_HidP_GetCaps)
        (
        IN      PHIDP_PREPARSED_DATA      PreparsedData,
        OUT     PHIDP_CAPS                Capabilities
        );

        NTSTATUS (__stdcall *_HidP_GetButtonCaps)
        (
        IN       HIDP_REPORT_TYPE     ReportType,
        OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
        IN OUT   PUSHORT              ButtonCapsLength,
        IN       PHIDP_PREPARSED_DATA PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_GetValueCaps)
        (
        IN       HIDP_REPORT_TYPE     ReportType,
        OUT      PHIDP_VALUE_CAPS     ValueCaps,
        IN OUT   PUSHORT              ValueCapsLength,
        IN       PHIDP_PREPARSED_DATA PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_GetLinkCollectionNodes)
        (
        OUT      PHIDP_LINK_COLLECTION_NODE LinkCollectionNodes,
        IN OUT   PULONG                     LinkCollectionNodesLength,
        IN       PHIDP_PREPARSED_DATA       PreparsedData
        );

        ULONG (__stdcall *_HidP_MaxDataListLength)
        (
        IN HIDP_REPORT_TYPE      ReportType,
        IN PHIDP_PREPARSED_DATA  PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_GetUsagesEx)
        (
        IN       HIDP_REPORT_TYPE     ReportType,
        IN       USHORT               LinkCollection,
        OUT      PUSAGE_AND_PAGE      ButtonList,
        IN OUT   ULONG *              UsageLength,
        IN       PHIDP_PREPARSED_DATA PreparsedData,
        IN       PCHAR                Report,
        IN       ULONG                ReportLength
        );

        NTSTATUS (__stdcall *_HidP_GetScaledUsageValue)
        (
        IN    HIDP_REPORT_TYPE     ReportType,
        IN    USAGE                UsagePage,
        IN    USHORT               LinkCollection,
        IN    USAGE                Usage,
        OUT   PLONG                UsageValue,
        IN    PHIDP_PREPARSED_DATA PreparsedData,
        IN    PCHAR                Report,
        IN    ULONG                ReportLength
        );

        NTSTATUS (__stdcall *_HidP_GetData)
        (
        IN       HIDP_REPORT_TYPE      ReportType,
        OUT      PHIDP_DATA            DataList,
        IN OUT   PULONG                DataLength,
        IN       PHIDP_PREPARSED_DATA  PreparsedData,
        IN       PCHAR                 Report,
        IN       ULONG                 ReportLength
        );

        NTSTATUS (__stdcall *_HidP_SetData)
        (
        IN       HIDP_REPORT_TYPE      ReportType,
        IN       PHIDP_DATA            DataList,
        IN OUT   PULONG                DataLength,
        IN       PHIDP_PREPARSED_DATA  PreparsedData,
        IN OUT   PCHAR                 Report,
        IN       ULONG                 ReportLength
        );

        NTSTATUS (__stdcall *_HidP_GetUsageValue)
        (
        IN    HIDP_REPORT_TYPE     ReportType,
        IN    USAGE                UsagePage,
        IN    USHORT               LinkCollection,
        IN    USAGE                Usage,
        OUT   PULONG               UsageValue,
        IN    PHIDP_PREPARSED_DATA PreparsedData,
        IN    PCHAR                Report,
        IN    ULONG                ReportLength
        );

        ULONG (__stdcall *_HidP_MaxUsageListLength)
        (
        IN HIDP_REPORT_TYPE      ReportType,
        IN USAGE                 UsagePage,
        IN PHIDP_PREPARSED_DATA  PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_GetSpecificButtonCaps) 
        (
        IN       HIDP_REPORT_TYPE     ReportType,
        IN       USAGE                UsagePage,      // Optional (0 => ignore)
        IN       USHORT               LinkCollection, // Optional (0 => ignore)
        IN       USAGE                Usage,          // Optional (0 => ignore)
        OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
        IN OUT   PUSHORT              ButtonCapsLength,
        IN       PHIDP_PREPARSED_DATA PreparsedData
        );

        NTSTATUS (__stdcall *_HidP_TranslateUsagesToI8042ScanCodes)
        (
        IN       PUSAGE               ChangedUsageList, // Those usages that changed
        IN       ULONG                UsageListLength,
        IN       HIDP_KEYBOARD_DIRECTION KeyAction,
        IN OUT   PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
        IN       PHIDP_INSERT_SCANCODES  InsertCodesProcedure,
        IN       PVOID                InsertCodesContext
        );

    };

} HIDDLL, *PHIDDLL;

extern HIDDLL g_hiddll;

        #undef HidD_GetHidGuid
        #undef HidD_GetPreparsedData
        #undef HidD_FreePreparsedData
        #undef HidD_FlushQueue
        #undef HidD_GetAttributes
        #undef HidD_GetFeature
        #undef HidD_SetFeature
        #undef HidD_GetProductString
        #undef HidD_GetInputReport
        #undef HidP_GetCaps
        #undef HidP_GetButtonCaps
        #undef HidP_GetValueCaps
        #undef HidP_GetLinkCollectionNodes
        #undef HidP_MaxDataListLength
        #undef HidP_GetUsagesEx
        #undef HidP_GetScaledUsageValue
        #undef HidP_GetData
        #undef HidP_SetData
        #undef HidP_GetUsageValue
        #undef HidP_MaxUsageListLength
        #undef HidP_GetSpecificButtonCaps
        #undef HidP_TranslateUsagesToI8042ScanCodes

        #define           HidD_GetHidGuid                       \
        g_hiddll._HidD_GetHidGuid

        #define           HidD_GetPreparsedData                 \
        g_hiddll._HidD_GetPreparsedData

        #define           HidD_FreePreparsedData                \
        g_hiddll._HidD_FreePreparsedData

        #define           HidD_FlushQueue                       \
        g_hiddll._HidD_FlushQueue

        #define           HidD_GetAttributes                    \
        g_hiddll._HidD_GetAttributes                    \

        #define           HidD_GetFeature                       \
        g_hiddll._HidD_GetFeature                       \

        #define           HidD_SetFeature                       \
        g_hiddll._HidD_SetFeature                       \

        #define           HidD_GetProductString                 \
        g_hiddll._HidD_GetProductString                 \

        #define           HidD_GetInputReport                   \
        g_hiddll._HidD_GetInputReport                   \

        #define           HidP_GetCaps                          \
        g_hiddll._HidP_GetCaps

        #define           HidP_GetButtonCaps                    \
        g_hiddll._HidP_GetButtonCaps

        #define           HidP_GetValueCaps                     \
        g_hiddll._HidP_GetValueCaps

        #define           HidP_GetLinkCollectionNodes           \
        g_hiddll._HidP_GetLinkCollectionNodes

        #define           HidP_MaxDataListLength                \
        g_hiddll._HidP_MaxDataListLength                \

        #define           HidP_GetUsagesEx                      \
        g_hiddll._HidP_GetUsagesEx                      \

        #define           HidP_GetScaledUsageValue              \
        g_hiddll._HidP_GetScaledUsageValue              \

        #define           HidP_GetData                          \
        g_hiddll._HidP_GetData                          \

        #define           HidP_SetData                          \
        g_hiddll._HidP_SetData                          \

        #define           HidP_GetUsageValue                    \
        g_hiddll._HidP_GetUsageValue                    \

        #define           HidP_MaxUsageListLength               \
        g_hiddll._HidP_MaxUsageListLength               \

        #define           HidP_GetSpecificButtonCaps            \
        g_hiddll._HidP_GetSpecificButtonCaps            \

        #define           HidP_TranslateUsagesToI8042ScanCodes  \
        g_hiddll._HidP_TranslateUsagesToI8042ScanCodes  \

/*****************************************************************************
 *
 * WINMMDLL
 *
 *  Note that this must match the WINMM section in diextdll.c
 *
 *****************************************************************************/

typedef union WINMMDLL
{
    MANUALIMPORT rgmi[11];             /* number of functions we import */

    struct
    {
        MMRESULT ( WINAPI * _joyGetDevCaps)
        (
        IN  UINT uJoyID,
        OUT LPJOYCAPS pjc,
        IN  UINT cbjc
        );

        MMRESULT ( WINAPI * _joyGetPosEx)
        (
        IN  UINT        uJoyID,
        OUT LPJOYINFOEX pji
        );

        MMRESULT ( WINAPI * _joyGetPos)
        (
        IN  UINT        uJoyID,
        OUT LPJOYINFO   pji
        );

        UINT ( WINAPI * _joyConfigChanged)
        (
        IN DWORD dwFlags
        );

        MMRESULT ( WINAPI * _mmioClose )
        ( 
        IN HMMIO hmmio, 
        IN UINT fuClose
        );

        HMMIO ( WINAPI * _mmioOpenA )
        ( 
        IN OUT LPSTR pszFileName, 
        IN OUT LPMMIOINFO pmmioinfo, 
        IN DWORD fdwOpen
        );

        MMRESULT ( WINAPI * _mmioDescend )
        ( 
        IN HMMIO hmmio, 
        IN OUT LPMMCKINFO pmmcki, 
        IN const MMCKINFO FAR* pmmckiParent, 
        IN UINT fuDescend
        );

        MMRESULT ( WINAPI * _mmioCreateChunk )
        (
        IN HMMIO hmmio, 
        IN LPMMCKINFO pmmcki, 
        IN UINT fuCreate
        );

        LONG ( WINAPI * _mmioRead )
        ( 
        IN HMMIO hmmio, 
        OUT HPSTR pch, 
        IN LONG cch
        );

        LONG ( WINAPI * _mmioWrite )
        ( 
        IN HMMIO hmmio, 
        IN const char _huge* pch, 
        IN LONG cch
        );

        MMRESULT ( WINAPI * _mmioAscend )
        ( 
        IN HMMIO hmmio, 
        IN LPMMCKINFO pmmcki, 
        IN UINT fuAscend
        );
    };

} WINMMDLL, *PWINMMDLL;

extern WINMMDLL g_winmmdll;

        #undef joyGetDevCaps
        #undef joyGetPosEx
        #undef joyGetPos
        #undef joyConfigChanged
        #undef mmioClose
        #undef mmioOpenA
        #undef mmioDescend
        #undef mmioCreateChunk
        #undef mmioRead
        #undef mmioWrite
        #undef mmioAscend

        #define             joyGetDevCaps                  \
        g_winmmdll._joyGetDevCaps

        #define             joyGetPosEx                    \
        g_winmmdll._joyGetPosEx

        #define             joyGetPos                      \
        g_winmmdll._joyGetPos

        #define             joyConfigChanged               \
        g_winmmdll._joyConfigChanged

        #define             mmioClose                      \
        g_winmmdll._mmioClose

        #define             mmioOpenA                      \
        g_winmmdll._mmioOpenA

        #define             mmioDescend                    \
        g_winmmdll._mmioDescend

        #define             mmioCreateChunk                \
        g_winmmdll._mmioCreateChunk

        #define             mmioRead                       \
        g_winmmdll._mmioRead

        #define             mmioWrite                      \
        g_winmmdll._mmioWrite

        #define             mmioAscend                     \
        g_winmmdll._mmioAscend


/*****************************************************************************
 *
 * USER32
 *
 *  Note that this must match the USER32 section in diextdll.c
 *
 *****************************************************************************/

#ifdef USE_WM_INPUT

typedef union USER32
{

    MANUALIMPORT rgmi[2];              /* number of functions we import */

    struct
    {
        BOOL ( WINAPI * _RegisterRawInputDevices)
        (
        PCRAWINPUTDEVICE pRawInputDevices,
        UINT             uiNumDevices,
        UINT             cbSize
        );

        UINT ( WINAPI * _GetRawInputData)
        (
        HRAWINPUT   hRawInput,
        UINT        uiCommand,
        LPVOID      pData,
        PUINT       pcbSize,
        UINT        cbSizeHeader
        );
    };

} USER32, *PUSER32;

extern USER32 g_user32;

        #undef RegisterRawInputDevices
        #undef GetRawInputData

        #define             RegisterRawInputDevices        \
        g_user32._RegisterRawInputDevices

        #define             GetRawInputData                \
        g_user32._GetRawInputData

#endif

/*****************************************************************************
 *
 * Dummy functions
 *
 *   These functions are used only when some DLLs can't be loaded.
 *
 *****************************************************************************/

//cfgmgr32.dll 

CONFIGRET WINAPI DIDummy_CM_Get_Child
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  dnDevInst,
IN  ULONG    ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Get_Sibling
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  DevInst,
IN  ULONG    ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Get_Parent
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  dnDevInst,
IN  ULONG    ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Get_DevNode_Registry_Property
(
IN  DEVINST     dnDevInst,
IN  ULONG       ulProperty,
OUT PULONG      pulRegDataType,   OPTIONAL
OUT PVOID       Buffer,           OPTIONAL
IN  OUT PULONG  pulLength,
IN  ULONG       ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Set_DevNode_Registry_Property
(
IN  DEVINST     dnDevInst,
IN  ULONG       ulProperty,
IN  PVOID       Buffer,           OPTIONAL
IN  ULONG       ulLength,
IN  ULONG       ulFlags
);

CONFIGRET WINAPI DIDummy_CM_Get_Device_ID
(
 IN  DEVINST  dnDevInst,
 OUT PTCHAR   Buffer,
 IN  ULONG    BufferLen,
 IN  ULONG    ulFlags
);

//Setupapi.dll

HDEVINFO WINAPI DIDummy_SetupDiGetClassDevs
(
IN LPGUID ClassGuid,  OPTIONAL
IN LPCTSTR Enumerator, OPTIONAL
IN HWND   hwndParent, OPTIONAL
IN DWORD  Flags
);

BOOL WINAPI DIDummy_SetupDiDestroyDeviceInfoList
(
IN HDEVINFO DeviceInfoSet
);

BOOL WINAPI DIDummy_SetupDiGetDeviceInterfaceDetail
(
IN  HDEVINFO                         DeviceInfoSet,
IN  PSP_DEVICE_INTERFACE_DATA        pdid,
OUT PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd,         OPTIONAL
IN  DWORD                            cbDidd,
OUT PDWORD                           RequiredSize,  OPTIONAL
OUT PSP_DEVINFO_DATA                 DeviceInfoData OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiEnumDeviceInterfaces
(
IN  HDEVINFO                  DeviceInfoSet,
IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
IN  LPGUID                    InterfaceClassGuid,
IN  DWORD                     MemberIndex,
OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
);

HKEY WINAPI DIDummy_SetupDiCreateDeviceInterfaceRegKey
(
IN HDEVINFO                  hdev,
IN PSP_DEVICE_INTERFACE_DATA pdid,
IN DWORD                     Reserved,
IN REGSAM                    samDesired,
IN HINF                      InfHandle,           OPTIONAL
IN PCSTR                     InfSectionName       OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiCallClassInstaller
(
IN DI_FUNCTION      InstallFunction,
IN HDEVINFO         DeviceInfoSet,
IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiGetDeviceRegistryProperty
(
IN  HDEVINFO         DeviceInfoSet,
IN  PSP_DEVINFO_DATA DeviceInfoData,
IN  DWORD            Property,
OUT PDWORD           PropertyRegDataType, OPTIONAL
OUT PBYTE            PropertyBuffer,
IN  DWORD            PropertyBufferSize,
OUT PDWORD           RequiredSize         OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiSetDeviceRegistryProperty
(
IN     HDEVINFO         DeviceInfoSet,
IN OUT PSP_DEVINFO_DATA DeviceInfoData,
IN     DWORD            Property,
IN     CONST BYTE*      PropertyBuffer,
IN     DWORD            PropertyBufferSize
);

BOOL WINAPI DIDummy_SetupDiGetDeviceInstanceId
(
IN  HDEVINFO         DeviceInfoSet,
IN  PSP_DEVINFO_DATA DeviceInfoData,
OUT PTSTR            DeviceInstanceId,
IN  DWORD            DeviceInstanceIdSize,
OUT PDWORD           RequiredSize          OPTIONAL
);

BOOL WINAPI DIDummy_SetupDiOpenDeviceInfo
(
IN  HDEVINFO         DeviceInfoSet,
IN  LPCTSTR          DeviceInstanceId,
IN  HWND             hwndParent,       OPTIONAL
IN  DWORD            OpenFlags,
OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
);

HDEVINFO WINAPI DIDummy_SetupDiCreateDeviceInfoList
(
IN LPGUID ClassGuid, OPTIONAL
IN HWND   hwndParent OPTIONAL
);

HKEY WINAPI DIDummy_SetupDiOpenDevRegKey
(
IN HDEVINFO         DeviceInfoSet,
IN PSP_DEVINFO_DATA DeviceInfoData,
IN DWORD            Scope,
IN DWORD            HwProfile,
IN DWORD            KeyType,
IN REGSAM           samDesired
);

// hid.dll

void __stdcall DIDummy_HidD_GetHidGuid
(
OUT   LPGUID   HidGuid
);

BOOLEAN __stdcall DIDummy_HidD_GetPreparsedData
(
IN    HANDLE                  HidDeviceObject,
OUT   PHIDP_PREPARSED_DATA  * PreparsedData
);

BOOLEAN __stdcall DIDummy_HidD_FreePreparsedData
(
IN    PHIDP_PREPARSED_DATA PreparsedData
);

BOOLEAN __stdcall DIDummy_HidD_FlushQueue
(
IN    HANDLE                HidDeviceObject
);

BOOLEAN __stdcall DIDummy_HidD_GetAttributes
(
IN  HANDLE              HidDeviceObject,
OUT PHIDD_ATTRIBUTES    Attributes
);

BOOLEAN __stdcall DIDummy_HidD_GetFeature
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
);

BOOLEAN __stdcall DIDummy_HidD_SetFeature
(
IN    HANDLE   HidDeviceObject,
IN    PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
);

BOOLEAN __stdcall DIDummy_HidD_GetProductString
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    Buffer,
IN    ULONG    BufferLength
);

BOOLEAN __stdcall DIDummy_HidD_GetInputReport
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
);

NTSTATUS __stdcall DIDummy_HidP_GetCaps
(
IN      PHIDP_PREPARSED_DATA      PreparsedData,
OUT     PHIDP_CAPS                Capabilities
);

NTSTATUS __stdcall DIDummy_HidP_GetButtonCaps
(
IN       HIDP_REPORT_TYPE     ReportType,
OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
IN OUT   PUSHORT              ButtonCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_GetValueCaps
(
IN       HIDP_REPORT_TYPE     ReportType,
OUT      PHIDP_VALUE_CAPS     ValueCaps,
IN OUT   PUSHORT              ValueCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_GetLinkCollectionNodes
(
OUT      PHIDP_LINK_COLLECTION_NODE LinkCollectionNodes,
IN OUT   PULONG                     LinkCollectionNodesLength,
IN       PHIDP_PREPARSED_DATA       PreparsedData
);

ULONG __stdcall DIDummy_HidP_MaxDataListLength
(
IN HIDP_REPORT_TYPE      ReportType,
IN PHIDP_PREPARSED_DATA  PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_GetUsagesEx   //unused
(
IN       HIDP_REPORT_TYPE     ReportType,
IN       USHORT               LinkCollection,
OUT      PUSAGE_AND_PAGE      ButtonList,
IN OUT   ULONG *              UsageLength,
IN       PHIDP_PREPARSED_DATA PreparsedData,
IN       PCHAR                Report,
IN       ULONG                ReportLength
);

NTSTATUS __stdcall DIDummy_HidP_GetScaledUsageValue  //unused
(
IN    HIDP_REPORT_TYPE     ReportType,
IN    USAGE                UsagePage,
IN    USHORT               LinkCollection,
IN    USAGE                Usage,
OUT   PLONG                UsageValue,
IN    PHIDP_PREPARSED_DATA PreparsedData,
IN    PCHAR                Report,
IN    ULONG                ReportLength
);

NTSTATUS __stdcall DIDummy_HidP_GetData
(
IN       HIDP_REPORT_TYPE      ReportType,
OUT      PHIDP_DATA            DataList,
IN OUT   PULONG                DataLength,
IN       PHIDP_PREPARSED_DATA  PreparsedData,
IN       PCHAR                 Report,
IN       ULONG                 ReportLength
);

NTSTATUS __stdcall DIDummy_HidP_SetData
(
IN       HIDP_REPORT_TYPE      ReportType,
IN       PHIDP_DATA            DataList,
IN OUT   PULONG                DataLength,
IN       PHIDP_PREPARSED_DATA  PreparsedData,
IN OUT   PCHAR                 Report,
IN       ULONG                 ReportLength
);

NTSTATUS __stdcall DIDummy_HidP_GetUsageValue
(
IN    HIDP_REPORT_TYPE     ReportType,
IN    USAGE                UsagePage,
IN    USHORT               LinkCollection,
IN    USAGE                Usage,
OUT   PULONG               UsageValue,
IN    PHIDP_PREPARSED_DATA PreparsedData,
IN    PCHAR                Report,
IN    ULONG                ReportLength
);

ULONG __stdcall DIDummy_HidP_MaxUsageListLength
(
IN HIDP_REPORT_TYPE      ReportType,
IN USAGE                 UsagePage,
IN PHIDP_PREPARSED_DATA  PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_GetSpecificButtonCaps 
(
IN       HIDP_REPORT_TYPE     ReportType,
IN       USAGE                UsagePage,      
IN       USHORT               LinkCollection, 
IN       USAGE                Usage,          
OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
IN OUT   PUSHORT              ButtonCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
);

NTSTATUS __stdcall DIDummy_HidP_TranslateUsagesToI8042ScanCodes
(
IN       PUSAGE               ChangedUsageList, // Those usages that changed
IN       ULONG                UsageListLength,
IN       HIDP_KEYBOARD_DIRECTION KeyAction,
IN OUT   PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
IN       PHIDP_INSERT_SCANCODES  InsertCodesProcedure,
IN       PVOID                InsertCodesContext
);

// winmm.dll

MMRESULT WINAPI DIDummy_joyGetDevCaps
(
IN  UINT uJoyID,
OUT LPJOYCAPS pjc,
IN  UINT cbjc
);

MMRESULT WINAPI DIDummy_joyGetPosEx
(
IN  UINT        uJoyID,
OUT LPJOYINFOEX pji
);

MMRESULT WINAPI DIDummy_joyGetPos
(
IN  UINT        uJoyID,
OUT LPJOYINFO   pji
);

UINT WINAPI DIDummy_joyConfigChanged
(
IN DWORD dwFlags
);

MMRESULT WINAPI DIDummy_mmioClose 
( 
IN HMMIO hmmio, 
IN UINT fuClose
);

HMMIO WINAPI DIDummy_mmioOpenA 
( 
IN OUT LPSTR pszFileName, 
IN OUT LPMMIOINFO pmmioinfo, 
IN DWORD fdwOpen
);

MMRESULT WINAPI DIDummy_mmioDescend 
( 
IN HMMIO hmmio, 
IN OUT LPMMCKINFO pmmcki, 
IN const MMCKINFO FAR* pmmckiParent, 
IN UINT fuDescend
);

MMRESULT WINAPI DIDummy_mmioCreateChunk 
(
IN HMMIO hmmio, 
IN LPMMCKINFO pmmcki, 
IN UINT fuCreate
);

LONG WINAPI DIDummy_mmioRead 
( 
IN HMMIO hmmio, 
OUT HPSTR pch, 
IN LONG cch
);

LONG WINAPI DIDummy_mmioWrite 
( 
IN HMMIO hmmio, 
IN const char _huge* pch, 
IN LONG cch
);

MMRESULT WINAPI DIDummy_mmioAscend 
( 
IN HMMIO hmmio, 
IN LPMMCKINFO pmmcki, 
IN UINT fuAscend
);

// user32.dll

#ifdef USE_WM_INPUT

BOOL WINAPI DIDummy_RegisterRawInputDevices
(
PCRAWINPUTDEVICE pRawInputDevices,
UINT uiNumDevices,
UINT cbSize
);

UINT WINAPI DIDummy_GetRawInputData
(
HRAWINPUT   hRawInput,
UINT        uiCommand,
LPVOID      pData,
PUINT       pcbSize,
UINT        cbSizeHeader
);

#endif // #ifdef USE_WM_INPUT

#endif /* STATIC_DLLUSAGE */

#endif /* _DIEXTDLL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\digenm.c ===
/*****************************************************************************
 *
 *  DIGenM.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Practice generic IDirectInputDevice callback for mouse.
 *
 *  Contents:
 *
 *      CMouse_New
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflMouse

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CMouse, IDirectInputDeviceCallback);

Interface_Template_Begin(CMouse)
    Primary_Interface_Template(CMouse, IDirectInputDeviceCallback)
Interface_Template_End(CMouse)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgodfMouse[] |
 *
 *          Device object data formats for the generic mouse device.
 *          The axes come first, then the buttons.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKEODF(guid, f, type, inst, aspect)                \
    { &GUID_##guid,                                         \
      FIELD_OFFSET(DIMOUSESTATE_INT, f),                        \
      DIDFT_##type | DIDFT_MAKEINSTANCE(inst),              \
      DIDOI_ASPECT##aspect,                                 \
    }                                                       \

/*
 * Warning!  If you change this table, you must adjust the IDS_MOUSEOBJECT
 * table in dinput.rc to match!
 */

DIOBJECTDATAFORMAT c_rgodfMouse[] = {
    MAKEODF( XAxis,            lX,   RELAXIS, 0, POSITION),
    MAKEODF( YAxis,            lY,   RELAXIS, 1, POSITION),
    MAKEODF( ZAxis,            lZ,   RELAXIS, 2, POSITION),
    MAKEODF(Button, rgbButtons[0], PSHBUTTON, 3,  UNKNOWN),
    MAKEODF(Button, rgbButtons[1], PSHBUTTON, 4,  UNKNOWN),
    MAKEODF(Button, rgbButtons[2], PSHBUTTON, 5,  UNKNOWN),
    MAKEODF(Button, rgbButtons[3], PSHBUTTON, 6,  UNKNOWN),
    MAKEODF(Button, rgbButtons[4], PSHBUTTON, 7,  UNKNOWN),
    MAKEODF(Button, rgbButtons[5], PSHBUTTON, 8,  UNKNOWN),
    MAKEODF(Button, rgbButtons[6], PSHBUTTON, 9,  UNKNOWN),
    MAKEODF(Button, rgbButtons[7], PSHBUTTON,10,  UNKNOWN),
};

#define c_podfMouseAxes     (&c_rgodfMouse[0])
#define c_podfMouseButtons  (&c_rgodfMouse[3])

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CMouse |
 *
 *          The <i IDirectInputDeviceCallback> object for the generic mouse.
 *
 *  @field  IDirectInputDeviceCalllback | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  LPDIMOUSESTATE_INT | pdmsPhys |
 *
 *          Pointer to physical mouse status information kept down in the
 *          VxD.
 *
 *  @field  POINT | ptPrev |
 *
 *          Location of the mouse at the time we stole it exclusively.
 *
 *  @field  HWND | hwndCaptured |
 *
 *          The window that captured the mouse.
 *
 *  @field  VXDINSTANCE * | pvi |
 *
 *          The DirectInput instance handle.  Even though we manipulate
 *          the flags field, we do not need to mark it volatile because
 *          we modify the flags only when unacquired, whereas the device
 *          driver modifies the flags only when acquired.
 *
 *  @field  UINT | dwAxes |
 *
 *          Number of axes on the mouse.
 *
 *  @field  UINT | dwButtons |
 *
 *          Number of buttons on the mouse.
 *
 *  @field  DWORD | flEmulation |
 *
 *          The emulation flags forced by the application.  If any of
 *          these flags is set (actually, at most one will be set), then
 *          we are an alias device.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          The dynamically-generated data format based on the
 *          mouse type.
 *
 *  @field  DIOBJECTDATAFORMAT | rgodf[] |
 *
 *          Object data format table generated as part of the
 *          <e CMouse.df>.
 *
 *  @comm
 *
 *          It is the caller's responsibility to serialize access as
 *          necessary.
 *
 *****************************************************************************/

typedef struct CMouse {

    /* Supported interfaces */
    IDirectInputDeviceCallback dcb;

    LPDIMOUSESTATE_INT pdmsPhys;            /* Physical mouse state */

    POINT ptPrev;
    HWND hwndCapture;

    VXDINSTANCE *pvi;

    UINT dwAxes;
    UINT dwButtons;
    DWORD flEmulation;

    DIDATAFORMAT df;
    DIOBJECTDATAFORMAT rgodf[cA(c_rgodfMouse)];

} CMouse, DM, *PDM;

#define ThisClass CMouse
#define ThisInterface IDirectInputDeviceCallback
#define riidExpected &IID_IDirectInputDeviceCallback

/*****************************************************************************
 *
 *      CMouse::QueryInterface      (from IUnknown)
 *      CMouse::AddRef              (from IUnknown)
 *      CMouse::Release             (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CMouse)
Default_AddRef(CMouse)
Default_Release(CMouse)

#else

#define CMouse_QueryInterface   Common_QueryInterface
#define CMouse_AddRef           Common_AddRef
#define CMouse_Release          Common_Release

#endif

#define CMouse_QIHelper         Common_QIHelper
#define CMouse_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CMouse_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CMouse_Finalize(PV pvObj)
{
    PDM this = pvObj;

    if (this->pvi) {
        HRESULT hres;
        hres = Hel_DestroyInstance(this->pvi);
        AssertF(SUCCEEDED(hres));
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | GetPhysicalPosition |
 *
 *          Read the physical mouse position into <p pmstOut>.
 *
 *          Note that it doesn't matter if this is not atomic.
 *          If a mouse motion occurs while we are reading it,
 *          we will get a mix of old and new data.  No big deal.
 *
 *  @parm   PDM | this |
 *
 *          The object in question.
 *
 *  @parm   LPDIMOUSESTATE_INT | pdmsOut |
 *
 *          Where to put the mouse position.
 *  @returns
 *          None.
 *
 *****************************************************************************/

void INLINE
CMouse_GetPhysicalPosition(PDM this, LPDIMOUSESTATE_INT pdmsOut)
{
    AssertF(this->pdmsPhys);
    *pdmsOut = *this->pdmsPhys;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | Acquire |
 *
 *          Tell the device driver to begin data acquisition.
 *          Give the device driver the current mouse button states
 *          in case it needs them.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_Acquire(PDICB pdcb)
{
    HRESULT hres;
    PDM this;
    VXDDWORDDATA vdd;
    DWORD mef;
    EnterProcI(IDirectInputDeviceCallback::Mouse::Acquire,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);

    vdd.pvi = this->pvi;
    vdd.dw = 0;

    /*
     *  Collect information about which buttons are down.
     */
    mef = 0;
    if (GetAsyncKeyState(VK_LBUTTON) < 0) {
        mef |= MOUSEEVENTF_LEFTUP;
        vdd.dw |= 0x80;
    }
    if (GetAsyncKeyState(VK_RBUTTON) < 0) {
        mef |= MOUSEEVENTF_RIGHTUP;
        vdd.dw |= 0x8000;
    }
    if (GetAsyncKeyState(VK_MBUTTON) < 0) {
        mef |= MOUSEEVENTF_MIDDLEUP;
        vdd.dw |= 0x800000;
    }

    /*
     *  HACKHACK - This, strictly speaking, belongs in dihel.c,
     *  but we need to maintain some state, and it's easier to
     *  put the state in our own object.
     */

    /*
     *  A bit of work needs to be done at ring 3 now.
     */
    if (this->pvi->fl & VIFL_CAPTURED) {
        RECT rc;

        /*
         *  Hide the mouse cursor (for compatibility with NT emulation)
         */
        GetCursorPos(&this->ptPrev);
        GetWindowRect(this->hwndCapture, &rc);
        SetCursorPos((rc.left + rc.right) >> 1,
                     (rc.top + rc.bottom) >> 1);
        ShowCursor(0);

	    if (!(this->pvi->fl & VIFL_EMULATED)) {
			/*
			 *  Force all mouse buttons up from USER's point of view
			 *  to avoid "stuck mouse button" problems.  However, don't
			 *  force a button up unless it is actually down.
			 */
			if (mef) {
				mouse_event(mef, 0, 0, 0, 0);
			}
		}
    }

    if (!(this->pvi->fl & VIFL_EMULATED)) {
        hres = IoctlHw(IOCTL_MOUSE_INITBUTTONS, &vdd.dw, cbX(vdd.dw), 0, 0);
    } else {
      #ifdef USE_WM_INPUT
        if( g_fRawInput ) {
            hres = CDIRaw_Mouse_InitButtons();
        }
      #endif
        hres = CEm_Mouse_InitButtons(&vdd);
    }

    AssertF(SUCCEEDED(hres));

    hres = S_FALSE;                 /* Please finish for me */

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | Unacquire |
 *
 *          Tell the device driver to stop data acquisition.
 *
 *          It is the caller's responsibility to call this only
 *          when the device has been acquired.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_Unacquire(PDICB pdcb)
{
    HRESULT hres;
    PDM this;
  #ifdef WANT_TO_FIX_MANBUG43879  
    DWORD mef;
  #endif
    EnterProcI(IDirectInputDeviceCallback::Mouse::Unacquire,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);

  #ifdef WANT_TO_FIX_MANBUG43879
    /*
     *  Collect information about which buttons are down.
     */
    mef = 0;
    if (GetAsyncKeyState(VK_LBUTTON) < 0) {
        mef |= MOUSEEVENTF_LEFTUP;
    }
    if (GetAsyncKeyState(VK_RBUTTON) < 0) {
        mef |= MOUSEEVENTF_RIGHTUP;
    }
    if (GetAsyncKeyState(VK_MBUTTON) < 0) {
        mef |= MOUSEEVENTF_MIDDLEUP;
    }

    if (this->pvi->fl & VIFL_FOREGROUND) {
        /*
         *  Force all mouse buttons up from USER's point of view
         *  to avoid "stuck mouse button" problems.  However, don't
         *  force a button up unless it is actually down.
         *  This could happen if DInput loses UP events due to slow
         *  low-level hook. See bug: 43879.
         */
        if (mef) {
            mouse_event(mef, 0, 0, 0, 0);
        }
    }
  #endif

    /*
     *  HACKHACK - This is the corresponding half of the HACKHACK
     *  in CMouse_Acquire.
     */

    /*
     *  A bit of work needs to be done at ring 3 now.
     */
    if (this->pvi->fl & VIFL_CAPTURED) {
        RECT rcDesk;
        RECT rcApp;

        /*
         *  Reposition and restore the mouse cursor
         *  (for compatibility with NT emulation)
         *
         *  Do not reposition the mouse cursor if we lost to a
         *  window that covers the screen.  Otherwise, our
         *  repositioning will nuke the screen saver.
         */
        GetWindowRect(GetDesktopWindow(), &rcDesk);
        GetWindowRect(GetForegroundWindow(), &rcApp);
        SubtractRect(&rcDesk, &rcDesk, &rcApp);
        if (!IsRectEmpty(&rcDesk)) {
            SetCursorPos(this->ptPrev.x, this->ptPrev.y);
        }
        ShowCursor(1);
    }

    hres = S_FALSE;
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetInstance |
 *
 *          Obtains the DirectInput instance handle.
 *
 *  @parm   OUT PPV | ppvi |
 *
 *          Receives the instance handle.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetInstance(PDICB pdcb, PPV ppvi)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetInstance, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    *ppvi = (PV)this->pvi;
    hres = S_OK;

    ExitOleProcPpvR(ppvi);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetDataFormat |
 *
 *          Obtains the device's preferred data format.
 *
 *  @parm   OUT LPDIDEVICEFORMAT * | ppdf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdf)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetDataFormat,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppdf = &this->df;
    hres = S_OK;

    ExitOleProcPpvR(ppdf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetDeviceInfo |
 *
 *          Obtain general information about the device.
 *
 *  @parm   OUT LPDIDEVICEINSTANCEW | pdiW |
 *
 *          <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *          Secret convenience:  <e DEVICEINSTANCE.guidProduct> is equal
 *          to <e DEVICEINSTANCE.guidInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW pdiW)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetDeviceInfo,
               (_ "pp", pdcb, pdiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEINSTANCEW(pdiW->dwSize));

    AssertF(IsEqualGUID(&GUID_SysMouse   , &pdiW->guidInstance) ||
            IsEqualGUID(&GUID_SysMouseEm , &pdiW->guidInstance) ||
            IsEqualGUID(&GUID_SysMouseEm2, &pdiW->guidInstance));
    pdiW->guidProduct = GUID_SysMouse;

    pdiW->dwDevType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_MOUSE,
                                         DI8DEVTYPEMOUSE_UNKNOWN);

    LoadStringW(g_hinst, IDS_STDMOUSE, pdiW->tszProductName, cA(pdiW->tszProductName));
    LoadStringW(g_hinst, IDS_STDMOUSE, pdiW->tszInstanceName, cA(pdiW->tszInstanceName));

    hres = S_OK;

    ExitOleProcR();
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | GetProperty |
 *
 *          Get a mouse device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  Granularity is only supported for wheels.
     */
    if (ppropi->pguid == DIPROP_GRANULARITY &&
        ppropi->dwDevType == (DIDFT_RELAXIS | DIDFT_MAKEINSTANCE(2)) )
    {
        LPDIPROPDWORD pdipdw = (PV)pdiph;
        pdipdw->dwData = g_lWheelGranularity? (DWORD)g_lWheelGranularity : 120;
        hres = S_OK;
    }
    else
    {
        hres = E_NOTIMPL;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | GetCapabilities |
 *
 *          Get mouse device capabilities.
 *
 *  @parm   LPDIDEVCAPS | pdc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdc)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetCapabilities,
               (_ "pp", pdcb, pdc));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    pdc->dwDevType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_MOUSE,
                                        DI8DEVTYPEMOUSE_UNKNOWN);
    pdc->dwFlags = DIDC_ATTACHED;
    if (this->flEmulation) {
        pdc->dwFlags |= DIDC_ALIAS;
    }

    pdc->dwAxes = this->dwAxes;
    pdc->dwButtons = this->dwButtons;
    AssertF(pdc->dwPOVs == 0);

    hres = S_OK;
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetDeviceState |
 *
 *          Obtains the state of the mouse device.
 *
 *          It is the caller's responsibility to have validated all the
 *          parameters and ensure that the device has been acquired.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Mouse data in the preferred data format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetDeviceState(PDICB pdcb, LPVOID pvData)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetDeviceState,
               (_ "pp", pdcb, pvData));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pdmsPhys);

    if (this->pvi->fl & VIFL_ACQUIRED) {
        CMouse_GetPhysicalPosition(this, pvData);
        hres = S_OK;
    } else {
        hres = DIERR_INPUTLOST;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | GetObjectInfo |
 *
 *          Obtain the friendly name of an object, passwed by index
 *          into the preferred data format.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          fields have already been filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                                 LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::GetObjectInfo,
               (_ "pxp", pdcb, ppropi->iobj, pdidoiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEW(pdidoiW->dwSize));

    if (ppropi->iobj < this->df.dwNumObjs) {
        AssertF(this->rgodf == this->df.rgodf);
        AssertF(ppropi->dwDevType == this->rgodf[ppropi->iobj].dwType);

        AssertF(DIDFT_GETTYPE(ppropi->dwDevType) == DIDFT_RELAXIS ||
                DIDFT_GETTYPE(ppropi->dwDevType) == DIDFT_PSHBUTTON);


        LoadStringW(g_hinst, IDS_MOUSEOBJECT +
                             DIDFT_GETINSTANCE(ppropi->dwDevType),
                             pdidoiW->tszName, cA(pdidoiW->tszName));

        /*
         *  We do not support force feedback on mice, so
         *  there are no FF flags to report.
         */
        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | SetCooperativeLevel |
 *
 *          Notify the device of the cooperative level.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDM this;
    EnterProcI(IDirectInputDeviceCallback::Mouse::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);

#ifdef USE_SLOW_LL_HOOKS
    AssertF(DIGETEMFL(this->pvi->fl) == 0 ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_MOUSE ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_MOUSE2);
#else
    AssertF(DIGETEMFL(this->pvi->fl) == 0 ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_MOUSE2);
#endif
    /*
     *  Even though we can do it, we don't let the app
     *  get background exclusive access.  As with the keyboard,
     *  there is nothing that technically prevents us from
     *  supporting it; we just don't feel like it because it's
     *  too dangerous.
     */

    /*
     *  VxD and LL (emulation 1) behave the same, so we check
     *  if it's "not emulation 2".
     */

    if (!(this->pvi->fl & DIMAKEEMFL(DIEMFL_MOUSE2))) {

        if (dwFlags & DISCL_EXCLUSIVE) {
            if (dwFlags & DISCL_FOREGROUND) {
              #ifdef WANT_TO_FIX_MANBUG43879  
                this->pvi->fl |= VIFL_FOREGROUND;
              #endif
                this->pvi->fl |= VIFL_CAPTURED;
                hres = S_OK;
            } else {                /* Disallow exclusive background */
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("Exclusive background mouse access disallowed"));
                hres = E_NOTIMPL;
            }
        } else {
          #ifdef WANT_TO_FIX_MANBUG43879
            if (dwFlags & DISCL_FOREGROUND) {
                this->pvi->fl |= VIFL_FOREGROUND;
            }
          #endif

            this->pvi->fl &= ~VIFL_CAPTURED;
            hres = S_OK;
        }

    } else {
        /*
         *  Emulation 2 supports only exclusive foreground.
         */
        if ((dwFlags & (DISCL_EXCLUSIVE | DISCL_FOREGROUND)) ==
                       (DISCL_EXCLUSIVE | DISCL_FOREGROUND)) {
          #ifdef WANT_TO_FIX_MANBUG43879  
            this->pvi->fl |= VIFL_FOREGROUND;
          #endif
            this->pvi->fl |= VIFL_CAPTURED;
            hres = S_OK;
        } else {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("Mouse access must be exclusive foreground in Emulation 2."));
            hres = E_NOTIMPL;
        }
    }

    if (SUCCEEDED(hres)) {
        this->hwndCapture = hwnd;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | RunControlPanel |
 *
 *          Run the mouse control panel.
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          The owner window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszMouse[] = TEXT("mouse");

#pragma END_CONST_DATA

STDMETHODIMP
CMouse_RunControlPanel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Mouse::RunControlPanel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    hres = hresRunControlPanel(c_tszMouse);

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CMouse | BuildDefaultActionMap |
 *
 *          Validate the passed action map, blanking out invalid ones.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInst |
 *
 *          Device instance GUID.
 *
 *  @returns
 *
 *          <c E_NOTIMPL>
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_BuildDefaultActionMap
(
    PDICB               pdcb,
    LPDIACTIONFORMATW   paf,
    DWORD               dwFlags,
    REFGUID             guidInst
)
{
    HRESULT hres;
    PDM this;

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    EnterProcI(IDirectInputDeviceCallback::Mouse::BuildDefaultActionMap,
        (_ "ppxG", pdcb, paf, dwFlags, guidInst));

    this = _thisPvNm(pdcb, dcb);

    hres = CMap_BuildDefaultSysActionMap ( paf, dwFlags, DIPHYSICAL_MOUSE,
        guidInst, &this->df, 3 /* Generic mice buttons start at instnace 3 */ );

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method UINT | CMouse | NumAxes |
 *
 *          Determine the number of mouse axes.
 *
 *          On Windows NT, we can use the new <c SM_MOUSEWHEELPRESENT>
 *          system metric.  On Windows 95, we have to hunt for the
 *          Magellan window (using the mechanism documented in the
 *          Magellan SDK).
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszMouseZClass[] = TEXT("MouseZ");
TCHAR c_tszMouseZTitle[] = TEXT("Magellan MSWHEEL");
TCHAR c_tszMouseZActive[] = TEXT("MSH_WHEELSUPPORT_MSG");

#pragma END_CONST_DATA

#ifdef WINNT
#define CMouse_IsMagellanWheel() FALSE
#else
BOOL INLINE
CMouse_IsMagellanWheel(void)
{
    HWND hwnd = FindWindow(c_tszMouseZClass, c_tszMouseZTitle);
    return hwnd && SendMessage(hwnd, RegisterWindowMessage(c_tszMouseZActive), 0, 0);
}
#endif

#ifndef SM_MOUSEWHEELPRESENT
#define SM_MOUSEWHEELPRESENT            75
#endif

UINT INLINE
CMouse_NumAxes(void)
{
    UINT dwAxes;

    if (GetSystemMetrics(SM_MOUSEWHEELPRESENT) || CMouse_IsMagellanWheel()) {
        dwAxes = 3;
    } else {
        dwAxes = 2;
    }

    if (dwAxes == 2) {
        //Should avoid rebuilding too frequently.
        DIHid_BuildHidList(FALSE);

        DllEnterCrit();

        if (g_phdl) {
            int ihdi;
            for (ihdi = 0; ihdi < g_phdl->chdi; ihdi++) {
                if (dwAxes < g_phdl->rghdi[ihdi].osd.uiAxes) {
                    dwAxes = g_phdl->rghdi[ihdi].osd.uiAxes;
                }
            }
        }
        DllLeaveCrit();
    }

    return dwAxes;
}

UINT INLINE
CMouse_NumButtons(DWORD dwAxes)
{
    UINT dwButtons;

    dwButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);

#ifndef WINNT
  #ifdef HID_SUPPORT
    {
        /*
         *  ISSUE-2001/03/29-timgill Should try to avoid rebuilding Hid List too frequently.
         */
        DIHid_BuildHidList(FALSE);

        DllEnterCrit();

        if (g_phdl) {
            int ihdi;
            for (ihdi = 0; ihdi < g_phdl->chdi; ihdi++) {
                if (dwButtons < g_phdl->rghdi[ihdi].osd.uiButtons) {
                    dwButtons = g_phdl->rghdi[ihdi].osd.uiButtons;
                }
            }
        }
        DllLeaveCrit();
    }
  #endif
#endif

    if( dwButtons >= 8 ) {
        dwButtons = 8;
    }
    else if (dwAxes == 3 && dwButtons < 3) {
        /*
         *  HACK FOR MAGELLAN!
         *
         *  They return 2 from GetSystemMetrics(SM_CMOUSEBUTTONS).
         *  So if we see a Z-axis, then assume that
         *  there is also a third button.
         */
        dwButtons = 3;
    }

    return dwButtons;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | AddObjects |
 *
 *          Add a number of objects to the device format.
 *
 *  @parm   LPCDIOBJECTDATAFORMAT | rgodf |
 *
 *          Array of objects to be added.
 *
 *  @parm   UINT | cObj |
 *
 *          Number of objects to add.
 *
 *****************************************************************************/

void INTERNAL
CMouse_AddObjects(PDM this, LPCDIOBJECTDATAFORMAT rgodf, UINT cObj)
{
    UINT iodf;
    EnterProc(CMouse_AddObjects, (_ "pxx", this, rgodf, cObj));

    for (iodf = 0; iodf < cObj; iodf++) {
        this->rgodf[this->df.dwNumObjs++] = rgodf[iodf];
    }
    AssertF(this->df.dwNumObjs <= cA(this->rgodf));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CMouse | Init |
 *
 *          Initialize the object by establishing the data format
 *          based on the mouse type.
 *
 *          Code for detecting the IntelliMouse (formerly known as
 *          Magellan) pointing device is swiped from zmouse.h.
 *
 *  @parm   REFGUID | rguid |
 *
 *          The instance GUID we are being asked to create.
 *
 *****************************************************************************/

HRESULT INTERNAL
CMouse_Init(PDM this, REFGUID rguid)
{
    HRESULT hres;
    VXDDEVICEFORMAT devf;
    EnterProc(CMouse_Init, (_ "pG", this, rguid));

    this->df.dwSize = cbX(DIDATAFORMAT);
    this->df.dwObjSize = cbX(DIOBJECTDATAFORMAT);
    this->df.dwDataSize = cbX(DIMOUSESTATE_INT);
    this->df.rgodf = this->rgodf;
    AssertF(this->df.dwFlags == 0);
    AssertF(this->df.dwNumObjs == 0);

    /*
     *  Need to know early if we have a Z-axis, so we can disable
     *  the Z-wheel if it doesn't exist.
     *
     *  Note that this disabling needs to be done only on Win95.
     *  Win98 and NT4 have native Z-axis support, so there is
     *  nothing bogus that needs to be hacked.
     */
    this->dwAxes = CMouse_NumAxes();
    devf.dwExtra = this->dwAxes;
    if (this->dwAxes < 3) {
        DWORD dwVer = GetVersion();
        if ((LONG)dwVer >= 0 ||
            MAKEWORD(HIBYTE(LOWORD(dwVer)), LOBYTE(dwVer)) >= 0x040A) {
            devf.dwExtra = 3;
        }
    }
    CMouse_AddObjects(this, c_podfMouseAxes, this->dwAxes);

    /*
     *  Create the object with the most optimistic data format.
     *  This is important, because DINPUT.VXD builds the
     *  data format only once, and we need to protect ourselves against
     *  the user going into Control Panel and enabling the Z-Wheel
     *  after DINPUT.VXD has already initialized.
     */

    devf.cbData = cbX(DIMOUSESTATE_INT);
    devf.cObj = cA(c_rgodfMouse);
    devf.rgodf = c_rgodfMouse;

    /*
     *  But first a word from our other sponsor:  Figure out the
     *  emulation flags based on the GUID.
     */

    AssertF(GUID_SysMouse   .Data1 == 0x6F1D2B60);
    AssertF(GUID_SysMouseEm .Data1 == 0x6F1D2B80);
    AssertF(GUID_SysMouseEm2.Data1 == 0x6F1D2B81);

    switch (rguid->Data1) {

    default:
    case 0x6F1D2B60:
        AssertF(IsEqualGUID(rguid, &GUID_SysMouse));
        AssertF(this->flEmulation == 0);
        break;

    case 0x6F1D2B80:
        AssertF(IsEqualGUID(rguid, &GUID_SysMouseEm));
        this->flEmulation = DIEMFL_MOUSE;
        break;

    case 0x6F1D2B81:
        AssertF(IsEqualGUID(rguid, &GUID_SysMouseEm2));
        this->flEmulation = DIEMFL_MOUSE2;
        break;

    }

    devf.dwEmulation = this->flEmulation;

    hres = Hel_Mouse_CreateInstance(&devf, &this->pvi);
    if (SUCCEEDED(hres)) {

        AssertF(this->pvi);
        this->pdmsPhys = this->pvi->pState;

        this->dwButtons = CMouse_NumButtons( this->dwAxes );

        CMouse_AddObjects(this, c_podfMouseButtons, this->dwButtons);

        hres = S_OK;

    } else {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("Mismatched version of dinput.vxd"));
        hres = E_FAIL;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      CMouse_New       (constructor)
 *
 *      Fail the create if the machine has no mouse.
 *
 *****************************************************************************/

STDMETHODIMP
CMouse_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Mouse::<constructor>,
               (_ "Gp", riid, ppvObj));

    AssertF(IsEqualGUID(rguid, &GUID_SysMouse) ||
            IsEqualGUID(rguid, &GUID_SysMouseEm) ||
            IsEqualGUID(rguid, &GUID_SysMouseEm2));

    if (GetSystemMetrics(SM_MOUSEPRESENT)) {
        hres = Common_NewRiid(CMouse, punkOuter, riid, ppvObj);

        if (SUCCEEDED(hres)) {
            /* Must use _thisPv in case of aggregation */
            PDM this = _thisPv(*ppvObj);

            if (SUCCEEDED(hres = CMouse_Init(this, rguid))) {
            } else {
                Invoke_Release(ppvObj);
            }

        }
    } else {
        RPF("Warning: System does not have a mouse");
        /*
         *  Since we by-passed the parameter checks and we failed to create
         *  the new interface, try to zero the pointer now.
         */
        if (!IsBadWritePtr(ppvObj, sizeof(UINT_PTR) ))
        {
            *(PUINT_PTR)ppvObj = 0;
        }
        hres = DIERR_DEVICENOTREG;
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CMouse_Signature        0x53554F4D      /* "MOUS" */

Primary_Interface_Begin(CMouse, IDirectInputDeviceCallback)
    CMouse_GetInstance,
    CDefDcb_GetVersions,
    CMouse_GetDataFormat,
    CMouse_GetObjectInfo,
    CMouse_GetCapabilities,
    CMouse_Acquire,
    CMouse_Unacquire,
    CMouse_GetDeviceState,
    CMouse_GetDeviceInfo,
    CMouse_GetProperty,
    CDefDcb_SetProperty,
    CDefDcb_SetEventNotification,
    CMouse_SetCooperativeLevel,
    CMouse_RunControlPanel,
    CDefDcb_CookDeviceData,
    CDefDcb_CreateEffect,
    CDefDcb_GetFFConfigKey,
    CDefDcb_SendDeviceData,
    CDefDcb_Poll,
    CDefDcb_GetUsage,
    CDefDcb_MapUsage,
    CDefDcb_SetDIData,
    CMouse_BuildDefaultActionMap,
Primary_Interface_End(CMouse, IDirectInputDeviceCallback)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\digenj.c ===
/*****************************************************************************
 *
 *  DIGenJ.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Generic IDirectInputDevice callback for joystick.
 *
 *  Contents:
 *
 *      CJoy_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"
#ifndef WINNT

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoy

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CJoy_New!
 *
 *****************************************************************************/

Primary_Interface(CJoy, IDirectInputDeviceCallback);

/*****************************************************************************
 *
 *      Macro "lookup tables".
 *
 *      iJoyStateAxis# converts an axis name to an axis number in the
 *      DIJOYSTATE structure.
 *
 *      ibJoyStateAxis# converts the name to an offset.
 *
 *      Note that the extra axes in DIJOYSTATE2 are arranged in relative
 *      positions just like a DIJOYSTATE.  We will exploit this
 *      arrangement frequently.
 *
 *****************************************************************************/

#define iJoyStateAxisX      0
#define iJoyStateAxisY      1
#define iJoyStateAxisZ      2
#define iJoyStateAxisRx     3
#define iJoyStateAxisRy     4
#define iJoyStateAxisRz     5
#define iJoyStateAxisS0     6
#define iJoyStateAxisS1     7
#define cJoyStateAxisMax    8

#define iJoyStateAxisSlider iJoyStateAxisS0     /* Hack for macros */

#define cJoyStateAxis       8

#define iobjPositions       (cJoyStateAxis * 0)
#define iobjVelocities      (cJoyStateAxis * 1)
#define iobjAccels          (cJoyStateAxis * 2)
#define iobjForces          (cJoyStateAxis * 3)

#define cJoyStateAxisTotal  (cJoyStateAxis * 4)

#define ibJoyStateAxisX      (iJoyStateAxisX  * cbX(LONG))
#define ibJoyStateAxisY      (iJoyStateAxisY  * cbX(LONG))
#define ibJoyStateAxisZ      (iJoyStateAxisZ  * cbX(LONG))
#define ibJoyStateAxisRx     (iJoyStateAxisRx * cbX(LONG))
#define ibJoyStateAxisRy     (iJoyStateAxisRy * cbX(LONG))
#define ibJoyStateAxisRz     (iJoyStateAxisRz * cbX(LONG))
#define ibJoyStateAxisS0     (iJoyStateAxisS0 * cbX(LONG))
#define ibJoyStateAxisS1     (iJoyStateAxisS1 * cbX(LONG))

#define ibJoyStateAxisSlider ibJoyStateAxisS0    /* Hack for macros */

#define cJoyStatePOVTotal   4
#define cJoyStateButtonTotal 128

#define cJoyStateObjTotal   (cJoyStateAxisTotal + \
                             cJoyStatePOVTotal + \
                             cJoyStateButtonTotal)

/*
 *  The worst-case data format for joysticks.  (Christmas-tree)
 */
VXDAXISCAPS c_vacMax = {
    JOYPF_ALLCAPS | JOYPF_POSITION,         /*  dwPos   */
    JOYPF_ALLCAPS | JOYPF_VELOCITY,         /*  dwVel   */
    JOYPF_ALLCAPS | JOYPF_ACCELERATION,     /*  dwAccel */
    JOYPF_ALLCAPS | JOYPF_FORCE,            /*  dwForce */
};

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | ibJoyStateAxisFromPosAxis |
 *
 *          Returns the offset of the <p iPosAxis>'th joystick axis
 *          in the <t DIJOYSTATE> structure.
 *
 *  @parm   UINT | uiStateAxis |
 *
 *          The index of the requested <t JOYPOS> axis.
 *          X, Y, Z, R, U and V are respectively zero through five.
 *
 *          Remember that we map R to Rz, U to Slider0 and V to Slider1.
 *
 *  @returns
 *
 *          The offset relative to the structure.
 *
 *****************************************************************************/

const int c_rgibJoyStateAxisFromPosAxis[6] = {
    FIELD_OFFSET(DIJOYSTATE, lX),           /* X */
    FIELD_OFFSET(DIJOYSTATE, lY),           /* Y */
    FIELD_OFFSET(DIJOYSTATE, lZ),           /* Z */
    FIELD_OFFSET(DIJOYSTATE, lRz),          /* R */
    FIELD_OFFSET(DIJOYSTATE, rglSlider[0]), /* U */
    FIELD_OFFSET(DIJOYSTATE, rglSlider[1]), /* V */
};

UINT INLINE
ibJoyStateAxisFromPosAxis(UINT uiPosAxis)
{
    AssertF(uiPosAxis < cA(c_rgibJoyStateAxisFromPosAxis));
    return c_rgibJoyStateAxisFromPosAxis[uiPosAxis];
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | iJoyStateAxisFromPosAxis |
 *
 *          Returns the index of the <p iPosAxis>'th joystick axis
 *          in the <t DIJOYSTATE> structure.
 *
 *  @parm   UINT | uiStateAxis |
 *
 *          The index of the requested <t JOYPOS> axis.
 *          X, Y, Z, R, U and V are respectively zero through five.
 *
 *          Remember that we map R to Rz, U to Slider0 and V to Slider1.
 *
 *  @returns
 *
 *          The offset relative to the structure.
 *
 *****************************************************************************/

const int c_rgiJoyStateAxisFromPosAxis[6] = {
    iJoyStateAxisX,             /* X */
    iJoyStateAxisY,             /* Y */
    iJoyStateAxisZ,             /* Z */
    iJoyStateAxisRz,            /* R */
    iJoyStateAxisS0,            /* U */
    iJoyStateAxisS1,            /* V */
};

UINT INLINE
iJoyStateAxisFromPosAxis(UINT uiPosAxis)
{
    AssertF(uiPosAxis < cA(c_rgiJoyStateAxisFromPosAxis));
    return c_rgiJoyStateAxisFromPosAxis[uiPosAxis];
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | ibJoyStateAxisFromStateAxis |
 *
 *          Returns the offset of the <p iStateAxis>'th joystick axis
 *          in the <t DIJOYSTATE> structure.
 *
 *  @parm   UINT | uiStateAxis |
 *
 *          The index of the requested <t JOYSTATE> axis.
 *          The first eight axes live at the top, and the
 *          later ones (corresponding to velocity, etc.)
 *          live down at the bottom.
 *
 *  @returns
 *
 *          The offset relative to the structure.
 *
 *****************************************************************************/

const int c_rgibJoyStateAxisFromStateAxis[cJoyStateAxisMax] = {
    FIELD_OFFSET(DIJOYSTATE, lX),           /* X  */
    FIELD_OFFSET(DIJOYSTATE, lY),           /* Y  */
    FIELD_OFFSET(DIJOYSTATE, lZ),           /* Z  */
    FIELD_OFFSET(DIJOYSTATE, lRx),          /* Rx */
    FIELD_OFFSET(DIJOYSTATE, lRy),          /* Ry */
    FIELD_OFFSET(DIJOYSTATE, lRz),          /* Rz */
    FIELD_OFFSET(DIJOYSTATE, rglSlider[0]), /* S0 */
    FIELD_OFFSET(DIJOYSTATE, rglSlider[1]), /* S1 */
};

UINT INLINE
ibJoyStateAxisFromStateAxis(UINT uiStateAxis)
{
    AssertF(uiStateAxis < cA(c_rgibJoyStateAxisFromStateAxis));
    return c_rgibJoyStateAxisFromStateAxis[uiStateAxis];
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | iJoyPosAxisFromStateAxis |
 *
 *          Convert a <t DIJOYSTATE> axis number back to
 *          a <t JOYPOS> axis number.
 *
 *  @parm   UINT | uiPosAxis |
 *
 *          The index of the requested <t JOYSTATE> axis.
 *
 *  @returns
 *
 *          The corresponding <t JOYPOS> axis number.
 *
 *****************************************************************************/

const int c_rgiJoyPosAxisFromStateAxis[8] = {
    iJoyPosAxisX,               /* X    */
    iJoyPosAxisY,               /* Y    */
    iJoyPosAxisZ,               /* Z    */
    -1,                         /* Rx   */
    -1,                         /* Ry   */
    iJoyPosAxisR,               /* Rz   */
    iJoyPosAxisU,               /* S0   */
    iJoyPosAxisV,               /* S1   */
};

UINT INLINE
iJoyPosAxisFromStateAxis(UINT uiStateAxis)
{
    AssertF(uiStateAxis < cA(c_rgiJoyPosAxisFromStateAxis));
    return c_rgiJoyPosAxisFromStateAxis[uiStateAxis];
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @topic  Cooking Joystick Data |
 *
 *          We always fetch joystick data raw, then cook it before
 *          returning it to the application.
 *
 *          If the app is in "raw" mode, then we don't cook anything.
 *
 *          If the app is in "cooked" mode, then things get interesting.
 *
 *          If there is `centered' cooking, then the center point of the
 *          joystick is reported in the center of the virtual range.
 *
 *
 *          Joystick properties work like this:
 *
 *          <c DIPROP_BUFFERSIZE> - No special semantics.
 *
 *          <c DIPROP_CALIBRATIONMODE> - Specifies whether
 *          cooked or raw data should be returned.  If raw data
 *          is requested, then most other properties have no effect.
 *
 *          The default is cooked.
 *
 *          <c DIPROP_GRANULARITY> - No special semantics.
 *
 *          <c DIPROP_RANGE> - This returns the range of values that
 *          can be returned by the axis.  For joysticks, this is a
 *          read/write property.  (For most devices, it is a read-only
 *          property.)  If you change the property, it affects only
 *          your device instance; it does not affect the ranges of other
 *          devices.
 *
 *          If the axis is in calibration mode, then setting this value
 *          has no immediate effect.
 *
 *          We also define a few new properties:
 *
 *          <c DIPROP_CENTER> - This returns the joystick center (neutral)
 *          position.  In other words, this is the position that
 *          DirectInput returns when the user has released the joystick
 *          and allowed it to self-center.
 *          When a joystick device is created, the center position is
 *          initially set to midway between the lower and
 *          upper bounds of the range.  An application may change the
 *          center position (although I don't see any reason why).
 *
 *          If the axis is in calibration mode, then setting this value
 *          has no immediate effect.
 *
 *          <c DIPROP_DEADZONE> - This returns the size of the joystick
 *          dead zone, as a percentage of total range.
 *
 *          If the axis is in calibration mode, then setting this value
 *          has no immediate effect.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CJoy |
 *
 *          The <i IDirectInputDeviceCallback> object for the
 *          generic joystick.
 *
 *  @field  IDirectInputDeviceCallback | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  PDIJOYSTATE2 | pjsPhys |
 *
 *          Pointer to physical joystick status information kept down in the
 *          VxD.
 *
 *  @field  UINT | idJoy |
 *
 *          Joystick identifier for <f joyGetPosEx> and friends.
 *
 *  @field  DWORD | dwPOVGranularity |
 *
 *          Granularity of the POV control.
 *
 *  @field  HWND | hwnd |
 *
 *          The window which we have subclassed in order to watch
 *          for joystick reconfiguration messages.
 *
 *  @field  HKEY | hkType |
 *
 *          The joystick type key opened with <c MAXIMUM_ALLOWED> access.
 *
 *  @field  VXDINSTANCE * | pvi |
 *
 *          The DirectInput instance handle.
 *
 *  @field  DIDEVCAPS | dc |
 *
 *          Device capability information.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          The dynamically-generated data format based on the
 *          joystick type.
 *
 *  @field  JOYRANGECONVERT | rgjrc |
 *
 *          Range conversion structures for each axis.
 *
 *  @field  DIJOYCONFIG | cfg |
 *
 *          Joystick configuration information.
 *
 *  @field  DIJOYTYPEINFO | typi |
 *
 *          Joystick type information.
 *
 *  @field  PDIDOBJDEFSEM | rgObjSem |
 *
 *          Pointer to array of semantics mapped to this device, 
 *          calculated during init.  
 *
 *  @field  DWORD | dwVersion |
 *
 *          DirectInput version requested by application
 *
 *  @field  DIAPPHACKS | diHacks |
 *
 *          Application hack flags
 *
 *  @field HKEY | hkProp |
 *
 *          Extended properties for device type. Currently we keep 
 *          OEMMapFile under this key. 
 *
 *  @comm
 *
 *          It is the caller's responsibility to serialize access as
 *          necessary.
 *
 *****************************************************************************/

typedef struct CJoy {

    /* Supported interfaces */
    IDirectInputDeviceCallback dcb;

    LPDIJOYSTATE2 pjsPhys;

    UINT idJoy;
    DWORD dwPOVGranularity;

    HWND hwnd;
    HKEY hkType;
    VXDINSTANCE *pvi;
    DIDEVCAPS dc;
    DIDATAFORMAT df;
    JOYRANGECONVERT rgjrc[cJoyStateAxisMax];

    DIJOYCONFIG cfg;
    DIJOYTYPEINFO typi;

    PDIDOBJDEFSEM rgObjSem;

    DWORD dwVersion;

    DIAPPHACKS  diHacks;

    HKEY    hkProp;

} CJoy, DJ, *PDJ;

#define ThisClass CJoy
#define ThisInterface IDirectInputDeviceCallback
#define riidExpected &IID_IDirectInputDeviceCallback

/*****************************************************************************
 *
 *      Forward declarations
 *
 *      These are out of laziness, not out of necessity.
 *
 *****************************************************************************/

STDMETHODIMP CJoy_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk);
void INTERNAL CJoy_InitPhysRanges(PDJ this, LPJOYREGHWCONFIG phwc);

LRESULT CALLBACK
CJoy_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                  UINT uid, ULONG_PTR dwRef);

/*****************************************************************************
 *
 *      CJoy::QueryInterface      (from IUnknown)
 *      CJoy::AddRef              (from IUnknown)
 *      CJoy::Release             (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CJoy)
Default_AddRef(CJoy)
Default_Release(CJoy)

#else

#define CJoy_QueryInterface   Common_QueryInterface
#define CJoy_AddRef           Common_AddRef
#define CJoy_Release          Common_Release

#endif

#define CJoy_QIHelper         Common_QIHelper

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | RemoveSubclass |
 *
 *          Remove our subclass hook on the window.
 *
 *          The parameter is intentionally misdeclared as a <t PV>
 *          so that this function can double as the <f CJoy_AppFinalize>.
 *
 *****************************************************************************/

void INTERNAL
CJoy_RemoveSubclass(PV pvObj)
{
    PDJ this = pvObj;

    /*
     *  If there was an old window, then un-subclass it
     *  and release the hold associated with it.
     *
     *  You might think that there's a race condition here, where
     *  we might unhold the device while the subclass procedure is
     *  still using it.
     *
     *  Ah, but that's not a problem, because the only message that
     *  the subclass procedure cares about is the joystick
     *  reconfiguration message, and when it is processing that message,
     *  it does its own artificial hold/unhold to keep the device alive
     *  while it dorks on the device.
     *
     *  Okay, so there *is* a really tiny race condition where we
     *  might nuke the device while the window procedure is studying
     *  the message to decide whether it cares or not.
     *
     *  Since that is so extremely rare, we close that window by
     *  hacking it:  We revalidate the device before partying on it.
     *  Note that the hack is not perfect, but the race window becomes
     *  only a few instructions long that I'm not going to worry about it.
     *
     *  By wiping out this->hwnd before removing the subclass, we
     *  can reduce the window to very small indeed.
     */
    if (this->hwnd) {
        HWND hwnd = this->hwnd;
        this->hwnd = 0;
        if (!RemoveWindowSubclass(hwnd, CJoy_SubclassProc, 0)) {
            /*
             *  The RemoveWindowSubclass can fail if the window
             *  was destroyed behind our back.
             */
//            AssertF(!IsWindow(hwnd));
        }
        Sleep(0);                   /* Let the worker thread drain */
        Common_Unhold(this);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CJoy_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CJoy_Finalize(PV pvObj)
{
    PDJ this = pvObj;

    if (this->pvi) {
        HRESULT hres;

        hres = Hel_DestroyInstance(this->pvi);
        AssertF(SUCCEEDED(hres));
        FreePpv(&this->df.rgodf);
        FreePpv(&this->rgObjSem );

        if (this->hkType) {
            RegCloseKey(this->hkType);
        }
        if( this->hkProp) {
            RegCloseKey(this->hkProp);
        }
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CJoy_AppFinalize |
 *
 *          The application has performed its final release.
 *          Remove our window subclass at this point.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

#define CJoy_AppFinalize      CJoy_RemoveSubclass

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CJoy_SubclassProc |
 *
 *          Window subclass procedure which watches for
 *          joystick configuration change notifications.
 *
 *  @parm   HWND | hwnd |
 *
 *          The victim window.
 *
 *  @parm   UINT | wm |
 *
 *          Window message.
 *
 *  @parm   WPARAM | wp |
 *
 *          Message-specific data.
 *
 *  @parm   LPARAM | lp |
 *
 *          Message-specific data.
 *
 *  @parm   UINT | uid |
 *
 *          Callback identification number, always zero.
 *
 *  @parm   DWORD | dwRef |
 *
 *          Reference data, a pointer to our joystick device callback.
 *
 *****************************************************************************/

LRESULT CALLBACK
CJoy_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                  UINT uid, ULONG_PTR dwRef)
{
#ifdef XDEBUG
    static CHAR s_szProc[] = "";
#endif
    AssertF(uid == 0);

    if (wm == g_wmJoyChanged) {
        PDJ this = (PDJ)dwRef;

        /*
         *  Wacky subtlety going on here to avoid race conditions.
         *  See the mondo comment block in CJoy_RemoveSubclass
         *  for details.
         *
         *  We can get faked out if the memory associated with the
         *  CJoy is still physically allocated, the vtbl is magically
         *  still there and the hwnd field somehow matches our hwnd.
         */
        if (SUCCEEDED(hresPv(this)) && this->hwnd == hwnd) {

            HRESULT hres;

            Common_Hold(this);
            /*
             *  We must ask for DIJC_CALLOUT even though we don't care,
             *  because that will trigger the Microsoft Gamepad hack-o-rama.
             *
             *  Also, make sure we don't decide that we tried recently
             */
#ifndef WINNT
            g_dwLastBonusPoll = GetTickCount() ^ 0x80000000;
#endif
            hres = JoyReg_GetConfig(this->idJoy, &this->cfg,
                                    DIJC_REGHWCONFIGTYPE | DIJC_CALLOUT);
            if (SUCCEEDED(hres)) {
                CJoy_InitPhysRanges(this, &this->cfg.hwc);
            }
            Common_Unhold(this);

        }
    }

    return DefSubclassProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetInstance |
 *
 *          Obtains the DirectInput instance handle.
 *
 *  @parm   OUT PPV | ppvi |
 *
 *          Receives the instance handle.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetInstance(PDICB pdcb, PPV ppvi)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetInstance, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppvi = (PV)this->pvi;
    hres = S_OK;

    ExitOleProcPpvR(ppvi);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetDataFormat |
 *
 *          Obtains the device's preferred data format.
 *
 *  @parm   OUT LPDIDEVICEFORMAT * | ppdf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdf)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetDataFormat,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppdf = &this->df;
    hres = S_OK;

    ExitOleProcPpvR(ppdf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetDeviceInfo |
 *
 *          Obtain general information about the device.
 *
 *  @parm   OUT LPDIDEVICEINSTANCEW | pdiW |
 *
 *          <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *          Secret convenience:  <e DEVICEINSTANCE.guidProduct> is equal
 *          to <e DEVICEINSTANCE.guidInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW pdiW)
{
    HRESULT hres;
    PDJ this;

    EnterProcI(IDirectInputDeviceCallback::Joy::GetDeviceInfo,
               (_ "pp", pdcb, pdiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEINSTANCEW(pdiW->dwSize));

    /*
     *  Unlike mouse and keyboard, there can be multiple instances of
     *  the same joystick product, so we can't just leave guidProduct
     *  equal to guidInstance.
     */

    pdiW->guidProduct = GUID_Joystick;
    AssertF(pdiW->guidInstance.Data1 ==
            (pdiW->guidProduct.Data1 | this->idJoy));

    pdiW->dwDevType = this->dc.dwDevType;

  #ifdef UNICODE
    lstrcpyn(pdiW->tszProductName, this->typi.wszDisplayName,
             cA(pdiW->tszProductName));
  #else
    CAssertF(cA(pdiW->tszProductName) >= cA(this->typi.wszDisplayName));
    CopyMemory(pdiW->tszProductName, this->typi.wszDisplayName,
               cbX(this->typi.wszDisplayName));
  #endif


/*
 * Since we use HID path, there is no meaning to distinguish 
 * the devices by using "Joystick x" name.
 * We'd better use the same DisplayName for InstanceName.
 * Shall we do this?
 *
    LoadString(g_hinst, IDS_STDJOYSTICK, tszFormat, cA(tszFormat));

#ifdef UNICODE
    wsprintf(pdiW->tszInstanceName, tszFormat, this->idJoy + 1);
#else
    wsprintf(tszName, tszFormat, this->idJoy + 1);
    AToU(pdiW->tszInstanceName, cA(pdiW->tszInstanceName), tszName);
#endif
 */

#ifdef UNICODE
    lstrcpyn(pdiW->tszInstanceName, this->typi.wszDisplayName,
             cA(pdiW->tszInstanceName));
#else
    CAssertF(cA(pdiW->tszInstanceName) >= cA(this->typi.wszDisplayName));
    CopyMemory(pdiW->tszInstanceName, this->typi.wszDisplayName,
               cbX(this->typi.wszDisplayName));
#endif

    if (pdiW->dwSize >= cbX(DIDEVICEINSTANCE_DX5W)) {
        HKEY hkFF;

        /*
         *  If there is a force feedback driver, then fetch the driver CLSID
         *  as the FF GUID.
         */
        hres = CJoy_GetFFConfigKey(pdcb, KEY_QUERY_VALUE, &hkFF);
        if (SUCCEEDED(hres)) {
            LONG lRc;
            TCHAR tszClsid[ctchGuid];

            lRc = RegQueryString(hkFF, TEXT("CLSID"), tszClsid, cA(tszClsid));
            if (lRc == ERROR_SUCCESS &&
                ParseGUID(&pdiW->guidFFDriver, tszClsid)) {
            } else {
                ZeroX(pdiW->guidFFDriver);
            }
            RegCloseKey(hkFF);
        }
    }


    hres = S_OK;

    ExitOleProcR();
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | SetAxisProperty |
 *
 *          If the request is to set a property on the device,
 *          then convert it into separate requests, one for each
 *          axis.
 *
 *  @parm   PDJ | this |
 *
 *          The device object.
 *
 *  @parm   GETSETJOYPROP | GetSetJoyProp |
 *
 *          Callback function that gets or sets the property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @parm   int | ibField |
 *
 *          Offset to field being set.  (Really: Reference data to
 *          pass to callback.)
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_SetAxisProperty(PDJ this, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;

    /*
     *  Note that we never pass the type key to CCal_SetProperty
     *  because we keep our calibration data elsewhere.
     */

    if (ppropi->dwDevType == 0) {           /* For device */
        int iAxis;

        for (iAxis = 0; iAxis < cA(this->rgjrc); iAxis++) {

            PJOYRANGECONVERT pjrc = &this->rgjrc[iAxis];

            hres = CCal_SetProperty(pjrc, ppropi, pdiph, NULL);

            if (FAILED(hres)) {
                goto done;
            }
        }
        hres = S_OK;

    } else if ((ppropi->dwDevType & DIDFT_ABSAXIS) &&
               DIDFT_GETINSTANCE(ppropi->dwDevType) < cA(this->rgjrc)) {

        PJOYRANGECONVERT pjrc;
        pjrc = &this->rgjrc[DIDFT_GETINSTANCE(ppropi->dwDevType)];

        hres = CCal_SetProperty(pjrc, ppropi, pdiph, NULL);

    } else {
        hres = E_NOTIMPL;
    }

done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | UpdateAxisCalibration |
 *
 *          Take our cached calibration information and smash it into
 *          the configuration section of the registry.
 *
 *  @parm   PDJ | this |
 *
 *          The device object.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_UpdateAxisCalibration(PDJ this)
{
    HRESULT hres;
    DIJOYCONFIG cfg;

    hres = JoyReg_GetConfig(this->idJoy, &cfg, DIJC_REGHWCONFIGTYPE);
    if (SUCCEEDED(hres)) {
        UINT uiPosAxis;

#define JoyPosValue(phwc, f, i)                                         \
        *(LPDWORD)pvAddPvCb(&(phwc)->hwv.jrvHardware.f,                 \
                            ibJoyPosAxisFromPosAxis(i))                 \


        for (uiPosAxis = 0; uiPosAxis < cJoyPosAxisMax; uiPosAxis++) {
            PJOYRANGECONVERT pjrc;
            UINT uiStateAxis;

            uiStateAxis = iJoyStateAxisFromPosAxis(uiPosAxis);

            pjrc = &this->rgjrc[uiStateAxis];

            JoyPosValue(&cfg.hwc, jpMin,    uiPosAxis) = pjrc->dwPmin;
            JoyPosValue(&cfg.hwc, jpMax,    uiPosAxis) = pjrc->dwPmax;
            JoyPosValue(&cfg.hwc, jpCenter, uiPosAxis) = pjrc->dwPc;

#undef JoyPosValue
        }

        hres = JoyReg_SetConfig(this->idJoy, &cfg.hwc, &cfg,
                                DIJC_UPDATEALIAS | DIJC_REGHWCONFIGTYPE);

    }

    if (FAILED(hres)) {
        RPF("Joystick::SetProperty::Calibration: "
            "Unable to update calibration in registry");
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | SetProperty |
 *
 *          Set a device property.
 *
 *  @parm   PDJ | this |
 *
 *          The device object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> for something we didn't handle natively.
 *          The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::SetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    switch ((DWORD)(UINT_PTR)ppropi->pguid) {

    case (DWORD)(UINT_PTR)DIPROP_RANGE:
    case (DWORD)(UINT_PTR)DIPROP_DEADZONE:
    case (DWORD)(UINT_PTR)DIPROP_SATURATION:
    case (DWORD)(UINT_PTR)DIPROP_CALIBRATIONMODE:
    case (DWORD)(UINT_PTR)DIPROP_CALIBRATION:
        hres = CJoy_SetAxisProperty(this, ppropi, pdiph);
        if (SUCCEEDED(hres) && ppropi->pguid == DIPROP_CALIBRATION) {
            hres = CJoy_UpdateAxisCalibration(this);
        }
        break;

    case (DWORD)(UINT_PTR)DIPROP_INSTANCENAME:
    case (DWORD)(UINT_PTR)DIPROP_PRODUCTNAME:
        {
            USHORT uVid, uPid;
            
            /*
             *  Friendly names cause all manner of problems with devices that 
             *  use auto detection so only allow non-predefined analog devices 
             *  to use them.
             *
             *  Prefix warns (240487) that ParseVIDPID could leave uVid 
             *  uninitialized and succeed but it won't.  
             *  See the comment in _ParseHex for more details.
             */
            if( ParseVIDPID( &uVid, &uPid, this->cfg.wszType ) &&
                ( uVid == MSFT_SYSTEM_VID ) &&
                ( uPid >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) &&
                ( ( uPid & 0xff00 ) == MSFT_SYSTEM_PID ) )
            {
                AssertF(this->hkType);
                
                if( this->hkType )
                {
                    LPDIPROPSTRING pstr = (PV)pdiph;

                    hres = JoyReg_SetValue(this->hkType,
                                           REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                           pstr->wsz,
                                           cbX(pstr->wsz));
                                              
                    if( SUCCEEDED(hres ) )
                    {
                        hres = S_OK;
                    } else {
                        hres = E_FAIL;
                    }
                }
            }
            else
            {
                hres = E_NOTIMPL;
            }
            break;
        }

    default:
        SquirtSqflPtszV(sqflJoy,
                        TEXT("CJoy_SetProperty: E_NOTIMPL on guid: %08x"),
                        ppropi->pguid);

        hres = E_NOTIMPL;
        break;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetAxisProperty |
 *
 *          Handle an axis property.
 *
 *  @cwrap  PDJ | this
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   OUT LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetAxisProperty(PDJ this, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    LPDIPROPRANGE pdiprg = (PV)pdiph;
    HRESULT hres;

    if ((ppropi->dwDevType & DIDFT_ABSAXIS) &&
        DIDFT_GETINSTANCE(ppropi->dwDevType) < cA(this->rgjrc)) {

        PJOYRANGECONVERT pjrc;
        pjrc = &this->rgjrc[DIDFT_GETINSTANCE(ppropi->dwDevType)];

        hres = CCal_GetProperty(pjrc, ppropi->pguid, pdiph);

    } else {
        SquirtSqflPtszV(sqflJoy,
                        TEXT("CJoy_GetProperty: E_NOTIMPL on guid: %08x"),
                        ppropi->pguid);

        hres = E_NOTIMPL;
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | GetGuidAndPath |
 *
 *          Get a Joy device's class GUID (namely, the MEDIA guid)
 *          and device interface (path).  The path is for the equivalent 
 *          HID device if possible, otherwise a NULL string.
 *
 *  @parm   PCHID | this |
 *
 *          The Joy object.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *****************************************************************************/

VOID INTERNAL
    CJoy_GetGuidAndPath(PDJ this, LPDIPROPHEADER pdiph)
{

/*
 *  This should never happen on Win2k because all devices are HID
 *  but just in case we build an NT4 SP5 version or something...
 */
#ifdef WINNT
    LPDIPROPGUIDANDPATH pgp = (PV)pdiph;

    UNREFERENCED_PARAMETER( this );

    pgp->guidClass = GUID_MediaClass;
    pgp->wszPath[0] = TEXT( '\0' );
#else

    LPDIPROPGUIDANDPATH pgp = (PV)pdiph;
    VXDINITPARMS    vip;
    TCHAR           szPath[MAX_PATH];
    PTCHAR          pszPath;

    pgp->guidClass = GUID_MediaClass;

    pszPath = JoyReg_JoyIdToDeviceInterface_95( this->idJoy, &vip, szPath );
    if( pszPath )
    {
        TToU( pgp->wszPath, cA(pgp->wszPath), pszPath );
    }
    else
    {
        pgp->wszPath[0] = TEXT( '\0' );
    }
#endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetProperty |
 *
 *          Retrieve a device property.
 *
 *  @parm   PDJ | this |
 *
 *          The device object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres = E_NOTIMPL;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    switch ((DWORD)(UINT_PTR)ppropi->pguid) {
        case (DWORD)(UINT_PTR)DIPROP_GRANULARITY:
            /*
             *  ISSUE-2001/03/29-timgill All POVs have the same granularity
             */
            if (ppropi->dwDevType & DIDFT_POV) {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                pdipdw->dwData = this->dwPOVGranularity;
                hres = S_OK;
            }
            break;
    
        case (DWORD)(UINT_PTR)DIPROP_GUIDANDPATH:
            if(ppropi->iobj == 0xFFFFFFFF)
            {
                CJoy_GetGuidAndPath(this, pdiph);
                hres = S_OK;
            }
            break;

        /*
         * In DX7, INSTANCENAME and PRODUCTNAME are the same for VJOYD devices.
         * It is different before DX7. Probably we need make them different again
         * after DX7.
         */
        case (DWORD)(UINT_PTR)DIPROP_INSTANCENAME:
        case (DWORD)(UINT_PTR)DIPROP_PRODUCTNAME:
            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;
                
                /*
                 * lstrcpW doesn't work in Win95. We have to use memcpy instead.
                 */
                //lstrcpyW(pstr->wsz, this->typi.wszDisplayName);
                if( cbX(pdipstr->wsz) > cbX(this->typi.wszDisplayName) )
                {
                    memset( &pdipstr->wsz[cA(this->typi.wszDisplayName)], 0, cbX(pdipstr->wsz) - cbX(this->typi.wszDisplayName) );
                }

                CAssertF( cbX(pdipstr->wsz) >= cbX(this->typi.wszDisplayName) );
                memcpy( pdipstr->wsz, this->typi.wszDisplayName, cbX(this->typi.wszDisplayName));
                if( this->diHacks.nMaxDeviceNameLength < lstrlenW(pdipstr->wsz) ) {
                    pdipstr->wsz[this->diHacks.nMaxDeviceNameLength] = L'\0';
                }
                hres = S_OK;
                break;
            }


        case (DWORD)(UINT_PTR)DIPROP_JOYSTICKID:
            if(ppropi->iobj == 0xFFFFFFFF)
            {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                pdipdw->dwData =  this->idJoy;
                hres = S_OK;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_MAPFILE):
            AssertF( ppropi->iobj == 0xFFFFFFFF );

            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;
                LONG    lRes;
                DWORD   dwBufferSize = cbX(pdipstr->wsz);

                lRes = RegQueryStringValueW( this->hkProp, REGSTR_VAL_JOYOEMMAPFILE, pdipstr->wsz, &dwBufferSize );
                hres = ( pdipstr->wsz[0] && ( lRes == ERROR_SUCCESS ) ) ? S_OK : DIERR_OBJECTNOTFOUND;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_TYPENAME):
            AssertF( ppropi->iobj == 0xFFFFFFFF );

            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;

                if( this->cfg.hwc.dwType >= JOY_HW_PREDEFMIN && this->cfg.hwc.dwType < JOY_HW_PREDEFMAX ) {
                    pdipstr->wsz[0] = L'#';
                    pdipstr->wsz[1] = L'0' + (WCHAR)this->cfg.hwc.dwType;
                    pdipstr->wsz[2] = L'\0';
                    hres = S_OK;
                } 
                else if( this->cfg.wszType[0] != L'\0' ) 
                {
                    /*
                     *  The type MUST be NULL terminated
                     */
#ifdef WINNT
                    lstrcpyW( pdipstr->wsz, this->cfg.wszType );
#else
                    UINT uiLen;

                    uiLen = lstrlenW( this->cfg.wszType ) + 1;
                    AssertF( uiLen <= cA( pdipstr->wsz ) );
                    memcpy( pdipstr->wsz, this->cfg.wszType, uiLen * cbX(this->cfg.wszType[0]) );
#endif
                    hres = S_OK;
                }
                else
                {
                    /*
                     *  Don't think this should ever happen so Assert for now
                     *  Assert that the hres is a failure (if not quite right)
                     */
                    AssertF( hres == E_NOTIMPL );
                    AssertF( !"No type name available in GetProperty" );
                }
            }
            break;

            

    /*
     *  Else, it might be something axis-specific.
     */
    default:
        hres = CJoy_GetAxisProperty(this, ppropi, pdiph);
        break;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | GetCapabilities |
 *
 *          Get joystick device capabilities.
 *
 *  @parm   PDJ | this |
 *
 *          The joystick object.
 *
 *  @parm   LPDIDEVCAPS | pdc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdc)
{
    HRESULT hres;
    PDJ this;
    JOYINFOEX jix;
    MMRESULT mmrc = MMSYSERR_ERROR;

    EnterProcI(IDirectInputDeviceCallback::Joy::GetCapabilities,
               (_ "pp", pdcb, pdc));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVCAPS(pdc->dwSize));
    CopyMemory(pvAddPvCb(pdc, cbX(DWORD)),
               pvAddPvCb(&this->dc, cbX(DWORD)),
               pdc->dwSize - cbX(DWORD));

    /*
     *  Joysticks can come and go.  Re-query each time.
     */

    /*
     *  Determine if joystick is physically attached
     *  or is possibly even phantom.
     *
     *  JOYERR_ATTACHED  - Is attached
     *  JOYERR_UNPLUGGED - Is not attached
     *  Anything else    - Is phantom
     */
    jix.dwSize = sizeof(JOYINFOEX);
    jix.dwFlags = JOY_CAL_READALWAYS | JOY_RETURNALL;
    mmrc = joyGetPosEx(this->idJoy, &jix);

    pdc->dwFlags &= ~DIDC_ATTACHED;
    if (mmrc == JOYERR_NOERROR) {
        pdc->dwFlags |= DIDC_ATTACHED;
    } else if (mmrc == JOYERR_UNPLUGGED) {
    } else {
        pdc->dwFlags |= DIDC_PHANTOM;
    }

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | GetPhysicalState |
 *
 *          Read the physical joystick state into <p pjsOut>.
 *
 *          After getting the physical data,
 *          we cook the axes as necessary.
 *
 *  @parm   LPDIJOYSTATE2 | pjsOut |
 *
 *          Where to put the joystick state.
 *
 *  @returns
 *
 *          None.
 *
 *****************************************************************************/

void INLINE
CJoy_GetPhysicalState(PDJ this, LPDIJOYSTATE2 pjsOut)
{
    UINT uiStateAxis;

    AssertF(this->pjsPhys);

    *pjsOut = *this->pjsPhys;

    /*
     *  Note only absolute positional data gets calibrated 
     */
    if( ( this->pvi->fl & VIFL_RELATIVE ) == 0 )
    {
        for (uiStateAxis = 0; uiStateAxis < cA(this->rgjrc); uiStateAxis++) {
            PLONG pl = pvAddPvCb(pjsOut,
                                 ibJoyStateAxisFromStateAxis(uiStateAxis));
            CCal_CookRange(&this->rgjrc[uiStateAxis], pl);
        }
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | Poll |
 *
 *          Ping down into the driver to get the latest data.
 *
 *  @returns
 *
 *          <c S_OK> if we pinged okay.
 *          <c DIERR_UNPLUGGED> if we did not
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_Poll(PDICB pdcb)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::Poll, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = Hel_Joy_Ping(this->pvi);
    if (FAILED(hres)) {
        AssertF(hres ==
            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32,
                                         ERROR_DEV_NOT_EXIST));
        hres = DIERR_UNPLUGGED;
    }
    /*
     *  Note, we don't keep this->pvi->fl:VIFL_UNPLUGGED up-to-date because 
     *  we don't use the flag and always retest the connectivity in GetCaps.
     */

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetDeviceState |
 *
 *          Obtains the state of the joystick device.
 *
 *          It is the caller's responsibility to have validated all the
 *          parameters and ensure that the device has been acquired.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          joystick data in the preferred data format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetDeviceState(PDICB pdcb, LPVOID pvData)
{
    HRESULT hres;
    PDJ this;
    LPDIJOYSTATE2 pjsOut = pvData;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetDeviceState,
               (_ "pp", pdcb, pvData));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pjsPhys);

    if (this->pvi->fl & VIFL_ACQUIRED) {
        CJoy_GetPhysicalState(this, pjsOut);
        hres = S_OK;
    } else {
        hres = DIERR_INPUTLOST;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | CookDeviceData |
 *
 *          Manipulate buffered device data.
 *
 *          If the item describe an axis, we need to cook it.
 *
 *  @parm   DWORD | cdod |
 *
 *          Number of objects to cook; zero is a valid value.
 *
 *  @parm   LPDIDEVICEOBJECTDATA | pdod |
 *
 *          Array of object data to cook.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_UNSUPPORTED> = <c E_NOTIMPL>: The callback does
 *          not cook device data.
 *
 *          <c DIERR_NOTACQUIRED>: The device could not be acquired.
 *
 ***************************************************************************/

STDMETHODIMP
CJoy_CookDeviceData
(
    PDICB                   pdcb, 
    DWORD                   cdod, 
    LPDIDEVICEOBJECTDATA    pdod
)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::CookDeviceData,
               (_ "pxp", pdcb, cdod, pdod));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  Step through array of either element size cooking the data.
     */
    for( ; cdod; cdod-- )
    {
        DWORD dwType = this->df.rgodf[pdod->dwOfs].dwType;
        if( dwType & DIDFT_ABSAXIS )
        {
            PJOYRANGECONVERT pjrc;

            AssertF( DIDFT_GETINSTANCE( dwType ) < cA( this->rgjrc ) );
            pjrc = &this->rgjrc[DIDFT_GETINSTANCE( dwType )];

            CCal_CookRange(pjrc, (PV)&pdod->dwData);
        }
        pdod++;
    }

    hres = S_OK;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | OpenIdSubkey |
 *
 *          Given an object ID, attempt to open the subkey that
 *          corresponds to it.
 *
 *  @cwrap  PDJ | this
 *
 *  @parm   DWORD | dwId |
 *
 *          Object id.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

HRESULT INLINE
CJoy_OpenIdSubkey(PDJ this, DWORD dwId, PHKEY phk)
{
      return CType_OpenIdSubkey(this->hkType, dwId, KEY_QUERY_VALUE, phk);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetObjectInfo |
 *
 *          Obtain the friendly name and FF/HID information
 *          of an object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          <e DIDEVICEOBJECTINSTANCE.dwFlags>
 *          fields have already been filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                               LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetObjectInfo,
               (_ "pxp", pdcb, ppropi->iobj, pdidoiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEW(pdidoiW->dwSize));
    if (ppropi->iobj < this->df.dwNumObjs) {

        AssertF(ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType);

        CType_RegGetObjectInfo(this->hkType, ppropi->dwDevType, pdidoiW);

        /*
         *  If we couldn't get a name from the registry,
         *  then grab one of the standard names.
         */
        if (pdidoiW->tszName[0] == L'\0') {
            UINT dids;

            if (ppropi->dwDevType & DIDFT_AXIS) {
                dids = 0;
                LoadStringW(g_hinst, IDS_JOYSTICKOBJECT + dids +
                                     DIDFT_GETINSTANCE(ppropi->dwDevType),
                                     pdidoiW->tszName, cA(pdidoiW->tszName));
            } else if (ppropi->dwDevType & DIDFT_BUTTON) {
                GetNthButtonString(pdidoiW->tszName,
                                   DIDFT_GETINSTANCE(ppropi->dwDevType));
            } else {
                AssertF(ppropi->dwDevType & DIDFT_POV);
                GetNthPOVString(pdidoiW->tszName,
                                DIDFT_GETINSTANCE(ppropi->dwDevType));
            }

        }

        /*
         *  ISSUE-2001/03/29-timgill Need a faster way of checking VJoyD devices
         *  On Win9x, many HID devices cannot use our ring 3 HID path so try
         *  to get any axis or POV usage from VJoyD
         *  This is not cheap to get but until we have a better way to 
         *  make sure the VJoyD device has not changed under us this is better 
         *  than caching it.  This is not inner loop code anyway.
         */
#ifndef WINNT
        if( pdidoiW->dwSize >= cbX(DIDEVICEOBJECTINSTANCE_DX5W) )
        {
            VXDINITPARMS vip;
            hres = Hel_Joy_GetInitParms(this->idJoy, &vip);

            if( SUCCEEDED( hres ) && ( vip.dwFlags & VIP_ISHID ) ) 
            {
                if( ppropi->dwDevType & DIDFT_AXIS )
                {
                    int AxisIdx;

                    AxisIdx = c_rgiJoyPosAxisFromStateAxis[DIDFT_GETINSTANCE(ppropi->dwDevType)];
                    pdidoiW->wUsagePage = HIWORD( vip.Usages[AxisIdx] );
                    pdidoiW->wUsage = LOWORD( vip.Usages[AxisIdx] );
                }
                else if( ppropi->dwDevType & DIDFT_BUTTON )
                {
                    /*
                     *  Only JoyHID uses this interface and it only counts 
                     *  button page buttons so assume the simplest case.
                     */
                    pdidoiW->wUsagePage = HID_USAGE_PAGE_BUTTON;
                    pdidoiW->wUsage = 1 + DIDFT_GETINSTANCE( ppropi->dwDevType );
                }
                else
                {
                    AssertF(ppropi->dwDevType & DIDFT_POV);
                    pdidoiW->wUsagePage = HIWORD( ((PDWORD)(&vip.dwPOV0usage))[DIDFT_GETINSTANCE(ppropi->dwDevType)] );
                    pdidoiW->wUsage = LOWORD( ((PDWORD)(&vip.dwPOV0usage))[DIDFT_GETINSTANCE(ppropi->dwDevType)] );
                }
            }
        }
        /*
         *  Ignore any errors getting params.
         */
#endif

        hres = S_OK;
    } else {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | SetCooperativeLevel |
 *
 *          The app changed the cooperative level.
 *          Un-subclass the old window and en-subclass the new window.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  First get out of the old window.
     */
    CJoy_RemoveSubclass(this);
    /*
     *  Prefix warns that "this" may have been freed (mb:34574) however 
     *  If you're in SetCooperativeLevel and you have a window subclassed 
     *  then there must be a hold for the subclassed window as well as 
     *  one for the unreleased interface so the Common_Unhold won't free 
     *  the pointer.
     */

    /*
     *  If a new window is passed, then subclass it so we can
     *  watch for joystick configuration change messages.
     *
     *  If we can't, don't worry.  All it means that we won't
     *  be able to catch when the user recalibrates the joystick,
     *  which isn't very often.
     */
    if (hwnd) {
        if (SetWindowSubclass(hwnd, CJoy_SubclassProc, 0, (ULONG_PTR)this)) {
            this->hwnd = hwnd;
            Common_Hold(this);
        }

    } else {
        RPF("SetCooperativeLevel: You really shouldn't pass hwnd = 0; "
            "joystick calibration may be dodgy");
    }

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | RunControlPanel |
 *
 *          Run the joystick control panel.
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          The owner window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags.
 *
 *****************************************************************************/

TCHAR c_tszJoyCpl[] = TEXT("joy.cpl");

STDMETHODIMP
CJoy_RunControlPanel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::RunControlPanel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = hresRunControlPanel(c_tszJoyCpl);

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetFFConfigKey |
 *
 *          Open and return the registry key that contains
 *          force feedback configuration information.
 *
 *  @parm   DWORD | sam |
 *
 *          Security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the registry key.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk)
{
    HRESULT hres;
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetFFConfigKey,
               (_ "px", pdcb, sam));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = JoyReg_OpenFFKey(this->hkType, sam, phk);

    AssertF(fLeqvFF(SUCCEEDED(hres), *phk));

    ExitBenignOleProcPpvR(phk);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | CreateEffect |
 *
 *          Create an <i IDirectInputEffectDriver> interface.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD * | ppes |
 *
 *          Receives the shepherd for the effect driver.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes)
{
    HRESULT hres;
    PDJ this;
    HKEY hk;
    EnterProcI(IDirectInputDeviceCallback::Joy::CreateEffect, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = CJoy_GetFFConfigKey(pdcb, KEY_QUERY_VALUE, &hk);
    if (SUCCEEDED(hres)) {
        hres = CEShep_New(hk, 0, &IID_IDirectInputEffectShepherd, ppes);
        if (SUCCEEDED(hres)) {
#ifndef WINNT
            VXDINITPARMS    vip;
            CHAR           szPath[MAX_PATH];
            PCHAR          pszPath;

            pszPath = JoyReg_JoyIdToDeviceInterface_95( this->idJoy, &vip, szPath );
            if( pszPath )
            {
                DIHIDFFINITINFO init;
                WCHAR           wszPath[MAX_PATH];

                ZeroX(init);
                init.dwSize = cbX(init);

                TToU( wszPath, cA(wszPath), pszPath );
                init.pwszDeviceInterface = wszPath;
                hresFindHIDDeviceInterface(pszPath, &init.GuidInstance);

                hres = (*ppes)->lpVtbl->DeviceID((*ppes), this->idJoy, TRUE, &init);
            }
            else
#endif
            {
                hres = (*ppes)->lpVtbl->DeviceID((*ppes), this->idJoy, TRUE, 0);
            }
        }
        if (SUCCEEDED(hres)) {
        } else {
            Invoke_Release(ppes);
        }
        RegCloseKey(hk);
    } else {
        hres = E_NOTIMPL;
        *ppes = 0;
    }

    ExitOleProcPpvR(ppes);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | GetVersions |
 *
 *          Ping down into the driver to get the driver version info.
 *
 *  @parm   LPDIDRIVERVERSIONS | pvers |
 *
 *          A structure which should be filled in with version information
 *          describing the hardware, firmware, and driver.
 *
 *          DirectInput will set the <e DIDRIVERVERSIONS.dwSize> field
 *          to sizeof(DIDRIVERVERSIONS) before calling this method.
 *
 *  @returns
 *
 *          <c S_OK> if we succeeded.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_GetVersions(PDICB pdcb, LPDIDRIVERVERSIONS pvers)
{
    HRESULT hres;
    PDJ this;
    VXDINITPARMS vip;
    EnterProcI(IDirectInputDeviceCallback::Joy::GetVersions, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(pvers->dwSize == cbX(*pvers));

    hres = Hel_Joy_GetInitParms(this->idJoy, &vip);

    if (SUCCEEDED(hres)) {
        pvers->dwFirmwareRevision = vip.dwFirmwareRevision;
        pvers->dwHardwareRevision = vip.dwHardwareRevision;
        pvers->dwFFDriverVersion  = vip.dwFFDriverVersion;
    }

    return hres;
}


/*****************************************************************************
 *
 *  Joystick registry usage
 *
 *****************************************************************************
 *
 *  Global joystick information is kept under
 *
 *  HKEY_LOCAL_MACHINE\
 *      System\
 *          CurrentControlSet\
 *              Control\
 *                  MediaProperties\
 *                      Joystick\
 *                          OEM
 *
 *  Under this key is a number of subkeys, each corresponding to a brand
 *  of joystick.
 *
 *  Under each OEM\<name> key, you can find the following values:
 *
 *      OEMData
 *
 *          This is a binary value containing a structure of two dwords.
 *          The first is the JOYREGHWCONFIG.hws.dwFlags and the second
 *          is the JOYREGHWCONFIG.hws.dwNumButtons.
 *
 *      OEMName
 *
 *          This is a string which gives a friendly name for the unit.
 *
 *
 *****************************************************************************
 *
 *  Under the driver key is kept information about the particular joystick.
 *
 *  HKEY_LOCAL_MACHINE\
 *      System\
 *          CurrentControlSet\
 *              Control\
 *                  MediaResources\
 *                      Joystick\
 *                          <driver key name>\
 *                              CurrentJoystickSettings
 *
 *  Under this key, there are a bunch of values named
 *  Joystick##Configuration, where ## is the joystick number
 *  (1 through 16).  Each value contains binary data in the form
 *  of a JOYREGHWCONFIG, which looks like this:
 *
 *      DWORD hws.dwFlags;    // JOY_HWS_*    \
 *      DWORD hws.dwNumButtons;               _\ JOYREGHWSETTINGS
 *      DWORD dwUsageSettings;// JOY_US_*    _____
 *      DWORD hwv.jrvHardware.jpMin.dwX;    \     |
 *      DWORD hwv.jrvHardware.jpMin.dwY;     \    |
 *      DWORD hwv.jrvHardware.jpMin.dwZ;      \
 *      DWORD hwv.jrvHardware.jpMin.dwR;      |
 *      DWORD hwv.jrvHardware.jpMin.dwU;       > JOYREGHWVALUES.JOYRANGE
 *      DWORD hwv.jrvHardware.jpMin.dwV;      |
 *      DWORD hwv.jrvHardware.jpMax.dwX;      |   |
 *      DWORD hwv.jrvHardware.jpMax.dwY;      |   |
 *      DWORD hwv.jrvHardware.jpMax.dwZ;      |   \
 *      DWORD hwv.jrvHardware.jpMax.dwR;      |    > JOYREGHWVALUES
 *      DWORD hwv.jrvHardware.jpMax.dwU;      |   /
 *      DWORD hwv.jrvHardware.jpMax.dwV;      |   |
 *      DWORD hwv.jrvHardware.jpCenter.dwX;   |   |
 *      DWORD hwv.jrvHardware.jpCenter.dwY;   |   |
 *      DWORD hwv.jrvHardware.jpCenter.dwZ;   |   |
 *      DWORD hwv.jrvHardware.jpCenter.dwR;   /   |
 *      DWORD hwv.jrvHardware.jpCenter.dwU;  /    |
 *      DWORD hwv.jrvHardware.jpCenter.dwV; /     |
 *      DWORD hwv.dwPOVValues[4];                 |
 *      DWORD hwv.dwCalFlags;               ______|
 *      DWORD dwType;         // JOY_HW_*
 *      DWORD dwReserved;
 *
 *
 *  Also under this key are optional values named Joystick##OEMName.
 *  If present, it is a string-data key whose contents are the name
 *  of another key that describes the joystick, stored in the global
 *  section described above.
 *
 *  Meanwhile, under the key
 *
 *  HKEY_LOCAL_MACHINE\
 *      System\
 *          CurrentControlSet\
 *              Control\
 *                  MediaResources\
 *                      Joystick\
 *                          <driver key name>
 *
 *  is a value called "JoystickUserValues".  This is a binary key
 *  that contains a JOYREGUSERVALUES structure:
 *
 *      DWORD   dwTimeOut;
 *      DWORD   jrvRanges.jpMin.dwX;    \
 *      DWORD   jrvRanges.jpMin.dwY;     \
 *      DWORD   jrvRanges.jpMin.dwZ;      \
 *      DWORD   jrvRanges.jpMin.dwR;      |
 *      DWORD   jrvRanges.jpMin.dwU;       > JOYRANGE
 *      DWORD   jrvRanges.jpMin.dwV;      |
 *      DWORD   jrvRanges.jpMax.dwX;      |
 *      DWORD   jrvRanges.jpMax.dwY;      |
 *      DWORD   jrvRanges.jpMax.dwZ;      |
 *      DWORD   jrvRanges.jpMax.dwR;      |
 *      DWORD   jrvRanges.jpMax.dwU;      |
 *      DWORD   jrvRanges.jpMax.dwV;      |
 *      DWORD   jrvRanges.jpCenter.dwX;   | (ignored)
 *      DWORD   jrvRanges.jpCenter.dwY;   | (ignored)
 *      DWORD   jrvRanges.jpCenter.dwZ;   | (ignored)
 *      DWORD   jrvRanges.jpCenter.dwR;   / (ignored)
 *      DWORD   jrvRanges.jpCenter.dwU;  /  (ignored)
 *      DWORD   jrvRanges.jpCenter.dwV; /   (ignored)
 *      DWORD   jpDeadZone.dwX;         \
 *      DWORD   jpDeadZone.dwY;          \
 *      DWORD   jpDeadZone.dwZ;           \ JOYPOS
 *      DWORD   jpDeadZone.dwR;           / Dead zone is recorded as a
 *      DWORD   jpDeadZone.dwU;          /  percentage of total range
 *      DWORD   jpDeadZone.dwV;         /
 *
 *  If there is no JoystickUserValues, then the following defaults
 *  are used:
 *
 *      jpMin.dw# = 0;
 *      jpMax.dw# = 65535;
 *      jpCenter.dw# = jpMax.dw# / 2;
 *      jrvDeadZone.dw# = 5;
 *
 *  (See ibmjoy\msjstick.c, function jsReadRegistry for the code that
 *  sets the defaults.)
 *
 *  We will also use the defaults if Min > Max or if Max >= 0x80000000
 *  or if DeadZone > 100.
 *
 *****************************************************************************/


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | InitPhysRanges |
 *
 *          Initialize (or re-initialize)
 *          the physical min/max/center values.  This is
 *          done as part of device initialization as well as in response
 *          to a notification that the Joystick control panel has been
 *          dinked with.
 *
 *          It is assumed that the <e DJ.hwc> already contains the
 *          registry hardware settings.
 *
 *          After the phys ranges are set, the ramps are recalculated.
 *
 *
 *****************************************************************************/

void INTERNAL
CJoy_InitPhysRanges(PDJ this, LPJOYREGHWCONFIG phwc)
{
    UINT uiPosAxis;
    UINT uiStateAxis;

#define GetJoyPosValue(phwc, f, i)                                      \
        *(LPDWORD)pvAddPvCb(&phwc->hwv.jrvHardware.f,                   \
                            ibJoyPosAxisFromPosAxis(i))                 \

    for (uiPosAxis = 0; uiPosAxis < cJoyPosAxisMax; uiPosAxis++) {
        DWORD dwMax, dwC;
        PJOYRANGECONVERT pjrc;

        uiStateAxis = iJoyStateAxisFromPosAxis(uiPosAxis);

        pjrc = &this->rgjrc[uiStateAxis];

        pjrc->dwPmin = GetJoyPosValue(phwc, jpMin, uiPosAxis);

        /*
         *  HACKHACK - Uncalibrated joysticks will have max == 0, in which
         *  case we use a fake max of 655, just like VJOYD.
         */
        dwMax = GetJoyPosValue(phwc, jpMax, uiPosAxis);
        if (dwMax == 0) {
            dwMax = 655;
        }

        pjrc->dwPmax = dwMax;

        /*
         *  HACKHACK - Uncalibrated joysticks will have center == 0,
         *  in which case we use a fake center of midway between min and
         *  max, just like VJOYD.
         *
         *  Quirk - Z, R, U, and V typically are not center-calibrated,
         *  so if the jpCenter value is not strictly between min and
         *  max, then assume it's one of the bogus cases and slam it
         *  into the middle of the range.
         */

        dwC = GetJoyPosValue(phwc, jpCenter, uiPosAxis);
        if (dwC <= pjrc->dwPmin || dwC >= pjrc->dwPmax) {
            dwC = (pjrc->dwPmin + pjrc->dwPmax) / 2;
        }

        pjrc->dwPc = dwC;

        if( pjrc->dwCPointsNum == 0 ) {
            //use two control points by default
            pjrc->dwCPointsNum = 2;
            pjrc->cp[0].lP = pjrc->dwPmin;
            pjrc->cp[0].dwLog = 0;
            pjrc->cp[1].lP = pjrc->dwPmax;
            pjrc->cp[1].dwLog = RANGEDIVISIONS;
        } else {
            pjrc->cp[0].lP = pjrc->dwPmin;
            pjrc->cp[pjrc->dwCPointsNum-1].lP = pjrc->dwPmax;
        }
    
        SquirtSqflPtszV(sqfl,
                        TEXT("CJoy_PhysRange %d -> %d: %08x / %08x / %08x"),
                        uiPosAxis,
                        uiStateAxis,
                        pjrc->dwPmin,
                        pjrc->dwPc,
                        pjrc->dwPmax);

    }

#undef GetJoyValue

    /*
     *  These two phantom axes are always raw because they don't exist.
     */
    this->rgjrc[iJoyStateAxisRx].fRaw = TRUE;
    this->rgjrc[iJoyStateAxisRy].fRaw = TRUE;

    /*
     *  Now compute all the dependent variables.
     */
    for (uiStateAxis = 0; uiStateAxis < cA(this->rgjrc); uiStateAxis++) {
        CCal_RecalcRange(&this->rgjrc[uiStateAxis]);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | InitLogRanges |
 *
 *          Initialize the logical ranges from the user values.
 *
 *****************************************************************************/

void INLINE
CJoy_InitLogRanges(PDJ this)
{
    HRESULT hres;
    UINT uiPosAxis;
    UINT uiStateAxis;
    DIJOYUSERVALUES juv;

    hres = JoyReg_GetUserValues(&juv, DIJU_USERVALUES);
    AssertF(SUCCEEDED(hres));

#define pJoyValue(jp, i)                                            \
        (LPDWORD)pvAddPvCb(&(jp), ibJoyPosAxisFromPosAxis(i))       \


    for (uiPosAxis = 0; uiPosAxis < cJoyPosAxisMax; uiPosAxis++) {

        PJOYRANGECONVERT pjrc;

        AssertF((int)*pJoyValue(juv.ruv.jrvRanges.jpMax, uiPosAxis) >= 0);
        AssertF(*pJoyValue(juv.ruv.jrvRanges.jpMin, uiPosAxis) <
                *pJoyValue(juv.ruv.jrvRanges.jpMax, uiPosAxis));

        uiStateAxis = iJoyStateAxisFromPosAxis(uiPosAxis);

        pjrc = &this->rgjrc[uiStateAxis];

        pjrc->lMin = *pJoyValue(juv.ruv.jrvRanges.jpMin, uiPosAxis);
        pjrc->lMax = *pJoyValue(juv.ruv.jrvRanges.jpMax, uiPosAxis);

        /*
         *  Note that we do *not* use the jpCenter value.  Strange
         *  but true.
         *
         *  The sum cannot overflow due to the sanity checks we did above.
         */

        pjrc->lC = CCal_Midpoint(pjrc->lMin, pjrc->lMax);

        /*
         *  Now do the dead zone.  Convert from percent to range units.
         */
        pjrc->dwDz = *pJoyValue(juv.ruv.jpDeadZone, uiPosAxis) *
                                    (RANGEDIVISIONS / 100);

        if (pjrc->dwDz > RANGEDIVISIONS) {
            pjrc->dwDz = 5 * (RANGEDIVISIONS / 100);
        }

        /*
         *  Now do the saturation level.  It always defaults to 100%.
         */
        pjrc->dwSat = RANGEDIVISIONS;

    }

}

#undef pJoyValue


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | BuildAxes |
 *
 *          Study a single capabilities flag and add axis items to the data
 *          format accordingly.
 *
 *  @parm   DWORD | dwCaps |
 *
 *          Collection of <c JOYPF_*> flags describing the axes supported.
 *
 *  @parm   UINT | ib |
 *
 *          Data format offset at which this data is provided.
 *
 *  @parm   UINT | uiObj |
 *
 *          Instance index for the first item.
 *
 *  @parm   DWORD | dwAspect |
 *
 *          <c DIDOI_ASPECT*> for these axes.
 *
 *****************************************************************************/


typedef struct AXISATTRIBUTES {
    DWORD dwMask;                   /* Mask that identifies the axis */
    UINT  uidObj;                   /* Object index delta from X axis */
} AXISATTRIBUTES, *PAXISATTRIBUTES;
typedef const AXISATTRIBUTES *PCAXISATTRIBUTES;

typedef struct AXISMAPPINGS {
    PCGUID pguid;                   /* GUID for the object */
    DWORD  dwSemantic;              /* Default semantic map */
} AXISMAPPINGS, *PAXISMAPPINGS;
typedef const AXISMAPPINGS *PCAXISMAPPINGS;

const AXISATTRIBUTES c_rgaattrJoy[] = {
    {   JOYPF_X,    iJoyStateAxisX,  },
    {   JOYPF_Y,    iJoyStateAxisY,  },
    {   JOYPF_Z,    iJoyStateAxisZ,  },
    {   JOYPF_R,    iJoyStateAxisRz, },
    {   JOYPF_U,    iJoyStateAxisS0, },
    {   JOYPF_V,    iJoyStateAxisS1, },
};


const AXISMAPPINGS c_rgamapJoy[6] = {
    { &GUID_XAxis,  DISEM_FLAGS_X | DISEM_TYPE_AXIS }, 
    { &GUID_YAxis,  DISEM_FLAGS_Y | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_RzAxis, DISEM_FLAGS_R | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
};

const AXISMAPPINGS c_rgamap6DOF[6] = {
    { &GUID_XAxis,  DISEM_FLAGS_X | DISEM_TYPE_AXIS }, 
    { &GUID_YAxis,  DISEM_FLAGS_Y | DISEM_TYPE_AXIS }, 
    { &GUID_ZAxis,  DISEM_FLAGS_Z | DISEM_TYPE_AXIS }, 
    { &GUID_RzAxis, DISEM_FLAGS_R | DISEM_TYPE_AXIS }, 
    { &GUID_RyAxis, DISEM_FLAGS_U | DISEM_TYPE_AXIS }, 
    { &GUID_RxAxis, DISEM_FLAGS_V | DISEM_TYPE_AXIS }, 
};

const AXISMAPPINGS c_rgamapZJoy[6] = {
    { &GUID_XAxis,  DISEM_FLAGS_X | DISEM_TYPE_AXIS }, 
    { &GUID_YAxis,  DISEM_FLAGS_Y | DISEM_TYPE_AXIS }, 
    { &GUID_ZAxis,  DISEM_FLAGS_Z | DISEM_TYPE_AXIS }, 
    { &GUID_RzAxis, DISEM_FLAGS_R | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
};

/*
 *  Since default HID mapping maps accel to Y and brake to Rz 
 *  use the GUIDs to match the correct axis to those mappings 
 *  and set appropriate semantics.
 */

const AXISMAPPINGS c_rgamapCarZY[6] = {
    { &GUID_XAxis,  DISEM_FLAGS_X | DISEM_TYPE_AXIS }, 
    { &GUID_RzAxis, DISEM_FLAGS_B | DISEM_TYPE_AXIS }, 
    { &GUID_YAxis,  DISEM_FLAGS_A | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
};

const AXISMAPPINGS c_rgamapCarYR[6] = {
    { &GUID_XAxis,  DISEM_FLAGS_X | DISEM_TYPE_AXIS }, 
    { &GUID_YAxis,  DISEM_FLAGS_A | DISEM_TYPE_AXIS }, 
    { &GUID_ZAxis,  DISEM_FLAGS_Z | DISEM_TYPE_AXIS }, 
    { &GUID_RzAxis, DISEM_FLAGS_B | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
};

const AXISMAPPINGS c_rgamapCarZR[6] = {
    { &GUID_XAxis,  DISEM_FLAGS_X | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_YAxis,  DISEM_FLAGS_A | DISEM_TYPE_AXIS }, 
    { &GUID_RzAxis, DISEM_FLAGS_B | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
    { &GUID_Slider, DISEM_FLAGS_S | DISEM_TYPE_AXIS }, 
};

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitFromHwc |
 *
 *          Initialize the information that is kept in the
 *          <t JOYREGHWCONFIG>.
 *
 *          Broken out from CJoy_InitRing3 to make things less monolithic.
 *
 *          The <e CJoy.cfg> structure already contains joystick
 *          configuration information.
 *
 *****************************************************************************/

HRESULT INLINE
CJoy_InitFromHwc(PDJ this)
{
    HRESULT hres;
    DWORD dwTestType;

    if( this->cfg.hwc.dwType >= JOY_HW_PREDEFMIN && this->cfg.hwc.dwType < JOY_HW_PREDEFMAX ) {
        WCHAR wszType[4];
        
        wszType[0] = L'#';
        wszType[1] = L'0' + (WCHAR)this->cfg.hwc.dwType;
        wszType[2] = L'\0';
        
        hres = JoyReg_GetPredefTypeInfo( wszType, &this->typi, DITC_DISPLAYNAME);
    } else if (this->cfg.wszType[0] != L'\0' ) {
        hres = JoyReg_GetTypeInfo(this->cfg.wszType, &this->typi, DITC_DISPLAYNAME | DITC_FLAGS2 );

        if (SUCCEEDED(hres)) {
        } else {
#ifdef WINNT
            ZeroMemory(&this->typi, cbX(this->typi));
#else
            //lstrcpyW( this->typi.wszDisplayName, this->cfg.wszType );
            memset( &this->typi.wszDisplayName[0], 0, sizeof(this->typi.wszDisplayName) );
            memcpy( &this->typi.wszDisplayName[0], &this->cfg.wszType[0], sizeof(this->cfg.wszType));
#endif
        }
    } else {
        ZeroMemory(&this->typi, cbX(this->typi));
    }

    #define hwc this->cfg.hwc
    

    if( ( this->typi.dwFlags2 & ( JOYTYPE_HIDEACTIVE | JOYTYPE_GAMEHIDE ) )
     == ( JOYTYPE_HIDEACTIVE | JOYTYPE_GAMEHIDE ) )
    {
        this->dc.dwFlags |= DIDC_HIDDEN;
    }

    dwTestType = GetValidDI8DevType( this->typi.dwFlags2, this->dc.dwButtons, hwc.hws.dwFlags );

    if( dwTestType )
    {
        /*
         *  If a valid override exists just use it
         */
        this->dc.dwDevType = dwTestType;
    }
    else
    {
#ifdef XDEBUG
        if( GET_DIDEVICE_TYPEANDSUBTYPE( this->typi.dwFlags2 ) )
        {
            RPF( "Ignoring invalid type/subtype Flags2 value 0x%08x for joystick", this->typi.dwFlags2 );
        }
#endif

        if (hwc.hws.dwFlags & JOY_HWS_ISYOKE) 
        {
            dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_FLIGHT, DI8DEVTYPEFLIGHT_STICK);
        } 
        else if (hwc.hws.dwFlags & JOY_HWS_ISGAMEPAD) 
        {
            dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_GAMEPAD, DI8DEVTYPEGAMEPAD_STANDARD);
        } 
        else if (hwc.hws.dwFlags & JOY_HWS_ISCARCTRL) 
        {
            AssertF( this->dc.dwAxes > 1 );
            if ( this->dc.dwAxes <= 2 )
            {
                dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_DRIVING, DI8DEVTYPEDRIVING_COMBINEDPEDALS );
            }
            else
            {
                dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_DRIVING, DI8DEVTYPEDRIVING_DUALPEDALS );
            }
        } 
        else if (hwc.hws.dwFlags & JOY_HWS_ISHEADTRACKER) 
        {
            dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_SUPPLEMENTAL, DI8DEVTYPESUPPLEMENTAL_HEADTRACKER);
        } 
        else 
        {
            dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_JOYSTICK, DI8DEVTYPEJOYSTICK_STANDARD);
        }

        /*
         *  Use the common function to make this a limited type if the 
         *  number of buttons or flags dictate it.
         *  Since the type and subtype are known to be valid, the return 
         *  value should never be a failure (zero).
         */
        this->dc.dwDevType = GetValidDI8DevType( dwTestType, this->dc.dwButtons, hwc.hws.dwFlags );
        AssertF( this->dc.dwDevType );
    }


    #undef hwc

    /*
     *  Now that we know the type, then make up a name ourselves if we 
     *  previously failed to do so.
     */
    if (this->typi.wszDisplayName[0] == TEXT('\0'))
    {
        CType_MakeGameCtrlName( this->typi.wszDisplayName, 
            this->dc.dwDevType, this->dc.dwAxes, this->dc.dwButtons, this->dc.dwPOVs );
    }


     
    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | AddObject |
 *
 *          Add one object to the device format.
 *
 *          If the device is polled, then the object is polled, too.
 *
 *  @cwrap  PDJ | this
 *
 *  @parm   PCGUID | pguid |
 *
 *          The <t GUID> that classifies the device.
 *
 *  @parm   DWORD | dwOfs |
 *
 *          Data offset.
 *
 *  @parm   DWORD | dwDevType |
 *
 *          Device type flags to apply to the object.
 *
 *  @parm   UINT | uiObj |
 *
 *          Object instance number.
 *
 *  @parm   DWORD | dwAspect |
 *
 *          Optional <c DIDOI_ASPECT*> flag.
 *
 *****************************************************************************/

void INTERNAL
CJoy_AddObject(PDJ this, PCGUID pguid, DWORD dwOfs,
               DWORD dwDevType, UINT uiObj, DWORD dwAspect, BOOL fReal)
{
    LPDIOBJECTDATAFORMAT podf;

    podf = &this->df.rgodf[this->df.dwNumObjs++];
    podf->pguid = pguid;
    podf->dwOfs = dwOfs;
    podf->dwType = dwDevType | DIDFT_MAKEINSTANCE(uiObj);
    podf->dwFlags = dwAspect;

    if (this->dc.dwFlags & DIDC_POLLEDDEVICE) {
        podf->dwFlags |= DIDOI_POLLED;
    }

    if( fReal )
    {
        CType_RegGetTypeInfo(this->hkType, podf, FALSE);
        if( ( GET_DIDEVICE_TYPE( this->dc.dwDevType ) == DI8DEVTYPE_DRIVING )
         && ( podf->dwFlags & DIDOI_FFACTUATOR )
         && ( podf->pguid != &GUID_XAxis ) )
        {
            /*
             *  IHVs set FF attributes on non-FF axes for wheels because 
             *  first generation FF apps were only written to support joysticks.
             *  Since we now munge the various configurations of pedal axes to 
             *  report all split pedals in the same way, the fake Y axis can 
             *  land up on different axes, usually Slider0.  Rather than have 
             *  people code to these different fake axes, strip out actuator 
             *  status from any driving axis except the wheel.
             */
            podf->dwFlags &= ~DIDOI_FFACTUATOR;
            podf->dwType &= ~DIDFT_FFACTUATOR;
        }
    }
}

void INTERNAL
CJoy_BuildAxes(PDJ this, DWORD dwCaps, UINT ib, UINT uiObj, 
               DWORD dwAspect, PCAXISMAPPINGS pamap, BOOL fReal )
{
    int iaattr;

    for (iaattr = 0; iaattr < cA(c_rgaattrJoy); iaattr++) {
        PCAXISATTRIBUTES paattr = &c_rgaattrJoy[iaattr];
        if (dwCaps & paattr->dwMask) {
            CJoy_AddObject(this, pamap[iaattr].pguid, (cbX(LONG)*paattr->uidObj) + ib,
                DIDFT_ABSAXIS, paattr->uidObj + uiObj, dwAspect, fReal);
        }
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CJoy | BuildDataFormat |
 *
 *          Study the device capabilities and build the device
 *          data format.
 *
 *****************************************************************************/

void INTERNAL
CJoy_BuildDataFormat(PDJ this, PVXDAXISCAPS pvac, DWORD dwButtons, PCAXISMAPPINGS pamap, BOOL fReal)
{
    DWORD dw;

    this->dc.dwAxes = 0;
    this->dc.dwButtons = 0;
    this->dc.dwPOVs = 0;

    this->df.dwSize = cbX(DIDATAFORMAT);
    this->df.dwObjSize = cbX(DIOBJECTDATAFORMAT);
    this->df.dwDataSize = sizeof(DIJOYSTATE2);
    AssertF(this->df.dwFlags == 0);
    this->df.dwNumObjs = 0;

    /*
     *  Repeat for each set of axes.
     */

    #define CheckAxisOrder(fStart, p, f)                                    \
            CAssertF(FIELD_OFFSET(DIJOYSTATE2, p##f) ==                     \
                     FIELD_OFFSET(DIJOYSTATE2, fStart) + ibJoyStateAxis##f) \

    CheckAxisOrder(lX, l, X);
    CheckAxisOrder(lX, l, Y);
    CheckAxisOrder(lX, l, Z);
    CheckAxisOrder(lX, l, Rx);
    CheckAxisOrder(lX, l, Ry);
    CheckAxisOrder(lX, l, Rz);
    CheckAxisOrder(lX, rgl, Slider);

    if (pvac->dwPos & JOYPF_POSITION) {
        CJoy_BuildAxes(this, pvac->dwPos, FIELD_OFFSET(DIJOYSTATE2, lX),
                       iobjPositions, DIDOI_ASPECTPOSITION, pamap, fReal);
    }

    CheckAxisOrder(lVX, lV, X);
    CheckAxisOrder(lVX, lV, Y);
    CheckAxisOrder(lVX, lV, Z);
    CheckAxisOrder(lVX, lV, Rx);
    CheckAxisOrder(lVX, lV, Ry);
    CheckAxisOrder(lVX, lV, Rz);
    CheckAxisOrder(lVX, rglV, Slider);

    if (pvac->dwPos & JOYPF_VELOCITY) {
        CJoy_BuildAxes(this, pvac->dwVel, FIELD_OFFSET(DIJOYSTATE2, lVX),
                       iobjVelocities, DIDOI_ASPECTVELOCITY, pamap, fReal);
    }

    CheckAxisOrder(lAX, lA, X);
    CheckAxisOrder(lAX, lA, Y);
    CheckAxisOrder(lAX, lA, Z);
    CheckAxisOrder(lAX, lA, Rx);
    CheckAxisOrder(lAX, lA, Ry);
    CheckAxisOrder(lAX, lA, Rz);
    CheckAxisOrder(lAX, rglA, Slider);

    if (pvac->dwPos & JOYPF_ACCELERATION) {
        CJoy_BuildAxes(this, pvac->dwAccel, FIELD_OFFSET(DIJOYSTATE2, lAX),
                       iobjAccels, DIDOI_ASPECTACCEL, pamap, fReal);
    }

    CheckAxisOrder(lFX, lF, X);
    CheckAxisOrder(lFX, lF, Y);
    CheckAxisOrder(lFX, lF, Z);
    CheckAxisOrder(lFX, lF, Rx);
    CheckAxisOrder(lFX, lF, Ry);
    CheckAxisOrder(lFX, lF, Rz);
    CheckAxisOrder(lFX, rglF, Slider);

    if (pvac->dwPos & JOYPF_FORCE) {
        CJoy_BuildAxes(this, pvac->dwForce, FIELD_OFFSET(DIJOYSTATE2, lFX),
                       iobjForces, DIDOI_ASPECTFORCE, pamap, fReal);
    }

    #undef CheckAxisOrder

    this->dc.dwAxes = this->df.dwNumObjs;

    /*
     *  Doing the POVs is a bit tricky but not that bad.
     */
    for (dw = 0; dw < cJoyStatePOVTotal; dw++) {
        if (pvac->dwPos & JOYPF_POV(dw)) {
            CJoy_AddObject(this, &GUID_POV,
                           FIELD_OFFSET(DIJOYSTATE2, rgdwPOV[dw]),
                           DIDFT_POV, dw, DIDOI_ASPECTUNKNOWN, fReal);
            this->dc.dwPOVs++;
        }
    }

    /*
     *  Doing the buttons is easy since they don't have
     *  any interesting attributes.
     */
    this->dc.dwButtons = min(dwButtons, cJoyStateButtonTotal);

    for (dw = 0; dw < this->dc.dwButtons; dw++) {
        CJoy_AddObject(this, &GUID_Button,
                       FIELD_OFFSET(DIJOYSTATE2, rgbButtons[dw]),
                       DIDFT_PSHBUTTON, dw, DIDOI_ASPECTUNKNOWN, fReal);
    }

    AssertF(this->df.dwNumObjs <= cJoyStateObjTotal);

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | PreInit |
 *
 *          Preallocate all the memory we will need up front, so we
 *          don't waste time reallocating later.
 *
 *****************************************************************************/

HRESULT INLINE
CJoy_PreInit(PDJ this)
{
    HRESULT hres;

    hres = ReallocCbPpv(cbCxX(cJoyStateObjTotal, DIOBJECTDATAFORMAT),
                        &this->df.rgodf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitRing0 |
 *
 *          Initialize the ring 0 information maintained about the object.
 *
 *          Broken out from CJoy_Init to make things less monolithic.
 *
 *****************************************************************************/

HRESULT INTERNAL
CJoy_InitRing0(PDJ this)
{
    HRESULT hres;
    VXDDEVICEFORMAT devf;

    /*
     *  Note that we now allow the device to be created even if
     *  the joystick doesn't physically exist.  This is necessary
     *  so that IDirectInputJoyConfig8 can calibrate the joystick
     *  that doesn't exist yet.
     *
     *  This won't confuse applications, however, because
     *  IDirectInput::EnumDevices will not return phantom devices
     *  unless the application explicitly asks for phantom devices
     *  to be included.
     */

    /*
     *  See if this joystick supports fancy notifications.
     *  The default is "no".
     *
     *  Also see if this is really a HID device (and hence our
     *  interface is an alias).
     *
     *  These things are all 9x-specific.
     */
#ifdef WINNT
    this->dc.dwFlags |= DIDC_POLLEDDEVICE;
#else

    VXDINITPARMS vip;

    this->dc.dwFlags |= DIDC_POLLEDDEVICE;

    hres = Hel_Joy_GetInitParms(this->idJoy, &vip);
    if (SUCCEEDED(hres)) 
    {
        if (vip.dwFlags & VIP_SENDSNOTIFY) 
        {
            this->dc.dwFlags &= ~DIDC_POLLEDDEVICE;
        }
       
        if (vip.dwFlags & VIP_ISHID) 
        {
            /*
             *  Use VJOYD as Alias if the device is HID 
             *  (the may be revised in CJoy_InitRing3).
             */
            this->dc.dwFlags |= DIDC_ALIAS;
        }
    }
#endif /* WINNT */

    this->dc.dwSize = cbX(DIDEVCAPS);

    /*
     *  Build the worst-case data format for the VxD.
     *
     *  We must always build worst-case because sometime
     *  later, a newer more capable joystick might show up,
     *  with more objects than the one we imprinted on.
     *
     *  Use the GUIDs for a joystick for now, and pass the flag 
     *  indicating that there is no need to check registry settings.
     */

    CJoy_BuildDataFormat(this, &c_vacMax, cJoyStateButtonTotal, c_rgamapJoy, FALSE);

    /*
     *  It won't actually get that high because of the
     *  nonexistent Rx and Ry axes.
     */
    AssertF(this->df.dwNumObjs <= cJoyStateObjTotal);

    devf.cbData = cbX(DIJOYSTATE2);
    devf.dwExtra = this->idJoy;
    devf.cObj = this->df.dwNumObjs;
    devf.rgodf = this->df.rgodf;
    devf.dwEmulation = 0;

    hres = Hel_Joy_CreateInstance(&devf, &this->pvi);
    if (SUCCEEDED(hres)) {
        AssertF(this->pvi);
        this->pjsPhys = this->pvi->pState;
    } else {                /* IOCTL failed; hres already set */
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitSemanticMap |
 *
 *          Initialize the semantic mapping information.
 *
 *****************************************************************************/

void INLINE
CJoy_GetAxisMap( PDJ this, PCAXISMAPPINGS* ppamap )
{
    if( GET_DIDEVICE_TYPEANDSUBTYPE( this->dc.dwDevType ) 
          == MAKE_DIDEVICE_TYPE( DI8DEVTYPE_1STPERSON, DI8DEVTYPE1STPERSON_SIXDOF ) )
    {
        *ppamap = &c_rgamap6DOF[0];
    }
    else if( ( GET_DIDEVICE_TYPE( this->dc.dwDevType ) == DI8DEVTYPE_DRIVING )
          && ( this->dc.dwAxes > 2 ) )
    {
        /*
         *  There are three common forms of pedals
         *      a.  Split Y axis, below center accel, above brake
         *      b.  Y break, Z accel
         *      c.  Y accel, R brake
         *  a. is just like a joystick but b and c need their own look ups
         *
         *  Use a registry flag if one is set, otherwise, select using HASR 
         *  as there is at least one case of an X,Y,R device that reports 
         *  the presence of a bogus Z axis.
         */
        switch( this->typi.dwFlags2 & JOYTYPE_INFOMASK )
        {
        case JOYTYPE_INFOYYPEDALS:
            *ppamap = &c_rgamapJoy[0];
            break;

        case JOYTYPE_INFOZYPEDALS:
            *ppamap = &c_rgamapCarZY[0];
            break;

        case JOYTYPE_INFOYRPEDALS:
            *ppamap = &c_rgamapCarYR[0];
            break;

        case JOYTYPE_INFOZRPEDALS:
            *ppamap = &c_rgamapCarZR[0];
            break;

        default:
            if( ( this->cfg.hwc.hws.dwFlags & JOY_HWS_HASR )
             && ( this->cfg.hwc.hws.dwFlags & JOY_HWS_HASZ ) )
            {
                *ppamap = &c_rgamapCarZR[0];
            }
            else if( this->cfg.hwc.hws.dwFlags & JOY_HWS_HASR )
            {
                *ppamap = &c_rgamapCarYR[0];
            }
            else if( this->cfg.hwc.hws.dwFlags & JOY_HWS_HASZ )
            {
                *ppamap = &c_rgamapCarZY[0];
            }
            else
            {
                *ppamap = &c_rgamapJoy[0];
            }
        }
    }
    else 
    {
        /*
         *  The default map is joystick
         *
         *  Check for Z axis behavior override
         *  Since the default behavior is to use Z as a slider, 
         *  only the override to a Z axis is needed here.
         */
        if( this->typi.dwFlags2 & JOYTYPE_INFOZISZ )
        {
            *ppamap = &c_rgamapZJoy[0];
        }
        else
        {
            *ppamap = &c_rgamapJoy[0];
        }
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitSemanticMap |
 *
 *          Initialize the semantic mapping information.
 *
 *****************************************************************************/

HRESULT INLINE
CJoy_InitSemanticMap( PDJ this, DWORD dwAxisMask, PCAXISMAPPINGS pamap )
{
    HRESULT hres;
    
    /*
     *  Prefix warns (mb:34681) that the pointer would be null if the 
     *  number of objects on the device is zero.
     *  This cannot be, so assert it but don't check in retail.
     */
    AssertF( this->dc.dwAxes + this->dc.dwPOVs + this->dc.dwButtons != 0 );
    if( SUCCEEDED( hres = AllocCbPpv(cbCxX( 
        (this->dc.dwAxes + this->dc.dwPOVs + this->dc.dwButtons ), DIDOBJDEFSEM), 
        &this->rgObjSem) ) )
    {
        UINT            Idx;
        PDIDOBJDEFSEM   pObjSem = this->rgObjSem;
        LPDIOBJECTDATAFORMAT podf;

        /*
         *  The axis mapping table does most of the work
         */
        for( Idx = 0; Idx < cA(c_rgaattrJoy); Idx++ ) 
        {
            PCAXISATTRIBUTES paattr = &c_rgaattrJoy[Idx];
            if( dwAxisMask & c_rgaattrJoy[Idx].dwMask) 
            {
                pObjSem->dwID = DIDFT_ABSAXIS | DIDFT_MAKEINSTANCE(c_rgaattrJoy[Idx].uidObj);
                pObjSem->dwSemantic = pamap[Idx].dwSemantic;
                pObjSem++;
            }
        }

        AssertF( pObjSem == &this->rgObjSem[this->dc.dwAxes] );

        /*
         *  POVs and buttons require no look ups.
         */

        for( Idx = 0; Idx < this->dc.dwPOVs; Idx++ )
        {
            pObjSem->dwID = DIDFT_POV | DIDFT_MAKEINSTANCE(Idx);
            pObjSem->dwSemantic = DISEM_TYPE_POV | DISEM_INDEX_SET(Idx+1);
            pObjSem++;
        }

        AssertF( pObjSem == &this->rgObjSem[this->dc.dwAxes + this->dc.dwPOVs] );

        for( Idx = 0; Idx < this->dc.dwButtons; Idx++ )
        {
            pObjSem->dwID = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE(Idx);
            pObjSem->dwSemantic = DISEM_TYPE_BUTTON | DISEM_INDEX_SET(Idx+1);
            pObjSem++;
        }

        AssertF( pObjSem == &this->rgObjSem[this->dc.dwAxes + this->dc.dwPOVs + this->dc.dwButtons] );

        /*
         *  Now go back to pick up any extra type bits, such as FF.
         *  Because we use the same order in creating the semantic table as 
         *  is used to create the data format, this is optimized to only 
         *  search from where the previous match was found.  We cannot rely 
         *  on a one-to-one mapping because of the non-positional axes.
         */

        podf = &this->df.rgodf[this->df.dwNumObjs];
        for( pObjSem--; pObjSem >= this->rgObjSem; pObjSem-- )
        {
            do 
            {
                podf--;
                if( ( podf->dwType & (DIDFT_INSTANCEMASK | DIDFT_TYPEMASK) ) 
                  == pObjSem->dwID )
                {
                    pObjSem->dwID = podf->dwType;
                    break;
                }
            } while( podf >= this->df.rgodf );

            AssertF( podf >= this->df.rgodf );
        }
    }

    return hres;
}
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | InitRing3 |
 *
 *          Initialize the ring 3 information maintained about the object.
 *
 *          Broken out from CJoy_Init to make things less monolithic.
 *
 *****************************************************************************/

HRESULT INTERNAL
CJoy_InitRing3(PDJ this )
{
    HRESULT hres;
    VXDAXISCAPS vac;
    PCAXISMAPPINGS pamap;

    /*
     *  We must ask for DIJC_CALLOUT even though we don't care,
     *  because that will trigger the Microsoft Gamepad hack-o-rama.
     */
    hres = JoyReg_GetConfig(this->idJoy, &this->cfg,
                            DIJC_REGHWCONFIGTYPE | DIJC_CALLOUT );
    if (SUCCEEDED(hres)) {
        /*
         * Fix phantom devices bug. See manbug: 23186
         */
        if( this->cfg.hwc.dwType == JOY_HW_NONE ) {
            hres = E_FAIL;
            goto done;
        }

        /*
         *  Open the type key so we can grovel into the type info.
         *  If the RegOpenKeyEx fails, the value of this->hkType
         *  will stay zero so we won't run with garbage.
         *
         *  Note that failure to open the type key is not an error.
         *
         *  We need to do this before building the data format, because
         *  BuildDataFormat needs the hkType to get the attributes.
         */
        AssertF(this->hkType == 0);
        
        /*
         *  Only open the key if it is intended to exist
         */
        if( this->cfg.hwc.dwUsageSettings & JOY_US_ISOEM )
        {
            JoyReg_OpenTypeKey(this->cfg.wszType, MAXIMUM_ALLOWED,
                               REG_OPTION_NON_VOLATILE, &this->hkType);
        }

        if FAILED (JoyReg_OpenPropKey(this->cfg.wszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &this->hkProp))
        {
            /*
             * If we fail to open the prop key - we will continue to function with loss in functionality
             * Specifically no device images, etc
             */
        }
    
        hres = Hel_Joy_GetAxisCaps(this->idJoy, &vac, &this->cfg.hwc );
        /*
         *  HACKHACK
         *  In the case of a DX5 VJoyD, the POV0 flag can be stripped out of 
         *  the vac if the poll returns a POV0 value other than (DWORD)-1.
         *  So add it back if the registry says we have it.
         */
        if( this->cfg.hwc.hws.dwFlags & JOY_HWS_HASPOV )
        {
            DWORD dwVersion = GetVersion();

            /*
             *  Check for any Win95 version
             */
            if( ( LOBYTE( dwVersion ) == 4 )
             && ( HIBYTE( LOWORD( dwVersion ) ) < 10 ) )
            {
                vac.dwPos |= JOYPF_POV0;
            }

        }

        AssertF(SUCCEEDED(hres));

        /*
         *  Previous versions of DInput allow a POV granularity of 1 if 
         *  joyGetCaps returned a wCaps with JOYCAPS_POV4DIR set.
         *  This does no good as neither drivers nor WinMM really 
         *  support this.  
         */
        this->dwPOVGranularity = 9000;

        /*
         *  Logical ranges must be done before physical ranges,
         *  because initializing the physical ranges will also
         *  recompute the ramp conversion parameters.
         */
        CJoy_InitLogRanges(this);

        CJoy_InitPhysRanges(this, &this->cfg.hwc);


        /*
         *  Need to init from HWC before building real data format so type 
         *  overrides can be taken into account.  Unfortunately, until the 
         *  data format is built, we don't know what axes are available.
         *  Since the code is already here, build the data format again.
         *  Use the joystick look-ups and don't bother with registry flags.
         */
        CJoy_BuildDataFormat(this, &vac, this->cfg.hwc.hws.dwNumButtons, c_rgamapJoy, FALSE );
        hres = CJoy_InitFromHwc( this );

        if( SUCCEEDED( hres ) )
        {
            CJoy_GetAxisMap( this, &pamap );
            /*
             *  At last, time to build the data format for real
             */
            CJoy_BuildDataFormat(this, &vac, this->cfg.hwc.hws.dwNumButtons, pamap, TRUE );
            hres = CJoy_InitSemanticMap( this, vac.dwPos, pamap );
        }


      #ifndef WINNT
        if( this->hkType )
        {
            DWORD dwFlags1;
            if( SUCCEEDED( JoyReg_GetValue( this->hkType,
                    REGSTR_VAL_FLAGS1, REG_BINARY, 
                    &dwFlags1, 
                    cbX(dwFlags1) ) ) )
            {
                if( dwFlags1 & JOYTYPE_NOHIDDIRECT )
                {
                    this->dc.dwFlags &= ~DIDC_ALIAS;
                }
            }
        }
      #endif

        this->diHacks.nMaxDeviceNameLength = MAX_PATH;

    } else {
        RPF("Unexpected error 0x%08x obtaining joystick capabilities",hres);
        hres = E_FAIL;
    }

done:
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | Init |
 *
 *          Initialize the object by establishing the data format
 *          based on the joystick capabilities.
 *
 *****************************************************************************/

HRESULT INTERNAL
CJoy_Init(PDJ this, REFGUID rguid)
{
    HRESULT hres;
    EnterProc(CJoy_Init, (_ "pG", this, rguid));

    this->idJoy = rguid->Data1 & 0xF;

    /* If joystick number is vaguely valid */
    if (this->idJoy < cJoyMax) {

        if (SUCCEEDED(hres = CJoy_PreInit(this)) &&
            SUCCEEDED(hres = CJoy_InitRing0(this)) &&
            SUCCEEDED(hres = CJoy_InitRing3(this))) {
        }
    } else {
        hres = DIERR_DEVICENOTREG;
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *      CJoy_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Joy::<constructor>,
               (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CJoy, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv in case of aggregation */
        PDJ this = _thisPv(*ppvObj);

        if (SUCCEEDED(hres = CJoy_Init(this, rguid))) {
        } else {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | SetDIData |
 *
 *          Set DirectInput version and apphack data from CDIDev *.
 *
 *  @parm   DWORD | dwVer |
 *
 *          DirectInput version
 *
 *  @parm   LPVOID | lpdihacks |
 *
 *          AppHack data
 *
 *  @returns
 *
 *          <c S_OK> because we cannot fail.
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks)
{
    PDJ this;
    EnterProcI(IDirectInputDeviceCallback::Joy::SetDIData,
               (_ "pup", pdcb, dwVer, lpdihacks));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    this->dwVersion = dwVer;

    CopyMemory(&this->diHacks, (LPDIAPPHACKS)lpdihacks, sizeof(this->diHacks));

    ExitProcR();
    return S_OK;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoy | BuildDefaultActionMap |
 *
 *          Generate default mappings for the objects on this device.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInst |
 *
 *          Device instance GUID.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> 
 *
 *****************************************************************************/

STDMETHODIMP
CJoy_BuildDefaultActionMap
(
    PDICB               pdcb, 
    LPDIACTIONFORMATW   paf, 
    DWORD               dwFlags, 
    REFGUID             guidInst
)
{
    HRESULT             hres;
    PDJ                 this;
    PDIDOBJDEFSEM       pObjDefSemTemp;

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    EnterProcI(IDirectInputDeviceCallback::Joy::BuildDefaultActionMap, 
        (_ "ppxG", pdcb, paf, dwFlags, guidInst));

    this = _thisPvNm(pdcb, dcb);

    /*
     *  Prefix warns (win:199090) that the pointer would be null if the 
     *  size of the semantic object list is zero.
     *  This cannot be, so assert it but don't check in retail.
     */
    AssertF( cbCxX( this->dc.dwAxes + this->dc.dwPOVs + this->dc.dwButtons, DIDOBJDEFSEM ) );
    hres = AllocCbPpv( cbCxX( 
        ( this->dc.dwAxes + this->dc.dwPOVs + this->dc.dwButtons ), DIDOBJDEFSEM ), 
        &pObjDefSemTemp );

    if( SUCCEEDED( hres ) )
    {
        memcpy( pObjDefSemTemp, this->rgObjSem, cbCxX( 
            ( this->dc.dwAxes + this->dc.dwPOVs + this->dc.dwButtons ), DIDOBJDEFSEM ) );
        hres = CMap_BuildDefaultDevActionMap( paf, dwFlags, guidInst, 
            pObjDefSemTemp, this->dc.dwAxes, this->dc.dwPOVs, this->dc.dwButtons );
        FreePv( pObjDefSemTemp );
    }

    ExitOleProcR();
    return hres;
}



/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#define CJoy_Signature        0x2044424B      /* "Joy " */

Interface_Template_Begin(CJoy)
    Primary_Interface_Template(CJoy, IDirectInputDeviceCallback)
Interface_Template_End(CJoy)

Primary_Interface_Begin(CJoy, IDirectInputDeviceCallback)
    CJoy_GetInstance,
    CJoy_GetVersions,
    CJoy_GetDataFormat,
    CJoy_GetObjectInfo,
    CJoy_GetCapabilities,
    CDefDcb_Acquire,
    CDefDcb_Unacquire,
    CJoy_GetDeviceState,
    CJoy_GetDeviceInfo,
    CJoy_GetProperty,
    CJoy_SetProperty,
    CDefDcb_SetEventNotification,
    CJoy_SetCooperativeLevel,
    CJoy_RunControlPanel,
    CJoy_CookDeviceData,
    CJoy_CreateEffect,
    CJoy_GetFFConfigKey,
    CDefDcb_SendDeviceData,
    CJoy_Poll,
    CDefDcb_GetUsage,
    CDefDcb_MapUsage,
    CJoy_SetDIData,
    CJoy_BuildDefaultActionMap,
Primary_Interface_End(CJoy, IDirectInputDeviceCallback)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\digenx.c ===
/*****************************************************************************
 *
 *  DIGenX.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Generic IDirectInputDevice callback for uninitialized devices.
 *
 *  Contents:
 *
 *      CNil_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflNil

/*****************************************************************************
 *
 *      Note!  This is not a normal refcounted interface.  It is
 *      a static object whose sole purpose is to keep the seat warm
 *      until the IDirectInputDevice gets Initialize()d.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *          We're not a real object, so we don't have any interfaces.
 *
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_QueryInterface(PDICB pdcb, REFIID riid, PPV ppvObj)
{
    return E_NOTIMPL;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *          We are always here, so the refcount is meaningless.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | Release |
 *
 *          Increments the reference count for the interface.
 *
 *          We are always here, so the refcount is meaningless.
 *
 *****************************************************************************/

STDMETHODIMP_(ULONG)
CNil_AddRefRelease(PDICB pdcb)
{
    return 0;
}

#define CNil_AddRef                 CNil_AddRefRelease
#define CNil_Release                CNil_AddRefRelease

/*****************************************************************************
 *
 *      You might think we could just write a bunch of stubs,
 *      <f CNil_NotInit0>,
 *      <f CNil_NotInit4>,
 *      <f CNil_NotInit8>, and so on, one for each arity, and
 *      point all of the methods at the appropriate stub.
 *
 *      However, you would be wrong.  Some processors (especially
 *      the 68k series) have weird calling conventions which depend
 *      on things other than just the number of bytes of parameters.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetInstance |
 *
 *          Called by DirectInput to obtain the DirectInput instance
 *          handle that was created by the DirectInput device driver.
 *
 *  @parm   LPVOID * | ppvInst |
 *
 *          Receives the DirectInput instance handle created by the
 *          DirectInput device driver.  This instance handle is returned
 *          to the device-specific driver, which in turn is given to
 *          the device callback via a private mechanism.
 *
 *          If the device callback does not use a device driver, then
 *          0 is returned in this variable.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_GetInstance(PDICB pdcb, LPVOID *ppvInst)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetDataFormat |
 *
 *          Called by DirectInput to obtain the device's preferred
 *          data format.
 *
 *  @parm   OUT LPDIDATAFORMAT * | ppdidf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ****************************************************************************/

STDMETHODIMP
CNil_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdidf)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetObjectInfo |
 *
 *          Obtain the friendly name of an object, passwed by index
 *          into the preferred data format.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          fields have already been filled in.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ****************************************************************************/

STDMETHODIMP
CNil_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                               LPDIDEVICEOBJECTINSTANCEW pdidioiW)
{
    /*
     *  This should never happen; didev.c validates the device
     *  before calling us.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetCapabilities |
 *
 *          Obtain device capabilities.
 *
 *  @parm   LPDIDEVCAPS | pdidc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ****************************************************************************/

STDMETHODIMP
CNil_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdidc)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::GetCapabilities.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | Acquire |
 *
 *          Begin data acquisition.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ****************************************************************************/

STDMETHODIMP
CNil_Acquire(PDICB pdcb)
{
    /*
     *  This should never happen; we don't get called until
     *  after the data format is set.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | Unacquire |
 *
 *          End data acquisition.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_Unacquire(PDICB pdcb)
{
    /*
     *  This should never happen; we don't get called until
     *  we've acquired, which never works.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetDeviceState |
 *
 *          Obtain instantaneous device state.
 *
 *  @parm   OUT LPVOID | lpvBuf |
 *
 *          Buffer to receive device state.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_GetDeviceState(PDICB pdcb, LPVOID lpvBuf)
{
    /*
     *  This may legitimately be called, because it happens only
     *  when the device is already acquired, which never happens.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetDeviceInfo |
 *
 *          Obtain the product id.
 *
 *  @parm   LPDIDEVICEINSTANCEW | lpdidiW |
 *
 *          (out) <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW lpdidiW)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::GetDeviceInfo.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetProperty |
 *
 *          Retrieve a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   OUT LPDIPROPHEADER | pdiph |
 *
 *          Where to put the property value.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER lpdiph)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::GetProperty.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | SetProperty |
 *
 *          Set a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   IN LPCDIPROPHEADER | pdiph |
 *
 *          Value of property.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER lpdiph)
{
    /*
     *  This should never happen; didev.c validates the device
     *  before calling us.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | SetEventNotification |
 *
 *          Set the handle associated with the device.
 *
 *  @parm   HANDLE | h |
 *
 *          Handle to be signalled when new data arrives.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_SetEventNotification(PDICB pdcb, HANDLE h)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::SetEventNotification.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | SetCooperativeLevel |
 *
 *          Set the device cooperativity level.  Device callbacks
 *          typically need only respond to the <c DISCL_EXCLUSIVE> bit.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::SetCooperativeLevel.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | RunControlPanel |
 *
 *          Run the control panel for the device.
 *
 *  @parm   HWND | hwndOwner |
 *
 *          Owner window (if modal).
 *
 *  @parm   DWORD | fl |
 *
 *          Flags.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_RunControlPanel(PDICB pdcb, HWND hwndOwner, DWORD fl)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling IDirectInputDevice::RunControlPanel.
     */
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}


/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | CookDeviceData |
 *
 *          Cook a piece of device data that was obtained from the
 *          data buffer.  This data does not pass through the device
 *          callback, so it needs to be cooked externally.  In
 *          comparison, device state information is obtained via
 *          DIDM_GETDEVICESTATE, which the callback can cook before
 *          returning.
 *
 *          If the callback returns E_NOTIMPL, then the caller is
 *          permitted to cache the result <y for the entire device>
 *          (not merely for the device object) until the next DIDM_ACQUIRE.
 *
 *  @parm   DWORD | cdod |
 *
 *          Number of objects to cook.  This can be zero, in which case
 *          the caller is checking whether the device requires cooking.
 *
 *  @parm   LPDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of object data to cook.
 *
 *          Note, however, that the <e DIDEVICEOBJETCDATA.dwOfs> fields
 *          are not what you think.  The low word contains the application
 *          data offset (which is not important to the callback); the
 *          high word contains the object ID (traditionally called the
 *          "device type" code).
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_CookDeviceData(PDICB pdcb, DWORD cdod, LPDIDEVICEOBJECTDATA rgdod)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | CreateEffect |
 *
 *          Create an <i IDirectInputEffectDriver> callback.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD * | ppes |
 *
 *          Receives the shepherd for the effect driver.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes)
{
    /*
     *  This may legitimately be called, because it comes from
     *  a client calling a force feedback method.
     */
    *ppes = 0;
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | GetFFConfigKey |
 *
 *          Returns a handle to the registry key which contains
 *          force feedback configuration information.
 *
 *  @parm   DWORD | sam |
 *
 *          Security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives key handle on success.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | SendDeviceData |
 *
 *          Spew some data to the device.
 *
 *  @parm   DWORD | cbdod |
 *
 *          Size of each object.
 *
 *  @parm   IN LPCDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          Number of items actually sent.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 *****************************************************************************/

STDMETHODIMP
CNil_SendDeviceData(PDICB pdcb, DWORD cbdod, LPCDIDEVICEOBJECTDATA rgdod,
                       LPDWORD pdwInOut, DWORD fl)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | Poll |
 *
 *          Poll the device as necessary.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_Poll(PDICB pdcb)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | MapUsage |
 *
 *          Given a usage and usage page (munged into a single
 *          <t DWORD>), find a device object that matches it.
 *
 *  @returns
 *
 *          <c DIERR_NOTINITIALIZED> because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_MapUsage(PDICB pdcb, DWORD dwUsage, PINT piOut)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CNil | GetUsage |
 *
 *          Given an object index, return the usage and usage page,
 *          packed into a single <t DWORD>.
 *
 *  @parm   int | iobj |
 *
 *          Object index to be converted.
 *
 *  @returns
 *
 *          Zero because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP_(DWORD)
CNil_GetUsage(PDICB pdcb, int iobj)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return 0;
}

/****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CNil | SetDIData |
 *
 *          Set DirectInput version from CDIDev *.
 *
 *  @parm   DWORD | dwVer |
 *
 *          DirectInput version
 *
 *  @parm   LPVOID | lpdihacks |
 *
 *          AppHack data
 *
 *  @returns
 *
 *          Zero because we are the canonical
 *          uninitialized device.
 *
 ***************************************************************************/

STDMETHODIMP
CNil_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return 0;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CNil | BuildDefaultActionMap |
 *
 *          Validate the passed action map, blanking out invalid ones.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInst |
 *
 *          Device instance GUID.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> 
 *
 *****************************************************************************/

STDMETHODIMP
CNil_BuildDefaultActionMap
(
    PDICB               pdcb, 
    LPDIACTIONFORMATW   paf, 
    DWORD               dwFlags, 
    REFGUID             guidInst
)
{
    /*
     *  This should never happen; we don't get called until we're sure
     *  it's okay.
     */
    AssertF(0);
    RPF("ERROR: IDirectInputDevice: Not initialized");
    return DIERR_NOTINITIALIZED;
}


/****************************************************************************
 *
 *      Our VTBL for our static object
 *
 ***************************************************************************/

#pragma BEGIN_CONST_DATA

IDirectInputDeviceCallbackVtbl c_vtblNil = {
    CNil_QueryInterface,
    CNil_AddRef,
    CNil_Release,
    CNil_GetInstance,
    CDefDcb_GetVersions,
    CNil_GetDataFormat,
    CNil_GetObjectInfo,
    CNil_GetCapabilities,
    CNil_Acquire,
    CNil_Unacquire,
    CNil_GetDeviceState,
    CNil_GetDeviceInfo,
    CNil_GetProperty,
    CNil_SetProperty,
    CNil_SetEventNotification,
    CNil_SetCooperativeLevel,
    CNil_RunControlPanel,
    CNil_CookDeviceData,
    CNil_CreateEffect,
    CNil_GetFFConfigKey,
    CNil_SendDeviceData,
    CNil_Poll,
    CNil_GetUsage,
    CNil_MapUsage,
    CNil_SetDIData,
    CNil_BuildDefaultActionMap,
};

IDirectInputDeviceCallback c_dcbNil = {
    &c_vtblNil,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\digenk.c ===
/*****************************************************************************
 *
 *  DIGenK.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Generic IDirectInputDevice callback for keyboard.
 *
 *  Contents:
 *
 *      CKbd_CreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      Some holes in windows.h on NT platforms.
 *
 *****************************************************************************/

#ifndef VK_KANA
#define VK_KANA         0x15
#endif

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflKbd

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CKbd_New!
 *
 *****************************************************************************/

Primary_Interface(CKbd, IDirectInputDeviceCallback);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct KBDSTAT |
 *
 *          Internal instantaneous keyboard status information.
 *
 *  @field  BYTE | rgb[DIKBD_CKEYS] |
 *
 *          Array of key states, one for each logical key.
 *
 *****************************************************************************/

typedef struct KBDSTAT {

    BYTE    rgb[DIKBD_CKEYS];

} KBDSTAT, *PKBDSTAT;

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @topic  Special remarks on keyboard scan codes |
 *
 *          There are several aspects of keyboards which applications should
 *          be aware of.  Applications are encouraged to allow users to
 *          reconfigure keyboard action keys to suit the physical keyboard
 *          layout.
 *
 *          For the purposes of this discussion, the baseline keyboard
 *          shall be the US PC Enhanced keyboard.  When a key is described
 *          as "missing", it means that the key is present on the US PC
 *          Enhanced keyboard but not on the keyboard under discussion.
 *          When a key is described as "added", it means that the key is
 *          absent on the US PC Enhanced keyboard but present on the
 *          keyboard under discussion.
 *
 *          Not all PC Enhanced keyboards support the new Windows keys
 *          (DIK_LWIN, DIK_RWIN, and DIK_APPS).  There is no way to
 *          determine whether the keys are physically available.
 *
 *          Note that there is no DIK_PAUSE key code.  The PC Enhanced
 *          keyboard does not generate a separate DIK_PAUSE scan code;
 *          rather, it synthesizes a "Pause" from the DIK_LCONTROL and
 *          DIK_NUMLOCK scan codes.
 *
 *          Keyboards for laptops or other reduced-footprint computers
 *          frequently do not implement a full set of keys.  Instead,
 *          some keys (typically numeric keypad keys) are multiplexed
 *          with other keys, selected by an auxiliary "mode" key which
 *          does not generate a separate scan code.
 *
 *          If the keyboard subtype indicates a PC XT or PC AT keyboard,
 *          then the following keys are not available:
 *          DIK_F11, DIK_F12, and all the extended keys (DIK_* values
 *          greater than or equal to 0x80).  Furthermore, the PC XT
 *          keyboard lacks DIK_SYSRQ.
 *
 *          Japanese keyboards contain a substantially different set of
 *          keys from US keyboards.  The following keyboard scan codes
 *          are not available on Japanese keyboards:
 *          DIK_EQUALS, DIK_APOSTROPHE, DIK_GRAVE, DIK_NUMPADENTER,
 *          DIK_RCONTROL, DIK_RMENU.  Furthermore, most Japanese
 *          keyboards do not support DIK_RSHIFT.  (It is customary
 *          to use DIK_NUMPADEQUAL in place of DIK_RSHIFT.)
 *
 *          Japanese keyboards contain the following additional keys:
 *          DIK_F14, DIK_NUMPADEQUAL, DIK_CIRCUMFLEX, DIK_AT, DIK_COLON,
 *          DIK_UNDERLINE, DIK_XFER, DIK_NFER, DIK_STOP, DIK_KANA, and
 *          DIK_NUMPADCOMMA.
 *
 *          Note that on Japanese keyboards, the DIK_CAPSLOCK and
 *          DIK_KANA keys are toggle buttons and not push buttons.
 *          They generate a down event
 *          when first pressed, then generate an up event when pressed a
 *          second time.
 *          Note that on Windows 2000, the DIK_KANJI key is also treated as a 
 *          toggle.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global KBDTYPE | c_rgktWhich[] |
 *
 *          Array that describes which keyboards support which keys.
 *
 *          The list is optimistic.  If any keyboard of the indicated
 *          type supports the key, then we list it.
 *
 *          Items marks "available for NEC" are keys which are extremely
 *          unlikely to be used in future versions of the Enhanced
 *          keyboard and therefore can be used as ersatz scan codes for
 *          NEC-only keys.
 *
 *          Note:  Kana and CAPSLOCK are toggle buttons on NEC keyboards.
 *          Note:  Kana, Kanji and CAPSLOCK are toggle buttons on all NT JPN 
 *                 keyboards.
 *
 *****************************************************************************/

BYTE g_rgbKbdRMap[DIKBD_CKEYS];

typedef BYTE KBDTYPE;

#define KBDTYPE_XT       0x01       /* Key exists on XT class keyboard */
#define KBDTYPE_AT       0x02       /* Key exists on AT class keyboard */
#define KBDTYPE_ENH      0x04       /* Key exists on Enhanced keyboard */
#define KBDTYPE_NEC      0x08       /* Key exists on NEC keyboard */
#define KBDTYPE_ANYKBD   0x0F       /* Key exists somewhere in the world */

#define KBDTYPE_NECTGL   0x10       /* Is a toggle-key on NEC keyboard */
#define KBDTYPE_NTTGL    0x20       /* Is a toggle-key on an NT FE keyboard */

#pragma BEGIN_CONST_DATA

#define XT      KBDTYPE_XT  |
#define AT      KBDTYPE_XT  |
#define ENH     KBDTYPE_ENH |
#define NEC     KBDTYPE_NEC |
#define NECTGL  KBDTYPE_NECTGL |
#define NTTGL   KBDTYPE_NTTGL |

KBDTYPE c_rgktWhich[] = {

                               0,     /* 0x00 - <undef>  */
    XT AT ENH NEC              0,     /* 0x01 - Esc      */
    XT AT ENH NEC              0,     /* 0x02 - 1        */
    XT AT ENH NEC              0,     /* 0x03 - 2        */
    XT AT ENH NEC              0,     /* 0x04 - 3        */
    XT AT ENH NEC              0,     /* 0x05 - 4        */
    XT AT ENH NEC              0,     /* 0x06 - 5        */
    XT AT ENH NEC              0,     /* 0x07 - 6        */
    XT AT ENH NEC              0,     /* 0x08 - 7        */
    XT AT ENH NEC              0,     /* 0x09 - 8        */
    XT AT ENH NEC              0,     /* 0x0A - 9        */
    XT AT ENH NEC              0,     /* 0x0B - 0        */
    XT AT ENH NEC              0,     /* 0x0C - -        */
    XT AT ENH                  0,     /* 0x0D - =        */
    XT AT ENH NEC              0,     /* 0x0E - BkSp     */
    XT AT ENH NEC              0,     /* 0x0F - Tab      */

    XT AT ENH NEC              0,     /* 0x10 - Q        */
    XT AT ENH NEC              0,     /* 0x11 - W        */
    XT AT ENH NEC              0,     /* 0x12 - E        */
    XT AT ENH NEC              0,     /* 0x13 - R        */
    XT AT ENH NEC              0,     /* 0x14 - T        */
    XT AT ENH NEC              0,     /* 0x15 - Y        */
    XT AT ENH NEC              0,     /* 0x16 - U        */
    XT AT ENH NEC              0,     /* 0x17 - I        */
    XT AT ENH NEC              0,     /* 0x18 - O        */
    XT AT ENH NEC              0,     /* 0x19 - P        */
    XT AT ENH NEC              0,     /* 0x1A - [        */
    XT AT ENH NEC              0,     /* 0x1B - ]        */
    XT AT ENH NEC              0,     /* 0x1C - Enter    */
    XT AT ENH NEC              0,     /* 0x1D - LCtrl    */
    XT AT ENH NEC              0,     /* 0x1E - A        */
    XT AT ENH NEC              0,     /* 0x1F - S        */

    XT AT ENH NEC              0,     /* 0x20 - D        */
    XT AT ENH NEC              0,     /* 0x21 - F        */
    XT AT ENH NEC              0,     /* 0x22 - G        */
    XT AT ENH NEC              0,     /* 0x23 - H        */
    XT AT ENH NEC              0,     /* 0x24 - J        */
    XT AT ENH NEC              0,     /* 0x25 - K        */
    XT AT ENH NEC              0,     /* 0x26 - L        */
    XT AT ENH NEC              0,     /* 0x27 - ;        */
    XT AT ENH                  0,     /* 0x28 - '        */
    XT AT ENH                  0,     /* 0x29 - `        */
    XT AT ENH NEC              0,     /* 0x2A - LShift   */
    XT AT ENH NEC              0,     /* 0x2B - \        */
    XT AT ENH NEC              0,     /* 0x2C - Z        */
    XT AT ENH NEC              0,     /* 0x2D - X        */
    XT AT ENH NEC              0,     /* 0x2E - C        */
    XT AT ENH NEC              0,     /* 0x2F - V        */

    XT AT ENH NEC              0,     /* 0x30 - B        */
    XT AT ENH NEC              0,     /* 0x31 - N        */
    XT AT ENH NEC              0,     /* 0x32 - M        */
    XT AT ENH NEC              0,     /* 0x33 - ,        */
    XT AT ENH NEC              0,     /* 0x34 - .        */
    XT AT ENH NEC              0,     /* 0x35 - /        */
    XT AT ENH NEC              0,     /* 0x36 - RShift   */
    XT AT ENH NEC              0,     /* 0x37 - Num*     */
    XT AT ENH NEC              0,     /* 0x38 - LAlt     */
    XT AT ENH NEC              0,     /* 0x39 - Space    */
    XT AT ENH NEC NECTGL NTTGL 0,     /* 0x3A - CapsLock */
    XT AT ENH NEC              0,     /* 0x3B - F1       */
    XT AT ENH NEC              0,     /* 0x3C - F2       */
    XT AT ENH NEC              0,     /* 0x3D - F3       */
    XT AT ENH NEC              0,     /* 0x3E - F4       */
    XT AT ENH NEC              0,     /* 0x3F - F5       */

    XT AT ENH NEC              0,     /* 0x40 - F6       */
    XT AT ENH NEC              0,     /* 0x41 - F7       */
    XT AT ENH NEC              0,     /* 0x42 - F8       */
    XT AT ENH NEC              0,     /* 0x43 - F9       */
    XT AT ENH NEC              0,     /* 0x44 - F10      */
    XT AT ENH                  0,     /* 0x45 - NumLock  */
    XT AT ENH                  0,     /* 0x46 - ScrLock  */
    XT AT ENH NEC              0,     /* 0x47 - Numpad7  */
    XT AT ENH NEC              0,     /* 0x48 - Numpad8  */
    XT AT ENH NEC              0,     /* 0x49 - Numpad9  */
    XT AT ENH NEC              0,     /* 0x4A - Numpad-  */
    XT AT ENH NEC              0,     /* 0x4B - Numpad4  */
    XT AT ENH NEC              0,     /* 0x4C - Numpad5  */
    XT AT ENH NEC              0,     /* 0x4D - Numpad6  */
    XT AT ENH NEC              0,     /* 0x4E - Numpad+  */
    XT AT ENH NEC              0,     /* 0x4F - Numpad1  */

    XT AT ENH NEC              0,     /* 0x50 - Numpad2  */
    XT AT ENH NEC              0,     /* 0x51 - Numpad3  */
    XT AT ENH NEC              0,     /* 0x52 - Numpad0  */
    XT AT ENH NEC              0,     /* 0x53 - Numpad.  */

                               0,     /* 0x54 - <undef>  */
                               0,     /* 0x55 - <undef>  */
          ENH                  0,     /* 0x56 - <undef>. On UK/Germany keyboards, it is <, > and |. */
          ENH NEC              0,     /* 0x57 - F11      */
          ENH NEC              0,     /* 0x58 - F12      */
                               0,     /* 0x59 - <undef>  */
                               0,     /* 0x5A - <undef>  */
                               0,     /* 0x5B - <undef>  */
                               0,     /* 0x5C - <undef>  */
                               0,     /* 0x5D - <undef>  */
                               0,     /* 0x5E - <undef>  */
                               0,     /* 0x5F - <undef>  */

                               0,     /* 0x60 - <undef>  */
                               0,     /* 0x61 - <undef>  */
                               0,     /* 0x62 - <undef>  */
                               0,     /* 0x63 - <undef>  */
              NEC              0,     /* 0x64 - F13      */
              NEC              0,     /* 0x65 - F14      */
              NEC              0,     /* 0x66 - F15      */
                               0,     /* 0x67 - <undef>  */
                               0,     /* 0x68 - <undef>  */
                               0,     /* 0x69 - <undef>  */
                               0,     /* 0x6A - <undef>  */
                               0,     /* 0x6B - <undef>  */
                               0,     /* 0x6C - <undef>  */
                               0,     /* 0x6D - <undef>  */
                               0,     /* 0x6E - <undef>  */
                               0,     /* 0x6F - <undef>  */

              NEC NECTGL NTTGL 0,     /* 0x70 - Kana     */
                               0,     /* 0x71 - <undef>  */
                               0,     /* 0x72 - <undef>  */
          ENH                  0,     /* 0x73 - <undef>.  On Portugese (Brazilian) keyboard, it is /, ? */
                               0,     /* 0x74 - <undef>  */
                               0,     /* 0x75 - <undef>  */
                               0,     /* 0x76 - <undef>  */
                               0,     /* 0x77 - <undef>  */
                               0,     /* 0x78 - <undef>  */
              NEC              0,     /* 0x79 - Convert  */
                               0,     /* 0x7A - <undef>  */
              NEC              0,     /* 0x7B - Nfer     */
                               0,     /* 0x7C - <undef>  */
              NEC              0,     /* 0x7D - Yen      */
          ENH                  0,     /* 0x7E - <undef>.  On Portugese (Brazilian) keyboard, it is keypad . */
                               0,     /* 0x7F - <undef>  */

                                /* Extended keycodes go here */

                               0,     /* 0x80 - <undef>  */
                               0,     /* 0x81 - <undef>  */
                               0,     /* 0x82 - <undef>  */
                               0,     /* 0x83 - <undef>  */
                               0,     /* 0x84 - <undef>  */
                               0,     /* 0x85 - <undef>  */
                               0,     /* 0x86 - <undef>  */
                               0,     /* 0x87 - <undef>  */
                               0,     /* 0x88 - <undef>  */
                               0,     /* 0x89 - <undef>  */
                               0,     /* 0x8A - <undef>  */
                               0,     /* 0x8B - <undef>  */
                               0,     /* 0x8C - <undef>  */
              NEC              0,     /* 0x8D - Num=     */
                               0,     /* 0x8E - <undef>  */
                               0,     /* 0x8F - <undef>  */

          ENH NEC              0,     /* 0x90 - ^        */ ///Prev Track
              NEC              0,     /* 0x91 - @        */
              NEC              0,     /* 0x92 - :        */
              NEC              0,     /* 0x93 - _        */
              NEC        NTTGL 0,     /* 0x94 - Xfer - AKA Kanji */
              NEC              0,     /* 0x95 - Stop     */
              NEC              0,     /* 0x96 - AX       */
              NEC              0,     /* 0x97 - Unlabel'd*/
                               0,     /* 0x98 - <undef>  */ /* available for NEC */
          ENH                  0,     /* 0x99 - <undef>  */ /* available for NEC */ ///Next Track
                               0,     /* 0x9A - <undef>  */
                               0,     /* 0x9B - <undef>  */
          ENH                  0,     /* 0x9C - NumEnter */
          ENH                  0,     /* 0x9D - RCtrl    */
                               0,     /* 0x9E - <undef>  */ /* available for NEC */
                               0,     /* 0x9F - <undef>  */ /* available for NEC */

          ENH                  0,     /* 0xA0 - <undef>  */ /* available for NEC */ ///Mute
          ENH                  0,     /* 0xA1 - <undef>  */ /* available for NEC */ ///Calculator
          ENH                  0,     /* 0xA2 - <undef>  */ /* available for NEC */ ///Play/Pause
                               0,     /* 0xA3 - <undef>  */ /* available for NEC */
          ENH                  0,     /* 0xA4 - <undef>  */ /* available for NEC */ ///Stop
                               0,     /* 0xA5 - <undef>  */ /* available for NEC */
                               0,     /* 0xA6 - <undef>  */ /* available for NEC */
                               0,     /* 0xA7 - <undef>  */
                               0,     /* 0xA8 - <undef>  */
                               0,     /* 0xA9 - <undef>  */
                               0,     /* 0xAA - <undef>  */
                               0,     /* 0xAB - <undef>  */
                               0,     /* 0xAC - <undef>  */ /* available for NEC */
                               0,     /* 0xAD - <undef>  */ /* available for NEC */
          ENH                  0,     /* 0xAE - <undef>  */ /* available for NEC */ ///Volume -
                               0,     /* 0xAF - <undef>  */ /* available for NEC */

          ENH                  0,     /* 0xB0 - <undef>  */ /* available for NEC */ ///Volume +
                               0,     /* 0xB1 - <undef>  */ /* available for NEC */
          ENH                  0,     /* 0xB2 - <undef>  */ /* available for NEC */ ///Web/Home
              NEC              0,     /* 0xB3 - Num,     */
                               0,     /* 0xB4 - <undef>  */
          ENH NEC              0,     /* 0xB5 - Num/     */
                               0,     /* 0xB6 - <undef>  */
       AT ENH NEC              0,     /* 0xB7 - SysRq    */
          ENH                  0,     /* 0xB8 - RAlt     */
                               0,     /* 0xB9 - <undef>  */
                               0,     /* 0xBA - <undef>  */
                               0,     /* 0xBB - <undef>  */
                               0,     /* 0xBC - <undef>  */
                               0,     /* 0xBD - <undef>  */
                               0,     /* 0xBE - <undef>  */
                               0,     /* 0xBF - <undef>  */

                               0,     /* 0xC0 - <undef>  */
                               0,     /* 0xC1 - <undef>  */
                               0,     /* 0xC2 - <undef>  */
                               0,     /* 0xC3 - <undef>  */
                               0,     /* 0xC4 - <undef>  */
          ENH                  0,     /* 0xC5 - Pause    */
                               0,     /* 0xC6 - <undef>  */
          ENH NEC              0,     /* 0xC7 - Home     */
          ENH NEC              0,     /* 0xC8 - UpArrow  */
          ENH NEC              0,     /* 0xC9 - PgUp     */
                               0,     /* 0xCA - <undef>  */
          ENH NEC              0,     /* 0xCB - LtArrow  */
                               0,     /* 0xCC - <undef>  */
          ENH NEC              0,     /* 0xCD - RtArrow  */
                               0,     /* 0xCE - <undef>  */
          ENH NEC              0,     /* 0xCF - End      */

          ENH NEC              0,     /* 0xD0 - DnArrow  */
          ENH NEC              0,     /* 0xD1 - PgDn     */
          ENH NEC              0,     /* 0xD2 - Insert   */
          ENH NEC              0,     /* 0xD3 - Delete   */
                               0,     /* 0xD4 - <undef>  */
                               0,     /* 0xD5 - <undef>  */
                               0,     /* 0xD6 - <undef>  */
                               0,     /* 0xD7 - <undef>  */
                               0,     /* 0xD8 - <undef>  */
                               0,     /* 0xD9 - <undef>  */
                               0,     /* 0xDA - <undef>  */
          ENH NEC              0,     /* 0xDB - LWin     */
          ENH NEC              0,     /* 0xDC - RWin     */
          ENH NEC              0,     /* 0xDD - AppMenu  */
          ENH                  0,     /* 0xDE - Power    */
          ENH                  0,     /* 0xDF - Sleep    */

                               0,     /* 0xE0 - <undef>  */
                               0,     /* 0xE1 - <undef>  */
                               0,     /* 0xE2 - <undef>  */
          ENH                  0,     /* 0xE3 - Wake     */
                               0,     /* 0xE4 - <undef>  */
          ENH                  0,     /* 0xE5 - <undef>  */ ///Search
          ENH                  0,     /* 0xE6 - <undef>  */ ///Favorites
          ENH                  0,     /* 0xE7 - <undef>  */ ///Refresh
          ENH                  0,     /* 0xE8 - <undef>  */ ///Stop
          ENH                  0,     /* 0xE9 - <undef>  */ ///Forward
          ENH                  0,     /* 0xEA - <undef>  */ ///Back
          ENH                  0,     /* 0xEB - <undef>  */ ///My Computer
          ENH                  0,     /* 0xEC - <undef>  */ ///Mail
          ENH                  0,     /* 0xED - <undef>  */ ///Media
                               0,     /* 0xEE - <undef>  */
                               0,     /* 0xEF - <undef>  */

                               0,     /* 0xF0 - <undef>  */
                               0,     /* 0xF1 - <undef>  */
                               0,     /* 0xF2 - <undef>  */
                               0,     /* 0xF3 - <undef>  */
                               0,     /* 0xF4 - <undef>  */
                               0,     /* 0xF5 - <undef>  */
                               0,     /* 0xF6 - <undef>  */
                               0,     /* 0xF7 - <undef>  */
                               0,     /* 0xF8 - <undef>  */
                               0,     /* 0xF9 - <undef>  */
                               0,     /* 0xFA - <undef>  */
                               0,     /* 0xFB - <undef>  */
                               0,     /* 0xFC - <undef>  */
                               0,     /* 0xFD - <undef>  */
                               0,     /* 0xFE - <undef>  */
                               0,     /* 0xFF - <undef>  */

};

#undef  XT
#undef  AT
#undef  ENH
#undef  NEC

#if 0
DWORD dwSpecKeys[] = {0x56, 0x64, 0x65, 0x66, 0x73, 0x7e, 0x90, 0x99, 
                      0xa0, 0xa1, 0xa2, 0xa4, 0xae, 0xb0, 0xb2, 0xde, 
                      0xdf, 0xe3, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 
                      0xeb, 0xec, 0xed };
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CKbd |
 *
 *          The <i IDirectInputDeviceCallback> object for the
 *          generic keyboard.
 *
 *  @field  IDirectInputDeviceCalllback | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  PMKBDSTAT | pksPhys |
 *
 *          Pointer to physical keyboard status information kept down in the
 *          VxD.
 *
 *  @field  VXDINSTANCE * | pvi |
 *
 *          The DirectInput instance handle.
 *
 *  @field  DWORD | dwKbdType |
 *
 *          The device subtype for this keyboard.
 *
 *  @field  DWORD | flEmulation |
 *
 *          The emulation flags forced by the application.  If any of
 *          these flags is set (actually, at most one will be set), then
 *          we are an alias device.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          The dynamically-generated data format based on the
 *          keyboard type.
 *
 *  @field  DIOBJECTDATAFORMAT | rgodf[] |
 *
 *          Object data format table generated as part of the
 *          <e CKbd.df>.
 *
 *  @comm
 *
 *          It is the caller's responsibility to serialize access as
 *          necessary.
 *
 *****************************************************************************/

typedef struct CKbd {

    /* Supported interfaces */
    IDirectInputDeviceCallback dcb;

    PKBDSTAT pksPhys;

    VXDINSTANCE *pvi;

    DWORD dwKbdType;
    DWORD flEmulation;

    DIDATAFORMAT df;
    DIOBJECTDATAFORMAT rgodf[DIKBD_CKEYS];

} CKbd, DK, *PDK;

#define ThisClass CKbd
#define ThisInterface IDirectInputDeviceCallback
#define riidExpected &IID_IDirectInputDeviceCallback

/*****************************************************************************
 *
 *      CKbd::QueryInterface      (from IUnknown)
 *      CKbd::AddRef              (from IUnknown)
 *      CKbd::Release             (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CKbd)
Default_AddRef(CKbd)
Default_Release(CKbd)

#else

#define CKbd_QueryInterface   Common_QueryInterface
#define CKbd_AddRef           Common_AddRef
#define CKbd_Release          Common_Release

#endif

#define CKbd_QIHelper         Common_QIHelper
#define CKbd_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CKbd_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CKbd_Finalize(PV pvObj)
{
    PDK this = pvObj;

    if (this->pvi) {
        HRESULT hres;
        hres = Hel_DestroyInstance(this->pvi);
        AssertF(SUCCEEDED(hres));
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | WrappedGetKeyboardType |
 *
 *          GetKeyboardType but wrapped in DEBUG for registry overrides.
 *
 *  @parm   int  | nTypeFlag |
 *
 *          Which data to return.  Only 0, 1 and 2 are supported
 *
 *  @returns
 *
 *          int value requested
 *
 *****************************************************************************/

#ifndef DEBUG
  #ifdef USE_WM_INPUT
    #define WrappedGetKeyboardType(x) DIRaw_GetKeyboardType(x)
  #else
    #define WrappedGetKeyboardType(x) GetKeyboardType(x)
  #endif
#else
int INTERNAL WrappedGetKeyboardType
( 
    int nTypeFlag 
)
{
    TCHAR ValueName[2];
    int TypeRes;

  #ifdef USE_WM_INPUT
    TypeRes = DIRaw_GetKeyboardType( nTypeFlag );
  #else
    TypeRes = GetKeyboardType( nTypeFlag );
  #endif

    if( nTypeFlag < 10 )
    {
        ValueName[0] = TEXT( '0' ) + nTypeFlag;
        ValueName[1] = TEXT( '\0' );
        
        TypeRes = (int)RegQueryDIDword( REGSTR_KEY_KEYBTYPE, ValueName, (DWORD)TypeRes );

        SquirtSqflPtszV(sqfl | sqflTrace, 
            TEXT( "DINPUT: GetKeyboardType(%d) returning 0x%08x" ),
            nTypeFlag, TypeRes );
    }
    else
    {
        RPF( "Somebody is passing %d to WrappedGetKeyboardType", nTypeFlag );
    }

    return TypeRes;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | Acquire |
 *
 *          Tell the device driver to begin data acquisition.
 *
 *          It is the caller's responsibility to have set the
 *          data format before obtaining acquisition.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_Acquire(PDICB pdcb)
{
    VXDDWORDDATA vdd;
    PDK this;
    HRESULT hres;

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  Propagate the state of the potential toggle keys down to
     *  the VxD.  This also alerts the VxD that acquisition is coming,
     *  so it can reset the state tables if necessary.
     */
    vdd.pvi = this->pvi;
    vdd.dw = 0;
    if( WrappedGetKeyboardType(0) == 7 )
    {
        /*
         *  Let the keyboard driver know that this is an FE keyboard
         */
        vdd.dw |= 16;

        if (GetAsyncKeyState(VK_KANA) < 0) {
            vdd.dw |= 1;
        }
        if (GetAsyncKeyState(VK_CAPITAL) < 0) {
            vdd.dw |= 2;
        }
        if (GetAsyncKeyState(VK_KANJI) < 0) {
            vdd.dw |= 8;
        }
    }

    if( this->pvi->fl & VIFL_CAPTURED )
    {
        vdd.dw |= 4;        // Tell the keyboard driver to pre-acquire hooks
    }

    hres = Hel_Kbd_InitKeys(&vdd);
    
    if( this->pvi->fl & VIFL_CAPTURED )
    {
        /*
         *  A bit of work needs to be done at ring 3 now.
         *  Try to clear any key that is set.  Start with VK_BACK as mouse 
         *  buttons and undefined things go before.
         *  This still covers a lot of undefined VKs but we're less likely 
         *  to do damage clearing something that was undefined than leaving 
         *  keys uncleared.
         */
        BYTE vk;
        for( vk=VK_BACK; vk<VK_OEM_CLEAR; vk++ )
        {
            if( ( vk == VK_KANA ) || ( vk == VK_KANJI ) || ( vk == VK_CAPITAL ) )
            {
                continue;
            }
            if(GetAsyncKeyState(vk) < 0)
            {
                keybd_event( vk, 0, KEYEVENTF_KEYUP, 0 );
            }
        }
    }

    return S_FALSE;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetInstance |
 *
 *          Obtains the DirectInput instance handle.
 *
 *  @parm   OUT PPV | ppvi |
 *
 *          Receives the instance handle.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetInstance(PDICB pdcb, PPV ppvi)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetInstance, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    *ppvi = (PV)this->pvi;
    hres = S_OK;

    ExitOleProcPpvR(ppvi);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetDataFormat |
 *
 *          Obtains the device's preferred data format.
 *
 *  @parm   OUT LPDIDEVICEFORMAT * | ppdf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdf)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetDataFormat,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppdf = &this->df;
    hres = S_OK;

    ExitOleProcPpvR(ppdf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetDeviceInfo |
 *
 *          Obtain general information about the device.
 *
 *  @parm   OUT LPDIDEVICEINSTANCEW | pdiW |
 *
 *          <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *          Secret convenience:  <e DEVICEINSTANCE.guidProduct> is equal
 *          to <e DEVICEINSTANCE.guidInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW pdiW)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetDeviceInfo,
               (_ "pp", pdcb, pdiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEINSTANCEW(pdiW->dwSize));

    AssertF(IsEqualGUID(&GUID_SysKeyboard   , &pdiW->guidInstance) ||
            IsEqualGUID(&GUID_SysKeyboardEm , &pdiW->guidInstance) ||
            IsEqualGUID(&GUID_SysKeyboardEm2, &pdiW->guidInstance));

    pdiW->guidProduct = GUID_SysKeyboard;

    pdiW->dwDevType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_KEYBOARD,
                                         this->dwKbdType);


    LoadStringW(g_hinst, IDS_STDKEYBOARD, pdiW->tszProductName, cA(pdiW->tszProductName));
    LoadStringW(g_hinst, IDS_STDKEYBOARD, pdiW->tszInstanceName, cA(pdiW->tszInstanceName));

    hres = S_OK;

    ExitOleProcR();
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetProperty |
 *
 *          Retrieve a device property.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c S_OK> if the operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres = E_NOTIMPL;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    switch((DWORD)(UINT_PTR)(ppropi->pguid))
    {
        case (DWORD)(UINT_PTR)(DIPROP_KEYNAME):
        {
            LPDIPROPSTRING pdipstr = (PV)pdiph;

            memset( pdipstr->wsz, 0, cbX(pdipstr->wsz) );
            hres = DIGetKeyNameText( ppropi->iobj, ppropi->dwDevType, pdipstr->wsz, cA(pdipstr->wsz) );
        }
        break;

        case (DWORD)(UINT_PTR)(DIPROP_SCANCODE):
        {
            LPDIPROPDWORD pdipdw = (PV)pdiph;
            DWORD dwCode;

            AssertF( ppropi->iobj < this->df.dwNumObjs );
            AssertF( ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType );

            dwCode = (DWORD)g_rgbKbdRMap[ppropi->iobj];
            
            if( dwCode == 0xC5 ) {
                dwCode = 0x451DE1;
            } else if( dwCode & 0x80 ) {
                dwCode = ((dwCode & 0x7F) << 8) | 0xE0;
            }
            pdipdw->dwData = dwCode;
            
            hres = S_OK;
        }
        break;

        default:
            SquirtSqflPtszV(sqflKbd | sqflBenign ,
                            TEXT("CKbd_GetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                            ppropi->iobj, ppropi->pguid);

            break;
    }


    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CKbd | GetCapabilities |
 *
 *          Get keyboard device capabilities.
 *
 *  @parm   LPDIDEVCAPS | pdc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdc)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetCapabilities,
               (_ "pp", pdcb, pdc));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    pdc->dwDevType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_KEYBOARD,
                                        this->dwKbdType);
    pdc->dwFlags = DIDC_ATTACHED;
    if (this->flEmulation) {
        pdc->dwFlags |= DIDC_ALIAS;
    }

    AssertF(pdc->dwAxes == 0);
    AssertF(pdc->dwPOVs == 0);
    pdc->dwButtons = this->df.dwNumObjs;
    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CKbd | GetPhysicalState |
 *
 *          Read the physical keyboard state into <p pksOut>.
 *
 *          Note that it doesn't matter if this is not atomic.
 *          If a key goes down or up while we are reading it,
 *          we will get a mix of old and new data.  No big deal.
 *
 *  @parm   PDK | this |
 *
 *          The object in question.
 *
 *  @parm   PKBDSTATE | pksOut |
 *
 *          Where to put the keyboard state.
 *  @returns
 *          None.
 *
 *****************************************************************************/

void INLINE
CKbd_GetPhysicalState(PDK this, PKBDSTAT pksOut)
{
    AssertF(this->pksPhys);
    *pksOut = *this->pksPhys;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetDeviceState |
 *
 *          Obtains the state of the keyboard device.
 *
 *          It is the caller's responsibility to have validated all the
 *          parameters and ensure that the device has been acquired.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Keyboard data in the preferred data format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetDeviceState(PDICB pdcb, LPVOID pvData)
{
    HRESULT hres;
    PDK this;
    PKBDSTAT pkstOut = pvData;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetDeviceState,
               (_ "pp", pdcb, pvData));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  ISSUE-2001/03/29-timgill older apps may need compat behaviour
     *  We never used to check whether or not the device was still 
     *  acquired since without exclusive mode there would be no reason for 
     *  the device not to be.  
     *  To keep behavior the same for older apps it might be better to 
     *  only fail if VIFL_CAPTURED is not set but just checking VIFL_ACQUIRED 
     *  is good enough for now, maybe for ever.
     */
//    if( !(this->pvi->fl & VIFL_CAPTURED) 
//      || (this->pvi->fl & VIFL_ACQUIRED) )
    if( this->pvi->fl & VIFL_ACQUIRED )
    {
        CKbd_GetPhysicalState(this, pkstOut);
        hres = S_OK;
    } else {
        RPF( "Keyboard VxD flags: 0x%08x", this->pvi->fl );
        hres = DIERR_INPUTLOST;
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | GetObjectInfo |
 *
 *          Obtain the friendly name of an object, passwed by index
 *          into the preferred data format.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          fields have already been filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                               LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres = S_OK;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::GetObjectInfo,
               (_ "pxp", pdcb, ppropi->iobj, pdidoiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEW(pdidoiW->dwSize));

    if (ppropi->iobj < this->df.dwNumObjs) {
        AssertF(this->rgodf == this->df.rgodf);
        AssertF(ppropi->dwDevType == this->rgodf[ppropi->iobj].dwType);
        AssertF(ppropi->dwDevType & DIDFT_BUTTON);

#if 0
        /*
         * We keep using this code only to make it consistent with old code, 
         * otherwise we would use the new code.
         * Someday, we may change to use the new code. It is more accurate,
         * especially for Japanese Keyboard, and for future devices.
         */
        LoadStringW(g_hinst,
                    IDS_KEYBOARDOBJECT +
                    DIDFT_GETINSTANCE(ppropi->dwDevType),
                    pdidoiW->tszName, cA(pdidoiW->tszName));
#else
        {
            memset( pdidoiW->tszName, 0, cbX(pdidoiW->tszName) );
            hres = DIGetKeyNameText(ppropi->iobj, ppropi->dwDevType, pdidoiW->tszName, cA(pdidoiW->tszName) );
        }
#endif
    } else {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | SetCooperativeLevel |
 *
 *          Notify the device of the cooperative level.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.  We do not support exclusive access.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);

    AssertF(DIGETEMFL(this->pvi->fl) == 0 ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_KBD ||
            DIGETEMFL(this->pvi->fl) == DIEMFL_KBD2);

    /*
     *  We don't allow background exclusive access.
     *  This is actually not a real problem to support; we just don't feel like it
     *  because it's too dangerous.
     */
    if (!(this->pvi->fl & DIMAKEEMFL(DIEMFL_KBD2))) {

        if (dwFlags & DISCL_EXCLUSIVE) {
            if (dwFlags & DISCL_FOREGROUND) {
                this->pvi->fl |= VIFL_CAPTURED;
                this->pvi->fl |= VIFL_NOWINKEY;
                hres = S_OK;
            } else {                /* Disallow exclusive background */
                hres = E_NOTIMPL;
            }
        } else {
            this->pvi->fl &= ~VIFL_CAPTURED;
            this->pvi->fl &= ~VIFL_NOWINKEY;
            hres = S_OK;

            if (dwFlags & DISCL_NOWINKEY) {
                if (dwFlags & DISCL_FOREGROUND) {
                    this->pvi->fl |= VIFL_NOWINKEY;
                } else {
                    RPF("Kbd::SetCooperativeLevel: NOWINKEY not supported in Backgroud mode.");
                    hres = E_NOTIMPL;
                }
            }
        }
    } else {

        /*
         *  Emulation level 2 does not support background access.
         */

        if ((this->pvi->fl & DIMAKEEMFL(DIEMFL_KBD2)) &&
            (dwFlags & DISCL_BACKGROUND)) {
            hres = E_NOTIMPL;
        } else {
            this->pvi->fl &= ~VIFL_NOWINKEY;
            hres = S_OK;

            if (dwFlags & DISCL_NOWINKEY) {
                if (dwFlags & DISCL_FOREGROUND) {
                    this->pvi->fl |= VIFL_NOWINKEY;
                } else {
                    RPF("Kbd::SetCooperativeLevel: NOWINKEY not supported in Backgroud mode.");
                    hres = E_NOTIMPL;
                }
            }
        }
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | RunControlPanel |
 *
 *          Run the keyboard control panel.
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          The owner window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszKeyboard[] = TEXT("keyboard");

#pragma END_CONST_DATA

STDMETHODIMP
CKbd_RunControlPanel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PDK this;
    EnterProcI(IDirectInputDeviceCallback::Kbd::RunControlPanel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = hresRunControlPanel(c_tszKeyboard);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | BuildDefaultActionMap |
 *
 *          Validate the passed action map, blanking out invalid ones.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInst |
 *
 *          Device instance GUID.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> 
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_BuildDefaultActionMap
(
    PDICB               pdcb, 
    LPDIACTIONFORMATW   paf, 
    DWORD               dwFlags, 
    REFGUID             guidInst
)
{
    HRESULT hres;
    PDK this;

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    EnterProcI(IDirectInputDeviceCallback::CKbd::BuildDefaultActionMap, 
        (_ "ppxG", pdcb, paf, dwFlags, guidInst));

    this = _thisPvNm(pdcb, dcb);

    hres = CMap_BuildDefaultSysActionMap ( paf, dwFlags, DIPHYSICAL_KEYBOARD, 
        guidInst, &this->df, 0 /* Mouse button instance, ignored for kbds */ );

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CKbd | InitJapanese |
 *
 *          Initialize the Japanese keyboard goo.
 *
 *          Annoying quirk!  On Windows 95, Japanese keyboards generate
 *          their own scan codes.  But on Windows NT, they generate
 *          "nearly AT-compatible" scan codes.
 *
 *  @returns
 *
 *          KBDTYPE_ANYKBD or KBDTYPE_ANYKBD + KBDTYPE_NECTGL.
 *
 *****************************************************************************/

DWORD INTERNAL
CKbd_InitJapanese(PDK this, PVXDDEVICEFORMAT pdevf)
{
    DWORD dwSubType;
    UINT idKbd;
    DWORD dwRc;

#ifdef WINNT
#define WIN9X_RC( rc ) 
#else
#define WIN9X_RC( rc ) dwRc = ( rc )
#endif
    dwSubType = WrappedGetKeyboardType(1);
    if (HIBYTE(dwSubType) == 0x0D) {    /* NEC PC98 series */

        switch (LOBYTE(dwSubType)) {
        case 1:
        default:
            idKbd = IDDATA_KBD_NEC98;
            this->dwKbdType = DI8DEVTYPEKEYBOARD_NEC98;
            WIN9X_RC( KBDTYPE_ANYKBD + KBDTYPE_NECTGL );
            break;

        case 4:
            idKbd = IDDATA_KBD_NEC98LAPTOP;
            this->dwKbdType = DI8DEVTYPEKEYBOARD_NEC98LAPTOP;
            WIN9X_RC( KBDTYPE_ANYKBD + KBDTYPE_NECTGL );
            break;

        case 5:
            idKbd = IDDATA_KBD_NEC98_106;
            this->dwKbdType = DI8DEVTYPEKEYBOARD_NEC98106;
            WIN9X_RC( KBDTYPE_ANYKBD + KBDTYPE_NECTGL );
            break;
        }

        /*
         *  If the scan code for ESC is 1, then we're on an
         *  NEC98 keyboard that acts AT-like.
         */

        CAssertF(IDDATA_KBD_NEC98_NT - IDDATA_KBD_NEC98 ==
                 IDDATA_KBD_NEC98LAPTOP_NT - IDDATA_KBD_NEC98LAPTOP);
        CAssertF(IDDATA_KBD_NEC98_NT - IDDATA_KBD_NEC98 ==
                 IDDATA_KBD_NEC98_106_NT - IDDATA_KBD_NEC98_106);

        if (MapVirtualKey(VK_ESCAPE, 0) == DIK_ESCAPE) {
            idKbd += IDDATA_KBD_NEC98_NT - IDDATA_KBD_NEC98;
        }

    } else {

        switch (dwSubType) {
        case 0:
            this->dwKbdType = DI8DEVTYPEKEYBOARD_PCENH;
            dwRc = KBDTYPE_ENH;
            goto done;                      /* Yuck */

        case 1:
            idKbd = IDDATA_KBD_JAPANAX;
            this->dwKbdType = DI8DEVTYPEKEYBOARD_JAPANAX;
            WIN9X_RC( KBDTYPE_ANYKBD );
            break;

        case 13:
        case 14:
        case 15:
            idKbd = IDDATA_KBD_J3100;
            this->dwKbdType = DI8DEVTYPEKEYBOARD_J3100;
            WIN9X_RC( KBDTYPE_ANYKBD );
            break;

        case 4:             /* Rumored to be Epson */
        case 5:             /* Rumored to be Fujitsu */
        case 7:             /* Rumored to be IBMJ */
        case 10:            /* Rumored to be Matsushita */
        case 18:            /* Rumored to be Toshiba */
        default:
            idKbd = IDDATA_KBD_JAPAN106;
            this->dwKbdType = DI8DEVTYPEKEYBOARD_JAPAN106;
            WIN9X_RC( KBDTYPE_ANYKBD );
            break;
        }
    }

#undef WIN9X_RC

#ifdef WINNT
    /*
         *  ISSUE-2001/03/29-timgill Japanese keyboard assumption needs testing
         *  All Japanese keyboards on NT have toggle keys
         *  Except subtype zero? Needs test
     */
    dwRc = KBDTYPE_ANYKBD + KBDTYPE_NTTGL;
#endif

    /*
     *  Now load up the translation table goo.
     */
    pdevf->dwExtra = (DWORD)(UINT_PTR)pvFindResource(g_hinst, idKbd, RT_RCDATA);
    if (pdevf->dwExtra == 0) {
        dwRc = 0;
    }

done:;
    return dwRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CKbd | Init |
 *
 *          Initialize the object by establishing the data format
 *          based on the keyboard type.  Anything we don't recognize,
 *          we treat as a PC Enhanced keyboard.
 *
 *  @parm   REFGUID | rguid |
 *
 *          The instance GUID we are being asked to create.
 *
 *****************************************************************************/

HRESULT INTERNAL
CKbd_Init(PDK this, REFGUID rguid)
{
    DWORD dwDevType;
    UINT ib;
    HRESULT hres;
    VXDDEVICEFORMAT devf;
    EnterProc(CKbd_Init, (_ "pG", this, rguid));

#ifdef DEBUG
    /*
     *  Check that the Japan tables aren't messed up.
     */
    {
        UINT idk;

        for (idk = IDDATA_KBD_NEC98; idk <= IDDATA_KBD_J3100; idk++) {
            BYTE rgb[DIKBD_CKEYS];
            HANDLE hrsrc;
            LPBYTE pb;
            ZeroX(rgb);

            /*
             *  Make sure the table exists.
             */
            hrsrc = FindResource(g_hinst, (LPTSTR)(LONG_PTR)(idk), RT_RCDATA);
            AssertF(hrsrc);
            pb = LoadResource(g_hinst, hrsrc);

            /*
             *  Walk the table and make sure each thing that exists
             *  in the translation table also exists in our master table.
             *  Also make sure that it isn't a dup with something else
             *  in the same table.
             */

            /*
             *  Note, however, that the JAPAN106 keyboard contains
             *  dups so we can save having to write an entire
             *  translation table.  And then NEC98_NT tables contain
             *  lots of dups out of sheer laziness.
             */

            for (ib = 0; ib < DIKBD_CKEYS; ib++) {
                if (pb[ib]) {
                    AssertF(c_rgktWhich[pb[ib]] & KBDTYPE_ANYKBD);
                    AssertF(fLorFF(idk == IDDATA_KBD_JAPAN106 && ib == 0x73,
                                   rgb[pb[ib]] == 0));
                    rgb[pb[ib]] = 1;
                }
            }
        }
    }
#endif

    this->df.dwSize = cbX(DIDATAFORMAT);
    this->df.dwObjSize = cbX(DIOBJECTDATAFORMAT);
    this->df.dwDataSize = sizeof(KBDSTAT);
    this->df.rgodf = this->rgodf;

    this->dwKbdType = WrappedGetKeyboardType(0);

    /*
     *  Create the object with the most optimistic data format.
     *  This allows apps to access new keys without having to rev DINPUT.
     *
     *  However, leave out the following scan codes because some keyboards
     *  generate them spuriously:
     *
     *  0xB6
     *
     *      If you hold the right shift key and then press an
     *      extended arrow key, then release both, some keyboards
     *      generate the following:
     *
     *          0x36        - right shift down
     *          0xE0 0xB6   - extended right shift up (?)
     *          0xE0 0x4B   - extended left arrow down
     *          0xE0 0xCB   - extended left arrow up
     *          0xE0 0x36   - extended right shift down (?)
     *          0xE6        - right shift up
     *
     *      The stray 0xE0 0x36 needs to be ignored.
     *
     *  0xAA
     *
     *      Same as 0xB6, but with the left shift key.
     *
     *
     */
    for (ib = 0; ib < DIKBD_CKEYS; ib++) {
        if (ib != 0xAA && ib != 0xB6) {
            this->rgodf[ib].pguid = &GUID_Key;
            this->rgodf[ib].dwOfs = ib;
            this->rgodf[ib].dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE(ib);
            AssertF(this->rgodf[ib].dwFlags == 0);
        }
    }
    devf.cObj = DIKBD_CKEYS;

    devf.cbData = cbX(KBDSTAT);
    devf.rgodf = this->rgodf;

    /*
     *  But first a word from our sponsor:  Figure out if this keyboard
     *  needs a translation table.
     */

    devf.dwExtra = 0;               /* Assume no translation */
    if (this->dwKbdType != 7) {     /* Not a yucky Japanese keyboard */
        switch (this->dwKbdType) {
        case DI8DEVTYPEKEYBOARD_PCXT:  dwDevType = KBDTYPE_XT;  break;
        case DI8DEVTYPEKEYBOARD_PCAT:  dwDevType = KBDTYPE_AT;  break;
        default:
        case DI8DEVTYPEKEYBOARD_PCENH: dwDevType = KBDTYPE_ENH; break;
        }
    } else {                        /* Yucky Japanese keyboard */
        dwDevType = CKbd_InitJapanese(this, &devf);
        if (!dwDevType) {
            goto justfail;
        }
    }

    /*
     *  And now a word from our other sponsor:  Figure out the
     *  emulation flags based on the GUID.
     */

    AssertF(GUID_SysKeyboard   .Data1 == 0x6F1D2B61);
    AssertF(GUID_SysKeyboardEm .Data1 == 0x6F1D2B82);
    AssertF(GUID_SysKeyboardEm2.Data1 == 0x6F1D2B83);

    switch (rguid->Data1) {

    default:
    case 0x6F1D2B61:
        AssertF(IsEqualGUID(rguid, &GUID_SysKeyboard));
        AssertF(this->flEmulation == 0);
        break;

    case 0x6F1D2B82:
        AssertF(IsEqualGUID(rguid, &GUID_SysKeyboardEm));
        this->flEmulation = DIEMFL_KBD;
        break;

    case 0x6F1D2B83:
        AssertF(IsEqualGUID(rguid, &GUID_SysKeyboardEm2));
        this->flEmulation = DIEMFL_KBD2;
        break;

    }

    devf.dwEmulation = this->flEmulation;

    hres = Hel_Kbd_CreateInstance(&devf, &this->pvi);
    if (SUCCEEDED(hres)) {
        UINT cobj;
        BYTE rgbSeen[DIKBD_CKEYS];
        AssertF(this->pvi);
        AssertF(this->df.dwFlags == 0);
        AssertF(this->df.dwNumObjs == 0);

        /*
         *  Japanese keyboards have many-to-one mappings, so
         *  we need to filter out the dups or we end up in big
         *  trouble.
         */
        ZeroX(rgbSeen);

        /*
         *  Now create the real data format.
         *
         *  We shadow this->df.dwNumObjs in cobj so that the compiler
         *  can enregister it.
         *
         *  Note that we filter through the translation table if there
         *  is one.
         */

        cobj = 0;
        for (ib = 0; ib < DIKBD_CKEYS; ib++) {
            BYTE bScan = devf.dwExtra ? ((LPBYTE)devf.dwExtra)[ib] : ib;
            if ((c_rgktWhich[bScan] & dwDevType) && !rgbSeen[bScan]) {
                PODF podf = &this->rgodf[cobj];
                rgbSeen[bScan] = 1;
                podf->pguid = &GUID_Key;
                podf->dwOfs = bScan;

                /*
                 * To make a mapping talbe for original scan code from DIK_* code.
                 */
                g_rgbKbdRMap[cobj] = (BYTE) ib;
                if( dwDevType == KBDTYPE_ENH ) {  //how about Japanese KBD?
                    if( ib == 0x45 || ib == 0xC5) {
                        g_rgbKbdRMap[cobj] = (ib & 0x7F) | (ib ^ 0x80);
                    }
                }

                if (c_rgktWhich[bScan] & dwDevType & (KBDTYPE_NECTGL|KBDTYPE_NTTGL) ) {
                    podf->dwType = DIDFT_TGLBUTTON | DIDFT_MAKEINSTANCE(bScan);
                } else {
                    podf->dwType = DIDFT_PSHBUTTON | DIDFT_MAKEINSTANCE(bScan);
                }
                AssertF(podf->dwFlags == 0);
                cobj++;
                this->df.dwNumObjs++;
            }
        }

        this->pksPhys = this->pvi->pState;

    } else {
    justfail:;
        hres = E_FAIL;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *      CKbd_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
CKbd_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Kbd::<constructor>,
               (_ "Gp", riid, ppvObj));

    AssertF(IsEqualGUID(rguid, &GUID_SysKeyboard) ||
            IsEqualGUID(rguid, &GUID_SysKeyboardEm) ||
            IsEqualGUID(rguid, &GUID_SysKeyboardEm2));

    hres = Common_NewRiid(CKbd, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv in case of aggregation */
        PDK this = _thisPv(*ppvObj);

        if (SUCCEEDED(hres = CKbd_Init(this, rguid))) {
        } else {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CKbd_Signature        0x2044424B      /* "KBD " */

Interface_Template_Begin(CKbd)
    Primary_Interface_Template(CKbd, IDirectInputDeviceCallback)
Interface_Template_End(CKbd)

Primary_Interface_Begin(CKbd, IDirectInputDeviceCallback)
    CKbd_GetInstance,
    CDefDcb_GetVersions,
    CKbd_GetDataFormat,
    CKbd_GetObjectInfo,
    CKbd_GetCapabilities,
    CKbd_Acquire,
    CDefDcb_Unacquire,
    CKbd_GetDeviceState,
    CKbd_GetDeviceInfo,
    CKbd_GetProperty,
    CDefDcb_SetProperty,
    CDefDcb_SetEventNotification,
    CKbd_SetCooperativeLevel,
    CKbd_RunControlPanel,
    CDefDcb_CookDeviceData,
    CDefDcb_CreateEffect,
    CDefDcb_GetFFConfigKey,
    CDefDcb_SendDeviceData,
    CDefDcb_Poll,
    CDefDcb_GetUsage,
    CDefDcb_MapUsage,
    CDefDcb_SetDIData,
    CKbd_BuildDefaultActionMap,
Primary_Interface_End(CKbd, IDirectInputDeviceCallback)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diguid.c ===
/*****************************************************************************
 *
 *  DIGuid.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Misc GUID-related helper functions.
 *
 *  Contents:
 *
 *      DICreateGuid
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflUtil


/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

typedef void (__stdcall *UUIDCREATE)(OUT LPGUID pguid);

UUIDCREATE g_UuidCreate;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | FakeUuidCreate |
 *
 *          Create a GUID using a fake algorithm that is close enough.
 *          Since we don't let our GUIDs leave the DirectInput world,
 *          the uniqueness policy can be relaxed.
 *
 *          OLE generates a GUID as follows:
 *
 *          Get the current local time in FILETIME format.
 *
 *          Add the magic number 0x00146bf33e42c000 = 580819200 seconds =
 *          9580320 minutes = 159672 hours = 6653 days, approximately
 *          18 years.  Who knows why.
 *
 *          Subtract 0x00989680 (approximately 256 seconds).  Who
 *          knows why.
 *
 *          If you combine the above two steps, the net result is to
 *          add 0x00146bf33daa2980.
 *
 *          The dwLowDateTime of the resulting FILETIME becomes Data1.
 *
 *          The dwHighDateTime of the resulting FILETIME becomes
 *          Data2 and Data3, except that the high nibble of Data3
 *          is forced to 1.
 *
 *          The first two bytes of Data4 are a big-endian 10-bit
 *          sequence counter, with the top bit set and the other
 *          bits zero.
 *
 *          The last six bytes are the network card identifier.
 *
 *  @parm   LPGUID | pguid |
 *
 *          Receives the GUID to create.
 *
 *****************************************************************************/

void INTERNAL
FakeUuidCreate(LPGUID pguid)
{
    LONG lRc;
    SYSTEMTIME st;
    union {
        FILETIME ft;
        DWORDLONG ldw;
    } u;

    GetLocalTime(&st);
    SystemTimeToFileTime(&st, &u.ft);
    u.ldw += 0x00146BF33DAA2980;

    /*
     *  Note: The wacky pun is actually safe on a RISC because
     *  Data2 is already dword-aligned.
     */

    pguid->Data1 = u.ft.dwLowDateTime;
    *(LPDWORD)&pguid->Data2 = (u.ft.dwHighDateTime & 0x0FFFFFFF) | 0x10000000;

    lRc = Excl_UniqueGuidInteger();
    lRc = lRc & 0x3FFF;

    pguid->Data4[0] = 0x80 | HIBYTE(lRc);
    pguid->Data4[1] =        LOBYTE(lRc);


    /*
     *  We use the network adapter ID of the dial-up adapter as our
     *  network ID.  No real network adapter will have this ID.
     */
    pguid->Data4[2] = 'D';
    pguid->Data4[3] = 'E';
    pguid->Data4[4] = 'S';
    pguid->Data4[5] = 'T';
    pguid->Data4[6] = 0x00;
    pguid->Data4[7] = 0x00;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DICreateGuid |
 *
 *          Create a GUID.  Because we don't want to pull in all of OLE,
 *          we don't actually use RPCRT4
 *
 *  @parm   LPGUID | pguid |
 *
 *          Receives the GUID to create.
 *
 *****************************************************************************/

void EXTERNAL
DICreateGuid(LPGUID pguid)
{
    AssertF(g_hmtxGlobal);

    FakeUuidCreate(pguid);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DICreateStaticGuid |
 *
 *          Create a "static" <t GUID>, which is a <t GUID> that can be
 *          deterministically regenerated from its parameters.
 *
 *          This is used to invent <t GUID>s for HID devices
 *          and vendors.
 *
 *          The entire <t GUID> is zero, except for the pid and vid
 *          which go into Data1, and the network adapter
 *          ID is the dial-up adapter.
 *
 *          We put the variable bits into the Data1 because that's
 *          how GUIDs work.
 *
 *          The resulting GUID is {pidvid-0000-0000-0000-504944564944}
 *
 *  @parm   LPGUID | pguid |
 *
 *          Receives the created <t GUID>.
 *
 *****************************************************************************/

void EXTERNAL
DICreateStaticGuid(LPGUID pguid, WORD pid, WORD vid)
{
    pguid->Data1 = MAKELONG(vid, pid);

    pguid->Data2 = 0;
    pguid->Data3 = 0;

    /*
     *  We use the string "PIDVID" as our network adapter ID.
     *  No real network adapter will have this ID.
     */
    pguid->Data4[0] = 0x00;
    pguid->Data4[1] = 0x00;
    pguid->Data4[2] = 'P';
    pguid->Data4[3] = 'I';
    pguid->Data4[4] = 'D';
    pguid->Data4[5] = 'V';
    pguid->Data4[6] = 'I';
    pguid->Data4[7] = 'D';

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diextdll.c ===
/*****************************************************************************
 *
 *  DIExtDll.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Dynamic loading of optional external DLLs.
 *
 *  Contents:
 *
 *      ExtDll_Init
 *      ExtDll_Term
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflExtDll

/*****************************************************************************
 *
 *  @define T | TEXT(ch) |
 *
 *          Either "A" or "W", depending on whether we are building
 *          the ANSI or UNICODE version.
 *
 *****************************************************************************/

    #ifdef UNICODE
        #define T       "W"
    #else
        #define T       "A"
    #endif

/*****************************************************************************
 *
 *  @define MAKEAPINAME | nm |
 *
 *          Emit a c_sz that records the name of the API.
 *
 *****************************************************************************/

    #define MAKEAPINAME(nm)     CHAR c_sz##nm[] = #nm

#ifndef STATIC_DLLUSAGE

/*****************************************************************************
 *
 *  CFGMGR32
 *
 *  Note that this must match the CFGMGR32 structure in diextdll.h
 *
 *****************************************************************************/

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(CM_Get_Child);
MAKEAPINAME(CM_Get_Sibling);
MAKEAPINAME(CM_Get_Parent);
MAKEAPINAME(CM_Get_DevNode_Registry_Property) T;
MAKEAPINAME(CM_Set_DevNode_Registry_Property) T;
MAKEAPINAME(CM_Get_Device_ID) T;
        #pragma END_CONST_DATA

#ifndef WINNT
LPSTR g_cfgmgr32_fn[] = {
    c_szCM_Get_Child,
    c_szCM_Get_Sibling,
    c_szCM_Get_Parent,
    c_szCM_Get_DevNode_Registry_Property,
    c_szCM_Set_DevNode_Registry_Property,
    c_szCM_Get_Device_ID
};

HINSTANCE g_hinstcfgmgr32;

CFGMGR32 g_cfgmgr32 = {
    (FARPROC)DIDummy_CM_Get_Child,
    (FARPROC)DIDummy_CM_Get_Sibling,
    (FARPROC)DIDummy_CM_Get_Parent,
    (FARPROC)DIDummy_CM_Get_DevNode_Registry_Property,
    (FARPROC)DIDummy_CM_Set_DevNode_Registry_Property,
    (FARPROC)DIDummy_CM_Get_Device_ID
};
#endif


/*****************************************************************************
 *
 *  SETUPAPI
 *
 *  Note that this must match the SETUPAPI structure in diextdll.h
 *
 *****************************************************************************/

       #pragma BEGIN_CONST_DATA
MAKEAPINAME(SetupDiGetClassDevs) T;
MAKEAPINAME(SetupDiDestroyDeviceInfoList);
MAKEAPINAME(SetupDiGetDeviceInterfaceDetail) T;
MAKEAPINAME(SetupDiEnumDeviceInterfaces);
MAKEAPINAME(SetupDiCreateDeviceInterfaceRegKey) T;
MAKEAPINAME(SetupDiCallClassInstaller);
MAKEAPINAME(SetupDiGetDeviceRegistryProperty) T;
MAKEAPINAME(SetupDiSetDeviceRegistryProperty) T;
MAKEAPINAME(SetupDiGetDeviceInstanceId) T;
MAKEAPINAME(SetupDiOpenDeviceInfo) T;
MAKEAPINAME(SetupDiCreateDeviceInfoList);
MAKEAPINAME(SetupDiOpenDevRegKey);
        #pragma END_CONST_DATA

LPSTR g_setupapi_fn[] = {
    c_szSetupDiGetClassDevs,
    c_szSetupDiDestroyDeviceInfoList,
    c_szSetupDiGetDeviceInterfaceDetail,
    c_szSetupDiEnumDeviceInterfaces,
    c_szSetupDiCreateDeviceInterfaceRegKey,
    c_szSetupDiCallClassInstaller,
    c_szSetupDiGetDeviceRegistryProperty,
    c_szSetupDiSetDeviceRegistryProperty,
    c_szSetupDiGetDeviceInstanceId,
    c_szSetupDiOpenDeviceInfo,
    c_szSetupDiCreateDeviceInfoList,
    c_szSetupDiOpenDevRegKey,
  #ifdef WINNT
    c_szCM_Get_Child,
    c_szCM_Get_Sibling,
    c_szCM_Get_Parent,
    c_szCM_Get_DevNode_Registry_Property,
    c_szCM_Set_DevNode_Registry_Property,
    c_szCM_Get_Device_ID
  #endif
};

HINSTANCE g_hinstSetupapi;

SETUPAPI g_setupapi = {
    (FARPROC)DIDummy_SetupDiGetClassDevs,
    (FARPROC)DIDummy_SetupDiDestroyDeviceInfoList,
    (FARPROC)DIDummy_SetupDiGetDeviceInterfaceDetail,
    (FARPROC)DIDummy_SetupDiEnumDeviceInterfaces,
    (FARPROC)DIDummy_SetupDiCreateDeviceInterfaceRegKey,
    (FARPROC)DIDummy_SetupDiCallClassInstaller,
    (FARPROC)DIDummy_SetupDiGetDeviceRegistryProperty,
    (FARPROC)DIDummy_SetupDiSetDeviceRegistryProperty,
    (FARPROC)DIDummy_SetupDiGetDeviceInstanceId,
    (FARPROC)DIDummy_SetupDiOpenDeviceInfo,
    (FARPROC)DIDummy_SetupDiCreateDeviceInfoList,
    (FARPROC)DIDummy_SetupDiOpenDevRegKey,
  #ifdef WINNT
    (FARPROC)DIDummy_CM_Get_Child,
    (FARPROC)DIDummy_CM_Get_Sibling,
    (FARPROC)DIDummy_CM_Get_Parent,
    (FARPROC)DIDummy_CM_Get_DevNode_Registry_Property,
    (FARPROC)DIDummy_CM_Set_DevNode_Registry_Property,
    (FARPROC)DIDummy_CM_Get_Device_ID
  #endif    
};

/*****************************************************************************
 *
 *  HIDDLL
 *
 *  Note that this must match the HIDDLL structure in diextdll.h
 *
 *****************************************************************************/

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(HidD_GetHidGuid);
MAKEAPINAME(HidD_GetPreparsedData);
MAKEAPINAME(HidD_FreePreparsedData);
MAKEAPINAME(HidD_FlushQueue);
MAKEAPINAME(HidD_GetAttributes);
MAKEAPINAME(HidD_GetFeature);
MAKEAPINAME(HidD_SetFeature);
MAKEAPINAME(HidD_GetProductString);
MAKEAPINAME(HidD_GetInputReport);
MAKEAPINAME(HidP_GetCaps);
MAKEAPINAME(HidP_GetButtonCaps);
MAKEAPINAME(HidP_GetValueCaps);
MAKEAPINAME(HidP_GetLinkCollectionNodes);
MAKEAPINAME(HidP_MaxDataListLength);
MAKEAPINAME(HidP_GetUsagesEx);
MAKEAPINAME(HidP_GetScaledUsageValue);
MAKEAPINAME(HidP_GetData);
MAKEAPINAME(HidP_SetData);
MAKEAPINAME(HidP_GetUsageValue);
MAKEAPINAME(HidP_MaxUsageListLength);
MAKEAPINAME(HidP_GetSpecificButtonCaps);
MAKEAPINAME(HidP_TranslateUsagesToI8042ScanCodes);
        #pragma END_CONST_DATA

LPSTR g_hiddll_fn[] = {
    c_szHidD_GetHidGuid,
    c_szHidD_GetPreparsedData,
    c_szHidD_FreePreparsedData,
    c_szHidD_FlushQueue,
    c_szHidD_GetAttributes,
    c_szHidD_GetFeature,
    c_szHidD_SetFeature,
    c_szHidD_GetProductString,
    c_szHidD_GetInputReport,
    c_szHidP_GetCaps,
    c_szHidP_GetButtonCaps,
    c_szHidP_GetValueCaps,
    c_szHidP_GetLinkCollectionNodes,
    c_szHidP_MaxDataListLength,
    c_szHidP_GetUsagesEx,
    c_szHidP_GetScaledUsageValue,
    c_szHidP_GetData,
    c_szHidP_SetData,
    c_szHidP_GetUsageValue,
    c_szHidP_MaxUsageListLength,
    c_szHidP_GetSpecificButtonCaps,
    c_szHidP_TranslateUsagesToI8042ScanCodes
};

HINSTANCE g_hinstHid;

HIDDLL g_hiddll = {
    (FARPROC)DIDummy_HidD_GetHidGuid,
    (FARPROC)DIDummy_HidD_GetPreparsedData,
    (FARPROC)DIDummy_HidD_FreePreparsedData,
    (FARPROC)DIDummy_HidD_FlushQueue,
    (FARPROC)DIDummy_HidD_GetAttributes,
    (FARPROC)DIDummy_HidD_GetFeature,
    (FARPROC)DIDummy_HidD_SetFeature,
    (FARPROC)DIDummy_HidD_GetProductString,
    (FARPROC)DIDummy_HidD_GetInputReport,
    (FARPROC)DIDummy_HidP_GetCaps,
    (FARPROC)DIDummy_HidP_GetButtonCaps,
    (FARPROC)DIDummy_HidP_GetValueCaps,
    (FARPROC)DIDummy_HidP_GetLinkCollectionNodes,
    (FARPROC)DIDummy_HidP_MaxDataListLength,
    (FARPROC)DIDummy_HidP_GetUsagesEx,
    (FARPROC)DIDummy_HidP_GetScaledUsageValue,
    (FARPROC)DIDummy_HidP_GetData,
    (FARPROC)DIDummy_HidP_SetData,
    (FARPROC)DIDummy_HidP_GetUsageValue,
    (FARPROC)DIDummy_HidP_MaxUsageListLength,
    (FARPROC)DIDummy_HidP_GetSpecificButtonCaps,
    (FARPROC)DIDummy_HidP_TranslateUsagesToI8042ScanCodes,
};

/*****************************************************************************
 *
 *  Winmm
 *
 *  Note that this must match the Winmm structure in diextdll.h
 *
 *****************************************************************************/

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(joyGetDevCaps) T;
MAKEAPINAME(joyGetPosEx);
MAKEAPINAME(joyGetPos);
MAKEAPINAME(joyConfigChanged);
MAKEAPINAME(mmioClose);
MAKEAPINAME(mmioOpenA);
MAKEAPINAME(mmioDescend);
MAKEAPINAME(mmioCreateChunk);
MAKEAPINAME(mmioRead);
MAKEAPINAME(mmioWrite);
MAKEAPINAME(mmioAscend);
        #pragma END_CONST_DATA

LPSTR g_winmmdll_fn[] = {
    c_szjoyGetDevCaps,
    c_szjoyGetPosEx,
    c_szjoyGetPos,
    c_szjoyConfigChanged,
    c_szmmioClose,      
    c_szmmioOpenA,
    c_szmmioDescend,    
    c_szmmioCreateChunk,
    c_szmmioRead,       
    c_szmmioWrite,      
    c_szmmioAscend
};      
        
HINSTANCE g_hinstwinmmdll;
        
WINMMDLL g_winmmdll = {
    (FARPROC)DIDummy_joyGetDevCaps,
    (FARPROC)DIDummy_joyGetPosEx,
    (FARPROC)DIDummy_joyGetPos,
    (FARPROC)DIDummy_joyConfigChanged,
    (FARPROC)DIDummy_mmioClose,
    (FARPROC)DIDummy_mmioOpenA,
    (FARPROC)DIDummy_mmioDescend,
    (FARPROC)DIDummy_mmioCreateChunk,
    (FARPROC)DIDummy_mmioRead,
    (FARPROC)DIDummy_mmioWrite,
    (FARPROC)DIDummy_mmioAscend,
};

/*****************************************************************************
 *
 *  User32
 *
 *  Note that this must match the User32 structure in dihid.h
 *
 *****************************************************************************/

#ifdef USE_WM_INPUT

        #pragma BEGIN_CONST_DATA
MAKEAPINAME(RegisterRawInputDevices);
MAKEAPINAME(GetRawInputData);
        #pragma END_CONST_DATA

LPSTR g_user32_fn[] = {
    c_szRegisterRawInputDevices,
    c_szGetRawInputData,
};

HINSTANCE g_hinstuser32;

USER32 g_user32 = {
    (FARPROC)DIDummy_RegisterRawInputDevices,
    (FARPROC)DIDummy_GetRawInputData,
};

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HINSTANCE | ExtDll_LoadDll |
 *
 *          Loads a DLL and resolves all the imports.
 *
 *  @parm   LPCTSTR | ptszName |
 *
 *          The name of the DLL to load.
 *
 *  @parm   PMANUALIMPORT | rgmi |
 *
 *          Array of <t MANUALIMPORT> structures to resolve.
 *
 *  @parm   int | cmi |
 *
 *          Number of <t MANUALIMPORT> structures to resolve.
 *
 *  @parm   LPSTR * | ppszProcName |
 * 
 *          Function names.
 *
 *  @returns
 *
 *          Returns the instance handle of the DLL if one or more of the imports
 *          were resolved successfully; otherwise, unloads the DLL
 *          and returns 0.
 *
 *          If none of the imports was resolved successfully, the value
 *          of the entries of <p rgmi> are not changed.
 *
 *****************************************************************************/

HINSTANCE INTERNAL
    ExtDll_LoadDll(LPCTSTR ptszName, PMANUALIMPORT rgmi, int cmi, LPSTR *ppszProcName)
{
    HINSTANCE hinst = 0;
    BOOL      fNeedFreeLib = TRUE;

    EnterProcR(ExtDll_LoadDll, (_ "spuup", ptszName, rgmi, cmi, ppszProcName));

    hinst = LoadLibrary(ptszName);
    if(hinst)
    {
        int     imi;
        FARPROC fp;

        for(imi = 0; imi < cmi; imi++)
        {
            fp = GetProcAddress(hinst, ppszProcName[imi]);
            if( fp ) {
                rgmi[imi].pfn = fp;
                fNeedFreeLib = FALSE;
            }
        }
    }

    if( fNeedFreeLib ) {
        FreeLibrary(hinst);
        hinst = 0;
    }
        
    ExitProcX((UINT_PTR)hinst);
    
    return hinst;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ExtDll_Init |
 *
 *          Try to load our optional DLLs.  Don't get upset if they
 *          don't load.
 *
 *****************************************************************************/

void EXTERNAL
    ExtDll_Init(void)
{
    g_hinstHid =      ExtDll_LoadDll(TEXT("HID.DLL"),
                                g_hiddll.rgmi,
                                cA(g_hiddll.rgmi),
                                g_hiddll_fn ); 
    
    g_hinstSetupapi = ExtDll_LoadDll(TEXT("SETUPAPI.DLL"),
                                g_setupapi.rgmi,
                                cA(g_setupapi.rgmi),
                                g_setupapi_fn );
    
    #ifndef WINNT
    g_hinstcfgmgr32 = ExtDll_LoadDll( TEXT("CFGMGR32.DLL" ),
                                g_cfgmgr32.rgmi,
                                cA(g_cfgmgr32.rgmi),
                                g_cfgmgr32_fn );
    #endif
    
  #ifdef WINNT
    #define JOYPROCNUM  4
    g_hinstwinmmdll = ExtDll_LoadDll( TEXT("WINMM.DLL" ),
                                &g_winmmdll.rgmi[JOYPROCNUM],
                                cA(g_winmmdll.rgmi) - JOYPROCNUM,
                                &g_winmmdll_fn[JOYPROCNUM] );
    #undef JOYPROCNUM
  #else
    g_hinstwinmmdll = ExtDll_LoadDll( TEXT("WINMM.DLL" ),
                                g_winmmdll.rgmi,
                                cA(g_winmmdll.rgmi),
                                g_winmmdll_fn );
  #endif
  
  #ifdef USE_WM_INPUT
    g_hinstuser32   = ExtDll_LoadDll( TEXT("USER32.DLL" ),
                                g_user32.rgmi,
                                cA(g_user32.rgmi),
                                g_user32_fn );
  #endif
      
}

#endif /* STATIC_DLLUSAGE */

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ExtDll_Term |
 *
 *          Unload any optional DLLs that we loaded.
 *
 *****************************************************************************/

void EXTERNAL
    ExtDll_Term(void)
{
  #ifndef STATIC_DLLUSAGE
    if(g_hinstSetupapi)
    {
  #endif /* STATIC_DLLUSAGE */

        DllEnterCrit();
        if(g_phdl)
        {
            DIHid_EmptyHidList();
            FreePpv(&g_phdl);
        }

        DIBus_FreeMemory();

        DllLeaveCrit();

#ifndef STATIC_DLLUSAGE
        FreeLibrary(g_hinstSetupapi);
        g_hinstSetupapi = NULL;
    }

  #ifndef WINNT
    if(g_hinstcfgmgr32)
    {
        FreeLibrary(g_hinstcfgmgr32);
        g_hinstcfgmgr32 = NULL;
    }
  #endif

    if(g_hinstHid)
    {
        FreeLibrary(g_hinstHid);
        g_hinstHid = NULL;
    }

    if( g_hinstwinmmdll)
    {
        FreeLibrary(g_hinstwinmmdll);
        g_hinstwinmmdll = NULL;
    }

  #ifdef USE_WM_INPUT    
    if( g_hinstuser32)
    {
        FreeLibrary(g_hinstuser32);
        g_hinstuser32 = NULL;
    }
  #endif

#endif /* STATIC_DLLUSAGE */

}

#ifndef STATIC_DLLUSAGE

////////////////////////////////////////
// cfgmgr32.dll dummy functions
////////////////////////////////////////

CONFIGRET WINAPI DIDummy_CM_Get_Child
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  dnDevInst,
IN  ULONG    ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_Child( %08x, %08x, %u )"),
                     pdnDevInst, dnDevInst, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Get_Sibling
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  DevInst,
IN  ULONG    ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_Sibling( %08x, %08x, %u )"),
                     pdnDevInst, DevInst, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Get_Parent
(
OUT PDEVINST pdnDevInst,
IN  DEVINST  dnDevInst,
IN  ULONG    ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_Parent( %08x, %08x, %u )"),
                     pdnDevInst, dnDevInst, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Get_DevNode_Registry_Property
(
IN  DEVINST     dnDevInst,
IN  ULONG       ulProperty,
OUT PULONG      pulRegDataType,   OPTIONAL
OUT PVOID       Buffer,           OPTIONAL
IN  OUT PULONG  pulLength,
IN  ULONG       ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_DevNode_Registry_Property( %08x, %u, %08x, %08x, %08x, %u )"),
                     dnDevInst, ulProperty, pulRegDataType, Buffer, pulLength, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Set_DevNode_Registry_Property
(
IN  DEVINST     dnDevInst,
IN  ULONG       ulProperty,
IN  PVOID       Buffer,           OPTIONAL
IN  ULONG       ulLength,
IN  ULONG       ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Set_DevNode_Registry_Property( %08x, %u, %08x, %u, %u )"),
                     dnDevInst, ulProperty, Buffer, ulLength, ulFlags );

    return CR_FAILURE;
}

CONFIGRET WINAPI DIDummy_CM_Get_Device_ID
(
 IN  DEVINST  dnDevInst,
 OUT PTCHAR   Buffer,
 IN  ULONG    BufferLen,
 IN  ULONG    ulFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_CM_Get_Device_ID( %08x, %08x, %u, %u )"),
                     dnDevInst, Buffer, BufferLen, ulFlags );

    return CR_FAILURE;
}

////////////////////////////////////////
//Setupapi.dll dummy functions
////////////////////////////////////////

HDEVINFO WINAPI DIDummy_SetupDiGetClassDevs
(
IN LPGUID ClassGuid,  OPTIONAL
IN LPCTSTR Enumerator, OPTIONAL
IN HWND   hwndParent, OPTIONAL
IN DWORD  Flags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetClassDevs( %08x, %08x, %08x, %u )"),
                     ClassGuid, Enumerator, hwndParent, Flags );

    return INVALID_HANDLE_VALUE;    
}

BOOL WINAPI DIDummy_SetupDiDestroyDeviceInfoList
(
IN HDEVINFO DeviceInfoSet
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiDestroyDeviceInfoList( %08x )"),
                     DeviceInfoSet );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiGetDeviceInterfaceDetail
(
IN  HDEVINFO                         DeviceInfoSet,
IN  PSP_DEVICE_INTERFACE_DATA        pdid,
OUT PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd,         OPTIONAL
IN  DWORD                            cbDidd,
OUT PDWORD                           RequiredSize,  OPTIONAL
OUT PSP_DEVINFO_DATA                 DeviceInfoData OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetDeviceInterfaceDetail( %08x, %08x, %08x, %u, %08x, %08x )"),
                     DeviceInfoSet, pdid, pdidd, cbDidd, RequiredSize, DeviceInfoData );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiEnumDeviceInterfaces
(
IN  HDEVINFO                  DeviceInfoSet,
IN  PSP_DEVINFO_DATA          DeviceInfoData,     OPTIONAL
IN  LPGUID                    InterfaceClassGuid,
IN  DWORD                     MemberIndex,
OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiEnumDeviceInterfaces( %08x, %08x, %08x, %u, %08x )"),
                     DeviceInfoSet, DeviceInfoData, InterfaceClassGuid, MemberIndex, DeviceInterfaceData );

    return FALSE;
}

HKEY WINAPI DIDummy_SetupDiCreateDeviceInterfaceRegKey
(
IN HDEVINFO                  hdev,
IN PSP_DEVICE_INTERFACE_DATA pdid,
IN DWORD                     Reserved,
IN REGSAM                    samDesired,
IN HINF                      InfHandle,           OPTIONAL
IN PCSTR                     InfSectionName       OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiCreateDeviceInterfaceRegKey( %08x, %08x, %u, %u, %08x, %s )"),
                     hdev, pdid, Reserved, samDesired, InfHandle, InfSectionName );

    return INVALID_HANDLE_VALUE;
}

BOOL WINAPI DIDummy_SetupDiCallClassInstaller
(
IN DI_FUNCTION      InstallFunction,
IN HDEVINFO         DeviceInfoSet,
IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiCallClassInstaller( %08x, %08x, %08x )"),
                     InstallFunction, DeviceInfoSet, DeviceInfoData );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiGetDeviceRegistryProperty
(
IN  HDEVINFO         DeviceInfoSet,
IN  PSP_DEVINFO_DATA DeviceInfoData,
IN  DWORD            Property,
OUT PDWORD           PropertyRegDataType, OPTIONAL
OUT PBYTE            PropertyBuffer,
IN  DWORD            PropertyBufferSize,
OUT PDWORD           RequiredSize         OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetDeviceRegistryProperty( %08x, %08x, %u, %08x, %08x, %u, %08x )"),
                     DeviceInfoSet, DeviceInfoData, Property, PropertyRegDataType, PropertyBuffer, PropertyBufferSize, RequiredSize );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiSetDeviceRegistryProperty
(
IN     HDEVINFO         DeviceInfoSet,
IN OUT PSP_DEVINFO_DATA DeviceInfoData,
IN     DWORD            Property,
IN     CONST BYTE*      PropertyBuffer,
IN     DWORD            PropertyBufferSize
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetDeviceInstanceId( %08x, %08x, %u, %08x, %u )"),
                     DeviceInfoSet, DeviceInfoData, Property, PropertyBuffer, PropertyBufferSize );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiGetDeviceInstanceId
(
IN  HDEVINFO         DeviceInfoSet,
IN  PSP_DEVINFO_DATA DeviceInfoData,
OUT PTSTR            DeviceInstanceId,
IN  DWORD            DeviceInstanceIdSize,
OUT PDWORD           RequiredSize          OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiGetDeviceInstanceId( %08x, %08x, %08x, %u, %08x )"),
                     DeviceInfoSet, DeviceInfoData, DeviceInstanceId, DeviceInstanceIdSize, RequiredSize );

    return FALSE;
}

BOOL WINAPI DIDummy_SetupDiOpenDeviceInfo
(
IN  HDEVINFO         DeviceInfoSet,
IN  LPCTSTR          DeviceInstanceId,
IN  HWND             hwndParent,       OPTIONAL
IN  DWORD            OpenFlags,
OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiOpenDeviceInfo( %08x, %08x, %08x, %u, %08x )"),
                     DeviceInfoSet, DeviceInstanceId, hwndParent, OpenFlags, DeviceInfoData );

    return FALSE;
}

HDEVINFO WINAPI DIDummy_SetupDiCreateDeviceInfoList
(
IN LPGUID ClassGuid, OPTIONAL
IN HWND   hwndParent OPTIONAL
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiCreateDeviceInfoList( %08x, %08x )"),
                     ClassGuid, hwndParent );

    return INVALID_HANDLE_VALUE;
}

HKEY WINAPI DIDummy_SetupDiOpenDevRegKey
(
IN HDEVINFO         DeviceInfoSet,
IN PSP_DEVINFO_DATA DeviceInfoData,
IN DWORD            Scope,
IN DWORD            HwProfile,
IN DWORD            KeyType,
IN REGSAM           samDesired
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_SetupDiOpenDevRegKey( %08x, %08x, %u, %u, %u, %u )"),
                     DeviceInfoSet, DeviceInfoData, Scope, HwProfile, KeyType, samDesired );

    return INVALID_HANDLE_VALUE;
}

////////////////////////////////////////
// hid.dll dummy functions
////////////////////////////////////////

void __stdcall DIDummy_HidD_GetHidGuid
(
OUT   LPGUID   HidGuid
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetHidGuid( %08x )"),
                     HidGuid );

    return;
}

BOOLEAN __stdcall DIDummy_HidD_GetPreparsedData
(
IN    HANDLE                  HidDeviceObject,
OUT   PHIDP_PREPARSED_DATA  * PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetPreparsedData( %08x, %08x )"),
                     HidDeviceObject, PreparsedData );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_FreePreparsedData
(
IN    PHIDP_PREPARSED_DATA PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_FreePreparsedData( %08x )"),
                     PreparsedData );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_FlushQueue  //unused
(
IN    HANDLE                HidDeviceObject
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_FlushQueue( %08x )"),
                     HidDeviceObject );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_GetAttributes
(
IN  HANDLE              HidDeviceObject,
OUT PHIDD_ATTRIBUTES    Attributes
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetAttributes( %08x, %08x )"),
                     HidDeviceObject, Attributes );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_GetFeature
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetFeature( %08x, %08x, %u )"),
                     HidDeviceObject, ReportBuffer, ReportBufferLength );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_SetFeature
(
IN    HANDLE   HidDeviceObject,
IN    PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_SetFeature( %08x, %08x, %u )"),
                     HidDeviceObject, ReportBuffer, ReportBufferLength );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_GetProductString
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    Buffer,
IN    ULONG    BufferLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetProductString( %08x, %08x, %u )"),
                     HidDeviceObject, Buffer, BufferLength );

    return FALSE;
}

BOOLEAN __stdcall DIDummy_HidD_GetInputReport
(
IN    HANDLE   HidDeviceObject,
OUT   PVOID    ReportBuffer,
IN    ULONG    ReportBufferLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidD_GetProductString( %08x, %08x, %u )"),
                     HidDeviceObject, ReportBuffer, ReportBufferLength );

    return FALSE;
}

NTSTATUS __stdcall DIDummy_HidP_GetCaps
(
IN      PHIDP_PREPARSED_DATA      PreparsedData,
OUT     PHIDP_CAPS                Capabilities
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetCaps( %08x, %08x )"),
                     PreparsedData, Capabilities );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetButtonCaps
(
IN       HIDP_REPORT_TYPE     ReportType,
OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
IN OUT   PUSHORT              ButtonCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetButtonCaps( %08x, %08x, %08x, %08x )"),
                     ReportType, ButtonCaps, ButtonCapsLength, PreparsedData );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetValueCaps
(
IN       HIDP_REPORT_TYPE     ReportType,
OUT      PHIDP_VALUE_CAPS     ValueCaps,
IN OUT   PUSHORT              ValueCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetValueCaps( %08x, %08x, %08x, %08x )"),
                     ReportType, ValueCaps, ValueCapsLength, PreparsedData );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetLinkCollectionNodes
(
OUT      PHIDP_LINK_COLLECTION_NODE LinkCollectionNodes,
IN OUT   PULONG                     LinkCollectionNodesLength,
IN       PHIDP_PREPARSED_DATA       PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetLinkCollectionNodes( %08x, %08x, %08x )"),
                     LinkCollectionNodes, LinkCollectionNodesLength, PreparsedData );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

ULONG __stdcall DIDummy_HidP_MaxDataListLength
(
IN HIDP_REPORT_TYPE      ReportType,
IN PHIDP_PREPARSED_DATA  PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_MaxDataListLength( %08x, %08x )"),
                     ReportType, PreparsedData );

    return 0;
}

NTSTATUS __stdcall DIDummy_HidP_GetUsagesEx   //unused
(
IN       HIDP_REPORT_TYPE     ReportType,
IN       USHORT               LinkCollection,
OUT      PUSAGE_AND_PAGE      ButtonList,
IN OUT   ULONG *              UsageLength,
IN       PHIDP_PREPARSED_DATA PreparsedData,
IN       PCHAR                Report,
IN       ULONG                ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetUsagesEx( %08x, %u, %08x, %08x, %08x, %08x, %u )"),
                     ReportType, LinkCollection, ButtonList, UsageLength, PreparsedData, Report, ReportLength );
	
    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetScaledUsageValue  //unused
(
IN    HIDP_REPORT_TYPE     ReportType,
IN    USAGE                UsagePage,
IN    USHORT               LinkCollection,
IN    USAGE                Usage,
OUT   PLONG                UsageValue,
IN    PHIDP_PREPARSED_DATA PreparsedData,
IN    PCHAR                Report,
IN    ULONG                ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetScaledUsageValue( %08x, %u, %u, %u, %08x, %08x, %08x, %u )"),
                     ReportType, UsagePage, LinkCollection, Usage, UsageValue, PreparsedData, Report, ReportLength );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetData
(
IN       HIDP_REPORT_TYPE      ReportType,
OUT      PHIDP_DATA            DataList,
IN OUT   PULONG                DataLength,
IN       PHIDP_PREPARSED_DATA  PreparsedData,
IN       PCHAR                 Report,
IN       ULONG                 ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetData( %08x, %08x, $08x, %08x, %08x, %u )"),
                     ReportType, DataList, DataLength, PreparsedData, Report, ReportLength );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_SetData
(
IN       HIDP_REPORT_TYPE      ReportType,
IN       PHIDP_DATA            DataList,
IN OUT   PULONG                DataLength,
IN       PHIDP_PREPARSED_DATA  PreparsedData,
IN OUT   PCHAR                 Report,
IN       ULONG                 ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_SetData( %08x, %08x, $08x, %08x, %08x, %u )"),
                     ReportType, DataList, DataLength, PreparsedData, Report, ReportLength );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_GetUsageValue
(
IN    HIDP_REPORT_TYPE     ReportType,
IN    USAGE                UsagePage,
IN    USHORT               LinkCollection,
IN    USAGE                Usage,
OUT   PULONG               UsageValue,
IN    PHIDP_PREPARSED_DATA PreparsedData,
IN    PCHAR                Report,
IN    ULONG                ReportLength
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetUsageValue( %08x, %u, %u, %u, %08x, %08x, %08x, %u )"),
                     ReportType, UsagePage, LinkCollection, Usage, UsageValue, PreparsedData, Report, ReportLength );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

ULONG __stdcall DIDummy_HidP_MaxUsageListLength
(
IN HIDP_REPORT_TYPE      ReportType,
IN USAGE                 UsagePage,
IN PHIDP_PREPARSED_DATA  PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_MaxUsageListLength( %08x, %u, %08x )"),
                     ReportType, UsagePage, PreparsedData );

    return 0;
}

NTSTATUS __stdcall DIDummy_HidP_GetSpecificButtonCaps 
(
IN       HIDP_REPORT_TYPE     ReportType,
IN       USAGE                UsagePage,      
IN       USHORT               LinkCollection, 
IN       USAGE                Usage,          
OUT      PHIDP_BUTTON_CAPS    ButtonCaps,
IN OUT   PUSHORT              ButtonCapsLength,
IN       PHIDP_PREPARSED_DATA PreparsedData
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_GetSpecificButtonCaps( %08x, %u, %u, %u, %08x, %08x, %08x )"),
                     ReportType, UsagePage, LinkCollection, Usage, ButtonCaps, ButtonCapsLength, PreparsedData );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

NTSTATUS __stdcall DIDummy_HidP_TranslateUsagesToI8042ScanCodes
(
IN       PUSAGE               ChangedUsageList, // Those usages that changed
IN       ULONG                UsageListLength,
IN       HIDP_KEYBOARD_DIRECTION KeyAction,
IN OUT   PHIDP_KEYBOARD_MODIFIER_STATE ModifierState,
IN       PHIDP_INSERT_SCANCODES  InsertCodesProcedure,
IN       PVOID                InsertCodesContext
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_HidP_TranslateUsagesToI8042ScanCodes( %08x, %u, %08x, %08x, %08x, %08x )"),
                     ChangedUsageList, UsageListLength, KeyAction, ModifierState, InsertCodesProcedure, InsertCodesContext );

    return HIDP_STATUS_NOT_IMPLEMENTED;
}

////////////////////////////////////////
// winmm.dll dummy functions
////////////////////////////////////////

MMRESULT WINAPI DIDummy_joyGetDevCaps
(
IN  UINT uJoyID,
OUT LPJOYCAPS pjc,
IN  UINT cbjc
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_joyGetDevCaps( %u, %08x, %u )"),
                     uJoyID, pjc, cbjc );

    return MMSYSERR_ERROR;
}

MMRESULT WINAPI DIDummy_joyGetPosEx
(
IN  UINT        uJoyID,
OUT LPJOYINFOEX pji
)
{   
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_joyGetPosEx( %u, %08x )"),
                     uJoyID, pji );

    return MMSYSERR_ERROR;
}

MMRESULT WINAPI DIDummy_joyGetPos
(
IN  UINT        uJoyID,
OUT LPJOYINFO   pji
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_joyGetPos( %u, %08x )"),
                     uJoyID, pji );

    return MMSYSERR_ERROR;
}

UINT WINAPI DIDummy_joyConfigChanged
(
IN DWORD dwFlags
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_joyConfigChanged( %u )"),
                     dwFlags );

    return MMSYSERR_ERROR;
}

MMRESULT WINAPI DIDummy_mmioClose
( 
IN HMMIO hmmio, 
IN UINT fuClose
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioClose( %08x, %u )"),
                     hmmio, fuClose );
	
    return MMSYSERR_ERROR;
}

HMMIO WINAPI DIDummy_mmioOpenA
( 
IN OUT LPSTR pszFileName, 
IN OUT LPMMIOINFO pmmioinfo, 
IN DWORD fdwOpen
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioOpenA( %s, %08x, %u )"),
                     pszFileName, pmmioinfo, fdwOpen );

    return NULL;
}

MMRESULT WINAPI DIDummy_mmioDescend
( 
IN HMMIO hmmio, 
IN OUT LPMMCKINFO pmmcki, 
IN const MMCKINFO FAR* pmmckiParent, 
IN UINT fuDescend
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioDescend( %08x, %08x, %08x, %u )"),
                     hmmio, pmmcki, pmmckiParent, fuDescend );

    return MMSYSERR_ERROR;
}

MMRESULT WINAPI DIDummy_mmioCreateChunk
(
IN HMMIO hmmio, 
IN LPMMCKINFO pmmcki, 
IN UINT fuCreate
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioCreateChunk( %08x, %08x, %u )"),
                     hmmio, pmmcki, fuCreate );

    return MMSYSERR_ERROR;
}

LONG WINAPI DIDummy_mmioRead
( 
IN HMMIO hmmio, 
OUT HPSTR pch, 
IN LONG cch
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioRead( %08x, %08x, %u )"),
                     hmmio, pch, cch );
	
    return 0;
}

LONG WINAPI DIDummy_mmioWrite
( 
IN HMMIO hmmio, 
IN const char _huge* pch, 
IN LONG cch
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioWrite( %08x, %08x, %u )"),
                     hmmio, pch, cch );

    return 0;
}

MMRESULT WINAPI DIDummy_mmioAscend
( 
IN HMMIO hmmio, 
IN LPMMCKINFO pmmcki, 
IN UINT fuAscend
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_mmioAscend( %08x, %08x, %u )"),
                     hmmio, pmmcki, fuAscend );
                           
    return MMSYSERR_ERROR;
}

////////////////////////////////////////
// user32.dll dummy functions
////////////////////////////////////////

#ifdef USE_WM_INPUT

BOOL WINAPI DIDummy_RegisterRawInputDevices
(
PCRAWINPUTDEVICE pRawInputDevices,
UINT uiNumDevices,
UINT cbSize
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_RegisterRawInputDevices( %08x, %u, %u )"),
                     pRawInputDevices, uiNumDevices, cbSize );
                           
    return FALSE;
}

UINT WINAPI DIDummy_GetRawInputData
(
HRAWINPUT   hRawInput,
UINT        uiCommand,
LPVOID      pData,
PUINT       pcbSize,
UINT        cbSizeHeader
)
{
    SquirtSqflPtszV( sqfl | sqflBenign,
                     TEXT("DIDummy_GetRawInputData( %08x, %u, %08x, %08x, %u )"),
                     hRawInput, uiCommand, pData, pcbSize, cbSizeHeader );
                           
    return -1;
}

#endif //#ifdef USE_WM_INPUT

#endif /* STATIC_DLLUSAGE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dihel.c ===
/*****************************************************************************
 *
 *  DIHel.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Hardware emulation layer for DirectInput.
 *
 *  Contents:
 *
 *      Hel_AcquireInstance
 *      Hel_UnacquireInstance
 *      Hel_SetBufferSize
 *      Hel_DestroyInstance
 *
 *      Hel_SetDataFormat
 *      Hel_SetNotifyHandle
 *
 *      Hel_Mouse_CreateInstance
 *      Hel_Kbd_CreateInstance
 *      Hel_Kbd_InitKeys
 *      Hel_Joy_CreateInstance
 *      Hel_Joy_Ping
 *      Hel_Joy_GetInitParms
 *
 *      IoctlHw
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHel

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | IoctlHw |
 *
 *          Send the IOCtl to the hardware device.
 *
 *  @parm   DWORD | ioctl |
 *
 *          I/O control code.
 *
 *  @parm   IN LPVOID | pvIn |
 *
 *          Optional input parameter.
 *
 *  @parm   DWORD | cbIn |
 *
 *          Size of input buffer in bytes.
 *
 *  @parm   IN LPVOID | pvOut |
 *
 *          Optional output parameter.
 *
 *  @parm   DWORD | cbOut |
 *
 *          Size of output buffer in bytes.
 *
 *  @returns
 *
 *          <c S_OK> if the ioctl succeeded and returned the correct
 *          number of bytes, else something based on the Win32 error code.
 *
 *****************************************************************************/

#ifndef WINNT
HRESULT EXTERNAL
IoctlHw(DWORD ioctl, LPVOID pvIn, DWORD cbIn, LPVOID pvOut, DWORD cbOut)
{
    HRESULT hres;
    DWORD cbRc;

    if (g_hVxD != INVALID_HANDLE_VALUE) {
        if (DeviceIoControl(g_hVxD, ioctl, pvIn, cbIn,
                            pvOut, cbOut, &cbRc, 0)) {
            if (cbRc == cbOut) {
                hres = S_OK;
            } else {
                SquirtSqflPtszV(sqfl, TEXT("Ioctl(%08x) returned wrong cbOut"),
                                ioctl);
                hres = DIERR_BADDRIVERVER;
            }
        } else {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("Ioctl(%08x) failed, error %d"),
                            ioctl, GetLastError());
            hres = hresLe(GetLastError());
        }
    } else {
        hres = DIERR_BADDRIVERVER;
    }
    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_IoctlChoose |
 *
 *          Send the IOCtl to the hardware device if it is native,
 *          or perform the operation through emulation if it is emulated.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The device in question.
 *
 *  @parm   PFNHANDLER | pfn |
 *
 *          The emulation function to call to carry out the operation.
 *
 *  @parm   DWORD | ioctl |
 *
 *          I/O control code.
 *
 *  @parm   IN LPVOID | pvIn |
 *
 *          Optional input parameter.
 *
 *  @parm   DWORD | cbIn |
 *
 *          Size of input buffer in bytes.
 *
 *****************************************************************************/

typedef HRESULT (EXTERNAL *PFNHANDLER)(PV pv);

HRESULT INTERNAL
Hel_IoctlChoose(PVXDINSTANCE pvi, PFNHANDLER pfn,
                DWORD ioctl, LPVOID pvIn, DWORD cbIn)
{
    HRESULT hres;
    if (!(pvi->fl & VIFL_EMULATED)) {
        hres = IoctlHw(ioctl, pvIn, cbIn, 0, 0);
    } else {
        hres = pfn(pvIn);
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_AcquireInstance |
 *
 *          Attempt to acquire the device instance, using either the
 *          device driver or emulation, whichever is appropriate.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The instance to acquire.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_AcquireInstance(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_AcquireInstance,
                           IOCTL_ACQUIREINSTANCE, &pvi, cbX(pvi));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_UnacquireInstance |
 *
 *          Attempt to unacquire the device instance.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The instance to unacquire.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_UnacquireInstance(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_UnacquireInstance,
                           IOCTL_UNACQUIREINSTANCE, &pvi, cbX(pvi));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_SetBufferSize |
 *
 *          Set the buffer size.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          Information about the buffer size.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_SetBufferSize(PVXDDWORDDATA pvdd)
{
    HRESULT hres;
    EnterProc(Hel_SetBufferSize, (_ "pxx", pvdd->pvi, pvdd->dw, pvdd->pvi->fl));

    hres = Hel_IoctlChoose(pvdd->pvi, CEm_SetBufferSize,
                           IOCTL_SETBUFFERSIZE, pvdd, cbX(*pvdd));

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_DestroyInstance |
 *
 *          Destroy the device instance in the appropriate way.
 *
 *  @parm   PVXDINSTANCE | pvi |
 *
 *          The instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_DestroyInstance(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_DestroyInstance,
                         IOCTL_DESTROYINSTANCE, &pvi, cbX(pvi));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_SetDataFormat |
 *
 *          Set the data format.
 *
 *  @parm   PVXDDATAFORMAT | pvdf |
 *
 *          Information about the data format.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_SetDataFormat(PVXDDATAFORMAT pvdf)
{
    return Hel_IoctlChoose(pvdf->pvi, CEm_SetDataFormat,
                           IOCTL_SETDATAFORMAT, pvdf, cbX(*pvdf));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_SetNotifyHandle |
 *
 *          Set the event handle for notification.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          9x: dw = ring 0 handle. Dinput calls _OpenVxDHandle to get ring 0 handle.
 *          NT: dw = ring 3 handle. DINPUT.SYS translates the handle to pointer.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_SetNotifyHandle(PVXDDWORDDATA pvdd)
{
    HRESULT hres;
    if (!(pvdd->pvi->fl & VIFL_EMULATED)) {
#ifndef WINNT
        AssertF(_OpenVxDHandle);
        if (pvdd->dw) {
            pvdd->dw = _OpenVxDHandle((HANDLE)pvdd->dw);
        }
#endif

        hres = IoctlHw(IOCTL_SETNOTIFYHANDLE, pvdd, cbX(*pvdd), 0, 0);
    } else {
        hres = S_OK;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CREATEDEVICEINFO |
 *
 *          Describes how to create the device either via the driver or
 *          via emulation.
 *
 *  @parm   DWORD | dwIoctl |
 *
 *          IOCtl code to try.
 *
 *  @parm   DWORD | flEmulation |
 *
 *          Flag in registry that forces emulation.
 *
 *  @parm   EMULATIONCREATEPROC | pfnCreate |
 *
 *          Function that creates emulation object.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

typedef HRESULT (EXTERNAL *EMULATIONCREATEPROC)
                (PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut);


typedef struct CREATEDEVICEINFO {
    DWORD dwIoctl;
    DWORD flEmulation;
    EMULATIONCREATEPROC pfnCreate;
} CREATEDEVICEINFO, *PCREATEDEVICEINFO;

CREATEDEVICEINFO c_cdiMouse = {
    IOCTL_MOUSE_CREATEINSTANCE,
    DIEMFL_MOUSE,
    CEm_Mouse_CreateInstance,
};

CREATEDEVICEINFO c_cdiKbd = {
    IOCTL_KBD_CREATEINSTANCE,
    DIEMFL_KBD | DIEMFL_KBD2,
    CEm_Kbd_CreateInstance,
};

CREATEDEVICEINFO c_cdiJoy = {
    IOCTL_JOY_CREATEINSTANCE,
    DIEMFL_JOYSTICK,
    CEm_Joy_CreateInstance,
};

#pragma END_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_CreateInstance |
 *
 *          Attempt to create the device instance through the driver
 *          with the specified IOCtl.
 *
 *          If that is not possible, then use the emulation callback.
 *
 *  @parm   PCREATEDEVICEINFO | pcdi |
 *
 *          Describes how to create the device.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          Describes the device being created.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          Receives created instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_CreateInstance(PCREATEDEVICEINFO pcdi,
                   PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    HRESULT hres;

    pdevf->dwEmulation |= g_flEmulation;
    pdevf->dwEmulation &= pcdi->flEmulation;

    if (pdevf->dwEmulation ||
        (FAILED(hres = IoctlHw(pcdi->dwIoctl, pdevf, cbX(*pdevf),
                        ppviOut, cbX(*ppviOut))))) {
        hres = pcdi->pfnCreate(pdevf, ppviOut);
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Mouse_CreateInstance |
 *
 *          Attempt to create the device instance through the driver.
 *          If that is not possible, then use the emulation layer.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          Describes the device being created.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          Receives created instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Mouse_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    return Hel_CreateInstance(&c_cdiMouse, pdevf, ppviOut);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Kbd_CreateInstance |
 *
 *          Attempt to create the device instance through the driver.
 *          If that is not possible, then use the emulation layer.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          Describes the device being created.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          Receives created instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Kbd_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    return Hel_CreateInstance(&c_cdiKbd, pdevf, ppviOut);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Kbd_InitKeys |
 *
 *          Tell the device driver (or emulation) about the key state.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The instance and the key state.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Kbd_InitKeys(PVXDDWORDDATA pvdd)
{
    return Hel_IoctlChoose(pvdd->pvi, CEm_Kbd_InitKeys,
                           IOCTL_KBD_INITKEYS, pvdd, cbX(*pvdd));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_CreateInstance |
 *
 *          Attempt to create the device instance through the driver.
 *          If that is not possible, then use the emulation layer.
 *
 *  @parm   PVXDDEVICEFORMAT | pdevf |
 *
 *          Describes the device being created.
 *
 *  @parm   PVXDINSTANCE * | ppviOut |
 *
 *          Receives created instance.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut)
{
    return Hel_CreateInstance(&c_cdiJoy, pdevf, ppviOut);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_Ping |
 *
 *          Ask the device driver (or emulation) to get the joystick info.
 *
 *  @parm   PVXDDWORDDATA | pvdd |
 *
 *          The instance and the key state.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_Ping(PVXDINSTANCE pvi)
{
    return Hel_IoctlChoose(pvi, CEm_Joy_Ping,
                           IOCTL_JOY_PING8, &pvi, cbX(pvi));
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_ConfigChanged |
 *
 *          Tell vjoyd config has been changed.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_ConfigChanged(DWORD dwFlags)
{
    return IoctlHw(IOCTL_JOY_CONFIGCHANGED, &dwFlags, cbX(dwFlags), NULL, 0);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_GetInitParms |
 *
 *          Ask the device driver (or emulation) for
 *          VJOYD initialization parameters.
 *
 *          In emulation, we assume the internal and external
 *          IDs are equal (because they may as well be),
 *          that no flags are set, and there are no versions.
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The external joystick number.
 *
 *  @parm   PVXDINITPARMS | pvip |
 *
 *          Receives assorted information.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_GetInitParms(DWORD dwExternalID, PVXDINITPARMS pvip)
{
    HRESULT hres;

    if ((g_flEmulation & DIEMFL_JOYSTICK) ||
         FAILED(hres = IoctlHw(IOCTL_JOY_GETINITPARMS,
                               &dwExternalID, cbX(dwExternalID),
                               pvip, cbX(*pvip))) ||
         FAILED(hres = pvip->hres)) {

        /*
         *  Do it the emulation way.
         */

         ZeroX(*pvip);
         pvip->dwId = dwExternalID;
         hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | Hel_Joy_GetAxisCaps |
 *
 *          Obtain a bitmask of the axes supported by the joystick.
 *          If VJOYD won't tell us, then we figure it out from the
 *          registry structure passed in.
 *
 *  @parm   DWORD | dwExternalID |
 *
 *          The external joystick number.
 *
 *  @parm   PVXDAXISCAPS | pvac |
 *
 *          Structure to receive the axis capabilities.
 *
 *  @parm   LPJOYREGHWCONFIG | phwc |
 *
 *          The joystick settings as reported by the registry.
 *
 *****************************************************************************/

HRESULT EXTERNAL
Hel_Joy_GetAxisCaps
(
    DWORD dwExternalID, 
    PVXDAXISCAPS pvac, 
    LPJOYREGHWCONFIG phwc
)
{
    HRESULT hres;
    DWORD   dwRegAxes;

    /*
     *  Every joystick has an X and Y (no way to tell)
     *  Mark as position axes or they won't count!
     */
    dwRegAxes = JOYPF_X | JOYPF_Y | JOYPF_POSITION;

    if (phwc->hws.dwFlags & JOY_HWS_HASZ) {
        dwRegAxes |= JOYPF_Z;
    }

    if ( (phwc->hws.dwFlags & JOY_HWS_HASR) || (phwc->dwUsageSettings & JOY_US_HASRUDDER) ){
        dwRegAxes |= JOYPF_R;
    }

    if (phwc->hws.dwFlags & JOY_HWS_HASU) {
        dwRegAxes |= JOYPF_U;
    }

    if (phwc->hws.dwFlags & JOY_HWS_HASV) {
        dwRegAxes |= JOYPF_V;
    }

    if ((g_flEmulation & DIEMFL_JOYSTICK) ||
        FAILED(hres = IoctlHw(IOCTL_JOY_GETAXES,
                        &dwExternalID, cbX(dwExternalID),
                        pvac, cbX(*pvac)))) {

        /*
         *  If that didn't work, then just use the registry.
         */
        if (phwc->hws.dwFlags & JOY_HWS_HASPOV) {
            pvac->dwPos |= JOYPF_POV0;
        }


        /*
         *  Old VJOYD clients do not support velocity or any of the
         *  other stuff.
         */
        pvac->dwVel = 0;
        pvac->dwAccel = 0;
        pvac->dwForce = 0;

        hres = S_OK;
    }
    else
    {
        /*
         *  ManBug 28971:  Logitech drivers (and probably others) respond to 
         *  probing on axes for which they do not report data so set the 
         *  position axes to whatever is reported in the registry.
         *  Note this still allows multiple POVs to be picked up as only one 
         *  POV is supported by the registry flags.
         */
        pvac->dwPos &= ~JOYPF_ALLAXES;
        pvac->dwPos |= dwRegAxes;
    }

    /*
     *  CJoy_InitRing3 assumes that this never fails.
     */
    AssertF(SUCCEEDED(hres));

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dihid.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dihid.h
 *  Content:    DirectInput internal include file for HID
 *
 ***************************************************************************/

#ifndef _DIHID_H
#define _DIHID_H

/*
 *  Defines that should be in hidusage.h but are not yet
 */

#ifndef HID_USAGE_PAGE_PID
#define HID_USAGE_PAGE_PID      ( (USAGE) 0x0000f )
#endif

#ifndef HID_USAGE_PAGE_VENDOR
#define HID_USAGE_PAGE_VENDOR   ( (USAGE) 0xff00 )
#endif  

#ifndef HID_USAGE_SIMULATION_RUDDER
#define HID_USAGE_SIMULATION_RUDDER         ((USAGE) 0xBA)
#endif
#ifndef HID_USAGE_SIMULATION_THROTTLE
#define HID_USAGE_SIMULATION_THROTTLE       ((USAGE) 0xBB)
#endif
#ifndef HID_USAGE_SIMULATION_ACCELERATOR
#define HID_USAGE_SIMULATION_ACCELERATOR    ((USAGE) 0xC4)
#endif
#ifndef HID_USAGE_SIMULATION_BRAKE
#define HID_USAGE_SIMULATION_BRAKE          ((USAGE) 0xC5)
#endif
#ifndef HID_USAGE_SIMULATION_CLUTCH
#define HID_USAGE_SIMULATION_CLUTCH         ((USAGE) 0xC6)
#endif
#ifndef HID_USAGE_SIMULATION_SHIFTER
#define HID_USAGE_SIMULATION_SHIFTER        ((USAGE) 0xC7)
#endif
#ifndef HID_USAGE_SIMULATION_STEERING
#define	HID_USAGE_SIMULATION_STEERING		((USAGE) 0xC8)
#endif
#ifndef HID_USAGE_GAME_POV
#define HID_USAGE_GAME_POV                  ((USAGE) 0x20)
#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDDEVICEINFO |
 *
 *          Records information about a single hid device.
 *
 *  @field  DIOBJECTSTATICDATA | osd |
 *
 *          Standard information that identifies the device crudely.
 *
 *          The <e DIOBJECTSTATICDATA.dwDevType> field contains the
 *          device type code, used by
 *          <f CDIDEnum_Next>.
 *
 *          If the device is a HID mouse, then the remaining fields
 *          are commandeered as follows:
 *
 *          The <e DIOBJECTSTATICDATA.pcguid> field is the number
 *          of buttons on the mouse.
 *
 *          The <e DIOBJECTSTATICDATA.CreateDcb> field is the number
 *          of axes on the mouse.
 *
 *          See <f DIHid_ProbeMouse> for an explanation of why we
 *          need to do this.
 *
 *  @field  PSP_DEVICE_INTERFACE_DETAIL_DATA | pdidd |
 *
 *          Pointer to name for device to be used in <f CreateFile>.
 *
 *  @field  HKEY | hk |
 *
 *          Registry key that contains configuration information.
 *          Sadly, we must keep it open because there is no way to
 *          obtain the name of the key, and the only way to open the
 *          key is inside an enumeration.
 *
 *  @field  HKEY | hkOld |
 *
 *          Registry key that contains configuration information.
 *          This key originally pointed to the registry used in Win2k Gold. 
 *          It is to maintain compatibiltiy with Win2k Gold.
 *
 *  @field  LPTSTR | ptszId |
 *
 *          Cached device ID that allows us to access other information
 *          about the device.
 *
 *  @field  GUID | guid |
 *
 *          The instance GUID for the device.
 *
 *  @field  GUID | guidProduct | 
 *
 *          The product GUID for the device.
 *
 *	@field	WORD | ProductID |
 *
 *			The PID for the device
 *
 *	@field	WORD | VendorID |
 *
 *			The VID for the device
 *
 *
 *****************************************************************************/

typedef struct HIDDEVICEINFO
{
    DIOBJECTSTATICDATA osd;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;
    HKEY hk;
    HKEY hkOld;
    LPTSTR ptszId;
    GUID guid;
    GUID guidProduct;
    int  idJoy;
	WORD ProductID;
	WORD VendorID;
    BOOL fAttached;
} HIDDEVICEINFO, *PHIDDEVICEINFO;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDDEVICELIST |
 *
 *          Records information about all the HID devices.
 *
 *  @field  int | chdi |
 *
 *          Number of items in the list that are in use.
 *
 *  @field  int | chdiAlloc |
 *
 *          Number of items allocated in the list.
 *
 *  @field  HIDDEVICEINFO | rghdi[0] |
 *
 *          Variable-size array of device information structures.
 *
 *****************************************************************************/

typedef struct HIDDEVICELIST
{

    int chdi;
    int chdiAlloc;
    int idMaxJoy;
    HIDDEVICEINFO rghdi[0];

} HIDDEVICELIST, *PHIDDEVICELIST;

extern PHIDDEVICELIST g_phdl;

    #define cbHdlChdi(chdi)         FIELD_OFFSET(HIDDEVICELIST, rghdi[chdi])

/*
 *  We choose our starting point at 64 devices, since
 *  that's the maximum number of USB devices supported.  This
 *  avoids needless reallocs.
 */

    #define chdiMax                 64
    #define chdiInit                16

/*
 *  Tag for unused translation of object instance
 */
    #define NOREGTRANSLATION        (0x80000000)

/*
 *  VID/PID definitions used to handle analog devices
 */
    #define MSFT_SYSTEM_VID         (0x45E)
    #define MSFT_SYSTEM_PID         (0x100)
    #define ANALOG_ID_ROOT          TEXT("VID_045E&PID_01")

/*
 *  VID/PID template so that upper case hex is always used
 */
    #define VID_PID_TEMPLATE        TEXT("VID_%04X&PID_%04X")

/*
 *  Size of string in characters generated using VID_PID_TEMPLATE
 */
    #define cbszVIDPID              cA( VID_PID_TEMPLATE )


/*****************************************************************************
 *
 *      dihidenm.c - HID enumeration functions.
 *
 *****************************************************************************/

extern TCHAR g_tszIdLastRemoved[MAX_PATH]; //in dihidenm.c
extern DWORD g_tmLastRemoved;   //in dihinenm.c

STDMETHODIMP hresFindHIDInstanceGUID(PCGUID pguid, CREATEDCB *pcdcb);
STDMETHODIMP hresFindHIDDeviceInterface(LPCTSTR ptszPath, LPGUID pguidOut);

PHIDDEVICEINFO EXTERNAL phdiFindHIDInstanceGUID(PCGUID pguid);
PHIDDEVICEINFO EXTERNAL phdiFindHIDDeviceInterface(LPCTSTR ptszPath);

void EXTERNAL DIHid_BuildHidList(BOOL fForce);
void EXTERNAL DIHid_EmptyHidList(void);

BOOL EXTERNAL
    DIHid_GetDevicePath(HDEVINFO hdev,
                        PSP_DEVICE_INTERFACE_DATA pdid,
                        PSP_DEVICE_INTERFACE_DETAIL_DATA *ppdidd,
                        PSP_DEVINFO_DATA pdinf);


BOOL EXTERNAL
    DIHid_GetDeviceInstanceId(HDEVINFO hdev,
                              PSP_DEVINFO_DATA pdinf, 
                              LPTSTR *pptszId);

BOOL EXTERNAL
    DIHid_GetInstanceGUID(HKEY hk, LPGUID pguid);

    
/*****************************************************************************
 *
 *      diguid.c - GUID generation
 *
 *****************************************************************************/

void EXTERNAL DICreateGuid(LPGUID pguid);
void EXTERNAL DICreateStaticGuid(LPGUID pguid, WORD pid, WORD vid);

/*****************************************************************************
 *
 *      dihid.c
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *          We will just use the HID item index as our DirectInput
 *          internal ID number, which is in turn an index into the
 *          <t DIOBJECTDATAFORMAT> array.
 *
 *          Keyboard support requires a translation table.
 *          Other devices also a translation table so that the external 
 *          instance numbers can be made compatible with legacy ones and 
 *          so that secondary aliases can be separated from primary ones.
 *
 *          Since HID restarts the item index counter at zero for
 *          each of input, feature, and output, we need to do some
 *          adjustment so there aren't any collisions.  So we
 *          shift the features to start after the inputs, and the
 *          outputs to start after the features.
 *
 *          The <e CHid.rgdwBase> array contains the amount by which
 *          each group of HID item indexes has been shifted.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | HidP_IsValidReportType |
 *
 *          For debugging only.  Check if a value is a valid
 *          <t HIDP_REPORT_TYPE>.
 *
 *          Note that we also create a "fake" report type in which
 *          to record our collections.
 *
 *  @field  HIDP_REPORT_TYPE | type |
 *
 *          One of the values
 *          <c HidP_Input>,
 *          <c HidP_Output>,
 *          or
 *          <c HidP_Feature>.  Hopefully.
 *
 *****************************************************************************/

    #define HidP_Max            (HidP_Feature + 1)
    #define HidP_Coll           HidP_Max
    #define HidP_MaxColl        (HidP_Coll + 1)

BOOL INLINE
    HidP_IsValidReportType(HIDP_REPORT_TYPE type)
{
    CAssertF(HidP_Input == 0);
    CAssertF(HidP_Output == 1);
    CAssertF(HidP_Feature == 2);
    return type < HidP_Max;
}

/*****************************************************************************
 *
 *          There are three (overlapping) classes of HID reports.
 *
 *          InputLike - HidP_Input and HidP_Feature
 *          OutputLike - HidP_Output and HidP_Feature
 *          NothingLike - HidP_Coll
 *
 *****************************************************************************/

BOOL INLINE
    HidP_IsInputLike(HIDP_REPORT_TYPE type)
{
    return type == HidP_Input || type == HidP_Feature;
}

BOOL INLINE
    HidP_IsOutputLike(HIDP_REPORT_TYPE type)
{
    return type == HidP_Output || type == HidP_Feature;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct LMINMAX |
 *
 *          Min and max, that's all.  These are kept in structures
 *          to make logical-to-physical and physical-to-logical
 *          translations less gross.
 *
 *  @field  LONG | Min |
 *
 *          The minimum value.
 *
 *  @field  LONG | Max |
 *
 *          The maximum value.
 *
 *****************************************************************************/

typedef struct LMINMAX
{
    LONG Min;
    LONG Max;
} LMINMAX, *PLMINMAX;

typedef const LMINMAX *PCLMINMAX;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDGROUPCAPS |
 *
 *          This structure unifies the various HID caps structures
 *          <t HIDP_BUTTON_CAPS> and
 *          <t HIDP_VALUE_CAPS>.
 *
 *  @field  HIDP_REPORT_TYPE | type |
 *
 *          One of the values
 *          <c HidP_Input>,
 *          <c HidP_Output>,
 *          or
 *          <c HidP_Feature>.
 *
 *  @field  UINT | cObj |
 *
 *          Number of objects in this group.
 *
 *  @field  USAGE | UsagePage |
 *
 *          Usage page for all usages in the group.
 *
 *  @field  USAGE | UsageMin |
 *
 *          First usage described by this group.  The remaining
 *          items are numbered consecutively starting from
 *          this value.
 *
 *  @field  USHORT | StringMin |
 *
 *          String for first usage described by this group.
 *          The remaining strings are numbered consecutively
 *          starting from this value, unless the string maximum
 *          is reached, in which case all subsequent objects
 *          share that last string.
 *
 *  @field  USHORT | StringMax |
 *
 *          Last string.
 *
 *  @field  USHORT | DesignatorMin |
 *
 *          Designator for first usage described by this group.
 *          The remaining designators are numbered consecutively
 *          starting from this value, unless the designator maximum
 *          is reached, in which case all subsequent objects
 *          share that last designator.
 *
 *  @field  USHORT | DesignatorMax |
 *
 *          Last designator.
 *
 *  @field  USHORT | DataIndexMin |
 *
 *          Data index for the first usage described by this group.
 *          The remaining data index values are numbered consecutively
 *          starting from this value.
 *
 *  @field  USHORT | usGranularity |
 *
 *          If object is a POV or wheel, then contains device granularity.
 *
 *  @field  LONG | lMask |
 *
 *          Mask bits used for sign extension.  For example, if the
 *          value is 8-bits, the mask will be 0xFFFFFF80, indicating
 *          that bit 7 (0x00000080) is extended to fill the remainder
 *          of the value.
 *
 *          This field is used only by values.
 *
 *  @field  USHORT | BitSize |
 *
 *          Number of bits devoted to this value, including the sign bit.
 *
 *          ISSUE-2001/03/29-timgill structure field probably not used anywhere.
 *
 *  @field  USHORT | LinkCollection |
 *
 *          HID link collection number.
 *
 *  @field  LMINMAX | Logical |
 *
 *          Logical minimum and maximum values.
 *          These are the extremes of raw values
 *          that can validly be received from the device.
 *
 *          This field is used only by values.
 *
 *  @field  LMINMAX | Physical |
 *
 *          Physical minimum and maximum values.
 *          This is the "actual" value
 *          that the logical minimum and maximum value corresponds to.
 *
 *          This field is used only by values, and is consulted
 *          only when converting between DirectInput calibration
 *          (which uses logical values) and VJOYD calibration
 *          (which uses physical values).
 *
 *  @field  LONG | Null |
 *
 *          The null value to be used for output.
 *
 *          This field is used only by values.
 *
 *  @field  ULONG | Units |
 *
 *          The HID units descriptor, if any.
 *
 *  @field  WORD | Exponent |
 *
 *          The HID unit exponent, if any.
 *
 *  @field  WORD | wReportId |
 *
 *          HID report Id
 *
 *  @field  BOOL | IsAbsolute |
 *
 *          Nonzero if the group describes absolute axes.
 *
 *          This field is used only by values.
 *
 *  @field  BOOL | IsValue |
 *
 *          Nonzero if the group describes a HID value.
 *
 *          Note that an analog pushbutton is reported by
 *          DirectInput as a <c DIDFT_BUTTON>, but is
 *          handled internally as a HID value.
 *
 *  @field  BOOL | IsAlias |
 *
 *          Nonzero if the group describes an alias.
 *
 *  @field  BOOL | IsSigned |
 *          
 *          The return data is signed. 
 *
 *  @field  BOOL | IsPolledPOV |
 *          
 *          TRUE if axis is a polled POV. 
 *
 *  @devnote New for DX6.1a
 *
 *****************************************************************************/

    #define HIDGROUPCAPS_SIGNATURE      0x47444948  /* HIDG */

typedef struct HIDGROUPCAPS
{

    D(DWORD dwSignature;)
    HIDP_REPORT_TYPE type;
    UINT    cObj;

    USAGE   UsagePage;
    USAGE   UsageMin;

    USHORT  StringMin,        StringMax;
    USHORT  DesignatorMin,    DesignatorMax;
    USHORT  DataIndexMin;

    USHORT  usGranularity;

    LONG    lMask;

    USHORT  BitSize;

    USHORT  LinkCollection;

    LMINMAX Logical;
    LMINMAX Physical;

    LONG    Null;

    ULONG   Units;
    WORD    Exponent;

    WORD    wReportId;
    BOOL    fReportDisabled;
    BOOL    Reserved;

    BOOL    IsAbsolute;
    BOOL    IsValue;
    BOOL    IsAlias;
    BOOL    IsSigned;
    
  #ifdef WINNT
    BOOL    IsPolledPOV;
  #endif

} HIDGROUPCAPS, *PHIDGROUPCAPS;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDOBJCAPS |
 *
 *          This structure contains various cached pointers for each
 *          object on the device, allowing us to get at things like
 *          the group caps and the calibration information.
 *
 *  @field  PHIDGROUPCAPS | pcaps |
 *
 *          The <t PHIDGROUPCAPS> for the group the object belongs to.
 *
 *  @field  PJOYRANGECONVERT | pjrc |
 *
 *          If non-NULL, then points to the range conversion information
 *          for the object.
 *
 *  @field  int | idata |
 *
 *          Index into the <t HIDP_DATA> array for the corresponding
 *          output/feature report,
 *          or <c -1> if the item is not in the output/feature report.
 *
 *****************************************************************************/

typedef struct HIDOBJCAPS
{
    PHIDGROUPCAPS pcaps;
    PJOYRANGECONVERT pjrc;
    int idata;
} HIDOBJCAPS, *PHIDOBJCAPS;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct HIDREPORTINFO |
 *
 *          This structure contains information that is used for
 *          parsing HID reports.
 *
 *  @field  PHIDP_DATA | rgdata |
 *
 *          Array used when parsing reports via
 *          <f HidP_GetData> or <f HidP_SetData>.  This MUST be aligned 
 *          correctly on some architechtures.
 *
 *  @field  PV | pvReport |
 *
 *          The report itself.
 *
 *  @field  int | cdataMax |
 *
 *          Number of elements in the <e HIDREPORTINFO.rgdata> array.
 *
 *  @field  int | cdataUsed |
 *
 *          Number of elements in the <e HIDREPORTINFO.rgdata> array
 *          that are actually in use.
 *
 *  @field  ULONG | cbReport |
 *
 *          Number of bytes in the report.
 *
 *  @field  BOOL | fNeedClear |
 *
 *          Nonzero if the report needs to be zero'd out because we
 *          deleted something (most likely a button) from it.
 *          The only way to delete an item from a report is to zero
 *          out the entire report and then re-add everything back in.
 *
 *  @field  BOOL | fChanged |
 *
 *          Nonzero if an element in the report has changed.
 *
 *****************************************************************************/

typedef struct HIDREPORTINFO
{
    PHIDP_DATA rgdata;
    PV pvReport;
    int cdataMax;
    int cdataUsed;
    ULONG cbReport;
    BOOL fNeedClear;
    BOOL fChanged;
} HIDREPORTINFO, *PHIDREPORTINFO;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CHid |
 *
 *          The <i IDirectInputDeviceCallback> object for HID devices.
 *
 *  @field  IDirectInputDeviceCalllback | didc |
 *
 *          The object (containing vtbl).
 *
 *  @field  PV | pvGroup2 |
 *
 *          Pointer to group 2 memory.  This field is a union with the 
 *          pointer to the first chunk of memory in the second memory group.
 *
 *  @field  HIDREPORTINFO | hriIn |
 *
 *          HID input report parsing and state.
 *
 *          This memory is the first chunk of group 2.
 *
 *  @field  HIDREPORTINFO | hriOut |
 *
 *          HID output report parsing and state.
 *
 *  @field  HIDREPORTINFO | hriFea |
 *
 *          HID feature report parsing and state.
 *
 *  @field  PV | pvPhys |
 *
 *          Pointer to physical device status information updated
 *          asynchronously by the data collection thread.
 *
 *  @field  PV | pvStage |
 *
 *          Staging area used when the HID report is parsed.
 *
 *          This memory is the last chunk of group 2.
 *
 *  @field  DWORD | cbPhys |
 *
 *          Size of the physical device state.
 *
 *  @field  VXDINSTANCE * | pvi |
 *
 *          The DirectInput instance handle.
 *
 *          HID devices always run through ring 3, which is misleadingly
 *          called "emulation".
 *
 *  @field  DWORD | dwDevType |
 *
 *          Device type code.
 *
 *  @field  LPTSTR | ptszId |
 *
 *          Setupapi device instance ID.  Used to obtain things
 *          like manufacturer name.
 *
 *  @field  LPTSTR | ptszPath |
 *
 *          Path to the device, for <f CreateFile>.
 *
 *  @field  UINT | dwAxes |
 *
 *          Number of axes on the device.
 *
 *  @field  UINT | dwButtons |
 *
 *          Number of buttons on the device.
 *
 *  @field  UINT | dwPOVs |
 *
 *          Number of POV controllers on the device.
 *
 *  @field  HANDLE | hdev |
 *
 *          Handle to the device itself.  This field is valid only
 *          while the device is acquired.
 *
 *  @field  HANDLE | hdevEm |
 *
 *          <f DuplicateHandle> of the <e CHid.hdev> which is used
 *          by the worker thread.  We need to keep this separate from
 *          the main copy to avoid race conditions between the main
 *          thread and the worker thread.
 *
 *  @field  HKEY | hkInstType |
 *
 *          Per-instance registry key that contains additional configuration
 *          information, equivalent to the joystick Type key.
 *
 *  @field  DWORD | rgdwBase[HidP_MaxColl] |
 *
 *          Array of base indices for the three HID usage classes:
 *          <c HidP_Input>, <c HidP_Output>, and <c HidP_Feature>.
 *          We hide the <c HidP_Collection> base index here, too.
 *
 *  @field  PHIDOBJCAPS | rghoc |
 *
 *          Pointer to array of
 *          <t PHIDOBJCAPS>, one for each object on the device,
 *          each of which in turn contains info about a single object.
 *
 *          This memory is allocated as part of the
 *          df.rgodf in the <t DIDATAFORMAT> structure
 *          hence should not be freed separately.
 *
 *  @field  DIDATAFORMAT | df |
 *
 *          The dynamically-generated data format based on the
 *          usages on the HID device.
 *
 *  @field  DWORD | ibButtonData |
 *
 *          The location of the button data inside the data format.
 *
 *  @field  DWORD | cbButtonData |
 *
 *          The number of bytes of button data inside the data format.
 *
 *  @field  PBYTE * | rgpbButtonMasks |
 *
 *          Pointer to a an array of pointers to byte strings to mask 
 *          the buttons relevant to a report.
 *
 *  @field  PHIDP_PREPARSED_DATA | ppd |
 *
 *          Preparsed data generated by the HID subsystem.
 *
 *  @field  PHIDGROUPCAPS | rgcaps |
 *
 *          Array of <t HIDGROUPCAPS> structures used to keep
 *          track of the various buttons, groups, and collections.
 *
 *  @field  UINT | ccaps |
 *
 *          Number of caps structures in the <e CHid.rgcaps> array.
 *
 *  @field  HIDP_CAPS | caps |
 *
 *          Cached HID caps.
 *
 *  @field  OVERLAPPED | o |
 *
 *          Overlapped I/O structure used by worker thread
 *          for reading.
 *
 *
 *  @field  PJOYRANGECONVERT | pjrcNext |
 *
 *          Pointer to the first <t JOYRANGECONVERT> structure
 *          (in a preallocated array) which has
 *          yet to be used.
 *          This structure is used for logical-to-physical
 *          range conversion (a.k.a. calibration).
 *
 *          This memory is allocated as part of the
 *          df.rgodf in the <t DIDATAFORMAT> structure
 *          hence should not be freed separately.
 *
 *          This field is used during device initialization to
 *          parcel out the <t JOYRANGECONVERT>s.  Afterwards,
 *          the field is <c NULL> if we did not create any
 *          conversion structures (hence do not need to subclass
 *          the cooperative window to catch recalibrations).
 *
 *  @field  PBYTE | rgbaxissemflags |
 *
 *          This points to an array which maps DirectInput axis 
 *          instance values to default semantic map flags.
 *
 *  @field  PINT | rgiobj |
 *
 *          This points to an array which maps DirectInput instance 
 *          values (DIDFT_GETINSTANCE) into object indices.
 *
 *  @field  PINT | rgipov |
 *
 *          If we are not a keyboard, then this is the first element in 
 *          the above array which maps povs.
 *
 *  @field  PINT | rgiaxis |
 *
 *          If we are not a keyboard, then this is the first element in 
 *          the above array which maps axes.
 *
 *  @field  PINT | rgicoll |
 *
 *          If we are not a keyboard, then this is the first element in 
 *          the above array which maps collections.
 *          //ISSUE-2001/03/29-timgill need to document keyboard case behaviour
 *
 *  @field  UINT | uiInstanceMax |
 *
 *          The number of elements in the above
 *          <f rgiobj> array.
 *
 *  @field  int | idJoy |
 *
 *          Joystick identifier for <f joyGetPosEx> and friends for
 *          legacy access.
 *
 *          This value starts out as -1, to meant that
 *          the corresponding legacy joystick is unknown.
 *          If we do something that requires the matched legacy
 *          joystick to be found, we check if the current value
 *          is still valid.  If not (either it is -1 or the cached
 *          value is stale), then we go hunt for the correct value.
 *
 *  @field  HKEY | hkType |
 *
 *          The joystick type key opened with <c MAXIMUM_ALLOWED> access.
 *          This is not per-instance; multiple instances of the same
 *          hardware share this key.
 *
 *  @field  USHORT | VendorID |
 *
 *          HID vendor ID for this device.
 *
 *  @field  USHORT | ProductID |
 *
 *          HID product ID for this device.
 *
 *  @field  HWND | hwnd |
 *
 *          The window which we have subclassed in order to watch
 *          for recalibration messages.
 *
 *  @field  BOOL | IsPolledInput |
 *
 *          Nonzero if the device has to be polled for Input data.
 *
 *  @field  BOOL | fPIDdevice |
 *
 *          Set to true if the device is found to support PID. 
 *
 *  @field  WORD | wMaxReportId | 
 *          
 *          The maximum (number) of ReportId used by the HID device.   
 *      
 *  @field  PUCHAR | pEnableReportId |
 *          
 *          Pointer to (wMaxReportId) bytes. If a reportID needs to be
 *          polled in order to get features / set Output, then that element
 *          of this array is set to 0x1.
 *
 *  @field HKEY | hkProp |
 *
 *          Extended properties for device type. Currently we keep dwFlags2 and
 *          OEMMapFile under this key.  
 *  
 *  @field  BOOL | fEnableInputReport |
 *
 *          True if Input report should be enabled for this device.
 *  
 *  @field  BOOL | fFlags2Checked |
 *
 *          True after we check the registry for Flags2 for disabling
 *          input reports.
 *
 *  @comm
 *
 *          It is the caller's responsibility to serialize access as
 *          necessary.
 *
 *****************************************************************************/

typedef struct CHid
{

    /* Supported interfaces */
    IDirectInputDeviceCallback dcb;

    union
    {
        PV            pvGroup2;
        HIDREPORTINFO hriIn;
    };

    HIDREPORTINFO hriOut;
    HIDREPORTINFO hriFea;

    PV       pvPhys;
    PV       pvStage;
    DWORD    cbPhys;

    VXDINSTANCE *pvi;

    DWORD    dwDevType;

    UINT     dwAxes;
    UINT     dwButtons;
    UINT     dwPOVs;
    UINT     dwCollections;

    HANDLE   hdev;
    HANDLE   hdevEm;

    DWORD    rgdwBase[HidP_MaxColl];
    PHIDOBJCAPS rghoc;
    DIDATAFORMAT df;

    DWORD    ibButtonData;
    DWORD    cbButtonData;
    PBYTE   *rgpbButtonMasks;

    PHIDP_PREPARSED_DATA ppd;
    PHIDGROUPCAPS rgcaps;

    PJOYRANGECONVERT pjrcNext;

    HIDP_CAPS caps;

    ED       ed;
    OVERLAPPED o;
    DWORD    dwStartRead;
    DWORD    dwStopRead;

    PBYTE    rgbaxissemflags;
    PINT     rgiobj;
    PINT     rgipov;
    PINT     rgiaxis;
    PINT     rgicoll;
    UINT     uiInstanceMax;

    LPTSTR   ptszId;
    LPTSTR   ptszPath;
    HKEY     hkInstType;
    UINT     ccaps;
    int      idJoy;

    HKEY     hkType;
    USHORT   VendorID;
    USHORT   ProductID;
    
    #define  FAILED_POLL_THRESHOLD   (0x4)
        
    HWND     hwnd;    
    
    BOOL     IsPolledInput;
    BOOL     fPIDdevice;  
    WORD     wMaxReportId[HidP_Max];
    PUCHAR   pEnableReportId[HidP_Max];

    DWORD    dwVersion;

    DIAPPHACKS  diHacks;

    HKEY     hkProp;

    BOOL     fEnableInputReport;
    BOOL     fFlags2Checked;

} CHid, CHID, *PCHID;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCHID | pchidFromPo |
 *
 *          Given an interior pointer to an <t OVERLAPPED>, retrieve
 *          a pointer to the parent <t CHid>.
 *
 *  @parm   LPOVERLAPPED | po |
 *
 *          The pointer to convert.
 *
 *****************************************************************************/

PCHID INLINE
    pchidFromPo(LPOVERLAPPED po)
{
    return pvSubPvCb(po, FIELD_OFFSET(CHid, o));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCHID | pchidFromPed |
 *
 *          Given an interior pointer to a <t CEd>, retrieve
 *          a pointer to the parent <t CHid>.
 *
 *  @parm   PED | ped |
 *
 *          The pointer to convert.
 *
 *****************************************************************************/

PCHID INLINE
    pchidFromPed(PED ped)
{
    return pvSubPvCb(ped, FIELD_OFFSET(CHid, ed));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PCHID | pchidFromPem |
 *
 *          Given a <t CEm>, wander back to the
 *          <t CHid> that spawned it.
 *
 *  @parm   PEM | pem |
 *
 *          The pointer at which to start.
 *
 *****************************************************************************/

PCHID INLINE
    pchidFromPem(PEM pem)
{
    PCHID pchid = pchidFromPed(pem->ped);
    AssertF(pemFromPvi(pchid->pvi) == pem);
    return pchid;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method UINT | CHid | ObjFromType |
 *
 *          Given a <p dwType>, extract the instance number
 *          and (if necessary) convert it to an object index.
 *          Note, the instance number will always be of the primary instance
 *          not an alias.
 *
 *  @parm   PCHID | this |
 *
 *          HID device object.
 *
 *  @parm   DWORD | dwType |
 *
 *          The type code to convert.
 *
 *  @returns
 *
 *          The object index, or an out-of-range value.
 *
 *****************************************************************************/

UINT INLINE
    CHid_ObjFromType(PCHID this, DWORD dwType)
{
    UINT uiObj = DIDFT_GETINSTANCE(dwType);

    // ISSUE-2001/03/29-timgill Range checks may be unnecessary
    // MarcAnd can we ever get the out of range value?
    //          if so, can we really run with it?
    //          if not, can these range checks be converted into Asserts?

    /*
     *  The range checking makes use of the fact that the translation 
     *  tables are taken from a contiguous memory allocation and that
     *  aliased collections are not distinguished.
     */
    if(this->rgiobj)
    {
        switch( DIDFT_GETTYPE(dwType) )
        {
        case DIDFT_RELAXIS:
        case DIDFT_ABSAXIS:
            if( &this->rgiaxis[uiObj] < this->rgicoll )
            {
                uiObj = this->rgiaxis[uiObj];
            } else
            {
                uiObj = 0xFFFFFFFF;
            }
            break;

        case DIDFT_PSHBUTTON:
        case DIDFT_TGLBUTTON:
            /*
             * If it is keyboard, this->rgiobj == this->rgipov (see CHid_MungeKeyboard).
             * So, we can't test &this->rgiobj[uiObj] < this->rgipov.
             */
            if( (GET_DIDEVICE_TYPE(this->dwDevType) == DI8DEVTYPE_KEYBOARD &&
                 uiObj < this->uiInstanceMax ) ||
                &this->rgiobj[uiObj] < this->rgipov )
            {
                uiObj = this->rgiobj[uiObj];
            } else
            {
                uiObj = 0xFFFFFFFF;
            }
            break;

        case DIDFT_POV:
            if( &this->rgipov[uiObj] < this->rgiaxis )
            {
                uiObj = this->rgipov[uiObj];
            } else
            {
                uiObj = 0xFFFFFFFF;
            }
            break;
        case (DIDFT_COLLECTION | DIDFT_NODATA):
            if( &this->rgicoll[uiObj] <= &this->rgiobj[this->uiInstanceMax] )
            {
                uiObj = this->rgicoll[uiObj];
            } else
            {
                uiObj = 0xFFFFFFFF;
            }
            break;
        case DIDFT_NODATA:
            /*
             * So far, this TYPE only shows up on Keyboard (HID_USAGE_PAGE_LED).
             */
            if( GET_DIDEVICE_TYPE(this->dwDevType) == DI8DEVTYPE_KEYBOARD &&
                 uiObj < this->uiInstanceMax )
            {
                uiObj = this->rgiobj[uiObj];
            }
            break;
        
        default:
            /*
             *  Hopefully this is just a vendor defined object but squirt
             *  in debug as these may cause problems.
             */
            SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                            TEXT("CHid_ObjFromType: dwType 0x%08x not converted"),
                            dwType );                
            break;
        }
    }
    else
    {
        SquirtSqflPtszV(sqflHidParse | sqflError,
                        TEXT("CHid_ObjFromType: Translation array missing") );
    }

    return uiObj;
}

LONG EXTERNAL
    CHid_CoordinateTransform(PLMINMAX Dst, PLMINMAX Src, LONG lVal);

#ifndef WINNT
void EXTERNAL
    CHid_UpdateVjoydCalibration(PCHID this, UINT iobj);

void EXTERNAL
    CHid_UpdateCalibrationFromVjoyd(PCHID this, UINT iobj, LPDIOBJECTCALIBRATION pCal);
#endif

/*****************************************************************************
 *
 *      dihidini.c - Device callback initialization stuff
 *
 *****************************************************************************/

#define INITBUTTONFLAG     0x10000000

HRESULT EXTERNAL CHid_InitParseData(PCHID this);

HRESULT EXTERNAL CHid_Init(PCHID this, REFGUID rguid);

HANDLE EXTERNAL CHid_OpenDevicePath(PCHID this, DWORD dwAttributes );

UINT EXTERNAL CHid_LoadCalibrations(PCHID this);

BOOL EXTERNAL CHid_IsPolledDevice( HANDLE hdev );

/*****************************************************************************
 *
 *      dihiddat.c - HID data parsing/management
 *
 *****************************************************************************/

typedef HRESULT (FAR PASCAL * SENDHIDREPORT)(PCHID this, PHIDREPORTINFO phri);

void EXTERNAL CHid_ResetDeviceData(PCHID this, PHIDREPORTINFO phri,
                                   HIDP_REPORT_TYPE type);
HRESULT EXTERNAL CHid_AddDeviceData(PCHID this, UINT uiObj, DWORD dwData);
STDMETHODIMP CHid_PrepareDeviceData(PCHID this, PHIDREPORTINFO phri);
STDMETHODIMP CHid_SendHIDReport(PCHID this, PHIDREPORTINFO phri,
                                HIDP_REPORT_TYPE type, SENDHIDREPORT SendHIDReport);

NTSTATUS EXTERNAL
    CHid_ParseData(PCHID this, HIDP_REPORT_TYPE type, PHIDREPORTINFO phri);


HRESULT EXTERNAL
    DIHid_GetRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPDIPROPHEADER pdiph);

DWORD EXTERNAL DIHid_DetectHideAndRevealFlags( PCHID this );

/*****************************************************************************
 *
 *      diemh.c - HID "emulation"
 *
 *****************************************************************************/

void EXTERNAL CEm_HID_Sync(PLLTHREADSTATE plts, PEM pem);

BOOL EXTERNAL CEm_HID_IssueRead( PCHID pchid );

#endif /* _DIHID_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dihiddat.c ===
/*****************************************************************************
 *
 *  DIHidDat.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      HID data management.
 *
 *  Contents:
 *
 *      CHid_AddDeviceData
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHidDev


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | DelDeviceData |
 *
 *          Remove an item of device data from the list.
 *
 *          We grab the last item and slide it into place, updating
 *          the various pointers as we go.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The HID report from which the item is being deleted.
 *
 *  @parm   int | idataDel |
 *
 *          The data value being deleted.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          The report type we are mangling with.
 *
 *****************************************************************************/

void INTERNAL
CHid_DelDeviceData(PCHID this, PHIDREPORTINFO phri, int idataDel,
                   HIDP_REPORT_TYPE type)
{
    DWORD dwBase = this->rgdwBase[type];
    int iobjDel = phri->rgdata[idataDel].DataIndex + dwBase;
    PHIDOBJCAPS phocDel = &this->rghoc[iobjDel];
    int idataSrc;

    SquirtSqflPtszV(sqflHidOutput,
                    TEXT("DelDeviceData(%d) - cdataUsed = %d, obj=%d"),
                    idataDel, phri->cdataUsed, iobjDel);

    AssertF(idataDel >= 0);
    AssertF(idataDel < phri->cdataUsed);
    AssertF(phri->cdataUsed > 0);

    /*
     *  Wipe out the item being deleted.
     *  Remember that the report needs to be rebuilt.
     */
    AssertF(phocDel->idata == idataDel);
    phocDel->idata = -1;
    phri->fNeedClear = TRUE;

    /*
     *  Slide the top item into its place.
     */
    idataSrc = (int)--(phri->cdataUsed);
    if (idataSrc > idataDel) {
        int iobjSrc;
        PHIDOBJCAPS phocSrc;

        AssertF(idataSrc > 0 && idataSrc < phri->cdataMax);

        iobjSrc = phri->rgdata[idataSrc].DataIndex + dwBase;
        phocSrc = &this->rghoc[iobjSrc];

        AssertF(phocSrc->idata == idataSrc);

        phocSrc->idata = idataDel;
        phri->rgdata[idataDel] = phri->rgdata[idataSrc];

    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | ResetDeviceData |
 *
 *          Clean out all old device data from the list.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The HID report which should be reset.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          The report type we are mangling with.
 *
 *****************************************************************************/

void EXTERNAL
CHid_ResetDeviceData(PCHID this, PHIDREPORTINFO phri, HIDP_REPORT_TYPE type)
{
    SquirtSqflPtszV(sqflHidOutput,
                    TEXT("ResetDeviceData(%d) - cdataUsed = %d"),
                    type, phri->cdataUsed);

    if (phri->cdataUsed) {
        int idata;
        DWORD dwBase = this->rgdwBase[type];

        phri->fNeedClear = TRUE;
        for (idata = 0; idata < phri->cdataUsed; idata++) {
            int iobj = phri->rgdata[idata].DataIndex + dwBase;
            PHIDOBJCAPS phoc = &this->rghoc[iobj];

            AssertF(phoc->idata == idata);
            phoc->idata = -1;
        }

        phri->cdataUsed = 0;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | AddDeviceData |
 *
 *          Add (or replace) a piece of device data to the array.
 *
 *          If we are removing a button, then we delete it, because
 *          the HID way of talking about a button is "If you don't
 *          talk about it, then it isn't set."
 *
 *  @parm   UINT | uiObj |
 *
 *          The object being added.
 *
 *  @parm   DWORD | dwData |
 *
 *          The data value to add.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_REPORTFULL>: Too many items are set in the report.
 *          ISSUE-2001/03/29-timgill Need more return code clarification
 *
 *****************************************************************************/

HRESULT EXTERNAL
CHid_AddDeviceData(PCHID this, UINT uiObj, DWORD dwData)
{
    HRESULT hres;
    LPDIOBJECTDATAFORMAT podf;

    AssertF(uiObj < this->df.dwNumObjs);

    podf = &this->df.rgodf[uiObj];

    if (podf->dwType & DIDFT_OUTPUT) {
        PHIDOBJCAPS phoc = &this->rghoc[uiObj];
        PHIDGROUPCAPS pcaps = phoc->pcaps;
        PHIDREPORTINFO phri;

		// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqflHidOutput,
                        TEXT("CHid_AddDeviceData(%p, %d, %d) - type %d"),
                        this, uiObj, dwData, pcaps->type);

        /*
         *  Decide if it's HidP_Output or HidP_Feature.
         */
        AssertF(HidP_IsOutputLike(pcaps->type));

        switch (pcaps->type) {
        case HidP_Output:  phri = &this->hriOut; break;
        case HidP_Feature: phri = &this->hriFea; break;
        default:           AssertF(0); hres = E_FAIL; goto done;
        }

        AssertF(phri->cdataUsed <= phri->cdataMax);
        if (phoc->idata == -1) {
            SquirtSqflPtszV(sqflHidOutput,
                            TEXT("CHid_AddDeviceData - no iData"));

        } else {
            AssertF(phoc->idata < phri->cdataUsed);
            AssertF(uiObj == phri->rgdata[phoc->idata].DataIndex +
                                         this->rgdwBase[pcaps->type]);
            SquirtSqflPtszV(sqflHidOutput,
                            TEXT("CHid_AddDeviceData - iData = %d ")
                            TEXT("DataIndex = %d"),
                            phoc->idata,
                            phri->rgdata[phoc->idata].DataIndex);
        }

        phri->fChanged = TRUE;

        if (pcaps->IsValue) {
            /*
             *  Just swipe the value.
             *  The fallthrough code will handle this.
             */
        } else {
            /*
             *  If the button is being deleted, then delete it
             *  and that's all.
             */
            if (dwData == 0) {
                if (phoc->idata >= 0) {
                    CHid_DelDeviceData(this, phri, phoc->idata, pcaps->type);
                    AssertF(phoc->idata == -1);
                } else {
                    SquirtSqflPtszV(sqflHidOutput,
                                    TEXT("CHid_AddDeviceData - nop"));
                }
                hres = S_OK;
                goto done;
            } else {
                dwData = TRUE;  /* HidP_SetData requires this for buttons */
            }
        }

        /*
         *  If there is not already a slot for this item, then
         *  find one.
         */
        if (phoc->idata < 0) {
            if (phri->cdataUsed < phri->cdataMax) {
                USHORT DataIndex;

                phoc->idata = phri->cdataUsed++;

                DataIndex = (USHORT)(uiObj - this->rgdwBase[pcaps->type]);
                phri->rgdata[phoc->idata].DataIndex = DataIndex;

                SquirtSqflPtszV(sqflHidOutput,
                                TEXT("CHid_AddDeviceData - create iData = %d ")
                                TEXT("DataIndex = %d"),
                                phoc->idata,
                                DataIndex);
            } else {
                RPF("SendDeviceData: No room for more data");
                hres = DIERR_REPORTFULL;
                goto done;
            }
        }

        AssertF(phri->cdataUsed <= phri->cdataMax);
        AssertF(phoc->idata >= 0 && phoc->idata < phri->cdataUsed);
        AssertF(uiObj == phri->rgdata[phoc->idata].DataIndex +
                                     this->rgdwBase[pcaps->type]);

        /*
         *  Here it comes... The entire purpose of this function
         *  is the following line of code...  (Well, not the
         *  *entire* purpose, but 90% of it...)
         */
        phri->rgdata[phoc->idata].RawValue = dwData;

        SquirtSqflPtszV(sqflHidOutput,
                        TEXT("CHid_AddDeviceData - iData(%d) dwData = %d"),
                        phoc->idata, dwData);

        hres = S_OK;
    done:;

    } else {
        RPF("SendDeviceData: Object %08x is not DIDFT_OUTPUT",
            podf->dwType);
        hres = E_INVALIDARG;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SendHIDReport |
 *
 *          Build up an output or feature report and send it.
 *          If the report has not changed, then do nothing.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          Describes the HID report we should build.
 *
 *  @parm   OUTPUTHIDREPORT | OutputHIDReport |
 *
 *          Output a HID report to wherever it's supposed to go.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          The report type being sent.
 *          <c HidP_Output> or <c HidP_Feature>.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully
 *          and the report is ready to be sent to the device.
 *
 *          <c DIERR_REPORTFULL>: Too many items are set in the report.
 *
 *  @cb     HRESULT CALLBACK | SendHIDReportProc |
 *
 *          An internal callback which takes a composed HID report
 *          and sends it in the appropriate manner to the device.
 *
 *  @parm   PCHID | this |
 *
 *          The device in question.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The report being sent.
 *
 *****************************************************************************/

STDMETHODIMP
CHid_SendHIDReport(PCHID this, PHIDREPORTINFO phri, HIDP_REPORT_TYPE type,
                   SENDHIDREPORT SendHIDReport)
{
    HRESULT hres = S_OK;
    DWORD cdata;
    NTSTATUS stat;

    if (phri->fChanged) {

        if (phri->fNeedClear) {
            ZeroMemory(phri->pvReport, phri->cbReport);
            phri->fNeedClear = FALSE;
        }

        cdata = phri->cdataUsed;
        stat = HidP_SetData(type, phri->rgdata, &cdata, this->ppd,
                            phri->pvReport, phri->cbReport);
        if (SUCCEEDED(stat) && (int)cdata == phri->cdataUsed) {
            if ( SUCCEEDED( hres = SendHIDReport(this, phri) ) ) {
                phri->fChanged = FALSE;
            }
        } else if (stat == HIDP_STATUS_BUFFER_TOO_SMALL) {
            hres = DIERR_REPORTFULL;
        } else {
            RPF("SendDeviceData: Unexpected HID failure");
            hres = E_FAIL;
        }

    } else {
        /* Vacuous success */
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method NTSTATUS | CHid | ParseData |
 *
 *          Parse a single input report and set up the
 *          <e CHid.pvStage> buffer to contain the new device state.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          HID report type being parsed.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          Information that tells us how to parse the report.
 *
 *****************************************************************************/

NTSTATUS INTERNAL
CHid_ParseData(PCHID this, HIDP_REPORT_TYPE type, PHIDREPORTINFO phri)
{
    NTSTATUS stat = E_FAIL;

    /*
     *  Do this only if there are inputs at all.  This avoids
     *  annoying boundary conditions.
     */
    UCHAR uReportId;
    ULONG cdataMax = phri->cdataMax;

    if (cdataMax && phri->cbReport) {
        
        uReportId = *(UCHAR*)phri->pvReport;
        
        if( uReportId <  this->wMaxReportId[type] &&
            *(this->pEnableReportId[type]  + uReportId) )
        {

            stat = HidP_GetData(type, phri->rgdata, &cdataMax,
                                this->ppd, phri->pvReport, phri->cbReport);

            if (SUCCEEDED(stat)) {
                ULONG idata;

                /*
                 *  If we successfully got stuff, then wipe out the old
                 *  buttons and start with new ones.
                 *
                 *  HID data parsing rules differ from buttons to axes.
                 *  For buttons, the rule is that if it isn't in the
                 *  report, then the button isn't presed.
                 *
                 *  Compare axes, where the rule is that if it isn't
                 *  in the report, then the value is unchanged.
                 *  
                 *  To avoid deleting buttons that are reported in reports 
                 *  other than the one just received we check for multiple 
                 *  reports during initialization and if necessary set up mask 
                 *  arrays for the buttons.  The mask is an arrays of bytes of 
                 *  the same length as the button data, one for each report 
                 *  that contains any buttons.  If the device only has one 
                 *  report there are no mask arrays so we can optimize by just 
                 *  zeroing all the buttons.  If the device has multiple 
                 *  reports there is an array of pointers to the mask arrays, 
                 *  if a report has no buttons, the pointer is NULL so no 
                 *  further processing is required.  For reports that do have 
                 *  buttons, each byte in the button data is ANDed with the 
                 *  corresponding byte in the mask so that only buttons in 
                 *  the received report are zeroed.
                 */
                if( this->rgpbButtonMasks == NULL )
                {
                    /*
                     *  Only one report so just zero all buttons
                     *  This is the normal case so it is important that this 
                     *  be done as quickly as possible.
                     */
                    ZeroMemory(pvAddPvCb(this->pvStage, this->ibButtonData),
                               this->cbButtonData);
                }
                else
                {
                    if( this->rgpbButtonMasks[uReportId-1] != NULL )
                    {
                        /*
                         *  ISSUE-2001/05/12-MarcAnd  Could mask buttons faster
                         *  If we do this often, we could consider doing masks 
                         *  with multiple bytes in each opperation.
                         */

                        PBYTE pbMask;
                        PBYTE pbButtons;
                        PBYTE pbButtonEnd = pvAddPvCb(this->pvStage, this->ibButtonData + this->cbButtonData);
                        for( pbMask = this->rgpbButtonMasks[uReportId-1],
                             pbButtons = pvAddPvCb(this->pvStage, this->ibButtonData);
                             pbButtons < pbButtonEnd;
                             pbMask++, pbButtons++ )
                        {
                            *pbButtons &= *pbMask;
                        }
                    }
                    else
                    {
                        /*
                         *  No buttons in this report
                         */
                    }
                }

                for (idata = 0; idata < cdataMax; idata++) {

                    UINT uiObj;
                    PHIDGROUPCAPS pcaps;

                    /*
                     *  Be careful and make sure that HID didn't
                     *  give us anything with a bogus item index.
                     *
                     *  ISSUE-2001/03/29-timgill Not Feature-friendly.
                     */
                    AssertF(this->rgdwBase[HidP_Input] == 0);

                    SquirtSqflPtszV(sqfl | sqflTrace,
                            TEXT("HidP_GetData: %2d -> %d"),
                            phri->rgdata[idata].DataIndex,
                            phri->rgdata[idata].RawValue);

                    uiObj = this->rgdwBase[type] + phri->rgdata[idata].DataIndex;

                    if (uiObj < this->df.dwNumObjs &&
                        (pcaps = this->rghoc[uiObj].pcaps) &&
                        pcaps->type == type) {
                        LPDIOBJECTDATAFORMAT podf;
                        LONG lValue = (LONG)phri->rgdata[idata].RawValue;

                        /*
                         *  Sign-extend the raw value if necessary.
                         */
                        if (lValue & pcaps->lMask ) {
                            if( pcaps->IsSigned) 
                                lValue |= pcaps->lMask;
                            else
                                lValue &= pcaps->lMask;
                        }

                        if (HidP_IsOutputLike(pcaps->type)) {
                            HRESULT hres;
                            hres = CHid_AddDeviceData(this, uiObj, lValue);
                            AssertF(SUCCEEDED(hres));
                        }

                        podf = &this->df.rgodf[uiObj];

                        if (!pcaps->IsValue) {
                            LPBYTE pb = pvAddPvCb(this->pvStage, podf->dwOfs);
                            AssertF(lValue);
                            *pb = 0x80;

                        } else {

                            LONG UNALIGNED *pl = pvAddPvCb(this->pvStage, podf->dwOfs);

                            // ISSUE-2001/03/29-timgill need to consider how logical/physical mapping can alter scaling

                            if (podf->dwType & DIDFT_RELAXIS) {
                                if (pcaps->usGranularity) {
                                    lValue = -lValue * pcaps->usGranularity;
                                }

                                *pl += lValue;
                            } else if ( (podf->dwType & DIDFT_ABSAXIS) 
                                      #ifdef WINNT
                                        || ((podf->dwType & DIDFT_POV) && pcaps->IsPolledPOV) 
                                      #endif
                            ) {
                                PJOYRANGECONVERT pjrc;
                                *pl = lValue;

                                /*
                                 *  Apply the ramp if any.
                                 */
                                pjrc = this->rghoc[uiObj].pjrc;
                                if( pjrc 
                                 && !( this->pvi->fl & VIFL_RELATIVE ) ) 
                                {
                                    CCal_CookRange(pjrc, pl);
                                }
                            } else if (podf->dwType & DIDFT_BUTTON) {

                                /*
                                 *  Current applications do not expect any values 
                                 *  other than zero and 0x80.  Just in case 
                                 *  someone has implemented an analog button the 
                                 *  way we had suggested, make sure we any value 
                                 *  greater than or equal to half pressed reports 
                                 *  0x80 and anything else reports as zero.
                                 *  Note, out of range values default to zero.
                                 */
                                if( ( lValue <= pcaps->Logical.Max )
                                 && ( ( lValue - pcaps->Logical.Min ) >= 
                                      ( ( ( pcaps->Logical.Max - pcaps->Logical.Min ) + 1 ) / 2 ) ) )
                                {
                                    *((PBYTE)pl) = 0x80;
                                }
                                else
                                {
                                    *((PBYTE)pl) = 0;
                                }

                            } else if (podf->dwType & DIDFT_POV) {
                                /*
                                 *  For (non-polled) POVs, an out of range value 
                                 *  is a NULL aka centered.  Otherwise work out 
                                 *  the angle from the fraction of the circle.
                                 */
                                if (lValue < pcaps->Logical.Min ||
                                    lValue > pcaps->Logical.Max) {
                                    *pl = JOY_POVCENTERED;
                                } else {
                                    lValue -= pcaps->Logical.Min;
                                    *pl = lValue * pcaps->usGranularity;
                                }
                            }

                        }
                    } else {
                        SquirtSqflPtszV(sqfl | sqflTrace,
                                TEXT("HidP_GetData: Unable to use data element"));
                    }
                }
                stat = S_OK;
            }
            stat = S_OK;
        }
    } else {
        stat = E_FAIL;    
    }
    return stat;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dihidini.c ===
/*****************************************************************************
 *
 *  DIHidIni.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The initialization-related functions of the HID device callback.
 *
 *      All the HID support is getting kind of bulky, so I've broken
 *      it out into submodules.
 *
 *  Contents:
 *
 *      CHid_Init
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHidIni


/*****************************************************************************
 *
 *      Hid devices are totally arbitrary, so there is nothing static we
 *      can cook up to describe them.  We generate all the information on
 *      the fly.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | CHid_LoadCalibrations |
 *
 *          Load calibration information from the registry (or wherever).
 *          This is done when the device is created, and whenever we
 *          receive a recalibration message.
 *
 *  @returns
 *
 *          Returns the number of axes we calibrated.  This information
 *          is used during device initialization to see if we need to
 *          worry about calibration in the future.
 *
 *****************************************************************************/

UINT EXTERNAL
    CHid_LoadCalibrations(PCHID this)
{
    UINT uiObj;
    UINT uiRc = 0;

    /*
     *  Preinitialize the HIDP_DATA indices to -1 to indicate
     *  that they aren't there.  We must do this before we
     *  mess with AddDeviceData, which assumes that all the
     *  indices are properly set up.
     */
    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        PJOYRANGECONVERT pjrc = this->rghoc[uiObj].pjrc;
        PHIDGROUPCAPS pcaps = this->rghoc[uiObj].pcaps;
        if(pjrc && pcaps)
        {
            LPDIOBJECTDATAFORMAT podf = &this->df.rgodf[uiObj];
            DIOBJECTCALIBRATION cal;
          #ifdef WINNT
            DIPOVCALIBRATION pov;
          #endif
            D(LPCTSTR ptszWhence;)

            /*
             *  Note, we do not have to deal with mice on Win2k, yet...
             */
          #ifdef WINNT
            HRESULT hres;
            HKEY hk;

            D( ptszWhence = TEXT("unknown") );
            
            if( podf->dwType & DIDFT_POV ) 
            {
                if( pcaps->IsPolledPOV )  {
                    ZeroX( pov );
                    hres = CType_OpenIdSubkey(this->hkInstType, podf->dwType,
                                              KEY_QUERY_VALUE, &hk);
                    if(SUCCEEDED(hres))
                    {
                        hres = JoyReg_GetValue(hk, TEXT("Calibration"),
                                               REG_BINARY, &pov,
                                               cbX(DIPOVCALIBRATION));
                        RegCloseKey(hk);
                    }
                }
            } else
            {
                ZeroX( cal );
    
                hres = CType_OpenIdSubkey(this->hkInstType, podf->dwType,
                                          KEY_QUERY_VALUE, &hk);
    
                if(SUCCEEDED(hres))
                {
                    hres = JoyReg_GetValue(hk, TEXT("Calibration"),
                                           REG_BINARY, &cal,
                                           cbX(DIOBJECTCALIBRATION));
                    RegCloseKey(hk);
                }
    
                /*
                 *  If there is no calibration data, then create
                 *  some defaults based on the logical min/max.
                 */
                if(FAILED(hres))
                {
                    /*
                     *  But only if the logical min/max is sane!
                     */
                    if(pcaps->Logical.Min < pcaps->Logical.Max)
                    {
                        cal.lMin = pcaps->Logical.Min;
                        /*
                         *  HACKHACK
                         *  The analog joystick driver cannot report the true 
                         *  range of the device, so to keep the sample driver 
                         *  pure, it reports a range of zero to the point at 
                         *  which it would consider the axis absent.  This is
                         *  good in terms of reporting healthy HID data but 
                         *  it means that any normal joystick will only return 
                         *  values in a fraction of this range.  So if this 
                         *  device is an analog device default the calibration 
                         *  to the typical range.
                         */
                        if( ( this->VendorID == MSFT_SYSTEM_VID )
                          &&( ( this->ProductID & 0xff00 ) == MSFT_SYSTEM_PID ) )
                        {
                            /*
                             *  To be extra safe, compute the max from the 
                             *  reported range.  The divisor is a fudge factor 
                             *  derived by what looked about right to MarcAnd.
                             */
                            cal.lMax = pcaps->Logical.Min + 
                                ( ( pcaps->Logical.Max - pcaps->Logical.Min ) / 11 );
                            D(ptszWhence = TEXT("log (adj)"));
                        }
                        else
                        {
                            cal.lMax = pcaps->Logical.Max;
                            D(ptszWhence = TEXT("log"));
                        }
                    } else
                    {
                        D(ptszWhence = TEXT("def"));
                        cal.lMin = 0;
                        cal.lMax = 655;
                    }
                    cal.lCenter = CCal_Midpoint(cal.lMin, cal.lMax);
                } else
                {
                    D(ptszWhence = TEXT("reg"));
                }
            }

          #else
            if( GET_DIDEVICE_TYPE(this->dwDevType) == DI8DEVTYPE_MOUSE )
            {
                if( this->df.rgodf[uiObj].dwType & DIDFT_ABSAXIS )
                {
                    if(pcaps->Logical.Min < pcaps->Logical.Max)
                    {
                        cal.lMin = pcaps->Logical.Min;
                        cal.lMax = pcaps->Logical.Max;
                        D(ptszWhence = TEXT("mouse log"));
                    }
                    else
                    {
                        /* 
                         *  Absolute mice traditionally report 0 - 64K 
                         */
                        cal.lMin = 0;
                        cal.lMax = 65535;   
                        D(ptszWhence = TEXT("mouse def"));
                    }
                    cal.lCenter = CCal_Midpoint(cal.lMin, cal.lMax);
                }
            } else if ( this->idJoy < 0 ) //See manbug 50591
            {
                HRESULT hres;
                HKEY hk;
                
                ZeroX( cal );
    
                hres = CType_OpenIdSubkey(this->hkInstType, podf->dwType,
                                          KEY_QUERY_VALUE, &hk);
    
                if(SUCCEEDED(hres))
                {
                    hres = JoyReg_GetValue(hk, TEXT("Calibration"),
                                           REG_BINARY, &cal,
                                           cbX(DIOBJECTCALIBRATION));
                    RegCloseKey(hk);
                } else {
                    /*
                     *  But only if the logical min/max is sane!
                     */
                    if(pcaps->Logical.Min < pcaps->Logical.Max)
                    {
                        cal.lMin = pcaps->Logical.Min;
                        cal.lMax = pcaps->Logical.Max;
                    } else
                    {
                        cal.lMin = 0;
                        cal.lMax = 655; //best guess
                    }

                    cal.lCenter = CCal_Midpoint(cal.lMin, cal.lMax);
                }
            } else
            {
                ZeroX( cal );
    
                /*
                 * Because the CPL on Win9x only updates calibration in MediaResources,
                 * We need read that calibration information and update for HID.
                 */
                CHid_UpdateCalibrationFromVjoyd(this, uiObj, &cal);

                D(ptszWhence = TEXT("WinMM Reg"));
            }
          #endif

          #ifdef WINNT
            if( podf->dwType & DIDFT_POV )
            {
                if( pcaps->IsPolledPOV )  {
                    memcpy( pjrc->lMinPOV, pov.lMin, cbX(pjrc->lMinPOV) );
                    memcpy( pjrc->lMaxPOV, pov.lMax, cbX(pjrc->lMaxPOV) );
                }
            } else 
          #endif
            {
                D(SquirtSqflPtszV(sqflHidParse,
                                  TEXT(" Calibration(%d) %s %d..%d..%d"),
                                  CHid_ObjFromType(this, podf->dwType), ptszWhence,
                                  cal.lMin, cal.lCenter, cal.lMax));
    
                /*
                 *  Saturation always defaults to 100%.
                 */
                pjrc->dwPmin = cal.lMin;
                pjrc->dwPmax = cal.lMax;
                pjrc->dwPc   = cal.lCenter;
    
                if( pjrc->dwCPointsNum == 0 ) {
                    //use two control points by default
                    pjrc->dwCPointsNum = 2;
                    pjrc->cp[0].lP = pjrc->dwPmin;
                    pjrc->cp[0].dwLog = 0;
                    pjrc->cp[1].lP = pjrc->dwPmax;
                    pjrc->cp[1].dwLog = RANGEDIVISIONS;
                } else {
                    pjrc->cp[0].lP = pjrc->dwPmin;
                    pjrc->cp[pjrc->dwCPointsNum-1].lP = pjrc->dwPmax;
                }
            
                CCal_RecalcRange(pjrc);
    
                uiRc++;
            }
        }
    }

    return uiRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CHid_SortCaps |
 *
 *          Sort the capabilities by Data Index.  This is important
 *          so that the items are assigned numbers in the same order
 *          by both DirectInput and HID.
 *
 *          Note that we exploit the not-exactly-a-coincidence
 *          that a <t HIDP_VALUE_CAPS> and a
 *          <t HIDP_BUTTON_CAPS> are identical wherever they overlap.
 *
 *  @parm   PV | rgv |
 *
 *          Array of either <t HIDP_VALUE_CAPS> or <t HIDP_BUTTON_CAPS>
 *          structures.
 *
 *  @parm   UINT | cv |
 *
 *          Number of structures that need to be sorted.
 *
 *****************************************************************************/

void INTERNAL
    CHid_SortCaps(PV rgv, UINT cv)
{
    /*
     *  For concreteness, we use HIDP_VALUE_CAPS.
     */
    PHIDP_VALUE_CAPS rgvcaps = rgv;
    UINT ivcaps;

    /*
     *  There are several non-coincidences which we exploit.
     *
     *  HIDP_VALUE_CAPS and HIDP_BUTTON_CAPS are the same size.
     *
     *  HIDP_VALUE_CAPS.Range.DataIndexMin,
     *  HIDP_VALUE_CAPS.NotRange.DataIndex,
     *  HIDP_BUTTON_CAPS.Range.DataIndexMin, and
     *  HIDP_BUTTON_CAPS.NotRange.DataIndex are all at the same offset.
     */
    CAssertF(cbX(HIDP_VALUE_CAPS) == cbX(HIDP_BUTTON_CAPS));

    /*
     *  For some reason, the compiler doesn't think that these
     *  expressions are constant so I can't use CAssertF.
     */
    AssertF(FIELD_OFFSET(HIDP_VALUE_CAPS,  NotRange.DataIndex) ==
            FIELD_OFFSET(HIDP_VALUE_CAPS,     Range.DataIndexMin));
    AssertF(FIELD_OFFSET(HIDP_VALUE_CAPS,     Range.DataIndexMin) ==
            FIELD_OFFSET(HIDP_BUTTON_CAPS,    Range.DataIndexMin));
    AssertF(FIELD_OFFSET(HIDP_BUTTON_CAPS,    Range.DataIndexMin) ==
            FIELD_OFFSET(HIDP_BUTTON_CAPS, NotRange.DataIndex));

    #ifdef REALLY_ANNOYING
    /*
     *  Dump the Before list.
     */
    for(ivcaps = 0; ivcaps < cv; ivcaps++)
    {
        SquirtSqflPtszV(sqflHidParse,
                        TEXT("HidP_SortCaps:%2d = %04x"),
                        ivcaps, rgvcaps[ivcaps].Range.DataIndexMin);
    }
    #endif

    /*
     *  Since there are typically not very many caps, we will use
     *  a simple insertion sort.
     *
     *  Note if caps entries have the same data index they are 
     *  aliases.  Make sure the primary alias will be the first
     *  in the sorted list.
     */

    for(ivcaps = 1; ivcaps < cv; ivcaps++)
    {
        int ivcapsT;
        HIDP_VALUE_CAPS vcaps = rgvcaps[ivcaps];

        ivcapsT = ivcaps;
        while( ( --ivcapsT >= 0 )
             &&( ( rgvcaps[ivcapsT].Range.DataIndexMin >
                   vcaps.Range.DataIndexMin )
               ||( ( rgvcaps[ivcapsT].Range.DataIndexMin ==
                     vcaps.Range.DataIndexMin )
                 &&( rgvcaps[ivcapsT].IsAlias ) ) ) )
        {
            rgvcaps[ivcapsT+1] = rgvcaps[ivcapsT];
        }
        rgvcaps[ivcapsT+1] = vcaps;
    }

    #ifdef REALLY_ANNOYING
    /*
     *  Dump the After list.
     */
    for(ivcaps = 0; ivcaps < cv; ivcaps++)
    {
        SquirtSqflPtszV(sqflHidParse,
                        TEXT("HidP_SortCaps:%2d = %04x"),
                        ivcaps, rgvcaps[ivcaps].Range.DataIndexMin);
    }
    #endif

    /*
     *  Assert that everything is weakly monotonically sorted.
     *
     *  If two items are equal, then it means that HID messed up 
     *  or the values are aliases.
     *  We don't complain about it here; we will notice later.
     */
    for(ivcaps = 1; ivcaps < cv; ivcaps++)
    {
        AssertF(rgvcaps[ivcaps-1].Range.DataIndexMin <=
                rgvcaps[ivcaps  ].Range.DataIndexMin);
    }
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CHid_FindAspect |
 *
 *          Try to determine the aspect flags for this value.
 *
 *  @parm   PHIDP_VALUE_CAPS | pvcaps |
 *
 *          Pointer to HID value caps to search through
 *          structures.
 *
 *  @returns
 *
 *          Flags set for the aspect if found
 *
 *  @comm
 *          Currently (08-Dec-98) most devices and drivers do not 
 *          declare units but since drivers must use the generic 
 *          position usages in order to be recognized assume that 
 *          these imply that position data is being returned.
 *
 *****************************************************************************/
DWORD CHID_FindAspect
(
    PHIDP_VALUE_CAPS    pvcaps
)
{
    DWORD               dwAspect = 0;

    if( pvcaps->Units )
    {
#define HID_UNIT_SYSTEM_MASK        0x0000000fL
#define HID_UNIT_LENGTH_MASK        0x000000f0L
#define HID_UNIT_MASS_MASK          0x00000f00L
#define HID_UNIT_TIME_MASK          0x0000f000L
        /*
         *  If available, use the units to derive the DI aspect 
         *  flags for input objects.
         */

        if( pvcaps->Units & ~( HID_UNIT_SYSTEM_MASK 
                             | HID_UNIT_LENGTH_MASK 
                             | HID_UNIT_MASS_MASK 
                             | HID_UNIT_TIME_MASK ) )
        {
            SquirtSqflPtszV(sqflTrace | sqflHidParse,
                            TEXT("Unit 0x%08x contains basic units that cannot be translated to aspects"),
                            pvcaps->Units );
        }
        else
        {
            /*
             *  The system of measurement should be one of the 
             *  four defined systems and the length must be one 
             *  dimensional.
             */
            if( ( ( pvcaps->Units & ( HID_UNIT_SYSTEM_MASK | HID_UNIT_LENGTH_MASK ) ) >= 0x11 )
              &&( ( pvcaps->Units & ( HID_UNIT_SYSTEM_MASK | HID_UNIT_LENGTH_MASK ) ) <= 0x14 ) )
            {
                switch( pvcaps->Units & ( HID_UNIT_TIME_MASK | HID_UNIT_MASS_MASK ) )
                {
                case 0x0000:
                    dwAspect = DIDOI_ASPECTPOSITION;
                    break;
                case 0xf000:
                    dwAspect = DIDOI_ASPECTVELOCITY;
                    break;
                case 0xe000:
                    dwAspect = DIDOI_ASPECTACCEL;
                    break;
                case 0xe100:
                    dwAspect = DIDOI_ASPECTFORCE;
                    break;
                default:
                    if( 0x0004 == ( pvcaps->Units & ( HID_UNIT_TIME_MASK | HID_UNIT_MASS_MASK | HID_UNIT_SYSTEM_MASK ) ) )
                    {
                        SquirtSqflPtszV(sqflTrace | sqflHidParse,
                            TEXT("Unit \"degrees\" will not be mapped to a DI aspect (probably a POV)") );
                    }
                    else
                    {
                        SquirtSqflPtszV(sqflTrace | sqflHidParse,
                                        TEXT("Unit 0x%04x represents a mass/time unit that cannot be translated to aspects"),
                                        pvcaps->Units );
                    }
                }
            }
            else
            {
                SquirtSqflPtszV(sqflTrace | sqflHidParse,
                                TEXT("Unit 0x%04x contains represents a length/system unit that cannot be translated to aspects"),
                                pvcaps->Units );                                
            }
        }

#ifdef DEBUG
        if( dwAspect )
        {
            SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                            TEXT("Unit 0x%04x translated to aspect 0x%04x"), 
                            pvcaps->Units, dwAspect );
        }
#endif

#undef HID_UNIT_SYSTEM_MASK
#undef HID_UNIT_LENGTH_MASK
#undef HID_UNIT_MASS_MASK
#undef HID_UNIT_TIME_MASK

    }
    else
    {
        PHIDUSAGEMAP phum;

        phum = UsageToUsageMap( DIMAKEUSAGEDWORD( pvcaps->UsagePage,
                                                     pvcaps->Range.UsageMin ) );

        if( phum && phum->bPosAxis <= 6 )
        {
            phum = UsageToUsageMap( DIMAKEUSAGEDWORD( pvcaps->UsagePage,
                                                         pvcaps->Range.UsageMax ) );

            if( phum && phum->bPosAxis <= 6 )
            {
                dwAspect = DIDOI_ASPECTPOSITION;
            }
        }
        else
        {
            SquirtSqflPtszV(sqflTrace | sqflHidParse,
                            TEXT("No aspect found for 0x%04x page usage 0x%04x-0x%04x"),
                            pvcaps->UsagePage, pvcaps->Range.UsageMin, pvcaps->Range.UsageMax );                                
        }        

#ifdef DEBUG
        if( dwAspect )
        {
            SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                            TEXT("Usage (page:min-max) 0x%04x:0x%04x-0x%04x translated to aspect 0x%04x"), 
                            pvcaps->UsagePage, pvcaps->Range.UsageMin, pvcaps->Range.UsageMax, dwAspect );
        }
#endif

    }

    return dwAspect;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitAxisClass |
 *
 *          Initialize one class (input, feature, output) of axes.
 *
 *  @parm   PHIDGROUPCAPS | rgcaps |
 *
 *          Array of <t HIDGROUPCAPS> structures to receive the caps
 *          of the axes in the class.
 *
 *  @parm   USHORT | ccaps |
 *
 *          Number of <t HIDGROUPCAPS> structures we expect to find.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          One of the values
 *          <c HidP_Input>,
 *          <c HidP_Feature> or
 *          <c HidP_Output>.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitAxisClass(PCHID this, PHIDGROUPCAPS rgcaps, USHORT ccaps,
                       HIDP_REPORT_TYPE type)
{
    USHORT cvcaps;
    NTSTATUS stat;
    HRESULT hres;
    DWORD ivcaps;
    LONG lSignedMask;
    PHIDP_VALUE_CAPS rgvcaps;

    AssertF(rgcaps >= this->rgcaps);
    AssertF(rgcaps + ccaps <= &this->rgcaps[this->ccaps]);

    /*
     *  Annoying quirk:
     *
     *  HID doesn't like it when you pass 0 to HidP_GetValueCaps,
     *  so we need to special-case the "no axes" scenario.
     */
    if(ccaps == 0)
    {
        hres = S_OK;
        goto done;
    }

    hres = AllocCbPpv(cbCxX(ccaps, HIDP_VALUE_CAPS), &rgvcaps);
    if(FAILED(hres))
    {
        goto done;
    }

    cvcaps = ccaps;
    stat = HidP_GetValueCaps(type, rgvcaps, &cvcaps, this->ppd);
    if(FAILED(stat))
    {
        RPF("HidP_GetValueCaps failed - can't use device");
        hres = E_FAIL;
        goto freedone;
    }

    if(cvcaps != ccaps)
    {
        RPF("HidP_GetValueCaps inconsistent with HidP_GetCaps - "
            "can't use device");
        hres = E_FAIL;
        goto freedone;
    }

    CHid_SortCaps(rgvcaps, cvcaps);

    for(ivcaps = 0; ivcaps < cvcaps; ivcaps++)
    {
        PHIDP_VALUE_CAPS pvcaps = &rgvcaps[ivcaps];
        PHIDGROUPCAPS pcaps = &rgcaps[ivcaps];
        BOOL fPOV;
        UINT uiObj;
        UINT duiObj;
        DWORD dwAspect;

        /*
         *  ISSUE-2001/03/06-MarcAnd Ignoring report count
         *  We ignore the report count which may be bad, need 
         *  to test device with values declared in a range to see what HID 
         *  really gives us.
         *  At the descriptor level, values can be delared in a range with 
         *  usages and the last usage is repeated for any excess values.  
         */
        if(pvcaps->IsRange)
        {
            if(pvcaps->Range.DataIndexMax - pvcaps->Range.DataIndexMin !=
               pvcaps->Range.UsageMax - pvcaps->Range.UsageMin)
            {
                RPF("HidP_GetValueCaps corrupted VALUE_CAPS - "
                    "can't use device");
                hres = E_FAIL;
                goto freedone;
            }

        } else
        {
            pvcaps->Range.UsageMax = pvcaps->Range.UsageMin;
        }

        if( ( type == HidP_Input ) && !pvcaps->IsAlias )
        {
            /*
             *  The values are sorted by data index with the primary alias 
             *  before any other.  So find out the aspect of the axis each 
             *  time we get a new primary and use it for any alias that follow.
             */
            dwAspect = CHID_FindAspect( pvcaps );
        }

        pcaps->wReportId          = pvcaps->ReportID;
        this->wMaxReportId[type]  = max(pcaps->wReportId, this->wMaxReportId[type]);

        pcaps->UsagePage          = pvcaps->UsagePage;
        pcaps->UsageMin           = pvcaps->Range.UsageMin;
        pcaps->DataIndexMin       = pvcaps->Range.DataIndexMin;

        pcaps->cObj               = pvcaps->Range.UsageMax -
                                    pvcaps->Range.UsageMin + 1;

        /*
         *  The mask consists of the top bit of the BitSize and          
         *  all bits above it.  Examples:
         *
         *           BitSize                     8              32  
         *           BitSize - 1                 7              31
         *     1 << (BitSize - 1)       0x00000080      0x80000000
         *    (1 << (BitSize - 1)) - 1  0x0000007F      0x7FFFFFFF
         *  ~((1 << (BitSize - 1)) - 1) 0xFFFFFF80      0x80000000
         *
         */

        pcaps->BitSize            = pvcaps->BitSize;
        pcaps->lMask              = ~((1 << (pcaps->BitSize - 1)) - 1);
        lSignedMask               =  max( 1, ( 1 << pcaps->BitSize) -1 );

        pcaps->LinkCollection     = pvcaps->LinkCollection;
        pcaps->Units              = pvcaps->Units;
        pcaps->Exponent           = LOWORD(pvcaps->UnitsExp);

        pcaps->Logical.Min        = pvcaps->LogicalMin;
        pcaps->Logical.Max        = pvcaps->LogicalMax;

        pcaps->Physical.Min       = pvcaps->PhysicalMin;
        pcaps->Physical.Max       = pvcaps->PhysicalMax;

        if(pcaps->Logical.Min >= pcaps->Logical.Max)
        {
            RPF("HidP_GetValueCaps Logical Min >= Logical Max - ");

            if( pcaps->Physical.Min < pcaps->Physical.Max )
            {
                pcaps->Logical = pcaps->Physical;
            } else
            {
                pcaps->Logical.Min = pcaps->lMask;
                pcaps->Logical.Max = ~pcaps->lMask;
            }

            SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                            TEXT("HidP_GetValueCaps:")
                            TEXT("Logical Min(was:%d now:%d)")
                            TEXT("Logical Max(was:%d now:%d)"),
                            pvcaps->LogicalMin, pcaps->Logical.Min,
                            pvcaps->LogicalMax, pcaps->Logical.Max);

        }

        /*
         *  the range for LogicalMin / LogicalMax had better fall
         *  within the range of values the device can possibly
         *  report.
         *
         *  The lMask value happens also to be the smallest possible
         *  negative value, and the bitwise negation of it happens
         *  to be the largest possible positive value.  The wonders
         *  of two-s complement arithmetic.
         */

        /* 
         *  Extra case is fix for 268519
         */
        if(pcaps->Physical.Min > pcaps->Physical.Max)
        {
            RPF("HidP_GetValueCaps Physical Min/Max(%d/%d) is bad setting all to zero to %d"
                "device may have bad firmware", pcaps->Physical.Min, pcaps->Physical.Max, lSignedMask);
            
            pcaps->Logical.Min = 0;
            pcaps->Physical.Min = 0;
            pcaps->Logical.Max = lSignedMask;
            pcaps->Physical.Max = lSignedMask;
            pcaps->lMask = lSignedMask; 
            pcaps->IsSigned = FALSE;
        }
        else
        {
            if(pcaps->Physical.Min == pcaps->Physical.Max)
            {
                pcaps->Physical = pcaps->Logical;
            }

            if(pcaps->Logical.Min >=  pcaps->lMask &&     // Logical Min / Max are signed
               pcaps->Logical.Max <= ~pcaps->lMask)
            {
                pcaps->IsSigned = TRUE; 

            } else if(pcaps->Logical.Min >= 0 && 
                      pcaps->Logical.Max <= lSignedMask  )
            {                                              // Logical Min / Max are unsigned
                pcaps->lMask = lSignedMask; 
                pcaps->IsSigned = FALSE;

            } else if (pcaps->UsagePage >= HID_USAGE_PAGE_VENDOR )
            {
                // Let this one pass, hopefully the broken descriptors are for
                // usages that are vendor specific and will not effect too many folks
                RPF("HidP_GetValueCaps Logical Min/Max(%d/%d) don't fit in BitSize(%d) - "
                    "device may have bad firmware", pcaps->Logical.Min, pcaps->Logical.Max, pcaps->BitSize);

                pcaps->Logical.Min = pcaps->lMask;
                pcaps->Logical.Max = ~pcaps->lMask;
                pcaps->IsSigned = TRUE;            

            }else
            {
                RPF("HidP_GetValueCaps UsagePage(0x%x)Usage(0x%x) Logical Min/Max(%d/%d) don't fit in BitSize(%d) - "
                    "can't use device", pcaps->UsagePage, pcaps->UsageMin, pcaps->Logical.Min, pcaps->Logical.Max, pcaps->BitSize);
                hres = E_FAIL;
                goto freedone;
            }
        }

        AssertF(pcaps->Physical.Min < pcaps->Physical.Max);

        pcaps->StringMin          = pvcaps->Range.StringMin;
        pcaps->StringMax          = pvcaps->IsStringRange ?
                                    pvcaps->Range.StringMax :
                                    pvcaps->Range.StringMin;

        pcaps->DesignatorMin      = pvcaps->Range.DesignatorMin;
        pcaps->DesignatorMax      = pvcaps->IsDesignatorRange ?
                                    pvcaps->Range.DesignatorMax :
                                    pvcaps->Range.DesignatorMin;

        pcaps->IsAbsolute         = pvcaps->IsAbsolute;
        pcaps->IsValue            = TRUE;
        pcaps->IsAlias            = pvcaps->IsAlias;
        pcaps->type               = type;

        /*
         *  HID reports axes and POVs as the same thing, and the two 
         *  POV usages we recognize are in different pages, so you 
         *  will never get multiple POVs coming through in a single 
         *  value-caps.
         *
         *  ISSUE-2001/03/06-MarcAnd POVs within caps are treated as axes
         *  There is, however, the problem of a POV buried inside
         *  a larger value-cap that describes axes.  Tough.  Those
         *  POVs are in trouble.
         */

#define HID_USAGE_GAME_POV                          ((USAGE) 0x20)

        fPOV = pcaps->cObj == 1 
                           && ( ( pcaps->UsagePage == HID_USAGE_PAGE_GENERIC 
                                &&pcaps->UsageMin == HID_USAGE_GENERIC_HATSWITCH )
                              ||( pcaps->UsagePage == HID_USAGE_PAGE_GAME 
                                &&pcaps->UsageMin == HID_USAGE_GAME_POV ) );


        if(fPOV)
        {
            LONG lUnits;

            /*
             *  POVs are assumed to start at north and increase
             *  clockwise through the logical maximum.
             */
            lUnits = pcaps->Logical.Max - pcaps->Logical.Min + 1;
            if(lUnits)
            {
                pcaps->usGranularity = (USHORT)(36000U / lUnits);
            }
        } else
        {
            if( ( pcaps->UsagePage == HID_USAGE_PAGE_GENERIC &&
                  pcaps->UsageMin <= HID_USAGE_GENERIC_HATSWITCH &&
                  pvcaps->Range.UsageMax >= HID_USAGE_GENERIC_HATSWITCH )
              ||( pcaps->UsagePage == HID_USAGE_PAGE_GAME &&
                  pcaps->UsageMin <= HID_USAGE_GAME_POV &&
                  pvcaps->Range.UsageMax >= HID_USAGE_GAME_POV ) )
            {
                SquirtSqflPtszV(sqflHidParse | sqflError,
                                TEXT("HidP_GetValueCaps - multi-usage cap ")
                                TEXT("includes hatswitch or POV - will be treated")
                                TEXT("as axis"));
            }
        }

#undef HID_USAGE_GAME_POV

        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Objs = %d"),
                        type, ivcaps, pcaps->cObj);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Index %d ..."),
                        type, ivcaps,
                        pcaps->DataIndexMin);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Logical = %d..%d"),
                        type, ivcaps,
                        pcaps->Logical.Min, pcaps->Logical.Max);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Physical = %d..%d"),
                        type, ivcaps,
                        pcaps->Physical.Min, pcaps->Physical.Max);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: Units = 0x%08x"),
                        type, ivcaps,
                        pcaps->Units);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: IsAbs = %d"),
                        type, ivcaps,
                        pcaps->IsAbsolute);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: BitSize = %d"),
                        type, ivcaps,
                        pcaps->BitSize);
        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetValueCaps(%d)[%d]: IsAlias = %d"),
                        type, ivcaps,
                        pcaps->IsAlias);
        if(pcaps->LinkCollection)
        {
            SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                            TEXT("HidP_GetValueCaps(%d)[%d]: ")
                            TEXT("LinkCollection %d"),
                            type, ivcaps,
                            pcaps->LinkCollection);
        }

        /*
         *  Come up with a decent Null value if possible.
         *  The traditional Null value is the arithmetically
         *  smallest value which lies outside the
         *  LogicalMin/LogicalMax range.  Conveniently, the
         *  pcaps->lMask is the most negative value that is
         *  in range.
         */
        AssertF(pcaps->Null == 0);
        if(pvcaps->HasNull)
        {
          #ifdef WINNT
            pcaps->IsPolledPOV = FALSE;
          #endif
          
            if(pcaps->lMask < pcaps->Logical.Min)
            {
                pcaps->Null = pcaps->lMask;
            } else if(!(pcaps->lMask & (pcaps->Logical.Max + 1)))
            {
                pcaps->Null = pcaps->Logical.Max + 1;
            } else if( ! pcaps->IsSigned )
            {
                pcaps->Null = 0x0;
            } else
            {
                SquirtSqflPtszV(sqflTrace,
                                TEXT("VALUE_CAPS claims Null but no room!"));
            }
            SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                            TEXT("HidP_GetValueCaps(%d)[%d]: Null = %d"),
                            type, ivcaps,
                            pcaps->Null);
        } else {
          #ifdef WINNT
            if( fPOV &&
                (this->VendorID == MSFT_SYSTEM_VID ) &&
                ( (this->ProductID & 0xff00) == MSFT_SYSTEM_PID) )
            {
                LONG lUnits;

                lUnits = pcaps->Logical.Max - pcaps->Logical.Min + 1;
                if(lUnits)
                {
                    pcaps->usGranularity = (USHORT)9000;
                }

                pcaps->IsPolledPOV = TRUE;

                SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                                TEXT("HidP_GetValueCaps(%d)[%d]: Null = %d (Polled POV)."),
                                type, ivcaps,
                                pcaps->Null);
            }
          #endif
        }

        uiObj = this->rgdwBase[type] + pcaps->DataIndexMin;
        for(duiObj = 0; duiObj < pcaps->cObj; duiObj++)
        {
            DWORD dwObjType;
            LPDIOBJECTDATAFORMAT podf;

            /*
             *  If HID messed up and gave us something out of range,
             *  then give up on this value caps (since the rest are
             *  also out of range) and move on to the next one.
             */
            if(uiObj + duiObj >= this->df.dwNumObjs)
            {
                RPF("HidP_GetValueCaps inconsistent with NumberDataIndices - "
                    "skipping object (sorry)");
                break;
            }

            AssertF(uiObj + duiObj < this->df.dwNumObjs);

            if(this->rghoc[uiObj + duiObj].pcaps)
            {
                RPF("HidP_GetValueCaps inconsistent - "
                    "can't use device");
                hres = E_FAIL;
                goto freedone;
            }

            this->rghoc[uiObj + duiObj].pcaps = pcaps;
            podf = &this->df.rgodf[uiObj + duiObj];

            /*
             *  HACKHACK!  Wheels are identified by
             *  UsageToUsageMap as GUID_Slider, but we
             *  want them to be GUID_ZAxis if we are a mouse.
             *
             *  We also set the granularity here.
             */
            if(GET_DIDEVICE_TYPE(this->dwDevType) == DI8DEVTYPE_MOUSE &&
               pcaps->UsageMin + duiObj == HID_USAGE_GENERIC_WHEEL &&
               pcaps->UsagePage == HID_USAGE_PAGE_GENERIC)
            {
                podf->pguid = &GUID_ZAxis;
                pcaps->usGranularity = (USHORT)g_lWheelGranularity;
            } else if( type == HidP_Input )
            {
                PHIDUSAGEMAP phum;

                phum = UsageToUsageMap( DIMAKEUSAGEDWORD( pcaps->UsagePage,
                                                          pcaps->UsageMin + duiObj ) );
                if(phum)
                {
                    podf->pguid = phum->pguid;
                } else
                {
                    podf->pguid = &GUID_Unknown;
                }
            } else 
            {
                podf->pguid = &GUID_Unknown;
            }

            /*
             *  Set a default instance.  This will be overwritten later 
             *  if this object is of a type we fully understand.
             */        
            dwObjType = DIDFT_MAKEINSTANCE(uiObj + duiObj);

            if( pcaps->IsAlias )
            {
                dwObjType |= DIDFT_ALIAS;
            }
            
            if(pcaps->UsagePage >= HID_USAGE_PAGE_VENDOR )
            {
                dwObjType |= DIDFT_VENDORDEFINED;
            }
            else if(podf->pguid == &GUID_POV)
            {
                /* Note, this must be an input to have been mapped */
                dwObjType |= DIDFT_POV;
                if( !pcaps->IsAlias )
                {
                    this->dwPOVs++;
                }
            } 
            else if( type == HidP_Input )
            {
                /*
                 *  In order to reduce the likelyhood of an app picking up an 
                 *  input value that is not a user controlled axis, only mark 
                 *  values as axes if they are inputs on a usage page that 
                 *  contains such usages.
                 *  ISSUE-2000/11/07-MarcAnd ideally we should be looking at 
                 *  not only the usage of the object but at the collections 
                 *  that contain it.
                 */
                switch( pcaps->UsagePage )
                {
                case HID_USAGE_PAGE_BUTTON:
                    /*
                     *  The plan was that an absolute input axis on the button 
                     *  page would be an analog button.  Unfortunately it 
                     *  could be a mis-declared button array selector (482186).  
                     *  Safest thing is to ignore the thing completely.
                     */
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("Ignoring value on button page usage ID 0x%04X"),
                        pcaps->UsageMin + duiObj );
                    break;

                case HID_USAGE_PAGE_GENERIC:
                    if( pcaps->UsageMin + duiObj == HID_USAGE_GENERIC_COUNTED_BUFFER )
                    {
                        SquirtSqflPtszV(sqfl | sqflTrace,
                            TEXT("Leaving counted buffer as unclassified object") );
                        break;
                    }

                    if( pcaps->UsageMin + duiObj == HID_USAGE_GENERIC_BYTE_COUNT )
                    {
                        SquirtSqflPtszV(sqfl | sqflTrace,
                            TEXT("Leaving byte count as unclassified object") );
                        break;
                    }

                case HID_USAGE_PAGE_SIMULATION:
                case HID_USAGE_PAGE_VR:
                case HID_USAGE_PAGE_SPORT:
                case HID_USAGE_PAGE_GAME:
                case HID_USAGE_PAGE_KEYBOARD:
                case HID_USAGE_PAGE_CONSUMER:
                case HID_USAGE_PAGE_DIGITIZER:
                    if( pcaps->IsAbsolute)
                    {
                        dwObjType |= DIDFT_ABSAXIS;
                    }
                    else
                    { 
                        dwObjType |= DIDFT_RELAXIS;
                    }
                    break;

                default:
                    SquirtSqflPtszV(sqfl | sqflTrace,
                        TEXT("Assuming value 0x%04X:0x%04X is not a user control"),
                        pcaps->UsagePage,pcaps->UsageMin + duiObj );
                }

                if( ( dwObjType & DIDFT_AXIS ) && !pcaps->IsAlias )
                {
                    this->dwAxes++;
                }
            }

            /*
             *  Objects must have an offset to be accessed
             */
            podf->dwOfs = this->df.dwDataSize;
            if( !pcaps->IsAlias) 
            { 
                this->df.dwDataSize += cbX(DWORD);
            }

            if(HidP_IsOutputLike(type))
            {
                /*
                 *  Input and feature allow data; output does not.
                 */
                if(type == HidP_Output)
                {
                    dwObjType |= ( DIDFT_NODATA | DIDFT_OUTPUT );
                }
                else
                {
                    dwObjType |= DIDFT_OUTPUT;
                }
            }

            podf->dwType = dwObjType;


            if(type != HidP_Input )
            {
                podf->dwFlags = DIDOI_POLLED | DIDOI_NOTINPUT;
            }
            else if(this->IsPolledInput )
            {
                podf->dwFlags = dwAspect | DIDOI_POLLED;
            } else
            {
                podf->dwFlags = dwAspect;
            }

            
            /*
             *  ISSUE-2001/03/06-MarcAnd  DIDOI FF attributes
             */
            if( this->fPIDdevice                    // FF device 
                && ! IsEqualGUID(podf->pguid, &GUID_Unknown ) )  // We map the axis
            {
                NTSTATUS            ntStat;
                USHORT              cAButton=0x0;
            
                ntStat =  HidP_GetSpecificButtonCaps 
                        (
                               HidP_Output,                        // ReportType
                               pcaps->UsagePage,                   // UsagePage
                               0x0,                                // Link Collection
                               (USAGE)(pcaps->UsageMin + duiObj),  // Usage 
                               NULL,                               // ValueCaps
                               &cAButton,                          // ValueCapsLength
                               this->ppd                           // PreparsedData
                        );
         
                if(   SUCCEEDED(ntStat)
                    || (ntStat == HIDP_STATUS_BUFFER_TOO_SMALL)  )// In case someone has more than one
            
                {
                    podf->dwFlags |= DIDOI_FFACTUATOR;
                    podf->dwType |= DIDFT_MAKEATTR(DIDOI_FFACTUATOR);
                }
            }
            
            /*
             *  Note that we do not calibrate relative axes,
             *  since there's really nothing to calibrate.
             *
             *  Note also that we calibrate only inputs.
             *  We don't want to do de-calibration on outputs.
             *  (And since features are input+output, we don't
             *  do it on features either.)
             *
             *  We merely set up the calibration here; the
             *  reading of the calibration values is done
             *  by CHid_LoadCalibrations.
             *
             */
            if(type == HidP_Input)
            {

                PJOYRANGECONVERT pjrc = this->pjrcNext++;

                this->rghoc[uiObj + duiObj].pjrc = pjrc;

                /*
                 *  Saturation always defaults to 100%.
                 */
                pjrc->dwSat = RANGEDIVISIONS;
                AssertF(pjrc->dwDz == 0);

                if( dwObjType & DIDFT_ABSAXIS ) 
                {
                    pjrc->lMin = 0;
                    pjrc->lMax = 65535;
                    pjrc->lC = 65535/2;
                } 
              #ifdef WINNT
                else if( (dwObjType & DIDFT_POV) && pcaps->IsPolledPOV ) 
                {
                    pjrc->fPolledPOV = TRUE;
                }
              #endif
            }
        }
        D(pcaps->dwSignature = HIDGROUPCAPS_SIGNATURE);
    }

    hres = S_OK;

    freedone:;
    FreePv(rgvcaps);

    done:;
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitAxes |
 *
 *          Identify and initialize the axes: input, feature and output.
 *
 *          HID calls them "values" because they might not really
 *          be axes in the joystick sense.
 *
 *          The input axes come first, then the feature axes,
 *          then the output axes.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitAxes(PCHID this)
{
    HRESULT hres;
    DWORD ccaps;

    /*
     *  Do the input axes...
     */
    hres = CHid_InitAxisClass(this, &this->rgcaps[0],
                              this->caps.NumberInputValueCaps,
                              HidP_Input);
    if(FAILED(hres))
    {
        goto done;
    }
    ccaps = this->caps.NumberInputValueCaps;

    /*
     *  Do the feature axes...
     */
    hres = CHid_InitAxisClass(this, &this->rgcaps[ccaps],
                              this->caps.NumberFeatureValueCaps,
                              HidP_Feature);
    if(FAILED(hres))
    {
        goto done;
    }
    ccaps += this->caps.NumberFeatureValueCaps;

    /*
     *  Do the output axes...
     */
    hres = CHid_InitAxisClass(this, &this->rgcaps[ccaps],
                              this->caps.NumberOutputValueCaps,
                              HidP_Output);
    if(FAILED(hres))
    {
        goto done;
    }

    done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitButtonClass |
 *
 *          Initialize one class (input, feature, output) of buttons.
 *
 *  @parm   PHIDGROUPCAPS | rgcaps |
 *
 *          Array of <t HIDGROUPCAPS> structures to receive the caps
 *          of the buttons in the class.
 *
 *  @parm   USHORT | ccaps |
 *
 *          Number of <t HIDGROUPCAPS> structures we expect to find.
 *
 *  @parm   HIDP_REPORT_TYPE | type |
 *
 *          One of the values
 *          <c HidP_Input>,
 *          <c HidP_Feature> or
 *          <c HidP_Output>.
 *
 *****************************************************************************/

HRESULT INTERNAL CHid_InitButtonClass
(
    PCHID this, 
    PHIDGROUPCAPS rgcaps, 
    PBYTE rgbReportIDs, 
    USHORT ccaps, 
    HIDP_REPORT_TYPE type
)
{
    USHORT cbcaps;
    NTSTATUS stat;
    HRESULT hres;
    DWORD ibcaps;
    PHIDP_BUTTON_CAPS rgbcaps;
    
    AssertF(rgcaps >= this->rgcaps);
    AssertF(rgcaps + ccaps <= &this->rgcaps[this->ccaps]);

    /*
     *  Annoying quirk:
     *
     *  HID doesn't like it when you pass 0 to HidP_GetButtonCaps,
     *  so we need to special-case the "no buttons" scenario.
     */
    if(ccaps == 0)
    {
        hres = S_OK;
        goto done;
    }

    hres = AllocCbPpv(cbCxX(ccaps, HIDP_BUTTON_CAPS), &rgbcaps);
    if(FAILED(hres))
    {
        goto done;
    }

    cbcaps = ccaps;

    stat = HidP_GetButtonCaps(type, rgbcaps, &cbcaps, this->ppd);

    if(FAILED(stat))
    {
        RPF("HidP_GetButtonCaps failed - can't use device");
        hres = E_FAIL;
        goto freedone;
    }

    /* HidP_GetCaps has the annoying habit of treating everything that is
     * single bit as a button. 
     * This causes some problems. For example the ALPS gamepad declares its
     * POVs as single bit values, (not buttons though). 
     * Hence we need to be prepared for the buttons being less than advertised 
     */

    if(cbcaps != ccaps)
    {
        RPF("HidP_GetButtonCaps(%d) (%d) inconsistent "
            "with HidP_GetCaps (%d) - "
            "can't use device", type, cbcaps, ccaps);
        hres = E_FAIL;
        goto freedone;
    }

    CHid_SortCaps(rgbcaps, cbcaps);

    for(ibcaps = 0; ibcaps < cbcaps; ibcaps++)
    {
        PHIDP_BUTTON_CAPS pbcaps = &rgbcaps[ibcaps];
        PHIDGROUPCAPS pcaps = &rgcaps[ibcaps];
        UINT uiObj;
        UINT duiObj;

        if(pbcaps->IsRange)
        {
            if(pbcaps->Range.DataIndexMax - pbcaps->Range.DataIndexMin !=
               pbcaps->Range.UsageMax - pbcaps->Range.UsageMin)
            {
                RPF("HidP_GetButtonCaps corrupted BUTTON_CAPS - "
                    "can't use device");
                hres = E_FAIL;
                goto freedone;
            }
        } else
        {
            pbcaps->Range.UsageMax = pbcaps->Range.UsageMin;
        }

        pcaps->wReportId          = pbcaps->ReportID;
        this->wMaxReportId[type]  = max(pcaps->wReportId, this->wMaxReportId[type]);

        pcaps->UsagePage          = pbcaps->UsagePage;
        pcaps->UsageMin           = pbcaps->Range.UsageMin;
        pcaps->DataIndexMin       = pbcaps->Range.DataIndexMin;

        pcaps->cObj               = pbcaps->Range.UsageMax -
                                    pbcaps->Range.UsageMin + 1;

        /*
         *  Buttons are (from the HID definition) items with
         *  a bit size of 1.
         */
        pcaps->BitSize            = 1;
        pcaps->lMask              = ~((1 << (pcaps->BitSize - 1)) - 1);
        /*
         *  Not applicable for buttons:
         *
         *  LogicalMin/Max, PhysicalMin/Max, Units.
         */
        pcaps->LinkCollection     = pbcaps->LinkCollection;

        pcaps->StringMin          = pbcaps->Range.StringMin;
        pcaps->StringMax          = pbcaps->IsStringRange ?
                                    pbcaps->Range.StringMax :
                                    pbcaps->Range.StringMin;

        pcaps->DesignatorMin      = pbcaps->Range.DesignatorMin;
        pcaps->DesignatorMax      = pbcaps->IsDesignatorRange ?
                                    pbcaps->Range.DesignatorMax :
                                    pbcaps->Range.DesignatorMin;

        /*
         *  ISSUE-2001/03/06-MarcAnd What does IsAbsolute mean for a button?
         */
        pcaps->IsAbsolute         = pbcaps->IsAbsolute;

        AssertF(!pcaps->IsValue);

        pcaps->type               = type;

        pcaps->IsAlias            = pbcaps->IsAlias;


        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetButtonCaps(%d)[%d]: ")
                        TEXT("Objs=%2d ")
                        TEXT("idx=%2d... ")
                        TEXT("coll=%d")
                        TEXT("IsAlias=%d"),
                        type, ibcaps,
                        pcaps->cObj,
                        pcaps->DataIndexMin,
                        pcaps->LinkCollection,
                        pcaps->IsAlias);

        uiObj = this->rgdwBase[type] + pcaps->DataIndexMin;
        for(duiObj = 0; duiObj < pcaps->cObj; duiObj++)
        {
            DWORD dwObjType;
            LPDIOBJECTDATAFORMAT podf;
            /*
             *  If HID messed up and gave us something out of range,
             *  then give up on this value caps (since the rest are
             *  also out of range) and move on to the next one.
             */
            if(uiObj + duiObj >= this->df.dwNumObjs)
            {
                RPF("HidP_GetButtonCaps inconsistent with NumberDataIndices - "
                    "skipping object (sorry)");
                break;
            }

            AssertF(uiObj + duiObj < this->df.dwNumObjs);

            if(this->rghoc[uiObj + duiObj].pcaps)
            {
                RPF("HidP_GetButtonCaps inconsistent - "
                    "can't use device");
                hres = E_FAIL;
                goto freedone;
            }

            /*
             *  No fatal errors have been detected so store the object details
             */
            AssertF( rgbReportIDs[uiObj + duiObj] == 0 );
            rgbReportIDs[uiObj + duiObj] = pbcaps->ReportID;

            this->rghoc[uiObj + duiObj].pcaps = pcaps;
            podf = &this->df.rgodf[uiObj + duiObj];
            
            /*
             *  Set a default instance.  This will be overwritten later 
             *  if this object is of a type we fully understand.
             */        
            dwObjType = DIDFT_MAKEINSTANCE(uiObj + duiObj);
            
            if(pcaps->UsagePage >= HID_USAGE_PAGE_VENDOR )
            {
                /*
                 *  ISSUE-2001/03/06-MarcAnd  vendor defined objects
                 *  An aliased vendor defined usage may have a standard (not 
                 *  vendor defined) alias but the whole object will still be 
                 *  marked as vendor defined
                 */
                if( pcaps->IsAlias )
                {
                    dwObjType |= DIDFT_ALIAS;
                }
                dwObjType |= DIDFT_VENDORDEFINED;
                podf->pguid = &GUID_Unknown;
            } 
            else
            {
                if( pcaps->IsAlias )
                {
                    dwObjType |= DIDFT_ALIAS;
                }
                /*
                 *  In order to reduce the likelyhood of an app picking up a 
                 *  bit that is not a user controlled button, only mark bits 
                 *  as buttons if they are inputs on a usage page that 
                 *  contains such usages.
                 *  ISSUE-2000/11/07-MarcAnd ideally we should be looking at 
                 *  not only the usage of the object but at the collections 
                 *  that contain it.
                 */
                if( type == HidP_Input )
                {
                    switch( pcaps->UsagePage )
                    {
                    case HID_USAGE_PAGE_KEYBOARD:
                        podf->pguid = &GUID_Key;            
                        break;

                    case HID_USAGE_PAGE_BUTTON:
                        if( ( duiObj == 0 )
                         && ( pcaps->UsageMin == 0 ) )
                        {
                            /*
                             *  Special case button zero means no buttons 
                             *  are pressed 
                             */
                            SquirtSqflPtszV(sqfl | sqflTrace,
                                TEXT("Ignoring \"No button\" button") );
                            goto IgnoreButton;
                        }
                    case HID_USAGE_PAGE_GENERIC:
                    case HID_USAGE_PAGE_SIMULATION:
                    case HID_USAGE_PAGE_VR:
                    case HID_USAGE_PAGE_SPORT:
                    case HID_USAGE_PAGE_GAME:
                    case HID_USAGE_PAGE_CONSUMER:
                    case HID_USAGE_PAGE_DIGITIZER:
                        podf->pguid = &GUID_Button;
                        break;
                    default:
                        SquirtSqflPtszV(sqfl | sqflTrace,
                            TEXT("Assuming button 0x%04X:0x%04X is not a user control"),
                            pcaps->UsagePage,pcaps->UsageMin + duiObj );
                        goto IgnoreButton;
                    }

                    dwObjType |= DIDFT_PSHBUTTON;
                    if( !pcaps->IsAlias )
                    {
                        this->dwButtons++;
                    }
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflTrace,
                        TEXT("Assuming non-input bit 0x%04X:0x%04X is not a user control"),
                        pcaps->UsagePage,pcaps->UsageMin + duiObj );
IgnoreButton:;
                    podf->pguid = &GUID_Unknown;
                }

            }
            


            
            /*
             *  Objects must have an offset to be accessed
             */
            podf->dwOfs = this->df.dwDataSize;
            if( !pcaps->IsAlias) 
            { 
                this->df.dwDataSize += cbX(BYTE);
            }

            if(HidP_IsOutputLike(type))
            {
                /*
                 *  Input and feature allow data; output does not.
                 */
                if(type == HidP_Output)
                {
                    dwObjType |= ( DIDFT_NODATA | DIDFT_OUTPUT );
                }
                else
                {
                    dwObjType |= DIDFT_OUTPUT;
                }
            }

            podf->dwType = dwObjType;

            if(type != HidP_Input  )
            {
                podf->dwFlags = DIDOI_POLLED | DIDOI_NOTINPUT;
            } else if( this->IsPolledInput )
            {
                podf->dwFlags = DIDOI_POLLED;
            } else
            {
                podf->dwFlags = 0;
            }
        
            /*
             *  ISSUE-2001/03/06-MarcAnd  DIDOI FF attributes if not defined in registry
             */
            if(    this->fPIDdevice  
                && ( dwObjType & DIDFT_PSHBUTTON ) )
            {
                podf->dwFlags |= DIDOI_FFEFFECTTRIGGER;
                podf->dwType |= DIDFT_MAKEATTR(DIDOI_FFEFFECTTRIGGER);
            }
        
        
        }

        D(pcaps->dwSignature = HIDGROUPCAPS_SIGNATURE);
    }

    hres = S_OK;

    freedone:;
    FreePv(rgbcaps);

    done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitButtons |
 *
 *          Identify and initialize the buttons: input, feature, and output.
 *
 *          The input buttons come first, then the feature buttons,
 *          then the output buttons.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitButtons(PCHID this)
{
    HRESULT hres;
    DWORD ccaps;
    PBYTE rgbReportIDs;
    UINT cbReportIDs;
    UINT uMaxReportId;

    this->ibButtonData = this->df.dwDataSize;

    /*
     *  Skip over the value caps to get to the buttons ...
     */
    ccaps = this->caps.NumberInputValueCaps +
            this->caps.NumberFeatureValueCaps +
            this->caps.NumberOutputValueCaps;

    /*
     *  Allocate a temporary buffer to store the report ID of each button.
     *  We use the sum of all data indices and collections so that the 
     *  internal object index of each button can be used as the index into 
     *  the buffer.  We leave value and collection elements alone so they 
     *  are just a small waste of space.
     */

    cbReportIDs = this->caps.NumberInputDataIndices +
                  this->caps.NumberFeatureDataIndices +
                  this->caps.NumberOutputDataIndices +
                  this->caps.NumberLinkCollectionNodes;

    hres = AllocCbPpv( cbReportIDs, &rgbReportIDs );

    if(FAILED(hres))
    {
        goto done;
    }

    /*
     *  Do the input buttons...
     */

    hres = CHid_InitButtonClass(this, 
                                &this->rgcaps[ccaps],
                                rgbReportIDs,
                                this->caps.NumberInputButtonCaps,
                                HidP_Input);
    if(FAILED(hres))
    {
        goto done;
    }
    ccaps += this->caps.NumberInputButtonCaps;

    /*
     *  Do the feature buttons...
     */
    hres = CHid_InitButtonClass(this, 
                                &this->rgcaps[ccaps],
                                rgbReportIDs,
                                this->caps.NumberFeatureButtonCaps,
                                HidP_Feature);
    if(FAILED(hres))
    {
        goto done;
    }
    ccaps += this->caps.NumberFeatureButtonCaps;

    /*
     *  Do the output buttons...
     */
    hres = CHid_InitButtonClass(this, 
                                &this->rgcaps[ccaps],
                                rgbReportIDs,
                                this->caps.NumberOutputButtonCaps,
                                HidP_Output);
    if(FAILED(hres))
    {
        goto done;
    }

    this->cbButtonData = this->df.dwDataSize - this->ibButtonData;

    /*
     *  If this device only has one report ID, it must be ID zero
     */
    uMaxReportId = (UINT) max( this->wMaxReportId[HidP_Input], 
                               max( this->wMaxReportId[HidP_Feature], 
                                    this->wMaxReportId[HidP_Output] ) );

    /*
     *  If there's only one report or there are no buttons there's 
     *  no need to set up the arrays of data masks for each report.
     */
    if( uMaxReportId == 0 )
    {
        AssertF( this->rgpbButtonMasks == NULL );
    }
    else if( this->cbButtonData == 0 )
    {
        AssertF( this->rgpbButtonMasks == NULL );
    }
    else
    {
        /*
         *  Allocate enough space for a mask array and a pointer to the array 
         *  for each report.
         */
        hres = AllocCbPpv( uMaxReportId * ( this->cbButtonData + cbX( PV ) ), 
            &this->rgpbButtonMasks );

        if( SUCCEEDED( hres ) )
        {
            UINT uReportId;
            UINT uDataIdx;
            UINT uBtnIdx;
            PBYTE pbCurrentMask;

            /*
             *  The masks start after the last pointer to masks
             */
            pbCurrentMask = (PBYTE)&this->rgpbButtonMasks[uMaxReportId];
            memset( pbCurrentMask, 0xFF, this->cbButtonData * uMaxReportId );


            /*
             *  Search through our temp buffer once for each report
             */
            for( uReportId=0; uReportId<uMaxReportId; uReportId++ )
            {
                for( uBtnIdx=uDataIdx=0; uDataIdx<cbReportIDs; uDataIdx++ )
                {
                    /*
                     *  Report IDs are one based but we use a zero based array 
                     *  so adjust when testing for a matching ID
                     */
                    if( rgbReportIDs[uDataIdx] == uReportId+1 )
                    {
                        /*
                         *  Set the pointer for this report to the current 
                         *  mask array.  If a report contains more than one  
                         *  button the same value will be set repeatedly.
                         */
                        this->rgpbButtonMasks[uReportId] = pbCurrentMask;

                        /*
                         *  The final result is an AND mask so clear all bits
                         *  so this button will be cleared when this report 
                         *  is being processed
                         */
                        pbCurrentMask[uBtnIdx] = 0;
                    }

                    /*
                     *  Just in case there are gaps in the HID report we 
                     *  use our own counter of button index which is only 
                     *  incremented when we find a button to keep in line 
                     *  with the contiguous block of buttons that we use.
                     */
                    if( rgbReportIDs[uDataIdx] != 0 )
                    {
                        uBtnIdx++;
                        AssertF( uBtnIdx <= this->cbButtonData );
                    }
                }
                
                /*
                 *  There should always be exactly as many buttons in 
                 *  all the reports combined as we found when counting 
                 *  how many buttons there were of each type.
                 */
                AssertF( uBtnIdx == this->cbButtonData );

                /*
                 *  If any buttons were found in this report, use next mask
                 */
                if( this->rgpbButtonMasks[uReportId] == pbCurrentMask )
                {
                    pbCurrentMask += this->cbButtonData;
                }
            }

            /*
             *  At least one report had to have a button in it.
             */
            AssertF( pbCurrentMask != (PBYTE)&this->rgpbButtonMasks[uMaxReportId] );
        
            /*
             *  Try to reduce the allocation to what we actually used
             *  In the worst case we only land up using excess memory
             */
            ReallocCbPpv( (UINT)((PBYTE)pbCurrentMask - (PBYTE)this->rgpbButtonMasks), 
                &this->rgpbButtonMasks );
        }
    }
    done:;

    FreePpv( &rgbReportIDs );

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | InitCollections |
 *
 *          Identify and initialize the HID link collections.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitCollections(PCHID this)
{
    HRESULT hres;
    NTSTATUS stat;
    DWORD icoll, ccoll, ccaps;
    PHIDP_LINK_COLLECTION_NODE rgcoll;

    ccoll = this->caps.NumberLinkCollectionNodes;

    /*
     *  Annoying quirk:
     *
     *  HID doesn't like it when you pass 0 to HidP_GetLinkCollectionNodes,
     *  so we need to special-case the "no collections" scenario.
     */
    if(ccoll == 0)
    {
        hres = S_OK;
        goto done;
    }

    hres = AllocCbPpv(cbCxX(ccoll, HIDP_LINK_COLLECTION_NODE), &rgcoll);
    if(FAILED(hres))
    {
        goto done;
    }

    /*
     *  Get the collections...
     */
    stat = HidP_GetLinkCollectionNodes(rgcoll, &ccoll, this->ppd);
    if(FAILED(stat))
    {
        RPF("HidP_GetLinkCollectionNodes failed - can't use device");
        hres = E_FAIL;
        goto freedone;
    }

    if(ccoll != this->caps.NumberLinkCollectionNodes)
    {
        RPF("HidP_GetLinkCollectionNodes inconsistent with HidP_GetCaps - "
            "can't use device");
        hres = E_FAIL;
        goto freedone;
    }

    ccaps = this->caps.NumberInputValueCaps +
            this->caps.NumberFeatureValueCaps +
            this->caps.NumberOutputValueCaps +
            this->caps.NumberInputButtonCaps +
            this->caps.NumberFeatureButtonCaps +
            this->caps.NumberOutputButtonCaps;

    AssertF(ccaps + ccoll == this->ccaps);

    for(icoll = 0; icoll < ccoll; icoll++)
    {
        PHIDP_LINK_COLLECTION_NODE pcoll = &rgcoll[icoll];
        PHIDGROUPCAPS pcaps = &this->rgcaps[ccaps + icoll];
        UINT uiObj;
        LPDIOBJECTDATAFORMAT podf;
      
        pcaps->UsagePage          = pcoll->LinkUsagePage;
        pcaps->UsageMin           = pcoll->LinkUsage;
        pcaps->cObj               = 1;
        pcaps->IsAlias            = pcoll->IsAlias;

        /*
         *  Not applicable for collections:
         *
         *  StringMin/Max,
         *  DesignatorMin/Max,
         *  BitSize, LogicalMin/Max, PhysicalMin/Max, Units.
         *  IsAbsolute
         */
        pcaps->LinkCollection     = pcoll->Parent;

        pcaps->type               = HidP_Coll;

        /*
         *  We cook up DataIndexMin to correspond to this item.
         */
        pcaps->DataIndexMin       = (USHORT)icoll;

        uiObj = this->rgdwBase[HidP_Coll] + pcaps->DataIndexMin;

        /*
         *  We generated these indices on our own, so they
         *  can't possible be wrong.
         */
        AssertF(uiObj < this->df.dwNumObjs);

        this->rghoc[uiObj].pcaps = pcaps;
        podf = &this->df.rgodf[uiObj];

        /*
         *  ISSUE-2001/03/06-MarcAnd  collections have GUID_Unknown
         *  Collections are more or less hidden and therefore unusable.
         */
        podf->pguid = &GUID_Unknown;

        /*
         *  Set a default instance.  This will be overwritten later 
         *  if this object is of a type we fully understand.
         */        
        podf->dwType = DIDFT_MAKEINSTANCE(uiObj) | DIDFT_COLLECTION | DIDFT_NODATA;

        if(pcaps->UsagePage >= HID_USAGE_PAGE_VENDOR )
        {
            podf->dwType |= DIDFT_VENDORDEFINED;
        }

        podf->dwFlags = 0;

        /*
         *  CHid_ObjFromType relies on dwCollections not being split between
         *  aliased and unaliased.
         */
        this->dwCollections++;

        SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                        TEXT("HidP_GetLinkCollectionNodes(%d)[%d]: ")
                        TEXT("Objs=%2d ")
                        TEXT("idx=%2d... ")
                        TEXT("coll=%d")
                        TEXT("IsAlias=%d"),
                        pcaps->type, icoll,
                        pcaps->cObj,
                        pcaps->DataIndexMin,
                        pcaps->LinkCollection,
                        pcaps->IsAlias);

        D(pcaps->dwSignature = HIDGROUPCAPS_SIGNATURE);
    }

    hres = S_OK;

    freedone:;
    FreePv(rgcoll);

    done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | AllocObjectMemory |
 *
 *          Allocate all the memory that will be used to store object
 *          information.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_AllocObjectMemory(PCHID this)
{
    DWORD cb;
    DWORD cvcaps, cbcaps, ccoll, cjrc;
    HRESULT hres;

    /*
     *  Some trace squirties because HID is tricky.
     */

    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberInputDataIndices    = %d"),
                    this->caps.NumberInputDataIndices);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberOutputDataIndices   = %d"),
                    this->caps.NumberOutputDataIndices);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberFeatureDataIndices  = %d"),
                    this->caps.NumberFeatureDataIndices);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberLinkCollectionNodes = %d"),
                    this->caps.NumberLinkCollectionNodes);

    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberInputValueCaps      = %d"),
                    this->caps.NumberInputValueCaps);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberOutputValueCaps     = %d"),
                    this->caps.NumberOutputValueCaps);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberFeatureValueCaps    = %d"),
                    this->caps.NumberFeatureValueCaps);

    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberInputButtonCaps     = %d"),
                    this->caps.NumberInputButtonCaps);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberOutputButtonCaps    = %d"),
                    this->caps.NumberOutputButtonCaps);
    SquirtSqflPtszV(sqflVerbose | sqflHidParse,
                    TEXT("HidP_GetCaps: NumberFeatureButtonCaps   = %d"),
                    this->caps.NumberFeatureButtonCaps);

    /*
     *  Allocate the memory into which we place
     *  the DIOBJECTDATAFORMATs we build.
     */
    this->df.dwNumObjs = this->caps.NumberInputDataIndices +
                         this->caps.NumberOutputDataIndices +
                         this->caps.NumberFeatureDataIndices +
                         this->caps.NumberLinkCollectionNodes;
    if(this->df.dwNumObjs >= DIDFT_GETINSTANCE(DIDFT_ANYINSTANCE))
    {
        ("Too many objects in HID device (%d) - can't use device",
         this->df.dwNumObjs);
        hres = E_FAIL;
        goto done;
    }

    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_AllocObjectMemory: dwNumObjs      = %d"),
                    this->df.dwNumObjs);

    /*
     *  ISSUE-2001/10/17-MarcAnd  Axes declared in ranges cause AVs
     *  We only allocate as many JOYRANGECONVERT elements as there are value 
     *  caps in HID but multiple axes may be declared in a range which will 
     *  be reported in a single value caps.
     */
    cjrc   = this->caps.NumberInputValueCaps;

    cvcaps = this->caps.NumberInputValueCaps +
             this->caps.NumberFeatureValueCaps +
             this->caps.NumberOutputValueCaps;

    cbcaps = this->caps.NumberInputButtonCaps +
             this->caps.NumberFeatureButtonCaps +
             this->caps.NumberOutputButtonCaps;

    ccoll  = this->caps.NumberLinkCollectionNodes;

    this->ccaps = cvcaps + cbcaps + ccoll;

    /*
     *  Allocating the memory is done in four phases.
     *
     *  1. Tally up how much memory we need,
     *  2. Allocate that memory,
     *  3. Dole out the memory we allocated,
     *  4. Check that we didn't mess up.
     *
     *  Since this is extremely error-prone (I've messed it up at least
     *  once), the work is hidden inside macros.
     *
     *  The macro THINGS expands to a series of THING()s, each of which
     *  specifies a field name and the size it should be.  Each time you
     *  want to iterate over the fields, use the THINGS macro.
     */

    #define THINGS()                                                        \
        THING(df.rgodf,     cbCxX(this->df.dwNumObjs, DIOBJECTDATAFORMAT)); \
        THING(rghoc,        cbCxX(this->df.dwNumObjs, HIDOBJCAPS));         \
        THING(rgcaps,       cbCxX(this->ccaps, HIDGROUPCAPS));              \
        THING(pjrcNext,     cbCxX(cjrc, JOYRANGECONVERT));                  \

    /*
     *  Make a pass through the fields adding up the memory requirements.
     */
    #define THING(f, cbF)       cb += cbF
    cb = 0;
    THINGS();
    #undef THING

    hres = ReallocCbPpv(cb, &this->df.rgodf);

    if(SUCCEEDED(hres))
    {

        PV pv;

        /*
         *  Make a pass through the fields carving up the memory block
         *  and handing out pieces of it.
         */
    #define THING(f, cbF) this->f = pv; pv = pvAddPvCb(pv, cbF)
        pv = this->df.rgodf;
        THINGS();
    #undef THING

        /*
         *  There should be no byte left over.
         */
        AssertF(pvAddPvCb(this->df.rgodf, cb) == pv);

    }

    #undef THINGS

    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_AllocObjectMemory: pv = %08x, cb = 0x%08x"),
                    this->df.rgodf, cb);

    done:;
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | EnumKeyboardMunge |
 *
 *          Enumerate the objects in the list, indicating whether
 *          each object is "keyboardlike" or "otherlike".
 *
 *  @parm   LPBYTE | pb |
 *
 *          Pointer to translation table that converts HID usages
 *          into keyboard scan codes.
 *
 *  @parm   KBDMUNGECALLBACK | Munge |
 *
 *          Callback function that handles each object as we find it.
 *
 *  @parm   PV | pvRef |
 *
 *          Reference data for callback.
 *
 *  @cb     void CALLBACK | KbdMungeCallback |
 *
 *          Called once for each object on a keyboard HID device.
 *
 *  @parm   PCHID | this |
 *
 *          The device itself.
 *
 *  @parm   UINT | uiObj |
 *
 *          The object being enumerated.
 *
 *  @parm   UINT | dik |
 *
 *          DirectInput scan code for the object, or a value greater than
 *          or equal to <c DIKBD_CKEYS> if it's a fake instance number
 *          concocted for a non-AT key.
 *
 *****************************************************************************/

typedef void (CALLBACK *KBDMUNGECALLBACK)(PCHID this, UINT uiObj, UINT dik);

void INTERNAL
    CHid_EnumKeyboardMunge(PCHID this, LPBYTE pb, KBDMUNGECALLBACK Munge)
{
    UINT uiObj;
    BYTE rgbSeen[DIKBD_CKEYS];
    UINT uiCollections;

    /*
     *  In principle we could walk the this->rgcaps array, but
     *  that would open the risk that the this->rgcaps array
     *  and this->df.rgodf array are out of sync for some
     *  bizarre reason.  Do it the slow way just to be safe.
     *
     *  Furthermore, only the first item with a particular
     *  keyboard usage gets mapped into the DirectInput table.
     *  So if a keyboard has two ESCAPE keys, only the first
     *  one shows up in the DirectInput table; the second one
     *  shows up as "just another key".
     */

    this->uiInstanceMax = DIKBD_CKEYS;
    ZeroX(rgbSeen);
    for(uiCollections = uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        PHIDGROUPCAPS pcaps;
        UINT dik;
        UINT duiObj;
        UINT DataIndex;
        UINT Usage;

        pcaps = this->rghoc[uiObj].pcaps;

        if( pcaps->type == HidP_Coll )
        {
            dik = uiCollections++;
        }
        else
        {
            AssertF( HidP_IsValidReportType(pcaps->type) );
                
            DataIndex = uiObj - this->rgdwBase[pcaps->type];
            duiObj = DataIndex - pcaps->DataIndexMin;

            AssertF(duiObj < pcaps->cObj);

            Usage = pcaps->UsageMin + duiObj;

            if(pcaps->UsagePage == HID_USAGE_PAGE_KEYBOARD)
            {
                if(Usage < DIKBD_CKEYS && pb[Usage] && !rgbSeen[pb[Usage]])
                {
                    rgbSeen[pb[Usage]] = 1;
                    dik = pb[Usage];
                } else
                {
                    dik = this->uiInstanceMax++;
                }

            } else
            {
                dik = this->uiInstanceMax++;
            }

        }
        Munge(this, uiObj, dik);
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | TallyKeyboardObjs |
 *
 *          Callback function used during preliminary tallying to
 *          tot up how many of the objects can be treated as
 *          AT-compatible keyboard gizmos and how many are HID-specific.
 *
 *  @parm   UINT | uiObj |
 *
 *          The object being enumerated.
 *
 *  @parm   UINT | dik |
 *
 *          DirectInput scan code for the object, or a value greater than
 *          or equal to <c DIKBD_CKEYS> if it's a fake instance number
 *          concocted for a non-AT key.
 *
 *****************************************************************************/

void INTERNAL
    CHid_TallyKeyboardObjs(PCHID this, UINT uiObj, UINT dik)
{
    this;
    uiObj;
    dik;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | ReassignKeyboardObjs |
 *
 *          Callback function used to shuffle instance numbers around
 *          to make them AT-compatible when possible.
 *
 *  @parm   UINT | uiObj |
 *
 *          The object being enumerated.
 *
 *  @parm   UINT | dik |
 *
 *          DirectInput scan code for the object, or a value greater than
 *          or equal to <c DIKBD_CKEYS> if it's a fake instance number
 *          concocted for a non-AT key or an index number for a collection.
 *
 *****************************************************************************/

void INTERNAL
    CHid_ReassignKeyboardObjs(PCHID this, UINT uiObj, UINT dik)
{
    if( this->df.rgodf[uiObj].dwType & DIDFT_COLLECTION )
    {
        this->rgicoll[dik] = uiObj;
    }
    else
    {
        this->rgiobj[dik] = uiObj;
    }

    SquirtSqflPtszV(sqfl | sqflVerbose,
                    TEXT("CHid_ReassignKeyboardObjs: ")
                    TEXT("uiObj = %03x, dwType = %08x, dik=%04x"),
                    uiObj, this->df.rgodf[uiObj].dwType,
                    dik);

    this->df.rgodf[uiObj].dwType =
        (this->df.rgodf[uiObj].dwType & ~DIDFT_INSTANCEMASK) |
        DIDFT_MAKEINSTANCE(dik);

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | MungeKeyboard |
 *
 *          We just created a keyboard device.
 *
 *          Unfortunately, DirectInput has some annoying requirements
 *          for keyboard devices, so here is where we swizzle the instance
 *          numbers around to keep DirectInput happy.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_MungeKeyboard(PCHID this)
{
    HRESULT hres;
    LPBYTE pb;

    AssertF(this->rgiobj == 0);

    pb = pvFindResource(g_hinst, IDDATA_HIDMAP, RT_RCDATA);
    if(pb)
    {
        /*
         *  Count up the number of non-keyboard things on this device.
         *  They will get instance numbers starting at DIKBD_CKEYS.
         */

        CHid_EnumKeyboardMunge(this, pb, CHid_TallyKeyboardObjs);

        /*
         *  Now that we know how many nonstandard keyboard thingies
         *  we have, allocate room for the translation table
         *  and work all the instance values around to keep
         *  legacy apps happy.
         */

        hres = ReallocCbPpv(cbCdw(this->uiInstanceMax + this->dwCollections), &this->rgiobj);
        if(SUCCEEDED(hres))
        {
            memset(this->rgiobj, 0xFF, cbCxX(this->uiInstanceMax + this->dwCollections, INT));

            /*
             *  In case a keyboard comes along with non-button inputs,
             *  set up the other types of pointers to the same buffer.
             */
            this->rgipov = this->rgiaxis = this->rgiobj;

            /*
             *  Put collections at the end, there should be at least one
             */
            AssertF( this->dwCollections );
            this->rgicoll = &this->rgiobj[this->uiInstanceMax];

            CHid_EnumKeyboardMunge(this, pb, CHid_ReassignKeyboardObjs);

            hres = S_OK;
        }

        /*
         *  Prefix warns that the resource is leaked (mb:34650) but there is 
         *  no API to release a raw resource (FreeResource is a stub) so there 
         *  is nothing we can do.
         */
    } else
    {
        hres = E_FAIL;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | MungeNotKeyboard |
 *
 *          We just created a device that is not a keyboard.
 *
 *          Since we need the instance for each object to be relative only to 
 *          objects of that type, we need to replace the device relative 
 *          values generated into type relative ones.  In addition, to 
 *          maintain compatability with pre-HID object instances we need to 
 *          use axis instance numbers that would be generated for a WinMM 
 *          mapped axis.
 *          Aliased objects must be given the same instance number as the 
 *          primary alias so that the only difference between them is their 
 *          usage.  This prevents a data format being generated using multiple 
 *          aliases of the same object.
 *
 *          ISSUE-2001/03/13-MarcAnd  HID object munging is incomplete
 *          1.  Multiple values on a single axis (force and position)
 *          2.  Multiple instances of an axis type (two throttles)
 *          3.  Does not distinguish output only values (actuators) from axes
 *          4.  Keyboards with anything other than buttons should have this 
 *              done but won't
 *
 *****************************************************************************/

/*
 *  Internal function to convert all the attributes of one object to another
 *
 *  If an axis needs to be reinterpreted here, both the axis semantic and the 
 *  object GUID need to be changed so that the axis will be used consistently 
 *  in both semantic mapper and data format games.
 *
 *  Note, multiple instances of an axis type are not handled well.
 */
void INTERNAL ReinterpretObject
(
    PCHID   this,
    PDWORD  pdwHints,
    int     cAxes,
    PDWORD  pdwTypeFlags,
    DWORD   dwSrcHint,
    DWORD   dwDstHint,
    BYTE    bSemFlags,
    PCGUID  pgNew
)
{

    if( ( *pdwTypeFlags & ( dwSrcHint | dwDstHint ) ) == dwSrcHint )
    {
        int idx;

        for( idx = 0; idx < cAxes + 6; idx++ )
        {
            if( pdwHints[idx] == dwSrcHint )
            {
                *pdwTypeFlags ^= ( dwSrcHint | dwDstHint );
                pdwHints[idx] = dwDstHint;
                this->rgbaxissemflags[idx] = bSemFlags;
                this->df.rgodf[this->rgiaxis[idx]].pguid = pgNew;
                break;
            }
        }
        AssertF( idx < cAxes + 6 );
    }
}


HRESULT INTERNAL
    CHid_MungeNotKeyboard(PCHID this)
{
    HRESULT hres;

    unsigned int uiObj;
    int iButton;
    int iCollection = 0;
    int iPOV = 0;
    int iAxis = 0;
    //to indicate the index of the last "actual" button
    int iLastButtonIndex = 0;
    //to indicate the number of "non-actual" buttons
    int iOtherButton = 0;

    PINT piRemap = 0;

    BOOL fCarController = FALSE;

    DWORD dwTypeFlags = 0;
    int cAxes;

    D( iButton = 0; )
    AssertF(this->rgiobj == 0);

    /*
     *  First count the distinct types so we know how to segment rgiobj
     */

    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                        TEXT("CHid_MungeNotKeyboard: uiObj: %d starts as dwType 0x%08x"),
                        uiObj, this->df.rgodf[uiObj].dwType );

        if( !this->rghoc[uiObj].pcaps )
        {
            continue;
        }

        if( this->rghoc[uiObj].pcaps->IsAlias )
        {
            /*
             *  If there's a steering wheel anywhere, we need to know
             */
            if( ( DIDFT_AXIS == ( this->df.rgodf[uiObj].dwType & ( DIDFT_AXIS | DIDFT_NODATA ) ) )
             && ( this->rghoc[uiObj].pcaps->UsagePage == HID_USAGE_PAGE_SIMULATION )
             && ( HID_USAGE_SIMULATION_STEERING == 
                  ( this->rghoc[uiObj].pcaps->UsageMin + uiObj 
                  - this->rgdwBase[this->rghoc[uiObj].pcaps->type] 
                  - this->rghoc[uiObj].pcaps->DataIndexMin ) ) )
            {
                fCarController = TRUE;
            }
            continue;
        }


        /*
         *  Don't bother taking pointer to dwType in this simple
         *  loop as it should be enregistered anyway.
         */
        if( this->df.rgodf[uiObj].dwType & DIDFT_COLLECTION )
        {
            iCollection++;
        } 
        else if( this->df.rgodf[uiObj].dwType & DIDFT_NODATA )
        {
            /*
             *  Don't count objects that report no data
             */
            continue;
        }
        else if( this->df.rgodf[uiObj].dwType & DIDFT_BUTTON )
        {
            //HID reports everything that has size 1 bit as a button.
            //We need to know the index of the highest "actual" button -- the one that has USAGE_PAGE_BUTTON
            //And then we also need to know how many "non-actual" buttons there are.
            //The total amount of memory we need to allocate for buttons is the sum of those 2.
            if (this->rghoc[uiObj].pcaps->UsagePage == HID_USAGE_PAGE_BUTTON)
            {
                int iUsage = ( this->rghoc[uiObj].pcaps->UsageMin
                                     + uiObj 
                                     - this->rgdwBase[this->rghoc[uiObj].pcaps->type] 
                                     - this->rghoc[uiObj].pcaps->DataIndexMin );
                if (iUsage > iLastButtonIndex)
                {
                    iLastButtonIndex = iUsage;
                }
            }
            else
            {
                iOtherButton++;
            }
            D( iButton++; )
        }
        else if( this->df.rgodf[uiObj].dwType & DIDFT_AXIS )
        {
            iAxis++;
        }
        else if( this->df.rgodf[uiObj].dwType & DIDFT_POV )
        {
            iPOV++;
        }
    }


    /*
     *  Assert that we counted everything OK while we have a button count
     */
    AssertF( (int)this->df.dwNumObjs >= ( iPOV + iButton + iAxis + iCollection ) );

    /*
     *  The total amount of memory we need to allocate for buttons is the sum of 
     *  the highest "actual" button index and the number of "non-actual" buttons.
     */
    iButton = iOtherButton + iLastButtonIndex;
    AssertF(iButton >= 0);

    /*
     *  You can go to a whole lot of trouble finding out exactly what gaps 
     *  are left by the WinMM mapping but in the end, it's only 24 bytes of 
     *  data and it takes way more to work out how to save them.
     *  So just allocate 6 extra in case all the axes are non-WinMM.
     *  Note, there is weirdnes involved in WinMM axes as a real WinMM device 
     *  always have the U (Ry) and V (Rx) axes mapped to S0 and S1 however HID 
     *  devices have more flexible mappings.  Since the main reason to try to 
     *  keep WinMM and HID axes the same is for FF, only X and Y are critical.
     *  Keep the button count in cAxes so we can reference it when we need to 
     *  without worrying about whether iAxis is the current max or the real 
     *  max.  Should do this for the other counts as well but that can wait 
     *  until this function gets its long overdue restructuring.
     */
    cAxes = iAxis;
    this->uiInstanceMax = iCollection + iButton + cAxes + iPOV + 6;

    /*
     *  Note, piRemap received a pointer to a buffer user for workspace.
     *  The single allocation is subdivided as follows: 
     *      a buffer for an array of ints for matched objects, 
     *      an array of USAGES for axes and 
     *      and array of DWORDs for hint flags.
     */
    if( SUCCEEDED( hres = ReallocCbPpv(cbCdw(this->uiInstanceMax), &this->rgiobj) ) 
     && SUCCEEDED( hres = AllocCbPpv( ( cbCdw( 2 * (cAxes + 6) ) + cbCxX(this->uiInstanceMax, INT) ), &piRemap ) ) 
     && SUCCEEDED( hres = AllocCbPpv( cAxes + 6, &this->rgbaxissemflags ) ) )
    {
    /*
     * NOTE - this is not the order they are stored in the registry - but the macro used for
     *        generating them internally has been reversed somewhere along the track.
     */
typedef union _USAGES
{
    struct
    {
        USAGE Usage;
        USAGE UsagePage;
    };
    DWORD dwUsages;
} USAGES, *PUSAGES;

        PUSAGES pUsageMatches;
        PDWORD  pdwHints;
        int iNops = 0;
        int iUsages = 0;
        int iAxisIdx;
        HKEY hkAxis;

        DWORD dwTestType = 0;
        int iTypeAxes = 0;
        BOOL bAllMatch=TRUE;

        ZeroMemory( this->rgbaxissemflags, cAxes + 6 );
        memset(piRemap, 0xFF, cbCxX(this->uiInstanceMax, INT));
        memset(this->rgiobj, 0xFF, cbCxX(this->uiInstanceMax, INT));

        /*
         *  CHid_ObjFromType relies on the order of these for range checking
         */
        this->rgipov = &this->rgiobj[iButton];
        this->rgiaxis = &this->rgipov[iPOV];
        this->rgicoll = &this->rgipov[cAxes+6];


        /*
         *  In order to allow IHVs to describe their devices with usages 
         *  that we don't have in our table but still work for legacy apps, we 
         *  allow axes to be selected using the DIOBJECTATTRIBUTES in the 
         *  registry.  
         */
        pUsageMatches = (PUSAGES)&piRemap[this->uiInstanceMax];
        pdwHints = &pUsageMatches[cAxes + 6].dwUsages;

        /*
         *  Assert that we can treat the combined usage page / usage 
         *  WORDs using a union of a DWORD and two WORDs.
        CAssertF( ( FIELD_OFFSET( DIOBJECTATTRIBUTES, wUsage ) 
                  - FIELD_OFFSET( DIOBJECTATTRIBUTES, wUsagePage ) )
               == ( FIELD_OFFSET( USAGES, Usage ) 
                  - FIELD_OFFSET( USAGES, UsagePage ) ) );
         */

        /*
         *  Fetch IHV matches for all reasonable axes.
         */
        for( iAxisIdx = 0; iAxisIdx < cAxes + 5; iAxisIdx++ )
        {
            if( SUCCEEDED( CType_OpenIdSubkey( this->hkType, 
                    DIDFT_AXIS | DIDFT_MAKEINSTANCE( iAxisIdx ), 
                    KEY_QUERY_VALUE, &hkAxis ) ) )
            {
                DIOBJECTATTRIBUTES attr;

                if( ( SUCCEEDED( JoyReg_GetValue( hkAxis, TEXT("Attributes"),
                        REG_BINARY, &attr, cbX(attr) ) ) )
                 && ( *(PDWORD)&attr.wUsagePage ) )
                {
                    pUsageMatches[iAxisIdx].UsagePage = attr.wUsagePage;
                    pUsageMatches[iAxisIdx].Usage = attr.wUsage;
                    iUsages++;
                    /*
                     * Check it really exists on the device
                     * New behaviour is to ignore ALL registry mappings
                     * and dfault to DX7 implementation if a bogus
                     * control is found
                     */
                    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
                    {
                        if( ( this->df.rgodf[uiObj].dwType & DIDFT_AXIS )
                           && ( this->rghoc[uiObj].pcaps )
                           && ( this->rghoc[uiObj].pcaps->type == HidP_Input ) )
                        {   
                            USAGES Usages;
                            UINT   uidObj;

                            Usages.UsagePage = this->rghoc[uiObj].pcaps->UsagePage;
                            uidObj = uiObj - ( this->rgdwBase[HidP_Input] + this->rghoc[uiObj].pcaps->DataIndexMin );
                            Usages.Usage = this->rghoc[uiObj].pcaps->UsageMin + uidObj;
                            if( Usages.dwUsages == pUsageMatches[iAxisIdx].dwUsages )
                            {
                                SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("CHid_MungeNotKeyboard: Object %d matches  0x%08x"),
                                    uiObj, pUsageMatches[iAxisIdx].dwUsages );
                                break;
                            }
                        }
                    }
                    if (uiObj >= this->df.dwNumObjs)
                    {
                        //Error in registry settings - usage/usagepage pair not present on device
                        //reset
                        SquirtSqflPtszV(sqfl | sqflVerbose,
                            TEXT("CHid_MungeNotKeyboard: No matches for 0x%08x -  abandoning IHV map"),
                            pUsageMatches[iAxisIdx].dwUsages );
                        iUsages=0;
                        memset(piRemap, 0xFF, cbCxX(this->uiInstanceMax, INT));
                        bAllMatch=FALSE;
                        break;
                    }
                }
                else
                {
                    iNops++;
                }

                RegCloseKey( hkAxis );

                if( iUsages + iNops == cAxes )
                {
                    /*
                     *  We've opened as many keys as we have axes
                     *  continue the loop in debug as sanity check.
                     */
#ifdef XDEBUG
                    int iDbgIdx;
                    for( iDbgIdx = iAxisIdx + 1; iDbgIdx < cAxes + 5; iDbgIdx++ )
                    {
                        if( SUCCEEDED( CType_OpenIdSubkey( this->hkType, 
                                DIDFT_AXIS | DIDFT_MAKEINSTANCE( iDbgIdx ), 
                                KEY_QUERY_VALUE, &hkAxis ) ) )
                        {
                            RPF( "More axis keys than axes on device %04x:%04x!",
                                this->VendorID, this->ProductID );
                        }
                    }
#endif
                    break;
                }
            }
        }

        /*
         *  Go through all input axes, including aliases, trying to find a match
         */
        for(uiObj = 0; uiObj < this->df.dwNumObjs && bAllMatch; uiObj++)
        {
            UINT    uiObjPrimary;
            int     iUsageIdx;

            if( ( this->df.rgodf[uiObj].dwType & DIDFT_AXIS )
             && ( this->rghoc[uiObj].pcaps )
             && ( this->rghoc[uiObj].pcaps->type == HidP_Input ) )
            {
                USAGES Usages;
                UINT   uidObj;

                if( !this->rghoc[uiObj].pcaps->IsAlias )
                {
                    uiObjPrimary = uiObj;
                }

                
                Usages.UsagePage = this->rghoc[uiObj].pcaps->UsagePage;
                uidObj = uiObj - ( this->rgdwBase[HidP_Input] + this->rghoc[uiObj].pcaps->DataIndexMin );
                Usages.Usage = this->rghoc[uiObj].pcaps->UsageMin + uidObj;
                
                /*
                 *  Use incremental loop for better JoyHID consistency
                 */
                for( iUsageIdx = 0; iUsageIdx <= iAxisIdx; iUsageIdx++ )
                {
                    if( Usages.dwUsages == pUsageMatches[iUsageIdx].dwUsages )
                    {
                        PHIDUSAGEMAP phum;
                        LPDIOBJECTDATAFORMAT podf;

                        /*
                         *  Remember this one for later and 
                         *  discount it from further matches.
                         */
                        piRemap[uiObjPrimary] = iUsageIdx;
                        pUsageMatches[iUsageIdx].dwUsages = 0;

                        /*
                         *  Try to fix up the object GUID
                         *  Use a usage page usage match if possible 
                         *  otherwise pretend this is a generic axis 
                         *  of the appropriate type or settle for 
                         *  unknown.
                         */
                        podf = &this->df.rgodf[uiObj + uidObj];
                        if( iUsageIdx < 6 )
                        {
                            phum = UsageToUsageMap( DIMAKEUSAGEDWORD( 
                                HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_X + iUsageIdx ) );
                            AssertF( phum );
                            podf->pguid = phum->pguid;
                            this->rgbaxissemflags[iUsageIdx] = phum->bSemFlag;
                            pdwHints[iUsageIdx] = phum->dwSemHint;
                            dwTypeFlags |= phum->dwSemHint;
                        }
                        else if (iUsageIdx < 8)
                        {
                            podf->pguid = &GUID_Slider;
                            this->rgbaxissemflags[iUsageIdx] = DISEM_FLAGS_GET( DISEM_FLAGS_S );
                        }
                        else
                        {
                            podf->pguid = &GUID_Unknown;
                            this->rgbaxissemflags[iUsageIdx] = DISEM_FLAGS_GET( DISEM_FLAGS_S );
                        }

                        /*
                         *  Mark the primary axis associated with 
                         *  the matched axis as already set up.
                         */
                        this->rgiaxis[iUsageIdx] = uiObjPrimary;
                        this->df.rgodf[uiObjPrimary].dwType &= ~DIDFT_INSTANCEMASK;
                        this->df.rgodf[uiObjPrimary].dwType |= DIDFT_MAKEINSTANCE(iUsageIdx);

                        break;
                    }
                }
            }
            else
            {
                /* Not an axis, with caps and input */
            }
        }
    

        iCollection = 0;
        iButton = 0;
        iPOV = 0;
        iAxis = 6;

        for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
        {
            PHIDUSAGEMAP phum;
            PDWORD pdwType;

            pdwType = &this->df.rgodf[uiObj].dwType;

            if( !this->rghoc[uiObj].pcaps || this->rghoc[uiObj].pcaps->IsAlias 
              ||!( *pdwType & ( DIDFT_AXIS | DIDFT_BUTTON | DIDFT_POV | DIDFT_COLLECTION ) ))
            {
                continue;
            }

            if( *pdwType & DIDFT_COLLECTION )
            {
                *pdwType = (*pdwType & ~DIDFT_INSTANCEMASK) | DIDFT_MAKEINSTANCE(iCollection);
                this->rgicoll[iCollection++] = uiObj;
                continue;
            }
            else if( *pdwType & DIDFT_NODATA )
            {
                /*
                 *  Leave other no data objects alone
                 */
                continue;
            }
            
            if( *pdwType & DIDFT_BUTTON )
            {
                *pdwType &= ~DIDFT_INSTANCEMASK;
                //The buttons need to be sorted (manbug 30320) --
                //the ones that have USAGE_PAGE_BUTTON come first, sorted by button number,
                //w/ gaps for missing numbers if necessary;
                //then add on those that do not have USAGE_PAGE_BUTTON 
                //(since HID reports anything w/ size 1 bit is a button), unsorted.

                if (this->rghoc[uiObj].pcaps->UsagePage == HID_USAGE_PAGE_BUTTON)
                {
                    //put in the correct position, leaving gaps if needed.
                    //Usage - 1 will give us the position, since HID usages are 1-based,
                    //but DInput button indeces are 0-based.
                    int iPosition = ( this->rghoc[uiObj].pcaps->UsageMin
                                     + uiObj 
                                     - this->rgdwBase[this->rghoc[uiObj].pcaps->type] 
                                     - this->rghoc[uiObj].pcaps->DataIndexMin ) - 1;
                    AssertF(iPosition >= 0);
                    *pdwType |= DIDFT_MAKEINSTANCE(iPosition);
                    this->rgiobj[iPosition] = uiObj;
                 }
                 else
                 {
                     //iLastIndex indicates where to put the non-USAGE_PAGE_BUTTON things
                     //in the order that they come in the report
                    *pdwType |= DIDFT_MAKEINSTANCE(iLastButtonIndex);
                    this->rgiobj[iLastButtonIndex++] = uiObj; 
                 }
                
                 //increment the count of how many real things (excluing gaps) we've got
                 iButton++;
            }
            else if( *pdwType & DIDFT_AXIS )
            {
                if( piRemap[uiObj] == -1 )
                {

                    WORD wUsage;
                    UINT uiObjPrimary = uiObj; 

                    *pdwType &= ~DIDFT_INSTANCEMASK;
                    /*
                     *  Check this axis and it's aliases for a match
                     */
                    while( TRUE )
                    {
                        wUsage = (WORD) ( this->rghoc[uiObj].pcaps->UsageMin
                                        + uiObj 
                                        - this->rgdwBase[this->rghoc[uiObj].pcaps->type] 
                                        - this->rghoc[uiObj].pcaps->DataIndexMin );

                        phum = UsageToUsageMap( DIMAKEUSAGEDWORD( 
                                this->rghoc[uiObj].pcaps->UsagePage, wUsage ) );
                        /*
                         *  Slightly odd loop structure to avoid incrementing 
                         *  uiObj on the last iteration.  This makes sure we 
                         *  don't miss anything in the outer loop and that 
                         *  uiObj relates to the alias we matched when testing 
                         *  for default semantic mappings.
                         */
                        if( phum || (uiObj+1 == this->df.dwNumObjs) 
                         || !this->rghoc[uiObj+1].pcaps->IsAlias )
                        {
                            break;
                        }
                        uiObj++;
                    } 
                    if( phum )
                    {
                        /*
                         *  Since the axis is recognixed up the count
                         */
                        iTypeAxes++;

                        /*
                         *  Find it's position keeping WinMM in mind.
                         */
                        if( ( phum->bPosAxis < 6 )
                          &&( this->rgiaxis[phum->bPosAxis] == -1 ) )
                        {
                            this->rgiaxis[phum->bPosAxis] = uiObjPrimary ;
                            *pdwType |= DIDFT_MAKEINSTANCE(phum->bPosAxis);
                        }
                        else if( ( phum->bPosAxis == 6 )
                               &&( this->rgiaxis[2] == -1 ) )
                        {
                            this->rgiaxis[2] = uiObjPrimary;
                            *pdwType |= DIDFT_MAKEINSTANCE(2);
                        }
                        else
                        {
                            *pdwType |= DIDFT_MAKEINSTANCE(iAxis);
                            this->rgiaxis[iAxis++] = uiObjPrimary ;
                        }

                        /*
                         *  While we know which usage is most recognizable, add in 
                         *  flags to help us refine the device type and save off 
                         *  flags for default semantic mapping of this axis.
                         */
                        this->rgbaxissemflags[DIDFT_GETINSTANCE(*pdwType)] = phum->bSemFlag;
                        pdwHints[DIDFT_GETINSTANCE(*pdwType)] = phum->dwSemHint;
                        dwTypeFlags |= phum->dwSemHint;
                    }
                    else
                    {
                        /*
                         *  Unfortunately, the current HID parser does not 
                         *  implement more unusual HID caps like "preferred 
                         *  state" so just assume any other axes are sliders.
                         */
                        if( this->rghoc[uiObj].pcaps->UsagePage == HID_USAGE_PAGE_SIMULATION )
                        {
                            if( wUsage == HID_USAGE_SIMULATION_CLUTCH )
                            {
                                dwTypeFlags |= DISEM_HINT_CLUTCH;
                                pdwHints[iAxis] = DISEM_HINT_CLUTCH;
                                this->rgbaxissemflags[iAxis] = DISEM_FLAGS_GET( DISEM_FLAGS_C );
                                iTypeAxes++;
                            }
                            else 
                            {
                                if( wUsage == HID_USAGE_SIMULATION_SHIFTER )
                                {
                                    dwTypeFlags |= DISEM_HINT_SHIFTER;
                                    pdwHints[iAxis] = DISEM_HINT_CLUTCH;
                                    iTypeAxes++;
                                }
                                else
                                {
                                    pdwHints[iAxis] = DISEM_HINT_SLIDER;
                                }
                                this->rgbaxissemflags[iAxis] = DISEM_FLAGS_GET( DISEM_FLAGS_S );
                            }
                        }
                        *pdwType |= DIDFT_MAKEINSTANCE(iAxis);
                        this->rgiaxis[iAxis++] = uiObjPrimary ;
                    }
                }
            }
            else 
            {
                /* 
                 *  We already checked that it's one of the above or a POV
                 *  so it must be a POV.
                 */
                AssertF( *pdwType & DIDFT_POV );
                *pdwType &= ~DIDFT_INSTANCEMASK;
                *pdwType |= DIDFT_MAKEINSTANCE(iPOV);
                this->rgipov[iPOV++] = uiObj;
                dwTypeFlags |= DISEM_HINT_POV;
            }
        }

        /*
         *  Now that we know about all the controls we base our type 
         *  decisions on, setup/validate the type and subtype.
         */

        AssertF( GET_DIDEVICE_TYPE( this->dwDevType ) != DI8DEVTYPE_KEYBOARD );

        if( GET_DIDEVICE_TYPE( this->dwDevType ) == DI8DEVTYPE_MOUSE )
        {
            if( dwTypeFlags & DISEM_HINT_ABSOLUTE )
            {
                this->dwDevType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_MOUSE,
                                                     DI8DEVTYPEMOUSE_ABSOLUTE)
                                 | DIDEVTYPE_HID;
            }
        }
        else
        {
            DWORD dwFlags2;
            JOYREGHWSETTINGS    hws;

            /*
             *  Get the old registry flags for initial hints in case this 
             *  device has more generic usages than it needed to have and 
             *  these have registry overrides.
             *  Only look for flags that are less generic to avoid a case 
             *  where an older DInput (or JoyHID) labelled this device 
             *  inadequately.
             *  If the call fails the buffer is zeroed
             */

            JoyReg_GetValue(this->hkType, REGSTR_VAL_JOYOEMDATA, 
                    REG_BINARY, &hws, cbX(hws));

            if( this->hkProp )
            {
                JoyReg_GetValue( this->hkProp, REGSTR_VAL_FLAGS2, REG_BINARY, 
                    &dwFlags2, cbX(dwFlags2) );
            }

            CAssertF( ( DISEM_HINT_THROTTLE >> 6 ) == JOY_HWS_HASZ );
            CAssertF( ( DISEM_HINT_POV >> 6 ) == JOY_HWS_HASPOV );

            dwTestType = GetValidDI8DevType( dwFlags2, iButton, dwTypeFlags >> 14 );

            if( dwTestType )
            {
                /*
                 *  If a valid override exists just use it
                 */
                this->dwDevType = dwTestType | DIDEVTYPE_HID;
            }
            else
            {

#ifdef XDEBUG
                /*
                 *  Fetch the value again in debug so we can report failures.
                 */
                if( this->hkProp )
                {
                    DWORD dwDbgFlags2;
                    JoyReg_GetValue( this->hkProp, REGSTR_VAL_FLAGS2, REG_BINARY, 
                        &dwDbgFlags2, cbX(dwDbgFlags2) );

                    if( GET_DIDEVICE_TYPEANDSUBTYPE( dwDbgFlags2 ) )
                    {
                        RPF( "Ignoring invalid type/subtype Flags2 value 0x%08x for HID", dwDbgFlags2 );
                    }
                }
#endif
                /*
                 *  This one is straight forward
                 */
                if( hws.dwFlags & JOY_HWS_ISHEADTRACKER )
                {
                    dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_SUPPLEMENTAL, 
                        DI8DEVTYPESUPPLEMENTAL_HEADTRACKER );
                    goto MNK_CheckType;
                }

                if( hws.dwFlags & JOY_HWS_ISYOKE )
                {
                    dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_FLIGHT,
                        DI8DEVTYPEFLIGHT_YOKE);
                    goto MNK_CheckType;
                }

                /*
                 *  Other registry flags only relate to the type so the 
                 *  subtype will still need to be found.
                 */
                if( hws.dwFlags & JOY_HWS_ISGAMEPAD )
                {
                    dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_GAMEPAD, DI8DEVTYPEGAMEPAD_STANDARD);
                    goto MNK_AdjustType;
                }
                
            }

            /*
             *  If we have somehow recognized this as a car controller, do any 
             *  processing necessary to munge the axes.
             *  Note we have to go through this path, even if the device has a 
             *  registry override type and subtype so that the right axes get 
             *  used for a device which has been changed into a car controller
             */
            if( ( hws.dwFlags & JOY_HWS_ISCARCTRL ) 
             || fCarController 
             || ( GET_DIDEVICE_TYPE( this->dwDevType ) == DI8DEVTYPE_DRIVING ) )
            {
                dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_DRIVING, 0);

                if( DISEM_HINT_X == ( dwTypeFlags & ( DISEM_HINT_X | DISEM_HINT_STEERING ) ) )
                {
                    /* 
                     *  If the device has no wheel but has an X axis 
                     *  use that instead.  The semantic flags are the 
                     *  same so just switch the hints.
                     */
                    dwTypeFlags ^= ( DISEM_HINT_X | DISEM_HINT_STEERING );
                }
                
                if( ( dwTypeFlags & DISEM_HINT_STEERING ) == 0 )
                {
                    /*
                     *  If there's still no steering wheel, make the type 
                     *  device so it can be processed into a supplemental
                     */
                    dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_DEVICE, 0 );
                }

                /*
                 *  In terms of HID usages, the common forms of pedals are:
                 *
                 *  1)  Accellerator and Brake
                 *  2)  Split Y axis, below center accel, above brake
                 *  3)  Z accel, Y brake
                 *  4)  Y accel, Rz brake
                 *  5)  Z accel, Rz brake
                 *
                 *  The first form is ideal so all that is needed is to 
                 *  make sure that any further processing does not disturb 
                 *  those axes whilst allowing for only one being exact.
                 *  The second form is assumed for a car controller with 
                 *  only a Y (in addition to a possible X).
                 *  The other two forms are distinguished either by an 
                 *  explicite registry flag or by the exact match of Y and 
                 *  Rz with none of Z, accel or brake for the latter form.
                 *  Since a real Z axis would be an oddity on a steering 
                 *  wheel, assume that the IHVs who have taken the Y, Rz 
                 *  path are not going to add a Z.
                 */
                
                
                /*
                 *  If there is an override to Y split pedals and a Y is 
                 *  present then set type and subtype and bypass the rest.
                 */

                switch( dwFlags2 & JOYTYPE_INFOMASK )
                {
                case JOYTYPE_INFODEFAULT:
                    break;
                case JOYTYPE_INFOYYPEDALS:
                    if( dwTypeFlags & DISEM_HINT_Y )
                    {
                        if( dwTypeFlags & DISEM_HINT_STEERING )
                        {
                            dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_DRIVING, DI8DEVTYPEDRIVING_COMBINEDPEDALS );
                        }
                        else
                        {
                            AssertF( GET_DIDEVICE_TYPEANDSUBTYPE( dwTestType ) == MAKE_DIDEVICE_TYPE( DI8DEVTYPE_DEVICE, 0 ) );
                        }
                        goto MNK_CheckType;
                    }
                    RPF( "JOYTYPE_INFOYYPEDALS set but device has no Y" );
                    break;

                case JOYTYPE_INFOZYPEDALS:
                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Y, DISEM_HINT_BRAKE, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_B_1), &GUID_RzAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Z, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_THROTTLE, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );
                    break;
                            
                case JOYTYPE_INFOYRPEDALS:
                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_RZ, DISEM_HINT_BRAKE, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_B_1), &GUID_RzAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Y, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );
                    break;
                            
                case JOYTYPE_INFOZRPEDALS:
                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_RZ, DISEM_HINT_BRAKE, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_B_1), &GUID_RzAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Z, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_THROTTLE, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );
                    break;
                            
                default:
                    RPF( "Ignoring invalid JOYTYPE_INFO* Flags in 0x%08x", dwFlags2 & JOYTYPE_INFOMASK );
                }

                /*
                 *  In the absence of an override, first see if there's 
                 *  anything worth reinterpreting.
                 */
                if( 0 == ( dwTypeFlags & 
                    ( DISEM_HINT_Z | DISEM_HINT_ACCELERATOR | DISEM_HINT_THROTTLE
                    | DISEM_HINT_RZ | DISEM_HINT_BRAKE | DISEM_HINT_ACCELERATOR ) ) )
                {
                    if( ( dwTypeFlags & ( DISEM_HINT_STEERING | DISEM_HINT_Y ) )
                     == ( DISEM_HINT_STEERING | DISEM_HINT_Y ) )
                    {
                        /*
                         *  Combined pedal device
                         */
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_DRIVING, DI8DEVTYPEDRIVING_COMBINEDPEDALS );
                    }
                    else
                    {
                        AssertF( GET_DIDEVICE_TYPEANDSUBTYPE( dwTestType ) == MAKE_DIDEVICE_TYPE( DI8DEVTYPE_DEVICE, 0 ) );
                    }
                    goto MNK_CheckType;
                }
                else if( ( DISEM_HINT_Y | DISEM_HINT_RZ ) == 
                    ( dwTypeFlags 
                    & ( DISEM_HINT_Y | DISEM_HINT_Z | DISEM_HINT_RZ | DISEM_HINT_BRAKE | DISEM_HINT_ACCELERATOR ) ) )
                {
                    /*
                     *  Although the axis GUIDs accel == Y and brake == RZ are 
                     *  already correct, use the common function to change the 
                     *  semantic flags or I'll forget to change the axis flags.
                     */
                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Y, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_RZ, DISEM_HINT_BRAKE, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_B_1), &GUID_RzAxis );
                }
                else
                {
                    /*
                     *  Both of the other split pedal types have a Z-like accelerator
                     */
                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Z, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_THROTTLE, DISEM_HINT_ACCELERATOR, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_A_1), &GUID_YAxis );


                    /*
                     *  Look for a brake on RZ before Y as a device with RZ 
                     *  is very likely to report a Y as well.
                     */
                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_RZ, DISEM_HINT_BRAKE, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_B_1), &GUID_RzAxis );

                    ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                        DISEM_HINT_Y, DISEM_HINT_BRAKE, 
                        DISEM_FLAGS_GET(DIAXIS_ANY_B_1), &GUID_RzAxis );

                }

                /*
                 *  If somehow we have found an accellerator, make sure we 
                 *  don't expose any Y axes as well or the accellerator 
                 *  may get bumped from the default Y position.
                 */
                if( dwTypeFlags & DISEM_HINT_ACCELERATOR )
                {
                    int idx;

                    dwTypeFlags &= ~DISEM_HINT_Y;
                    for( idx = 0; idx < cAxes + 6; idx++ )
                    {
                        if( pdwHints[idx] == DISEM_HINT_Y )
                        {
                            pdwHints[idx] = DISEM_HINT_SLIDER;
                            dwTypeFlags |= DISEM_HINT_SLIDER;
                            this->rgbaxissemflags[idx] = DISEM_FLAGS_GET(DIAXIS_ANY_S_1);
                            this->df.rgodf[this->rgiaxis[idx]].pguid = &GUID_Slider;
                        }
                    }
                }
            }
            else
            {
                /*
                 *  Just take the default calculated from the HID caps (or the override)
                 */
                dwTestType = this->dwDevType;
#ifdef XDEBUG
                if( GET_DIDEVICE_TYPEANDSUBTYPE( dwTestType ) != GET_DIDEVICE_TYPEANDSUBTYPE( dwFlags2 ) )
                {
                    switch( GET_DIDEVICE_TYPE( dwTestType ) )
                    {
                    case DI8DEVTYPE_DEVICE:
                        AssertF( GET_DIDEVICE_SUBTYPE( dwTestType ) == 0 );
                        break;
                    case DI8DEVTYPE_JOYSTICK:
                        AssertF( GET_DIDEVICE_SUBTYPE( dwTestType ) == DI8DEVTYPEJOYSTICK_STANDARD );
                        break;
                    case DI8DEVTYPE_GAMEPAD:
                        AssertF( GET_DIDEVICE_SUBTYPE( dwTestType ) == DI8DEVTYPEGAMEPAD_STANDARD );
                        break;
                    default:
                        RPF( "Invalid type %02x", GET_DIDEVICE_TYPE( dwTestType ) );
                        AssertF( !"Invalid type!" );
                    }
                }
#endif

                /*
                 *  Check for Z axis behavior overrides
                 *  Since the default behavior is to always use a Z as a Z, 
                 *  only the override to slider is needed here.
                 */
                if( dwFlags2 & JOYTYPE_INFOZISSLIDER )
                {
                    if( dwTypeFlags & DISEM_HINT_Z )
                    {
                        /*
                         *  Reset the slider flag as ReinterpretObject does 
                         *  not change axes if the target this axis
                         */
                        dwTypeFlags &= ~DISEM_HINT_SLIDER;
                        ReinterpretObject( this, pdwHints, cAxes, &dwTypeFlags, 
                            DISEM_HINT_Z, DISEM_HINT_SLIDER, 
                            DISEM_FLAGS_GET(DIAXIS_ANY_S_1), &GUID_Slider );
                    }
                    else
                    {
                        RPF( "JOYTYPE_INFOZISSLIDER set but device has no Z" );
                    }
                }
            }

            /*
             *  If the dwFlags2 and dwTestType are the same, we are using a 
             *  registry override so don't try to refine it.
             */
            if( GET_DIDEVICE_TYPEANDSUBTYPE( dwTestType ) != GET_DIDEVICE_TYPEANDSUBTYPE( dwFlags2 ) )
            {
                if( dwTypeFlags & DISEM_HINT_STEERING )
                {
                    /*
                     *  If it has a steering wheel, it's a driving device
                     */
                    dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_DRIVING, 0 );
                }
                else if( ( dwTypeFlags & DISEM_HINT_SIXDOF ) == DISEM_HINT_SIXDOF )
                {
                    /*
                     *  Special case six degree of freedom devices
                     */
                    dwTestType = MAKE_DIDEVICE_TYPE(DI8DEVTYPE_1STPERSON, 
                        DI8DEVTYPE1STPERSON_SIXDOF );
                    goto MNK_CheckType;
                }

MNK_AdjustType:;
                /*
                 *  We should be left with only the following device types: 
                 *      joystick, gamepad, driving and device
                 *  For the first three only subtypes need to be found.
                 *  For DI8DEVTYPE_DEVICE some may be changed to 
                 *  DI8DEVTYPE_SUPPLEMENTAL if an appropriate subtype can be 
                 *  found.
                 */
                switch( GET_DIDEVICE_TYPE( dwTestType ) )
                {
                case DI8DEVTYPE_DEVICE:
                    /*
                     *  Since this is not a joystick or gamepad, only use it 
                     *  if it has the vehicle simulation controls we support.
                     */
                    if( ( dwTypeFlags & ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE | DISEM_HINT_CLUTCH ) )
                     == ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE | DISEM_HINT_CLUTCH ) )
                    {
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, 
                            DI8DEVTYPESUPPLEMENTAL_THREEPEDALS );
                    }
                    else if( ( dwTypeFlags & ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE ) )
                          == ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE ) )
                    {
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, 
                            DI8DEVTYPESUPPLEMENTAL_DUALPEDALS );
                    }
                    else if( dwTypeFlags & DISEM_HINT_THROTTLE ) 
                    {
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, 
                            DI8DEVTYPESUPPLEMENTAL_THROTTLE );
                    }
                    else if( dwTypeFlags & DISEM_HINT_SHIFTER ) 
                    {
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, 
                            DI8DEVTYPESUPPLEMENTAL_SHIFTER );
                    }
                    else if( dwTypeFlags & DISEM_HINT_RUDDER ) 
                    {
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, 
                            DI8DEVTYPESUPPLEMENTAL_RUDDERPEDALS );
                    }
                    else
                    {
                        /* 
                         *  Totally unknown so leave it as device 
                         *  Allowing other devices to be treated as game 
                         *  controllers can cause HID controls on devices 
                         *  such as speakers to be included.
                         */
                    }
                    break;
                case DI8DEVTYPE_JOYSTICK:
                case DI8DEVTYPE_GAMEPAD:
                    if( ( dwTypeFlags & ( DISEM_HINT_X | DISEM_HINT_Y ) ) != ( DISEM_HINT_X | DISEM_HINT_Y ) )
                    {
                        dwTestType = MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, 
                            DI8DEVTYPESUPPLEMENTAL_UNKNOWN );
                    }
                    break;

                case DI8DEVTYPE_DRIVING:
                    if( ( dwTypeFlags & ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE | DISEM_HINT_CLUTCH ) )
                     == ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE | DISEM_HINT_CLUTCH ) )
                    {
                        dwTestType |= MAKE_DIDEVICE_TYPE( 0, DI8DEVTYPEDRIVING_THREEPEDALS );
                    }
                    else if( ( dwTypeFlags & ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE ) )
                     == ( DISEM_HINT_ACCELERATOR | DISEM_HINT_BRAKE ) )
                    {
                        dwTestType |= MAKE_DIDEVICE_TYPE( 0, DI8DEVTYPEDRIVING_DUALPEDALS );
                    }
                    else if( dwTypeFlags & DISEM_HINT_Y  ) 
                    {
                        dwTestType |= MAKE_DIDEVICE_TYPE( 0, DI8DEVTYPEDRIVING_COMBINEDPEDALS );
                    }
                    else
                    {
                        dwTestType |= MAKE_DIDEVICE_TYPE( 0, DI8DEVTYPEDRIVING_LIMITED );
                    }
                    break;

                default:
                    AssertF( !"Unexpected device type" );
                }
        
            
                /*
                 *  Use the common function to make this a limited type if the 
                 *  number of buttons or flags dictate it.
                 *  Since the type and subtype are known to be valid, the return 
                 *  value should never be a failure (zero).
                 */
MNK_CheckType:;
                this->dwDevType = DIDEVTYPE_HID 
                    | GetValidDI8DevType( dwTestType, iButton, hws.dwFlags );
                AssertF( this->dwDevType & ~DIDEVTYPE_HID );
            }                        
        }

        /*
         *  Finally, mark all secondary aliases with the primary alias 
         *  instance and sqfl all the translations.
         */
        for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
        {
            int iPrimary;
            D( iPrimary = -1; )

            if( this->rghoc[uiObj].pcaps )
            {
                if( !this->rghoc[uiObj].pcaps->IsAlias )
                {
                    iPrimary = this->df.rgodf[uiObj].dwType;
                }
                else
                {
                    D( AssertF( iPrimary != -1 ) );
                    /*
                     *  Prefix notices that iPrimary would be uninitialized if 
                     *  we find the alias before the primary but that should 
                     *  never happen as the object are sorted by definition.
                     */
                    if( DIDFT_GETTYPE(iPrimary) != DIDFT_GETTYPE(this->df.rgodf[uiObj].dwType) )
                    {
                        SquirtSqflPtszV(sqflHidParse | sqflError,
                            TEXT("CHid_MungeNotKeyboard: uiObj: %d dwType 0x%08x ")
                            TEXT("does not match primary 0x%08x"),
                            uiObj, this->df.rgodf[uiObj].dwType, iPrimary );
                    }
                    /*
                     *  There are very few attributes of an alias that are not 
                     *  overridden by the primary.
                     */
                    this->df.rgodf[uiObj].dwType = ( iPrimary & ~DIDFT_ALIASATTRMASK ) 
                                                 | ( this->df.rgodf[uiObj].dwType & DIDFT_ALIASATTRMASK );
                }
                SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                                TEXT("CHid_MungeNotKeyboard: uiObj: %d set to dwType 0x%08x"),
                                uiObj, this->df.rgodf[uiObj].dwType );
            }
            else
            {
                SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                                TEXT("CHid_MungeNotKeyboard: uiObj: %d  has pcaps == NULL"),
                                uiObj );                
            }
        }

    }
    else
    {
        FreePpv( &this->rgbaxissemflags );
    }
    FreePpv( &piRemap );

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitObjects |
 *
 *          Identify and initialize the objects supported by the device.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitObjects(PCHID this)
{
    HRESULT hres;
    UINT uiObj;
    UINT iType;
    /*
     *  Build the base array table to convert HID item indexes
     *  into DirectInput ID instance numbers.
     */
    AssertF(this->rgdwBase[HidP_Input] == 0);
    this->rgdwBase[HidP_Feature] = this->caps.NumberInputDataIndices;
    this->rgdwBase[HidP_Output ] = this->rgdwBase[HidP_Feature] +
                                   this->caps.NumberFeatureDataIndices;
    this->rgdwBase[HidP_Coll   ] = this->rgdwBase[HidP_Output ] +
                                   this->caps.NumberOutputDataIndices;


    /*
     *  Determine if this device supports PID 
     */
    this->fPIDdevice = FALSE;
    if(    this->caps.NumberOutputValueCaps != 0x0 
        && this->caps.NumberOutputButtonCaps != 0x0 )
    {
        NTSTATUS    ntStat;
        USHORT      cAButton=0x0;
        
        ntStat = HidP_GetSpecificButtonCaps
         (
                HidP_Output,                        // ReportType
                HID_USAGE_PAGE_PID,                 // UsagePage
                0x0,                                // Link Collection
                0x0,                                // Usage 
                NULL,                               // ValueCaps
                &cAButton,                          // ValueCapsLength
                this->ppd                           // PreparsedData
         );

        
        if(     ntStat == HIDP_STATUS_BUFFER_TOO_SMALL
            &&  cAButton > 0x2    // Is this enough for PID device ??   
            )
        {
            this->fPIDdevice = TRUE;
        }
     }


    /*
     *  Note that we must do axes first because that keeps
     *  everything aligned.
     *
     *  Warning, diem.c assumes axes come first.
     */
    hres = CHid_InitAxes(this);
    if(FAILED(hres))
    {
        goto done;
    }

    hres = CHid_InitButtons(this);
    if(FAILED(hres))
    {
        goto done;
    }

    hres = CHid_InitCollections(this);
    if(FAILED(hres))
    {
        goto done;
    }

    /*
     *  Round the data size up to the nearest DWORD.
     */
    this->df.dwDataSize = (this->df.dwDataSize + 3) & ~3;

    /*
     * Allocate memory for report ID enable flags
     *
     *  ISSUE-2001/05/12-MarcAnd  Memory allocations should be merged
     *  These memory blocks could be merged.  For most devices the total memory 
     *  needed is only one or two bytes so there may be better ways.
     */
    for( iType = HidP_Input; iType < HidP_Max; iType++ )
    {
        this->wMaxReportId[iType] += 1;
        hres = AllocCbPpv(this->wMaxReportId[iType], &this->pEnableReportId[iType]);
        if( FAILED(hres) )
        {
            goto done;
        }
    }



    AssertF(this->rgiobj == 0);

    /*
     *  Munge the data before trying to look up supplemental 
     *  information in the registry.
     */
    if(GET_DIDEVICE_TYPE(this->dwDevType) == DI8DEVTYPE_KEYBOARD)
    {
        CHid_MungeKeyboard(this);
    }
    else
    {
        CHid_MungeNotKeyboard(this);
    }

    /*
     *  Collect attributes for each object and add them to the
     *  device type code.  This allows the registry to enable
     *  things like force feedback.
     */
    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        CType_RegGetTypeInfo(this->hkType, &this->df.rgodf[uiObj], this->fPIDdevice);
        if( ( GET_DIDEVICE_TYPE(this->dwDevType) == DI8DEVTYPE_DRIVING )
         && ( this->df.rgodf[uiObj].dwFlags & DIDOI_FFACTUATOR )
         && ( this->df.rgodf[uiObj].pguid != &GUID_XAxis ) )
        {
            /*
             *  IHVs set FF attributes on non-FF axes for wheels because 
             *  first generation FF apps were only written to support joysticks.
             *  Since we now munge the various configurations of pedal axes to 
             *  report all split pedals in the same way, the fake Y axis can 
             *  land up on different axes, usually Slider0.  Rather than have 
             *  people code to these different fake axes, strip out actuator 
             *  status from any driving axis except the wheel.
             */
            this->df.rgodf[uiObj].dwFlags &= ~DIDOI_FFACTUATOR;
            this->df.rgodf[uiObj].dwType &= ~DIDFT_FFACTUATOR;
        }
    }

    #ifdef DEBUG
    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        PHIDGROUPCAPS pcaps;
        UINT uiObjReal =
            CHid_ObjFromType(this, this->df.rgodf[uiObj].dwType);
        pcaps = this->rghoc[uiObjReal].pcaps;
        if(pcaps)
        {
            AssertF(pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE);
        }
        
        if( uiObjReal != uiObj )
        {
            RPF( "uiObj = 0x%08x, type = 0x%08x, exposed Obj = 0x%08x",
                uiObj, this->df.rgodf[uiObj].dwType, uiObjReal );
        }
        AssertF(CHid_ObjFromType(this, this->df.rgodf[uiObj].dwType)
                == uiObj);

        /*
         *  Anything that is DIDFT_AXIS must be a HID axis.  However,
         *  the converse is not true for the case of analog buttons.
         */
        AssertF(fLimpFF(this->df.rgodf[uiObj].dwType & DIDFT_AXIS,
                        pcaps->IsValue));

        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("CHid_InitObj: uiObj = %02x, dwType = %08x"),
                        uiObj, this->df.rgodf[uiObj].dwType);

    }
    #endif

    hres = S_OK;

    done:;
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitParse |
 *
 *          Identify and initialize the data structures needed for
 *          parsing reports.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_InitParse(PCHID this)
{
    DWORD cb;
    HRESULT hres;

    /*
     *  Obtain the maximum number of HIDP_DATA structures
     *  that will be returned at one go.
     */

    this->hriIn .cdataMax = HidP_MaxDataListLength(HidP_Input ,  this->ppd);
    this->hriOut.cdataMax = HidP_MaxDataListLength(HidP_Output,  this->ppd);
    this->hriFea.cdataMax = HidP_MaxDataListLength(HidP_Feature, this->ppd);

    /*
     *  More annoyances.
     */
    this->hriIn .cbReport = this->caps.  InputReportByteLength;
    this->hriOut.cbReport = this->caps. OutputReportByteLength;
    this->hriFea.cbReport = this->caps.FeatureReportByteLength;

    /*
     *  Some trace squirties because HID is tricky.
     */

    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_InitParse: MaxDataListLength(Input)  = %d"),
                    this->hriIn.cdataMax);
    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_InitParse: MaxDataListLength(Output) = %d"),
                    this->hriOut.cdataMax);
    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_InitParse: MaxDataListLength(Feature)= %d"),
                    this->hriFea.cdataMax);
    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_InitParse: InputReportByteLength     = %d"),
                    this->caps.InputReportByteLength);
    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_InitParse: OutputReportByteLength    = %d"),
                    this->caps.OutputReportByteLength);
    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_InitParse: FeatureReportByteLength   = %d"),
                    this->caps.FeatureReportByteLength);

    /*
     *  Now allocate all the report-related memory.
     */
    this->cbPhys = this->df.dwDataSize;

    /*
     *  Allocating the memory is done in four phases.
     *
     *  1. Tally up how much memory we need,
     *  2. Allocate that memory,
     *  3. Dole out the memory we allocated,
     *  4. Check that we didn't mess up.
     *
     *  Since this is extremely error-prone (I've messed it up at least
     *  once), the work is hidden inside macros.
     *
     *  The macro THINGS expands to a series of THING()s, each of which
     *  specifies a field name and the size it should be.  Each time you
     *  want to iterate over the fields, use the THINGS macro.
     *
     *  (Yes, this is the same comment block as when we did this before.)
     *
     *  Note, the arrays of HIDP_DATA structures must be correctly
     *  aligned in some architechtures.
     */
    CAssertF( FIELD_OFFSET(CHID, hriIn.rgdata) == FIELD_OFFSET(CHID, pvGroup2) );

    #define THINGS()                                                        \
        THING(hriIn.rgdata,    cbCxX(this->hriIn.cdataMax, HIDP_DATA));     \
        THING(hriOut.rgdata,   cbCxX(this->hriOut.cdataMax, HIDP_DATA));    \
        THING(hriFea.rgdata,   cbCxX(this->hriFea.cdataMax, HIDP_DATA));    \
        THING(hriIn.pvReport,  this->hriIn.cbReport);                       \
        THING(hriOut.pvReport, this->hriOut.cbReport);                      \
        THING(hriFea.pvReport, this->hriFea.cbReport);                      \
        THING(pvPhys,          this->cbPhys);                               \
        THING(pvStage,         this->cbPhys);                               \

    /*
     *  Make a pass through the fields adding up the memory requirements.
     */
    #define THING(f, cbF)       cb += cbF
    cb = 0;
    THINGS();
    #undef THING

    hres = ReallocCbPpv(cb, &this->pvGroup2);

    if(SUCCEEDED(hres))
    {

        PV pv;

        /*
         *  Assert that the allocation is aligned
         */
        AssertF( !( ((UINT_PTR)this->pvGroup2) & ( MAX_NATURAL_ALIGNMENT - 1 ) ) );

        /*
         *  Make a pass through the fields carving up the memory block
         *  and handing out pieces of it.
         */
    #define THING(f, cbF) this->f = pv; pv = pvAddPvCb(pv, cbF)
        pv = this->pvGroup2;
        THINGS();
    #undef THING

        /*
         *  There should be no byte left over.
         */
        AssertF(pvAddPvCb(this->pvGroup2, cb) == pv);

    }

    #undef THINGS

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitParseData |
 *
 *          Post-init pass to set up all the data used by parsing.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    CHid_InitParseData(PCHID this)
{
    HRESULT hres;
    UINT uiObj;

    /*
     *  Preinitialize the HIDP_DATA indices to -1 to indicate
     *  that they aren't there.  We must do this before we
     *  mess with AddDeviceData, which assumes that all the
     *  indices are properly set up.
     */
    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        this->rghoc[uiObj].idata = -1;
    }

    /*
     *  Now do some initialization of each object.
     */
    for(uiObj = 0; uiObj < this->df.dwNumObjs; uiObj++)
    {
        PHIDGROUPCAPS pcaps = this->rghoc[uiObj].pcaps;
        LPDIOBJECTDATAFORMAT podf = &this->df.rgodf[uiObj];

        /* 
         *  ISSUE-2001/03/13-MarcAnd  Should we panic if this assertion fails?
         */
        AssertF(pcaps);

        if(pcaps)
        {
            /*
             *  For input-like objects, we need to initialize the
             *  physical state fields to sane defaults so apps
             *  don't get confused if they issue a read before the first
             *  report arrives.
             *
             *  Buttons start out not pressed, which means we don't need
             *  to do anything since it's already zero-initialized.
             *
             *  Relative axes start out not moving, which means we don't need
             *  to do anything since it's already zero-initialized.
             *
             *  Absolute axes start out centered.
             *
             *  POVs start out neutral.
             *
             */

            /* No calibration for features as they are input / output */

            if(pcaps->type == HidP_Input )
            {
                LONG UNALIGNED * pl;

                pl = pvAddPvCb(this->pvPhys, podf->dwOfs);

                if(podf->dwType & DIDFT_ABSAXIS )
                {
                    if( this->rghoc[uiObj].pjrc->fRaw )
                        *pl = (this->rghoc[uiObj].pcaps->Logical.Min + this->rghoc[uiObj].pcaps->Logical.Max) / 2;
                    else
                        *pl = this->rghoc[uiObj].pjrc->lC;
                } else if(podf->dwType & DIDFT_POV)
                {
                    *pl = JOY_POVCENTERED;
                }
            }

            /*
             *  ISSUE-2001/03/13-MarcAnd output objects uninitialized
             *  For output-like objects, we would have liked to have set the 
             *  value to Null if possible to keep things vaguely sane.
             *  Unfortunately code like:
             *      if(HidP_IsOutputLike(pcaps->type))
             *      {
             *          CHid_AddDeviceData(this, uiObj,pcaps->Null);
             *      }
             *  Does not work!
             */
        }
    }

    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | InitAttributes |
 *
 *          Pull out the <t HIDD_ATTRIBUTES> and squirrel away the
 *          information we like.  Doing this up front is important
 *          in case the device gets unplugged later and we lose the
 *          ability to talk to it.
 *
 *  @parm   PHIDD_ATTRIBUTES | pattr |
 *
 *          <t HIDD_ATTRIBUTES> containing attributes of device.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    CHid_InitAttributes(PCHID this, PHIDD_ATTRIBUTES pattr)
{
    HRESULT hres;

    TCHAR tszType[20];
    #ifndef UNICODE
    WCHAR wszType[20];
    #endif
    int ctch;

    // Input report is disabled until we read flags2 from registry.
    this->fEnableInputReport = FALSE;
    this->fFlags2Checked = FALSE;

    this->ProductID = pattr->ProductID;
    this->VendorID = pattr->VendorID;

    AssertF(this->hkType == 0);

    if( ( this->VendorID == MSFT_SYSTEM_VID )
      &&( ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN )
        &&( this->ProductID < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
    {
        /* 
         *  Predefined types don't have keys 
         */
    }
    else
    {
        /*
         *  The type key for HID devices is "VID_xxxx&PID_yyyy",
         *  mirroring the format used by plug and play.
         */
        ctch = wsprintf(tszType, VID_PID_TEMPLATE,
                        this->VendorID, this->ProductID);

        AssertF(ctch < cA(tszType));

        #ifdef UNICODE
        hres = JoyReg_OpenTypeKey(tszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &this->hkType);
        JoyReg_OpenPropKey(tszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &this->hkProp);
        /*
         * If we fail to open the prop key - we will continue to function with loss in functionality
         * Specifically no device images, etc
         */
        #else
        TToU(wszType, cA(wszType), tszType);
        hres = JoyReg_OpenTypeKey(wszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &this->hkType);
        JoyReg_OpenPropKey(wszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &this->hkProp);
        /*
         * If we fail to open the prop key - we will continue to function with loss in functionality
         * Specifically no device images, etc
         */

        #endif

        /*
         *  It is not a problem if we can't open the type key.
         *  The device will run suboptimally, but it will still run.
         */
        AssertF(fLeqvFF(SUCCEEDED(hres), this->hkType));

        
    }
    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CHid_DoPathAndIdMatch |
 *
 *          Given a device name, obtain the corresponding path
 *          ("device interface") associated with it, and check
 *          that it's the right string.
 *
 *  @parm   LPCTSTR | ptszId |
 *
 *          The device name.
 *
 *  @parm   LPCTSTR | ptszPath |
 *
 *          The path we should get back.
 *
 *****************************************************************************/

BOOL INTERNAL
    CHid_DoPathAndIdMatch(LPCTSTR ptszId, LPCTSTR ptszPath)
{
    GUID guidHid;
    HDEVINFO hdev;
    BOOL fRc;

    HidD_GetHidGuid(&guidHid);

    hdev = SetupDiGetClassDevs(&guidHid, ptszId, 0,
                               DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVICE_INTERFACE_DATA did;
        PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;

        /* 
         *  SetupDI requires that the caller initialize cbSize.
         */
        did.cbSize = cbX(did);

        if(SetupDiEnumDeviceInterfaces(hdev, 0, &guidHid, 0, &did))
        {
            pdidd      = NULL;
            if(DIHid_GetDevicePath(hdev, &did, &pdidd, NULL))
            {
                fRc = ( lstrcmpi(pdidd->DevicePath, ptszPath) == 0x0 );
                if( fRc == FALSE )
                {
                    SquirtSqflPtszV(sqflHidParse | sqflError,
                                    TEXT("pdidd->DevicePath = %s")
                                    TEXT("ptszPath = %s "),
                                    pdidd->DevicePath, ptszPath
                                   );
                }
                FreePv(pdidd);
            } else // GetDevicePath FAILED
            {
                fRc = FALSE;
                SquirtSqflPtszV(sqflHidParse,
                                TEXT("GetDevicePath FAILED"));
            }
        } else // SetupDiEnumDeviceInterface FAILED
        {
            fRc = FALSE;
            SquirtSqflPtszV(sqflHidParse,
                            TEXT("SetupDiEnumDeviceInterface FAILED"));
        }
        SetupDiDestroyDeviceInfoList(hdev);
    } else // SetupDiGetClassDevs FAILED
    {
        fRc = FALSE;
        SquirtSqflPtszV(sqflHidParse,
                        TEXT("SetupDiGetClassDevs FAILED"));
    }

    return fRc;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | IsPolledDevice |
 *
 *          Returns true if this device has to be polled for input data
 *          False if this device supports event driven input 
 *
 *  @parm   HANDLE | hdev |
 *
 *          File Handle to a HID device
 *
 *****************************************************************************/

BOOL EXTERNAL CHid_IsPolledDevice( HANDLE hdev )
{

    /*
     *  To determine if a device is polled, we send it an IOCTL to set its 
     *  poll frequency.  If the device responds with a, huh! 
     *  (STATUS_INVALID_DEVICE_REQUEST) then we know the device is not polled.  
     *  On Win2k we use the poll interval value zero which is a special value 
     *  that signals HID that we want to do opportunistic polls rather than 
     *  polls on a background timer.  In this case, as long as polls are not 
     *  faster than the predefined minimum (currently 5ms) the poll will be 
     *  completed either with recent data or the result of an immediate poll.
     *  On Win98 Gold opportunistic polls are not implemented so we always 
     *  use HIDs background polling, with an interval set to keep the device 
     *  responsive without swamping the system.  To make sure we use a read 
     *  thread, rather than a blocking read, we have to treat this devices as 
     *  interrupt driven.
     *  HID makes this change the polling interval specific to our handle so 
     *  that other apps reading from this device will not be damaged.
     */
    BOOL    frc;
    ULONG   uPollingFreq;
    DWORD   cbRc;

#ifdef WINNT
    BOOL    fRet;
    uPollingFreq = 0;
#else
    uPollingFreq = 40;
#endif

    frc = DeviceIoControl (hdev,
                           IOCTL_HID_SET_POLL_FREQUENCY_MSEC,
                           &uPollingFreq, cbX(uPollingFreq),
                           &uPollingFreq, cbX(uPollingFreq),
                           &cbRc, NULL);
#ifdef WINNT
    if( frc )
    {
        SquirtSqflPtszV(sqflHidParse,
                        TEXT("CHid_IsPolledDevice: Opportunistic polling set") );
        fRet = TRUE;            
    } else
    {
        SquirtSqflPtszV(sqflHidParse,
                        TEXT("CHid_IsPolledDevice: NOT POLLED, LastError = 0x%x"),
                        GetLastError());
        fRet = FALSE;
    }
    return fRet;

#else
    return FALSE;
#endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HANDLE | CHid_OpenDevicePath |
 *
 *          Given a device name, open the device via its
 *          device interface.
 *
 *  @parm   LPCTSTR | ptszId |
 *
 *  @parm   DWORD | dwAttributes |
 *          
 *          Create File attributes 
 *
 *          The device name.
 *
 *****************************************************************************/

HANDLE EXTERNAL
    CHid_OpenDevicePath(PCHID this, DWORD dwAttributes)
{
    HANDLE hDev;

    hDev = CreateFile(this->ptszPath,
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   0,                /* no SECURITY_ATTRIBUTES */
                   OPEN_EXISTING,
                   dwAttributes, /* attributes */
                   0);               /* template */

    if( hDev == INVALID_HANDLE_VALUE )
    {
        SquirtSqflPtszV(sqflHidParse | sqflBenign,
            TEXT("Failed to open HID %s, le=%d"), this->ptszPath, GetLastError() );
    }

    this->IsPolledInput = CHid_IsPolledDevice(hDev);

    return hDev;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetHdevInfo |
 *
 *          Get information about the device that is kept in the
 *          HANDLE itself.  We create the handle, get the goo, and
 *          then close the handle.
 *
 *          The preparsed data is stashed into the <e CHid.ppd>
 *          field of the <t CHid> structure.
 *
 *  @parm   PHIDD_ATTRIBUTES | pattr |
 *
 *          Receives the <t HIDD_ATTRIBUTES> of the device.
 *
 *****************************************************************************/

BOOL INTERNAL
    CHid_GetHdevInfo(PCHID this, PHIDD_ATTRIBUTES pattr)
{
    HANDLE hdev;
    BOOL fRc = FALSE;

    hdev = CHid_OpenDevicePath(this, FILE_FLAG_OVERLAPPED);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        pattr->Size = cbX(*pattr);
        if( HidD_GetAttributes(hdev, pattr) )
        {
            if( HidD_GetPreparsedData(hdev, &this->ppd) )
            {
                fRc = TRUE;
            }
            else
            {
                RPF( "HidD_GetPreparsedData failed, le=%d", GetLastError() );
            }
        }
        else
        {
            RPF( "HidD_GetAttributes failed, le=%d", GetLastError() );
        }
        CloseHandle(hdev);
    }
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Init |
 *
 *          Initialize the object.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    CHid_Init(PCHID this, REFGUID rguid)
{
    HRESULT hres = E_FAIL;
    PHIDDEVICEINFO phdi;
    EnterProc(CHid_Init, (_ "p", this));

    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_Init: Starting %08x"), rguid->Data1);

    this->df.dwSize = cbX(DIDATAFORMAT);
    this->df.dwObjSize = cbX(DIOBJECTDATAFORMAT);

    AssertF(this->df.dwDataSize == 0);
    AssertF(this->df.rgodf == 0);
    AssertF(this->df.dwFlags == 0);
    AssertF(this->df.dwNumObjs == 0);
    AssertF(this->dwAxes == 0);
    AssertF(this->dwButtons == 0);
    AssertF(this->dwCollections == 0);

    this->idJoy = -1;                   /* Unknown associated VJOYD device */
    this->hdev = INVALID_HANDLE_VALUE;
    this->hdevEm = INVALID_HANDLE_VALUE;

    this->diHacks.nMaxDeviceNameLength = MAX_PATH;

    DllEnterCrit();

    phdi = phdiFindHIDInstanceGUID(rguid);

    if(phdi)
    {
        this->dwDevType = phdi->osd.dwDevType;
        this->idJoy = phdi->idJoy;

        /*
         *  Dup the registry key so we can hang onto it after
         *  the original has been closed.  If the RegOpenKeyEx
         *  fails, the value of this->hkInstType will stay zero
         *  so we won't run with garbage.
         */
        AssertF(this->hkInstType == 0);

        hres = hresMumbleKeyEx(phdi->hk, 
                               TEXT("Type"), 
                               DI_KEY_ALL_ACCESS, 
                               REG_OPTION_NON_VOLATILE, 
                               &this->hkInstType);
        /*
         *  Dup the paths and stuff.
         */
        hres = hresDupPtszPptsz(phdi->pdidd->DevicePath, &this->ptszPath);

        if(SUCCEEDED(hres))
        {
            hres = hresDupPtszPptsz(phdi->ptszId, &this->ptszId);
        }
    }

    /*
     *  Get out of the critical section as quickly as possible.
     *  Note phdi is invalid once we leave the critical section however 
     *  we can safely use is as a flag that the GUID was found.
     */
    DllLeaveCrit();

    if(phdi)
    {
        if(SUCCEEDED(hres))
        {
            HIDD_ATTRIBUTES attr;
            
            if( !CHid_GetHdevInfo(this, &attr) )
            {
                SquirtSqflPtszV(sqflHidParse | sqflError,
                    TEXT("%hs: CHid_GetHdevInfo failed"), s_szProc );
                hres = E_FAIL;
            }
            else if( FAILED(HidP_GetCaps(this->ppd, &this->caps) ) )
            {
                SquirtSqflPtszV(sqflHidParse | sqflError,
                    TEXT("%hs: HidP_GetCaps failed, le=%d"), s_szProc, GetLastError() );
                hres = E_FAIL;
            }
            else if( !CHid_DoPathAndIdMatch(this->ptszId, this->ptszPath) )
            {
                SquirtSqflPtszV(sqflHidParse | sqflError,
                    TEXT("%hs: Path and HW ID do not match"), s_szProc );
                hres = E_FAIL;
            }
            else
            {

                if(SUCCEEDED(hres = CHid_InitAttributes(this, &attr)) &&
                   SUCCEEDED(hres = CHid_AllocObjectMemory(this)) &&
                   SUCCEEDED(hres = CHid_InitObjects(this)) &&
                   SUCCEEDED(hres = CHid_InitParse(this)) &&
                   SUCCEEDED(hres = CHid_InitParseData(this)))
                {

                    VXDDEVICEFORMAT devf;
                    UINT uiCal;

                    /*
                     *  Load calibration information, and if there were
                     *  no calibratable items, then wipe out this->pjrcNext
                     *  to indicate that there is no need to watch for
                     *  recalibration messages.
                     */
                    uiCal = CHid_LoadCalibrations(this);
                    if(uiCal == 0)
                    {
                        this->pjrcNext = NULL;
                    }

                    

                    /*
                     *  Remember to do this after we have
                     *  created the data format.
                     */
                    devf.cbData  = this->df.dwDataSize;
                    devf.cObj    = this->df.dwNumObjs;
                    devf.rgodf   = this->df.rgodf;
                    /* 
                     *  Note, dwExtra is 64 bits on 64 bit platforms
                     *  should update the name one day.
                     */
                    devf.dwExtra = (UINT_PTR)this;
                    devf.dwEmulation = 0;

                    hres = Hel_HID_CreateInstance(&devf, &this->pvi);  

                    /* Polled input devices may not be attached */
                    if(this->IsPolledInput)
                    {
                        HANDLE hdev;
                        PHIDDEVICEINFO  phdi;
                        PBUSDEVICEINFO  pbdi;

                        hdev = CHid_OpenDevicePath(this, 0x0);

                        if( hdev != INVALID_HANDLE_VALUE )
                        {
                            int i;
                            BOOL frc;
                            DWORD cbRead;                        
                            BOOL bPresent = FALSE;

                            for( i=0x0; i < FAILED_POLL_THRESHOLD; i++ )
                            {
                                frc = ReadFile(hdev, this->hriIn.pvReport,
                                               this->hriIn.cbReport, &cbRead, 0x0  );

                                if( frc != 0x0  &&
                                    cbRead == this->hriIn.cbReport )
                                {
                                    bPresent = TRUE;
                                    break;
                                } else
                                {
                                    Sleep(10);
                                    
                                    SquirtSqflPtszV(sqflHidParse | sqflVerbose,
                                                    TEXT("CHid_Init: ReadFailed, LastError = 0x%x"),
                                                    GetLastError());
                                
                                }
                            }

                            CloseHandle(hdev);

                            if( bPresent == FALSE )
                            {
                                this->pvi->fl |=  VIFL_UNPLUGGED;                            
                                SquirtSqflPtszV(sqflHidParse | sqflBenign,
                                                TEXT("%hs: ReadFailed, setting to unplugged"), s_szProc );
                            }

                            DllEnterCrit();

                            phdi = phdiFindHIDDeviceInterface(this->ptszPath);
                            AssertF(phdi != NULL);
                            pbdi = pbdiFromphdi(phdi);

                            DllLeaveCrit();


                            if( pbdi != NULL )
                            {
                                if( pbdi->fDeleteIfNotConnected == TRUE )
                                {
                                    if( bPresent == FALSE )
                                    {
                                        lstrcpy( g_tszIdLastRemoved, pbdi->ptszId );
                                        g_tmLastRemoved = GetTickCount();

                                        DIBusDevice_Remove(pbdi);
                                    }
                                    pbdi->fDeleteIfNotConnected = FALSE;
                                }
                            }
                        } else
                        {
                            // Could not Open the device 
                            this->pvi->fl |=  VIFL_UNPLUGGED;
                        }
                    }
                }
            } 
        }
    } else
    {
        // Squirt: device mysteriously gone
        hres = DIERR_DEVICENOTREG;
    }

    SquirtSqflPtszV(sqflHidParse,
                    TEXT("CHid_Init: Ending %08x"), rguid->Data1);

    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dihidenm.c ===
/*****************************************************************************
 *
 *  DIHidEnm.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Support functions for HID enumeration.
 *
 *  Contents:
 *
 *      DIHid_BuildHidList
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHid


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global PHIDDEVICELIST | g_hdl |
 *
 *          List of known HID devices.
 *
 *  @global DWORD | g_tmLastHIDRebuild |
 *
 *          The time we last rebuilt the HID list.  Zero means that the
 *          HID list has never been rebuilt.  Watch out for wraparound;
 *          a 32-bit value rolls over after about 30 days.
 *
 *****************************************************************************/

#define MSREBUILDRATE       20000                /* Twenty seconds */
#define MSREBUILDRATE_FIFTH  5000                /* Two seconds */

PHIDDEVICELIST g_phdl;
DWORD g_tmLastHIDRebuild;

TCHAR g_tszIdLastRemoved[MAX_PATH];
DWORD g_tmLastRemoved = 0;
TCHAR g_tszIdLastUnknown[MAX_PATH];
DWORD g_tmLastUnknown = 0;


    #pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFindHIDInstanceGUID |
 *
 *          Locates information given an instance GUID for a HID device.
 *
 *          The parameters have already been validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          The instance GUID to be located.
 *
 *  @returns
 *
 *          Pointer to the <t HIDDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PHIDDEVICEINFO EXTERNAL
    phdiFindHIDInstanceGUID(PCGUID pguid)
{
    PHIDDEVICEINFO phdi;

    AssertF(InCrit());

    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0, phdi = g_phdl->rghdi; 
           ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            if(IsEqualGUID(pguid, &phdi->guid)  )
            {
                goto done;
            }
        }
        /* 
         * Memphis Bug#68994. App does not detect USB device. 
         * App was using product guid. 
         * Fix: We allow match to HID guid, if product guid is specfied
         */
        for(ihdi = 0, phdi = g_phdl->rghdi;
           ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            if(IsEqualGUID(pguid, &phdi->guidProduct)  )
            {
                RPF("Warning: Use instance GUID (NOT product GUID) to refer to a device.");
                goto done;
            }
        }

        #ifdef WINNT
        /*
         *  NT Bug#351951.
         *  If they are directly asking for one of the predefined joystick 
         *  IDs then see if we have a device mapped to that ID.  If so,
         *  pretend they asked for that GUID instead.
         */

        /*
         *  Weakly Assert the range of predefined static joystick instance GUIDs
         */
        AssertF( ( rgGUID_Joystick[0].Data1 & 0x0f ) == 0 );
        AssertF( ( rgGUID_Joystick[0x0f].Data1 & 0x0f ) == 0x0f );

        /*
         *  Check the GUID is the same as the first static one ignoring LS 4 bits
         */
        if( ( (pguid->Data1 & 0xf0) == (rgGUID_Joystick[0].Data1 & 0xf0) )
          && !memcmp( ((PBYTE)&rgGUID_Joystick)+1, ((PBYTE)pguid)+1, sizeof(*pguid) - 1 ) )
        {
            RPF("Using predefined instance GUIDs is bad and should not work!");
            phdi = phdiFindJoyId( pguid->Data1 & 0x0f );
            goto done;
        }
        #endif
    }
    phdi = 0;

    done:;

    return phdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFindHIDInstanceGUID |
 *
 *          Locates information given an instance GUID for a HID device.
 *
 *          The parameters have already been validated.
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          The instance GUID to be located.
 *
 *  @parm   OUT CREATEDCB * | pcdcb |
 *
 *          Receives pointer to the <f CreateDcb> function for the object.
 *
 *****************************************************************************/

STDMETHODIMP
    hresFindHIDInstanceGUID(PCGUID pguid, CREATEDCB *pcdcb)
{
    HRESULT hres;
    PHIDDEVICEINFO phdi;
    EnterProc(hresFindHIDInstanceGUID, (_ "G", pguid));

    AssertF(SUCCEEDED(hresFullValidGuid(pguid, 0)));

    DllEnterCrit();

    phdi = phdiFindHIDInstanceGUID(pguid);
    if(phdi)
    {
        *pcdcb = CHid_New;
        hres = S_OK;
    } else
    {
        hres = DIERR_DEVICENOTREG;
    }

    DllLeaveCrit();

    /*
     *  Don't use ExitOleProcPpv because that will validate that
     *  *pcdcb == 0 if FAILED(hres), but that's not our job.
     */
    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFindHIDDeviceId |
 *
 *          Locates information given a deviceID
 *          (in other words, <enumerator>\<enumerator-specific-device-ID>) for a HID device.
 *
 *          The parameters have already been validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN LPCTSTR | ptszId |
 *
 *          The interface device to be located.
 *
 *  @returns
 *
 *          Pointer to the <t HIDDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PHIDDEVICEINFO EXTERNAL
    phdiFindHIDDeviceId(LPCTSTR ptszId)
{
    PHIDDEVICEINFO phdi;

    AssertF(InCrit());

    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0, phdi = g_phdl->rghdi; ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            if(phdi->pdidd &&
               lstrcmpi(phdi->ptszId, ptszId) == 0)
            {
                goto done;
            }
        }
    }
    phdi = 0;

    done:;

    return phdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFindHIDDeviceInterface |
 *
 *          Locates information given a device interface
 *          (in other words, a \\.\... thing) for a HID device.
 *
 *          The parameters have already been validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN LPCTSTR | ptszPath |
 *
 *          The interface device to be located.
 *
 *  @returns
 *
 *          Pointer to the <t HIDDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PHIDDEVICEINFO EXTERNAL
    phdiFindHIDDeviceInterface(LPCTSTR ptszPath)
{
    PHIDDEVICEINFO phdi;

    AssertF(InCrit());

    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0, phdi = g_phdl->rghdi; ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            if(phdi->pdidd &&
               lstrcmpi(phdi->pdidd->DevicePath, ptszPath) == 0)
            {
                goto done;
            }
        }
    }
    phdi = 0;

    done:;

    return phdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFindHIDDeviceInterface |
 *
 *          Locates information given a device interface
 *          (in other words, a \\.\... thing) for a HID device.
 *
 *          The parameters have already been validated.
 *
 *  @parm   IN LPCTSTR | ptszPath |
 *
 *          The interface device to be located.
 *
 *  @parm   OUT LPGUID | pguidOut |
 *
 *          Receives the instance GUID of the device found.
 *
 *****************************************************************************/

STDMETHODIMP
    hresFindHIDDeviceInterface(LPCTSTR ptszPath, LPGUID pguidOut)
{
    HRESULT hres;
    PHIDDEVICEINFO phdi;
    EnterProc(hresFindHIDDeviceInterface, (_ "s", ptszPath));

    DllEnterCrit();

    phdi = phdiFindHIDDeviceInterface(ptszPath);

    if(phdi)
    {
        *pguidOut = phdi->guid;
        hres = S_OK;
    } else
    {
        hres = DIERR_DEVICENOTREG;
    }

    DllLeaveCrit();

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_ProbeMouse |
 *
 *          That this function exists at all is a total hack to work
 *          around bugs in Memphis and NT5.
 *
 *          If you call GetSystemMetrics(SM_WHEELPRESENT) or
 *          GetSystemMetrics(SM_MOUSEBUTTONS), USER32 does not
 *          return the correct values if your HID mouse is
 *          not the same as your PS/2 mouse (if any).
 *
 *          For example, if your PS/2 mouse is a regular two-button
 *          mouse but your HID mouse is a wheel mouse, GetSystemMetrics
 *          will still say "No wheel, 2 buttons" even though it's wrong.
 *
 *          So what we have to do is wander through all the HID mice in
 *          the system and record the number of buttons they have,
 *          and whether they have a wheel.
 *
 *          That way, when we create a system mouse, we can take the
 *          maximum of every supported device.
 *
 *****************************************************************************/

void INTERNAL
    DIHid_ProbeMouse(PHIDDEVICEINFO phdi, PHIDP_CAPS pcaps,
                     PHIDP_PREPARSED_DATA ppd)
{
    LPVOID pvReport;
    HRESULT hres;

    /*
     *  Get the number of buttons in the generic button page.
     *  This is the only page the MOUHID uses.
     */
    phdi->osd.uiButtons =
        HidP_MaxUsageListLength(HidP_Input, HID_USAGE_PAGE_BUTTON, ppd);

    /*
     *  See if there is a HID_USAGE_GENERIC_WHEEL.
     *  This is the way that MOUHID detects a wheel.
     */
    hres = AllocCbPpv(pcaps->InputReportByteLength, &pvReport);
    if(SUCCEEDED(hres))
    {
        ULONG ul;
        NTSTATUS stat;

        stat = HidP_GetUsageValue(HidP_Input, HID_USAGE_PAGE_GENERIC, 0,
                                  HID_USAGE_GENERIC_WHEEL, &ul, ppd,
                                  pvReport,
                                  pcaps->InputReportByteLength);
        if(SUCCEEDED(stat))
        {
            phdi->osd.uiAxes = 3;
        }

        FreePv(pvReport);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_ParseUsagePage |
 *
 *  ISSUE-2001/02/06-TimGill  Enumeration needs to know device type
 *          Parse the usage page information and create a first pass at DI 
 *          style type information.
 *          This really is not enough information to be useful as 
 *          enumeration needs to know the final device type.
 *
 *****************************************************************************/

void INTERNAL
    DIHid_ParseUsagePage(PHIDDEVICEINFO phdi, PHIDP_CAPS pcaps,
                         PHIDP_PREPARSED_DATA ppd)

{
    switch(pcaps->UsagePage)
    {
    case HID_USAGE_PAGE_GENERIC:
        switch(pcaps->Usage)
        {

        /*
         *  MouHID accepts either HID_USAGE_GENERIC_MOUSE or
         *  HID_USAGE_GENERIC_POINTER, so we will do the same.
         */
        case HID_USAGE_GENERIC_MOUSE:
        case HID_USAGE_GENERIC_POINTER:
            DIHid_ProbeMouse(phdi, pcaps, ppd);
            phdi->osd.dwDevType =
                MAKE_DIDEVICE_TYPE(DI8DEVTYPE_MOUSE,
                                   DI8DEVTYPEMOUSE_UNKNOWN) |
                DIDEVTYPE_HID;
            break;

        case HID_USAGE_GENERIC_JOYSTICK:
            phdi->osd.dwDevType =
                MAKE_DIDEVICE_TYPE(DI8DEVTYPE_JOYSTICK,
                                   DI8DEVTYPEJOYSTICK_STANDARD) |
                DIDEVTYPE_HID;
            break;

        case HID_USAGE_GENERIC_GAMEPAD:
            phdi->osd.dwDevType =
                MAKE_DIDEVICE_TYPE(DI8DEVTYPE_GAMEPAD,
                                   DI8DEVTYPEGAMEPAD_STANDARD) |
                DIDEVTYPE_HID;
            break;

        case HID_USAGE_GENERIC_KEYBOARD:
            phdi->osd.dwDevType =
                MAKE_DIDEVICE_TYPE(DI8DEVTYPE_KEYBOARD,
                                   DI8DEVTYPEKEYBOARD_UNKNOWN) |
                DIDEVTYPE_HID;
            break;

        default:
            phdi->osd.dwDevType = DI8DEVTYPE_DEVICE | DIDEVTYPE_HID;
            break;
        }
        break;

    default:
        phdi->osd.dwDevType = DI8DEVTYPE_DEVICE | DIDEVTYPE_HID;
        break;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIHid_GetDevicePath |
 *
 *          Obtain the path for the device.  This is a simple wrapper
 *          function to keep DIHid_BuildHidListEntry from getting too
 *          annoying.
 *
 *          This also gets the devinfo so we can get the
 *          instance ID string for subsequent use to get the
 *          friendly name, etc.
 *
 *****************************************************************************/

BOOL EXTERNAL
    DIHid_GetDevicePath(HDEVINFO hdev,
                        PSP_DEVICE_INTERFACE_DATA pdid,
                        PSP_DEVICE_INTERFACE_DETAIL_DATA *ppdidd,
                        OPTIONAL PSP_DEVINFO_DATA pdinf)
{
    HRESULT hres;
    BOOL fRc;
    DWORD cbRequired;
    EnterProcI(DIHid_GetDevicePath, (_ "xp", hdev, pdid));

    AssertF(*ppdidd == 0);

    /*
     *  Ask for the required size then allocate it then fill it.
     *
     *  Note that we don't need to free the memory on the failure
     *  path; our caller will do the necessary memory freeing.
     *
     *  Sigh.  Windows NT and Windows 98 implement
     *  SetupDiGetDeviceInterfaceDetail differently if you are
     *  querying for the buffer size.
     *
     *  Windows 98 returns FALSE, and GetLastError() returns
     *  ERROR_INSUFFICIENT_BUFFER.
     *
     *  Windows NT returns TRUE.
     *
     *  So we allow the cases either where the call succeeds or
     *  the call fails with ERROR_INSUFFICIENT_BUFFER.
     */
    if(SetupDiGetDeviceInterfaceDetail(hdev, pdid, 0, 0,
                                       &cbRequired, 0) ||
       GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {

        hres = AllocCbPpv(cbRequired, ppdidd);


        // Keep prefix happy, manbug 29341
        if(SUCCEEDED(hres) && ( *ppdidd != NULL) )
        {
            PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd = *ppdidd;

            /* 
             *  Note, The cbSize field always contains the size of the fixed 
             *  part of the data structure, not a size reflecting the 
             *  variable-length string at the end. 
             */

            pdidd->cbSize = cbX(SP_DEVICE_INTERFACE_DETAIL_DATA);

            fRc = SetupDiGetDeviceInterfaceDetail(hdev, pdid, pdidd,
                                                  cbRequired, &cbRequired, pdinf);

            if(!fRc)
            {
                FreePpv(ppdidd);

                /*
                 * Set fRc = FALSE again, so the compiler doesn't need
                 * to blow a register to cache the value zero.
                 */
                fRc = FALSE;
            }
        } else
        {
            fRc = FALSE;
        }
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%hs: SetupDiGetDeviceInterfaceDetail failed 1, ")
                        TEXT("Error = %d"),
                        s_szProc, GetLastError());
        fRc = FALSE;
    }

    ExitProcF(fRc);
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIHid_GetDeviceInstanceId |
 *
 *          Obtain the instance ID for the device.
 *
 *          The instance ID allows us to get access to device
 *          properties later.
 *
 *****************************************************************************/

BOOL EXTERNAL
    DIHid_GetDeviceInstanceId(HDEVINFO hdev,
                              PSP_DEVINFO_DATA pdinf, LPTSTR *pptszId)
{
    BOOL fRc;
    DWORD ctchRequired;

    AssertF(*pptszId == 0);

    /*
     *  Ask for the required size then allocate it then fill it.
     *
     *  Note that we don't need to free the memory on the failure
     *  path; our caller will do the necessary memory freeing.
     */
    if(SetupDiGetDeviceInstanceId(hdev, pdinf, NULL, 0,
                                  &ctchRequired) == 0 &&
       GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        HRESULT hres;

        hres = AllocCbPpv(cbCtch(ctchRequired), pptszId);

        if(SUCCEEDED(hres))
        {
            fRc = SetupDiGetDeviceInstanceId(hdev, pdinf, *pptszId,
                                             ctchRequired, NULL);
        } else
        {
            fRc = FALSE;
        }
    } else
    {
        fRc = FALSE;
    }
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIHid_GetInstanceGUID |
 *
 *          Read the instance GUID from the registry, or create one if
 *          necessary.
 *
 *****************************************************************************/

BOOL INTERNAL
    DIHid_GetInstanceGUID(HKEY hk, LPGUID pguid)
{
    LONG lRc;
    DWORD cb;

    cb = cbX(GUID);
    lRc = RegQueryValueEx(hk, TEXT("GUID"), 0, 0, (PV)pguid, &cb);

    if(lRc != ERROR_SUCCESS)
    {
        DICreateGuid(pguid);
        lRc = RegSetValueEx(hk, TEXT("GUID"), 0, REG_BINARY,
                            (PV)pguid, cbX(GUID));
    }

    return lRc == ERROR_SUCCESS;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_EmptyHidList |
 *
 *          Empty the list of HID devices.
 *
 *          This function must be called under the DLL critical section.
 *
 *****************************************************************************/

void EXTERNAL
    DIHid_EmptyHidList(void)
{
    AssertF(InCrit());

    /*
     *  Free all the old strings and things in the HIDDEVICEINFO's.
     */
    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0; ihdi < g_phdl->chdi; ihdi++)
        {
            FreePpv(&g_phdl->rghdi[ihdi].pdidd);
            FreePpv(&g_phdl->rghdi[ihdi].ptszId);
            if(g_phdl->rghdi[ihdi].hk)
            {
                RegCloseKey(g_phdl->rghdi[ihdi].hk);
            }
        }

        /*
         *  We invalidated all the pointers, so make sure
         *  nobody looks at them.
         */
        g_phdl->chdi = 0;
    }

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_CheckHidList |
 *
 *          Check the list of HID devices, and free whose what can not be opened
 *
 *          This function must be called under the DLL critical section.
 *
 *****************************************************************************/

void INTERNAL
    DIHid_CheckHidList(void)
{
    HANDLE hf;

    EnterProcI(DIHid_CheckList, (_ "x", 0x0) );

    AssertF(InCrit());

    /*
     *  Free all the information of the device cannot be opened
     */
    if(g_phdl)
    {
        int ihdi;

        for(ihdi = 0, g_phdl->chdi = 0; ihdi < g_phdl->chdiAlloc; ihdi++)
        {

            if( g_phdl->rghdi[ihdi].pdidd )
            {

                /*
                 *  Open the device
                 */
                hf = CreateFile(g_phdl->rghdi[ihdi].pdidd->DevicePath,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                0,                /* no SECURITY_ATTRIBUTES */
                                OPEN_EXISTING,
                                0,                /* attributes */
                                0);               /* template */

                if(hf == INVALID_HANDLE_VALUE)
                {                                        
#if 0
                    PHIDDEVICEINFO phdi;
                    PBUSDEVICEINFO pbdi;

                    CloseHandle(hf);
                    
                    phdi = &g_phdl->rghdi[ihdi];
                    
                    DllEnterCrit();

                    phdi = phdiFindHIDDeviceInterface(g_phdl->rghdi[ihdi].pdidd->DevicePath);
                    AssertF(phdi != NULL);
                    pbdi = pbdiFromphdi(phdi);

                    DllLeaveCrit();

                    if( pbdi != NULL )
                    {
                        if( pbdi->fDeleteIfNotConnected == TRUE )
                        {
                            lstrcpy( g_tszIdLastRemoved, pbdi->ptszId );
                            g_tmLastRemoved = GetTickCount();

                            DIBusDevice_Remove(pbdi);
                            
                            pbdi->fDeleteIfNotConnected = FALSE;
                        }
                    }
#endif                    

                    FreePpv(&g_phdl->rghdi[ihdi].pdidd);
                    FreePpv(&g_phdl->rghdi[ihdi].ptszId);

                    if(g_phdl->rghdi[ihdi].hk)
                    {
                        RegCloseKey(g_phdl->rghdi[ihdi].hk);
                    }
                    
                    ZeroX( g_phdl->rghdi[ihdi] );

                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: CreateFile(%s) failed? le=%d"),
                                    s_szProc, g_phdl->rghdi[ihdi].pdidd->DevicePath, GetLastError());
                    
                    /* Skip erroneous items */

                } else
                {
                    CloseHandle(hf);
                    g_phdl->chdi++;
                }
            }
        }

        //re-order the existing devices, put them at the front of the hid list.
        for(ihdi = 0; ihdi < g_phdl->chdi; ihdi++)
        {
            if( !g_phdl->rghdi[ihdi].pdidd )
            {
                int ihdi2;

                //find the existing device from the biggest index in the hid list.
                for( ihdi2 = g_phdl->chdiAlloc; ihdi2 >= ihdi+1; ihdi2-- )
                {
                    if( g_phdl->rghdi[ihdi2].pdidd )
                    {
                        memcpy( &g_phdl->rghdi[ihdi], &g_phdl->rghdi[ihdi2], sizeof(HIDDEVICEINFO) );
                        ZeroX( g_phdl->rghdi[ihdi2] );
                    }
                }
            }
        }

    }

    ExitProc();
    return;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIHid_CreateDeviceInstanceKeys |
 *
 *          Create the keys associaciated with a particular device.
 *
 *  @parm   IN OUT PHIDDEVICEINFO | phdi |
 *
 *          HIDDEVICEINFO we to use/update.
 *
 *  @returns
 *
 *          S_OK for a success
 *          A COM error for a failure
 *
 *****************************************************************************/

#define DIHES_UNDEFINED 0
#define DIHES_UNKNOWN   1
#define DIHES_KNOWN     2


HRESULT INTERNAL
    DIHid_CreateDeviceInstanceKeys( PHIDDEVICEINFO phdi, PBYTE pState )
{
    HRESULT hres;
    HKEY hkDin;

    USHORT uVid, uPid;

    TCHAR tszName[MAX_PATH];
    PTCHAR ptszInstance = NULL;

    EnterProcI(DIHid_CreateDeviceInstanceKeys, (_ "p", phdi));

    /*
     *  Unfortunately, we need to open our registry keys before we can open 
     *  the device so rather than ask the device for its VID and PID, we 
     *  parse it from the 
     */

    /*
     *  ISSUE-2001/01/27-MarcAnd Should avoid parsing device ID ourselves
     *  Need to find some documented way to parse out the three parts of the 
     *  device ID: class, device and instance in case the form changes.
     */

    /*
     *  The format of the device ID is a set of strings in the form 
     *  "<class>\<device>\<instance>" with variable case.
     *  For HID devices, the class should be "hid" and the instance is a set 
     *  of hex values separated by ampersands.  The device string should be 
     *  of the form vid_9999&pid_9999 but devices exposed via a gameport can 
     *  use any string that PnP accepts.
     */

    AssertF( ( phdi->ptszId[0]  == TEXT('H') ) || ( phdi->ptszId[0] == TEXT('h') ) );
    AssertF( ( phdi->ptszId[1]  == TEXT('I') ) || ( phdi->ptszId[1] == TEXT('i') ) );
    AssertF( ( phdi->ptszId[2]  == TEXT('D') ) || ( phdi->ptszId[2] == TEXT('d') ) );


    /*
     *  Assert that a defined state and a valid VID/PID on entry must both be 
     *  true or both false (so we can use the state after getting VID/PID).
     */        
    if( ( phdi->ProductID != 0 ) && ( phdi->VendorID !=0 ) )
    {
        AssertF( *pState != DIHES_UNDEFINED );
    }
    else
    {
        AssertF( *pState == DIHES_UNDEFINED );
    }

    if( phdi->ptszId[3] == TEXT('\\') )
    {
        PTCHAR ptcSrc;
        PTCHAR ptDevId;

        ptcSrc = ptDevId = &phdi->ptszId[4];

        if( ( phdi->ProductID != 0 ) && ( phdi->VendorID !=0 ) )
        {
            int iLen;
            /*
             *  Create the key name from VID / PID (because it may be 
             *  different from the value derived from the device ID).
             */
            iLen = wsprintf(tszName, VID_PID_TEMPLATE, phdi->VendorID, phdi->ProductID);

            while( *ptcSrc != TEXT('\\') )
            {
                if( *ptcSrc == TEXT('\0') )
                {
                    break;
                }
                ptcSrc++;
            }

            if( ( *ptcSrc != TEXT('\0') )
             && ( ptcSrc != ptDevId ) )
            {
                ptszInstance = &tszName[iLen+2];
                lstrcpy( ptszInstance, ptcSrc+1 );
            }
        }
        else 
        {
            PTCHAR ptcDest;
            BOOL   fFirstAmpersand = FALSE;

            /*
             *  Copy the device ID (minus "HID\") so we can corrupt the copy.
             *  Convert to upper case and find the other slash on the way.
             *  Terminate the string at either the separator slash or a second 
             *  ampersand if one is found (VID_1234&PID_1234&COL_12 or REV_12).
             *  These are device IDs so we're only really interested in keeping 
             *  real VID\PID style IDs in upper case so we don't care if this 
             *  is imperfect for other cases as long as it is reproducable.
             */

            for( ptcDest = tszName; *ptcSrc != TEXT('\0'); ptcSrc++, ptcDest++ )
            {
                if( ( *ptcSrc >= TEXT('a') ) && ( *ptcSrc <= TEXT('z') ) )
                {
                    *ptcDest = *ptcSrc - ( TEXT('a') - TEXT('A') );
                }
                else if( *ptcSrc == TEXT('&') )
                {
                    if( ( ptszInstance != NULL )
                     || !fFirstAmpersand )
                    {
                        fFirstAmpersand = TRUE;
                        *ptcDest = TEXT('&');
                    }
                    else
                    {
                        *ptcDest = TEXT('\0');
                    }
                }
                else if( *ptcSrc != TEXT('\\') )
                {
                    *ptcDest = *ptcSrc;
                }
                else
                {
                    /*
                     *  Only one slash and not the first char
                     */
                    if( ( ptszInstance != NULL ) 
                     || ( ptcDest == tszName ) )
                    {
                        ptszInstance = NULL;
                        break;
                    }

                    /*
                     *  Separate the device ID and the instance
                     */
                    *ptcDest = TEXT('\0');
                    ptszInstance = ptcDest + 1;
                }
            }

            if( ptszInstance != NULL )
            {
#ifndef UNICODE
/*
 *  ISSUE-2001/02/06-MarcAnd  Should have a ParseVIDPIDA
 *  ParseVIDPID is going to convert this string back to ANSI ifndef UNICODE
 */
                WCHAR wszName[cbszVIDPID];
                AToU( wszName, cA(wszName), ptDevId );

                if( ( ptszInstance - tszName == cbszVIDPID )
                 && ( ParseVIDPID( &uVid, &uPid, wszName ) ) )
#else
                if( ( ptszInstance - tszName == cbszVIDPID )
                 && ( ParseVIDPID( &uVid, &uPid, ptDevId ) ) )
#endif
                {
                    phdi->VendorID  = uVid;
                    phdi->ProductID = uPid;
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%hs: ID %s, len %d not VID PID"), 
                                s_szProc, ptDevId, ptszInstance - tszName );
                }

                /*
                 *  Terminate the instance string
                 */
                *ptcDest = TEXT('\0');
            }
        }
    }
            
    if( ptszInstance == NULL )
    {
        hres = E_INVALIDARG;
        RPF( "Ignoring invalid device ID handle \"%s\" enumerated by system" );
    }
    else
    {
        //Open our own reg key under MediaProperties\DirectInput,
        //creating it if necessary.
        hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                               REGSTR_PATH_DITYPEPROP, 
                               DI_KEY_ALL_ACCESS, 
                               REG_OPTION_NON_VOLATILE, 
                               &hkDin);

        if( SUCCEEDED(hres) )
        {
            HKEY hkVidPid;
            hres = hresMumbleKeyEx(hkDin, 
                                   (LPTSTR)tszName, 
                                   DI_KEY_ALL_ACCESS, 
                                   REG_OPTION_NON_VOLATILE, 
                                   &hkVidPid);
        
            if( SUCCEEDED(hres) )
            {
                HKEY hkDevInsts;

                /*
                 *  Need to create user subkeys even if the device ID is not 
                 *  VID/PID as an auto-detect device could use the auto-detect 
                 *  HW ID for whatever device it detects.  
                 */

                //Create the key for Calibration
                HKEY hkCal;

                hres = hresMumbleKeyEx(hkVidPid, 
                                   TEXT("Calibration"), 
                                   DI_KEY_ALL_ACCESS, 
                                   REG_OPTION_NON_VOLATILE, 
                                   &hkCal);

                if (SUCCEEDED(hres))
                {
                    //Create the key for the instance (as the user sees it).
                    //For this, need to find out how many instances of the particular device
                    //we have already enumerated.
                    int ihdi;
                    int iNum = 0;
                    TCHAR tszInst[3];

                    for( ihdi = 0; ihdi < g_phdl->chdi; ihdi++)
                    {
                        if ((g_phdl->rghdi[ihdi].VendorID == phdi->VendorID) && (g_phdl->rghdi[ihdi].ProductID == phdi->ProductID))
                        {
                            iNum++;
                        }
                    }

                    wsprintf(tszInst, TEXT("%u"), iNum);

                    hres = hresMumbleKeyEx(hkCal, 
                                       tszInst, 
                                       DI_KEY_ALL_ACCESS, 
                                       REG_OPTION_NON_VOLATILE, 
                                       &phdi->hk);
                    if (SUCCEEDED(hres))
                    {
                        DIHid_GetInstanceGUID(phdi->hk, &phdi->guid);
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: RegCreateKeyEx failed on Instance reg key"),
                                    s_szProc);
                    }

                    RegCloseKey(hkCal);
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%hs: RegCreateKeyEx failed on Calibration reg key"),
                                s_szProc);
                }

                /*
                 *  Try to open the device (plug) instances to find out or 
                 *  update the staus of processing on this device but don't 
                 *  return any failures.
                 */
                if( SUCCEEDED( hresMumbleKeyEx(hkVidPid, 
                                       TEXT("DeviceInstances"), 
                                       DI_KEY_ALL_ACCESS, 
                                       REG_OPTION_NON_VOLATILE, 
                                       &hkDevInsts) ) )
                {
                    LONG lRc;

                    if( *pState == DIHES_UNDEFINED )
                    {
                        DWORD cb = cbX( *pState );

                        lRc = RegQueryValueEx( hkDevInsts,
                                    ptszInstance, 0, 0, pState, &cb );

                        if( lRc != ERROR_SUCCESS )
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: RegQueryValueEx failed (%d) to get state for instance %s"),
                                        s_szProc, lRc, ptszInstance );
                            /*
                             *  Make sure it was not trashed in the failure
                             */
                            *pState = DIHES_UNDEFINED;
                        }
                    }
                    else
                    {
                        lRc = RegSetValueEx( hkDevInsts,
                                    ptszInstance, 0, REG_BINARY, pState, cbX( *pState ) );

                        if( lRc != ERROR_SUCCESS)
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: RegSetValueEx failed (%d) to update state for instance %S"),
                                        s_szProc, lRc, ptszInstance );
                        }
                    }

                    RegCloseKey(hkDevInsts);
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("%hs: Failed to open DeviceInstances key"),
                                s_szProc );
                }

                RegCloseKey(hkVidPid);
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%hs: RegCreateKeyEx failed on Device reg key"),
                                s_szProc);
            }

            RegCloseKey(hkDin);
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%hs: RegOpenKeyEx failed on DirectInput reg key"),
                                s_szProc);
        }
    }

    ExitOleProc();

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_GetDevInfo |
 *
 *          Get the HIDDEVICEINFO info from the device
 *
 *  @parm   HDEVINFO | hdev |
 *
 *          Device to get information
 *
 *  @parm   PSP_DEVICE_INTERFACE_DATA | pdid |
 *
 *          Describes the device
 *
 *  @parm   OUT PHIDDEVICEINFO | phdi |
 *
 *          HIDDEVICEINFO we need to collect
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

BOOL INTERNAL
    DIHid_GetDevInfo( HDEVINFO hdev, PSP_DEVICE_INTERFACE_DATA pdid, PHIDDEVICEINFO phdi )
{
    BOOL fRc = FALSE;
    SP_DEVINFO_DATA dinf;

    EnterProcI(DIHid_GetDevInfo, (_ "xpp", hdev, pdid, phdi));

    /*
     *  Open the registry key for the device so we can obtain
     *  auxiliary information.
     */

    dinf.cbSize = cbX(SP_DEVINFO_DATA);

    /*
     *  Get the instance GUID and the path to
     *  the HID device so we can talk to it.
     */
    if (DIHid_GetDevicePath(hdev, pdid, &phdi->pdidd, &dinf) &&
        DIHid_GetDeviceInstanceId(hdev, &dinf, &phdi->ptszId))
    {
        HANDLE  hf;
        TCHAR   tszName[MAX_PATH];
        ULONG   len = sizeof(tszName);
        BOOL    fCreateOK = FALSE;
        BYTE    bNewState = DIHES_UNDEFINED;
        BYTE    bPreviousState = DIHES_UNDEFINED;


        DIHid_CreateDeviceInstanceKeys( phdi, &bPreviousState );

        //////////////////// BEGIN OF PATCH ////////////////////////
        /*
         * This part is to keep the compatibility with Win2k Gold. 
         * Some driver, like Thrustmaster driver, tries to get Joystick ID
         * from old registry key: 
         *   HKLM\SYSTEM\CurrentControlSet\Control\DeviceClasses\{4d1e55b2-f16f-11cf-88cb-001111000030}\<?????????>\#\Device Parameters\DirectX
         * See Windows bug 395416 for detail.
         */
        {
            HKEY    hkDev;
            HRESULT hres;
    
            /*
             *  Open the registry key for the device so we can obtain
             *  auxiliary information, creating it if necessary.
             */
            hkDev = SetupDiCreateDeviceInterfaceRegKey(hdev, pdid, 0,
                                                   MAXIMUM_ALLOWED, NULL, NULL);
                                                   
            if(hkDev && hkDev != INVALID_HANDLE_VALUE)
            {
                hres = hresMumbleKeyEx(hkDev, 
                                   TEXT("DirectX"), 
                                   KEY_ALL_ACCESS, 
                                   REG_OPTION_NON_VOLATILE, 
                                   &phdi->hkOld);
                if(SUCCEEDED(hres) )
                {
                    LONG lRc;
                    
                    lRc = RegSetValueEx(phdi->hkOld, TEXT("GUID"), 0, REG_BINARY,
                            (PV)&phdi->guid, cbX(GUID));
                }
            }
        }
        /////////////////// END OF PATCH /////////////////////

        /*
         *  Before we CreateFile on the device, we need to make sure the 
         *  device is not in the middle of the setup process. If a device has 
         *  no device description it is probably still being setup (plugged 
         *  in) so delay opening it to avoid having an open handle on a device 
         *  that setup is trying to update.  If that happens, setup will prompt 
         *  the user to reboot to use the device.
         *  Since HIDs are "RAW" devices (don't need drivers) don't ignore 
         *  such a device forever.
         */
        if( CM_Get_DevNode_Registry_Property(dinf.DevInst,
                                             CM_DRP_DEVICEDESC,
                                             NULL,
                                             tszName,
                                             &len,
                                             0) == CR_SUCCESS) 
        {
            /*
             * Known device.
             */
            fCreateOK = TRUE;
            bNewState = DIHES_KNOWN;
        } 
        else 
        {
            /*
             *  Unknown device.  This either means that setup has not yet 
             *  completed processing the HID or that no device description 
             *  was set for the device where it matched.
             *
             *  For now, see if we've seen this device instance before.  
             *  If we have, then if it was previously unknown assume it's 
             *  going to stay that way and start using the device.  If it 
             *  was previously known or we've never seen it before wait for 
             *  a while in case setup is just taking it's time.
             *
             *  If the device was the last one we tried to remove, then it's 
             *  OK to open it while it's still showing up.  
             *  ISSUE-2001/02/06-MarcAnd  Opening removed devices
             *  I assume this is so we get a read failure when it really goes 
             *  away but I don't know how that's better than ignoring it.
             */
            /*
             *  ISSUE-2001/01/27-MarcAnd Should keep real list with status 
             *  We should keep a complete list of all the devices we know 
             *  about with status indicating things like "pending on 
             *  setup since X" or "removed" not these globals.
             */
            if( lstrcmpi(phdi->ptszId, g_tszIdLastRemoved) == 0 ) 
            {
                fCreateOK = TRUE;
                bNewState = bPreviousState;
            } 
            else 
            {
                if( bPreviousState == DIHES_UNKNOWN )
                {
                    /*
                     *  We've seen this device before and it was Unknown so 
                     *  don't expect that to change (as Setup does not retry 
                     *  the ID search through the INFs) so just use it.
                     */
                    fCreateOK = TRUE;
                    bNewState = DIHES_UNKNOWN;
                }
                else
                {
                    if( lstrcmpi(phdi->ptszId, g_tszIdLastUnknown) == 0 ) 
                    {
                        if( GetTickCount() - g_tmLastUnknown < MSREBUILDRATE ) 
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: DIHid_BuildHidListEntry: %s pending on setup."), 
                                        s_szProc, phdi->ptszId );
                            fRc = FALSE;
                        } 
                        else 
                        {
                            /*
                             *  Don't wait any longer but we'll need to update 
                             *  the state to "Unknown".
                             */
                            fCreateOK = TRUE;
                            bNewState = DIHES_UNKNOWN;
                            g_tszIdLastUnknown[0] = TEXT('0');
                          #ifdef XDEBUG
                            if( bPreviousState == DIHES_KNOWN )
                            {
                                SquirtSqflPtszV(sqfl | sqflBenign,
                                    TEXT("%hs: %s was known but is now unknown!"), 
                                    s_szProc, phdi->ptszId );
                            }
                          #endif
                        }
                    } 
                    else 
                    {
                        lstrcpy( g_tszIdLastUnknown, phdi->ptszId );
                        g_tmLastUnknown = GetTickCount();
                        fRc = FALSE;
                    }
                }
            }
        }

        if( fCreateOK ) 
        {
            /*
             *  bNewState should always have been set if OK to create
             */

            AssertF( bNewState != DIHES_UNDEFINED );
            /*
             *  Open the device so we can get its (real) usage page / usage.
             */
            hf = CreateFile(phdi->pdidd->DevicePath,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0,                /* no SECURITY_ATTRIBUTES */
                            OPEN_EXISTING,
                            0,                /* attributes */
                            0);               /* template */

            if(hf != INVALID_HANDLE_VALUE)
            {
                PHIDP_PREPARSED_DATA ppd;
                HIDD_ATTRIBUTES attr;

                if(HidD_GetPreparsedData(hf, &ppd))
                {
                    HIDP_CAPS caps;

                    if( SUCCEEDED(HidP_GetCaps(ppd, &caps)) )
                    {
                        DIHid_ParseUsagePage(phdi, &caps, ppd);
                        SquirtSqflPtszV(sqfl,
                                        TEXT("%hs: Have %s"),
                                        s_szProc, phdi->pdidd->DevicePath);
                        /*
                         *  ISSUE-2001/02/06-MarcAnd  Incorrect return possible
                         *  There's nothing to reset this to false if any of 
                         *  the following code fails.
                         */
                        fRc = TRUE;
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%hs: HidP_GetCaps(%s) failed, le= %d"),
                                        s_szProc, phdi->pdidd->DevicePath, GetLastError());
                    }

                    HidD_FreePreparsedData(ppd);

                } 
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: GetPreparsedData(%s) failed, le= %d"),
                                    s_szProc, phdi->pdidd->DevicePath, GetLastError());
                }

                attr.Size = cbX(attr);
                if( HidD_GetAttributes(hf, &attr) )
                {
                    if( ( phdi->ProductID != attr.ProductID )
                     || ( phdi->VendorID != attr.VendorID ) )
                    {
                        SquirtSqflPtszV(sqfl | sqflBenign,
                            TEXT("%hs: Device changed from VID_%04X&PID_%04X to VID_%04X&PID_%04X"),
                            s_szProc, phdi->VendorID, phdi->ProductID, attr.VendorID, attr.ProductID );

                        phdi->ProductID = attr.ProductID;
                        phdi->VendorID = attr.VendorID;

                        /*
                         *  Make sure we update the registry.
                         */
                        bPreviousState = DIHES_UNDEFINED;
                    }

                    if( bPreviousState != bNewState )
                    {
                        DIHid_CreateDeviceInstanceKeys( phdi, &bNewState );
                    }
                } 
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: HidD_GetAttributes(%s) failed"),
                                    s_szProc, phdi->pdidd->DevicePath);
                }

                DICreateStaticGuid(&phdi->guidProduct, attr.ProductID, attr.VendorID); 

                CloseHandle(hf);

            } 
            else
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%hs: CreateFile(%s) failed? le=%d"),
                                 s_szProc, phdi->pdidd->DevicePath, GetLastError());
            }
        }


#ifndef WINNT
        /*
        * The following part is to resolve the swap id problem in OSR.
        * If a USB joystick is not in the lowest available id, after unplug and replug,
        * VJOYD will assign the same joystick to the lowest available id, but DINPUT still
        * remembers its last id. To resolve this conflict, we need this code.
        */

        {
            VXDINITPARMS vip;
            CHAR sz[MAX_PATH];
            LPSTR pszPath;
            BOOL fFindIt = FALSE;

            for( phdi->idJoy = 0; phdi->idJoy < cJoyMax; phdi->idJoy++ )
            {
                pszPath = JoyReg_JoyIdToDeviceInterface_95(phdi->idJoy, &vip, sz);
                if(pszPath)
                {
                    if( lstrcmpiA(pszPath, (PCHAR)phdi->pdidd->DevicePath) == 0x0 ) {
                        fFindIt = TRUE;
                        break;
                    }
                }
            }

            if( fFindIt ) 
            {
                if( phdi->hk != 0x0 )
                {
                    /*
                     *  Don't worry if the registry write fails
                     */
                    RegSetValueEx(phdi->hk, TEXT("Joystick Id"), 0, 0, (PV)&phdi->idJoy, cbX(phdi->idJoy) );
                }
            } 
            else 
            {
                /*
                 *  Post Dx7 Patch. Win9x only
                 *  Some IHVs have created VJoyD mini drivers for their 
                 *  USB game controllers that are used instead of JoyHID.  
                 *  Since the interface to communicate hot-plugging with 
                 *  VJoyD has not been made public, these devices cannot 
                 *  be matched with a HID alias.  To avoid both instances 
                 *  of the same device being enumerated, mark any HID 
                 *  game controller that does not have a VJoyD alias as 
                 *  a (unknown) device type.
                 *
                 *  Post DX7a!  Only do this for game controllers
                 */
                if( GET_DIDEVICE_TYPE( phdi->osd.dwDevType ) >= DI8DEVTYPE_GAMEMIN )
                {
                    /*
                     *  Change type from joystick to device
                     */
                    phdi->osd.dwDevType &= ~(DIDEVTYPE_TYPEMASK | DIDEVTYPE_SUBTYPEMASK);
                    phdi->osd.dwDevType |= DI8DEVTYPE_DEVICE;
                }
                /*
                 *  Set to the invalid id anyway
                 */
                phdi->idJoy = -1;
            }
        }
#else
        // Executed only on WINNT
        if( phdi->hk != 0x0 )
        {
            DWORD cb;

            cb =  cbX(phdi->idJoy);

            if( RegQueryValueEx(phdi->hk, TEXT("Joystick Id"),
                   0, 0, (PV)&phdi->idJoy, &cb ) != ERROR_SUCCESS )
            {
                phdi->idJoy = JOY_BOGUSID;
            }
        }
#endif // WINNT
    } 
    else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%hs: Unable to get GUID or device path"),
                        s_szProc);
    }


    /*
     *  If we failed, then free the goo we already got.
     */
    if(!fRc)
    {
        if( phdi->hk ) 
        {
            RegCloseKey(phdi->hk);
        }
        phdi->hk = 0;
        FreePpv(&phdi->pdidd);
        FreePpv(&phdi->ptszId);
    }

    ExitProcF(fRc);

    return fRc;
}

#undef DIHES_UNDEFINED
#undef DIHES_UNKNOWN
#undef DIHES_KNOWN


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_BuildHidListEntry |
 *
 *          Builds a single entry in the list of HID devices.
 *
 *  @parm   HDEVINFO | hdev |
 *
 *          Device list being enumerated.
 *
 *  @parm   PSP_DEVICE_INTERFACE_DATA | pdid |
 *
 *          Describes the device that was enumerated.
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

BOOL INTERNAL
    DIHid_BuildHidListEntry(HDEVINFO hdev, PSP_DEVICE_INTERFACE_DATA pdid)
{
    BOOL            fRc = TRUE;
    BOOL            fAlreadyExist = FALSE;
    PHIDDEVICEINFO  phdi;
    HIDDEVICEINFO   hdi;

    EnterProcI(DIHid_BuildHidListEntry, (_ "xp", hdev, pdid));


    if(g_phdl)
    {
        PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;

        /* GetDevicePath is expecting a NULL */
        pdidd = NULL;
        if( DIHid_GetDevicePath(hdev, pdid, &pdidd, NULL) )
        {
            PHIDDEVICEINFO phdi;
            int ihdi;
            
            //Check whether the device has been in the list
            for(ihdi = 0, phdi = g_phdl->rghdi; 
                ihdi < g_phdl->chdi;
                ihdi++, phdi++)
            {
                if( phdi->pdidd )
                {
                    if( lstrcmp( pdidd->DevicePath, phdi->pdidd->DevicePath ) == 0 )
                    {
                        //already in the list
                        fAlreadyExist = TRUE;

                      #ifdef WINNT
                        // Id may be changed, so refresh here. 
                        // See Windows bug 321711. -qzheng
                        if( phdi->hk != 0x0 )
                        {
                            DWORD cb;
                            cb =  cbX(phdi->idJoy);

                            if( RegQueryValueEx(phdi->hk, TEXT("Joystick Id"),
                                                0, 0, (PV)&phdi->idJoy, &cb ) != ERROR_SUCCESS )
                            {
                                phdi->idJoy = JOY_BOGUSID;
                            }
                        }
                      #endif

                        SquirtSqflPtszV(sqfl | sqflTrace,
                                        TEXT("%hs: Device %s Already Exists in HID List "), s_szProc, pdidd->DevicePath);
                        break;      
                    }
                }
            }
            FreePpv(&pdidd);
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%hs: DIHid_GetDevicePath failed"), s_szProc, pdidd->DevicePath);
        }

        if( fAlreadyExist )
        {
            //device is already there, needn't do anything, just leave
        } else 
        {
            PBUSDEVICEINFO pbdi;

            if( g_phdl->chdi >= g_phdl->chdiAlloc )
            {
                /*
                 *  Make sure there is room for this device in the list.
                 *  Grow by doubling. 
                 */

                HRESULT hres;

                /*
                 *  Prefix warns that g_phdl would be NULL if the requested 
                 *  size is zero (mb:35353).  Assert that it is never zero.
                 */
                AssertF( cbHdlChdi(g_phdl->chdiAlloc * 2) );
                hres = ReallocCbPpv(cbHdlChdi(g_phdl->chdiAlloc * 2), &g_phdl);

                if(FAILED(hres))
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: Realloc failed"), s_szProc);

                    fRc = FALSE;
                    goto done;
                }

                g_phdl->chdiAlloc *= 2;
            }

            phdi = &g_phdl->rghdi[g_phdl->chdi];

            memset( &hdi, 0, sizeof(hdi) );

            if( DIHid_GetDevInfo(hdev, pdid, &hdi) )
            {
                hdi.fAttached = TRUE;
            
                pbdi = pbdiFromphdi(&hdi);
                if( pbdi != NULL )
                {

                    /*
                     * If the devices is just being removed, and PnP is working on the
                     * removing, then we won't include it in our list.
                     */
                    if( lstrcmpi(pbdi->ptszId, g_tszIdLastRemoved) == 0 &&
                        GetTickCount() - g_tmLastRemoved < MSREBUILDRATE_FIFTH ) 
                    {
                        SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: DIHid_BuildHidListEntry: %s pending on removal."), 
                                        s_szProc, pbdi->ptszId );
                        
                        fRc = FALSE;
                    } else {
                        BUS_REGDATA RegData;

                        memcpy( phdi, &hdi, sizeof(hdi) );
                        g_phdl->chdi++;

                        if( SUCCEEDED(DIBusDevice_GetRegData(pbdi->hk, &RegData)) )
                        {
                            RegData.fAttachOnReboot = TRUE;
                            DIBusDevice_SetRegData(pbdi->hk, &RegData);
                        }
                    }
                } else {
                    memcpy( phdi, &hdi, sizeof(hdi) );
                    g_phdl->chdi++;
                }
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflBenign,
                    TEXT("%hs: DIHid_GetDevInfo failed, ignoring device"), s_szProc );
                fRc = FALSE;
            }
        }
    }    // end of if(g_phdl)

done:

    ExitProcF(fRc);

    return fRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIHid_BuildHidList |
 *
 *          Builds the list of HID devices.
 *
 *  @parm   BOOL | fForce |
 *
 *          If nonzero, we force a rebuild of the HID list.
 *          Otherwise, we rebuild only if the list hasn't
 *          been rebuilt recently.
 *
 *****************************************************************************/

void EXTERNAL
    DIHid_BuildHidList(BOOL fForce)
{
    HRESULT hres;
    DWORD   dwTick;
    
    EnterProcI(DIHid_BuildHidList, (_ "u", fForce));

    DllEnterCrit();


    // Force implies a complete rebuild of the list
    // No hanging onto old entries. 
    if( fForce )
    {
        DIHid_EmptyHidList();
    }
    //ISSUE-2001/03/29-timgill Meltdown code change may be unnecessary

    dwTick = GetTickCount();
    
    if(!(g_flEmulation & 0x80000000) &&        /* Not disabled by emulation */
       HidD_GetHidGuid &&                      /* HID actually exists */
       (fForce ||                              /* Forcing rebuild, or */
        g_tmLastHIDRebuild == 0 ||             /* Never built before, or */
        dwTick - g_tmLastHIDRebuild > MSREBUILDRATE /* Haven't built for a while */
      #ifdef WINNT
        || dwTick - Excl_GetConfigChangedTime() < MSREBUILDRATE  /* joyConfig just Changed */
      #endif
      ))
    {
        GUID guidHid;
        HDEVINFO hdev;

        HidD_GetHidGuid(&guidHid);

        hdev = SetupDiGetClassDevs(&guidHid, 0, 0,
                                   DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
        if(hdev != INVALID_HANDLE_VALUE)
        {
            DIHid_CheckHidList();

            /*
             *  There is no way to query the number of devices.
             *  You just have to keep incrementing until you run out.
             *
             *  If we already have a g_phdl, then re-use it.  Else, create
             *  a new one.  But always realloc up to the minimum starting
             *  point.  (This upward realloc is important in case there
             *  were no HID devices the last time we checked.)
             */

            if( !g_phdl )
            {
                hres = AllocCbPpv(cbHdlChdi(chdiInit), &g_phdl);

                if(SUCCEEDED(hres))
                {
                    g_phdl->chdi = 0;
                    g_phdl->chdiAlloc = chdiInit;
                } else
                {
                    /* Skip erroneous items */
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("DIHid_BuildHidListEntry ")
                                    TEXT("Realloc g_phdl fails."));
                }
            } else
            {
                hres = S_OK;
            }


            if(SUCCEEDED(hres))
            {
                int idev;

                /*
                 *  To avoid infinite looping on
                 *  internal *boo-boo's*, break on any
                 *  error once we have tried more than
                 *  chdiMax devices, since that's the most
                 *  HID will ever give us.
                 */
                for(idev = 0; idev < chdiMax; idev++)
                {
                    SP_DEVICE_INTERFACE_DATA did;

                    AssertF(g_phdl->chdi <= g_phdl->chdiAlloc);

                    /* 
                     *  SetupDI requires that the caller initialize cbSize.
                     */
                    did.cbSize = cbX(did);
                    if(SetupDiEnumDeviceInterfaces(hdev, 0, &guidHid,
                                                   idev, &did))
                    {
                        if(!DIHid_BuildHidListEntry(hdev, &did))
                        {
                            /* Skip erroneous items */
                            SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("DIHid_BuildHidListEntry ")
                                            TEXT("failed?"));
                        }

                    } 
                    else if(GetLastError() == ERROR_NO_MORE_ITEMS)
                    {
                        break;
                    } 
                    else
                    {
                        /* Skip erroneous items */
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("SetupDiEnumDeviceInterface ")
                                        TEXT("failed? le=%d"), GetLastError());
                    }

                }

            }

            SetupDiDestroyDeviceInfoList(hdev);
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                TEXT("SetupDiGetClassDevs failed le=%d"), GetLastError());
        }

      #ifdef WINNT
        if( g_phdl && g_phdl->chdi )
        {
            DIWdm_InitJoyId();
        }
      #endif
      
        g_tmLastHIDRebuild = GetTickCount();
    }

    DllLeaveCrit();

    ExitProc();

}


DWORD DIHid_DetectHideAndRevealFlags( PCHID this )
{
    //  Get hold of the Devices Parent
    //  If the Parent a HID device that we know about ? 
    //      If the parent is a gaming device ( joystick / gamepad, etc )
    //          Mark the device as being "fictional"

    DWORD dwFlags2 = 0x0;
    HDEVINFO hdev;

    
    // We only detect and hide mice and keyboard, 
    // For now, there is no reason to hide other HID devices.
    // Futhermore the scheme to detect which devices to hide is based
    // on MSHs filter driver implementation where they eject PDOs for 
    // "fictional" devices. These fictional devices show up as childern of
    // gaming devices. FredBh (HID/PM) informs us that most multi-function devices he
    // has seen (mice and kbd) have had multiple top level collections. 
    AssertF( ( GET_DIDEVICE_TYPE( this->dwDevType ) == DI8DEVTYPE_MOUSE )
          || ( GET_DIDEVICE_TYPE( this->dwDevType ) == DI8DEVTYPE_KEYBOARD ) );

    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if (hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;
        dinf.cbSize = cbX(SP_DEVINFO_DATA);
        if (SetupDiOpenDeviceInfo(hdev, this->ptszId, NULL, 0, &dinf))
        {
            DEVINST DevInst;
            if ( (CM_Get_Parent(&DevInst, dinf.DevInst, 0x0)) == CR_SUCCESS )
            {
                TCHAR tszId[MAX_PATH];
                if ( CR_SUCCESS == CM_Get_Device_ID(DevInst, tszId, MAX_PATH, 0x0 ))
                {
                    PHIDDEVICEINFO phdi;
                    DllEnterCrit();
                    phdi = phdiFindHIDDeviceId(tszId);

                    if ( phdi )
                    {
                        DWORD dwDevType = phdi->osd.dwDevType;
                        // If the device is a HID gaming device (in the broadest definition)
                        if ( ( GET_DIDEVICE_TYPE(dwDevType) >= DI8DEVTYPE_GAMEMIN ) 
                               && ( dwDevType & DIDEVTYPE_HID ) )
                        {
                            dwFlags2 = JOYTYPE_HIDEACTIVE;
                            
                            switch (GET_DIDEVICE_TYPE( this->dwDevType ))
                            {
                                case DI8DEVTYPE_MOUSE:
                                    dwFlags2 |= JOYTYPE_MOUSEHIDE;
                                    break;
                                case DI8DEVTYPE_KEYBOARD:
                                    dwFlags2 |= JOYTYPE_KEYBHIDE;
                                    break;
                                default:
                                    AssertF(0);
                            }
                        }
                    }

                    DllLeaveCrit();

                }
            }
        }
        SetupDiDestroyDeviceInfoList(hdev);
    }
    return dwFlags2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dihel.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dihel.h
 *  Content:    DirectInput internal include file for the
 *              hardware emulation layer
 *
 ***************************************************************************/

HRESULT EXTERNAL Hel_AcquireInstance(PVXDINSTANCE pvi);
HRESULT EXTERNAL Hel_UnacquireInstance(PVXDINSTANCE pvi);
HRESULT EXTERNAL Hel_SetBufferSize(PVXDDWORDDATA pvdd);
HRESULT EXTERNAL Hel_DestroyInstance(PVXDINSTANCE pvi);

HRESULT EXTERNAL Hel_SetDataFormat(PVXDDATAFORMAT pvdf);
HRESULT EXTERNAL Hel_SetNotifyHandle(PVXDDWORDDATA pvdd);

HRESULT EXTERNAL
Hel_Mouse_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut);

HRESULT EXTERNAL
Hel_Kbd_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut);

HRESULT EXTERNAL Hel_Kbd_InitKeys(PVXDDWORDDATA pvdd);

HRESULT EXTERNAL
Hel_Joy_CreateInstance(PVXDDEVICEFORMAT pdevf, PVXDINSTANCE *ppviOut);

HRESULT EXTERNAL Hel_Joy_Ping(PVXDINSTANCE pvi);

HRESULT EXTERNAL Hel_Joy_ConfigChanged(DWORD dwFlags);

HRESULT EXTERNAL
Hel_Joy_GetInitParms(DWORD dwExternalID, PVXDINITPARMS pvip);

HRESULT EXTERNAL
Hel_Joy_GetAxisCaps(DWORD dwExternalID, PVXDAXISCAPS pvac, LPJOYREGHWCONFIG phwc );

/*
 *  HID always runs via ring 3.
 */
#define Hel_HID_CreateInstance          CEm_HID_CreateInstance

#ifdef WINNT
#define IoctlHw( ioctl, pvIn, cbIn, pvOut, cbOut ) ( (HRESULT)DIERR_BADDRIVERVER )
#else
HRESULT EXTERNAL
IoctlHw(DWORD ioctl, LPVOID pvIn, DWORD cbIn, LPVOID pvOut, DWORD cbOut);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dijoyhid.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dijoyhid.h
 *  Content:    DirectInput internal include file JoyHid mapping
 *
 ***************************************************************************/

#ifndef DIJOYHID_H
#define DIJOYHID_H

#define MIN_PERIOD         10  /* minimum polling period */
#define MAX_PERIOD         1000  /* maximum polling period */

typedef struct tag_USAGES {
	DWORD dwUsage;
    DWORD dwFlags;
    DWORD dwCaps;
    DWORD dwAxisPos;
} USAGES;

#define USAGE_SENTINAL  { 0x0, 0x0, 0x0  }

enum eControls {			// Index list for supported joystick axes
	ecX=0x0, ecY, ecZ, ecRz, ecRy, ecRx, ecEnd
};


#ifndef HID_USAGE_SIMULATION
#define	HID_USAGE_SIMULATION_STEERING       ((USAGE) 0xC8)
#endif

#ifndef HID_USAGE_SIMULATION_ACCELERATOR 
#define	HID_USAGE_SIMULATION_ACCELERATOR    ((USAGE) 0xC4)
#endif

#ifndef HID_USAGE_SIMULATION_BRAKE
#define	HID_USAGE_SIMULATION_BRAKE          ((USAGE) 0xC5)
#endif

/*
 * keep the following dwAxisPos as ascending.
 */
USAGES AxesUsages[] = {
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_X),              0x0,          0x0         , 0 },  // X
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_STEERING),    0x0,          0x0         , 0 },

    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_Y),              0x0,          0x0         , 1 },  // Y
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_ACCELERATOR), 0x0,          0x0         , 1 },

    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_Z),              JOY_HWS_HASZ, JOYCAPS_HASZ, 2 },  // Z
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_SLIDER),         JOY_HWS_HASZ, JOYCAPS_HASZ, 2 },
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_THROTTLE),    JOY_HWS_HASZ, JOYCAPS_HASZ, 2 },
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_GENERIC_DIAL),           JOY_HWS_HASZ, JOYCAPS_HASZ, 2 },
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_WHEEL),          JOY_HWS_HASZ, JOYCAPS_HASZ, 2 },
    
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_RUDDER),      JOY_HWS_HASR, JOYCAPS_HASR, 3 },
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_RZ),             JOY_HWS_HASR, JOYCAPS_HASR, 3 },  // R
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_BRAKE),       JOY_HWS_HASR, JOYCAPS_HASR, 3 },
    
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_RY),             JOY_HWS_HASU, JOYCAPS_HASU, 4 },  // U
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_SIMULATION, HID_USAGE_SIMULATION_THROTTLE),    JOY_HWS_HASU, JOYCAPS_HASU, 4 },
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_SLIDER),         JOY_HWS_HASU, JOYCAPS_HASU, 4 },
    
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_RX),             JOY_HWS_HASV, JOYCAPS_HASV, 5 },  // V
    
    USAGE_SENTINAL
};


USAGES CheckHatswitch[] = {
    { DIMAKEUSAGEDWORD(HID_USAGE_PAGE_GENERIC,    HID_USAGE_GENERIC_HATSWITCH)  , JOY_HWS_HASPOV, JOYCAPS_HASPOV },  // ecHatswitch
    USAGE_SENTINAL
};

#endif // DIJOYHID_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dihid.c ===
/*****************************************************************************
*
*  DIHid.c
*
*  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
*
*  Abstract:
*
*      The HID device callback.
*
*  Contents:
*
*      CHid_New
*
*****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHidDev


/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CHid, IDirectInputDeviceCallback);

Interface_Template_Begin(CHid)
Primary_Interface_Template(CHid, IDirectInputDeviceCallback)
Interface_Template_End(CHid)

/*****************************************************************************
 *
 *      Forward declarations
 *
 *      These are out of laziness, not out of necessity.
 *
 *****************************************************************************/

LRESULT CALLBACK
    CHid_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                      UINT_PTR uid, ULONG_PTR dwRef);
STDMETHODIMP_(DWORD) CHid_GetUsage(PDICB pdcb, int iobj);

/*****************************************************************************
 *
 *      Hid devices are totally arbitrary, so there is nothing static we
 *      can cook up to describe them.  We generate all the information on
 *      the fly.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      Auxiliary helper definitions for CHid.
 *
 *****************************************************************************/

    #define ThisClass CHid
    #define ThisInterface IDirectInputDeviceCallback
    #define riidExpected &IID_IDirectInputDeviceCallback

/*****************************************************************************
 *
 *      CHid::QueryInterface      (from IUnknown)
 *      CHid::AddRef              (from IUnknown)
 *      CHid::Release             (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************/

    #ifdef DEBUG

Default_QueryInterface(CHid)
Default_AddRef(CHid)
Default_Release(CHid)

    #else

        #define CHid_QueryInterface   Common_QueryInterface
        #define CHid_AddRef           Common_AddRef
        #define CHid_Release          Common_Release

    #endif

    #define CHid_QIHelper         Common_QIHelper

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | RemoveSubclass |
 *
 *          Remove our subclass hook on the window.
 *
 *****************************************************************************/

void INTERNAL
    CHid_RemoveSubclass(PCHID this)
{

    /*
     *  !! All the comments in CJoy_RemoveSubclass apply here !!
     */
    if(this->hwnd)
    {
        HWND hwnd = this->hwnd;
        this->hwnd = 0;
        if(!RemoveWindowSubclass(hwnd, CHid_SubclassProc, 0))
        {
            /*
             *  The RemoveWindowSubclass can fail if the window
             *  was destroyed behind our back.
             */
            // AssertF(!IsWindow(hwnd));
        }
        Sleep(0);                   /* Let the worker thread drain */
        Common_Unhold(this);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Unacquire |
 *
 *          Tell the device driver to stop data acquisition.
 *
 *          It is the caller's responsibility to call this only
 *          when the device has been acquired.
 *
 *          Warning!  We require that the device critical section be
 *          held so we don't race against our worker thread.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_Unacquire(PDICB pdcb)
{
    HRESULT hres;
    PCHID this;

    EnterProcI(IDirectInputDeviceCallback::HID::Unacquire,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pvi->pdd);
    AssertF(CDIDev_InCrit(this->pvi->pdd));    

    hres = S_FALSE;     /* Please finish for me */

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CHid_Finalize |
 *
 *          Releases the resources of the device after all references
 *          (both strong and weak) are gone.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
    CHid_Finalize(PV pvObj)
{
    UINT  iType;
    PCHID this = pvObj;

    if(this->hkInstType)
    {
        RegCloseKey(this->hkInstType);
    }

    if(this->hkType)
    {
        RegCloseKey(this->hkType);
    }

    if( this->hkProp)
    {
        RegCloseKey(this->hkProp);
    }

    AssertF(this->hdev == INVALID_HANDLE_VALUE);
    AssertF(this->hdevEm == INVALID_HANDLE_VALUE);

    if(this->ppd)
    {
        HidD_FreePreparsedData(this->ppd);
    }

    /*
     *
     *  Free group 2 memory:
     *
     *      hriIn.pvReport      Input data
     *      hriIn.rgdata
     *
     *      hriOut.pvReport     Output data
     *      hriOut.rgdata
     *
     *      hriFea.pvReport     Feature data (both in and out)
     *      hriFea.rgdata
     *
     *      pvPhys              Used by ED
     *      pvStage
     */

    FreePpv(&this->pvGroup2);

    /*
     *  Freeing df.rgodf also frees rgpvCaps, rgvcaps, rgbcaps, rgcoll.
     */
    FreePpv(&this->df.rgodf);

    FreePpv(&this->rgbaxissemflags);
    FreePpv(&this->rgiobj);
    FreePpv(&this->ptszPath);
    FreePpv(&this->ptszId);
    FreePpv(&this->rgpbButtonMasks);

    for(iType = 0x0; iType < HidP_Max; iType++)
    {
        FreePpv(&this->pEnableReportId[iType]);  
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | AppFinalize |
 *
 *          The client <t VXDINSTANCE> contains a weak pointer back
 *          to us so that that it can party on the data format we
 *          collected.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

void INTERNAL
    CHid_AppFinalize(PV pvObj)
{
    PCHID this = pvObj;

    if(this->pvi)
    {
        HRESULT hres;
        CHid_RemoveSubclass(this);
        /*
         *  Prefix warns that "this" may have been freed (mb:34570) however 
         *  in AppFinalize we should always have our internal reference to 
         *  keep it around.  As long as refcounting is not broken, we are OK 
         *  and any refcount bug has to be fixed so don't hide it here.
         */
        hres = Hel_DestroyInstance(this->pvi);
        AssertF(SUCCEEDED(hres));
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CHid_SubclassProc |
 *
 *          Window subclass procedure which watches for
 *          joystick configuration change notifications.
 *
 *          Even if we are not a joystick, we still listen to
 *          this, in case somebody recalibrated a remote control
 *          or some other wacky thing like that.
 *
 *          However, if our device has no calibratable controls,
 *          then there's no point in watching for recalibration
 *          notifications.
 *
 *  @parm   HWND | hwnd |
 *
 *          The victim window.
 *
 *  @parm   UINT | wm |
 *
 *          Window message.
 *
 *  @parm   WPARAM | wp |
 *
 *          Message-specific data.
 *
 *  @parm   LPARAM | lp |
 *
 *          Message-specific data.
 *
 *  @parm   UINT | uid |
 *
 *          Callback identification number, always zero.
 *
 *  @parm   DWORD | dwRef |
 *
 *          Reference data, a pointer to our joystick device callback.
 *
 *****************************************************************************/

LRESULT CALLBACK
    CHid_SubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                      UINT_PTR uid, ULONG_PTR dwRef)
{
    #ifdef XDEBUG
    static CHAR s_szProc[] = "";
    #endif

    PCHID this = (PCHID)dwRef;
    AssertF(uid == 0);
    /*
     *  Wacky subtlety going on here to avoid race conditions.
     *  See the mondo comment block in CJoy_RemoveSubclass [sic]
     *  for details.
     *
     *  We can get faked out if the memory associated with the
     *  CHid is still physically allocated, the vtbl is magically
     *  still there and the hwnd field somehow matches our hwnd.
     */
    if(SUCCEEDED(hresPv(this)) && this->hwnd == hwnd)
    {
        switch(wm)
        {
        case WM_POWERBROADCAST :
            // 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV( sqfl | sqflError,
                TEXT("WM_POWERBROADCAST(0x%x) for 0x%p"), wp, this);

            if(wp == PBT_APMSUSPEND )
            {
                CEm_ForceDeviceUnacquire(pemFromPvi(this->pvi)->ped, 0x0 );
            }
            else if(wp == PBT_APMRESUMESUSPEND )
            {
                CEm_ForceDeviceUnacquire(pemFromPvi(this->pvi)->ped, 0x0 );
                
                DIBus_BuildList(TRUE);
            }
            break;

        default:
            if( wm == g_wmJoyChanged )
            {
                /*
                 * Once we receive this notification message, we need to rebuild
                 * our list, because sometimes the user has just changed the device's ID.
                 * See manbug: 35445
                 */
                DIHid_BuildHidList(TRUE);

                Common_Hold(this);

                CHid_LoadCalibrations(this);

                Common_Unhold(this);
            }
            // 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV( sqfl | sqflVerbose,
                TEXT("wp(0x%x) wm(0x%x) for 0x%p"), wm, wp, this);
            break;
        }
    }
    return DefSubclassProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | GetPhysicalState |
 *
 *          Read the physical device state into <p pmstOut>.
 *
 *          Note that it doesn't matter if this is not atomic.
 *          If a device report arrives while we are reading it,
 *          we will get a mix of old and new data.  No big deal.
 *
 *  @parm   PCHID | this |
 *
 *          The object in question.
 *
 *  @parm   PV | pvOut |
 *
 *          Where to put the device state.
 *
 *  @returns
 *          None.
 *
 *****************************************************************************/

void INLINE
    CHid_GetPhysicalState(PCHID this, PV pvOut)
{
    AssertF(this->pvPhys);
    AssertF(this->cbPhys);

    CopyMemory(pvOut, this->pvPhys, this->cbPhys);


}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Acquire |
 *
 *          Tell the device driver to begin data acquisition.
 *          We create a handle to the device so we can talk to it again.
 *          We must create each time so we can survive in the
 *          "unplug/replug" case.  When a device is unplugged,
 *          its <t HANDLE> becomes permanently invalid and must be
 *          re-opened for it to work again.
 *
 *          Warning!  We require that the device critical section be
 *          held so we don't race against our worker thread.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The operation was begun and should be completed
 *          by the caller by communicating with the <t VXDINSTANCE>.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_Acquire(PDICB pdcb)
{
    HRESULT hres;
    HANDLE h;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::HID::Acquire,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pvi->pdd);
    AssertF(CDIDev_InCrit(this->pvi->pdd));
    AssertF(this->hdev == INVALID_HANDLE_VALUE);


    /*
     *  We must check connectivity by opening the device, because NT
     *  leaves the device in the info list even though it has
     *  been unplugged.
     */
    h = CHid_OpenDevicePath(this, FILE_FLAG_OVERLAPPED);
    if(h != INVALID_HANDLE_VALUE)
    {
        NTSTATUS stat;
        DWORD dwFlags2 = 0;

        /*
         * Obtain Flags2 to find out if input report is disabled for this device,
         * if we haven't done so.
         */
        if (!this->fFlags2Checked)
        {
            JoyReg_GetValue( this->hkProp, REGSTR_VAL_FLAGS2, REG_BINARY,
                             &dwFlags2, cbX(dwFlags2) );
            this->fFlags2Checked = TRUE;
            this->fEnableInputReport = ( (dwFlags2 & JOYTYPE_ENABLEINPUTREPORT) != 0 );
        }

        if ( this->fEnableInputReport )
        {
            BYTE id;
            for (id = 0; id < this->wMaxReportId[HidP_Input]; ++id)
                if ( this->pEnableReportId[HidP_Input][id] )
                {
                    BOOL bRet;

                    *(BYTE*)this->hriIn.pvReport = id;
                    bRet = HidD_GetInputReport(h, this->hriIn.pvReport, this->hriIn.cbReport);

                    if (bRet)
                    {
                        stat = CHid_ParseData(this, HidP_Input, &this->hriIn);
                        if (SUCCEEDED(stat))
                        {
                            this->pvi->fl |= VIFL_INITIALIZE;  /* Set the flag so the event can be buffered.
                                                                  since VIFL_ACQUIRED isn't set yet. */
                            CEm_AddState(&this->ed, this->pvStage, GetTickCount());
                            this->pvi->fl &= ~VIFL_INITIALIZE;  /* Clear the flag when done. */
                        }
                    } else
                    {
                        DWORD dwError = GetLastError();

                        // ERROR_SEM_TIMEOUT means the device has timed out.
                        if (dwError == ERROR_SEM_TIMEOUT)
                        {
                            /*
                             * Timed out. The device does not support input report. We need to record
                             * the fact in registry so that GetInputReport() does not ever get called
                             * again for this device, since each failed call takes five seconds to
                             * complete.
                             */
                            this->fEnableInputReport = TRUE;
                            dwFlags2 &= ~JOYTYPE_ENABLEINPUTREPORT;
                            hres = JoyReg_SetValue( this->hkProp, REGSTR_VAL_FLAGS2, 
                                                    REG_BINARY, (PV)&dwFlags2, cbX( dwFlags2 ) );
                            break;
                        }

                        RPF("CHid_InitParse: Unable to read HID input report LastError(0x%X)", dwError );
                    }
                }
        }

        CloseHandle(h);
        /* Please finish for me */
        hres = S_FALSE;
    } else
    {
        hres = DIERR_UNPLUGGED;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetInstance |
 *
 *          Obtains the DirectInput instance handle.
 *
 *  @parm   OUT PPV | ppvi |
 *
 *          Receives the instance handle.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetInstance(PDICB pdcb, PPV ppvi)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetInstance, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    *ppvi = (PV)this->pvi;
    hres = S_OK;

    ExitOleProcPpvR(ppvi);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetDataFormat |
 *
 *          Obtains the device's preferred data format.
 *
 *  @parm   OUT LPDIDEVICEFORMAT * | ppdf |
 *
 *          <t LPDIDEVICEFORMAT> to receive pointer to device format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetDataFormat(PDICB pdcb, LPDIDATAFORMAT *ppdf)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetDataFormat,
               (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    *ppdf = &this->df;
    hres = S_OK;

    ExitOleProcPpvR(ppdf);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIHid_GetParentRegistryProperty |
 *
 *  @parm   LPTSTR | ptszId |
 *
 *          Device Instance ID.           
 *
 *  @parm   DWORD | dwProperty |
 *
 *          The property being queried.
 *
 *  @parm   LPDIPROPHEADER | diph |
 *
 *          Property data to be set.
 *
 *  @parm   BOOL | diph |
 *
 *          Get from parent or grand parent.
 *
 *****************************************************************************/

HRESULT INTERNAL
    DIHid_GetParentRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPDIPROPHEADER pdiph, BOOL bGrandParent)
{

    HDEVINFO hdev;
    LPDIPROPSTRING pstr = (PV)pdiph;
    TCHAR   tsz[MAX_PATH];
    HRESULT hres = E_FAIL;

    ZeroX(tsz);
    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;

        /*
         *  For the instance name, use the friendly name if possible.
         *  Else, use the device description.
         */
        dinf.cbSize = cbX(SP_DEVINFO_DATA);
        if(SetupDiOpenDeviceInfo(hdev, ptszId, NULL, 0, &dinf))
        {
            DEVINST DevInst;
            CONFIGRET cr;
            if( (cr = CM_Get_Parent(&DevInst, dinf.DevInst, 0x0)) == CR_SUCCESS )
            {
                ULONG   ulLength;

                CAssertF( SPDRP_DEVICEDESC   +1  == CM_DRP_DEVICEDESC  );
                CAssertF( SPDRP_FRIENDLYNAME +1  ==  CM_DRP_FRIENDLYNAME );

                if(bGrandParent)
                {
                    cr = CM_Get_Parent(&DevInst, DevInst, 0x0);
                    if( cr != CR_SUCCESS )
                    {
                        // No GrandParent ?? 
                    }
                }

                ulLength = MAX_PATH * cbX(TCHAR);

                if( cr == CR_SUCCESS && 
                    ( cr = CM_Get_DevNode_Registry_Property(
                                                           DevInst,
                                                           dwProperty+1,
                                                           NULL,
                                                           tsz,
                                                           &ulLength,
                                                           0x0 ) ) == CR_SUCCESS )
                {
                    // Success
                    hres = S_OK;
    #ifdef UNICODE
                    lstrcpyW(pstr->wsz, tsz);
    #else
                    TToU(pstr->wsz, MAX_PATH, tsz);
    #endif
                } else
                {
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("CM_Get_DevNode_Registry_Property FAILED") );
                }
            } else
            {
                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("CM_Get_Parent FAILED") );
            }
        }

        SetupDiDestroyDeviceInfoList(hdev);
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("SetupDiCreateDeviceInfoList FAILED, le = %d"), GetLastError() );
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIHid_GetRegistryProperty |
 *
 *  @parm   LPTSTR | ptszId |
 *
 *          Device Instance ID.           
 *
 *  @parm   DWORD | dwProperty |
 *
 *          The property being queried.
 *
 *  @parm   LPDIPROPHEADER | diph |
 *
 *          Property data to be set.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    DIHid_GetRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPDIPROPHEADER pdiph)
{

    HDEVINFO hdev;
    LPDIPROPSTRING pstr = (PV)pdiph;
    TCHAR   tsz[MAX_PATH];
    HRESULT hres = E_FAIL;

    ZeroX(tsz);
    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;

        /*
         *  For the instance name, use the friendly name if possible.
         *  Else, use the device description.
         */
        dinf.cbSize = cbX(SP_DEVINFO_DATA);
        if(SetupDiOpenDeviceInfo(hdev, ptszId, NULL, 0, &dinf))
        {
            if(SetupDiGetDeviceRegistryProperty(hdev, &dinf, dwProperty, NULL, 
                                                (LPBYTE)tsz, MAX_PATH, NULL) )
            {
                hres = S_OK;
    #ifdef UNICODE
                lstrcpyW(pstr->wsz, tsz);
    #else
                TToU(pstr->wsz, MAX_PATH, tsz);
    #endif
            } else
            {
                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("SetupDiOpenDeviceInfo FAILED, le = %d"), GetLastError() );
            }
        } else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("SetupDiOpenDeviceInfo FAILED, le = %d"), GetLastError() );
        }

        SetupDiDestroyDeviceInfoList(hdev);
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("SetupDiCreateDeviceInfoList FAILED, le = %d"), GetLastError() );
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetGuidAndPath |
 *
 *          Get a Hid device's class GUID (namely, the HID guid)
 *          and device interface (path).
 *
 *  @parm   PCHID | this |
 *
 *          The Hid object.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CHid_GetGuidAndPath(PCHID this, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    LPDIPROPGUIDANDPATH pgp = (PV)pdiph;

    pgp->guidClass = GUID_HIDClass;
    TToU(pgp->wszPath, cA(pgp->wszPath), this->ptszPath);

    hres = S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method BOOLEAN | CHid | CHidInsertScanCodes |
 *
 *
 *  @parm   
 *
 *   ISSUE-2001/03/29-timgill function needs documenting
 *
 *
 *****************************************************************************/

BOOLEAN CHidInsertScanCodes
(
    IN PVOID Context,      // Some caller supplied context.
    IN PCHAR NewScanCodes, // A list of i8042 scan codes.
    IN ULONG Length        // the length of the scan codes.
)
{
    int Idx;
    /*
     *  This is not inner loop code so don't rush it
     */
    AssertF( Length <= cbX( DWORD ) );
    for( Idx = 0; Idx < cbX( DWORD ); Idx++ )
    {
        if( Length-- )
        {
            *(((PCHAR)Context)++) = *(NewScanCodes++);
        }
        else
        {
            *(((PCHAR)Context)++) = '\0';
        }
    }

    return TRUE;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL |  fHasSpecificHardwareMatch |
 *
 *          Find out from SetupAPI whether the device was matched with a 
 *          specific hardware ID match or generic match.
 *          A specific match should have caused a device description to be 
 *          installed which is likely to be at least as good as what HID could 
 *          get from a product string in firmware.  (a. because it's easier to 
 *          update an INF after release than firmware; b. because HID can only 
 *          get us an English string.)  Generic matches on the other hand are,
 *          by definition, all the same so cannot be used to tell two devices 
 *          apart.
 *
 *  @parm   LPTSTR | ptszId |
 *          
 *          Device Instance ID.
 *  
 *  @returns 
 *          <c TRUE> if the device was installed using a specific match.
 *          <c FALSE> if it was not or if installation info was unobtainable.
 *
 *  @comm
 *          This is used on Win2k for game controllers and Win9x for mice and 
 *          keyboards.  Win2k we can't read HID mice and keyboards and on 
 *          Win9x VJoyD should always create device names before DInput.dll.  
 *          On Win9x this is less of a big deal for game controllers because 
 *          IHVs are accoustomed to adding their display name to 
 *          MediaProperties.
 *
 *****************************************************************************/
BOOL fHasSpecificHardwareMatch( LPTSTR ptszId )
{
    HDEVINFO    hInfo;
    BOOL        fRc = FALSE;

    EnterProcI(fHasSpecificHardwareMatch,(_ "s", ptszId));

    hInfo = SetupDiCreateDeviceInfoList(NULL, NULL);
    if( hInfo != INVALID_HANDLE_VALUE )
    {
        SP_DEVINFO_DATA dinf;

        dinf.cbSize = cbX(SP_DEVINFO_DATA);
        if( SetupDiOpenDeviceInfo(hInfo, ptszId, NULL, 0, &dinf) )
        {
            CONFIGRET   cr;
            DEVINST     DevInst;

            cr = CM_Get_Parent( &DevInst, dinf.DevInst, 0x0 );
            if( cr == CR_SUCCESS )
            {
                TCHAR       tszDevInst[MAX_PATH];
                cr = CM_Get_Device_ID( DevInst, (DEVINSTID)tszDevInst, MAX_PATH, 0 );
                if( cr == CR_SUCCESS )
                {
                    if( SetupDiOpenDeviceInfo(hInfo, tszDevInst, NULL, 0, &dinf) )
                    {
                        HKEY hkDrv;

                        hkDrv = SetupDiOpenDevRegKey( hInfo, &dinf, DICS_FLAG_GLOBAL, 0, 
                            DIREG_DRV, MAXIMUM_ALLOWED );

                        if( hkDrv != INVALID_HANDLE_VALUE )
                        {
                            PTCHAR      tszHardwareID = NULL;
                            PTCHAR      tszMatchingID = NULL;
                            ULONG       ulLength = 0;
                    
                            cr = CM_Get_DevNode_Registry_Property(DevInst,
                                                                  CM_DRP_HARDWAREID,
                                                                  NULL,
                                                                  NULL,
                                                                  &ulLength,
                                                                  0x0 );
                            /*
                             *  Win2k returns CR_BUFFER_SMALL but 
                             *  Win9x returns CR_SUCCESS so allow both.
                             */
                            if( ( ( cr == CR_BUFFER_SMALL ) || ( cr == CR_SUCCESS ) )
                             && ulLength )
                            {
#ifndef WINNT
                                /*
                                 *  Need to allocate extra for terminator on Win9x
                                 */
                                ulLength++;
#endif
                                if( SUCCEEDED( AllocCbPpv( ulLength + ( MAX_PATH * cbX(tszMatchingID[0]) ), &tszMatchingID ) ) )
                                {
                                    cr = CM_Get_DevNode_Registry_Property(DevInst,
                                                                          CM_DRP_HARDWAREID,
                                                                          NULL,
                                                                          (PBYTE)&tszMatchingID[MAX_PATH],
                                                                          &ulLength,
                                                                          0x0 );
                                    if( cr == CR_SUCCESS )
                                    {
                                        tszHardwareID = &tszMatchingID[MAX_PATH];
                                    }
                                    else
                                    {
                                        SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("CR error %d getting HW ID"), cr );
                                    }
                                }
                                else
                                {
                                    SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("No memory requesting %d bytes for HW ID"), ulLength );
                                }
                            }
                            else
                            {
                                SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("Unexpected CR error %d getting HW ID size"), cr );
                            }

                            if( tszHardwareID )
                            {
                                ulLength = MAX_PATH * cbX(tszMatchingID[0]);
                                cr = RegQueryValueEx( hkDrv, REGSTR_VAL_MATCHINGDEVID, 0, 0, (PBYTE)tszMatchingID, &ulLength );
                                if( CR_SUCCESS == cr )
                                {
                                    while( ulLength = lstrlen( tszHardwareID ) )
                                    {
                                        if( !lstrcmpi( tszHardwareID, tszMatchingID ) )
                                        {
                                            fRc = TRUE;
                                            break;
                                        }
                                        tszHardwareID += ulLength + 1;
                                    }
                                }
                                else
                                {
                                    SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("No matching ID!, cr = %d"), cr );
                                }
                            }

                            if( tszMatchingID )
                            {
                                FreePv( tszMatchingID );
                            }

                            RegCloseKey( hkDrv );
                        }
                        else
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("SetupDiOpenDevRegKey failed, le = %d"), GetLastError() );
                        }
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("SetupDiOpenDeviceInfo failed for %S (parent), le = %d"), 
                            tszDevInst, GetLastError() );
                    }
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("CM_Get_Device_ID FAILED %d"), cr );
                }
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("CM_Get_Parent FAILED %d"), cr );
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                TEXT("SetupDiOpenDeviceInfo failed for %S (child), le = %d"), 
                ptszId, GetLastError() );
        }

        SetupDiDestroyDeviceInfoList(hInfo);
    } 
    else
    {
        SquirtSqflPtszV(sqfl | sqflError,
            TEXT("SetupDiCreateDeviceInfoList failed, le = %d"), GetLastError() );
    }

    ExitProc();

    return fRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL |  fGetProductStringFromDevice |
 *
 *          Try getting the product name from HID.
 *          If the device has one of these, this is what is displayed 
 *          when the device is initially recognized.  Unfortunately 
 *          this name does not land up in the friendly name registry 
 *          entry so in case this gets fixed we go directly to HID.
 *
 *  @parm   PCHID | this |
 *
 *          The Hid object.
 *
 *  @parm   PWCHAR | wszBuffer |
 *          
 *          Where to put the product string if found.
 *  
 *  @parm   ULONG | ulBufferLen |
 *          
 *          How big the string buffer is in bytes
 *  
 *  @returns 
 *          <c TRUE> if a string has been placed in the buffer
 *          <c FALSE> if no string was retrieved
 *
 *****************************************************************************/
BOOL fGetProductStringFromDevice
( 
    PCHID   this,
    PWCHAR  wszBuffer,
    ULONG   ulBufferLen
)
{
    BOOL fRc;

    /*
     *  If we already have a handle open (device is acquired), use 
     *  it, otherwise open one just for now.
     */
    if( this->hdev != INVALID_HANDLE_VALUE )
    {
        fRc = HidD_GetProductString( this->hdev, wszBuffer, ulBufferLen );
    }
    else
    {
        HANDLE hdev;

        hdev = CHid_OpenDevicePath(this, FILE_FLAG_OVERLAPPED);
        if(hdev != INVALID_HANDLE_VALUE)
        {
            wszBuffer[0] = 0;
            fRc = HidD_GetProductString( hdev, wszBuffer, ulBufferLen );
            fRc = (fRc)?(wszBuffer[0] != 0):FALSE;
            CloseHandle(hdev);
        } 
        else
        {
            fRc = FALSE;
        }
    }

    return fRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetProperty |
 *
 *          Get a Hid device property.
 *
 *  @parm   PCHID | this |
 *
 *          The Hid object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being retrieved.
 *
 *  @parm   LPDIPROPHEADER | pdiph |
 *
 *          Structure to receive property value.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/
#ifdef WINNT
TCHAR   g_wszDefaultHIDName[80];
UINT    g_uLenDefaultHIDSize;
#endif

STDMETHODIMP
    CHid_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    if(ppropi->iobj < this->df.dwNumObjs)
    {    /* Object property */
        AssertF(ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType);
        switch((DWORD)(UINT_PTR)(ppropi->pguid))
        {
        case (DWORD)(UINT_PTR)(DIPROP_ENABLEREPORTID):
            {        
                LPDIPROPDWORD ppropdw = CONTAINING_RECORD(pdiph, DIPROPDWORD, diph);

                PHIDGROUPCAPS pcaps = this->rghoc[ppropi->iobj].pcaps;

                AssertF(fLimpFF(pcaps,
                                pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE));

                ppropdw->dwData = 0x0;
                AssertF(pcaps->wReportId < this->wMaxReportId[pcaps->type]);
                AssertF(this->pEnableReportId[pcaps->type]);
                (UCHAR)ppropdw->dwData = *(this->pEnableReportId[pcaps->type] + pcaps->wReportId);
                hres = S_OK;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_PHYSICALRANGE):
            {        
                LPDIPROPRANGE pdiprg  = CONTAINING_RECORD(pdiph, DIPROPRANGE, diph);
                PHIDGROUPCAPS pcaps = this->rghoc[ppropi->iobj].pcaps;

                pdiprg->lMin = pcaps->Physical.Min;
                pdiprg->lMax = pcaps->Physical.Max;
                hres = S_OK;
                break;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_LOGICALRANGE):
            {        
                LPDIPROPRANGE pdiprg  = CONTAINING_RECORD(pdiph, DIPROPRANGE, diph);
                PHIDGROUPCAPS pcaps = this->rghoc[ppropi->iobj].pcaps;

                pdiprg->lMin = pcaps->Logical.Min;
                pdiprg->lMax = pcaps->Logical.Max;
                hres = S_OK;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_KEYNAME):
            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;
                UINT uiInstance = ppropi->iobj;
                PHIDGROUPCAPS pcaps;

                AssertF(uiInstance == CHid_ObjFromType(this, ppropi->dwDevType));

                pcaps = this->rghoc[uiInstance].pcaps;

                /*
                 *  pcaps might be NULL if HID messed up and left gaps
                 *  in the index lists.
                 */
                if(pcaps)
                {
                    UINT duiInstance;
        
                    AssertF(pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE);
        
                    if(ppropi->dwDevType & DIDFT_COLLECTION)
                    {
                        duiInstance = 0;
                    } else
                    {
                        /*
                         *  Now convert the uiInstance to a duiInstance,
                         *  giving the index of this object into the group.
                         */
                        AssertF(HidP_IsValidReportType(pcaps->type));
                        duiInstance = uiInstance - (this->rgdwBase[pcaps->type] +
                            pcaps->DataIndexMin);
                    }

                    if(GetHIDString(pcaps->UsageMin + duiInstance,
                                        pcaps->UsagePage,
                                        pdipstr->wsz, cA(pdipstr->wsz)))
                    {
                        hres = S_OK;
                    }
                    else
                    {
                        hres = DIERR_OBJECTNOTFOUND;
                    } 
        
                } else
                {
                    hres = DIERR_NOTFOUND;
                }
                
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_SCANCODE):
            {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                UINT uiInstance = ppropi->iobj;
                PHIDGROUPCAPS pcaps;

                AssertF(uiInstance == CHid_ObjFromType(this, ppropi->dwDevType));

                pcaps = this->rghoc[uiInstance].pcaps;

                /*
                 *  pcaps might be NULL if HID messed up and left gaps
                 *  in the index lists.
                 */
                if(pcaps ) 
                {
                    if ( pcaps->UsagePage == HID_USAGE_PAGE_KEYBOARD )
//ISSUE-2001/03/29-timgill unable to access keyboard consumer keys
//can't do this           || pcaps->UsagePage == HID_USAGE_PAGE_CONSUMER )
                    {
                        UINT duiInstance;
                        HIDP_KEYBOARD_MODIFIER_STATE modifiers;
                        USAGE us;
            
                        AssertF(pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE);
    
                        if(ppropi->dwDevType & DIDFT_COLLECTION)
                        {
                            duiInstance = 0;
                        } else
                        {
                            /*
                             *  Now convert the uiInstance to a duiInstance,
                             *  giving the index of this object into the group.
                             */
                            AssertF(HidP_IsValidReportType(pcaps->type));
                            duiInstance = uiInstance - (this->rgdwBase[pcaps->type] +
                                          pcaps->DataIndexMin);
                        }
            
                        us = pcaps->UsageMin + duiInstance;
    
                        CAssertF( cbX( modifiers ) == cbX( modifiers.ul ) );
                        modifiers.ul = 0; // Use no modifiers for translation
    
                        if( SUCCEEDED(HidP_TranslateUsagesToI8042ScanCodes( &us, 1, HidP_Keyboard_Make, &modifiers, 
                                                                   CHidInsertScanCodes,
                                                                   &pdipdw->dwData 
                                                                 ) ) )
                        {
                            hres = S_OK;
                        } else
                        {
                            hres = E_FAIL;
                        }
                    } else 
                    {
                        hres = E_NOTIMPL;
                    }
                } else 
                {
                    hres = DIERR_NOTFOUND;
                }
            }
            break;
        
        default:
            if(ppropi->dwDevType & DIDFT_POV)
            {
                PHIDGROUPCAPS pcaps = this->rghoc[ppropi->iobj].pcaps;

                AssertF(fLimpFF(pcaps,
                                pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE));

              #ifdef WINNT
                if( pcaps && pcaps->IsPolledPOV && ppropi->pguid == DIPROP_CALIBRATIONMODE ) {
                    PJOYRANGECONVERT pjrc = this->rghoc[ppropi->iobj].pjrc;

                    if(pjrc)
                    {
                        hres = CCal_GetProperty(pjrc, ppropi->pguid, pdiph);
                    } else
                    {
                        hres = E_NOTIMPL;
                    }
                } else
              #endif
                {
                    if(pcaps && ppropi->pguid == DIPROP_GRANULARITY)
                    {
                        LPDIPROPDWORD pdipdw = (PV)pdiph;
                        pdipdw->dwData = pcaps->usGranularity;
                        hres = S_OK;
                    } else
                    {
                        hres = E_NOTIMPL;
                    }
                }
            } else if(ppropi->dwDevType & DIDFT_RELAXIS)
            {

                /*
                 *  All relative axes have a full range by default,
                 *  so we don't need to do anything.
                 */
                hres = E_NOTIMPL;

            } else if(ppropi->dwDevType & DIDFT_ABSAXIS)
            {
                PJOYRANGECONVERT pjrc = this->rghoc[ppropi->iobj].pjrc;

                /*
                 *  Theoretically, every absolute axis will have
                 *  calibration info.  But test just in case something
                 *  impossible happens.
                 */
                if(pjrc)
                {
                    hres = CCal_GetProperty(pjrc, ppropi->pguid, pdiph);
                } else
                {
                    hres = E_NOTIMPL;
                }

            } else
            {
                SquirtSqflPtszV(sqflHidDev | sqflError,
                                TEXT("CHid_GetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                                ppropi->iobj, ppropi->pguid);

                hres = E_NOTIMPL;
            }
        }
    } else if(ppropi->iobj == 0xFFFFFFFF)
    {        /* Device property */

        switch((DWORD)(UINT_PTR)ppropi->pguid)
        {

        case (DWORD)(UINT_PTR)DIPROP_GUIDANDPATH:
            hres = CHid_GetGuidAndPath(this, pdiph);
            break;

        case (DWORD)(UINT_PTR)DIPROP_INSTANCENAME:
        {
            /*
             *  Friendly names cause all manner of problems with devices that 
             *  use auto detection so only allow non-predefined analog devices 
             *  to use them.
             */
            if( ( this->VendorID == MSFT_SYSTEM_VID )
             && ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX )
             && ( ( this->ProductID & 0xff00 ) == MSFT_SYSTEM_PID ) )
            {
                AssertF(this->hkType);
                
                if( this->hkType )
                {
                    LPDIPROPSTRING pstr = (PV)pdiph;

                    hres = JoyReg_GetValue(this->hkType,
                                           REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                           pstr->wsz,
                                           cbX(pstr->wsz));
                                              
                    if( SUCCEEDED(hres ) )
                    {
                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT( "Got instance name %s"), pstr->wsz );

                        if( ( this->diHacks.nMaxDeviceNameLength < MAX_PATH )
                         && ( this->diHacks.nMaxDeviceNameLength < lstrlenW(pstr->wsz) ) )
                        {
                            pstr->wsz[this->diHacks.nMaxDeviceNameLength] = L'\0';
                        }

                        hres = S_OK;
                        break;
                    }
                }
            }
            /*
             *  Fall through to catch the product name
             */
        }
        case (DWORD)(UINT_PTR)DIPROP_PRODUCTNAME:
        {

            LPDIPROPSTRING pdipstr = (PV)pdiph;

            /*
             *  For now, don't deal with mice and keyboard names on NT
             */
          #ifdef WINNT
            AssertF( ( GET_DIDEVICE_TYPE( this->dwDevType ) != DI8DEVTYPE_KEYBOARD )
                  && ( GET_DIDEVICE_TYPE( this->dwDevType ) != DI8DEVTYPE_MOUSE ) );
          #endif
            if( GET_DIDEVICE_TYPE( this->dwDevType ) < DI8DEVTYPE_GAMEMIN ) 
            {
                AssertF( GET_DIDEVICE_TYPE( this->dwDevType ) >= DI8DEVTYPE_DEVICE );
                if( fHasSpecificHardwareMatch( this->ptszId )
                      && SUCCEEDED( hres = DIHid_GetParentRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph, 0x0 ) ) )
                {
                    SquirtSqflPtszV(sqflHid | sqflVerbose,
                        TEXT("Got sys dev description %S"), pdipstr->wsz );
                }
                else if( fGetProductStringFromDevice( this, pdipstr->wsz, cbX( pdipstr->wsz ) ) )
                {
                    SquirtSqflPtszV(sqflHid | sqflVerbose,
                        TEXT( "Got sys dev name from device %S"), pdipstr->wsz );
                    hres = S_OK;
                }
                else
                {
                    if( SUCCEEDED( hres = DIHid_GetRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph ) ) )
                    {
                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT( "Got sys dev name from devnode registry %S"), pdipstr->wsz );
                    }
                    else
                    {
                        UINT uDefName;

                        switch( GET_DIDEVICE_TYPE( this->dwDevType ) )
                        {
                        case DI8DEVTYPE_MOUSE:
                            uDefName = IDS_STDMOUSE;
                            break;
                        case DI8DEVTYPE_KEYBOARD:
                            uDefName = IDS_STDKEYBOARD;
                            break;
                        default:
                            uDefName = IDS_DEVICE_NAME;
                            break;
                        }
                        if( LoadStringW(g_hinst, uDefName, pdipstr->wsz, cbX( pdipstr->wsz ) ) )
                        {
                            SquirtSqflPtszV(sqflHid | sqflVerbose,
                                TEXT( "Loaded default sys dev name %S"), pdipstr->wsz );
                            hres = S_OK;
                        }
                        else
                        {
                            /*
                             *  Give up, this machine is toast if we can't 
                             *  even load a string from our own resources.
                             */
                            SquirtSqflPtszV(sqflHidDev | sqflError,
                                            TEXT("CHid_GetProperty(guid:%08x) failed to get name"),
                                            ppropi->pguid);
                            hres = E_FAIL;
                        }
                    }
                }
            }
            else
            {

                /*
                 *  For game controllers, first look in MediaProperties.
                 *  This is the most likely place to find a localized string 
                 *  free from corruption by the setup process.
                 *  This should only fail before the type key is created when 
                 *  it first used so other paths are rare.
                 */

                DIJOYTYPEINFO dijti;
                WCHAR wszType[cbszVIDPID];

                /* Check the type key or get predefined name */
                ZeroX(dijti);
                dijti.dwSize = cbX(dijti);

                if( ( this->VendorID == MSFT_SYSTEM_VID )
                    &&( ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN )
                        &&( this->ProductID < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
                {
                    wszType[0] = L'#';
                    wszType[1] = L'0' + (WCHAR)(this->ProductID-MSFT_SYSTEM_PID);
                    wszType[2] = L'\0';

                    hres = JoyReg_GetPredefTypeInfo( wszType, &dijti, DITC_DISPLAYNAME);
                    AssertF( SUCCEEDED( hres ) );
                    AssertF( dijti.wszDisplayName[0] != L'\0' );
                    lstrcpyW(pdipstr->wsz, dijti.wszDisplayName);
                    SquirtSqflPtszV(sqflHid | sqflVerbose,
                        TEXT( "Got name as predefined %s"), pdipstr->wsz );
                } 
                else
                {
                  #ifndef WINNT
                    static WCHAR wszDefHIDName[] = L"HID Game Controller";
                  #endif
                    BOOL fOverwriteDeviceName = FALSE;

                  #ifndef UNICODE
                    TCHAR tszType[cbszVIDPID];

                    wsprintf(tszType, VID_PID_TEMPLATE, this->VendorID, this->ProductID);
                    TToU( wszType, cA(wszType), tszType );
                  #else
                    wsprintf(wszType, VID_PID_TEMPLATE, this->VendorID, this->ProductID);
                  #endif

                  #ifdef WINNT
                    #define INPUT_INF_FILENAME L"\\INF\\INPUT.INF"
                    if( g_wszDefaultHIDName[0] == L'\0' )
                    {
                        WCHAR   wszInputINF[MAX_PATH];
                        UINT    uLen;
                        uLen = GetWindowsDirectoryW( wszInputINF, cA( wszInputINF ) );

                        /*
                         *  If the path is too long, don't set the filename 
                         *  so the the default string gets used when the 
                         *  GetPrivateProfileString fails.
                         */
                        if( uLen < cA(wszInputINF) - cA(INPUT_INF_FILENAME) )
                        {
                            memcpy( (PBYTE)&wszInputINF[uLen], (PBYTE)INPUT_INF_FILENAME, cbX( INPUT_INF_FILENAME ) );
                        }

                        /*
                         *  Remember the length, if the string was too long to 
                         *  fit in the buffer there will be plenty to make a 
                         *  reasonable comparison.
                         */
                        g_uLenDefaultHIDSize = 2 * GetPrivateProfileStringW( 
                            L"strings", L"HID.DeviceDesc", L"USB Human Interface Device",
                            g_wszDefaultHIDName, cA( g_wszDefaultHIDName ) - 1, wszInputINF );
                    }
                    #undef INPUT_INF_FILENAME
                  #endif
                  
                    if( SUCCEEDED(hres = JoyReg_GetTypeInfo(wszType, &dijti, DITC_DISPLAYNAME))
                        && (dijti.wszDisplayName[0] != L'\0')
                      #ifdef WINNT
                        && ( (g_uLenDefaultHIDSize == 0)
                            || memcmp(dijti.wszDisplayName, g_wszDefaultHIDName, g_uLenDefaultHIDSize) ) // not equal
                      #else
                        && memcmp(dijti.wszDisplayName, wszDefHIDName, cbX(wszDefHIDName)-2)  //not equal
                      #endif
                    )
                    {
                        LPDIPROPSTRING pdipstr = (PV)pdiph;
                        lstrcpyW(pdipstr->wsz, dijti.wszDisplayName);

                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT("Got name from type info %s"), pdipstr->wsz );
                    }
                  #ifdef WINNT
                    else if( fHasSpecificHardwareMatch( this->ptszId )
                          && SUCCEEDED( hres = DIHid_GetParentRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph, 0x0 ) ) )
                    {
                        fOverwriteDeviceName = TRUE;

                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT("Got device description %s"), pdipstr->wsz );
                    }
                  #endif
                    else
                    {
                        if( fGetProductStringFromDevice( this, pdipstr->wsz, cbX( pdipstr->wsz ) ) )
                        {
                            fOverwriteDeviceName = TRUE;

                            SquirtSqflPtszV(sqflHid | sqflVerbose,
                                TEXT("Got description %s from device"), pdipstr->wsz );
                        }
                        else
                        {
                            /*
                             *  Just make up a name from the caps
                             */
                            CType_MakeGameCtrlName( pdipstr->wsz, 
                                this->dwDevType, this->dwAxes, this->dwButtons, this->dwPOVs );

                            fOverwriteDeviceName = TRUE;

                            SquirtSqflPtszV(sqflHid | sqflVerbose,
                                TEXT("Made up name %s"), pdipstr->wsz );

                        }

                        hres = S_OK;
                    }

                    if( fOverwriteDeviceName ) {
                        /*
                         * If we have a better name, overwrite the old one with this better one.
                         * See manbug 46438.
                         */
                        AssertF(this->hkType);
                        AssertF(pdipstr->wsz[0]);
                        hres = JoyReg_SetValue(this->hkType,
                                               REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                               pdipstr->wsz,
                                               cbX(pdipstr->wsz));
                        if( FAILED(hres) ){
                            SquirtSqflPtszV(sqflHid | sqflVerbose,
                                TEXT("Unable to overwrite generic device name with %s"), pdipstr->wsz );
    
                            // This failure (unlikely) doesn't matter.
                            hres = S_OK;
                        }
                    }

                }
            }

            if( SUCCEEDED(hres) 
             && ( this->diHacks.nMaxDeviceNameLength < MAX_PATH )
             && ( this->diHacks.nMaxDeviceNameLength < lstrlenW(pdipstr->wsz) ) )
            {
                pdipstr->wsz[this->diHacks.nMaxDeviceNameLength] = L'\0';
            }
            break;
        }

        case (DWORD)(UINT_PTR)DIPROP_JOYSTICKID:
            if( ( GET_DIDEVICE_TYPE( this->dwDevType ) >= DI8DEVTYPE_GAMEMIN ) 
             && ( this->dwDevType & DIDEVTYPE_HID ) )
            {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                pdipdw->dwData =  this->idJoy;
                hres = S_OK;

            } else
            {
                hres = E_NOTIMPL;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_GETPORTDISPLAYNAME:

#ifdef WINNT
            /* For HID devices Port Display Name is the grand parent name */
            hres = DIHid_GetParentRegistryProperty(this->ptszId, SPDRP_FRIENDLYNAME, pdiph, TRUE);
            if( FAILED(hres) )
            {
                /* Maybe we can use the Product Name */
                hres = DIHid_GetParentRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph, TRUE);
                if( SUCCEEDED(hres) )
                {
                    /* We only sort of succeeded */
                    hres = S_FALSE;
                }
            }
            if( SUCCEEDED(hres) 
             && ( this->diHacks.nMaxDeviceNameLength < MAX_PATH ) )
            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;
                if( this->diHacks.nMaxDeviceNameLength < lstrlenW(pdipstr->wsz) )
                {
                    pdipstr->wsz[this->diHacks.nMaxDeviceNameLength] = L'\0';
                }
            }
#else
            // Not sure how this works on Win9x
            hres = E_NOTIMPL;
#endif
            break;

        case (DWORD)(UINT_PTR)(DIPROP_ENABLEREPORTID):
            hres = E_NOTIMPL;
            break;

        case (DWORD)(UINT_PTR)DIPROP_VIDPID:
            {
                LPDIPROPDWORD pdipdw = (PV)pdiph;
                /* Assert that a DWORD copy is all that is needed */
                CAssertF( FIELD_OFFSET( CHID, VendorID ) + cbX( this->VendorID ) 
                       == FIELD_OFFSET( CHID, ProductID ) );
                pdipdw->dwData =  *((PDWORD)(&this->VendorID));
                hres = S_OK;
            } 
            break;

        case (DWORD)(UINT_PTR)(DIPROP_MAPFILE):
            if( ( this->dwDevType == DI8DEVTYPE_MOUSE )
             || ( this->dwDevType == DI8DEVTYPE_KEYBOARD ) )
            {
                hres = E_NOTIMPL;
            }
            else
            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;
                LONG    lRes;
                DWORD   dwBufferSize = cbX(pdipstr->wsz);

                lRes = RegQueryStringValueW( this->hkProp, REGSTR_VAL_JOYOEMMAPFILE, pdipstr->wsz, &dwBufferSize );
                hres = ( pdipstr->wsz[0] && ( lRes == ERROR_SUCCESS ) ) ? S_OK : DIERR_OBJECTNOTFOUND;
            }
            break;

        case (DWORD)(UINT_PTR)(DIPROP_TYPENAME):
            if( ( this->dwDevType == DI8DEVTYPE_MOUSE )
             || ( this->dwDevType == DI8DEVTYPE_KEYBOARD ) )
            {
                hres = E_NOTIMPL;
            }
            else
            {
                LPDIPROPSTRING pdipstr = (PV)pdiph;

                if( ( this->VendorID == MSFT_SYSTEM_VID )
                    &&( ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN )
                        &&( this->ProductID < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
                {
                    pdipstr->wsz[0] = L'#';
                    pdipstr->wsz[1] = L'0' + (WCHAR)(this->ProductID-MSFT_SYSTEM_PID);
                    pdipstr->wsz[2] = L'\0';
                } 
                else
                {
    #ifndef UNICODE
                    TCHAR tszType[cbszVIDPID];

                    wsprintf(tszType, VID_PID_TEMPLATE, this->VendorID, this->ProductID);
                    TToU( pdipstr->wsz, cA(pdipstr->wsz), tszType );
    #else
                    wsprintf(pdipstr->wsz, VID_PID_TEMPLATE, this->VendorID, this->ProductID);
    #endif
                }
                hres = S_OK;
            }
            break;

        default:
            SquirtSqflPtszV(sqflHid | sqflBenign ,
                            TEXT("CHid_GetProperty(iobj=0xFFFFFFFF): E_NOTIMPL on guid: %08x"),
                            ppropi->pguid);

            hres = E_NOTIMPL;
            break;
        }

    } else
    {
        SquirtSqflPtszV(sqflHidDev | sqflError,
                        TEXT("CHid_GetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                        ppropi->iobj, ppropi->pguid);

        hres = E_NOTIMPL;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | CHid_CoordinateTransform |
 *
 *          Convert numbers from logical to physical or vice versa.
 *
 *          If either the To or From values look suspicious, then
 *          ignore them and leave the values alone.
 *
 *  @parm   PLMINMAX | Dst |
 *
 *          Destination min/max information.
 *
 *  @parm   PLMINMAX | Src |
 *
 *          Source min/max information.
 *
 *  @parm   LONG | lVal |
 *
 *          Source value to be converted.
 *
 *  @returns
 *
 *          The destination value after conversion.
 *
 *****************************************************************************/

LONG EXTERNAL
    CHid_CoordinateTransform(PLMINMAX Dst, PLMINMAX Src, LONG lVal)
{
    /*
     *  Note that the sanity check is symmetric in Src and Dst.
     *  This is important, so that we never get into a weird
     *  case where we can convert one way but can't convert back.
     */
    if(Dst->Min < Dst->Max && Src->Min < Src->Max)
    {

        /*
         *  We need to perform a straight linear interpolation.
         *  The math comes out like this:
         *
         *  x  - x0   y  - y0
         *  ------- = -------
         *  x1 - x0   y1 - y0
         *
         *  If you now do a "solve for y", you get
         *
         *
         *               y1 - y0
         *  y = (x - x0) ------- + y0
         *               x1 - x0
         *
         *  where "x" is Src, "y" is Dst, 0 is Min, and 1 is Max.
         *
         *
         */

        lVal = MulDiv(lVal - Src->Min, Dst->Max - Dst->Min,
                      Src->Max - Src->Min) + Dst->Min;
    }

    return lVal;
}


#ifndef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CHid | IsMatchingJoyDevice |
 *
 *          Does the cached joystick ID match us?
 *
 *  @parm   OUT PVXDINITPARMS | pvip |
 *
 *          On success, contains parameter values.
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

BOOL INTERNAL
    CHid_IsMatchingJoyDevice(PCHID this, PVXDINITPARMS pvip)
{
    CHAR sz[MAX_PATH];
    LPSTR pszPath;
    BOOL fRc;

    pszPath = JoyReg_JoyIdToDeviceInterface_95(this->idJoy, pvip, sz);
    if(pszPath)
    {
        SquirtSqflPtszV(sqfl | sqflTrace,
                        TEXT("CHid_IsMatchingJoyDevice: %d -> %s"),
                        this->idJoy, pszPath);
    #ifdef UNICODE
        {
            CHAR szpath[MAX_PATH];
            UToA( szpath, cA(szpath), (LPWSTR)this->ptszPath);
            fRc = ( lstrcmpiA(pszPath, szpath) == 0x0 );
        }
    #else
        fRc = ( lstrcmpiA(pszPath, (PCHAR)this->ptszPath) == 0x0 );
    #endif
    } else
    {
        fRc = FALSE;
    }

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | FindJoyDevice |
 *
 *          Look for the VJOYD device that matches us, if any.
 *
 *          On return, the <e CHID.idJoy> field contains the
 *          matching joystick number, or -1 if not found.
 *
 *  @parm   OUT PVXDINITPARMS | pvip |
 *
 *          On success, contains parameter values.
 *
 *****************************************************************************/

void INTERNAL
    CHid_FindJoyDevice(PCHID this, PVXDINITPARMS pvip)
{

    /*
     *  If we have a cached value, and it still works, then
     *  our job is done.
     */
    if(this->idJoy >= 0 &&
       CHid_IsMatchingJoyDevice(this, pvip))
    {
    } else
    {
        /*
         *  Need to keep looking.  (Or start looking.)
         *
         *  A countdown loop is nicer, but for efficiency, we count
         *  upwards, since the joystick we want tends to be near the
         *  beginning.
         */
        for(this->idJoy = 0; this->idJoy < cJoyMax; this->idJoy++)
        {
            if(CHid_IsMatchingJoyDevice(this, pvip))
            {
                goto done;
            }
        }
        this->idJoy = -1;
    }

    done:;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method int | CHid | MapAxis |
 *
 *          Find VJOYD axis from HID axis, if one.
 *
 *  @parm   PVXDINITPARMS | pvip |
 *
 *          Parameter values that let us known which axes VJOYD
 *          has mapped to which HID Axes.
 *
 *  @parm   UINT | iobj |
 *
 *          Object index of the object whose axis value changed.
 *
 *  @returns
 *
 *          The VJOYD axis number that changed (0 to 5), or -1
 *          if there is no matching axis.  There will be no matching
 *          axis if, for example, the device has something that is
 *          not expressible via VJOYD (e.g., a temperature sensor).
 *
 *****************************************************************************/

int INTERNAL
    CHid_MapAxis(PCHID this, PVXDINITPARMS pvip, UINT iobj)
{
    int iAxis;
    DWORD dwUsage;

    AssertF(this->dcb.lpVtbl->GetUsage == CHid_GetUsage);

    dwUsage = CHid_GetUsage(&this->dcb, (int)iobj);

    if(dwUsage)
    {

        /*
         *  A countdown loop lets us fall out with the correct failure
         *  code (namely, -1).
         */
        iAxis = cJoyPosAxisMax;
        while(--iAxis >= 0)
        {
            if(pvip->Usages[iAxis] == dwUsage)
            {
                break;
            }
        }
    } else
    {
        /*
         *  Eek!  No usage information for the axis.  Then it certainly
         *  isn't a VJOYD axis.
         */
        iAxis = -1;
    }

    return iAxis;

}

#ifndef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | UpdateVjoydCalibration |
 *
 *          Somebody changed the calibration on a single axis.  If we
 *          are shadowing a joystick, then look for the VJOYD alias of
 *          our device and update its registry settings, too.
 *
 *
 *  @parm   UINT | iobj |
 *
 *          Object index of the object whose calibration changed.
 *
 *****************************************************************************/

void EXTERNAL
    CHid_UpdateVjoydCalibration(PCHID this, UINT iobj)
{
    HRESULT hres;
    int iAxis;
    VXDINITPARMS vip;
    DIJOYCONFIG cfg;
    PHIDGROUPCAPS pcaps;
    PJOYRANGECONVERT pjrc;

    AssertF(iobj < this->df.dwNumObjs);

    /*
     *  Proceed if...
     *
     *  -   We can find the VJOYD device we correspond to.
     *  -   We can find the axis that got updated.
     *  -   The indicated axis has capability information.
     *  -   The indicated axis has calibration information.
     *  -   We can read the old calibration information.
     */

    CHid_FindJoyDevice(this, &vip);
    if(this->idJoy >= 0 &&
       (iAxis = CHid_MapAxis(this, &vip, iobj)) >= 0 &&
       (pcaps = this->rghoc[iobj].pcaps) != NULL &&
       (pjrc = this->rghoc[iobj].pjrc) != NULL &&
       SUCCEEDED(hres = JoyReg_GetConfig(this->idJoy, &cfg,
                                         DIJC_REGHWCONFIGTYPE)))
    {

        PLMINMAX Dst = &pcaps->Physical;
        PLMINMAX Src = &pcaps->Logical;

        AssertF(iAxis < cJoyPosAxisMax);

    #define JoyPosValue(phwc, f, i)                                 \
            *(LPDWORD)pvAddPvCb(&(phwc)->hwv.jrvHardware.f,             \
                            ibJoyPosAxisFromPosAxis(i))

        /*
         *  We use logical coordinates, but VJOYD wants physical
         *  coordinates, so do the conversion while we copy the
         *  values.
         */
    #define ConvertValue(f1, f2)                                    \
            JoyPosValue(&cfg.hwc, f1, iAxis) =                          \
                    CHid_CoordinateTransform(Dst, Src, pjrc->f2)        \

        ConvertValue(jpMin   , dwPmin);
        ConvertValue(jpMax   , dwPmax);
        ConvertValue(jpCenter, dwPc  );

    #undef ConvertValue
    #undef JoyPosValue

        /*
         *  Notice that we do *not* pass the DIJC_UPDATEALIAS flag
         *  because WE ARE THE ALIAS!  If we had passed the flag,
         *  then JoyReg would create us and attempt to update our
         *  calibration which we don't want it to do because the
         *  whole thing was our idea in the first place.
         */
        hres = JoyReg_SetConfig(this->idJoy, &cfg.hwc, &cfg,
                                DIJC_REGHWCONFIGTYPE);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | UpdateCalibrationFromVjoyd |
 *
 *          This function is only for Win9x. Joy.cpl uses winmm (through vjoyd)
 *          to calibrate the device, and save calibration information directly into
 *          registry without notifying HID. ANother issue is: vjoyd only use unsigned
 *          data (physical data), while HID also use signed data. When we read
 *          calibration information from VJOYD, we need do conversion.
 *
 *  @parm   UINT | iobj |
 *
 *          Object index of the object whose calibration changed.
 *
 *****************************************************************************/

void EXTERNAL
    CHid_UpdateCalibrationFromVjoyd(PCHID this, UINT iobj, LPDIOBJECTCALIBRATION pCal)
{
    HRESULT hres;
    int iAxis;
    VXDINITPARMS vip;
    DIJOYCONFIG cfg;
    PHIDGROUPCAPS pcaps;
    PJOYRANGECONVERT pjrc;

    AssertF(iobj < this->df.dwNumObjs);

    /*
     *  Proceed if...
     *
     *  -   We can find the VJOYD device we correspond to.
     *  -   We can find the axis that got updated.
     *  -   The indicated axis has capability information.
     *  -   The indicated axis has calibration information.
     *  -   We can read the calibration information.
     */

    CHid_FindJoyDevice(this, &vip);
    if(this->idJoy >= 0 &&
       (iAxis = CHid_MapAxis(this, &vip, iobj)) >= 0 &&
       (pcaps = this->rghoc[iobj].pcaps) != NULL &&
       (pjrc = this->rghoc[iobj].pjrc) != NULL &&
       SUCCEEDED(hres = JoyReg_GetConfig(this->idJoy, &cfg,
                                         DIJC_REGHWCONFIGTYPE)))
    {

        PLMINMAX Src = &pcaps->Physical;
        PLMINMAX Dst = &pcaps->Logical;

        AssertF(iAxis < cJoyPosAxisMax);

        #define JoyPosValue(phwc, f, i)                                 \
            *(LPDWORD)pvAddPvCb(&(phwc)->hwv.jrvHardware.f,             \
                            ibJoyPosAxisFromPosAxis(i))

        /*
         *  We use logical coordinates, but VJOYD wants physical
         *  coordinates, so do the conversion while we copy the
         *  values.
         */
        #define ConvertValue(f1, f2)                           \
            pCal->f2 = CHid_CoordinateTransform(Dst, Src,     \
                                             JoyPosValue(&cfg.hwc, f1, iAxis) ) 
        ConvertValue(jpMin   , lMin);
        ConvertValue(jpMax   , lMax);
        ConvertValue(jpCenter, lCenter);

        #undef ConvertValue
        #undef JoyPosValue

    }
}
#endif

#ifdef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func HRESULT |  DIHid_SetParentRegistryProperty |
 *
 *          Wrapper around <f SetupDiSetDeviceRegistryProperty>
 *          that handles character set issues.
 *
 *  @parm   LPTSTR ptszId
 *          
 *          Device Instance ID.
 *  
 *  @parm   DWORD | dwProperty |
 *
 *          The property being queried.
 *
 *  @parm   LPCDIPROPHEADER | diph |
 *
 *          Property data to be set.
 *
 *****************************************************************************/
HRESULT INTERNAL
    DIHid_SetParentRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPCDIPROPHEADER pdiph)
{
    HDEVINFO hdev;
    TCHAR   tsz[MAX_PATH];
    LPDIPROPSTRING pstr = (PV)pdiph;
    HRESULT hres = E_FAIL;

    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;

        ZeroX(tsz);
    #ifdef UNICODE
        lstrcpyW(tsz, pstr->wsz);
    #else 
        UToA(tsz, cA(tsz), pstr->wsz);
    #endif
        dinf.cbSize = cbX(SP_DEVINFO_DATA);

        if(SetupDiOpenDeviceInfo(hdev, ptszId, NULL, 0, &dinf))
        {
            CONFIGRET cr;
            DEVINST DevInst;
            if( (cr = CM_Get_Parent(&DevInst, dinf.DevInst, 0x0) ) == CR_SUCCESS )
            {
                CAssertF( SPDRP_DEVICEDESC   +1  == CM_DRP_DEVICEDESC  );
                CAssertF( SPDRP_FRIENDLYNAME +1  ==  CM_DRP_FRIENDLYNAME );

                if( ( cr = CM_Set_DevNode_Registry_Property(
                                                           DevInst,
                                                           dwProperty+1,
                                                           (LPBYTE)tsz,
                                                           MAX_PATH *cbX(TCHAR),
                                                           0x0 ) ) == CR_SUCCESS )
                {
                    hres = S_OK;
                } else
                {
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                                    TEXT("CM_Get_DevNode_Registry_Property FAILED") );
                }
            } else
            {
                SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("CM_Get_Parent FAILED") );
            }
        } else
        {
            SquirtSqflPtszV(sqfl | sqflVerbose,
                            TEXT("SetupDiOpenDeviceInfo FAILED, le = %d"), GetLastError() );
        }

        SetupDiDestroyDeviceInfoList(hdev);
    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("SetupDiCreateDeviceInfoList FAILED, le = %d"), GetLastError() );
    }

    return hres;
}
#else
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func HRESULT |  DIHid_SetRegistryProperty |
 *
 *          Wrapper around <f SetupDiSetDeviceRegistryProperty>
 *          that handles character set issues.
 *
 *  @parm   LPTSTR ptszId
 *          
 *          Device Instance ID.
 *  
 *  @parm   DWORD | dwProperty |
 *
 *          The property being queried.
 *
 *  @parm   LPCDIPROPHEADER | diph |
 *
 *          Property data to be set.
 *
 *****************************************************************************/
HRESULT INTERNAL
    DIHid_SetRegistryProperty(LPTSTR ptszId, DWORD dwProperty, LPCDIPROPHEADER pdiph)
{
    HDEVINFO hdev;
    TCHAR   tsz[MAX_PATH];
    LPDIPROPSTRING pstr = (PV)pdiph;
    HRESULT hres;

    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf;

        ZeroX(tsz);
    #ifdef UNICODE
        lstrcpyW(tsz, pstr->wsz);
    #else 
        UToA(tsz, cA(tsz), pstr->wsz);
    #endif
        dinf.cbSize = cbX(SP_DEVINFO_DATA);

        if(SetupDiOpenDeviceInfo(hdev, ptszId, NULL, 0, &dinf))
        {
            if(SetupDiSetDeviceRegistryProperty(hdev, &dinf, dwProperty,
                                                (LPBYTE)tsz, MAX_PATH*cbX(TCHAR)) )
            {
                hres = S_OK;

            } else
            {
                hres = E_FAIL;
            }
        } else
        {
            hres = E_FAIL;
        }

        SetupDiDestroyDeviceInfoList(hdev);
    } else
    {
        hres = E_FAIL;
    }

    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SetAxisProperty |
 *
 *          Set the appropriate axis property (or return E_NOTIMPL if the 
 *          property is not an axis property).
 *          If the request is to set a property on the device,
 *          then convert it into separate requests, one for each
 *          axis.
 *
 *  @parm   PDCHID | this |
 *
 *          The device object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
CHid_SetAxisProperty
(
    PCHID this, 
    LPCDIPROPINFO ppropi, 
    LPCDIPROPHEADER pdiph
)
{
    HRESULT hres;
    INT     iObjLimit;
    INT     iObj;


    if (ppropi->dwDevType == 0) 
    {   /* For device try every object */
        iObj = 0;
        iObjLimit = this->df.dwNumObjs;
    } 
    else
    {   /* For axis just do the requested one */
        iObj = ppropi->iobj;
        iObjLimit = ppropi->iobj + 1;
    }

    hres = S_OK;
    for( ; iObj < iObjLimit; iObj++ )
    {
        PJOYRANGECONVERT pjrc;

        if( pjrc = this->rghoc[iObj].pjrc )
        {
            if( (this->df.rgodf[iObj].dwType &
                 (DIDFT_ALIAS | DIDFT_VENDORDEFINED | DIDFT_OUTPUT | DIDFT_ABSAXIS)) == DIDFT_ABSAXIS)
            {
                PHIDGROUPCAPS pcaps = this->rghoc[iObj].pcaps;
                DIPROPCAL cal;
                
                /*
                *  Specific calibrations arrive in VJOYD coordinates.
                *  We need to convert them to DirectInput (logical)
                *  coordinates if so.
                */
                if(ppropi->pguid == DIPROP_SPECIFICCALIBRATION)
                {
                   if( pcaps )
                   {
                       PLMINMAX Dst = &pcaps->Logical;
                       PLMINMAX Src = &pcaps->Physical;
                       LPDIPROPCAL pcal = CONTAINING_RECORD(pdiph, DIPROPCAL, diph);
                
                       cal.lMin    = CHid_CoordinateTransform(Dst, Src, pcal->lMin);
                       cal.lCenter = CHid_CoordinateTransform(Dst, Src, pcal->lCenter);
                       cal.lMax    = CHid_CoordinateTransform(Dst, Src, pcal->lMax);
                
                       pdiph = &cal.diph;
                   }
                   else
                   {
                       AssertF( ppropi->dwDevType == 0 );
                       /*
                        *  Ignore the error.  If this is an object set 
                        *  property validation should have caught this 
                        *  already and the DX7 patch code for device set 
                        *  property special cased E_NOTIMPL so that one bad 
                        *  axis would not cause the whole call to fail when 
                        *  other axes may be OK.
                        *  A bit flakey but "this should never happen"
                        */            
                       continue;
                   }
                }
                
                hres = CCal_SetProperty( pjrc, ppropi, pdiph, this->hkInstType );
                
                #ifndef WINNT
                /*
                *  If we successfully changed the calibration of a game 
                *  controller device, then see if it's a VJOYD device.
                */
                if(SUCCEEDED(hres) &&
                  ppropi->pguid == DIPROP_CALIBRATION &&
                  GET_DIDEVICE_TYPE(this->dwDevType) >= DI8DEVTYPE_GAMEMIN)
                {
                   CHid_UpdateVjoydCalibration(this, ppropi->iobj);
                }
                #endif
            }
          #ifdef WINNT
            else if( (this->df.rgodf[iObj].dwType & 
                  (DIDFT_ALIAS | DIDFT_VENDORDEFINED | DIDFT_OUTPUT | DIDFT_POV)) == DIDFT_POV)
            {
                PHIDGROUPCAPS pcaps = this->rghoc[iObj].pcaps;
                
                if( pcaps )
                {
                    if( pcaps->IsPolledPOV ) 
                    {
                        hres = CCal_SetProperty(pjrc, ppropi, pdiph, this->hkInstType);
            
                        if( SUCCEEDED(hres) ) {
                            CHid_LoadCalibrations(this);
                            CHid_InitParseData( this );
                        }
                    }
                    else
                    {
                        if( ppropi->dwDevType != 0 )
                        {
                            hres = E_NOTIMPL;
                        }
                    }
                }
                else
                {
                    AssertF( ppropi->dwDevType == 0 );
                    /*
                     *  Ignore the error.  If this is an object set 
                     *  property validation should have caught this 
                     *  already and the DX7 patch code for device set 
                     *  property special cased E_NOTIMPL so that one bad 
                     *  axis would not cause the whole call to fail when 
                     *  other axes may be OK.
                     *  A bit flakey but "this should never happen"
                     */            
                    continue;
                }
            }
          #endif
        }
        else
        {
            /*
             *  If the object cannot have an axis property set, the DX7 code 
             *  returned E_NOTIMPL when it should have returned some parameter 
             *  error.  For a device, this is not an error as we are iterating 
             *  all objects looking for absolute axes.
             *  If it is an absolute axis but has no range conversion, return 
             *  E_NOTIMPL to match previous versions for an object but ignore 
             *  for the device.  This probably should be an E_FAIL...
             */
            if( ppropi->dwDevType != 0 )
            {
                hres = E_NOTIMPL;
            }
        }
    }

    /*
     *  Don't need to hold/unhold here because the app called us so it should 
     *  not be releasing us at the same time. (mb:34570)
     */
    CHid_LoadCalibrations(this);

    if( SUCCEEDED(hres) )
    {
        /*
         *  Until such time as CHid_InitParseData returns anything other than 
         *  S_OK, don't update a possibly more informative result with this.
         */
        D( HRESULT hresDbg = )
        CHid_InitParseData( this );
        D( AssertF( hresDbg == S_OK ); ) 
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SetProperty |
 *
 *          Set a hid device property.
 *
 *  @parm   PCHID | this |
 *
 *          The hid object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the property being set.
 *
 *  @parm   LPCDIPROPHEADER | pdiph |
 *
 *          Structure containing property value.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c E_NOTIMPL> nothing happened.  The caller will do
 *          the default thing in response to <c E_NOTIMPL>.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::SetProperty,
               (_ "pxxp", pdcb, ppropi->pguid, ppropi->iobj, pdiph));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    if(ppropi->iobj < this->df.dwNumObjs)
    {
        /* 
         * Object Property
         */
        PHIDGROUPCAPS pcaps;
        AssertF(ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType);
        AssertF(ppropi->iobj == CHid_ObjFromType(this, ppropi->dwDevType));

        if( pcaps = this->rghoc[ppropi->iobj].pcaps )
        {
            switch((DWORD)(UINT_PTR)ppropi->pguid)
            {
            case (DWORD)(UINT_PTR)(DIPROP_ENABLEREPORTID):
                {
                    LPDIPROPDWORD ppropdw = CONTAINING_RECORD(pdiph, DIPROPDWORD, diph);

                    AssertF(pcaps->wReportId < this->wMaxReportId[pcaps->type]);
                    AssertF(this->pEnableReportId[pcaps->type]);

                    hres = S_OK;
                    if( ppropdw->dwData == 0x1 )
                    {
                        *(this->pEnableReportId[pcaps->type] + pcaps->wReportId) = 0x1;
                        pcaps->fReportDisabled = FALSE;
                    } else
                    {
                        *(this->pEnableReportId[pcaps->type] + pcaps->wReportId) = 0x0;
                        pcaps->fReportDisabled = TRUE;
                    }
                }
                break;

            default:
                AssertF(ppropi->dwDevType == this->df.rgodf[ppropi->iobj].dwType);
                AssertF(ppropi->iobj == CHid_ObjFromType(this, ppropi->dwDevType));

                hres = CHid_SetAxisProperty( this, ppropi, pdiph );

            }
        } else
        {
            SquirtSqflPtszV(sqflHidDev | sqflError,
                            TEXT("CHid_SetProperty FAILED due to missing caps for type 0x%08x, obj %d"),
                            ppropi->dwDevType, ppropi->iobj  );

            hres = E_NOTIMPL;
        }
    } else if(ppropi->iobj == 0xFFFFFFFF)
    {        /* Device property */

        switch((DWORD)(UINT_PTR)ppropi->pguid)
        {
        case (DWORD)(UINT_PTR)DIPROP_GUIDANDPATH:
            SquirtSqflPtszV(sqflHidDev | sqflError,
                            TEXT("CHid_SetProperty(iobj=%08x): PROP_GUIDANDPATH is read only.") );
            hres = E_NOTIMPL;
            break;


        case (DWORD)(UINT_PTR)DIPROP_INSTANCENAME:
            /*
             *  Friendly names cause all manner of problems with devices that 
             *  use auto detection so only allow non-predefined analog devices 
             *  to use them.
             */
            if( ( this->VendorID == MSFT_SYSTEM_VID )
             && ( this->ProductID >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX )
             && ( ( this->ProductID & 0xff00 ) == MSFT_SYSTEM_PID ) )
            {
                AssertF(this->hkType);
                
                if( this->hkType )
                {
                    LPDIPROPSTRING pstr = (PV)pdiph;

                    hres = JoyReg_SetValue(this->hkType,
                                           REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                           pstr->wsz,
                                           cbX(pstr->wsz));
                                              
                    if( SUCCEEDED(hres ) )
                    {
                        SquirtSqflPtszV(sqflHid | sqflVerbose,
                            TEXT( "Set instance name %s"), pstr->wsz );
                        hres = S_OK;
                    } else {
                        hres = E_FAIL;
                    }
                } else {
                    hres = E_FAIL;
                }
            }
            else
            {
                /*
                 *  GenJ returns E_NOTIMPL for this property so do the same
                 */
                hres = E_NOTIMPL;
            }

            break;

        case (DWORD)(UINT_PTR)DIPROP_PRODUCTNAME:
          #ifdef WINNT
            hres = DIHid_SetParentRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph);
          #else
            hres = DIHid_SetRegistryProperty(this->ptszId, SPDRP_DEVICEDESC, pdiph);
          #endif
            break;

        case (DWORD)(UINT_PTR)(DIPROP_ENABLEREPORTID):
            {            
                LPDIPROPDWORD ppropdw = CONTAINING_RECORD(pdiph, DIPROPDWORD, diph);

                UINT iType;

                if( ppropdw->dwData == 0x0  )
                {
                    for( iType = 0x0; iType < HidP_Max; iType++)
                    {
                        ZeroBuf(this->pEnableReportId[iType], this->wMaxReportId[iType]);
                    }

                } else
                {
                    for( iType = 0x0; iType < HidP_Max; iType++)
                    {
                        memset(this->pEnableReportId[iType], 0x1, this->wMaxReportId[iType]);
                    }
                }
                hres = S_OK;
            }
            break;

        case (DWORD)(UINT_PTR)DIPROP_RANGE:
        case (DWORD)(UINT_PTR)DIPROP_DEADZONE:
        case (DWORD)(UINT_PTR)DIPROP_SATURATION:
        case (DWORD)(UINT_PTR)DIPROP_CALIBRATIONMODE:
        case (DWORD)(UINT_PTR)DIPROP_CALIBRATION:
            hres = CHid_SetAxisProperty( this, ppropi, pdiph );
            break;

        default:
            SquirtSqflPtszV(sqflHidDev| sqflBenign,
                            TEXT("CHid_SetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                            ppropi->iobj, ppropi->pguid);

            hres = E_NOTIMPL;
            break;
        }

    } else
    {
        SquirtSqflPtszV(sqflHidDev | sqflError,
                        TEXT("CHid_SetProperty(iobj=%08x): E_NOTIMPL on guid: %08x"),
                        ppropi->iobj, ppropi->pguid);

        hres = E_NOTIMPL;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | CHid | GetCapabilities |
 *
 *          Get Hid device capabilities.
 *
 *  @parm   LPDIDEVCAPS | pdc |
 *
 *          Device capabilities structure to receive result.
 *
 *  @returns
 *          <c S_OK> on success.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetCapabilities(PDICB pdcb, LPDIDEVCAPS pdc)
{
    HRESULT hres;
    PCHID this;
    HANDLE h;
    DWORD dwFlags2 = 0;

    EnterProcI(IDirectInputDeviceCallback::Hid::GetCapabilities,
               (_ "pp", pdcb, pdc));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  We must check connectivity by opening the device, because NT
     *  leaves the device in the info list even though it has
     *  been unplugged.
     */
    h = CHid_OpenDevicePath(this, FILE_FLAG_OVERLAPPED);
    if(h != INVALID_HANDLE_VALUE)
    {
      #ifndef WINNT
        if( this->hkType )
        {
            VXDINITPARMS vip;

            CHid_FindJoyDevice(this, &vip);

            if( TRUE == CHid_IsMatchingJoyDevice( this, &vip ) )
            {
                DWORD dwFlags1;
                if( SUCCEEDED( JoyReg_GetValue( this->hkType,
                                                REGSTR_VAL_FLAGS1, REG_BINARY, 
                                                &dwFlags1, 
                                                cbX(dwFlags1) ) ) )
                {
                    if( dwFlags1 & JOYTYPE_NOHIDDIRECT )
                    {
                        pdc->dwFlags |= DIDC_ALIAS;
                    }
                }
            }
        }
      #endif // !WINNT

        CloseHandle(h);

        if( this->pvi->fl & VIFL_UNPLUGGED )
        {
            pdc->dwFlags &= ~DIDC_ATTACHED;
        } else
        {
            pdc->dwFlags |= DIDC_ATTACHED;
        }

    } else
    {
        pdc->dwFlags &= ~DIDC_ATTACHED;
    }

    if( this->IsPolledInput )
    {
        pdc->dwFlags |= DIDC_POLLEDDEVICE;
    }

    if( this->hkProp )
    {
        JoyReg_GetValue( this->hkProp, REGSTR_VAL_FLAGS2, REG_BINARY, 
            &dwFlags2, cbX(dwFlags2) );
    }

    if( !( dwFlags2 & JOYTYPE_HIDEACTIVE ) )
    {
        // Currently we only hide "fictional" keyboards and mice. 
        if(   ( GET_DIDEVICE_TYPE( this->dwDevType ) == DI8DEVTYPE_MOUSE )
            ||( GET_DIDEVICE_TYPE( this->dwDevType ) == DI8DEVTYPE_KEYBOARD )
              )
        {
            dwFlags2 = DIHid_DetectHideAndRevealFlags(this) ;
        }
    }

    if( dwFlags2 & JOYTYPE_HIDEACTIVE )
    {
        switch( GET_DIDEVICE_TYPE( this->dwDevType ) )
        {
        case DI8DEVTYPE_DEVICE:
            if( dwFlags2 & JOYTYPE_DEVICEHIDE )
            {
                pdc->dwFlags |= DIDC_HIDDEN;
            }
            break;
        case DI8DEVTYPE_MOUSE:
            if( dwFlags2 & JOYTYPE_MOUSEHIDE )
            {
                pdc->dwFlags |= DIDC_HIDDEN;
            }
            break;
        case DI8DEVTYPE_KEYBOARD:
            if( dwFlags2 & JOYTYPE_KEYBHIDE )
            {
                pdc->dwFlags |= DIDC_HIDDEN;
            }
            break;
        default:
            if( dwFlags2 & JOYTYPE_GAMEHIDE )
            {
                pdc->dwFlags |= DIDC_HIDDEN;
            }
            break;
        }
    }

    pdc->dwDevType = this->dwDevType;
    pdc->dwAxes = this->dwAxes;
    pdc->dwButtons = this->dwButtons;
    pdc->dwPOVs = this->dwPOVs;

    hres = S_OK;
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetDeviceState |
 *
 *          Obtains the state of the Hid device.
 *
 *          It is the caller's responsibility to have validated all the
 *          parameters and ensure that the device has been acquired.
 *
 *  @parm   OUT LPVOID | lpvData |
 *
 *          Hid data in the preferred data format.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpmdr> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetDeviceState(PDICB pdcb, LPVOID pvData)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetDeviceState,
               (_ "pp", pdcb, pvData));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(this->pvi);
    AssertF(this->pvPhys);
    AssertF(this->cbPhys);

    if(this->pvi->fl & VIFL_ACQUIRED)
    {
        CHid_GetPhysicalState(this, pvData);
        hres = S_OK;
    } else
    {
        hres = DIERR_INPUTLOST;
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetObjectInfo |
 *
 *          Obtain the friendly name and FF/HID information
 *          of an object.
 *
 *  @parm   IN LPCDIPROPINFO | ppropi |
 *
 *          Information describing the object being accessed.
 *
 *  @parm   IN OUT LPDIDEVICEOBJECTINSTANCEW | pdidioiW |
 *
 *          Structure to receive information.  All fields have been
 *          filled in up to the <e DIDEVICEOBJECTINSTANCE.tszObjName>.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetObjectInfo(PDICB pdcb, LPCDIPROPINFO ppropi,
                       LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetObjectInfo,
               (_ "pxp", pdcb, ppropi->iobj, pdidoiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF((int) ppropi->iobj >= 0);

    if(ppropi->iobj < this->df.dwNumObjs)
    {
        UINT uiInstance = ppropi->iobj;
        PHIDGROUPCAPS pcaps;

        AssertF(ppropi->dwDevType == this->df.rgodf[uiInstance].dwType);
        AssertF(uiInstance == CHid_ObjFromType(this, ppropi->dwDevType));

        pcaps = this->rghoc[uiInstance].pcaps;

        /*
         *  pcaps might be NULL if HID messed up and left gaps
         *  in the index lists.
         */
        if(pcaps)
        {
            UINT ids, duiInstance;

            AssertF(pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE);

            /*
             *  See if there's anything in the registry that will help.
             */
            CType_RegGetObjectInfo(this->hkType, ppropi->dwDevType, pdidoiW);


            if(ppropi->dwDevType & DIDFT_COLLECTION)
            {

                ids = IDS_COLLECTIONTEMPLATE;

                duiInstance = 0;

            } else
            {
                if(ppropi->dwDevType & DIDFT_BUTTON)
                {

                    ids = IDS_BUTTONTEMPLATE;

                } else if(ppropi->dwDevType & DIDFT_AXIS)
                {

                    ids = IDS_AXISTEMPLATE;

                } else if(ppropi->dwDevType & DIDFT_POV)
                {

                    ids = IDS_POVTEMPLATE;

                } else
                {
                    ids = IDS_UNKNOWNTEMPLATE;
                }

                /*
                 *  Now convert the uiInstance to a duiInstance,
                 *  giving the index of this object into the group.
                 */
                AssertF(HidP_IsValidReportType(pcaps->type));
                duiInstance = uiInstance -
                              (this->rgdwBase[pcaps->type] +
                               pcaps->DataIndexMin);
            }

            /*
             *  Okay, now we have all the info we need to proceed.
             */

            /*
             *  If there was no overriding name in the registry, then
             *  try to get a custom name from the usage page/usage.
             *  If even that fails, then use the generic name.
             *  Note, generic names will contain zero based numbers
             *  which can look wrong if some objects have names and 
             *  others take defaults.
             */
            if(pdidoiW->tszName[0])
            {
            } else
                if(GetHIDString(pcaps->UsageMin + duiInstance,
                                pcaps->UsagePage,
                                pdidoiW->tszName, cA(pdidoiW->tszName)))
            {
                if(ppropi->dwDevType & DIDFT_COLLECTION)
                {
                    InsertCollectionNumber(DIDFT_GETINSTANCE( ppropi->dwDevType ), 
                                           pdidoiW->tszName);
                }
            } else
            {
                GetNthString(pdidoiW->tszName, ids, 
                             DIDFT_GETINSTANCE( ppropi->dwDevType ));
            }
            if(pdidoiW->dwSize >= cbX(DIDEVICEOBJECTINSTANCE_DX5W))
            {

                pdidoiW->wCollectionNumber = pcaps->LinkCollection;

                pdidoiW->wDesignatorIndex = pcaps->DesignatorMin + duiInstance;
                if(pdidoiW->wDesignatorIndex > pcaps->DesignatorMax)
                {
                    pdidoiW->wDesignatorIndex = pcaps->DesignatorMax;
                }

                /*
                 *  Much as you may try, you cannot override the usage
                 *  page and usage.  Doing so would mess up the GUID
                 *  selection code that happens in DIHIDINI.C.
                 *
                 *  If you change your mind and allow overridden usage
                 *  pages and usages, then you'll also have to change
                 *  CHid_GetUsage.
                 *
                 *  At this point, the registry overrides have already 
                 *  been read so defeat the override here.
                 */
                pdidoiW->wUsagePage = pcaps->UsagePage;
                pdidoiW->wUsage = pcaps->UsageMin + duiInstance;
                pdidoiW->dwDimension  = pcaps->Units;
                pdidoiW->wExponent  = pcaps->Exponent;
                pdidoiW->wReportId  = pcaps->wReportId;
            }

            hres = S_OK;
        } else
        {
            hres = E_INVALIDARG;
        }
    } else
    {
        hres = E_INVALIDARG;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method DWORD | CHid | GetUsage |
 *
 *          Given an object index, return the usage and usage page,
 *          packed into a single <t DWORD>.
 *
 *  @parm   int | iobj |
 *
 *          The object index to convert.
 *
 *  @returns
 *
 *          Returns a <c DIMAKEUSAGEDWORD> of the resulting usage and
 *          usage page, or zero on error.
 *
 *****************************************************************************/

STDMETHODIMP_(DWORD)
CHid_GetUsage(PDICB pdcb, int iobj)
{
    PCHID this;
    PHIDGROUPCAPS pcaps;
    DWORD dwRc;
    EnterProcI(IDirectInputDeviceCallback::Hid::GetUsage,
               (_ "pu", pdcb, iobj));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    AssertF(iobj >= 0);
    AssertF((UINT)iobj < this->df.dwNumObjs);

    pcaps = this->rghoc[iobj].pcaps;

    /*
     *  pcaps might be NULL if HID messed up and left gaps
     *  in the index lists.
     */
    if(pcaps)
    {
        UINT duiInstance;

        AssertF(pcaps->dwSignature == HIDGROUPCAPS_SIGNATURE);

        if(this->df.rgodf[iobj].dwType & DIDFT_COLLECTION)
        {

            duiInstance = 0;

        } else
        {

            /*
             *  Now convert the iobj to a duiInstance,
             *  giving the index of this object into the group.
             */
            AssertF(HidP_IsValidReportType(pcaps->type));
            duiInstance = iobj -
                          (this->rgdwBase[pcaps->type] +
                           pcaps->DataIndexMin);
        }

        /*
         *  CHid_GetObjectInfo also assumes that there is no way
         *  to override the usage page and usage values in the
         *  registry.
         */
        dwRc = DIMAKEUSAGEDWORD(pcaps->UsagePage,
                                pcaps->UsageMin + duiInstance);

    } else
    {
        dwRc = 0;
    }

    ExitProcX(dwRc);
    return dwRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | MapUsage |
 *
 *
 *          Given a usage and usage page (munged into a single
 *          <t DWORD>), find a device object that matches it.
 *
 *  @parm   DWORD | dwUsage |
 *
 *          The usage page and usage combined into a single <t DWORD>
 *          with the <f DIMAKEUSAGEDWORD> macro.
 *
 *  @parm   PINT | piOut |
 *
 *          Receives the object index of the found object, if successful.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *          <c S_OK> if an object was found.
 *
 *          <c DIERR_NOTFOUND> if no matching object was found.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_MapUsage(PDICB pdcb, DWORD dwUsage, PINT piOut)
{
    HRESULT hres;
    PCHID   this;
    UINT    icaps;
    UINT    uiObj;
    UINT    duiObj;

    EnterProcI(IDirectInputDeviceCallback::Hid::MapUsage,
               (_ "px", pdcb, dwUsage));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    for(icaps = 0; icaps < this->ccaps; icaps++)
    {
        PHIDGROUPCAPS pcaps = &this->rgcaps[icaps];

        /*
         * Shall we support mapping HidP_Output usage? 
         * If we should, it is easy to add it later.
         */
        uiObj = this->rgdwBase[HidP_Input] + pcaps->DataIndexMin;

        for(duiObj = 0; duiObj < pcaps->cObj; duiObj++)
        {
            if( dwUsage == DIMAKEUSAGEDWORD(pcaps->UsagePage, pcaps->UsageMin+duiObj) )
            {
                *piOut = uiObj+duiObj; 
                AssertF(*piOut < (INT)this->df.dwNumObjs);
                hres = S_OK;
                goto done;
            }

        }
    }
    
    hres = DIERR_NOTFOUND;

    done:;
    ExitBenignOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SetCooperativeLevel |
 *
 *          Notify the device of the cooperative level.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          The window handle.
 *
 *  @parm   IN DWORD | dwFlags |
 *
 *          The cooperativity level.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/


STDMETHODIMP
    CHid_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PCHID this;

    EnterProcI(IDirectInputDeviceCallback::Hid::SetCooperativityLevel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     *  We won't subclass Motocross Madness. See NT bug 262280.
     *  Use the app hacks for MCM and any app like it.
     */
    if( !this->diHacks.fNoSubClass )
    {

        AssertF(this->pvi);

        /*
         *  First get out of the old window.
         */
        CHid_RemoveSubclass(this);
        /*
         *  Prefix warns that "this" may have been freed (mb:34570) however 
         *  If you're in SetCooperativeLevel and you have a window subclassed 
         *  then there must be a hold for the subclassed window as well as 
         *  one for the unreleased interface so the Common_Unhold won't free 
         *  the pointer.
         */


        /*
         *  If a new window is passed, then subclass it so we can
         *  watch for joystick configuration change messages.
         *
         *  If we can't, don't worry.  All it means that we won't
         *  be able to catch when the user recalibrates a device,
         *  which isn't very often.
         */
        if(hwnd)
        {
            if(SetWindowSubclass(hwnd, CHid_SubclassProc, 0x0, (ULONG_PTR)this))
            {
                this->hwnd = hwnd;
                Common_Hold(this);
            }

        } else
        {
            RPF("SetCooperativeLevel: You really shouldn't pass hwnd = 0; "
                "device calibration may be dodgy");
        }

    }

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | RunControlPanel |
 *
 *          Run the Hid control panel.
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          The owner window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_RunControlPanel(PDICB pdcb, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::RunControlPanel,
               (_ "pxx", pdcb, hwnd, dwFlags));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    /*
     * How to invoke HID cpl?
     *
     * Currently, we just launch joy.cpl. If more HID devices show up
     * which don't belong to game control panel, we may change it to
     * proper cpl.
     *
     * on NT hresRunControlPanel(TEXT("srcmgr.cpl,@2"));
     * on 9x hresRunControlPanel(TEXT("sysdm.cpl,@0,1"));
     *
     */
    hres = hresRunControlPanel(TEXT("joy.cpl"));

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetFFConfigKey |
 *
 *          Open and return the registry key that contains
 *          force feedback configuration information.
 *
 *  @parm   DWORD | sam |
 *
 *          Security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the registry key.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::HID::GetFFConfigKey,
               (_ "px", pdcb, sam));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = JoyReg_OpenFFKey(this->hkType, sam, phk);

    AssertF(fLeqvFF(SUCCEEDED(hres), *phk));

    if(FAILED(hres) && this->fPIDdevice )
    {
        *phk = NULL;
        hres = S_FALSE;
    }

    ExitBenignOleProcPpvR(phk);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | GetDeviceInfo |
 *
 *          Obtain general information about the device.
 *
 *  @parm   OUT LPDIDEVICEINSTANCEW | pdiW |
 *
 *          <t DEVICEINSTANCE> to be filled in.  The
 *          <e DEVICEINSTANCE.dwSize> and <e DEVICEINSTANCE.guidInstance>
 *          have already been filled in.
 *
 *          Secret convenience:  <e DEVICEINSTANCE.guidProduct> is equal
 *          to <e DEVICEINSTANCE.guidInstance>.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_GetDeviceInfo(PDICB pdcb, LPDIDEVICEINSTANCEW pdiW)
{
    HRESULT hres;
    PCHID this;

    DIPROPINFO      propi;                            
    DIPROPSTRING    dips;

    EnterProcI(IDirectInputDeviceCallback::Hid::GetDeviceInfo,
               (_ "pp", pdcb, pdiW));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);
    AssertF(IsValidSizeDIDEVICEINSTANCEW(pdiW->dwSize));

    DICreateStaticGuid(&pdiW->guidProduct, this->ProductID, this->VendorID);

    pdiW->dwDevType = this->dwDevType;

    if(pdiW->dwSize >= cbX(DIDEVICEINSTANCE_DX5W))
    {
        pdiW->wUsagePage = this->caps.UsagePage;
        pdiW->wUsage     = this->caps.Usage;
    }

    propi.dwDevType = DIPH_DEVICE;
    propi.iobj      = 0xFFFFFFFF;
    propi.pguid = DIPROP_PRODUCTNAME;

    if(SUCCEEDED(hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dips.diph)) )
    {
        lstrcpyW(pdiW->tszProductName, dips.wsz);
    }

    propi.pguid = DIPROP_INSTANCENAME;
    if( FAILED(pdcb->lpVtbl->GetProperty(pdcb, &propi, &dips.diph)))
    {
        // Use Product Name
    }

    lstrcpyW(pdiW->tszInstanceName, dips.wsz); 


    if(pdiW->dwSize >= cbX(DIDEVICEINSTANCE_DX5W))
    {
        HKEY hkFF;
        HRESULT hresFF;

        /*
         *  If there is a force feedback driver, then fetch the driver CLSID
         *  as the FF GUID.
         */
        hresFF = CHid_GetFFConfigKey(pdcb, KEY_QUERY_VALUE, &hkFF);
        if(SUCCEEDED(hresFF))
        {
            LONG lRc;
            TCHAR tszClsid[ctchGuid];

            lRc = RegQueryString(hkFF, TEXT("CLSID"), tszClsid, cA(tszClsid));
            if(lRc == ERROR_SUCCESS &&
               ParseGUID(&pdiW->guidFFDriver, tszClsid))
            {
            } else
            {
                ZeroX(pdiW->guidFFDriver);
            }
            RegCloseKey(hkFF);
        }
    }


    ExitOleProcR();
    return hres;

}
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | CreateEffect |
 *
 *
 *          Create an <i IDirectInputEffectDriver> interface.
 *
 *  @parm   LPDIRECTINPUTEFFECTSHEPHERD * | ppes |
 *
 *          Receives the shepherd for the effect driver.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes)
{
    HRESULT hres;
    PCHID this;
    HKEY hk;
    EnterProcI(IDirectInputDeviceCallback::HID::CreateEffect, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    hres = CHid_GetFFConfigKey(pdcb, KEY_QUERY_VALUE, &hk);
    if(SUCCEEDED(hres))
    {
        DIHIDFFINITINFO init;
        PHIDDEVICEINFO phdi;

        hres = CEShep_New(hk, 0, &IID_IDirectInputEffectShepherd, ppes);
        if(SUCCEEDED(hres))
        {
    #ifndef UNICODE
            WCHAR wszPath[MAX_PATH];
    #endif

            init.dwSize = cbX(init);
    #ifdef UNICODE
            init.pwszDeviceInterface = this->ptszPath;
    #else
            init.pwszDeviceInterface = wszPath;
            TToU(wszPath, cA(wszPath), this->ptszPath);
    #endif

            DllEnterCrit();
            phdi = phdiFindHIDDeviceInterface(this->ptszPath);

            if( phdi )
            {
                init.GuidInstance = phdi->guid;
            } else
            {
                ZeroX(init.GuidInstance);
            }
            DllLeaveCrit();

            hres = (*ppes)->lpVtbl->DeviceID((*ppes), this->idJoy, TRUE, &init);
            if(SUCCEEDED(hres))
            {
            } else
            {
                Invoke_Release(ppes);
            }
        }
        RegCloseKey(hk);
    } else
    {
        hres = E_NOTIMPL;
        *ppes = 0;
    }

    ExitOleProcPpvR(ppes);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SendOutputReport |
 *
 *          Actually send the report as an output report.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The report being sent.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

void CALLBACK
    CHid_DummyCompletion(DWORD dwError, DWORD cbRead, LPOVERLAPPED po)
{
}

STDMETHODIMP
    CHid_SendOutputReport(PCHID this, PHIDREPORTINFO phri)
{
    HRESULT hres;
    OVERLAPPED o;

    AssertF(phri == &this->hriOut);
    ZeroX(o);

    /*
     *  Annoying API:  Since this->hdev was opened
     *  as FILE_FLAG_OVERLAPPED, *all* I/O must be overlapped.
     *  So we simulate a synchronous I/O by issuing an
     *  overlapped I/O and waiting for the completion.
     */

    if(WriteFileEx(this->hdev, phri->pvReport,
                   phri->cbReport, &o, CHid_DummyCompletion))
    {
        do
        {
            SleepEx(INFINITE, TRUE);
        } while(!HasOverlappedIoCompleted(&o));

        if(phri->cbReport == o.InternalHigh)
        {
            hres = S_OK;
        } else
        {
            RPF("SendDeviceData: Wrong HID output report size?");
            hres = E_FAIL;      /* Aigh!  HID lied to me! */
        }
    } else
    {
        hres = hresLe(GetLastError());

        /* 
         *  Note, we have not broken the read loop so there is no need to 
         *  force the device unaquired (though dinput.dll does).
         *
         *  If this causes problems revert to the old behavior.
         *  CEm_ForceDeviceUnacquire(pemFromPvi(this->pvi)->ped, 0x0);
         */
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SendFeatureReport |
 *
 *          Actually send the report as an feature report.
 *
 *  @parm   PHIDREPORTINFO | phri |
 *
 *          The report being sent.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_SendFeatureReport(PCHID this, PHIDREPORTINFO phri)
{
    HRESULT hres;

    AssertF(phri == &this->hriFea);

    if(HidD_SetFeature(this->hdev, phri->pvReport, phri->cbReport))
    {
        hres = S_OK;
    } else
    {
        RPF("SendDeviceData: Unable to set HID feature");
        hres = hresLe(GetLastError());
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SendDeviceData |
 *
 *          Spew some data to the device.
 *
 *  @parm   DWORD | cbdod |
 *
 *          Size of each object.
 *
 *  @parm   IN LPCDIDEVICEOBJECTDATA | rgdod |
 *
 *          Array of <t DIDEVICEOBJECTDATA> structures.
 *
 *  @parm   INOUT LPDWORD | pdwInOut |
 *
 *          On entry, number of items to send;
 *          on exit, number of items actually sent.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_REPORTFULL>: Too many items are set in the report.
 *                                (More than can be sent to the device)
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_SendDeviceData(PDICB pdcb, DWORD cbdod, LPCDIDEVICEOBJECTDATA rgdod,
                        LPDWORD pdwInOut, DWORD fl)
{
    HRESULT hres;
    PCHID this;
    DWORD dwIn, dw;
    const BYTE * pbcod;
    EnterProcI(IDirectInputDeviceCallback::Hid::SendDeviceData,
               (_ "xpux", cbdod, pdcb, *pdwInOut, fl));


    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    dwIn = *pdwInOut;
    *pdwInOut = 0;

    if(fl & DISDD_CONTINUE)
    {
    } else
    {
        CHid_ResetDeviceData(this, &this->hriOut, HidP_Output);
        CHid_ResetDeviceData(this, &this->hriFea, HidP_Feature);
    }

    for(dw = 0, pbcod = (const BYTE*)rgdod; dw < dwIn; dw++)
    {
        DWORD dwType = ((LPDIDEVICEOBJECTDATA)pbcod)->dwOfs;
        UINT uiObj = CHid_ObjFromType(this, dwType);

        if(uiObj < this->df.dwNumObjs &&
           DIDFT_FINDMATCH(this->df.rgodf[uiObj].dwType, dwType))
        {
            hres = CHid_AddDeviceData(this, uiObj, ((LPDIDEVICEOBJECTDATA)pbcod)->dwData);
            if(FAILED(hres))
            {
                *pdwInOut = dw;
                goto done;
            }
        } else
        {
            hres = E_INVALIDARG;
            goto done;
        }
        pbcod += cbdod;
    }

    /*
     *  All the items made it into the buffer.
     */
    *pdwInOut = dw;

    /*
     *  Now send it all out.
     */
    if(SUCCEEDED(hres = CHid_SendHIDReport(this, &this->hriOut, HidP_Output,
                                           CHid_SendOutputReport)) &&
       SUCCEEDED(hres = CHid_SendHIDReport(this, &this->hriFea, HidP_Feature,
                                           CHid_SendFeatureReport)))
    {
    }

    done:;
    ExitOleProcR();
    return hres;
}
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | Poll |
 *
 *          Read any polled input and features to see what's there.
 *
 *  @returns
 *
 *          <c S_OK> if we pinged okay.
 *          <c S_FALSE> doesn't require polling
 *          <c DIERR_UNPLUGGED> the device requires polling and is unplugged
 *          Other errors returned from HID are possible for a polled device.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_Poll(PDICB pdcb)
{
    //Prefix: 45082
    HRESULT hres = S_FALSE;  //We need use S_FALSE as default. See manbug 31874.
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::Poll, (_ "p", pdcb));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    if( this->IsPolledInput )
    {
        hres = DIERR_UNPLUGGED;
        if(ReadFileEx(this->hdev, this->hriIn.pvReport,
                      this->hriIn.cbReport, &this->o, CHid_DummyCompletion))
        {
            do
            {
                SleepEx( INFINITE, TRUE);
            } while(!HasOverlappedIoCompleted(&this->o));

            if(this->hriIn.cbReport == this->o.InternalHigh)
            {
                NTSTATUS stat;

                CopyMemory(this->pvStage, this->pvPhys, this->cbPhys);

                stat = CHid_ParseData(this, HidP_Input, &this->hriIn);

                if(SUCCEEDED(stat))
                {
                    CEm_AddState(&this->ed, this->pvStage, GetTickCount());                
                    this->pvi->fl &=  ~VIFL_UNPLUGGED;
                    hres = S_OK;
                } else
                {
                    RPF( "CHid_ParseData failed in Poll, status = 0x%08x", stat );
                    hres = stat;
                }
            }
        }

        if( FAILED(hres) )
        {
            /* 
             *  Note, we have not broken the read loop so there is no need to 
             *  force the device unaquired (though dinput.dll does).
             *
             *  If this causes problems revert to the old behavior.
             *  CEm_ForceDeviceUnacquire(pemFromPvi(this->pvi)->ped, 0x0);
             */
            hres = DIERR_UNPLUGGED;
            this->pvi->fl |= VIFL_UNPLUGGED;        
        }
    }


    if( this->hriFea.cbReport )
    {
        UINT uReport;
        /*
         *  We should never get here unless there really are any
         *  features that need to be polled.
         */
        AssertF(this->hriFea.cbReport);
        AssertF(this->hriFea.pvReport);

        /*
         *  Read the new features and parse/process them.
         *
         *  Notice that we read the features into the same buffer
         *  that we log them into.  That's okay; the "live" parts
         *  of the two buffers never actually overlap.
         */
        for( uReport = 0x0; uReport < this->wMaxReportId[HidP_Feature]; uReport++ )
        {
            if( *(this->pEnableReportId[HidP_Feature] + uReport ) == TRUE )
            {
                *((UCHAR*)(this->hriFea.pvReport)) = (UCHAR)uReport;

                /*
                 *  Wipe out all the old goo because we're taking over.
                 */
                CHid_ResetDeviceData(this, &this->hriFea, HidP_Feature);

                if(HidD_GetFeature(this->hdev, this->hriFea.pvReport,
                                   this->hriFea.cbReport))
                {
                    NTSTATUS stat;

                    stat = CHid_ParseData(this, HidP_Feature, &this->hriFea);

                    AssertF(SUCCEEDED(stat));
                    if(SUCCEEDED(stat))
                    {
                        CEm_AddState(&this->ed, this->pvStage, GetTickCount());                
                    }

                    hres = stat;

                } else
                {
                    RPF("CHid_Poll: Unable to read HID features (ReportID%d) LastError(0x%x)", uReport, GetLastError() );
                    hres = hresLe(GetLastError());

                }
            }
        }
    }

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *      CHid_New       (constructor)
 *
 *      Fail the create if we can't open the device.
 *
 *****************************************************************************/

STDMETHODIMP
    CHid_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputDeviceCallback::Hid::<constructor>,
               (_ "Gp", riid, ppvObj));

    hres = Common_NewRiid(CHid, punkOuter, riid, ppvObj);

    if(SUCCEEDED(hres))
    {
        /* Must use _thisPv in case of aggregation */
        PCHID this = _thisPv(*ppvObj);

        if(SUCCEEDED(hres = CHid_Init(this, rguid)))
        {
        } else
        {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | SetDIData |
 *
 *          Set DirectInput version and apphack data from CDIDev *.
 *
 *  @parm   DWORD | dwVer |
 *
 *          DirectInput version
 *
 *  @parm   LPVOID | lpdihacks |
 *
 *          AppHack data
 *
 *  @returns
 *
 *          <c E_NOTIMPL> because we don't support usages.
 *
 *****************************************************************************/

STDMETHODIMP
CHid_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks)
{
    HRESULT hres;
    PCHID this;
    EnterProcI(IDirectInputDeviceCallback::Hid::SetDIData,
               (_ "pup", pdcb, dwVer, lpdihacks));

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    this = _thisPvNm(pdcb, dcb);

    this->dwVersion = dwVer;
    CopyMemory(&this->diHacks, (LPDIAPPHACKS)lpdihacks, sizeof(this->diHacks));

    hres = S_OK;

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CHid | BuildDefaultActionMap |
 *
 *          Generate default mappings for the objects on this device.
 *
 *  @parm   LPDIACTIONFORMATW | pActionFormat |
 *
 *          Actions to map.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags used to indicate mapping preferences.
 *
 *  @parm   REFGUID | guidInst | 
 *
 *          Device instance GUID.
 *
 *  @returns
 *
 *          <c E_NOTIMPL> 
 *
 *****************************************************************************/

STDMETHODIMP
CHid_BuildDefaultActionMap
(
    PDICB               pdcb, 
    LPDIACTIONFORMATW   paf, 
    DWORD               dwFlags, 
    REFGUID             guidInst
)
{
    HRESULT hres;
    PCHID   this;
    DWORD   dwPhysicalGenre;

    /*
     *  This is an internal interface, so we can skimp on validation.
     */
    EnterProcI(IDirectInputDeviceCallback::Hid::BuildDefaultActionMap, 
        (_ "ppxG", pdcb, paf, dwFlags, guidInst));

    this = _thisPvNm(pdcb, dcb);

    switch( GET_DIDEVICE_TYPE( this->dwDevType ) )
    {
    case DI8DEVTYPE_DEVICE:
        hres = S_FALSE;
        goto ExitBuildDefaultActionMap;
    case DI8DEVTYPE_MOUSE:
        dwPhysicalGenre = DIPHYSICAL_MOUSE;
        break;
    case DI8DEVTYPE_KEYBOARD:
        dwPhysicalGenre = DIPHYSICAL_KEYBOARD;
        break;
    default:
        dwPhysicalGenre = 0;
        break;
    }

    if( dwPhysicalGenre  )
    {
        hres = CMap_BuildDefaultSysActionMap( paf, dwFlags, dwPhysicalGenre, 
            guidInst, &this->df, 0 /* HID mice buttons start at instance zero */ );
    }
    else
    {
        PDIDOBJDEFSEM       rgObjSem;

        if( SUCCEEDED( hres = AllocCbPpv(cbCxX( 
            (this->dwAxes + this->dwPOVs + this->dwButtons ), DIDOBJDEFSEM),
            &rgObjSem) ) )
        {
            PDIDOBJDEFSEM   pAxis;
            PDIDOBJDEFSEM   pPOV;
            PDIDOBJDEFSEM   pButton;
            BYTE            rgbIndex[DISEM_FLAGS_GET(DISEM_FLAGS_S)];
            UINT            ObjIdx;
            
            pAxis = rgObjSem;
            pPOV = &pAxis[this->dwAxes];
            pButton = &pPOV[this->dwPOVs];
            ZeroMemory( rgbIndex, cbX(rgbIndex) );

            for( ObjIdx = 0; ObjIdx < this->df.dwNumObjs; ObjIdx++ )
            {
                if( this->df.rgodf[ObjIdx].dwType & DIDFT_NODATA )
                {
                    continue;
                }

                if( this->df.rgodf[ObjIdx].dwType & DIDFT_AXIS ) 
                {
                    PHIDGROUPCAPS   pcaps;

                    pcaps = this->rghoc[ObjIdx].pcaps;
                    
                    pAxis->dwID = this->df.rgodf[ObjIdx].dwType;
                    if( this->rgbaxissemflags[DIDFT_GETINSTANCE( pAxis->dwID )] )
                    {
                        pAxis->dwSemantic = DISEM_TYPE_AXIS | DISEM_FLAGS_SET ( this->rgbaxissemflags[DIDFT_GETINSTANCE( pAxis->dwID )] );

                        /*
                         *  The index is zero so that a real index can be ORed in.
                         *  Also, assert that the rgbIndex is big enough and 
                         *  that subtracting 1 won't give a negative index!
                         */
                        AssertF( DISEM_INDEX_GET(pAxis->dwSemantic) == 0 );
                        AssertF( DISEM_FLAGS_GET(pAxis->dwSemantic) > 0 );
                        AssertF( DISEM_FLAGS_GET(pAxis->dwSemantic) <= DISEM_FLAGS_GET(DISEM_FLAGS_S) );
                    
                        CAssertF( DISEM_FLAGS_GET(DISEM_FLAGS_X) == 1 );
                        pAxis->dwSemantic |= DISEM_INDEX_SET( rgbIndex[DISEM_FLAGS_GET(pAxis->dwSemantic)-1]++ );
                    }
                    else
                    {
                        /*
                         *  If the axis has no semantic flags, it is 
                         *  unrecognized so short cut the above to produce 
                         *  a plain axis that can be matched only with "ANY".
                         */
                        pAxis->dwSemantic = DISEM_TYPE_AXIS;
                    }

                    if( !pcaps->IsAbsolute )
                    {
                        pAxis->dwSemantic |= DIAXIS_RELATIVE;
                    }

                    pAxis++;
                }
                else if( this->df.rgodf[ObjIdx].dwType & DIDFT_POV ) 
                {
                    pPOV->dwID = this->df.rgodf[ObjIdx].dwType;
                    pPOV->dwSemantic = DISEM_TYPE_POV;
                    pPOV++;
                }
                else if( this->df.rgodf[ObjIdx].dwType & DIDFT_BUTTON ) 
                {
                    pButton->dwID = this->df.rgodf[ObjIdx].dwType;
                    pButton->dwSemantic = DISEM_TYPE_BUTTON;
                    pButton++;
                }
            }

            AssertF( pAxis == &rgObjSem[this->dwAxes] );
            AssertF( pPOV == &rgObjSem[this->dwAxes + this->dwPOVs] );
            AssertF( pButton == &rgObjSem[this->dwAxes + this->dwPOVs + this->dwButtons] );

            hres = CMap_BuildDefaultDevActionMap( paf, dwFlags, guidInst, rgObjSem, 
                this->dwAxes, this->dwPOVs, this->dwButtons );

            FreePv( rgObjSem );
        }
    }

ExitBuildDefaultActionMap:;

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

    #pragma BEGIN_CONST_DATA

    #define CHid_Signature          0x20444948      /* "HID " */

Primary_Interface_Begin(CHid, IDirectInputDeviceCallback)
CHid_GetInstance,
CDefDcb_GetVersions,
CHid_GetDataFormat,
CHid_GetObjectInfo,
CHid_GetCapabilities,
CHid_Acquire,
CHid_Unacquire,
CHid_GetDeviceState,
CHid_GetDeviceInfo,
CHid_GetProperty,
CHid_SetProperty,
CDefDcb_SetEventNotification,
    #ifdef WINNT
    CHid_SetCooperativeLevel,
    #else
    CDefDcb_SetCooperativeLevel,
    #endif
CHid_RunControlPanel,
CDefDcb_CookDeviceData,
CHid_CreateEffect,
CHid_GetFFConfigKey,
CHid_SendDeviceData,
CHid_Poll,
CHid_GetUsage,
CHid_MapUsage,
CHid_SetDIData,
CHid_BuildDefaultActionMap,
Primary_Interface_End(CHid, IDirectInputDeviceCallback)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dijoyreg.h ===
/*****************************************************************************
 *
 *  DIJoyReg.h
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Registry-related snippets from the Windows 95 mmddk.h file.
 *      We must steal it because the Windows NT mmddk.h file does not
 *      contain the registry settings.  (Sigh.)
 *
 *****************************************************************************/

#include <regstr.h>

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_TWO_2A_2B_WITH_Y         12
#define JOY_HW_LASTENTRY                13

/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;      /* value at which to timeout joystick polling */
    JOYRANGE    jrvRanges;      /* range of values app wants returned for axes */
    JOYPOS      jpDeadZone;     /* area around center to be considered
                                   as "dead". specified as a percentage
                                   (0-100). Only X & Y handled by system driver */
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;           /* number of buttons */
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;            /* values returned by hardware */
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];/* POV values returned by hardware */
    DWORD       dwCalFlags;             /* what has been calibrated */
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;            /* hardware settings */
    DWORD               dwUsageSettings;/* usage settings */
    JOYREGHWVALUES      hwv;            /* values returned by hardware */
    DWORD               dwType;         /* type of joystick */
    DWORD               dwReserved;     /* reserved for OEM drivers */
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

/* joystick calibration info structure */
typedef struct joycalibrate_tag {
    UINT    wXbase;
    UINT    wXdelta;
    UINT    wYbase;
    UINT    wYdelta;
    UINT    wZbase;
    UINT    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dihidusg.c ===
/*****************************************************************************
 *
 *  DIHidUsg.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Mapping between GUIDs and HID usages.
 *
 *  Contents:
 *
 *      UsageToGuid
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflHidUsage

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global HIDUSAGEMAP | c_rghum[] |
 *
 *          Mapping between GUIDs and HID usages for one-to-one mappings.
 *
 *****************************************************************************/

#ifndef DISEM_FLAGS_0
#define DISEM_FLAGS_0 0
#endif

#define MAKEHUM(Page, Usage, PosAxis, SemFlag, Guid)        \
    {   DIMAKEUSAGEDWORD(HID_USAGE_PAGE_##Page,             \
                         HID_USAGE_##Page##_##Usage),       \
        PosAxis,                                            \
        DISEM_FLAGS_GET(DISEM_FLAGS_##SemFlag),             \
        0,0,                                                \
        DISEM_HINT_##Usage,                                 \
        &Guid,                                              \
    }                                                       \


HIDUSAGEMAP c_rghum[] = {
    MAKEHUM(GENERIC,    X,          0,  X,  GUID_XAxis),
    MAKEHUM(GENERIC,    Y,          1,  Y,  GUID_YAxis),
    MAKEHUM(GENERIC,    Z,          2,  Z,  GUID_ZAxis),
    MAKEHUM(GENERIC,    WHEEL,      2,  Z,  GUID_ZAxis),
    MAKEHUM(GENERIC,    RX,         3,  V,  GUID_RxAxis),
    MAKEHUM(GENERIC,    RY,         4,  U,  GUID_RyAxis),
    MAKEHUM(GENERIC,    RZ,         5,  R,  GUID_RzAxis),
    MAKEHUM(GENERIC,    HATSWITCH,  7,  0,  GUID_POV),

    MAKEHUM(GENERIC,    SLIDER,     6,  S,  GUID_Slider),
    MAKEHUM(GENERIC,    DIAL,       6,  S,  GUID_Slider),

    MAKEHUM(SIMULATION, STEERING,   0,  X,  GUID_XAxis),
    MAKEHUM(SIMULATION, ACCELERATOR,1,  A,  GUID_YAxis),
    MAKEHUM(SIMULATION, BRAKE,      5,  B,  GUID_RzAxis),
    MAKEHUM(SIMULATION, RUDDER,     5,  R,  GUID_RzAxis),
    MAKEHUM(SIMULATION, THROTTLE,   6,  A,  GUID_Slider),
    MAKEHUM(GAME,       POV,        7,  0,  GUID_POV),
};

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   PCGUID | UsageToUsageMap |
 *
 *          Takes some HID usage and usage page information and
 *          returns a pointer to a <t HIDUSAGEMAP> that describes
 *          how we should treat it.
 *
 *          If the type is not recognized, then <c NULL> is returned.
 *
 *  @parm   DWORD | dwUsage |
 *
 *          Usage page and usage to convert.  This should be a <t DWORD>
 *          formed using DIMAKEUSAGEDWORD on the component <t USAGE> values.
 *
 *****************************************************************************/

PHIDUSAGEMAP EXTERNAL
UsageToUsageMap(DWORD dwUsage)
{
    PHIDUSAGEMAP phum;
    int   ihum;

    for (ihum = 0; ihum < cA(c_rghum); ihum++) {
        if (c_rghum[ihum].dwUsage == dwUsage) {
            phum = &c_rghum[ihum];
            goto done;
        }
    }

    phum = 0;

done:;
    if( phum )
    {
        SquirtSqflPtszV(sqflHidUsage | sqflVerbose,
                        TEXT("UsageToUsageMap: mapped 0x%04x:0x%04x to index %d"),
                            HIWORD( dwUsage ), LOWORD( dwUsage ), ihum );
    }
    else
    {
        SquirtSqflPtszV(sqflHidUsage | sqflVerbose,
                        TEXT("UsageToUsageMap: failed to map 0x%04x:0x%04x"),
                            HIWORD( dwUsage ), LOWORD( dwUsage ) );
    }

    return phum;
}


#if 0
// After we fixed Windows bug 357943, this function is no longer needed.
// But keep here for sometime just in case...
//
/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   DWORD | GuidToUsage |
 *
 *          Map Guid to Usage
 *
 *          If the guid is not recognized, then 0 is returned.
 *
 *  @parm   PCGUID | pguid |
 *
 *          guid to map
 *
 *****************************************************************************/

DWORD EXTERNAL
GuidToUsage(PCGUID pguid)
{
    DWORD dwUsage;
    int   ihum;

    for (ihum = 0; ihum < cA(c_rghum); ihum++) {
        if ( IsEqualGUID( c_rghum[ihum].pguid, pguid ) ) {
            dwUsage = c_rghum[ihum].dwUsage;
            goto done;
        }
    }

    dwUsage = 0;

done:;
    return dwUsage;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | GetHIDString |
 *
 *          Given a HID usage page and usage, obtain a generic string
 *          that describes it if we recognize it.
 *
 *  @parm   DWORD | Usage |
 *
 *          Usage number to convert.  This is a <t DWORD> instead of
 *          a <t USAGE> because you aren't supposed to pass short types
 *          as parameters to functions.
 *
 *  @parm   DWORD | UsagePage |
 *
 *          Usage page to convert.
 *
 *  @parm   LPWSTR | pwszBuf |
 *
 *          Buffer to receive string.
 *
 *  @parm   UINT | cwch |
 *
 *          Size of buffer.
 *
 *  @returns
 *
 *          Returns the number of characters retrieved, or zero
 *          if no string was obtained.
 *
 *****************************************************************************/

/*
 *  Maps usage pages to string groups.  Each string group is 512 strings long.
 *  Zero means "No string group".
 */
UINT c_mpuiusagePage[] = {
    0,                          /* Invalid */
    IDS_PAGE_GENERIC,           /* HID_USAGE_PAGE_GENERIC   */
    IDS_PAGE_VEHICLE,           /* HID_USAGE_PAGE_SIMULATION */
    IDS_PAGE_VR,                /* HID_USAGE_PAGE_VR        */
    IDS_PAGE_SPORT,             /* HID_USAGE_PAGE_SPORT     */
    IDS_PAGE_GAME,              /* HID_USAGE_PAGE_GAME      */
    0,                          /* ???????????????????????  */
    IDS_PAGE_KEYBOARD,          /* HID_USAGE_PAGE_KEYBOARD  */
    IDS_PAGE_LED,               /* HID_USAGE_PAGE_LED       */
    0,                          /* HID_USAGE_PAGE_BUTTON    */
    0,                          /* HID_USAGE_PAGE_ORDINAL   */
    IDS_PAGE_TELEPHONY,         /* HID_USAGE_PAGE_TELEPHONY */
    IDS_PAGE_CONSUMER,          /* HID_USAGE_PAGE_CONSUMER  */
    IDS_PAGE_DIGITIZER,         /* HID_USAGE_PAGE_DIGITIZER */
    0,                          /* ???????????????????????  */
    IDS_PAGE_PID,               /* HID_USAGE_PAGE_PID       */
};

UINT EXTERNAL
GetHIDString(DWORD Usage, DWORD UsagePage, LPWSTR pwszBuf, UINT cwch)
{
    UINT uiRc;

    if (UsagePage < cA(c_mpuiusagePage) &&
        c_mpuiusagePage[UsagePage] &&
        Usage < 512) {
        uiRc = LoadStringW(g_hinst, c_mpuiusagePage[UsagePage] + Usage,
                           pwszBuf, cwch);

         SquirtSqflPtszV(sqflHidUsage | sqflBenign,
                        TEXT("[%s]\nName=%s\n Usage=%d \n UsagePage=%d"),
                            pwszBuf, pwszBuf, Usage, UsagePage );

    } else {
        uiRc = 0;
    }
    return uiRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | InsertCollectionNumber |
 *
 *          Prefix the collection number on the existing string.
 *
 *  @parm   UINT | icoll |
 *
 *          Collection number to be prefixed.
 *
 *          (Actually, it's placed wherever the string resource
 *          tells us, to allow for localization.)
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          Output buffer assumed to be of size MAX_PATH.
 *
 *****************************************************************************/

void EXTERNAL
InsertCollectionNumber(UINT icoll, LPWSTR pwszBuf)
{
    TCHAR tsz[MAX_PATH];
    TCHAR tszFormat[64];
#ifndef UNICODE
    TCHAR tszOut[MAX_PATH];
#endif
    int ctch;

    ctch = LoadString(g_hinst, IDS_COLLECTIONTEMPLATEFORMAT,
                      tszFormat, cA(tszFormat));

    /*
     *  Make sure the combined format and collection name
     *  don't overflow the buffer.  The maximum length of
     *  the stringification of icoll is 65534 because we
     *  allow only 16 bits worth of DIDFT_INSTANCEMASK.
     *
     *  We also have to put it into a holding buffer because
     *  pwszBuf is about to be smashed by the upcoming wsprintf.
     */
    UToT(tsz, cA(tsz) - ctch, pwszBuf);

#ifdef UNICODE
    wsprintfW(pwszBuf, tszFormat, icoll, tsz);
#else
    wsprintfA(tszOut, tszFormat, icoll, tsz);
    TToU(pwszBuf, MAX_PATH, tszOut);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dilib1.c ===
/*****************************************************************************
 *
 *  DILib1.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIMouse
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIMouse[] |
 *
 *          Device object data formats for mouse-style access.
 *
 *  @global DIDEVICEFORMAT | c_dfDIMouse |
 *
 *          Device format for mouse-style access.
 *
 *          A pointer to this structure may be passed to
 *          <mf IDirectInputDevice::SetDataFormat> to indicate that
 *          the device will be accessed in the form of a mouse.
 *
 *          When a device has been set to the mouse data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          returns a <t DIMOUSESTATE> structure, and the
 *          <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIMOFS_*> value which describes the
 *          object whose data is being reported.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

static DIOBJECTDATAFORMAT c_rgodfDIMouse[] = {
    { &GUID_XAxis, FIELD_OFFSET(DIMOUSESTATE,        lX),       DIDFT_AXIS | DIDFT_ANYINSTANCE, },
    { &GUID_YAxis, FIELD_OFFSET(DIMOUSESTATE,        lY),       DIDFT_AXIS | DIDFT_ANYINSTANCE, },
    { &GUID_ZAxis, FIELD_OFFSET(DIMOUSESTATE,        lZ),       DIDFT_AXIS | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE, rgbButtons[0]), DIDFT_BUTTON | DIDFT_ANYINSTANCE, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE, rgbButtons[1]), DIDFT_BUTTON | DIDFT_ANYINSTANCE, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE, rgbButtons[2]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE, rgbButtons[3]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
};

const DIDATAFORMAT c_dfDIMouse = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_RELAXIS,
    sizeof(DIMOUSESTATE),
    cA(c_rgodfDIMouse),
    c_rgodfDIMouse,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dilib2.c ===
/*****************************************************************************
 *
 *  DILib1.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIKeyboard
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIKbd[] |
 *
 *          Device object data formats for keyboard-style access.
 *
 *  @doc    EXTERNAL
 *
 *  @global DIDATAFORMAT | c_dfDIKeyboard |
 *
 *          A predefined <t DIDATAFORMAT> structure which describes a
 *          keyboard device.  This object is provided in the
 *          DINPUT.LIB library file as a convenience.
 *
 *          A pointer to this structure may be passed to
 *          <mf IDirectInputDevice::SetDataFormat> to indicate that
 *          the device will be accessed in the form of a keyboard.
 *
 *          When a device has been set to the keyboard data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          behaves in the same way as the Windows <f GetKeyboardState>
 *          function:  The device state is stored in an array of
 *          256 bytes, with each byte corresponding to the state
 *          of a key.  For example, if high bit of the <c DIK_ENTER>'th
 *          byte is set, then the Enter key is being held down.
 *
 *          When a device has been set to the keyboard data format,
 *          the <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIK_*> value which describes the
 *          key which was pressed or released.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKEODF(b)                                                      \
    { &GUID_Key, b,                                                     \
      DIDFT_BUTTON | DIDFT_MAKEINSTANCE(b) | 0x80000000, }              \

#define MAKEODF16(b) \
    MAKEODF(b+0x00), \
    MAKEODF(b+0x01), \
    MAKEODF(b+0x02), \
    MAKEODF(b+0x03), \
    MAKEODF(b+0x04), \
    MAKEODF(b+0x05), \
    MAKEODF(b+0x06), \
    MAKEODF(b+0x07), \
    MAKEODF(b+0x08), \
    MAKEODF(b+0x09), \
    MAKEODF(b+0x0A), \
    MAKEODF(b+0x0B), \
    MAKEODF(b+0x0C), \
    MAKEODF(b+0x0D), \
    MAKEODF(b+0x0E), \
    MAKEODF(b+0x0F)  \

static DIOBJECTDATAFORMAT c_rgodfDIKeyboard[] = {
    MAKEODF16(0x00),
    MAKEODF16(0x10),
    MAKEODF16(0x20),
    MAKEODF16(0x30),
    MAKEODF16(0x40),
    MAKEODF16(0x50),
    MAKEODF16(0x60),
    MAKEODF16(0x70),
    MAKEODF16(0x80),
    MAKEODF16(0x90),
    MAKEODF16(0xA0),
    MAKEODF16(0xB0),
    MAKEODF16(0xC0),
    MAKEODF16(0xD0),
    MAKEODF16(0xE0),
    MAKEODF16(0xF0),
};


const DIDATAFORMAT c_dfDIKeyboard = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_RELAXIS,
    256,
    cA(c_rgodfDIKeyboard),
    c_rgodfDIKeyboard,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dilib3.c ===
/*****************************************************************************
 *
 *  DILib3.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIJoystick
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIJoy[] |
 *
 *          Device object data formats for joystick-style access.
 *
 *  @doc    EXTERNAL
 *
 *  @global DIDEVICEFORMAT | c_dfDIJoystick |
 *
 *          Predefined device format for joystick-style access.
 *
 *          When a device has been set to the joystick data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          returns a <t DIJOYSTATE> structure, and the
 *          <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIJOFS_*> value which describes the
 *          object whose data is being reported.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKEVAL(guid, f, type, aspect)                                  \
    { &GUID_##guid,                                                     \
      FIELD_OFFSET(DIJOYSTATE, f),                                      \
      DIDFT_##type | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      DIDOI_ASPECT##aspect,                                             \
    }                                                                   \

#define MAKEBTN(n)                                                      \
    { 0,                                                                \
      FIELD_OFFSET(DIJOYSTATE, rgbButtons[n]),                          \
      DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      DIDOI_ASPECTUNKNOWN,                                              \
    }                                                                   \

static DIOBJECTDATAFORMAT c_rgodfDIJoy[] = {
    MAKEVAL( XAxis,  lX,         AXIS, POSITION),
    MAKEVAL( YAxis,  lY,         AXIS, POSITION),
    MAKEVAL( ZAxis,  lZ,         AXIS, POSITION),
    MAKEVAL(RxAxis,  lRx,        AXIS, POSITION),
    MAKEVAL(RyAxis,  lRy,        AXIS, POSITION),
    MAKEVAL(RzAxis,  lRz,        AXIS, POSITION),
    MAKEVAL(Slider,rglSlider[0], AXIS, POSITION),
    MAKEVAL(Slider,rglSlider[1], AXIS, POSITION),
    MAKEVAL(POV,     rgdwPOV[0], POV,  UNKNOWN),
    MAKEVAL(POV,     rgdwPOV[1], POV,  UNKNOWN),
    MAKEVAL(POV,     rgdwPOV[2], POV,  UNKNOWN),
    MAKEVAL(POV,     rgdwPOV[3], POV,  UNKNOWN),
    MAKEBTN( 0),
    MAKEBTN( 1),
    MAKEBTN( 2),
    MAKEBTN( 3),
    MAKEBTN( 4),
    MAKEBTN( 5),
    MAKEBTN( 6),
    MAKEBTN( 7),
    MAKEBTN( 8),
    MAKEBTN( 9),
    MAKEBTN(10),
    MAKEBTN(11),
    MAKEBTN(12),
    MAKEBTN(13),
    MAKEBTN(14),
    MAKEBTN(15),
    MAKEBTN(16),
    MAKEBTN(17),
    MAKEBTN(18),
    MAKEBTN(19),
    MAKEBTN(20),
    MAKEBTN(21),
    MAKEBTN(22),
    MAKEBTN(23),
    MAKEBTN(24),
    MAKEBTN(25),
    MAKEBTN(26),
    MAKEBTN(27),
    MAKEBTN(28),
    MAKEBTN(29),
    MAKEBTN(30),
    MAKEBTN(31),
};

const DIDATAFORMAT c_dfDIJoystick = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_ABSAXIS,
    sizeof(DIJOYSTATE),
    cA(c_rgodfDIJoy),
    c_rgodfDIJoy,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dilib4.c ===
/*****************************************************************************
 *
 *  DILib4.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIJoystick2
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIJoy2[] |
 *
 *          Device object data formats for joystick-style access.
 *
 *  @doc    EXTERNAL
 *
 *  @global DIDEVICEFORMAT | c_dfDIJoystick2 |
 *
 *          Predefined device format for extended joystick-style access.
 *
 *          When a device has been set to the joystick data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          returns a <t DIJOYSTATE2> structure, and the
 *          <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIJOFS_*> value which describes the
 *          object whose data is being reported.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKEVAL(guid, f, type, aspect)                                  \
    { &GUID_##guid,                                                     \
      FIELD_OFFSET(DIJOYSTATE2, f),                                     \
      DIDFT_##type | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      DIDOI_ASPECT##aspect,                                             \
    }                                                                   \

#define MAKEVALS(l, aspect)                                             \
    MAKEVAL( XAxis,l##X,           AXIS, aspect),                       \
    MAKEVAL( YAxis,l##Y,           AXIS, aspect),                       \
    MAKEVAL( ZAxis,l##Z,           AXIS, aspect),                       \
    MAKEVAL(RxAxis,l##Rx,          AXIS, aspect),                       \
    MAKEVAL(RyAxis,l##Ry,          AXIS, aspect),                       \
    MAKEVAL(RzAxis,l##Rz,          AXIS, aspect),                       \
    MAKEVAL(Slider,rgl##Slider[0], AXIS, aspect),                       \
    MAKEVAL(Slider,rgl##Slider[1], AXIS, aspect)                        \

#define MAKEPOV(n)                                                      \
    MAKEVAL(POV,     rgdwPOV[n], POV,  UNKNOWN)                         \

#define MAKEBTN(n)                                                      \
    { 0,                                                                \
      FIELD_OFFSET(DIJOYSTATE2, rgbButtons[n]),                         \
      DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL,                \
      DIDOI_ASPECTUNKNOWN,                                              \
    }                                                                   \

#define MAKEBTNS(n)                                                     \
    MAKEBTN(n + 0x00),                                                  \
    MAKEBTN(n + 0x01),                                                  \
    MAKEBTN(n + 0x02),                                                  \
    MAKEBTN(n + 0x03),                                                  \
    MAKEBTN(n + 0x04),                                                  \
    MAKEBTN(n + 0x05),                                                  \
    MAKEBTN(n + 0x06),                                                  \
    MAKEBTN(n + 0x07),                                                  \
    MAKEBTN(n + 0x08),                                                  \
    MAKEBTN(n + 0x09),                                                  \
    MAKEBTN(n + 0x0A),                                                  \
    MAKEBTN(n + 0x0B),                                                  \
    MAKEBTN(n + 0x0C),                                                  \
    MAKEBTN(n + 0x0D),                                                  \
    MAKEBTN(n + 0x0E),                                                  \
    MAKEBTN(n + 0x0F)                                                   \

static DIOBJECTDATAFORMAT c_rgodfDIJoy2[] = {
    MAKEVALS(l, POSITION),
    MAKEPOV(0),
    MAKEPOV(1),
    MAKEPOV(2),
    MAKEPOV(3),
    MAKEBTNS(0x00),
    MAKEBTNS(0x10),
    MAKEBTNS(0x20),
    MAKEBTNS(0x30),
    MAKEBTNS(0x40),
    MAKEBTNS(0x50),
    MAKEBTNS(0x60),
    MAKEBTNS(0x70),
    MAKEVALS(lV, VELOCITY),
    MAKEVALS(lA, ACCEL),
    MAKEVALS(lF, FORCE),
};

const DIDATAFORMAT c_dfDIJoystick2 = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_ABSAXIS,
    sizeof(DIJOYSTATE2),
    cA(c_rgodfDIJoy2),
    c_rgodfDIJoy2,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dijoyreg.c ===
/*****************************************************************************
 *
 *  DIJoyReg.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Registry access services for joystick configuration.
 *
 *  Contents:
 *
 *      JoyReg_GetConfig
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoyReg

#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global JOYREGHWSETTINGS | c_rghwsPredef[] |
 *
 *          Array of predefined hardware settings.
 *
 *****************************************************************************/

JOYREGHWSETTINGS c_rghwsPredef[] = {
    /* dwFlags             dwNumButtons */
    {  0,                             2},  /* JOY_HW_2A_2B_GENERIC         */
    {  0,                             4},  /* JOY_HW_2A_4B_GENERIC         */
    {  JOY_HWS_ISGAMEPAD,             2},  /* JOY_HW_2B_GAMEPAD            */
    {  JOY_HWS_ISYOKE,                2},  /* JOY_HW_2B_FLIGHTYOKE         */
    {  JOY_HWS_HASZ | JOY_HWS_ISYOKE, 2},  /* JOY_HW_2B_FLIGHTYOKETHROTTLE */
    {  JOY_HWS_HASZ,                  2},  /* JOY_HW_3A_2B_GENERIC         */
    {  JOY_HWS_HASZ,                  4},  /* JOY_HW_3A_4B_GENERIC         */
    {  JOY_HWS_ISGAMEPAD,             4},  /* JOY_HW_4B_GAMEPAD            */
    {  JOY_HWS_ISYOKE,                4},  /* JOY_HW_4B_FLIGHTYOKE         */
    {  JOY_HWS_HASZ | JOY_HWS_ISYOKE, 4},  /* JOY_HW_4B_FLIGHTYOKETHROTTLE */
    {  JOY_HWS_HASR                 , 2},  /* JOY_HW_TWO_2A_2B_WITH_Y      */
    /* To prevent the CPL from allowing 
       a user to add a rudder to to JOY_HWS_TWO_2A_2B_WITH_Y case, we 
       will pretend that it already has a rudder. This should not be a problem 
       as this struct is internal to DInput
       */
};

/* Hardware IDs for Predefined Joystick types */
LPCWSTR c_rghwIdPredef[] =
{
    L"GAMEPORT\\VID_045E&PID_0102",  //   L"GAMEPORT\\Generic2A2B",
    L"GAMEPORT\\VID_045E&PID_0103",  //   L"GAMEPORT\\Generic2A4B",
    L"GAMEPORT\\VID_045E&PID_0104",  //   L"GAMEPORT\\Gamepad2B",
    L"GAMEPORT\\VID_045E&PID_0105",  //   L"GAMEPORT\\FlightYoke2B",
    L"GAMEPORT\\VID_045E&PID_0106",  //   L"GAMEPORT\\FlightYokeThrottle2B",
    L"GAMEPORT\\VID_045E&PID_0107",  //   L"GAMEPORT\\Generic3A2B",
    L"GAMEPORT\\VID_045E&PID_0108",  //   L"GAMEPORT\\Generic3A4B",
    L"GAMEPORT\\VID_045E&PID_0109",  //   L"GAMEPORT\\Gamepad4B",
    L"GAMEPORT\\VID_045E&PID_010A",  //   L"GAMEPORT\\FlightYoke4B",
    L"GAMEPORT\\VID_045E&PID_010B",  //   L"GAMEPORT\\FlightYokeThrottle4B",
    L"GAMEPORT\\VID_045E&PID_010C",  //   L"GAMEPORT\\YConnectTwo2A2B",
};

WCHAR c_hwIdPrefix[] = L"GAMEPORT\\";   //  Prefix for custom devices

/*****************************************************************************
 *
 *      The default global port driver.
 *
 *****************************************************************************/

WCHAR c_wszDefPortDriver[] = L"MSANALOG.VXD";

#ifdef WINNT
    #define REGSTR_SZREGKEY     TEXT("\\DINPUT.DLL\\")
#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetValue |
 *
 *          Retrieve registry information.  If the data is short, and
 *          the type is <c REG_BINARY>, then the extra is zero-filled.
 *
 *  @parm   HKEY | hk |
 *
 *          Registry key containing fun values.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Registry value name.
 *
 *  @parm   DWORD | reg |
 *
 *          Registry data type expected.
 *
 *  @parm   LPVOID | pvBuf |
 *
 *          Buffer to receive information from registry.
 *
 *  @parm   DWORD | cb |
 *
 *          Size of recipient buffer, in bytes.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The binary read was short.  The remainder of the
 *          buffer is zero-filled.
 *
 *          <c E_FAIL>: Error reading value from registry.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_GetValue(HKEY hk, LPCTSTR ptszValue, DWORD reg, PV pvBuf, DWORD cb)
{
    HRESULT hres;
    DWORD cbOut;
    LONG lRc;

    /*
     *  Strings must be handled differently from binaries.
     *
     *  Strings are retrieved in UNICODE and may be short.
     *
     *  Binaries are retrieved as binary (duh) and may be long.
     *
     */

    cbOut = cb;

    if (reg == REG_SZ)
    {
        lRc = RegQueryStringValueW(hk, ptszValue, pvBuf, &cbOut);
        if (lRc == ERROR_SUCCESS)
        {
            hres = S_OK;
        } else
        {
            hres = hresLe(lRc);          /* Else, something bad happened */
        }

    } else
    {

        AssertF(reg == REG_BINARY);

        lRc = RegQueryValueEx(hk, ptszValue, 0, NULL, pvBuf, &cbOut);
        if (lRc == ERROR_SUCCESS)
        {
            if (cb == cbOut)
            {
                hres = S_OK;
            } else
            {

                /*
                 *  Zero out the extra.
                 */
                ZeroBuf(pvAddPvCb(pvBuf, cbOut), cb - cbOut);
                hres = S_FALSE;
            }


        } else if (lRc == ERROR_MORE_DATA)
        {

            /*
             *  Need to double-buffer the call and throw away
             *  the extra...
             */
            LPVOID pv;

            hres = AllocCbPpv(cbOut, &pv);
            // prefix 29344, odd chance that cbOut is 0x0 
            if (SUCCEEDED(hres) && ( pv != NULL)  )
            {
                lRc = RegQueryValueEx(hk, ptszValue, 0, NULL, pv, &cbOut);
                if (lRc == ERROR_SUCCESS)
                {
                    CopyMemory(pvBuf, pv, cb);
                    hres = S_OK;
                } else
                {
                    ZeroBuf(pvBuf, cb);
                    hres = hresLe(lRc);  /* Else, something bad happened */
                }
                FreePv(pv);
            }

        } else
        {
            if (lRc == ERROR_KEY_DELETED || lRc == ERROR_BADKEY)
            {
                lRc = ERROR_FILE_NOT_FOUND;
            }
            hres = hresLe(lRc);
            ZeroBuf(pvBuf, cb);
        }
    }

#ifdef DEBUG
    /*
     *  Don't whine if the key we couldn't find was
     *  REGSTR_VAL_JOYUSERVALUES, because almost no one has it.
     */
    if (FAILED(hres) &&  lstrcmpi(ptszValue, REGSTR_VAL_JOYUSERVALUES)  )
    {

        SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("Unable to read %s from registry"),
                        ptszValue);
    }
#endif

    return hres;

}

#ifndef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_IsWdmGameport |
 *
 *          To test whether the joy type is WDM device or not.
 *
 *  @parm   HKEY | hk |
 *
 *          Registry key containing fun values.
 *
 *  @returns
 *
 *          S_OK: if it uses WDM driver
 *
 *          E_FAIL>: Not uses WDM driver
 *
 *****************************************************************************/


STDMETHODIMP
JoyReg_IsWdmGameport( HKEY hk ) 
{
    HRESULT hres = E_FAIL;

    if ( hk )
    {
        WCHAR wsz[MAX_JOYSTRING];

        // Whistler PREFIX Bug #  45075, 45076
        // Wsz is not initialized
        ZeroX(wsz);

        if ( ( SUCCEEDED( JoyReg_GetValue( hk, REGSTR_VAL_JOYOEMHARDWAREID, REG_SZ, 
                                           &wsz, cbX(wsz) ) ) )
             &&( wsz[0] ) )
        {
            hres = S_OK;
        } else if ( SUCCEEDED( JoyReg_GetValue( hk, REGSTR_VAL_JOYOEMCALLOUT, REG_SZ, 
                                                &wsz, cbX(wsz) ) ) )
        {
            static WCHAR wszJoyhid[] = L"joyhid.vxd";
            int Idx;
#define WLOWER 0x0020

            CAssertF( cbX(wszJoyhid) <= cbX(wsz) ); 

            /*
             *  Since neither CharUpperW nor lstrcmpiW are really 
             *  implemented on 9x, do it by hand.
             */

            for ( Idx=cA(wszJoyhid)-2; Idx>=0; Idx-- )
            {
                if ( ( wsz[Idx] | WLOWER ) != wszJoyhid[Idx] )
                {
                    break;
                }
            }

            if ( ( Idx < 0 ) && ( wsz[cA(wszJoyhid)-1] == 0 ) )
            {
                hres = S_OK;
            }

#undef WLOWER
        }

    }

    return hres;
}
#endif /* ndef WINNT */


#if 0
/*
 * This function should be in diutil.c Putting here is just to keep it together with
 * JoyReg_IsWdmGameport();
 */
STDMETHODIMP
JoyReg_IsWdmGameportFromDeviceInstance( LPTSTR ptszDeviceInst ) 
{
    /*
     * ptszDeviceInst's format is like this: 
     *     HID\VID_045E&PID_0102\0000GAMEPORT&PVID_....
     */

    WCHAR wszDeviceInst[MAX_PATH];
    HRESULT hres = E_FAIL;

    if ( ptszDeviceInst )
    {
        memset( wszDeviceInst, 0, cbX(wszDeviceInst) );
        TToU( wszDeviceInst, MAX_PATH, ptszDeviceInst );
        wszDeviceInst[34] = 0;

        if ( memcmp( &wszDeviceInst[26], c_hwIdPrefix, 16 ) == 0 )
        {
            hres = S_OK;
        }
    }

    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetValue |
 *
 *          Write registry information.
 *
 *  @parm   HKEY | hk |
 *
 *          Registry key containing fun values.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Registry value name.
 *
 *  @parm   DWORD | reg |
 *
 *          Registry data type to set.
 *
 *  @parm   LPCVOID | pvBuf |
 *
 *          Buffer containing information to write to registry.
 *
 *  @parm   DWORD | cb |
 *
 *          Size of buffer, in bytes.  Ignored if writing a string.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c E_FAIL>: Error writing value to registry.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_SetValue(HKEY hk, LPCTSTR ptszValue, DWORD reg, PCV pvBuf, DWORD cb)
{
    HRESULT hres;
    LONG lRc;

    /*
     *  Strings must be handled differently from binaries.
     *
     *  A null string translates into deleting the key.
     */

    if (reg == REG_SZ)
    {
        lRc = RegSetStringValueW(hk, ptszValue, pvBuf);
    } else
    {
        lRc = RegSetValueEx(hk, ptszValue, 0, reg, pvBuf, cb);
    }

    if (lRc == ERROR_SUCCESS)
    {
        hres = S_OK;
    } else
    {
        RPF("Unable to write %s to registry", ptszValue);
        hres = E_FAIL;          /* Else, something bad happened */
    }

    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_OpenTypeKey |
 *
 *          Open the joystick registry key that corresponds to a
 *          joystick type.
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          The name of the type.
 *
 *  @parm   DWORD | sam |
 *
 *          Desired security access mask.
 *
 *  @parm   OUT PHKEY | phk |
 *
 *          Receives the opened registry key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: The joystick type was not found.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_OpenTypeKey(LPCWSTR pwszType, DWORD sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    HKEY hkTypes;
    EnterProc(JoyReg_OpenTypeKey, (_ "W", pwszType));

    /*
     *  Note that it is not safe to cache the registry key.
     *  If somebody deletes the registry key, our handle
     *  goes stale and becomes useless.
     */

    hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                           REGSTR_PATH_JOYOEM, 
                           sam, 
                           REG_OPTION_NON_VOLATILE, 
                           &hkTypes);

    if ( SUCCEEDED(hres) )
    {
#ifndef UNICODE
        TCHAR tszType[MAX_PATH];
        UToA( tszType, cA(tszType), pwszType );

        hres = hresMumbleKeyEx(hkTypes, 
                               tszType, 
                               sam, 
                               dwOptions, 
                               phk);
#else

        hres = hresMumbleKeyEx(hkTypes, 
                               pwszType, 
                               sam,
                               dwOptions, 
                               phk);
#endif     

        RegCloseKey(hkTypes);
    }

    if (FAILED(hres))
    {
        *phk = 0;
    }

    ExitBenignOleProcPpv(phk);
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_OpenPropKey |
 *
 *          Open the Dinput properties registry key that corresponds to a
 *          device type. This key contains the OEMMapFile and dwFlags2 information
 *          Nominally the location HKLM/REGSTR_PATH_PRIVATEPROPERTIES/DirectInput.
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          The name of the type.
 *
 *  @parm   DWORD | sam |
 *
 *          Desired security access mask.
 *
 *  @parm   OUT PHKEY | phk |
 *
 *          Receives the opened registry key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: The type was not found.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_OpenPropKey(LPCWSTR pwszType, DWORD sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    HKEY hkTypes;
    EnterProc(JoyReg_OpenTypeKey, (_ "W", pwszType));

    /*
     *  Note that it is not safe to cache the registry key.
     *  If somebody deletes the registry key, our handle
     *  goes stale and becomes useless.
     */

    hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                           REGSTR_PATH_DITYPEPROP, 
                           sam, 
                           REG_OPTION_NON_VOLATILE, 
                           &hkTypes);

    if ( SUCCEEDED(hres) )
    {
#ifndef UNICODE
        TCHAR tszType[MAX_PATH];
        UToA( tszType, cA(tszType), pwszType );

        hres = hresMumbleKeyEx(hkTypes, 
                               tszType, 
                               sam, 
                               dwOptions, 
                               phk);
#else

        hres = hresMumbleKeyEx(hkTypes, 
                               pwszType, 
                               sam,
                               dwOptions, 
                               phk);
#endif     

        RegCloseKey(hkTypes);
    }

    if (FAILED(hres))
    {
        *phk = 0;
    }

    ExitBenignOleProcPpv(phk);
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetTypeInfo |
 *
 *          Obtain information about a non-predefined joystick type.
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          The name of the type.
 *
 *  @parm   OUT LPDIJOYTYPEINFO | pjti |
 *
 *          Receives information about the joystick type.
 *          The caller is assumed to have validated the
 *          <e DIJOYCONFIG.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DITC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjti> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          <c S_FALSE> if some of the data was not available.
 *
 *          <c DIERR_NOTFOUND>: The joystick type was not found.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_GetTypeInfo(LPCWSTR pwszType, LPDIJOYTYPEINFO pjti, DWORD fl)
{
    HRESULT hres = S_FALSE;
    HKEY    hk;
    BOOL    fPartialData = FALSE;
    EnterProc(JoyReg_GetTypeInfo, (_ "Wx", pwszType, fl));


    ZeroX(pjti->clsidConfig);

    if( fl & ( DITC_FLAGS2 | DITC_MAPFILE ) )
    {
        /*
         *  The new registry branch is likely to be empty for many devices 
         *  so don't fail for anything here.
         */

        hres = JoyReg_OpenPropKey(pwszType, KEY_QUERY_VALUE, REG_OPTION_NON_VOLATILE, &hk);

        if( SUCCEEDED( hres ) )
        {
            if( fl & DITC_FLAGS2 )
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_FLAGS2, REG_BINARY, 
                                       &pjti->dwFlags2, 
                                       cbX(pjti->dwFlags2) );

                pjti->dwFlags2 &= JOYTYPE_FLAGS2_GETVALID;

                if( FAILED( hres ) )
                {
                    pjti->dwFlags2 = 0x0;
                    fPartialData = TRUE;
                }
            }

            if( fl & DITC_MAPFILE )
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_JOYOEMMAPFILE, REG_SZ,
                                       pjti->wszMapFile,
                                       cbX(pjti->wszMapFile));
                if( FAILED( hres ) )
                {
                    ZeroX(pjti->wszMapFile);
                    fPartialData = TRUE;
                }
            }

            RegCloseKey(hk);
        }
        else
        {
            pjti->dwFlags2 = 0x0;
            ZeroX(pjti->wszMapFile);
            fPartialData = TRUE;
        }

        hres = S_OK;
    }

    if( fl & DITC_INREGISTRY_DX6 )
    {
        hres = JoyReg_OpenTypeKey(pwszType, KEY_QUERY_VALUE, REG_OPTION_NON_VOLATILE, &hk);

        if (SUCCEEDED(hres))
        {

            if (fl & DITC_REGHWSETTINGS)
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_JOYOEMDATA, REG_BINARY,
                                       &pjti->hws, cbX(pjti->hws));
                if (FAILED(hres))
                {
                    goto closedone;
                }
            }

            /*
             *  Note that this never fails.
             */
            if (fl & DITC_CLSIDCONFIG)
            {
                TCHAR tszGuid[ctchGuid];
                LONG lRc;

                lRc = RegQueryString(hk, REGSTR_VAL_CPLCLSID, tszGuid, cA(tszGuid));

                if (lRc == ERROR_SUCCESS &&
                    ParseGUID(&pjti->clsidConfig, tszGuid))
                {
                    /* Guid is good */
                } else
                {
                    ZeroX(pjti->clsidConfig);
                }
            }

            if (fl & DITC_DISPLAYNAME)
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                       pjti->wszDisplayName,
                                       cbX(pjti->wszDisplayName));
                if (FAILED(hres))
                {
                    goto closedone;
                }
            }

#ifndef WINNT
            if (fl & DITC_CALLOUT)
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_JOYOEMCALLOUT, REG_SZ,
                                       pjti->wszCallout,
                                       cbX(pjti->wszCallout));
                if (FAILED(hres))
                {
                    ZeroX(pjti->wszCallout);
                    hres = S_FALSE;
                    fPartialData = TRUE;
                }
            }
#endif

            if ( fl & DITC_HARDWAREID )
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_JOYOEMHARDWAREID, REG_SZ,
                                       pjti->wszHardwareId,
                                       cbX(pjti->wszHardwareId));
                if ( FAILED(hres))
                {
                    ZeroX(pjti->wszHardwareId);
                    hres = S_FALSE;
                    fPartialData = TRUE;
                }
            }

            if ( fl & DITC_FLAGS1 )
            {
                hres = JoyReg_GetValue(hk,
                                       REGSTR_VAL_FLAGS1, REG_BINARY, 
                                       &pjti->dwFlags1, 
                                       cbX(pjti->dwFlags1) );
                if ( FAILED(hres) )
                {
                    pjti->dwFlags1 = 0x0;
                    hres = S_FALSE;
                    fPartialData = TRUE;
                }
                pjti->dwFlags1 &= JOYTYPE_FLAGS1_GETVALID;
            }
            hres = S_OK;

            closedone:;
            RegCloseKey(hk);


        } else
        {
            // ISSUE-2001/03/29-timgill debug string code should be higher
            // (MarcAnd) this really should be at least sqflError but
            // this happens a lot, probably due to not filtering out predefs
            SquirtSqflPtszV(sqfl | sqflBenign,
                            TEXT( "IDirectInputJoyConfig::GetTypeInfo: Nonexistent type %lS" ),
                            pwszType);
            hres = DIERR_NOTFOUND;
        }
    }

    if( SUCCEEDED( hres ) && fPartialData )
    {
        hres = S_FALSE;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetTypeInfo |
 *
 *          Store information about a non-predefined joystick type
 *          into the registry.
 *
 *  @parm   HKEY | hkTypeW |
 *
 *          Registry key to the types branch with write access.
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          The name of the type.
 *
 *  @parm   IN LPCDIJOYTYPEINFO | pjti |
 *
 *          Contains information about the joystick type.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DITC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjti> contain values which are to be set.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: The joystick type was not found.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_SetTypeInfo(HKEY hkTypesW,
                   LPCWSTR pwszType, LPCDIJOYTYPEINFO pjti, DWORD fl)
{
    HRESULT hres = S_OK;   /* Vacuous success in case of no flags set */
    ULONG lRc;
    EnterProc(JoyRegSetTypeInfo, (_ "Wx", pwszType, fl));

    if( fl & ( DITC_FLAGS2 | DITC_MAPFILE ) )
    {
        HKEY hkProp;

        hres = JoyReg_OpenPropKey(pwszType, DI_KEY_ALL_ACCESS, REG_OPTION_NON_VOLATILE, &hkProp);

        if( SUCCEEDED( hres ) )
        {
            if( fl & DITC_FLAGS2 )
            {
                DWORD   dwTemp;
                LONG    lRc;

                /*
                 *  Read and merge any current value so that bits unused in 
                 *  DX8 can be preserved.  Although this is more work now it 
                 *  should save adding Flags3 support next time.
                 */
                AssertF( (pjti->dwFlags2 & ~JOYTYPE_FLAGS2_SETVALID) == 0x0 );

                /*
                 *  PREFIX warns (259898) that RegQueryValueEx reads the value 
                 *  of dwTemp before it is set but then it checks lpData and 
                 *  zeroes the value before it is used.
                 */
                lRc = RegQueryValueEx( hkProp, REGSTR_VAL_FLAGS2, 0, 0, 0, &dwTemp );

                if( lRc == ERROR_FILE_NOT_FOUND )
                {
                    lRc = ERROR_SUCCESS;
                    dwTemp = cbX( pjti->dwFlags2 );
                }

                if( lRc == ERROR_SUCCESS )
                {
                    if( dwTemp <= cbX( pjti->dwFlags2 ) )
                    {
                        CAssertF( cbX( dwTemp ) == cbX( pjti->dwFlags2 ) );
                        JoyReg_GetValue( hkProp, REGSTR_VAL_FLAGS2, 
                                         REG_BINARY, &dwTemp, cbX( dwTemp ) );

                        dwTemp &= ~JOYTYPE_FLAGS2_SETVALID;
                        dwTemp |= pjti->dwFlags2;

                        if( dwTemp )
                        {
                            hres = JoyReg_SetValue( hkProp, REGSTR_VAL_FLAGS2, 
                                                    REG_BINARY, (PV)&dwTemp, cbX( dwTemp ) );
                        } else
                        {
                            lRc = RegDeleteValue( hkProp, REGSTR_VAL_FLAGS2 );
                            if (lRc == ERROR_FILE_NOT_FOUND)
                            {
                                lRc = ERROR_SUCCESS;
                            }
                            hres = hresLe( lRc );
                        }
                    } 
                    else
                    {
                        /*
                         *  Need to double buffer for the extra bytes
                         */
                        PBYTE pbFlags2;

                        hres = AllocCbPpv( dwTemp, &pbFlags2 );
                        if( SUCCEEDED( hres ) )
                        {
                            if ( ERROR_SUCCESS == RegQueryValueEx(
                                                                 hkProp, REGSTR_VAL_FLAGS2, 0, NULL, pbFlags2, &dwTemp ) )
                            {
                                CAssertF( JOYTYPE_FLAGS2_SETVALID == JOYTYPE_FLAGS2_GETVALID );
                                *(PDWORD)pbFlags2 &= ~JOYTYPE_FLAGS2_SETVALID;
                                *(PDWORD)pbFlags2 |= pjti->dwFlags2;

                                if ( ERROR_SUCCESS == RegSetValueEx(
                                                                   hkProp, REGSTR_VAL_FLAGS2, 0, REG_BINARY, pbFlags2, dwTemp ) )
                                {
                                    hres = S_OK;
                                } else
                                {
                                    SquirtSqflPtszV(sqfl | sqflError,
                                                    TEXT( "IDIJC::SetTypeInfo: failed to write extended Flags2" ) );
                                    hres = E_FAIL;
                                }
                            } else
                            {
                                SquirtSqflPtszV(sqfl | sqflError,
                                                TEXT( "IDIJC::SetTypeInfo: failed to read extended Flags2" ) );
                                hres = E_FAIL;  /* Else, something bad happened */
                            }
                            FreePv( pbFlags2 );
                        }
                    }
                } 
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT( "IDIJC::SetTypeInfo: failed to read size of Flags2, error %d" ), lRc );
                    hres = hresLe( lRc );
                }

                if( FAILED( hres ) )
                {
                    hres = S_FALSE;
                    goto closedoneprop;
                }
            }

            if( fl & DITC_MAPFILE )
            {
                hres = JoyReg_SetValue(hkProp,
                                       REGSTR_VAL_JOYOEMMAPFILE, REG_SZ,
                                       pjti->wszMapFile,
                                       cbX(pjti->wszMapFile));
                if( FAILED(hres) )
                {
                    hres = S_FALSE;
                    goto closedoneprop;
                }
            }

            hres = S_OK;
            closedoneprop:;

            RegCloseKey(hkProp);
        }
        else
        {
            RPF( "Failed to open DirectInput type property key" );
        }
    }

    if( hres == S_OK )
    {
        if( fl & DITC_INREGISTRY_DX6 )
        {
            HKEY hk;
            DWORD dwOptions = 0;


            if ( fl & DITC_VOLATILEREGKEY )
            {
                dwOptions = REG_OPTION_VOLATILE;
            } else
            {
                dwOptions = REG_OPTION_NON_VOLATILE;    
            }

#ifndef UNICODE
            {
                TCHAR tszType[MAX_PATH];

                UToA(tszType, cA(tszType), pwszType);

                hres = hresMumbleKeyEx(hkTypesW, 
                                       tszType, 
                                       DI_KEY_ALL_ACCESS, 
                                       dwOptions, 
                                       &hk);

            }
#else
            hres = hresMumbleKeyEx(hkTypesW, 
                                   pwszType, 
                                   DI_KEY_ALL_ACCESS, 
                                   dwOptions, 
                                   &hk);
#endif

            if ( SUCCEEDED(hres) )
            {

                if (fl & DITC_REGHWSETTINGS)
                {
                    hres = JoyReg_SetValue(hk, REGSTR_VAL_JOYOEMDATA, REG_BINARY,
                                           (PV)&pjti->hws, cbX(pjti->hws));
                    if (FAILED(hres))
                    {
                        goto closedone;
                    }
                }

                if (fl & DITC_CLSIDCONFIG)
                {
                    if (IsEqualGUID(&pjti->clsidConfig, &GUID_Null))
                    {
                        lRc = RegDeleteValue(hk, REGSTR_VAL_CPLCLSID);

                        /*
                         *  It is not an error if the key does not already exist.
                         */
                        if (lRc == ERROR_FILE_NOT_FOUND)
                        {
                            lRc = ERROR_SUCCESS;
                        }
                    } else
                    {
                        TCHAR tszGuid[ctchNameGuid];
                        NameFromGUID(tszGuid, &pjti->clsidConfig);
                        lRc = RegSetValueEx(hk, REGSTR_VAL_CPLCLSID, 0, REG_SZ,
                                            (PV)&tszGuid[ctchNamePrefix], ctchGuid * cbX(tszGuid[0]) );
                    }
                    if (lRc == ERROR_SUCCESS)
                    {
                    } else
                    {
                        hres = E_FAIL;
                        goto closedone;
                    }
                }

            /* ISSUE-2001/03/29-timgill Needs more data checking
               Should make sure string is terminated properly */
                if (fl & DITC_DISPLAYNAME)
                {
                    hres = JoyReg_SetValue(hk,
                                           REGSTR_VAL_JOYOEMNAME, REG_SZ,
                                           pjti->wszDisplayName,
                                           cbX(pjti->wszDisplayName));
                    if (FAILED(hres))
                    {
                        goto closedone;
                    }
                }

#ifndef WINNT
            /* ISSUE-2001/03/29-timgill Needs more data checking
               Should make sure string is terminated properly */
                if (fl & DITC_CALLOUT)
                {
                    hres = JoyReg_SetValue(hk,
                                           REGSTR_VAL_JOYOEMCALLOUT, REG_SZ,
                                           pjti->wszCallout,
                                           cbX(pjti->wszCallout));
                    if (FAILED(hres))
                    {
                        hres = S_FALSE;
                        //continue to go
                    }
                }
#endif

                if ( fl & DITC_HARDWAREID )
                {
                    hres = JoyReg_SetValue(hk,
                                           REGSTR_VAL_JOYOEMHARDWAREID, REG_SZ,
                                           pjti->wszHardwareId,
                                           cbX(pjti->wszHardwareId) );
                    if ( FAILED(hres) )
                    {
                        hres = S_FALSE;
                        goto closedone;
                    }
                }

                if ( fl & DITC_FLAGS1 )
                {
                    AssertF( (pjti->dwFlags1 & ~JOYTYPE_FLAGS1_SETVALID) == 0x0 );
                    hres = JoyReg_SetValue(hk,
                                           REGSTR_VAL_FLAGS1, REG_BINARY, 
                                           (PV)&pjti->dwFlags1, 
                                           cbX(pjti->dwFlags1) );
                    if ( FAILED(hres) )
                    {
                        hres = S_FALSE;
                        goto closedone;
                    }
                }

                hres = S_OK;

                closedone:;
                RegCloseKey(hk);

            } else
            {
                hres = E_FAIL;              /* Registry problem */
            }
        }
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_OpenConfigKey |
 *
 *          Open the registry key that accesses joystick configuration data.
 *
 *          Warning!  Do not cache this regkey.
 *
 *          If the user deletes the key and then re-creates it,
 *          the opened key will go stale and will become useless.
 *          You have to close the key and reopen it.
 *          To avoid worrying about that case, merely open it every time.
 *
 *  @parm   UINT | idJoy |
 *
 *          Joystick number.
 *
 *  @parm   DWORD | sam |
 *
 *          Access level desired.
 *
 *  @parm   IN DWORD  | dwOptions |
 *          Option flags to RegCreateEx
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives created registry key.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          hresLe(ERROR_FILE_NOT_FOUND): The key does not exist.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_OpenConfigKey(UINT idJoy, DWORD sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    EnterProc(JoyReg_OpenConfigKey, (_ "uxx", idJoy, sam, dwOptions));

#ifdef WINNT
    hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                           REGSTR_PATH_JOYCONFIG REGSTR_SZREGKEY REGSTR_KEY_JOYCURR, 
                           sam, REG_OPTION_VOLATILE, phk);
#else
    
    {
        MMRESULT mmrc = MMSYSERR_ERROR;
        JOYCAPS caps;
        /*
         *  If we can't get the dev caps for the specified joystick,
         *  then use the magic joystick id "-1" to get non-specific
         *  caps.
         */
        mmrc = joyGetDevCaps(idJoy, &caps, cbX(caps));
        if ( mmrc != JOYERR_NOERROR )
        {
            mmrc = joyGetDevCaps((DWORD)-1, &caps, cbX(caps));
        }

        if (mmrc == JOYERR_NOERROR)
        {

            TCHAR tsz[cA(REGSTR_PATH_JOYCONFIG) +
                      1 +                           /* backslash */
                      cA(caps.szRegKey) +
                      1 +                           /* backslash */
                      cA(REGSTR_KEY_JOYCURR) + 1];        

            /* tsz = MediaResources\Joystick\<drv>\CurrentJoystickSettings */
            wsprintf(tsz, TEXT("%s\\%s\\") REGSTR_KEY_JOYCURR,
                     REGSTR_PATH_JOYCONFIG, caps.szRegKey);


            hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, tsz, sam, REG_OPTION_VOLATILE, phk);

        } else
        {
            hres = E_FAIL;
        }
    }
#endif

    ExitBenignOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_OpenSaveKey |
 *
 *          Open the registry key that accesses joystick saved configurations
 *
 *          Warning!  Do not cache this regkey.
 *
 *          If the user deletes the key and then re-creates it,
 *          the opened key will go stale and will become useless.
 *          You have to close the key and reopen it.
 *          To avoid worrying about that case, merely open it every time.
 *
 *  @parm   DWORD | dwType |
 *
 *          Joystick type.
 *
 *          This is either one of the standard ones in the range
 *
 *  @parm   IN LPCDIJOYCONFIG | pcfg |
 *
 *          If the dwType represents an OEM type, this should point to a
 *          configuration data structure containing a valid wszType.
 *
 *  @parm   DWORD | sam |
 *
 *          Access level desired.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives created registry key.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          hresLe(ERROR_FILE_NOT_FOUND): The key does not exist.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_OpenSaveKey(DWORD dwType, LPCDIJOYCONFIG pcfg, DWORD sam, PHKEY phk)
{
    HRESULT hres;
    JOYCAPS caps;
    DWORD   dwOptions = 0;
    EnterProc(JoyReg_OpenSaveKey, (_ "upx", dwType, pcfg, sam));


#ifdef WINNT
    lstrcpy(caps.szRegKey, REGSTR_SZREGKEY );
#else

    /*
     *  use the magic joystick id "-1" to get non-specific caps.
     */

    if ( joyGetDevCaps((DWORD)-1, &caps, cbX(caps)) != JOYERR_NOERROR )
    {
        hres = E_FAIL;
    } else
#endif
    {
        TCHAR tsz[cA(REGSTR_PATH_JOYCONFIG) +
                  1 +                           /* backslash */
                  cA(caps.szRegKey) +
                  1 +                           /* backslash */
                  cA(REGSTR_KEY_JOYSETTINGS) +
                  1 +                           /* backslash */
                  max( cA(REGSTR_KEY_JOYPREDEFN), cA(pcfg->wszType) ) + 1 ];

        /* tsz = MediaResources\Joystick\<drv>\JoystickSettings\<Type> */
        if ( dwType >= JOY_HW_PREDEFMAX )
        {
            wsprintf(tsz, TEXT("%s\\%s\\%s\\%ls"),
                     REGSTR_PATH_JOYCONFIG, caps.szRegKey, REGSTR_KEY_JOYSETTINGS, pcfg->wszType);
        } else
        {
            /*
             *  We will probably never have more than the current 11 predefined
             *  joysticks.  Assume no more than 99 so %d is as many characters.
             */
            wsprintf(tsz, TEXT("%s\\%s\\%s\\" REGSTR_KEY_JOYPREDEFN),
                     REGSTR_PATH_JOYCONFIG, caps.szRegKey, REGSTR_KEY_JOYSETTINGS, dwType );
        }

        if ( pcfg->hwc.dwUsageSettings & JOY_US_VOLATILE )
            dwOptions = REG_OPTION_VOLATILE;
        else
            dwOptions = REG_OPTION_NON_VOLATILE;

        hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, tsz, sam, dwOptions, phk);

    } 

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetSetConfigValue |
 *
 *          Retrieve or update configuration information about a joystick,
 *          as stored in the registry instance key.
 *
 *  @parm   HKEY | hk |
 *
 *          Registry key containing fun values.
 *
 *  @parm   LPCTSTR | ptszNValue |
 *
 *          Registry value name, with "%d" where a joystick number
 *          should be.
 *
 *  @parm   UINT | idJoy |
 *
 *          Zero-based joystick number.
 *
 *  @parm   DWORD | reg |
 *
 *          Registry data type expected.
 *
 *  @parm   LPVOID | pvBuf |
 *
 *          Buffer to receive information from registry (if getting)
 *          or containing value to set.
 *
 *  @parm   DWORD | cb |
 *
 *          Size of buffer, in bytes.
 *
 *  @parm   BOOL | fSet |
 *
 *          Nonzer if the value should be set; otherwise, it will be
 *          retrieved.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c E_FAIL>: Error reading/writing value to/from registry.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_GetSetConfigValue(HKEY hk, LPCTSTR ptszNValue, UINT idJoy,
                         DWORD reg, PV pvBuf, DWORD cb, BOOL fSet)
{
    HRESULT hres;
    int ctch;

    /* Extra +12 because a UINT can be as big as 4 billion */
    TCHAR tsz[max(
                 max(
                    max(cA(REGSTR_VAL_JOYNCONFIG),
                        cA(REGSTR_VAL_JOYNOEMNAME)),
                    cA(REGSTR_VAL_JOYNOEMCALLOUT)),
                 cA(REGSTR_VAL_JOYNFFCONFIG)) + 12 + 1];

    ctch = wsprintf(tsz, ptszNValue, idJoy + 1);
    AssertF(ctch < cA(tsz));

    if (fSet)
    {
        hres = JoyReg_SetValue(hk, tsz, reg, pvBuf, cb);
    } else
    {
        hres = JoyReg_GetValue(hk, tsz, reg, pvBuf, cb);
    }

    return hres;

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresIdJoypInstanceGUID |
 *
 *          Given a joystick ID obtain the corresponding GUID.
 *          This routine differs in implementation on WINNT and WIN9x
 *          On WINNT there are no predefined GUID for Joystick IDs.
 *
 *  @parm   IN UINT | idJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   OUT LPGUID | lpguid |
 *
 *          Receives the joystick GUID. If no mapping exists,
 *          GUID_NULL is passed back
 *
 *  On Windows NT all joysticks are HID devices. The corresponding function
 *  for WINNT is defined in diWinnt.c
 *
 *****************************************************************************/

HRESULT EXTERNAL hResIdJoypInstanceGUID_95
(
UINT    idJoy,
LPGUID  lpguid
)
{
    HRESULT hRes;

    hRes = S_OK;
    if ( idJoy < cA(rgGUID_Joystick) )
    {
        *lpguid = rgGUID_Joystick[idJoy];
    } else
    {
        hRes = DIERR_NOTFOUND;
        ZeroX(*lpguid);
    }
    return hRes;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetConfigInternal |
 *
 *          Obtain information about a joystick's configuration.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   OUT LPDIJOYCONFIG | pcfg |
 *
 *          Receives information about the joystick configuration.
 *          The caller is assumed to have validated the
 *          <e DIJOYCONFIG.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjc> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOMOREITEMS>: No more joysticks.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_GetConfigInternal(UINT idJoy, LPDIJOYCONFIG pcfg, DWORD fl)
{
    HRESULT hres = E_FAIL;

    EnterProc(JoyReg_GetConfigInternal, (_ "upx", idJoy, pcfg, fl));

    AssertF((fl & ~DIJC_GETVALID) == 0);

    /* We only support (0/16) joysticks */
    if ( idJoy < cJoyMax )
    {
        /* Force a rescan of all HID device list
         * Some device may have been attached
         * since we last looked
         */
        DIHid_BuildHidList(FALSE);
        
        if (fl & DIJC_GUIDINSTANCE)
        {
            hres = hResIdJoypInstanceGUID_WDM(idJoy, &pcfg->guidInstance);

         #ifndef WINNT
            if ( FAILED(hres) )
            {
                hres = hResIdJoypInstanceGUID_95(idJoy, &pcfg->guidInstance);
            }
         #endif

            if ( FAILED(hres) )
            {
                goto done;
            }
        }

        if ( fl & DIJC_INREGISTRY )
        {
            HKEY hk;
            /* Does the registry entry exist ? */
            hres = JoyReg_OpenConfigKey(idJoy, KEY_QUERY_VALUE, REG_OPTION_NON_VOLATILE , &hk);
            if (SUCCEEDED(hres))
            {
                if (fl & DIJC_REGHWCONFIGTYPE)
                {
                    hres = JoyReg_GetConfigValue(
                                                hk, REGSTR_VAL_JOYNCONFIG,
                                                idJoy, REG_BINARY,
                                                &pcfg->hwc, cbX(pcfg->hwc));
                    if (FAILED(hres))
                    {
                        goto closedone;
                    }

                    pcfg->wszType[0] = TEXT('\0');
                    if ( (pcfg->hwc.dwUsageSettings & JOY_US_ISOEM)
#ifndef WINNT
                         ||( (pcfg->hwc.dwType >= JOY_HW_PREDEFMIN) 
                             &&(pcfg->hwc.dwType <  JOY_HW_PREDEFMAX) ) 
#endif
                       )
                    {
                        hres = JoyReg_GetConfigValue(
                                                    hk, REGSTR_VAL_JOYNOEMNAME, idJoy, REG_SZ,
                                                    pcfg->wszType, cbX(pcfg->wszType));
                        if (FAILED(hres))
                        {
                            goto closedone;
                        }
                    }
                }

#ifndef WINNT
                if (fl & DIJC_CALLOUT)
                {
                    pcfg->wszCallout[0] = TEXT('\0');
                    hres = JoyReg_GetConfigValue(
                                                hk, REGSTR_VAL_JOYNOEMCALLOUT, idJoy, REG_SZ,
                                                pcfg->wszCallout, cbX(pcfg->wszCallout));
                    if (FAILED(hres))
                    {
                        ZeroX(pcfg->wszCallout);
                        hres = S_FALSE;
                        /* Note that we fall through and let hres = S_OK */
                    }
                }
#endif

                if (fl & DIJC_GAIN)
                {
                    /*
                     *  If there is no FF configuration, then
                     *  default to DI_FFNOMINALMAX gain.
                     */
                    hres = JoyReg_GetConfigValue(hk,
                                                 REGSTR_VAL_JOYNFFCONFIG,
                                                 idJoy, REG_BINARY,
                                                 &pcfg->dwGain, cbX(pcfg->dwGain));

                    if (SUCCEEDED(hres) && ISVALIDGAIN(pcfg->dwGain))
                    {
                        /* Leave it alone; it's good */
                    } else
                    {
                        hres = S_FALSE;
                        pcfg->dwGain = DI_FFNOMINALMAX;
                        /* Note that we fall through and let hres = S_OK */
                    }
                }

                if ( fl & DIJC_WDMGAMEPORT )
                {
                    PBUSDEVICEINFO pbdi;
                    /*
                     * If there is no Gameport Associated with this device
                     * then it must be a USB device
                     */

                    DllEnterCrit();
                    if ( pbdi = pbdiFromJoyId(idJoy) )
                    {
                        pcfg->guidGameport = pbdi->guid;
                        //lstrcpyW(pcfg->wszGameport, pbdi->wszDisplayName);
                    } else
                    {
                        ZeroX(pcfg->guidGameport);
                        //pcfg->wszGameport[0] = TEXT('\0');
                    }

                    DllLeaveCrit();
                }

            }

            closedone:
            RegCloseKey(hk);
        }
    } else
    {
        hres = DIERR_NOMOREITEMS;
    }

    done:
    ExitBenignOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetConfig |
 *
 *          Obtain information about a joystick's configuration,
 *          taking the *naive* MSGAME.VXD driver into account.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   OUT LPDIJOYCONFIG | pcfg |
 *
 *          Receives information about the joystick configuration.
 *          The caller is assumed to have validated the
 *          <e DIJOYCONFIG.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjc> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOMOREITEMS>: No more joysticks.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_GetConfig(UINT idJoy, LPDIJOYCONFIG pcfg, DWORD fl)
{
    HRESULT hres;
    GUID    guid;

    EnterProc(JoyReg_GetConfig, (_ "upx", idJoy, pcfg, fl));

    AssertF((fl & ~DIJC_GETVALID) == 0);

    /* 
     * First determine if the joystick exits 
     * On NT, we use WDM driver.
     * On Win9x, if WDM fails, use static guids.
     */
    hres = hResIdJoypInstanceGUID_WDM(idJoy, &guid);

#ifndef WINNT
    if ( FAILED(hres) )
    {
        hres = hResIdJoypInstanceGUID_95(idJoy, &guid);
    }
#endif

    if ( SUCCEEDED( hres) )
    {

        hres = JoyReg_GetConfigInternal(idJoy, pcfg, fl);

      #ifndef WINNT
        /***************************************************
         *
         *  Beginning of hack for *naive* Sidewinder Gamepad.
         *
         *  The gamepad needs to be polled sixteen times 
         *  before it realizes what is going on.
         *
         ***************************************************/

        if (SUCCEEDED(hres) && (fl & DIJC_CALLOUT))
        {

            static WCHAR s_wszMSGAME[] = L"MSGAME.VXD";

            if (memcmp(pcfg->wszCallout, s_wszMSGAME, cbX(s_wszMSGAME)) == 0)
            {
                SquirtSqflPtszV(sqfl,
                                TEXT("Making bonus polls for Sidewinder"));

                /*
                 *  Sigh.  It's a Sidewinder.  Make sixteen
                 *  bonus polls to shake the stick into submission.
                 *
                 *  There's no point in doing this over and over if we're 
                 *  in some kind of loop so make sure a "reasonable" 
                 *  length of time has passed since last time we tried.
                 *  3 seconds is a little less than the current CPL 
                 *  background refresh rate.
                 */

                if ( !g_dwLastBonusPoll || ( GetTickCount() - g_dwLastBonusPoll > 3000 ) )
                {
                    JOYINFOEX ji;
                    int i;
                    DWORD dwWait;

                    ji.dwSize = cbX(ji);
                    ji.dwFlags = JOY_RETURNALL;
                        
                    for (i = 0; i < 16; i++)
                    {
                        MMRESULT mmrc = joyGetPosEx(idJoy, &ji);
                        SquirtSqflPtszV(sqfl,
                                        TEXT("joyGetPosEx(%d) = %d"),
                                        idJoy, mmrc);
                        /*
                         *  Sleep 10ms between each poll because that
                         *  seems to help a bit.
                         */
                        Sleep(10);
                    }

                    /*
                     *  Bonus hack!  Now sleep for some time.  
                     *  The amount of time we need to sleep is CPU-speed 
                     *  dependent, so we'll grab the sleep time from the 
                     *  registry to allow us to tweak it later.
                     *
                     *  What a shame.
                     */
                    dwWait = RegQueryDIDword(NULL, REGSTR_VAL_GAMEPADDELAY, 100);
                    if (dwWait > 10 * 1000)
                    {
                        dwWait = 10 * 1000;
                    }

                    Sleep(dwWait);

                    /*
                     *  And then check again.
                     */
                    hres = JoyReg_GetConfigInternal(idJoy, pcfg, fl);

                    g_dwLastBonusPoll = GetTickCount();
                }
            }

        }
        /***************************************************
         *
         *  End of hack for *naive* Sidewinder Gamepad.
         *
         ***************************************************/

      #endif
      
    }

    return hres;
}


#ifndef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_JoyIdToDeviceInterface_95 |
 *
 *          Given a joystick ID number, obtain the device interface
 *          corresponding to it.
 *
 *  @parm   UINT | idJoy |
 *
 *          Joystick ID number, zero-based.
 *
 *  @parm   PVXDINITPARMS | pvip |
 *
 *          Receives init parameters from the driver.
 *
 *  @parm   LPTSTR | ptszBuf |
 *
 *          A buffer of size <c MAX_PATH> in which the device interface
 *          path is built.  Note that we can get away with a buffer of
 *          this size, since the code path exists only on Windows 95,
 *          and Windows 95 does not support paths longer than <c MAX_PATH>.
 *          (I.e., there ain't no \\?\ support in Win95.)
 *
 *  @returns
 *
 *          A pointer to the part of the <p ptszBuf> buffer that
 *          contains the actual device interface path.
 *
 *****************************************************************************/

LPSTR EXTERNAL
JoyReg_JoyIdToDeviceInterface_95(UINT idJoy, PVXDINITPARMS pvip, LPSTR ptszBuf)
{
    UINT cwch;
    HRESULT hres;
    LPSTR ptszRc;

    hres = Hel_Joy_GetInitParms(idJoy, pvip);
    if (SUCCEEDED(hres))
    {

        /*
         *  The length counter includes the terminating null.
         */
        cwch = LOWORD(pvip->dwFilenameLengths);

        /*
         *  The name that comes from HID is "\DosDevices\blah"
         *  but we want to use "\\.\blah".  So check if it indeed
         *  of the form "\DosDevices\blah" and if so, convert it.
         *  If not, then give up.
         *
         *  For the string to possibly be a "\DosDevices\", it
         *  needs to be of length 12 or longer.
         */

        if (cwch >= 12 && cwch < MAX_PATH)
        {

            /*
             *  WideCharToMultiByte does parameter validation so we
             *  don't have to.
             */
            WideCharToMultiByte(CP_ACP, 0, pvip->pFilenameBuffer, cwch,
                                ptszBuf, MAX_PATH, 0, 0);

            /*
             *  The 11th (zero-based) character must be a backslash.
             *  And the value of cwch had better be right.
             */
            if (ptszBuf[cwch-1] == ('\0') && ptszBuf[11] == ('\\'))
            {

                /*
                 *  Wipe out the backslash and make sure the lead-in
                 *  is "\DosDevices".
                 */
                ptszBuf[11] = ('\0');
                if (lstrcmpiA(ptszBuf, ("\\DosDevices")) == 0)
                {
                    /*
                     *  Create a "\\.\" at the start of the string.
                     *  Note!  This code never runs on Alphas so we
                     *  can do evil unaligned data accesses.
                     *
                     *  (Actually, 8 is a multiple of 4, so everything
                     *  is aligned after all.)
                     */
                    *(LPDWORD)&ptszBuf[8] = 0x5C2E5C5C;

                    ptszRc = &ptszBuf[8];
                } else
                {
                    ptszRc = NULL;
                }
            } else
            {
                ptszRc = NULL;
            }
        } else
        {
            ptszRc = NULL;
        }
    } else
    {
        ptszRc = NULL;
    }

    return ptszRc;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | JoyReg_SetCalibration |
 *
 *          Store information about a joystick's configuration,
 *          shadowing the information back into the HID side of
 *          things as well.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   LPJOYREGHWCONFIG | phwc |
 *
 *          Contains information about the joystick capabilities.
 *          This value supercedes the value in the <p pcfg>.
 *
 *  @parm   LPCDIJOYCONFIG | pcfg |
 *
 *          Contains information about the joystick configuration.
 *          The caller is assumed to have validated all fields.
 *
 *****************************************************************************/

STDMETHODIMP
TFORM(CDIObj_FindDevice)(PV pdiT, REFGUID rguid,
                         LPCTSTR ptszName, LPGUID pguidOut);

void EXTERNAL
JoyReg_SetCalibration(UINT idJoy, LPJOYREGHWCONFIG phwc)
{
    HRESULT hres;
    VXDINITPARMS vip;
    GUID guid;
    CHAR tsz[MAX_PATH];
    LPSTR pszPath;
    TCHAR ptszPath[MAX_PATH];
    EnterProc(JoyReg_SetCalibration, (_ "up", idJoy, phwc));

    pszPath = JoyReg_JoyIdToDeviceInterface_95(idJoy, &vip, tsz);

    if ( pszPath )
#ifdef UNICODE
        AToU( ptszPath, MAX_PATH, pszPath );
#else
        lstrcpy( (LPSTR)ptszPath, pszPath );
#endif

    if (pszPath &&
        SUCCEEDED(CDIObj_FindDeviceInternal(ptszPath, &guid)))
    {
        IDirectInputDeviceCallback *pdcb;
#ifdef DEBUG
        CREATEDCB CreateDcb;
#endif

#ifdef DEBUG

        /*
         *  If the associated HID device got unplugged, then
         *  the instance GUID is no more.  So don't get upset
         *  if we can't find it.  But if we do find it, then
         *  it had better be a HID device.
         *
         *  CHid_New will properly fail if the associated
         *  device is not around.
         */
        hres = hresFindInstanceGUID(&guid, &CreateDcb, 1);
        AssertF(fLimpFF(SUCCEEDED(hres), CreateDcb == CHid_New));
#endif

        if (SUCCEEDED(hres = CHid_New(0, &guid,
                                      &IID_IDirectInputDeviceCallback,
                                      (PPV)&pdcb)))
        {
            LPDIDATAFORMAT pdf;

            /*
             *  The VXDINITPARAMS structure tells us where JOYHID
             *  decided to place each of the axes.  Follow that
             *  table to put them into their corresponding location
             *  in the HID side.
             */
            hres = pdcb->lpVtbl->GetDataFormat(pdcb, &pdf);
            if (SUCCEEDED(hres))
            {
                UINT uiAxis;
                DIPROPINFO propi;

                propi.pguid = DIPROP_SPECIFICCALIBRATION;

                /*
                 *  For each axis...
                 */
                for (uiAxis = 0; uiAxis < 6; uiAxis++)
                {
                    DWORD dwUsage = vip.Usages[uiAxis];
                    /*
                     *  If the axis is mapped to a usage...
                     */
                    if (dwUsage)
                    {
                        /*
                         *  Convert the usage into an object index.
                         */
                        hres = pdcb->lpVtbl->MapUsage(pdcb, dwUsage,
                                                      &propi.iobj);
                        if (SUCCEEDED(hres))
                        {
                            DIPROPCAL cal;

                            /*
                             *  Convert the old-style calibration into
                             *  a new-style calibration.
                             */
#define CopyCalibration(f, ui) \
                cal.l##f = (&phwc->hwv.jrvHardware.jp##f.dwX)[ui]

                            CopyCalibration(Min, uiAxis);
                            CopyCalibration(Max, uiAxis);
                            CopyCalibration(Center, uiAxis);

#undef CopyCalibration


                            /*
                             *  Set the calibration property on the object.
                             */
                            propi.dwDevType =
                            pdf->rgodf[propi.iobj].dwType;
                            hres = pdcb->lpVtbl->SetProperty(pdcb, &propi,
                                                             &cal.diph);
                        }
                    }
                }
            }

            Invoke_Release(&pdcb);
        }
    }

    ExitProc();
}
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetHWConfig |
 *
 *          Store information about a joystick's <t JOYREGHWCONFIG>.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   LPJOYREGHWCONFIG | phwc |
 *
 *          Contains information about the joystick capabilities.
 *          This value supercedes the value in the <p pcfg>.
 *
 *  @parm   LPCDIJOYCONFIG | pcfg |
 *
 *          Contains information about the joystick configuration.
 *          The caller is assumed to have validated all fields.
 *
 *  @parm   HKEY | hk |
 *
 *          The type key we are munging.
 *
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

HRESULT INTERNAL
JoyReg_SetHWConfig(UINT idJoy, LPJOYREGHWCONFIG phwc, LPCDIJOYCONFIG pcfg,
                   HKEY hk)
{
    HRESULT hres;
    HKEY hkSave;
    DWORD dwSam;

    /*
     *  The caller has set phwc->dwType, so use it to determine
     *  where the data comes from or goes to.
     */
    if ( phwc->dwType == JOY_HW_NONE )
    {
        /*
         *  Nothing to do
         */
    } else if ( phwc->dwType == JOY_HW_CUSTOM )
    {
        /*
        /*  ISSUE-2001/03/29-timgill Custom HWConfig not handled correctly
         *  We don't know the type name and the only time we can look
         *  it up is when were modifying an existing config so although we
         *  could store the config, we'd never be able to get it back.
         *  Should return no better than S_FALSE.  This will have to wait.
         */
    } else
    {
        /*
         *  Try to access saved values
         */

        // ISSUE-2001/03/29-timgill Dangerous type cast
        PDWORD pdw = (PDWORD)&phwc->hwv;

        dwSam = KEY_QUERY_VALUE;

        while ( pdw < &phwc->dwType )
        {
            if ( *pdw )
            {
                /*
                 *  Real config data so write it
                 */
                dwSam = KEY_SET_VALUE;
                break;
            }
            pdw++;
        }

        /*
         *  If the device is autoloaded and yet the user is manually assigning it
         *  to an ID, set the volatile flag.  The flag will be set to the driver
         *  defined value if a driver ever gets hotplug assigned to this ID but if
         *  not, this makes sure that the settings are removed on next reboot.
         */
        if (phwc->hws.dwFlags & JOY_HWS_AUTOLOAD)
        {
            phwc->dwUsageSettings |= JOY_US_VOLATILE;
        }

        hres = JoyReg_OpenSaveKey( phwc->dwType, pcfg, dwSam, &hkSave );

        if ( SUCCEEDED(hres) )
        {
            if ( dwSam == KEY_SET_VALUE )
            {
                hres = JoyReg_SetConfigValue(hkSave, REGSTR_VAL_JOYNCONFIG,
                                             idJoy, REG_BINARY,
                                             phwc, cbX(*phwc));
                if ( FAILED(hres) )
                {
                    // Report the error but live with it
                    RPF("JoyReg_SetConfig: failed to set saved config %08x", hres );
                }
            } else
            {
                JOYREGHWCONFIG hwc;

                /*
                 *  Read it into an extra buffer because we only want it
                 *  if it's complete.
                 */
                hres = JoyReg_GetConfigValue(hkSave, REGSTR_VAL_JOYNCONFIG,
                                             idJoy, REG_BINARY,
                                             &hwc, cbX(hwc));
                if ( hres == S_OK )
                {
                    // Assert hws is first and no gap before dwUsageSettings
                    CAssertF( FIELD_OFFSET( JOYREGHWCONFIG, hws ) == 0 );
                    CAssertF( FIELD_OFFSET( JOYREGHWCONFIG, dwUsageSettings ) == sizeof( hwc.hws ) );

                    // Copy the whole structure except the hws
                    memcpy( &phwc->dwUsageSettings, &hwc.dwUsageSettings, 
                            sizeof( hwc ) - sizeof( hwc.hws ) );
                }
            }

            RegCloseKey( hkSave );
        }
        /*
         *  If we failed to read, there's probably nothing there and the
         *  structure is set up already for a blank config.
         *  If we failed to write there probably not much we can do
         */
    }


    hres = JoyReg_SetConfigValue(hk, REGSTR_VAL_JOYNCONFIG,
                                 idJoy, REG_BINARY,
                                 phwc, cbX(*phwc));
    if (FAILED(hres))
    {
        goto done;
    }

    if (phwc->dwUsageSettings & JOY_US_ISOEM)
    {

        hres = JoyReg_SetConfigValue(
                                    hk, REGSTR_VAL_JOYNOEMNAME, idJoy, REG_SZ,
                                    pcfg->wszType, cbX(pcfg->wszType));

    } else
    {
        hres = JoyReg_SetConfigValue(
                                    hk, REGSTR_VAL_JOYNOEMNAME, idJoy, REG_SZ,
                                    0, 0);
    }

    done:;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetConfig |
 *
 *          Store information about a joystick's configuration.
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.
 *
 *  @parm   JOYREGHWCONFIG | phwc |
 *
 *          Contains information about the joystick capabilities.
 *          This value supercedes the value in the <p pcfg>.
 *          It may be modified if we needed to load the config
 *          info from the saved settings.
 *
 *  @parm   LPCDIJOYCONFIG | pcfg |
 *
 *          Contains information about the joystick configuration.
 *          The caller is assumed to have validated all fields.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structures pointed
 *          to by <p phwc> and <p pjc> are to be written out.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *****************************************************************************/

JOYREGHWVALUES      null_hwv = { 0};

STDMETHODIMP
JoyReg_SetConfig(UINT idJoy, LPJOYREGHWCONFIG phwc,
                 LPCDIJOYCONFIG pcfg, DWORD fl)
{
    HRESULT hres;
    EnterProc(JoyReg_SetConfig, (_ "uppx", idJoy, phwc, pcfg, fl));

    AssertF((fl & ~DIJC_INTERNALSETVALID) == 0);

    if (idJoy < cJoyMax )
    {

        if (fl & DIJC_INREGISTRY)
        {
            HKEY hk;
            DWORD dwOptions = 0;

            hres = JoyReg_OpenConfigKey(idJoy, KEY_SET_VALUE, dwOptions, &hk);

            if (SUCCEEDED(hres))
            {

                if (fl & DIJC_REGHWCONFIGTYPE)
                {
                    hres = JoyReg_SetHWConfig(idJoy, phwc, pcfg, hk);

                    if (FAILED(hres))
                    {
                        goto closedone;
                    }

#ifndef WINNT
                    if (fl & DIJC_UPDATEALIAS)
                    {
                        JoyReg_SetCalibration(idJoy, phwc);
                    }
#endif

                }

#ifndef WINNT
                if (fl & DIJC_CALLOUT)
                {
                    hres = JoyReg_SetConfigValue(
                                                hk, REGSTR_VAL_JOYNOEMCALLOUT, idJoy, REG_SZ,
                                                pcfg->wszCallout, cbX(pcfg->wszCallout));
                    if (FAILED(hres))
                    {
                        hres = S_FALSE;
                        //continue to go
                    }
                }
#endif

                if (fl & DIJC_GAIN)
                {
                    if (ISVALIDGAIN(pcfg->dwGain))
                    {

                        /*
                         *  If restoring to nominal, then the key
                         *  can be deleted; the default value will
                         *  be assumed subsequently.
                         */
                        if (pcfg->dwGain == DI_FFNOMINALMAX)
                        {
                            hres = JoyReg_SetConfigValue(hk,
                                                         TEXT("Joystick%dFFConfiguration"),
                                                         idJoy, REG_SZ, 0, 0);
                        } else
                        {
                            hres = JoyReg_SetConfigValue(hk,
                                                         TEXT("Joystick%dFFConfiguration"),
                                                         idJoy, REG_BINARY,
                                                         &pcfg->dwGain, cbX(pcfg->dwGain));
                        }

                        if (FAILED(hres))
                        {
                            hres = S_FALSE;
                            goto closedone;
                        }
                    } else
                    {
                        RPF("ERROR: SetConfig: Invalid dwGain");
                        hres = E_INVALIDARG;
                        goto closedone;
                    }
                }

                hres = S_OK;

                closedone:;
                RegCloseKey(hk);
            }
        } else
        {
            hres = S_OK;
        }

    } else
    {
        hres = E_FAIL;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | ibJoyPosAxis |
 *
 *          Returns the offset of the <p iAxis>'th joystick axis
 *          in the <t JOYPOS> structure.
 *
 *  @parm   int | iAxis |
 *
 *          The index of the requested axis.  X, Y, Z, R, U and V are
 *          respctively zero through five.
 *
 *  @returns
 *
 *          The offset relative to the structure.
 *
 *****************************************************************************/

#define ibJoyPosAxis(iAxis)                                         \
        (FIELD_OFFSET(JOYPOS, dwX) + cbX(DWORD) * (iAxis))          \

#define pJoyValue(jp, i)                                            \
        (LPDWORD)pvAddPvCb(&(jp), ibJoyPosAxis(i))                  \

/*
 *  The following doesn't do anything at runtime.  It is a compile-time
 *  check that everything is okay.
 */
void INLINE
JoyReg_CheckJoyPosAxis(void)
{
#define CheckAxis(x)    \
        CAssertF(ibJoyPosAxis(iJoyPosAxis##x) == FIELD_OFFSET(JOYPOS, dw##x))

    CheckAxis(X);
    CheckAxis(Y);
    CheckAxis(Z);
    CheckAxis(R);
    CheckAxis(U);
    CheckAxis(V);

#undef CheckAxis
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_IsValidUserValues |
 *
 *          Retermine whether the values are ostensibly valid.
 *
 *  @parm   IN LPCDIJOYUSERVALUES | pjuv |
 *
 *          Contains information about the user joystick configuration.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:
 *          Something looks bad.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_IsValidUserValues(LPCDIJOYUSERVALUES pjuv)
{
    HRESULT hres;
    int iAxis;

    /*
     *  First set up the values to values that are out of range so
     *  that we will fall back to defaults.
     */
    for (iAxis = 0; iAxis < cJoyPosAxisMax; iAxis++)
    {
        if ((int)*pJoyValue(pjuv->ruv.jrvRanges.jpMax, iAxis) < 0)
        {
            RPF("JOYUSERVALUES: Negative jpMax not a good idea");
            goto bad;
        }
        if (*pJoyValue(pjuv->ruv.jrvRanges.jpMin, iAxis) >
            *pJoyValue(pjuv->ruv.jrvRanges.jpMax, iAxis))
        {
            RPF("JOYUSERVALUES: Min > Max not a good idea");
            goto bad;
        }

        if (!fInOrder(0, *pJoyValue(pjuv->ruv.jpDeadZone, iAxis), 100))
        {
            RPF("JOYUSERVALUES: DeadZone > 100 not a good idea");
            goto bad;
        }
    }

    hres = S_OK;

    return hres;

    bad:;
    hres = E_INVALIDARG;
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_GetUserValues |
 *
 *          Obtain information about user settings for the joystick.
 *
 *
 *  @parm   IN OUT LPDIJOYUSERVALUES | pjuv |
 *
 *          Receives information about the user joystick configuration.
 *          The caller is assumed to have validated the
 *          <e DIJOYUSERVALUES.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJU_*> flags specifying which parts
 *          of the <t DIJOYUSERVALUES> structure contain values
 *          which are to be retrieved.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_GetUserValues(LPDIJOYUSERVALUES pjuv, DWORD fl)
{
    HRESULT hres;
    HKEY hk;
    LONG lRc;
    EnterProc(JoyReg_GetUserValues, (_ "px", pjuv, fl));

    hres = S_OK;                    /* If nothing happens, then success */

    if (fl & DIJU_USERVALUES)
    {

        /*
         *  Okay, now get the user settings.
         *
         *  If anything goes wrong, then just limp with the default values.
         */
        lRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_JOYCONFIG,
                           0, KEY_QUERY_VALUE, &hk);
        if (lRc == ERROR_SUCCESS)
        {

            hres = JoyReg_GetValue(hk, REGSTR_VAL_JOYUSERVALUES,
                                   REG_BINARY, &pjuv->ruv, cbX(pjuv->ruv));
            if (SUCCEEDED(hres))
            {
                /*
                 *  Sanity-check the values.  If anything is screwy,
                 *  then fall back to the defaults.
                 */
                hres = JoyReg_IsValidUserValues(pjuv);

            }

            if (FAILED(hres))
            {
                /*
                 *  Oh well.  Just use the default values, then.
                 *
                 *  Stolen from ibmjoy\msjstick.c.
                 */
                ZeroMemory(&pjuv->ruv, cbX(pjuv->ruv));

#define DEFAULT_RANGE_MAX 65535
#define DEFAULT_TIMEOUT   5000
#define DEFAULT_DEADZONE  5

                pjuv->ruv.jrvRanges.jpMax.dwX = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwY = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwZ = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwR = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwU = DEFAULT_RANGE_MAX;
                pjuv->ruv.jrvRanges.jpMax.dwV = DEFAULT_RANGE_MAX;
                pjuv->ruv.jpDeadZone.dwX = DEFAULT_DEADZONE;
                pjuv->ruv.jpDeadZone.dwY = DEFAULT_DEADZONE;
                pjuv->ruv.dwTimeOut = DEFAULT_TIMEOUT;
            }

            RegCloseKey(hk);
        }
    }

    if (fl & DIJU_INDRIVERREGISTRY)
    {
        hres = JoyReg_OpenConfigKey((UINT)-1, KEY_QUERY_VALUE, FALSE, &hk);

        if (SUCCEEDED(hres))
        {

            if (fl & DIJU_GLOBALDRIVER)
            {

                LONG lRc;

                /*
                 *  If it doesn't work, then return the default value
                 *  of "MSANALOG.VXD".  We can't blindly use
                 *  JoyReg_GetValue, because that treats a nonexistent
                 *  value as having a default of the null string.
                 */
                lRc = RegQueryValueEx(hk, REGSTR_VAL_JOYOEMCALLOUT,
                                      0, 0, 0, 0);
                if ((lRc == ERROR_SUCCESS || lRc == ERROR_MORE_DATA) &&
                    SUCCEEDED(
                             hres = JoyReg_GetValue(hk, REGSTR_VAL_JOYOEMCALLOUT,
                                                    REG_SZ, pjuv->wszGlobalDriver,
                                                    cbX(pjuv->wszGlobalDriver))))
                {
                    /* Yay, it worked */
                } else
                {
                    CopyMemory(pjuv->wszGlobalDriver,
                               c_wszDefPortDriver,
                               cbX(c_wszDefPortDriver));
                }

            }

            if (fl & DIJU_GAMEPORTEMULATOR)
            {

                /*
                 *  If it doesn't work, then just return a null string.
                 */
                hres = JoyReg_GetValue(hk, REGSTR_VAL_JOYGAMEPORTEMULATOR,
                                       REG_SZ, pjuv->wszGameportEmulator,
                                       cbX(pjuv->wszGameportEmulator));
                if (FAILED(hres))
                {
                    pjuv->wszGameportEmulator[0] = TEXT('\0');
                }

            }

            RegCloseKey(hk);
        }

    }

    /*
     *  Warning!  CJoy_InitRanges() assumes this never fails.
     */
    hres = S_OK;

    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_SetUserValues |
 *
 *          Store information about user settings for the joystick.
 *
 *
 *  @parm   IN LPCDIJOYUSERVALUES | pjuv |
 *
 *          Contains information about the user joystick configuration.
 *          The caller is assumed to have validated the
 *          <e DIJOYUSERVALUES.dwSize> field.
 *
 *  @parm   DWORD | fl |
 *
 *          Zero or more <c DIJU_*> flags specifying which parts
 *          of the <t DIJOYUSERVALUES> structure contain values
 *          which are to be set.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_SetUserValues(LPCDIJOYUSERVALUES pjuv, DWORD fl)
{
    HRESULT hres = E_FAIL;
    HKEY hk;
    EnterProc(JoyReg_SetUserValues, (_ "px", pjuv, fl));

    if (fl & DIJU_USERVALUES)
    {

        /*
         *  See if the values are sane.
         */
        if (fl & DIJU_USERVALUES)
        {
            hres = JoyReg_IsValidUserValues(pjuv);
            if (FAILED(hres))
            {
                goto done;
            }
        }

        /*
         *  Off to the registry we go.
         */

        hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                               REGSTR_PATH_JOYCONFIG, 
                               DI_KEY_ALL_ACCESS, 
                               REG_OPTION_NON_VOLATILE, 
                               &hk);

        if (SUCCEEDED(hres))
        {

            hres = JoyReg_SetValue(hk, REGSTR_VAL_JOYUSERVALUES,
                                   REG_BINARY, &pjuv->ruv,
                                   cbX(pjuv->ruv));
            RegCloseKey(hk);

            if (FAILED(hres))
            {
                goto done;
            }
        } else
        {
            goto done;
        }
    }

    if (fl & DIJU_INDRIVERREGISTRY)
    {

        hres = JoyReg_OpenConfigKey((UINT)-1, KEY_SET_VALUE, FALSE, &hk);

        if (SUCCEEDED(hres))
        {

            if (fl & DIJU_GLOBALDRIVER)
            {
                /*
                 *  This is a weird key.  The default value is
                 *  "MSANALOG.VXD", so if we get a null string, we
                 *  can't use JoyReg_SetValue, because that will
                 *  delete the key.
                 */
                if (pjuv->wszGlobalDriver[0])
                {
                    hres = JoyReg_SetValue(hk, REGSTR_VAL_JOYOEMCALLOUT,
                                           REG_SZ, pjuv->wszGlobalDriver,
                                           cbX(pjuv->wszGlobalDriver));
                } else
                {
                    LONG lRc;
                    lRc = RegSetValueEx(hk, REGSTR_VAL_JOYOEMCALLOUT, 0,
                                        REG_SZ, (PV)TEXT(""), cbCtch(1));
                    if (lRc == ERROR_SUCCESS)
                    {
                        hres = S_OK;
                    } else
                    {
                        RPF("Unable to write %s to registry",
                            REGSTR_VAL_JOYOEMCALLOUT);
                        hres = E_FAIL;  /* Else, something bad happened */
                    }
                }
                if (FAILED(hres))
                {
                    goto regdone;
                }
            }

            if (fl & DIJU_GAMEPORTEMULATOR)
            {

                hres = JoyReg_SetValue(hk, REGSTR_VAL_JOYGAMEPORTEMULATOR,
                                       REG_SZ, pjuv->wszGameportEmulator,
                                       cbX(pjuv->wszGameportEmulator));
                if (FAILED(hres))
                {
                    goto regdone;
                }
            }

            regdone:;
            RegCloseKey(hk);

        } else
        {
            goto done;
        }
    }

    done:;
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_OpenFFKey |
 *
 *          Given a type key, move to its force feedback subkey.
 *
 *  @parm   HKEY | hkType |
 *
 *          The parent type key.
 *
 *  @parm   REGSAM | sam |
 *
 *          Access level desired.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives created registry key.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: Couldn't open the key.
 *
 *****************************************************************************/

STDMETHODIMP
JoyReg_OpenFFKey(HKEY hkType, REGSAM sam, PHKEY phk)
{
    HRESULT hres;
    EnterProc(JoyReg_OpenFFKey, (_ "xx", hkType, sam));

    *phk = 0;

    if (hkType)
    {
        if (RegOpenKeyEx(hkType, TEXT("OEMForceFeedback"), 0, sam, phk) == 0)
        {
            hres = S_OK;
        } else
        {
            hres = E_FAIL;
        }
    } else
    {
        hres = DIERR_NOTFOUND;
    }

    ExitBenignOleProc();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   TCHAR | CJoyCfg_CharFromType |
 *
 *          Convert a predefined type number to a character.
 *
 *  @func   UINT | CJoyCfg_TypeFromChar |
 *
 *          Convert a character back to a predefined type number.
 *
 *****************************************************************************/

#define JoyCfg_CharFromType(t)     ((TCHAR)(L'0' + t))
#define JoyCfg_TypeFromChar(tch)   ((tch) - L'0')

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | JoyReg_GetPredefTypeInfo |
 *
 *          Obtain information about a predefined joystick type.
 *
 *  @parm   LPCWSTR | pwszType |
 *
 *          Points to the name of the type.  It is known to begin
 *          with a "#".  The remainder has not yet been parsed.
 *
 *  @parm   IN OUT LPDIJOYTYPEINFO | pjti |
 *
 *          Receives information about the joystick type,
 *          already validated.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DITC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjti> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTFOUND>: The joystick type was not found.
 *
 *****************************************************************************/

HRESULT EXTERNAL
JoyReg_GetPredefTypeInfo(LPCWSTR pwszType, LPDIJOYTYPEINFO pjti, DWORD fl)
{
    HRESULT hres;
    UINT itype;
    EnterProcI(JoyReg_GetPredefTypeInfo, (_ "Wpx", pwszType, pjti, fl));

    AssertF(pwszType[0] == L'#');

    itype = JoyCfg_TypeFromChar(pwszType[1]);

    if (fInOrder(JOY_HW_PREDEFMIN, itype, JOY_HW_PREDEFMAX) &&
        pwszType[2] == L'\0')
    {
        /*
         *  No real point in checking the bits in fl, since
         *  setting it up is so easy.
         */
        pjti->hws = c_rghwsPredef[itype - JOY_HW_PREDEFMIN];
        LoadStringW(g_hinst, IDS_PREDEFJOYTYPE + itype,
                    pjti->wszDisplayName, cA(pjti->wszDisplayName));
        pjti->wszCallout[0] = L'\0';

        ZeroX(pjti->clsidConfig);

        pjti->dwFlags1 = 0x0;

        if ( fl & DITC_HARDWAREID )
        {
            lstrcpyW(pjti->wszHardwareId, c_rghwIdPredef[itype-JOY_HW_PREDEFMIN] );
        }

        pjti->dwFlags2 = 0x0;

        pjti->wszMapFile[0] = L'\0';

        hres = S_OK;
    } else
    {
        hres = DIERR_NOTFOUND;
    }

    ExitOleProc();
    return hres;
}


#if 0  //don't delete it now.
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyCfg_GetIDByOemName |
 *
 *          Get the Id by OEMNAME
 *
 *  @parm   IN LPTSTR | szOEMNAME |
 *
 *          String used to find the ID.
 *
 *  @parm   IN LPUNIT | lpID |
 *
 *          The ID to get.
 *
 *  @returns
 *
 *          A COM success code unless the current configuration key could not
 *          be opened, or could not find the OEMNAME.
 *
 *****************************************************************************/

HRESULT EXTERNAL JoyReg_GetIDByOemName( LPTSTR szOemName, PUINT pId )
{
    HRESULT hres = E_FAIL;
    LONG    lRc;
    HKEY    hkCurrCfg;
    UINT    JoyId;
    TCHAR   szTestName[MAX_JOYSTRING];
    TCHAR   szOemNameKey[MAX_JOYSTRING];
    DWORD   cb;

    EnterProcI(JoyReg_GetIDByOemName, (_ "sp", szOemName, pId ));

    hres = JoyReg_OpenConfigKey( (UINT)(-1), KEY_WRITE, REG_OPTION_NON_VOLATILE, &hkCurrCfg );

    if ( SUCCEEDED( hres ) )
    {
        for ( JoyId = 0; (JoyId < 16) || ( lRc == ERROR_SUCCESS ); JoyId++ )
        {
            wsprintf( szOemNameKey, REGSTR_VAL_JOYNOEMNAME, JoyId+1 );
            cb = sizeof( szTestName );
            lRc = RegQueryValueEx( hkCurrCfg, szOemNameKey, 0, NULL, (PBYTE)szTestName, &cb );
            if ( lRc == ERROR_SUCCESS )
            {
                if ( !lstrcmpi( szOemName, szTestName ) )
                {
                    *pId = JoyId;
                    pId ++;
                    hres = S_OK;
                    break;
                }
            }
        }

    } else
    {
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("JoyReg_OpenConfigKey failed code 0x%08x"), hres );
    }

    ExitOleProc();

    return hres;

} /* JoyReg_GetIDByOemName */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dijoytyp.c ===
/*****************************************************************************
 *
 *  DIJoyTyp.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Functions that pull data out of the joystick type key
 *      (wherever it is).
 *
 *  Contents:
 *
 *      ?
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoyType

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CType_OpenIdSubkey |
 *
 *          Given an object ID, attempt to open the subkey that
 *          corresponds to it for reading.
 *
 *  @parm   HKEY | hkType |
 *
 *          The joystick type key, possibly <c NULL> if we don't
 *          have a type key.  (For example, if it was never created.)
 *
 *  @parm   DWORD | dwId |
 *
 *          Object id.
 *
 *  @parm   REGSAM | regsam |
 *
 *          Registry security access mask.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the object key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
    CType_OpenIdSubkey(HKEY hkType, DWORD dwId, REGSAM sam, PHKEY phk)
{
    HRESULT hres;

    EnterProc(CType_OpenIdSubkey, (_ "xx", hkType, dwId));

    *phk = 0;

    if(hkType)
    {
        /*
         *  Worst case is "Actuators\65535" which has length 15.
         */
        TCHAR tsz[32];
        LPCTSTR ptszType;

        if(dwId & DIDFT_AXIS)
        {
            ptszType = TEXT("Axes");
        } else if(dwId & DIDFT_BUTTON)
        {
            ptszType = TEXT("Buttons");
        } else if(dwId & DIDFT_POV)
        {
            ptszType = TEXT("POVs");
        } else if(dwId & DIDFT_NODATA)
        {
            ptszType = TEXT("Actuators");
        } else
        {
            hres = E_NOTIMPL;
            goto done;
        }

        // ISSUE-2001/03/29-timgill Need to scale back for pos vs state
        // MarcAnd -- I believe this means: if you're trying to
        //            look for the X axis, we should use the position
        //            instance, not the velocity one.
        wsprintf(tsz, TEXT("%s\\%u"), ptszType, DIDFT_GETINSTANCE(dwId));

        hres = hresMumbleKeyEx(hkType, tsz, sam, REG_OPTION_NON_VOLATILE, phk);

    } else
    {
        hres = DIERR_NOTFOUND;
    }

    done:;
    if(hres == DIERR_NOTFOUND)
    {
        ExitBenignOleProcPpv(phk);
    } else
    {
        ExitOleProcPpv(phk);
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CType_RegGetObjectInfo |
 *
 *          Given an object ID, look into the registry subkey for the
 *          object and extract anything we can find.
 *
 *          If we find nothing, then do nothing.
 *
 *  @parm   HKEY | hkType |
 *
 *          The joystick type key, possibly <c NULL> if we don't
 *          have a type key.  (For example, if it was never created.)
 *
 *  @parm   DWORD | dwId |
 *
 *          Object id.
 *
 *  @parm   LPDIDEVICEOBJECTINSTANCEW | pdidoiW |
 *
 *          Structure to receive information.  The
 *          <e DIDEVICEOBJECTINSTANCE.guidType>,
 *          <e DIDEVICEOBJECTINSTANCE.dwOfs>,
 *          and
 *          <e DIDEVICEOBJECTINSTANCE.dwType>
 *          <e DIDEVICEOBJECTINSTANCE.dwFlags>
 *          fields have already been filled in so we should only not override 
 *          these with default data.
 *
 *****************************************************************************/

void EXTERNAL
    CType_RegGetObjectInfo(HKEY hkType, DWORD dwId,
                           LPDIDEVICEOBJECTINSTANCEW pdidoiW)
{
    HRESULT hres;
    HKEY hk;
    EnterProc(CType_RegKeyObjectInfo, (_ "xx", hkType, dwId));

    /*
     *  Extract information about this item from the registry.
     */
    hres = CType_OpenIdSubkey(hkType, dwId, KEY_QUERY_VALUE, &hk);

    if(SUCCEEDED(hres))
    {

        DIOBJECTATTRIBUTES attr;

        /*
         *  Read the regular and HID attributes.
         */

        hres = JoyReg_GetValue(hk, TEXT("Attributes"),
                               REG_BINARY, &attr,
                               cbX(attr));

        if(SUCCEEDED(hres))
        {
            /*
             *  Copy the bit fields.
             *  PREFIX warns (333540) that attr.dwFlags is not initialized 
             *  however JoyReg_GetValue zeroes any part of the buffer after 
             *  the bytes read from the registry if the buffer size is larger 
             *  than what was read.
             */
            pdidoiW->dwFlags |= (attr.dwFlags & ~DIDOI_ASPECTMASK);

            /*
             *  Don't add FF if the dwId did not have it. 
             *  (See comment on FF attrs below for why.)
             */
            if( ( dwId & ( DIDFT_FFEFFECTTRIGGER | DIDFT_FFACTUATOR ) ) == 0 )
            {
                pdidoiW->dwFlags &= ~( DIDOI_FFACTUATOR | DIDOI_FFEFFECTTRIGGER );
            }
                

            /*
             *  Copy the aspect, but don't change
             *  the aspect from "known" to "unknown".  If the
             *  registry doesn't have an aspect, then use the
             *  aspect we got from the caller.
             */
            if((attr.dwFlags & DIDOI_ASPECTMASK) != DIDOI_ASPECTUNKNOWN)
            {
                pdidoiW->dwFlags = (pdidoiW->dwFlags & ~DIDOI_ASPECTMASK) |
                                   (attr.dwFlags & DIDOI_ASPECTMASK);
            }
        }

        /*
         *  If the caller wants force feedback info,
         *  then get it.
         */
        if(pdidoiW->dwSize >= cbX(DIDEVICEOBJECTINSTANCE_DX5W))
        {
            /*
             *  Only copy the usages if they are valid.
             *  JoyReg_GetValue zeros any buffer beyond what is read.
             */
            if(SUCCEEDED(hres) && attr.wUsagePage && attr.wUsage )
            {
                pdidoiW->wUsagePage = attr.wUsagePage;
                pdidoiW->wUsage = attr.wUsage;
            }

            /*
             *  Only try to read the FF attributes if the object supports FF
             *  This may save time but is primarily to allow us to ignore FF 
             *  attributes in the registry for objects (such as FF driving 
             *  controller pedals) which IHVs mark incorrectly.
             */
            if( dwId & ( DIDFT_FFEFFECTTRIGGER | DIDFT_FFACTUATOR ) )
            {
                /*
                 *  Assert that we can read the DIFFOBJECTATTRIBUTES
                 *  directly into the DIDEVICEOBJECTINSTANCE_DX5.
                 */
                CAssertF(FIELD_OFFSET(DIFFOBJECTATTRIBUTES,
                                      dwFFMaxForce) == 0);
                CAssertF(FIELD_OFFSET(DIFFOBJECTATTRIBUTES,
                                      dwFFForceResolution) == 4);
                CAssertF(FIELD_OFFSET(DIDEVICEOBJECTINSTANCE_DX5,
                                      dwFFMaxForce) + 4 ==
                         FIELD_OFFSET(DIDEVICEOBJECTINSTANCE_DX5,
                                      dwFFForceResolution));
                CAssertF(cbX(DIFFOBJECTATTRIBUTES) == 8);

                /*
                 *  If this doesn't work, gee that's too bad.
                 *  JoyReg_GetValue will zero-fill the error parts.
                 */
                JoyReg_GetValue(hk, TEXT("FFAttributes"),
                                REG_BINARY, &pdidoiW->dwFFMaxForce,
                                cbX(DIFFOBJECTATTRIBUTES));
            }
            else
            {
                AssertF( ( pdidoiW->dwFFMaxForce | pdidoiW->dwFFForceResolution ) == 0 );
            }
        }

        /*
         *  Read the optional custom name.
         *
         *  Note that JoyReg_GetValue(REG_SZ) uses
         *  RegQueryStringValueW, which sets the
         *  string to null on error so we don't have to.
         */
        hres = JoyReg_GetValue(hk, 0, REG_SZ,
                               pdidoiW->tszName, cbX(pdidoiW->tszName));

        if(SUCCEEDED(hres))
        {
        } else
        {
            AssertF(pdidoiW->tszName[0] == L'\0');
        }

        RegCloseKey(hk);
    } else
    {
        AssertF(pdidoiW->tszName[0] == L'\0');
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CType_RegGetTypeInfo |
 *
 *          Given an object ID, look into the registry subkey for the
 *          object and extract attribute bits that should be OR'd
 *          into the object ID.
 *
 *          This needs to be done during device initialization to
 *          establish the attributes in the data format so that
 *
 *          1.  <mf IDirectInputDevice::EnumObjects> filters properly, and
 *
 *          2.  >mf IDirectInputEffect::SetParameters> can validate properly.
 *
 *  @parm   HKEY | hkType |
 *
 *          The joystick type key, possibly <c NULL> if we don't
 *          have a type key.  (For example, if it was never created.)
 *
 *  @parm   LPDIOBJECTDATAFORMAT | podf |
 *
 *          Structure to receive more information.  The
 *          <e DIOBJECTDATAFORMAT.dwType> field identifies the object.
 *
 *          On return the
 *          <e DIOBJECTDATAFORMAT.dwType>
 *          and
 *          <e DIOBJECTDATAFORMAT.dwFlags>
 *          fields are updated.
 *
 *****************************************************************************/

void EXTERNAL
    CType_RegGetTypeInfo(HKEY hkType, LPDIOBJECTDATAFORMAT podf, BOOL fPidDevice)
{
    HRESULT hres;
    HKEY hk;
    EnterProc(CType_RegKeyObjectInfo, (_ "xx", hkType, podf->dwType));

    hres = CType_OpenIdSubkey(hkType, podf->dwType, KEY_QUERY_VALUE, &hk);

    if(SUCCEEDED(hres))
    {
        DWORD dwFlags;

        CAssertF(FIELD_OFFSET(DIOBJECTATTRIBUTES, dwFlags) == 0);

        hres = JoyReg_GetValue(hk, TEXT("Attributes"),
                               REG_BINARY, &dwFlags, cbX(dwFlags));

        if(SUCCEEDED(hres))
        {
            /*
             *  Propagate the attributes into the type code.
             */
            CAssertF(DIDOI_FFACTUATOR == DIDFT_GETATTR(DIDFT_FFACTUATOR));
            CAssertF(DIDOI_FFEFFECTTRIGGER
                     == DIDFT_GETATTR(DIDFT_FFEFFECTTRIGGER));

            /*
             *  PREFIX warns (333539) that dwFlags is not initialized however 
             *  JoyReg_GetValue zeroes any part of the buffer after the bytes 
             *  read from the registry if the buffer size is larger than what 
             *  was read.
             */
            podf->dwType |= DIDFT_MAKEATTR(dwFlags);

            podf->dwFlags |= (dwFlags & ~DIDOI_ASPECTMASK);

            /*
             *  Copy the aspect, but don't change
             *  the aspect from "known" to "unknown".  If the
             *  registry doesn't have an aspect, then use the
             *  aspect we got from the caller.
             */
            if((dwFlags & DIDOI_ASPECTMASK) != DIDOI_ASPECTUNKNOWN)
            {
                podf->dwFlags = (podf->dwFlags & ~DIDOI_ASPECTMASK) |
                                (dwFlags & DIDOI_ASPECTMASK);
            }
        }

        RegCloseKey(hk);
    }else
    {
#ifndef WINNT
        // Post Dx7Gold Patch
        // This is for Win9x only.
        // On Win9x, a device that is being accessed through the vjoyd path
        // will not get forces, as the attributes necessary for FF have not
        // been appropriately marked.

        // THe following code will mark the

        DWORD dwFlags  = DIDFT_GETATTR( podf->dwType & ~DIDFT_ATTRMASK )
                        | ( podf->dwFlags & ~DIDOI_ASPECTMASK);

        if(   dwFlags != 0x0
           && fPidDevice )
        {
            hres = CType_OpenIdSubkey(hkType, podf->dwType, DI_KEY_ALL_ACCESS, &hk);

            if(SUCCEEDED(hres) )
            {

                hres = JoyReg_SetValue(hk, TEXT("Attributes"),
                                   REG_BINARY, &dwFlags, cbX(dwFlags));

                RegCloseKey(hk);
            }
         }
#endif // ! WINNT
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CType_MakeGameCtrlName |
 *
 *          Make a game controller name from the attributes of the controller.
 *          Used as a last resort when a name is needed but none is available.
 *
 *  @parm   PWCHAR | wszName |
 *
 *          Output buffer where name will be generated.
 *
 *  @parm   DWORD | dwType |
 *
 *          DI8DEVTYPE value for the controller.
 *
 *  @parm   DWORD | dwAxes |
 *
 *          The number of axes the device has.
 *
 *  @parm   DWORD | dwButtons |
 *
 *          The numer of buttons the device has.
 *
 *  @parm   DWORD | dwPOVs |
 *
 *          The number of POVs the device has.
 *
 *****************************************************************************/

void EXTERNAL
CType_MakeGameCtrlName
( 
    PWCHAR  wszOutput, 
    DWORD   dwDevType,
    DWORD   dwAxes,
    DWORD   dwButtons,
    DWORD   dwPOVs
)
{
    TCHAR tsz[64];
    TCHAR tszPOV[64];
    TCHAR tszFormat[64];
#ifndef UNICODE
    TCHAR tszOut[cA(tsz)+cA(tszFormat)+cA(tszPOV)];
#endif

    /* tszFormat = %d axis, %d button %s */
    LoadString(g_hinst, IDS_TEXT_TEMPLATE, tszFormat, cA(tszFormat));

    /* tsz = joystick, gamepad, etc. */

    if( ( GET_DIDEVICE_TYPE( dwDevType ) >= DI8DEVTYPE_JOYSTICK )
     && ( GET_DIDEVICE_TYPE( dwDevType ) <= DI8DEVTYPE_FLIGHT ) )
    {
        LoadString(g_hinst, GET_DIDEVICE_TYPE( dwDevType ) + IDS_PLAIN_STICK - DI8DEVTYPE_JOYSTICK,
                            tsz, cA(tsz));
    }
    else if( GET_DIDEVICE_TYPEANDSUBTYPE( dwDevType ) 
          == MAKE_DIDEVICE_TYPE( DI8DEVTYPE_SUPPLEMENTAL, DI8DEVTYPESUPPLEMENTAL_HEADTRACKER ) )
    {
        LoadString(g_hinst, IDS_HEAD_TRACKER, tsz, cA(tsz));
    }
    else 
    {
        LoadString(g_hinst, IDS_DEVICE_NAME, tsz, cA(tsz));
    }

    if( dwPOVs )
    {
        LoadString(g_hinst, IDS_WITH_POV, tszPOV, cA(tszPOV));
    }
    else
    {
        tszPOV[0] = TEXT( '\0' );
    }

#ifdef UNICODE
    wsprintfW(wszOutput, tszFormat, dwAxes, dwButtons, tsz, tszPOV);
#else
    wsprintfA(tszOut, tszFormat, dwAxes, dwButtons, tsz, tszPOV);
    TToU(wszOutput, cA(tszOut), tszOut);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dijoyhid.c ===
/*****************************************************************************
 *
 *  DIHid.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      WINNT implementation of JOYHID.
 *
 *  Contents:
 *
 *      DIWdm_JoyHidMapping
 *      JoyReg_JoyIdToDeviceInterface
 *
 *****************************************************************************/

#include "dinputpr.h"

#undef  sqfl
#define sqfl sqflWDM

#include "dijoyhid.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT EXTERNAL | DIWdm_JoyHidMapping |
 *
 *          Does the work done by JoyHid on Win9x. This function
 *          maps the Joystick ID to a HID device and talks to the
 *          HID device to obtain its capabilities.
 *
 *  @parm   IN int | idJoy |
 *
 *          The Id of the joystick to be located.
 *
 *  @parm   OUT PVXDINITPARAMS | pvip | OPTIONAL
 *          Address of a VXDINITPARAMS structure that is filled out
 *          by this function. This is an optional parameter
 *          and can be NULL
 *
 *  @parm   OUT LPDIJOYCONFIG | pcfg  |
 *          Address of a DIJOYCONFIG structure that is filled out
 *          by this function. This is an optional parameter.
 *
 *  @parm   IN OUT LPDIJOYTYPEINFO | pdijti | 
 *          Address of a DIJOYTYPEINFO structure that is filled out
 *          by this function. This is an optional parameter.
 *          If passed in, the hws.dwFlags is used to initialize the 
 *          same flags in the DIJOYCONFIG structure.
 *
 *  @returns    HRESULT
 *          Returns a COM error code
 *
 *****************************************************************************/
/*
 *  ISSUE-2001/03/29-timgill function uses too much stack space
 *  This function uses over 4K of stack space! 
 *  This causes the Win9x build to choke looking for _chkstk.
 *  Hack by forcing caller to pass pcfg and pdijti
 */
HRESULT EXTERNAL
    DIWdm_JoyHidMapping
    (
    IN  int             idJoy,
    OUT PVXDINITPARMS   pvip,   OPTIONAL
    OUT LPDIJOYCONFIG   pcfg,   OPTIONAL
    IN OUT LPDIJOYTYPEINFO pdijti 
    )
{
    HRESULT         hres;
    PHIDDEVICEINFO  phdi;
    VXDINITPARMS    vip;
//    DIJOYCONFIG     cfg;
//    DIJOYTYPEINFO   dijti;
    DWORD           wCaps = 0;
    DIPROPINFO      propi;                            
    DIPROPSTRING    dips;
    DIPROPDWORD     dipd;
    BOOL            fBadCalData = FALSE;

    EnterProc(DIWdm_JoyHidMapping, (_ "uxx", idJoy, pvip, pcfg));

    // AssertF(InCrit());

    if( pvip == NULL )
    {
        ZeroX(vip);
        vip.dwSize = cbX(vip);
        pvip = &vip;
    }

//    AssertF(pcfg != NULL );
//    if( pcfg == NULL )
//    {
//        ZeroX(cfg);
//        cfg.dwSize = cbX(cfg);
//        pcfg = & cfg;
//    }

    AssertF(pdijti != NULL );
//    if(pdijti == NULL )
//    {
//        ZeroX(dijti);
//        dijti.dwSize = cbX(dijti);
//        pdijti = &dijti;
//    }

    /*
     *  Copy the type info because JOY_HWS_ISYOKE, JOY_HWS_ISCARCTRL and 
     *  JOY_HWS_ISHEADTRACKER have no simple equivalents in HID so would 
     *  otherwise get lost.  No harm done if it's zero.
     *  Note, the dwFlags is built in pvip then copied elsewhere.
     */
    pvip->dwFlags = pdijti->hws.dwFlags;

    phdi = phdiFindJoyId(idJoy);
    if( phdi != NULL )
    {
        IDirectInputDeviceCallback *pdcb;

        hres = CHid_New(0, &phdi->guid,
                        &IID_IDirectInputDeviceCallback,
                        (PPV)&pdcb);
        if( SUCCEEDED(hres) )
        {
            DIDEVCAPS dc;

            hres = pdcb->lpVtbl->GetCapabilities(pdcb, &dc );
            if( SUCCEEDED(hres) )
            {
                DIDEVICEINSTANCEW didi;

                didi.dwSize = cbX(didi);

                hres = pdcb->lpVtbl->GetDeviceInfo(pdcb, &didi);
                if( SUCCEEDED(hres) )
                {
                    LPDIDATAFORMAT pdf;

                    hres = pdcb->lpVtbl->GetDataFormat(pdcb, &pdf);
                    if( SUCCEEDED(hres) )
                    {
                        DIPROPCAL dipc;
                        DWORD axis, pov = 0;

                        ZeroBuf(pvip->Usages, 6 * cbX(pvip->Usages[0]));

                        hres = pdcb->lpVtbl->MapUsage(pdcb, CheckHatswitch->dwUsage, &propi.iobj);
                        if(SUCCEEDED(hres) )
                        {
                            pvip->dwPOV1usage      = CheckHatswitch->dwUsage;
                            pvip->dwFlags         |= CheckHatswitch->dwFlags;
                            wCaps                 |= CheckHatswitch->dwCaps;

                            propi.pguid = DIPROP_GRANULARITY;
                            propi.dwDevType = pdf->rgodf[propi.iobj].dwType;
                            hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dipd.diph);
                            if( SUCCEEDED( hres ) )
                            {
                                if( dipd.dwData >= 9000 ) // 4 directional POV
                                {
                                    wCaps |= JOYCAPS_POV4DIR;
                                    
                                    if( pcfg != NULL ) {
                                        pcfg->hwc.hwv.dwPOVValues[JOY_POVVAL_FORWARD]   = JOY_POVFORWARD;
                                        pcfg->hwc.hwv.dwPOVValues[JOY_POVVAL_BACKWARD]  = JOY_POVBACKWARD;
                                        pcfg->hwc.hwv.dwPOVValues[JOY_POVVAL_LEFT]      = JOY_POVLEFT;
                                        pcfg->hwc.hwv.dwPOVValues[JOY_POVVAL_RIGHT]     = JOY_POVRIGHT;
                                    }
                                } else // Continuous POV
                                {
                                    wCaps |= JOYCAPS_POVCTS;
                                }
                            }
                        } 

                        for( axis = 0; axis < cA(AxesUsages)-1; axis++ ) 
                        {
                            USAGES *pUse = &AxesUsages[axis];
                            DWORD   dwCurAxisPos = pUse->dwAxisPos;

                            if( pvip->Usages[dwCurAxisPos] != 0) {
                                continue;
                            } else {
                            	int i;
                            	BOOL bHasUsed = FALSE;
                            	
                            	for( i = 0; i < (int)dwCurAxisPos; i++ ) {
                                    if( pvip->Usages[i] == pUse->dwUsage ) {
                                        bHasUsed = TRUE;
                                        break;
                                    }
                                }
                                
                                if( bHasUsed ) {
                                    continue;
                                }
                            }
                            
                            hres = pdcb->lpVtbl->MapUsage(pdcb, pUse->dwUsage, &propi.iobj);
                            if(SUCCEEDED(hres) )
                            {
                                pvip->Usages[dwCurAxisPos] = pUse->dwUsage;
                                pvip->dwFlags     |= pUse->dwFlags;
                                wCaps             |= pUse->dwCaps;

                                propi.pguid = DIPROP_CALIBRATION;
                                propi.dwDevType = pdf->rgodf[propi.iobj].dwType;
                                hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dipc.diph);
                                if( SUCCEEDED(hres) && pcfg != NULL )
                                {

#ifdef WINNT
                                    (&pcfg->hwc.hwv.jrvHardware.jpMin.dwX)[dwCurAxisPos] 
                                        = dipc.lMin;
                                    (&pcfg->hwc.hwv.jrvHardware.jpMax.dwX)[dwCurAxisPos] 
                                        = dipc.lMax;
                                    (&pcfg->hwc.hwv.jrvHardware.jpCenter.dwX)[dwCurAxisPos] 
                                        = CCal_Midpoint(dipc.lMin, dipc.lMax);
#else
                                    DIPROPRANGE diprp;
                                    DIPROPRANGE diprl;
                                    
                                    propi.pguid = DIPROP_PHYSICALRANGE;
                                    propi.dwDevType = pdf->rgodf[propi.iobj].dwType;
                                    hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &diprp.diph);
                                    if( SUCCEEDED( hres ) )
                                    {
                                        propi.pguid = DIPROP_LOGICALRANGE;
                                        propi.dwDevType = pdf->rgodf[propi.iobj].dwType;
                                        hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &diprl.diph);
                                        if( SUCCEEDED( hres ) )
                                        {
                                            LONG lMin, lMax;

                                            lMin = (&pcfg->hwc.hwv.jrvHardware.jpMin.dwX)[dwCurAxisPos] 
                                                = CHid_CoordinateTransform( (PLMINMAX)&diprp.lMin, (PLMINMAX)&diprl.lMin, dipc.lMin );
                                            lMax = (&pcfg->hwc.hwv.jrvHardware.jpMax.dwX)[dwCurAxisPos] 
                                                = CHid_CoordinateTransform( (PLMINMAX)&diprp.lMin, (PLMINMAX)&diprl.lMin, dipc.lMax );
                                            (&pcfg->hwc.hwv.jrvHardware.jpCenter.dwX)[dwCurAxisPos] 
                                                = CCal_Midpoint(lMin, lMax);

                                            if( lMin >= lMax ) {
                                                fBadCalData = TRUE;
                                                break;
                                            }
                                        }

                                    }
#endif

                                }
                            }
                        } //for (axis=0...
                    }  //GetDataFormat

                    pvip->hres                  =   S_OK;
                    pvip->dwSize                =   cbX(*pvip);          /* Which version of VJOYD are we? */
                    pvip->dwFlags              |=   JOY_HWS_AUTOLOAD;    /* Describes the device */

                    if(didi.wUsage ==  HID_USAGE_GENERIC_GAMEPAD) {
                        pvip->dwFlags |= JOY_HWS_ISGAMEPAD;
                    }

                    pvip->dwId                  =   idJoy;               /* Internal joystick ID */
                    pvip->dwFirmwareRevision    =   dc.dwFirmwareRevision;
                    pvip->dwHardwareRevision    =   dc.dwHardwareRevision;
                    pvip->dwFFDriverVersion     =   dc.dwFFDriverVersion;
                    pvip->dwFilenameLengths     =   lstrlen(phdi->pdidd->DevicePath);
                    pvip->pFilenameBuffer       =   phdi->pdidd->DevicePath;

                    //pvip->Usages[6];
                    //pvip->dwPOV1usage =   0x0;
                    pvip->dwPOV2usage =   0x0;
                    pvip->dwPOV3usage =   0x0;

                    /* Fill all fields of cfg */

                    if( pcfg != NULL ) {
                        AssertF(pcfg->dwSize          ==   cbX(*pcfg) );
                        pcfg->guidInstance            =   phdi->guid;
    
                        pcfg->hwc.hws.dwNumButtons    =   dc.dwButtons;
                        pcfg->hwc.hws.dwFlags         =   pvip->dwFlags;
    
                        //pcfg.hwc.hwv.jrvHardware
                        //pcfg.hwc.hwv.dwPOVValues
    
                        pcfg->hwc.hwv.dwCalFlags      =   0x0;
    
                        if( ( LOWORD(phdi->guidProduct.Data1) == MSFT_SYSTEM_VID )
                          &&( ( HIWORD(phdi->guidProduct.Data1) >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN) 
                            &&( HIWORD(phdi->guidProduct.Data1) < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
                        {
                            pcfg->hwc.dwType          =    HIWORD(phdi->guidProduct.Data1) - MSFT_SYSTEM_PID;
                            pcfg->hwc.dwUsageSettings =    JOY_US_PRESENT | JOY_US_VOLATILE;
                        }
                        else
                        {
                            /*
                             *  This value really does not matter much but ideally 
                             *  should be greater than or equal to JOY_HW_PREDEFMAX
                             *  Add idJoy for best compatiblity with the old CPLs.
                             */
                            pcfg->hwc.dwType          =    idJoy + JOY_HW_PREDEFMAX;
                            pcfg->hwc.dwUsageSettings =    JOY_US_PRESENT | JOY_US_VOLATILE | JOY_US_ISOEM;
                        }
                        
                        if(pcfg && pvip->Usages[ecRz]) {
                            pcfg->hwc.dwUsageSettings |= JOY_US_HASRUDDER;
                        }
    
                        pcfg->hwc.dwReserved          =    0x0;
    
                        /*
                         *  Default gain to nominal max so it does not get written
                         *  to the registry unless it has some other value.
                         */
                        pcfg->dwGain                  =    DI_FFNOMINALMAX;
    
                        propi.pguid     = DIPROP_FFGAIN;
                        propi.dwDevType = DIPH_DEVICE;
                        propi.iobj      = 0xFFFFFFFF;
                        hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dipd.diph);
                        if( SUCCEEDED(hres) )
                        {
                            pcfg->dwGain  =  dipd.dwData;
                        } else
                        {
                            // Failure to get gain is not crutial
                            hres = S_OK;     
                        }
    
    
                        if( pcfg->hwc.dwType >= JOY_HW_PREDEFMAX )
                        {
        #ifndef UNICODE
                            char szType[20];
        #endif
                            /*
                             * This should work, but it doesn't in Win98, bug!
                             *
                             *  wsprintfW(pcfg->wszType, L"VID_%04X&PID_%04X",
                             *    LOWORD(didi.guidProduct.Data1), HIWORD(didi.guidProduct.Data1));
                             */
        
        #ifdef UNICODE
                            wsprintf(pcfg->wszType, VID_PID_TEMPLATE,
                                LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
        #else
                            wsprintf(szType, VID_PID_TEMPLATE,
                                LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
                            AToU(pcfg->wszType, cA(pcfg->wszType), szType);
        #endif
                        }
                        else
                        {
                            /*
                             *  Predefined types do not have type strings for the 
                             *  uses the callers of this function need.
                             */
                            ZeroX(pcfg->wszType);
                        }
    
#ifdef WINNT
                        // No callout on NT
                        ZeroX(pcfg->wszCallout);
#else
                        lstrcpyW( pcfg->wszCallout, L"joyhid.vxd" );
#endif
                    } // end of filling pcfg's fields
    
    
                    pdijti->dwSize            = cbX(*pdijti);
                    pdijti->hws.dwNumButtons  = dc.dwButtons;
                    pdijti->hws.dwFlags       = pvip->dwFlags;
                    ZeroX(pdijti->clsidConfig);


                    propi.pguid     = DIPROP_INSTANCENAME;
                    propi.dwDevType = DIPH_DEVICE;
                    propi.iobj      = 0xFFFFFFFF;
                    hres = pdcb->lpVtbl->GetProperty(pdcb, &propi, &dips.diph);

                    if( hres != S_OK && lstrlenW(pdijti->wszDisplayName) != 0x0 )
                    {
                        // Failure to get friendly name
                        // We will try and use the OEM name from the registry
                        lstrcpyW(dips.wsz, pdijti->wszDisplayName);                     
                        //pdcb->lpVtbl->SetProperty(pdcb, &propi, &dips.diph);

                    }else if( SUCCEEDED(hres) )
                    {
                        // Use friendly name in the registry 
                        lstrcpyW(pdijti->wszDisplayName, dips.wsz);
                        hres = S_OK;
                    }
                } // GetDeviceInfo FAILED
            } // GetCapabilities FAILED

            Invoke_Release(&pdcb);
        }
    } else // No HID device for JoyID
    {
        hres = E_FAIL;
    }

    if( fBadCalData ) {
        hres = E_FAIL;
    }

    ExitProcX(hres);
    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyReg_JoyIdToDeviceInterface |
 *
 *          Given a joystick ID number, obtain the device interface
 *          corresponding to it.
 *
 *  @parm   UINT | idJoy |
 *
 *          Joystick ID number, zero-based.
 *
 *  @parm   PVXDINITPARMS | pvip |
 *
 *          Receives init parameters from the driver.
 *
 *  @parm   LPTSTR | ptszBuf |
 *
 *          A buffer of size <c MAX_PATH> in which the device interface
 *          path is built.
 *
 *  @returns
 *          A pointer to the part of the <p ptszBuf> buffer that
 *          contains the actual device interface path.
 *
 *****************************************************************************/

LPTSTR EXTERNAL
    JoyReg_JoyIdToDeviceInterface_NT
    (
    IN  UINT idJoy,
    OUT PVXDINITPARMS pvip,
    OUT LPTSTR ptszBuf
    )
{
    HRESULT hres;
    DIJOYCONFIG     cfg;
    DIJOYTYPEINFO   dijti;

    DllEnterCrit();

    ZeroX(cfg);
    ZeroX(dijti);

    cfg.dwSize = cbX(cfg);
    dijti.dwSize = cbX(dijti);

    hres = DIWdm_JoyHidMapping(idJoy, pvip, &cfg, &dijti );

    if( SUCCEEDED(hres ) )
    {
        AssertF( lstrlen(pvip->pFilenameBuffer) < MAX_PATH );
        lstrcpy(ptszBuf, pvip->pFilenameBuffer);
    }

    DllLeaveCrit();

    return ptszBuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dijoycfg.c ===
/*****************************************************************************
*
*  DIJoyCfg.c
*
*  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
*
*  Abstract:
*
*      IDirectInputJoyConfig8
*
*  Contents:
*
*      CJoyCfg_New
*
*****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflJoyCfg


BOOL  fVjoydDeviceNotExist = TRUE;
#ifdef WINNT
WCHAR wszDITypeName[128];
#endif

    #pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *      WARNING!  If you add a secondary interface, you must also change
 *      CJoyCfg_New!
 *
 *****************************************************************************/

Primary_Interface(CJoyCfg, IDirectInputJoyConfig8);

Interface_Template_Begin(CJoyCfg)
Primary_Interface_Template(CJoyCfg, IDirectInputJoyConfig8)
Interface_Template_End(CJoyCfg)

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CJoyCfg |
 *
 *          The <i IDirectInputJoyConfig8> object.  Note that this is
 *          aggregated onto the main <i IDirectInput> object.
 *
 *  @field  IDirectInputJoyConfig8 | djc |
 *
 *          The object (containing vtbl).
 *
 *  @field  BOOL | fAcquired:1 |
 *
 *          Set if joystick configuration has been acquired.
 *
 *  @field  BOOL | fCritInited:1 |
 *
 *          Set if the critical section has been initialized.
 *
 *  @field  HKEY | hkTypesW |
 *
 *          Read/write key to access the joystick types.
 *          This key is created only while acquired.
 *
 *  @field  DWORD | idJoyCache |
 *
 *          The identifier of the joystick in the effect shepherd cache,
 *          if there is anything in the cache at all.
 *
 *  @field  IDirectInputEffectShepherd * | pes |
 *
 *          The cached effect shepherd itself.
 *
 *  @field  LONG | cCrit |
 *
 *          Number of times the critical section has been taken.
 *          Used only in XDEBUG to check whether the caller is
 *          releasing the object while another method is using it.
 *
 *  @field  DWORD | thidCrit |
 *
 *          The thread that is currently in the critical section.
 *          Used only in DEBUG for internal consistency checking.
 *
 *  @field  CRITICAL_SECTION | crst |
 *
 *          Object critical section.  Must be taken when accessing
 *          volatile member variables.
 *
 *****************************************************************************/

typedef struct CJoyCfg
{

    /* Supported interfaces */
    IDirectInputJoyConfig8 djc;

    BOOL fAcquired:1;
    BOOL fCritInited:1;

    HKEY hkTypesW;
    HWND hwnd;

    DWORD discl;

    DWORD idJoyCache;
    LPDIRECTINPUTEFFECTSHEPHERD pes;

    RD(LONG cCrit;)
    D(DWORD thidCrit;)
    CRITICAL_SECTION crst;

} CJoyCfg, JC, *PJC;

typedef LPDIRECTINPUTJOYCONFIG8 PDJC;


    #define ThisClass CJoyCfg
    #define ThisInterface  IDirectInputJoyConfig8
    #define ThisInterfaceT IDirectInputJoyConfig8

/*****************************************************************************
 *
 *      Forward references
 *
 *      Not really needed; just a convenience, because Finalize
 *      calls Unacquire to clean up in the case where the caller forgot.
 *
 *****************************************************************************/

STDMETHODIMP CJoyCfg_InternalUnacquire(PV pdd);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   TCHAR | CJoyCfg_CharFromType |
 *
 *          Convert a predefined type number to a character.
 *
 *  @func   UINT | CJoyCfg_TypeFromChar |
 *
 *          Convert a character back to a predefined type number.
 *
 *****************************************************************************/

    #define CJoyCfg_CharFromType(t)     ((TCHAR)(L'0' + t))
    #define CJoyCfg_TypeFromChar(tch)   ((tch) - L'0')

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputJoyConfig8 | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *****************************************************************************/

void INLINE
    CJoyCfg_EnterCrit(PJC this)
{
    EnterCriticalSection(&this->crst);
    D(this->thidCrit = GetCurrentThreadId());
    RD(InterlockedIncrement(&this->cCrit));
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method void | IDirectInputJoyConfig8 | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *****************************************************************************/

void INLINE
    CJoyCfg_LeaveCrit(PJC this)
{
    #ifdef XDEBUG
    AssertF(this->cCrit);
    AssertF(this->thidCrit == GetCurrentThreadId());
    if(InterlockedDecrement(&this->cCrit) == 0)
    {
        D(this->thidCrit = 0);
    }
    #endif
    LeaveCriticalSection(&this->crst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  BOOL | CJoyCfg | InCrit |
 *
 *          Nonzero if we are in the critical section.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *****************************************************************************/

    #ifdef DEBUG

BOOL INTERNAL
    CJoyCfg_InCrit(PJC this)
{
    return this->cCrit && this->thidCrit == GetCurrentThreadId();
}

    #endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | IsAcquired |
 *
 *          Check that the device is acquired.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @returns
 *
 *          Returns
 *          <c S_OK> if all is well, or <c DIERR_NOTACQUIRED> if
 *          the device is not acquired.
 *
 *
 *****************************************************************************/

    #ifndef XDEBUG
\
        #define CJoyCfg_IsAcquired_(pdd, z)                                 \
       _CJoyCfg_IsAcquired_(pdd)                                    \

    #endif

    HRESULT INLINE
    CJoyCfg_IsAcquired_(PJC this, LPCSTR s_szProc)
{
    HRESULT hres;

    if(this->fAcquired)
    {
        hres = S_OK;
    } else
    {
        RPF("ERROR %s: Not acquired", s_szProc);
        hres = DIERR_NOTACQUIRED;
    }
    return hres;
}

    #define CJoyCfg_IsAcquired(pdd)                                     \
        CJoyCfg_IsAcquired_(pdd, s_szProc)                          \


/*****************************************************************************
 *
 *      CJoyCfg::QueryInterface   (from IUnknown)
 *      CJoyCfg::AddRef           (from IUnknown)
 *      CJoyCfg::Release          (from IUnknown)
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @returns
 *
 *      Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | QIHelper |
 *
 *      We don't have any dynamic interfaces and simply forward
 *      to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *      The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *      Receives a pointer to the obtained interface.
 *
 *****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

    #ifdef DEBUG

Default_QueryInterface(CJoyCfg)
Default_AddRef(CJoyCfg)
Default_Release(CJoyCfg)

    #else

        #define CJoyCfg_QueryInterface   Common_QueryInterface
        #define CJoyCfg_AddRef           Common_AddRef
        #define CJoyCfg_Release          Common_Release

    #endif

    #define CJoyCfg_QIHelper         Common_QIHelper
    #define CJoyCfg_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | InternalUnacquire |
 *
 *          Do the real work of an unacquire.
 *
 *          See <mf IDirectInputJoyConfig8::Unacquire> for more
 *          information.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG88
 *
 *  @returns
 *
 *          Returns a COM error code.
 *          See <mf IDirectInputJoyConfig8::Unacquire> for more
 *          information.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_InternalUnacquire(PJC this)
{
    HRESULT hres;
    EnterProc(CJoyCfg_InternalUnacquire, (_ "p", this));

    /*
     *  Must protect with the critical section to prevent somebody from
     *  interfering with us while we're unacquiring.
     */
    CJoyCfg_EnterCrit(this);

    if(this->fAcquired)
    {

        AssertF(this->hkTypesW);

        RegCloseKey(this->hkTypesW);

        this->hkTypesW = 0;

        Invoke_Release(&this->pes);

        Excl_Unacquire(&IID_IDirectInputJoyConfig, this->hwnd, this->discl);

        this->fAcquired = 0;
        hres = S_OK;
    } else
    {
        hres = S_FALSE;
    }

    CJoyCfg_LeaveCrit(this);

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CJoyCfg_Finalize |
 *
 *          Releases the resources of the device.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
    CJoyCfg_Finalize(PV pvObj)
{
    PJC this = pvObj;

    #ifdef XDEBUG
    if(this->cCrit)
    {
        RPF("IDirectInputJoyConfig8::Release: Another thread is using the object; crash soon!");
    }
    #endif

    if(this->fAcquired)
    {
        CJoyCfg_InternalUnacquire(this);
    }

    AssertF(this->pes == 0);

    if(this->hkTypesW)
    {
        RegCloseKey(this->hkTypesW);
    }

    if(this->fCritInited)
    {
        DeleteCriticalSection(&this->crst);
    }

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | SetCooperativeLevel |
 *
 *          Establish the cooperativity level for the instance of
 *          the device.
 *
 *          The only cooperative levels supported for the
 *          <i IDirectInputJoyConfig8> interface are
 *          <c DISCL_EXCLUSIVE> and <c DISCL_BACKGROUND>.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   HWND | hwnd |
 *
 *          The window associated with the interface. This parameter
 *          must be non-NULL and must be a top-level window.
 *
 *          It is an error to destroy the window while it is still
 *          associated with an <i IDirectInputJoyConfig8> interface.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags which describe the cooperativity level associated
 *          with the device.
 *
 *          The value must be
 *          <c DISCL_EXCLUSIVE> <vbar> <c DISCL_BACKGROUND>.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p hwnd> parameter is not a valid pointer.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_SetCooperativeLevel(PDJC pdjc, HWND hwnd, DWORD dwFlags)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::SetCooperativityLevel,
               (_ "pxx", pdjc, hwnd, dwFlags));

    if(SUCCEEDED(hres = hresPv(pdjc)))
    {
        PJC this = _thisPvNm(pdjc, djc);

        if(dwFlags != (DISCL_EXCLUSIVE | DISCL_BACKGROUND))
        {
            RPF("%s: Cooperative level must be "
                "DISCL_EXCLUSIVE | DISCL_BACKGROUND", s_szProc);
            hres = E_NOTIMPL;
        } else if(GetWindowPid(hwnd) == GetCurrentProcessId())
        {
            this->hwnd = hwnd;
            this->discl = dwFlags;
            hres = S_OK;
        } else
        {
            RPF("ERROR %s: window must belong to current process", s_szProc);
            hres = E_HANDLE;
        }
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | Acquire |
 *
 *          Acquire "joystick configuration mode".  Only one application can
 *          be in joystick configuration mode at a time; subsequent
 *          applications will receive the error <c DIERR_OTHERAPPHASPRIO>.
 *
 *          After entering configuration mode, the application may
 *          make alterations to the global joystick configuration
 *          settings.  It is encouraged that the application
 *          re-check the existing settings before installing the new
 *          ones in case another application had changed the settings
 *          in the interim.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_OTHERAPPHASPRIO>: Another application is already
 *          in joystick configuration mode.
 *
 *          <c DIERR_INSUFFICIENTPRIVS>: The current user does not have
 *          the necessary permissions to alter the joystick configuration.
 *
 *          <c DIERR_DEVICECHANGE>: Another application has changed
 *          the global joystick configuration.  The interface needs
 *          to be re-initialized.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_Acquire(PDJC pdjc)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::Acquire, (_ "p", pdjc));

    if(SUCCEEDED(hres = hresPv(pdjc)))
    {
        PJC this = _thisPvNm(pdjc, djc);

        /*
         *  Must protect with the critical section to prevent somebody from
         *  acquiring or changing the data format while we're acquiring.
         */
        CJoyCfg_EnterCrit(this);

        if(this->discl == 0)
        {
            RPF("%s: Cooperative level not yet set", s_szProc);
            hres = E_FAIL;
            goto done;
        }

        if(this->fAcquired)
        {
            AssertF(this->hkTypesW);
            hres = S_FALSE;
        } else if(SUCCEEDED(hres = Excl_Acquire(&IID_IDirectInputJoyConfig,
                                                this->hwnd, this->discl)))
        {
            AssertF(this->hkTypesW == 0);


            hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                                   REGSTR_PATH_JOYOEM, 
                                   DI_KEY_ALL_ACCESS, 
                                   REG_OPTION_NON_VOLATILE, 
                                   &this->hkTypesW);

            if(SUCCEEDED(hres) )
            {
                this->fAcquired = 1;
            } else
            {
                RegCloseKey(this->hkTypesW);
                this->hkTypesW = 0;
                hres = DIERR_INSUFFICIENTPRIVS;
            }

        }

        done:;
        CJoyCfg_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | Unacquire |
 *
 *          Unacquire "joystick configuration mode".  Before unacquiring
 *          configuration mode, the application must perform an
 *          <mf IDirectInputJoyConfig8::SendNotify> to propagate
 *          the changes in the joystick configuration
 *          to all device drivers and applications.
 *
 *          Applications which hold interfaces to a joystick which is
 *          materially affected by a change in configuration will
 *          receive the <c DIERR_DEVICECHANGE> error code until the
 *          device is re-initialized.
 *
 *          Examples of material changes to configuration include
 *          altering the number of axes or the number of buttons.
 *          In comparison, changes to device calibration
 *          are handled internally by
 *          DirectInput and are transparent to the application.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration mode was
 *          not acquired.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_Unacquire(PDJC pdjc)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::Unacquire, (_ "p", pdjc));

    if(SUCCEEDED(hres = hresPv(pdjc)))
    {
        PJC this = _thisPvNm(pdjc, djc);

        hres = CJoyCfg_InternalUnacquire(this);

    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | SendNotify |
 *
 *          Notifies device drivers and applications that changes to
 *          the device configuration have been made.  An application
 *          which changes device configurations must invoke this
 *          method after the changes have been made (and before
 *          unacquiring).
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration mode was
 *          not acquired.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_SendNotify(PDJC pdjc)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::SendNotify, (_ "p", pdjc));

    if(SUCCEEDED(hres = hresPv(pdjc)))
    {
        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);

        if(this->fAcquired)
        {
          #ifdef WINNT
            Excl_SetConfigChangedTime( GetTickCount() );
            PostMessage(HWND_BROADCAST, g_wmJoyChanged, 0, 0L);   
          #else
            joyConfigChanged(0);
          #endif

            /*
             *  If we don't have a joyConfigChanged, it's probably just 
             *  because we're running on NT and don't need it.
             */
            hres = S_OK;
        } else
        {
            hres = DIERR_NOTACQUIRED;
        }

        CJoyCfg_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyCfg_ConvertCurrentConfigs |
 *
 *          Converts any OEMType name matching the first input string and 
 *          replaces it with the other input string.
 *
 *  @parm   IN LPTSTR | szFindType |
 *
 *          String to match.
 *
 *  @parm   IN LPTSTR | szReplaceType |
 *
 *          String to replace any matches instances.
 *
 *  @returns
 *
 *          A COM success code unless the current configuration key could not
 *          be opened, or a type that needed to be replaced could not be 
 *          overwritten.
 *
 *****************************************************************************/

HRESULT JoyCfg_ConvertCurrentConfigs( LPTSTR szFindType, LPTSTR szReplaceType )
{
    HRESULT hres;
    LONG    lRc;
    HKEY    hkCurrCfg;
    UINT    JoyId;
    TCHAR   szTestType[MAX_JOYSTRING];
    TCHAR   szTypeName[MAX_JOYSTRING];
    DWORD   cb;

    EnterProcI(JoyCfg_ConvertCurrentConfigs, (_ "ss", szFindType, szReplaceType ));

    hres = JoyReg_OpenConfigKey( (UINT)(-1), KEY_WRITE, REG_OPTION_NON_VOLATILE, &hkCurrCfg );

    if( SUCCEEDED( hres ) )
    {
        for( JoyId = 0; (JoyId < 16) || ( lRc == ERROR_SUCCESS ); JoyId++ )
        {
            wsprintf( szTypeName, REGSTR_VAL_JOYNOEMNAME, JoyId+1 );
            cb = sizeof( szTestType );
            lRc = RegQueryValueEx( hkCurrCfg, szTypeName, 0, NULL, (PBYTE)szTestType, &cb );
            if( lRc == ERROR_SUCCESS )
            {
                if( !lstrcmpi( szTestType, szFindType ) )
                {
                    cb = sizeof( szReplaceType) * (1 + lstrlen( szReplaceType ));
                    lRc = RegSetValueEx( hkCurrCfg, szTypeName, 0, REG_SZ, (PBYTE)szReplaceType, cb );
                    if( lRc != ERROR_SUCCESS )
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("RegSetValueEx failed to replace type of %s 0x%08x"), 
                            szTypeName, lRc );
                        /* This is the only error that counts as an error in this loop */
                        hres = hresReg( lRc );
                    }
                }
            }
        }

    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflError,
            TEXT("JoyReg_OpenConfigKey failed code 0x%08x"), hres );
    }

    ExitOleProc();

    return hres;

} /* JoyCfg_ConvertCurrentConfigs */


#ifdef WINNT
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyCfg_FixHardwareId |
 *
 *          Fixes the hardwareId for an analog type by assinging a VID/PID to 
 *          it and recreating the type using that hardwareId.
 *
 *  @parm   IN HKEY | hkTypesR |
 *
 *          Handle of key opened to the root of types.
 *
 *  @parm   IN HKEY | hkSrc |
 *
 *          Handle of key opened to the original type.
 *
 *  @parm   IN PTCHAR | ptszPrefName |
 *
 *          VID&PID name from the HardwareID if present, NULL otherwise
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The key is valid
 *          <c DI_NOEFFECT> = <c S_FALSE> The key should be ignored
 *
 *          <c OLE_E_ENUM_NOMORE> = The key has been fixed but enumeration
 *                                  must be restarted.
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:  Out of memory.
 *
 *****************************************************************************/

HRESULT INTERNAL
    JoyCfg_FixHardwareId( HKEY hkTypesR, HKEY hkSrc, PTCHAR szSrcType , PTCHAR ptszPrefName)
{
    HRESULT hres;
    HKEY    hkNew;
    BYTE    PIDlow;
    DWORD   ClassLen;
    PTCHAR  szClassName;
    TCHAR   szDestType[sizeof( ANALOG_ID_ROOT ) + 2];  //Two digits will be appended
    TCHAR   szHardwareId[MAX_JOYSTRING];

    EnterProcI(JoyCfg_FixHardwareId, (_ "xxs", hkTypesR, hkSrc, szSrcType));

    hres = hresReg( RegQueryInfoKey(  hkSrc,              // handle to key to query
                                      NULL,               // Class
                                      &ClassLen,          // ClassLen
                                      NULL,               // Reserved
                                      NULL, NULL, NULL,   // NumSubKeys, MaxSubKeyLen, MaxClassLen
                                      NULL, NULL, NULL,   // NumValues, MaxValueNameLen, MaxValueLen
                                      NULL, NULL ) );     // Security descriptor, last write

    if( SUCCEEDED( hres ) )
    {
        ClassLen++;
        /*
         *  Part of mb:34633 (see below, 2 comments) was that prefix considers 
         *  the case of zero bytes being requested in the following call so 
         *  assert that we always ask for some memory otherwise checking the 
         *  result does not guarantee that the pointer is valid.
         */
        AssertF( ClassLen * sizeof(szClassName[0]) );
        hres = AllocCbPpv( ClassLen * sizeof(szClassName[0]), &szClassName );
        if( SUCCEEDED( hres ) )
        {
            hres = hresReg( RegQueryInfoKey(  hkSrc,              // handle to key to query
                                              szClassName,        // Class
                                              &ClassLen,          // ClassLen
                                              NULL,               // Reserved
                                              NULL, NULL, NULL,   // NumSubKeys, MaxSubKeyLen, MaxClassLen
                                              NULL, NULL, NULL,   // NumValues, MaxValueNameLen, MaxValueLen
                                              NULL, NULL ) );     // Security descriptor, last write
            if( FAILED( hres ) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("RegQueryInfoKey on type %s for class name failed 0x%04x"), 
                    szSrcType, LOWORD(hres) );
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflError,
                TEXT("Failed to allocate %d bytes for class name of type %s, error 0x%04x"), 
                ClassLen, szSrcType, LOWORD(hres) );
        }
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflError,
            TEXT("RegQueryInfoKey on type %s for class name length failed 0x%04x"), 
            szSrcType, LOWORD(hres) );
        /* Make sure not to free an uninitialized pointer */
        szClassName = NULL;
    }

    if( SUCCEEDED( hres ) )
    {
        for( PIDlow = JOY_HW_PREDEFMAX+1; PIDlow; PIDlow++ )
        {
            if (ptszPrefName)
            {
                lstrcpy( szDestType, ptszPrefName);
#ifdef UNICODE
                CharUpperW(szDestType);
#else
                CharUpper(szDestType);
#endif
            }
            else
            {
                wsprintf( szDestType, TEXT("%s%02X"), ANALOG_ID_ROOT, PIDlow );
            }
            hres = hresRegCopyKey( hkTypesR, szSrcType, szClassName, hkTypesR, szDestType, &hkNew );
            if( hres == S_OK )
            {
                /*
                 *  Prefix warns that hkNew may be uninitialized (mb:34633) 
                 *  however hresRegCopyKey only returns a SUCCESS if hkNew 
                 *  is initialized to an opened key handle.
                 */
                hres = hresRegCopyBranch( hkSrc, hkNew );

                if( SUCCEEDED( hres ) )
                {
                    if (!ptszPrefName)
                    {
#ifdef MULTI_SZ_HARDWARE_IDS
                        /*
                         *  Make up the hardwareId using the assigned PID with a generic hardwareId appended
                         */
                        int CharIdx = 0;
                        while( TRUE )
                        {
                            CharIdx += wsprintf( &szHardwareId[CharIdx], TEXT("%s%s%02X"), TEXT("GamePort\\"), ANALOG_ID_ROOT, PIDlow );
                            CharIdx++;    /* Leave NULL terminator in place */
                            if( PIDlow )
                            {
                                PIDlow = 0; /* Trash this value to make the generic PID on second iteration */
                            }
                            else
                            {
                                break;
                            }
                        }
                        szHardwareId[CharIdx++] = TEXT('\0'); /* MULTI_SZ */

                        hres = hresReg( RegSetValueEx( hkNew, REGSTR_VAL_JOYOEMHARDWAREID, 0, 
                            REG_MULTI_SZ, (PBYTE)szHardwareId, (DWORD)( sizeof(szHardwareId[0]) * CharIdx ) ) );
                        if( FAILED( hres ) )
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("JoyCfg_FixHardwareId: failed to write hardware ID %s"), szHardwareId );
                        }
#else
                        /*
                         *  Make up the hardwareId using the assigned PID
                         */
                        int CharIdx = 0;
                        CharIdx = wsprintf( szHardwareId, TEXT("%s%s%02X"), TEXT("GamePort\\"), ANALOG_ID_ROOT, PIDlow );
                        CharIdx++;    /* Leave NULL terminator in place */

                        hres = hresReg( RegSetValueEx( hkNew, REGSTR_VAL_JOYOEMHARDWAREID, 0, 
                            REG_SZ, (PBYTE)szHardwareId, (DWORD)( sizeof(szHardwareId[0]) * CharIdx ) ) );
                        if( FAILED( hres ) )
                        {
                            SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("JoyCfg_FixHardwareId: failed to write hardware ID %s"), szHardwareId );
                        }
#endif
                    }
                }

                /*
                 *  Prefix warns that hkNew may be uninitialized (mb:34633) 
                 *  however hresRegCopyKey only returns a SUCCESS if hkNew 
                 *  is initialized to an opened key handle.
                 */
                RegCloseKey( hkNew );
                if( SUCCEEDED( hres ) )
                {
                    hres = JoyCfg_ConvertCurrentConfigs( szSrcType, szDestType );
                }

                DIWinnt_RegDeleteKey( hkTypesR, ( SUCCEEDED( hres ) ) ? szSrcType
                                                                      : szDestType );
                break;
            }
            else if( SUCCEEDED( hres ) )
            {
                /*
                 *  Prefix warns that hkNew may be uninitialized (mb:37926) 
                 *  however hresRegCopyKey only returns a SUCCESS if hkNew 
                 *  is initialized to an opened key handle.
                 */
                /*
                 *  The key already existed so keep looking
                 */
                RegCloseKey( hkNew );
            }
            else
            {
                /*
                 *  RegCopyKey should have already posted errors
                 */
                break;
            }
        }
        if( !PIDlow )
        {
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("JoyCfg_FixHardwareId: no free analog keys for type %s"), 
                szSrcType );
            hres = DIERR_NOTFOUND;
        }
    }

    if( szClassName )
    {
        FreePpv( &szClassName );
    }


    ExitOleProc();

    return( hres );        
} /* JoyCfg_FixHardwareId */
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | JoyCfg_CheckTypeKey |
 *
 *          Checks the contents of a type key for validity on the current OS
 *          and if not valid, try to make it so.
 *
 *          Only custom analog types can be fixed and this only needs to be 
 *          done on a WDM enabled OS as non-WDM requirements are a sub-set of
 *          the WDM ones.
 *
 *  @parm   IN HKEY | hkTypesR |
 *
 *          Handle of key opened to the root of types.
 *
 *  @parm   IN LPTSTR | szType |
 *
 *          Receives a pointer either an ansi or UNICODE key name to test.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The key is valid
 *          <c DI_NOEFFECT> = <c S_FALSE> The key should be ignored
 *
 *          <c OLE_E_ENUM_NOMORE> = The key has been fixed but enumeration
 *                                  must be restarted.
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:  Out of memory.
 *
 *****************************************************************************/

HRESULT INTERNAL
    JoyCfg_CheckTypeKey( HKEY hkTypesR, LPTSTR szType )
{
    HRESULT hres;
    HKEY hk;
    LONG lRc;
    DWORD cb;

    TCHAR tszCallout[MAX_JOYSTRING];
    TCHAR tszHardwareId[MAX_JOYSTRING];
#ifdef WINNT
    JOYREGHWSETTINGS hws;
    TCHAR* ptszLastSlash=NULL;
#endif
    
    EnterProcI(JoyCfg_CheckTypeKey, (_ "xs",hkTypesR, szType));

    /*
     *  Open read only just in case we don't have better permission to any 
     *  of the type sub-keys.
     */
    lRc = RegOpenKeyEx( hkTypesR, szType, 0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hk );

    if(lRc == ERROR_SUCCESS )
    {
        /*
         *  Gather the needed results using standard registry functions so 
         *  that the exact return code is known.
         */

        lRc = RegQueryValueEx(hk, REGSTR_VAL_JOYOEMNAME, NULL, NULL, NULL, NULL );

#ifdef WINNT
        if(lRc == ERROR_SUCCESS )
        {
            cb = cbX(hws);
            lRc = RegQueryValueEx(hk, REGSTR_VAL_JOYOEMDATA, NULL, NULL, (PBYTE)&hws, &cb );
            if( ( lRc == ERROR_SUCCESS ) && ( hws.dwFlags & JOY_HWS_AUTOLOAD ) )
            {
                /*
                 *  WARNING goto
                 *  If we have a name and JOY_HWS_AUTOLOAD is set, that's all we need
                 */
                RegCloseKey( hk );
                hres = S_OK;
                goto fast_out;
            }
             
            if( lRc == ERROR_FILE_NOT_FOUND )
            {
                hws.dwFlags = 0;
                lRc = ERROR_SUCCESS;
            }
        }
#endif

        if(lRc == ERROR_SUCCESS )
        {
            cb = cbX(tszCallout);
            lRc = RegQueryValueEx(hk, REGSTR_VAL_JOYOEMCALLOUT, NULL, NULL, (PBYTE)tszCallout, &cb );
            if( lRc == ERROR_FILE_NOT_FOUND )
            {
                tszCallout[0] = TEXT('\0');
                lRc = ERROR_SUCCESS;
            }
        }

        if(lRc == ERROR_SUCCESS )
        {
            cb = cbX(tszHardwareId);
            lRc = RegQueryValueEx(hk, REGSTR_VAL_JOYOEMHARDWAREID, NULL, NULL, (PBYTE)tszHardwareId, &cb );
            if( lRc == ERROR_FILE_NOT_FOUND )
            {
                tszHardwareId[0] = TEXT('\0');
                lRc = ERROR_SUCCESS;
            }
#ifdef WINNT
            else
            {
                TCHAR* ptsz;
                for (ptsz = tszHardwareId;*ptsz!='\0';++ptsz)
                {
                    if (*ptsz == '\\')
                    {
                        ptszLastSlash = ptsz;
                    }
                }
                if (ptszLastSlash)
                {
                    ptszLastSlash++; //next char is the one we want
                }
            }
#endif
        }


        if(lRc != ERROR_SUCCESS )
        {
            RegCloseKey( hk );
        }
    }

    if(lRc == ERROR_SUCCESS )
    {
#ifdef WINNT
        SHORT DontCare;
#endif
        WCHAR wszType[18];

        TToU( wszType, cA(wszType),szType );

        /*
         *  Work out the status of this type based on the OS and the registry data
         *
         *  Note on 98 we allow WDM types to be enumerated but do not convert 
         *  analog types to WDM.  We may want to convert analog types if we get 
         *  WDM gameport drivers appear for gameports that are incompatible with 
         *  msanalog.
         */

#define HAS_VIDPID ( ParseVIDPID( &DontCare, &DontCare, wszType ) )
#define HAS_HARDWARE_ID ( tszHardwareId[0] != TEXT('\0') )
#define HAS_OEMCALLOUT ( tszCallout[0] != TEXT('\0') )
#define IS_ANALOG \
        ( tszHardwareId[ sizeof( ANALOG_ID_ROOT ) - 1 ] = TEXT('\0'), \
          ( !lstrcmpi( tszHardwareId, ANALOG_ID_ROOT ) ) )
#define IS_WIN98 (HidD_GetHidGuid)

#ifdef WINNT
        if (HAS_HARDWARE_ID)
        {
            //Need to check if there is a VID and PID in the HW ID
            if (ParseVIDPID(&DontCare, &DontCare, ptszLastSlash))
            {
                //If the type VIDPID doesn't match the HardwareId VIDPID
                //we need to fix it
                if (!lstrcmpi(ptszLastSlash,wszType))
                {
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                      TEXT("OEMHW %s(%s) and/or Type %s have matching VID/PID"), 
                      tszHardwareId,ptszLastSlash,wszType);
                    hres = S_OK;
                }
                else
                {
                    hres = OLE_E_ENUM_NOMORE;
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                      TEXT("OEMHW %s(%s) and/or Type %s have non-matching VID/PID. Fix Needed."), 
                      tszHardwareId,ptszLastSlash,wszType);
                }
            }
            else
            {
                hres = S_OK; //no VIDPID in the type
                SquirtSqflPtszV(sqfl | sqflVerbose,
                    TEXT("OEMHW %s(%s) and/or Type %s have no VID/PID"), 
                    tszHardwareId,ptszLastSlash,wszType);
            }
        }
        else
        {
            if (HAS_VIDPID)
            {
                hres = DIERR_MOREDATA;
            }
            else
            {
                if (HAS_OEMCALLOUT)
                {
                    hres = S_FALSE;
                }
                else
                {
                    hres = OLE_E_ENUM_NOMORE;
                }
            }
        }

#else
        hres = (IS_WIN98) ? S_OK                                                        /* Anything goes on 98 */
                          : (HAS_OEMCALLOUT) ? S_OK                                     /* Win9x device, OK */
                                             : (HAS_HARDWARE_ID) ? (IS_ANALOG) ? S_OK   /* Analog type, OK */
                                                                               : S_FALSE /* WDM device, ignore */
                                                                 : S_OK;                /* Analog type, OK */
#endif
                                                                
        switch( hres )
        {
#ifdef WINNT
        case DIERR_MOREDATA:
            /*
             *  The device is not marked as autoload but has a VID/PID type 
             *  name.  If the OEMCallout is blank or "joyhid.vxd" we'll assume 
             *  the type should be autoload and correct it.
             *  If there's any other value, we could assume either that we 
             *  have a bogus Win9x driver type key and hide it or that the 
             *  device is autoload.  
             *  Safest route, now that our expose code is smart enough to not 
             *  expose a device without a hardware ID, is to enumerate it as 
             *  non-autoload as Win2k did.  It won't work if you try to add 
             *  it but at least the type will be enumerated if the device 
             *  does show up from PnP (so nobody will get confused by a 
             *  device without a type).
             *
             *  ISSUE-2001/01/04-MarcAnd should use common joyhid string
             *  Not sure if the compiler/linker will resolve the various 
             *  instances of L"joyhid.vxd" to a single string.  Should 
             *  reference the same one to be certain.
             */

            if( !HAS_OEMCALLOUT 
             || ( !lstrcmpi( tszCallout, L"joyhid.vxd" ) ) )
            {
                HKEY hkSet;

                /*
                 *  Need to open a new handle for the key as the one we have 
                 *  is read-only.
                 */
                lRc = RegOpenKeyEx( hkTypesR, szType, 0, KEY_SET_VALUE, &hkSet );

                if( lRc == ERROR_SUCCESS )
                {
                    hws.dwFlags |= JOY_HWS_AUTOLOAD;
                    cb = cbX(hws);
                    lRc = RegSetValueEx( hkSet, REGSTR_VAL_JOYOEMDATA, 0, 
                        REG_BINARY, (PBYTE)&hws, (DWORD)( cbX(hws) ) );

                    if( lRc == ERROR_SUCCESS )
                    {
                        SquirtSqflPtszV(sqfl | sqflTrace,
                                TEXT("FIXED Type %s to have JOY_HWS_AUTOLOAD"), szType );
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflBenign,
                                TEXT("Failed to set JOY_HWS_AUTOLOAD on Type %s (rc=%d,le=%d)"), 
                                szType, lRc, GetLastError() );
                    }

                    RegCloseKey( hkSet );
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflBenign,
                            TEXT("Failed to open Type %s to fix JOY_HWS_AUTOLOAD(rc=%d,le=%d)"), 
                            szType, lRc, GetLastError() );
                }
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflBenign,
                        TEXT("Type %s with OEMCallout<%s> has no HardwareId so cannot be added"), 
                        szType, tszCallout );
            }
            
            /*
             *  Whether or not we fixed this, we want to enumerate the key.
             */
            hres = S_OK;
            break;

        case OLE_E_ENUM_NOMORE:
            {
                HRESULT hres0;
                hres0 = JoyCfg_FixHardwareId( hkTypesR, hk, szType , ptszLastSlash);
                if( FAILED( hres0 ) )
                {
                    /*
                     *  Failed to fix type it must be ignored to avoid an infinite loop
                     */
                    SquirtSqflPtszV(sqfl | sqflBenign,
                            TEXT("Ignoring type %s as fix failed"), szType );
                    hres = S_FALSE;
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflTrace,
                            TEXT("FIXED Type %s with HardwareId<%s> and OEMCallout<%s>"), 
                            szType, tszHardwareId, tszCallout );
                }
            }
            break;
#endif
        case S_FALSE:
            SquirtSqflPtszV(sqfl | sqflBenign,
                    TEXT("Ignoring type %s with HardwareId<%s> and OEMCallout<%s>"), 
                    szType, tszHardwareId, tszCallout );
            break;
        case S_OK:
            SquirtSqflPtszV(sqfl | sqflTrace,
                    TEXT("Enumerating type %s with HardwareId<%s> and OEMCallout<%s>"), 
                    szType, tszHardwareId, tszCallout );
            break;
        }

        RegCloseKey( hk );

#undef HAS_VIDPID
#undef HAS_HARDWARE_ID
#undef HAS_OEMCALLOUT
#undef IS_ANALOG
#undef IS_WIN98

    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("Ignoring type %s due to registry error 0x%08x"), szType, lRc );
        /*
         *  It seems a bit bogus, to return success for an error but this 
         *  makes sure the key is ignored and enumeration will proceed.
         */
        hres = S_FALSE;
    }
#ifdef WINNT
fast_out:;
#endif

    ExitOleProc();

    return( hres );

} /* JoyCfg_CheckTypeKey */


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CDIJoyCfg | SnapTypes |
 *
 *          Snapshot the list of subkeys for OEM types.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   OUT LPWSTR * | ppwszz |
 *
 *          Receives a pointer to a UNICODEZZ
 *          list of type names.  Note that the returned list
 *          is pre-populated with the predefined types, too.
 *
 *          We need to snapshot the names up front because
 *          the caller might create or delete OEM types during the
 *          enumeration.
 *
 *          As we enumerate we check each key for validity and repair any 
 *          analog custom configurations that we can.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:  Out of memory.
 *
 *****************************************************************************/

HRESULT INTERNAL
    CJoyCfg_SnapTypes(PJC this, LPWSTR *ppwszz)
{
    HRESULT hres;
    LONG    lRc;
    HKEY    hkTypesR;
    DWORD   chkSub;
    BOOL    fRetry;

    EnterProcI(CJoyCfg_SnapTypes, (_ "p", this));

    RD(*ppwszz = 0);

    /*
     *  If an analog configuration needs to be fixed, the enumeration is 
     *  restarted because adding/removing keys may mess with the key indicies.
     *  Since registry keys can go stale, start from scratch.
     */
    
    do
    {
        fRetry=FALSE;

        /*
         *  Note that it is not safe to cache the registry key in
         *  the object.  If somebody deletes the registry key, our
         *  cached handle goes stale and becomes useless.
         */
        lRc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           REGSTR_PATH_JOYOEM, 0,
                           KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkTypesR);

        /*
         *  Note also that if the registry key is not available,
         *  we still want to return the predefined types.
         */

        if(lRc == ERROR_SUCCESS)
        {
            lRc = RegQueryInfoKey(hkTypesR, 0, 0, 0, &chkSub,
                                  0, 0, 0, 0, 0, 0, 0);

            if(lRc == ERROR_SUCCESS  )
            {
            } else
            {
                chkSub = 0;
            }
        } else
        {
            hkTypesR = 0;
            chkSub = 0;
        }


        /*
         *  Each predefined name is of the form #n\0,
         *  which is 3 characters.
         */
        hres = AllocCbPpv(cbCwch( chkSub  * MAX_JOYSTRING +
                                 (JOY_HW_PREDEFMAX - JOY_HW_PREDEFMIN)
                                 * 3 + 1), ppwszz);

        // Not really a bug,we never get to this point with a NULL ptr, 
        // but lets keep prefix happy Manbugs: 29340
        if(SUCCEEDED(hres) && *ppwszz != NULL ){
            DWORD dw;
            LPWSTR pwsz;

            /*
             *  First add the predef keys.
             */
            for(dw = JOY_HW_PREDEFMIN, pwsz = *ppwszz;
               dw < JOY_HW_PREDEFMAX; dw++)
            {
                *pwsz++ = L'#';
                *pwsz++ = CJoyCfg_CharFromType(dw);
                *pwsz++ = L'\0';
            }

            /*
             *  Now add the named keys.
             */
            for(dw = 0; dw < chkSub; dw++)
            {
        #ifdef UNICODE
                lRc = RegEnumKey(hkTypesR, dw, pwsz, MAX_JOYSTRING);
        #else
                CHAR sz[MAX_JOYSTRING];
                lRc = RegEnumKey(hkTypesR, dw, sz, MAX_JOYSTRING);
        #endif
                if(lRc == ERROR_SUCCESS )
                {
            #ifdef UNICODE
                    hres = JoyCfg_CheckTypeKey( hkTypesR, pwsz );
            #else
                    hres = JoyCfg_CheckTypeKey( hkTypesR, sz );
            #endif
                    if( FAILED( hres ) )
                    {
                        /*
                         *  Had to fix type so restart
                         */
                        FreePpv( ppwszz );
                        break;
                    }

                    if( hres != S_OK )
                    {
                        /*
                         *  Ignore this type
                         */
                        continue;
                    }

            #ifdef UNICODE
                    pwsz += lstrlenW(pwsz) + 1;
            #else
                    pwsz += AToU(pwsz, MAX_JOYSTRING, sz);
            #endif
                }
                else
                {
                }
            }        

            if( SUCCEEDED( hres ) )
            {
                *pwsz = L'\0';              /* Make it ZZ */

                hres = S_OK;
            }
            else
            {
                fRetry = TRUE;
            }
        }

        if(hkTypesR)
        {
            RegCloseKey(hkTypesR);
        }

    } while( fRetry );

    ExitOleProcPpv(ppwszz);
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | EnumTypes |
 *
 *          Enumerate the joystick types currently supported by
 *          DirectInput.  A "joystick type" describes how DirectInput
 *          should communicate with a joystick device.  It includes
 *          information such as the presence and
 *          locations of each of the axes and the number of buttons
 *          supported by the device.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   LPDIJOYTYPECALLBACK | lpCallback |
 *
 *          Points to an application-defined callback function.
 *          For more information, see the description of the
 *          <f DIEnumJoyTypeProc> callback function.
 *
 *  @parm   IN LPVOID | pvRef |
 *
 *          Specifies a 32-bit application-defined
 *          value to be passed to the callback function.  This value
 *          may be any 32-bit value; it is prototyped as an <t LPVOID>
 *          for convenience.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          callback procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumJoyTypeProc |
 *
 *          An application-defined callback function that receives
 *          DirectInput joystick types as a result of a call to the
 *          <om IDirectInputJoyConfig8::EnumTypes> method.
 *
 *  @parm   IN LPCWSTR | pwszTypeName |
 *
 *          The name of the joystick type.  A buffer of <c MAX_JOYSTRING>
 *          characters will be sufficient to hold the type name.
 *          The type name should never be shown to the end user; instead,
 *          the "display name" should be shown.  Use
 *          <mf IDirectInputJoyConfig8::GetTypeInfo> to obtain the
 *          display name of a joystick type.
 *
 *          Type names that begin with a sharp character ("#")
 *          represent predefined types which cannot be modified
 *          or deleted.
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInputJoyConfig8::EnumTypes> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *  @devnote
 *
 *  EnumTypes must snapshot because people will try to get/set/delete
 *  during the enumeration.
 *
 *  EnumTypes enumerates the predefined types as "#digit".
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_EnumTypes(PDJC pdjc, LPDIJOYTYPECALLBACK ptc, LPVOID pvRef)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::EnumTypes, (_ "ppx", pdjc, ptc, pvRef));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidPfn(ptc, 1)))
    {
        PJC this = _thisPvNm(pdjc, djc);
        LPWSTR pwszKeys;

        hres = CJoyCfg_SnapTypes(this, &pwszKeys);
        if(SUCCEEDED(hres))
        {
            LPWSTR pwsz;

            /*
             *  Prefix warns that pwszKeys could be null (mb:34685)
             *  Little does it know that CJoyCfg_SnapTypes can only return a 
             *  success if the pointer is not NULL.
             */
            AssertF( pwszKeys );

            /*
             *  Surprise!  Win95 implements lstrlenW.
             */
            for(pwsz = pwszKeys; *pwsz; pwsz += lstrlenW(pwsz) + 1)
            {
                BOOL fRc;

                /*
                 *  WARNING!  "goto" here!  Make sure that nothing
                 *  is held while we call the callback.
                 */
                fRc = Callback(ptc, pwsz, pvRef);

                switch(fRc)
                {
                    case DIENUM_STOP: goto enumdoneok;
                    case DIENUM_CONTINUE: break;
                    default:
                        RPF("%s: Invalid return value from callback", s_szProc);
                        ValidationException();
                        break;
                }
            }

            FreePpv(&pwszKeys);
            hres = DIPort_SnapTypes(&pwszKeys);
            if(SUCCEEDED(hres))
            {
                LPWSTR pwsz;
    
                /*
                 *  Surprise!  Win95 implements lstrlenW.
                 */
                for(pwsz = pwszKeys; *pwsz; pwsz += lstrlenW(pwsz) + 1)
                {
                    BOOL fRc;
    
                    /*
                     *  WARNING!  "goto" here!  Make sure that nothing
                     *  is held while we call the callback.
                     */
                    fRc = Callback(ptc, pwsz, pvRef);
    
                    switch(fRc)
                    {
                        case DIENUM_STOP: goto enumdoneok;
                        case DIENUM_CONTINUE: break;
                        default:
                            RPF("%s: Invalid return value from callback", s_szProc);
                            ValidationException();
                            break;
                    }
                }
            }

            enumdoneok:;
            FreePpv(&pwszKeys);
            hres = S_OK;
        }

        hres = S_OK;
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | GetTypeInfo |
 *
 *          Obtain information about a joystick type.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          Points to the name of the type, previously obtained
 *          from a call to <mf IDirectInputJoyConfig8::EnumTypes>.
 *
 *  @parm   IN OUT LPDIJOYTYPEINFO | pjti |
 *
 *          Receives information about the joystick type.
 *          The caller "must" initialize the <e DIJOYTYPEINFO.dwSize>
 *          field before calling this method.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DITC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjti> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_NOTFOUND>: The joystick type was not found.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_GetTypeInfo(PDJC pdjc, LPCWSTR pwszType,
                        LPDIJOYTYPEINFO pjti, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::GetTypeInfo,
               (_ "pWpx", pdjc, pwszType, pjti, fl));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidReadStrW(pwszType, MAX_JOYSTRING, 1)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb3(pjti,
                                                DIJOYTYPEINFO_DX8,
                                                DIJOYTYPEINFO_DX6,
                                                DIJOYTYPEINFO_DX5, 2)) &&
       SUCCEEDED( (pjti->dwSize == cbX(DIJOYTYPEINFO_DX8) )
                  ? ( hres = hresFullValidFl(fl, DITC_GETVALID, 3) )
                  : (pjti->dwSize == cbX(DIJOYTYPEINFO_DX6 ) )
                      ? ( hres = hresFullValidFl(fl, DITC_GETVALID_DX6, 3) )
                      : ( hres = hresFullValidFl(fl, DITC_GETVALID_DX5, 3) ) ) )
    {

        PJC this = _thisPvNm(pdjc, djc);
        GUID    guid;
        BOOL    fParseGuid;

#ifndef UNICODE
        TCHAR   tszType[MAX_PATH/4];

        UToT( tszType, cA(tszType), pwszType );
        fParseGuid = ParseGUID(&guid, tszType);
#else
        fParseGuid = ParseGUID(&guid, pwszType);
#endif

        if(pwszType[0] == TEXT('#'))
        {
            hres = JoyReg_GetPredefTypeInfo(pwszType, pjti, fl);
        } else if( fParseGuid )
        {
            hres = DIBusDevice_GetTypeInfo(&guid, pjti, fl);
        }else
        {
            hres = JoyReg_GetTypeInfo(pwszType, pjti, fl);
        }
        
    }

    ExitOleProcR();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidStructStr |
 *
 *          Validate a string field in a struct.
 *
 *  @parm   IN LPCWSTR | pwsz |
 *
 *          String to be validated.
 *
 *  @parm   UINT | cwch |
 *
 *          Maximum string length.
 *
 *  @parm   LPCSTR | pszName |
 *
 *          Field name.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

    #ifndef XDEBUG
\
        #define hresFullValidStructStr_(pwsz, cwch, pszName, z, i)             \
       _hresFullValidStructStr_(pwsz, cwch)                            \

    #endif

    #define hresFullValidStructStr(Struct, f, iarg)                          \
        hresFullValidStructStr_(Struct->f, cA(Struct->f), #f, s_szProc,iarg)\


    HRESULT INLINE
    hresFullValidStructStr_(LPCWSTR pwsz, UINT cwch, LPCSTR pszName,
                            LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    if(SUCCEEDED(hres = hresFullValidReadStrW(pwsz, cwch, iarg)))
    {
    } else
    {
    #ifdef XDEBUG
        RPF("%s: Invalid value for %s",  s_szProc, pszName);
    #endif
    }
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresValidFlags2 |
 *
 *          Validate the dwFlags2 value for SetTypeInfo.  
 *
 *  @parm   IN DWORD | dwFlags2 |
 *
 *          Flags to be validated.
 *
 *  @returns
 *
 *          <c DI_OK> = <c S_OK>: The flags appear to be valid.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: The flags are invalid.
 *
 *****************************************************************************/

#ifdef XDEBUG

#define hresValidFlags2( flags, iarg ) hresValidFlags2_( flags, s_szProc, iarg )

HRESULT INLINE hresValidFlags2_
( 
    DWORD dwFlags2,
    LPCSTR s_szProc, 
    int iarg
)

#else

#define hresValidFlags2( flags, iarg ) hresValidFlags2_( flags )

HRESULT hresValidFlags2_
( 
    DWORD dwFlags2 
)

#endif
{
    if( !( dwFlags2 & ~JOYTYPE_FLAGS2_SETVALID )
     && ( ( GET_DIDEVICE_TYPEANDSUBTYPE( dwFlags2 ) == 0 )
       || GetValidDI8DevType( dwFlags2, 0, 0 ) ) ) 
    {
        return S_OK;
    }
    else
    {
    #ifdef XDEBUG
        if( dwFlags2 & ~JOYTYPE_FLAGS2_SETVALID )
        {
            RPF("%s: Invalid flags 0x%04x in HIWORD(dwFlags2) of arg %d",  
            s_szProc, HIWORD(dwFlags2), iarg);
        }
        if( GET_DIDEVICE_TYPEANDSUBTYPE( dwFlags2 )
         &&!GetValidDI8DevType( dwFlags2, 127, JOY_HWS_HASPOV | JOY_HWS_HASZ ) ) 
        {
            RPF("%s: Invalid type:subtype 0x%02x:%02x in dwFlags2 of arg %d",  
            s_szProc, GET_DIDEVICE_TYPE( dwFlags2 ), 
            GET_DIDEVICE_SUBTYPE( dwFlags2 ), iarg );
        }
    #endif
        return E_INVALIDARG;
    }
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | SetTypeInfo |
 *
 *          Creates a new joystick type
 *          or redefine information about an existing joystick type.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          Points to the name of the type.  The name of the type may
 *          not exceed MAX_JOYSTRING characters, including the terminating
 *          null character.
 *
 *          If the type name does not already exist, then it is created.
 *
 *          You cannot change the type information for a predefined type.
 *
 *          The name may not begin with
 *          a "#" character.  Types beginning with "#" are reserved
 *          by DirectInput.
 *
 *  @parm   IN LPDIJOYTYPEINFO | pjti |
 *
 *          Contains information about the joystick type.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DITC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjti> contain values which are to be set.
 *
 *  @parm   OUT LPWSTR | pwszVIDPIDTypeName |
 *          If the type name is an OEM type not in VID_xxxx&PID_yyyy format,
 *          pwszVIDPIDTypeName will return the name in VID_xxxx&PID_yyyy
 *          format that is assigned by Dinput. 
 *          This VID_xxxx&PID_yyyy name should be used in DIJOYCONFIG.wszType
 *          field when calling SetConfig.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration has not been
 *          acquired.  You must call <mf IDirectInputJoyConfig8::Acquire>
 *          before you can alter joystick configuration settings.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_READONLY>: Attempted to change a predefined type.
 *
 *****************************************************************************/

typedef struct _TYPENAME {
    WCHAR wszRealTypeName[MAX_JOYSTRING];
    WCHAR wszDITypeName[MAX_JOYSTRING/4];
} TYPENAME, *LPTYPENAME;

#ifdef WINNT
BOOL CALLBACK CJoyCfg_FindTypeProc( LPCWSTR pwszTypeName, LPVOID pv )
{
    DIJOYTYPEINFO dijti;
    LPTYPENAME lptype = (LPTYPENAME)pv;
    
    ZeroMemory( &dijti, sizeof(dijti));
    dijti.dwSize = sizeof(dijti);
    if( pwszTypeName[0] == L'\0' || pwszTypeName[0] == L'#' )
    {
        return TRUE;
    } else {
        if( SUCCEEDED(JoyReg_GetTypeInfo(pwszTypeName, &dijti, DITC_REGHWSETTINGS | DITC_DISPLAYNAME)) )
        {
            if( !lstrcmpW(dijti.wszDisplayName, lptype->wszRealTypeName) ) {
                lstrcpynW(lptype->wszDITypeName, pwszTypeName, sizeof(lptype->wszDITypeName)-1 );
                return FALSE;
            }
        }
    }

    return(TRUE);
}
#endif  // #ifdef WINNT

STDMETHODIMP
    CJoyCfg_SetTypeInfo(PDJC pdjc, LPCWSTR pwszType,
                        LPCDIJOYTYPEINFO pjti, DWORD fl, LPWSTR pwszDITypeName)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::SetTypeInfo,
               (_ "pWpx", pdjc, pwszType, pjti, fl));


    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidReadStrW(pwszType, MAX_JOYSTRING, 1)) &&

       SUCCEEDED(hres = hresFullValidReadPxCb3((PV)pjti,
                                               DIJOYTYPEINFO_DX8,
                                               DIJOYTYPEINFO_DX6,
                                               DIJOYTYPEINFO_DX5, 2)) &&
#ifdef WINNT
       SUCCEEDED(hres = hresFullValidFl(pjti->dwFlags1, JOYTYPE_FLAGS1_SETVALID, 3) ) &&
#endif
       SUCCEEDED( (pjti->dwSize == cbX(DIJOYTYPEINFO_DX8) )
                  ? ( hres = hresFullValidFl(fl, DITC_SETVALID, 3) )
                  : (pjti->dwSize == cbX(DIJOYTYPEINFO_DX6 ) )
                      ? ( hres = hresFullValidFl(fl, DITC_SETVALID_DX6, 3) )
                      : ( hres = hresFullValidFl(fl, DITC_SETVALID_DX5, 3) ) ) &&
       fLimpFF(fl & DITC_HARDWAREID,
               SUCCEEDED(hres = hresFullValidStructStr(pjti, wszHardwareId, 2))) &&
       fLimpFF(fl & DITC_DISPLAYNAME,
               SUCCEEDED(hres = hresFullValidStructStr(pjti, wszDisplayName, 2))) &&
#ifndef WINNT
       fLimpFF(fl & DITC_CALLOUT,
               SUCCEEDED(hres = hresFullValidStructStr(pjti, wszCallout, 2))) &&
#endif
       fLimpFF(fl & DITC_FLAGS2,
               SUCCEEDED(hres = hresValidFlags2( pjti->dwFlags2, 2)) ) &&
       fLimpFF(fl & DITC_MAPFILE,
               SUCCEEDED(hres = hresFullValidStructStr(pjti, wszMapFile, 2)))
      )
    {
        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);

        if(SUCCEEDED(hres = CJoyCfg_IsAcquired(this)))
        {
            switch(pwszType[0])
            {

                case L'\0':
                    RPF("%s: Invalid pwszType (null)", s_szProc);
                    hres = E_INVALIDARG;
                    break;

                case L'#':
                    RPF("%s: Invalid pwszType (predefined)", s_szProc);
                    hres = DIERR_READONLY;
                    break;

                default:
                    hres = JoyReg_SetTypeInfo(this->hkTypesW, pwszType, pjti, fl);
                    
                    if( SUCCEEDED(hres) ) {
                    #ifdef WINNT
                        TYPENAME type;
                        short DontCare;
                            
                        if( (pjti->wszHardwareId[0] == TEXT('\0')) && 
                            !(ParseVIDPID(&DontCare, &DontCare, pwszType)) )
                        {
                            lstrcpyW(type.wszRealTypeName, pwszType);
                            hres = CJoyCfg_EnumTypes(pdjc, CJoyCfg_FindTypeProc, &type);
                            if( SUCCEEDED(hres) ) {
                                if( !IsBadWritePtr((LPVOID)pwszDITypeName, lstrlenW(type.wszDITypeName)) )
                                {
                                    CharUpperW(type.wszDITypeName);
                                    lstrcpyW(pwszDITypeName, type.wszDITypeName);
                                } else {
                                    hres = ERROR_NOT_ENOUGH_MEMORY;
                                }
                            }
                        } else 
                    #endif
                        {
                            if( !IsBadWritePtr((LPVOID)pwszDITypeName, lstrlenW(pwszType)) )
                            {
                                lstrcpyW(pwszDITypeName, pwszType);
                            } else {
                                hres = ERROR_NOT_ENOUGH_MEMORY;
                            }
                        }
                    }
                    break;
            }
        }
        CJoyCfg_LeaveCrit(this);
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | DeleteType |
 *
 *          Removes information about a joystick type.
 *
 *          Use this method with caution; it is the caller's responsibility
 *          to ensure that no joystick refers to the deleted type.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   LPCWSTR | pwszTypeName |
 *
 *          Points to the name of the type.  The name of the type may
 *          not exceed <c MAX_PATH> characters, including the terminating
 *          null character.
 *
 *          The name may not begin with
 *          a "#" character.  Types beginning with "#" are reserved
 *          by DirectInput.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration has not been
 *          acquired.  You must call <mf IDirectInputJoyConfig8::Acquire>
 *          before you can alter joystick configuration settings.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_DeleteType(PDJC pdjc, LPCWSTR pwszType)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::DeleteType, (_ "pW", pdjc, pwszType));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidReadStrW( pwszType, MAX_JOYSTRING, 1)))
    {

        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);

        if(SUCCEEDED(hres = CJoyCfg_IsAcquired(this)))
        {
            LONG lRc;
            switch(pwszType[0])
            {

                case L'\0':
                    RPF("%s: Invalid pwszType (null)", s_szProc);
                    hres = E_INVALIDARG;
                    break;

                case L'#':
                    RPF("%s: Invalid pwszType (predefined)", s_szProc);
                    hres = DIERR_READONLY;
                    break;

                default:

#ifdef WINNT
    #ifdef UNICODE
                    lRc = DIWinnt_RegDeleteKey(this->hkTypesW, (LPTSTR)pwszType);
    #else
                    {
                        CHAR sz[MAX_PATH];
                        UToA( sz, cA(sz), pwszType );
                        lRc = DIWinnt_RegDeleteKey(this->hkTypesW, (LPTSTR)sz);
                    }
    #endif
#else
    #ifdef UNICODE
                    lRc = RegDeleteKey(this->hkTypesW, (LPTSTR)pwszType);
    #else
                    {
                        CHAR sz[MAX_PATH];
                        UToA( sz, cA(sz), pwszType );
                        lRc = RegDeleteKey(this->hkTypesW, (LPTSTR)sz);
                    }
    #endif
#endif
    
/*
    #ifdef WINNT
                        lRc = DIWinnt_RegDeleteKey(this->hkTypesW, pwszType);
    #else
                        lRc = RegDeleteKeyW(this->hkTypesW, pwszType);
    #endif
*/

                    if(lRc == ERROR_SUCCESS)
                    {
                        hres = S_OK;
                    } else
                    {
                        if(lRc == ERROR_KEY_DELETED || lRc == ERROR_BADKEY)
                        {
                            lRc = ERROR_FILE_NOT_FOUND;
                        }
                        hres = hresLe(lRc);
                    }
                    break;
            }
        }
        CJoyCfg_LeaveCrit(this);
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | GetConfig |
 *
 *          Obtain information about a joystick's configuration.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   UINT | uiJoy |
 *
 *          Joystick identification number.  This is a nonnegative
 *          integer.  To enumerate joysticks, begin with joystick
 *          zero and increment the joystick number by one until the
 *          function returns <c DIERR_NOMOREITEMS>.
 *
 *          Yes, it's different from all other DirectX enumerations.
 *
 *
 *  @parm   IN OUT LPDIJOYCONFIG | pjc |
 *
 *          Receives information about the joystick configuration.
 *          The caller "must" initialize the <e DIJOYCONFIG.dwSize>
 *          field before calling this method.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjc> are to be filled in.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c S_FALSE>: The specified joystick has not yet been
 *          configured.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_NOMOREITEMS>: No more joysticks.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_GetConfig(PDJC pdjc, UINT uiJoy, LPDIJOYCONFIG pjc, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::GetConfig,
               (_ "pupx", pdjc, uiJoy, pjc, fl));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb2(pjc,
                                                DIJOYCONFIG_DX6,
                                                DIJOYCONFIG_DX5, 2)) &&
       SUCCEEDED( (pjc->dwSize == cbX(DIJOYCONFIG)
                   ? (hres = hresFullValidFl(fl, DIJC_GETVALID, 3) )
                   : (hres = hresFullValidFl(fl, DIJC_GETVALID_DX5, 3)))) )
    {

        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);

        /*
         *  Note that we always get the DIJC_REGHWCONFIGTYPE because
         *  we need to check if the joystick type is "none".
         */
        hres = JoyReg_GetConfig(uiJoy, pjc, fl | DIJC_REGHWCONFIGTYPE);

        if(SUCCEEDED(hres))
        {
#ifndef WINNT           
            static WCHAR s_wszMSGAME[] = L"MSGAME.VXD";

            if(memcmp(pjc->wszCallout, s_wszMSGAME, cbX(s_wszMSGAME)) == 0)
            {
                 ; // do nothing
            } else 
#endif            
            if(fInOrder(JOY_HW_PREDEFMIN, pjc->hwc.dwType,
                        JOY_HW_PREDEFMAX))
            {
                pjc->wszType[0] = TEXT('#');
                pjc->wszType[1] = CJoyCfg_CharFromType(pjc->hwc.dwType);
                pjc->wszType[2] = TEXT('\0');

            }

            if(pjc->hwc.dwType == JOY_HW_NONE)
            {
                hres = S_FALSE;
            } else
            {
                hres = S_OK;
            }

            /*
             *  In DEBUG, re-scramble the hwc and type if the caller
             *  didn't ask for it.
             */
            if(!(fl & DIJC_REGHWCONFIGTYPE))
            {
                ScrambleBuf(&pjc->hwc, cbX(pjc->hwc));
                ScrambleBuf(&pjc->wszType, cbX(pjc->wszType));
            }
        }

        CJoyCfg_LeaveCrit(this);
    }
    ExitBenignOleProcR();
    return hres;
}

#if 0
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | CJoyCfg | UpdateGlobalGain |
 *
 *          Create the device callback so we can talk to its driver and
 *          tell it to change the gain value.
 *
 *          This function must be called under the object critical section.
 *
 *  @cwrap  PJC | this
 *
 *  @parm   DWORD | idJoy |
 *
 *          The joystick identifier.
 *
 *  @parm   DWORD | dwCplGain |
 *
 *          New global gain.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_UpdateGlobalGain(PJC this, DWORD idJoy, DWORD dwCplGain)
{
    HRESULT hres;
    EnterProcI(CJoyCfg_UpdateGlobalGain, (_ "puu", this, idJoy, dwCplGain));

    AssertF(CJoyCfg_InCrit(this));

    /*
     *  Create the deviceeffect shepherd if we don't already have it.
     */

    if(this->pes && idJoy == this->idJoyCache)
    {
        hres = S_OK;
    } else if(idJoy < cA(rgGUID_Joystick))
    {
        PCGUID rguid;
    #ifdef DEBUG
        CREATEDCB CreateDcb;
    #endif
        IDirectInputDeviceCallback *pdcb;

        /*
         *  Assume the creation will work.
         */
        this->idJoyCache = idJoy;

        /*
         *  Out with the old...
         */
        Invoke_Release(&this->pes);

        /*
         *  And in with the new...
         */
        rguid = &rgGUID_Joystick[idJoy];

    #ifdef DEBUG
        hres = hresFindInstanceGUID(rguid, &CreateDcb, 1);
        AssertF(SUCCEEDED(hres));
        AssertF(CreateDcb == CJoy_New);
    #endif

        if(SUCCEEDED(hres = CJoy_New(0, rguid,
                                     &IID_IDirectInputDeviceCallback,
                                     (PPV)&pdcb)))
        {
            hres = pdcb->lpVtbl->CreateEffect(pdcb, &this->pes);

            Invoke_Release(&pdcb);
        }

    } else
    {
        hres = DIERR_DEVICENOTREG;
    }

    /*
     *  If we have an effect shepherd, then tell it what the new
     *  global gain is.
     */
    if(SUCCEEDED(hres))
    {
        AssertF(this->pes && idJoy == this->idJoyCache);

        hres = this->pes->lpVtbl->SetGlobalGain(this->pes, dwCplGain);
    }


    ExitOleProc();
    return hres;
}
#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | SetConfig |
 *
 *          Create or redefine configuration information about a joystick.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   UINT | idJoy |
 *
 *          Zero-based joystick identification number.
 *
 *  @parm   IN LPDIJOYCONFIG | pcfg |
 *
 *          Contains information about the joystick.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIJC_*> flags
 *          which specify which parts of the structure pointed
 *          to by <p pjc> contain information to be set.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration has not been
 *          acquired.  You must call <mf IDirectInputJoyConfig8::Acquire>
 *          before you can alter joystick configuration settings.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *  @devnote
 *
 *          This one is tricky.  If the type begins with a sharp, then
 *          it's an internal type.  And if it is null, then it's a
 *          custom type.
 *
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_SetConfig(PDJC pdjc, UINT idJoy, LPCDIJOYCONFIG pcfg, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::SetConfig,
               (_ "pupx", pdjc, idJoy, pcfg, fl));


    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidReadPxCb2(pcfg,
                                               DIJOYCONFIG_DX6,
                                               DIJOYCONFIG_DX5, 2)) &&
       SUCCEEDED( (pcfg->dwSize == cbX(DIJOYCONFIG)
                   ? ( hres = hresFullValidFl(fl, DIJC_SETVALID, 3) )
                   : ( hres = hresFullValidFl(fl, DIJC_SETVALID_DX5,3)) )) &&
       fLimpFF(fl & DIJC_REGHWCONFIGTYPE,
               SUCCEEDED(hres = hresFullValidStructStr(pcfg, wszType, 2))) &&
#ifndef WINNT
       fLimpFF(fl & DIJC_CALLOUT,
               SUCCEEDED(hres = hresFullValidStructStr(pcfg, wszCallout, 2))) &&
#endif
       fLimpFF(fl & DIJC_WDMGAMEPORT,
               SUCCEEDED(hres = hresFullValidGuid(&pcfg->guidGameport, 2)))
      )
    {

        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);

        if(SUCCEEDED(hres = CJoyCfg_IsAcquired(this)))
        {
            JOYREGHWCONFIG jwc;

            // We just ignore the DIJC_WDMGAMEPORT flag for Win9x passed by user.
            // We will detect it ourself.
#ifndef WINNT
            fl &= ~DIJC_WDMGAMEPORT;
#endif


            if(fl & DIJC_REGHWCONFIGTYPE)
            {
                LPDWORD lpStart, lp;

                jwc = pcfg->hwc;

                /*
                 * Need to check whether the whole jwc is zero.
                 * If all are zero, we won't set it to JOY_HW_CUSTOM type.
                 * See manbug: 39542.
                 */
                for( lpStart=(LPDWORD)&jwc, lp=(LPDWORD)&jwc.dwReserved; lp >= lpStart; lp-- ) {
                    if( *lp ) {
                        break;
                    }
                }

                if( lp < lpStart ) {
                    goto _CONTINUE_SET;
                }

                jwc.dwUsageSettings &= ~JOY_US_ISOEM;

                if(pcfg->wszType[0] == TEXT('\0'))
                {
                    jwc.dwType = JOY_HW_CUSTOM;
                } else if(pcfg->wszType[0] == TEXT('#'))
                {
                    jwc.dwType = CJoyCfg_TypeFromChar(pcfg->wszType[1]);
                    if(fInOrder(JOY_HW_PREDEFMIN, jwc.dwType,
                                JOY_HW_PREDEFMAX) &&
                       pcfg->wszType[2] == TEXT('\0'))
                    {
                        /*
                         * If we want to use WDM for predefined devices, 
                         * then take away the comments.
                         *
                         *  fl |= DIJC_WDMGAMEPORT;
                         */
                    } else
                    {
                        RPF("%s: Invalid predefined type \"%ls\"",
                            s_szProc, pcfg->wszType);
                        hres = E_INVALIDARG;
                        goto done;
                    }
                } else
                {
                    /*
                     *  The precise value of jwc.dwType is not relevant.
                     *  The Windows 95 joystick control panel sets the
                     *  value to JOY_HW_PREDEFMAX + id, so we will too.
                     */
                    jwc.dwUsageSettings |= JOY_US_ISOEM;
                    jwc.dwType = JOY_HW_PREDEFMAX + idJoy;

                #ifndef WINNT
                    if( !(fl & DIJC_WDMGAMEPORT) ) {
                        HKEY hk;

                        hres = JoyReg_OpenTypeKey(pcfg->wszType, MAXIMUM_ALLOWED, REG_OPTION_NON_VOLATILE, &hk);

                        if( SUCCEEDED( hres ) ) {
                            hres = JoyReg_IsWdmGameport( hk );
                            if( SUCCEEDED(hres) ) {
                                fl |= DIJC_WDMGAMEPORT;
                            }
                            RegCloseKey( hk );
                        }
                    }
                #endif
                }
            }

_CONTINUE_SET:

          #ifdef WINNT
            fl |= DIJC_WDMGAMEPORT;

            if(
          #else
            if( (fl & DIJC_WDMGAMEPORT) && 
          #endif
                (cbX(*pcfg) >= cbX(DIJOYCONFIG_DX6)) )
            {
              #ifndef WINNT
                if( (pcfg->hwc.hws.dwFlags & JOY_HWS_ISANALOGPORTDRIVER)   // USB joystick
                    && !fVjoydDeviceNotExist )   // WDM gameport joystick and no VJOYD is used.
                {
                    /*
                     * This is in Win9X, and VJOYD devices are being used.
                     * We don't want to add WDM device at the same time.
                     */
                    hres = E_FAIL;
                }
                else
              #endif
                { 
                    DIJOYCONFIG cfg;
                    GUID guidGameport = {0xcae56030, 0x684a, 0x11d0, 0xd6, 0xf6, 0x00, 0xa0, 0xc9, 0x0f, 0x57, 0xda};
                    
                    if( fHasAllBitsFlFl( fl, DIJC_GUIDINSTANCE | DIJC_REGHWCONFIGTYPE | DIJC_GAIN | DIJC_WDMGAMEPORT ) )
                    {
                        memcpy( &cfg, pcfg, sizeof(DIJOYCONFIG) );
                    } else {
                        hres = JoyReg_GetConfig( idJoy, &cfg, DIJC_GUIDINSTANCE | DIJC_REGHWCONFIGTYPE | DIJC_GAIN | DIJC_WDMGAMEPORT);
        
                        if( SUCCEEDED(hres) ) {
                            if( fl & DIJC_GUIDINSTANCE ) {
                                 cfg.guidInstance = pcfg->guidInstance;
                            }
        
                            if( fl & DIJC_GAIN ) {
                                 cfg.dwGain = pcfg->dwGain;
                            }
        
                            if( fl & DIJC_REGHWCONFIGTYPE ) {
                                memcpy( &cfg.hwc, &pcfg->hwc, sizeof(JOYREGHWCONFIG) );
                                memcpy( &cfg.wszType, &pcfg->wszType, sizeof(pcfg->wszType) );
                            }
        
                            if( fl & DIJC_WDMGAMEPORT ) {
                                cfg.guidGameport = pcfg->guidGameport;
                            }
                        } else {
                            memcpy( &cfg, pcfg, sizeof(DIJOYCONFIG) );
                        }
                    }
                    
                    /*
                     * use standard guidGameport if it is NULL.
                     */
                    if( IsEqualGUID(&cfg.guidGameport, &GUID_NULL) )
                    {
                        memcpy( &cfg.guidGameport, &guidGameport, sizeof(GUID) ); 
                    }

                    if( IsEqualGUID(&cfg.guidInstance, &GUID_NULL) )
                    {
                        DWORD i;    
                        DIJOYCONFIG cfg2;

                        hres = DIWdm_SetConfig(idJoy, &jwc, &cfg, fl );

                        if( SUCCEEDED(hres) )
                        {
                            // We can't set the correct id from above call, so we have to find
                            // which id we set and try again.
                            for( i=0; i<16; i++ ) {
                                hres = JoyReg_GetConfig( i, &cfg2, DIJC_GUIDINSTANCE | DIJC_REGHWCONFIGTYPE | DIJC_GAIN | DIJC_WDMGAMEPORT);
                                if( SUCCEEDED(hres) && (i != idJoy) ) {
                                    if( lstrcmpW(cfg.wszType, cfg2.wszType) == 0 ) {
                                        hres = DIWdm_SetJoyId(&cfg2.guidInstance, idJoy);
                                        break;
                                    }
                                }
                            }

                            hres = JoyReg_SetConfig(idJoy, &jwc, &cfg, fl);
                        
                        }
                        goto done;
                    } else
                    {
                        /*
                         * Since pcfg is not null, we set it here to avoid calling
                         * DIWdm_JoyHidMapping. Even if it fails, it doesn't hurt anything.
                         */
                        hres = JoyReg_SetConfig(idJoy, &jwc, &cfg, fl);
                        hres = DIWdm_SetJoyId(&cfg.guidInstance, idJoy);
                        hres = JoyReg_SetConfig(idJoy, &jwc, &cfg, fl);
                    }
                }
            } else {
                hres = JoyReg_SetConfig(idJoy, &jwc, pcfg, DIJC_UPDATEALIAS | fl);
              
                if (SUCCEEDED(hres)) {
                  #ifdef WINNT
                    PostMessage(HWND_BROADCAST, g_wmJoyChanged, idJoy+1, 0L);   
                  #else
                    joyConfigChanged(0);
                    fVjoydDeviceNotExist = FALSE;
                  #endif
               }
            }

        }

        done:;
        CJoyCfg_LeaveCrit(this);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | DeleteConfig |
 *
 *          Delete configuration information about a joystick.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   UINT | idJoy |
 *
 *          Zero-based joystick identification number.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration has not been
 *          acquired.  You must call <mf IDirectInputJoyConfig8::Acquire>
 *          before you can alter joystick configuration settings.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

DIJOYCONFIG c_djcReset = {
    cbX(c_djcReset),                    /* dwSize               */
    { 0},                              /* guidInstance         */
    { 0},                              /* hwc                  */
    DI_FFNOMINALMAX,                    /* dwGain               */
    { 0},                              /* wszType              */
    { 0},                              /* wszCallout           */
};

STDMETHODIMP
    CJoyCfg_DeleteConfig(PDJC pdjc, UINT idJoy)
{
    HRESULT hres;

    EnterProcR(IDirectInputJoyConfig8::DeleteConfig, (_ "pu", pdjc, idJoy));

    if(SUCCEEDED(hres = hresPv(pdjc)))
    {

        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);


        if(SUCCEEDED(hres = CJoyCfg_IsAcquired(this)))
        {

            HKEY hk;
            TCHAR tsz[MAX_JOYSTRING];
            DIJOYCONFIG dijcfg;

            hres = DIWdm_DeleteConfig(idJoy);

          #ifndef WINNT
            if( hres == DIERR_DEVICENOTREG ) {
                fVjoydDeviceNotExist = TRUE;
            }
          #endif

            /*
             *  To delete it, set everything to the Reset values and
             *  delete the configuration subkey.
             */
            if( ( SUCCEEDED(hres) || hres == DIERR_DEVICENOTREG ) &&
                SUCCEEDED(hres = JoyReg_SetConfig(idJoy, &c_djcReset.hwc,
                                                 &c_djcReset, DIJC_SETVALID)) &&
               SUCCEEDED(hres = JoyReg_OpenConfigKey(idJoy, MAXIMUM_ALLOWED,
                                                     REG_OPTION_VOLATILE, &hk)))
            {

                wsprintf(tsz, TEXT("%u"), idJoy + 1);

                // DIWinnt_RegDeleteKey:: name is a mismomer, the function
                // recursively deletes the key and all subkeys.
                DIWinnt_RegDeleteKey(hk, tsz);

                RegCloseKey(hk);

              #ifndef WINNT
                joyConfigChanged(0);
              #endif
              
                hres = S_OK;
            }
        
            if( FAILED(hres) )
            {
                if( FAILED( JoyReg_GetConfig(idJoy, &dijcfg, DIJC_REGHWCONFIGTYPE | DIJC_GUIDINSTANCE) ) )
                {
                /* No config exists, so vacuous success on delete */
                    hres = S_FALSE;
                }
            }
        }

        CJoyCfg_LeaveCrit(this);
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | GetUserValues |
 *
 *          Obtain information about user settings for the joystick.
 *
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   IN OUT LPDIJOYUSERVALUES | pjuv |
 *
 *          Receives information about the user joystick configuration.
 *          The caller "must" initialize the <e DIJOYUSERVALUES.dwSize>
 *          field before calling this method.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIJU_*> flags specifying which parts
 *          of the <t DIJOYUSERVALUES> structure contain values
 *          which are to be retrieved.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_GetUserValues(PDJC pdjc, LPDIJOYUSERVALUES pjuv, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::GetUserValues,
               (_ "ppx", pdjc, pjuv, fl));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidWritePxCb(pjuv, DIJOYUSERVALUES, 2)) &&
       SUCCEEDED(hres = hresFullValidFl(fl, DIJU_GETVALID, 3)))
    {
        PJC this = _thisPvNm(pdjc, djc);

        hres = JoyReg_GetUserValues(pjuv, fl);
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidUVStr |
 *
 *          Validate a string field in a <t DIJOYUSERVALUES>.
 *
 *  @parm   IN LPCWSTR | pwsz |
 *
 *          String to be validated.
 *
 *  @parm   UINT | cwch |
 *
 *          Maximum string length.
 *
 *  @parm   LPCSTR | pszName |
 *
 *          Field name.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

    #ifndef XDEBUG

        #define hresFullValidUVStr_(pwsz, cwch, pszName, z, i)              \
       _hresFullValidUVStr_(pwsz, cwch)                             \

    #endif

    #define hresFullValidUVStr(pjuv, f, iarg)                           \
        hresFullValidUVStr_(pjuv->f, cA(pjuv->f), #f, s_szProc,iarg)\


HRESULT INLINE
    hresFullValidUVStr_(LPCWSTR pwsz, UINT cwch, LPCSTR pszName,
                        LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    if(SUCCEEDED(hres = hresFullValidReadStrW(pwsz, cwch, iarg)))
    {
    } else
    {
    #ifdef XDEBUG
        RPF("%s: Invalid value for DIJOYUSERVALUES.%s", s_szProc, pszName);
    #endif
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | SetUserValues |
 *
 *          Set the user settings for the joystick.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   IN LPCDIJOYUSERVALUES | pjuv |
 *
 *          Contains information about the new user joystick settings.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Zero or more <c DIJU_*> flags specifying which parts
 *          of the <t DIJOYUSERVALUES> structure contain values
 *          which are to be set.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration has not been
 *          acquired.  You must call <mf IDirectInputJoyConfig8::Acquire>
 *          before you can alter joystick configuration settings.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_SetUserValues(PDJC pdjc, LPCDIJOYUSERVALUES pjuv, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::SetUserValues,
               (_ "pp", pdjc, pjuv, fl));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidReadPxCb(pjuv, DIJOYUSERVALUES, 2)) &&
       fLimpFF(fl & DIJU_GLOBALDRIVER,
               SUCCEEDED(hres = hresFullValidUVStr(pjuv,
                                                   wszGlobalDriver, 2))) &&
       fLimpFF(fl & DIJU_GAMEPORTEMULATOR,
               SUCCEEDED(hres = hresFullValidUVStr(pjuv,
                                                   wszGameportEmulator, 2))) &&
       SUCCEEDED(hres = hresFullValidFl(fl, DIJU_SETVALID, 3)))
    {

        PJC this = _thisPvNm(pdjc, djc);

        CJoyCfg_EnterCrit(this);

        if(SUCCEEDED(hres = CJoyCfg_IsAcquired(this)))
        {
            hres = JoyReg_SetUserValues(pjuv, fl);
        }

        CJoyCfg_LeaveCrit(this);
    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | AddNewHardware |
 *
 *          Displays the "Add New Hardware" dialog to
 *          guide the user through installing
 *          new game controller.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   HWND | hwndOwner |
 *
 *          Window to act as owner window for UI.
 *
 *  @parm   REFGUID | rguidClass |
 *
 *          <t GUID> which specifies the class of the hardware device
 *          to be added.  DirectInput comes with the following
 *          class <t GUIDs> already defined:
 *
 *          <c GUID_KeyboardClass>: Keyboard devices.
 *
 *          <c GUID_MouseClass>: Mouse devices.
 *
 *          <c GUID_MediaClass>: Media devices, including joysticks.
 *
 *          <c GUID_HIDClass>: HID devices.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_INVALIDCLASSINSTALLER>: The "media" class installer
 *          could not be found or is invalid.
 *
 *          <c DIERR_CANCELLED>: The user cancelled the operation.
 *
 *          <c DIERR_BADINF>: The INF file for the device the user
 *          selected could not be found or is invalid or is damaged.
 *
 *          <c S_FALSE>: DirectInput could not determine whether the
 *          operation completed successfully.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_AddNewHardware(PDJC pdjc, HWND hwnd, REFGUID rguid)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::AddNewHardware,
               (_ "pxG", pdjc, hwnd, rguid));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidHwnd0(hwnd, 1)) &&
       SUCCEEDED(hres = hresFullValidGuid(rguid, 2)))
    {

        PJC this = _thisPvNm(pdjc, djc);

        hres = AddNewHardware(hwnd, rguid);

    }
    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | OpenTypeKey |
 *
 *          Open the registry key associated with a joystick type.
 *
 *          Control panel applications can use this key to store
 *          per-type persistent information, such as global
 *          configuration parameters.
 *
 *          Such private information should be kept in a subkey
 *          named "OEM"; do not store private information in the
 *          main type key.
 *
 *          Control panel applications can also use this key to
 *          read configuration information, such as the strings
 *          to use for device calibration prompts.
 *
 *          The application should use <f RegCloseKey> to close
 *          the registry key.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   LPCWSTR | pwszType |
 *
 *          Points to the name of the type.  The name of the type may
 *          not exceed <c MAX_PATH> characters, including the terminating
 *          null character.
 *
 *          The name may not begin with
 *          a "#" character.  Types beginning with "#" are reserved
 *          by DirectInput.
 *
 *  @parm   REGSAM | regsam |
 *
 *          Registry security access mask.  This can be any of the
 *          values permitted by the <f RegOpenKeyEx> function.
 *          If write access is requested, then joystick
 *          configuration must first have been acquired.
 *          If only read access is requested, then acquisition is
 *          not required.
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the opened registry key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_NOTACQUIRED>: Joystick configuration has not been
 *          acquired.  You must call <mf IDirectInputJoyConfig8::Acquire>
 *          before you can open a joystick type configuration key
 *          for writing.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ErrorCode)>:
 *          A Win32 error code if access to the key is denied by
 *          registry permissions or some other external factor.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_OpenTypeKey(PDJC pdjc, LPCWSTR pwszType, REGSAM sam, PHKEY phk)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::OpenTypeKey,
               (_ "pWx", pdjc, pwszType, sam));

    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidReadStrW(pwszType, MAX_JOYSTRING, 1)) &&
       SUCCEEDED(hres = hresFullValidPcbOut(phk, cbX(*phk), 3)))
    {

        PJC this = _thisPvNm(pdjc, djc);

        if(pwszType[0] != TEXT('#'))
        {
            /*
             *  Attempting to get write access requires acquisition.
             */
            if(fLimpFF(IsWriteSam(sam),
                       SUCCEEDED(hres = CJoyCfg_IsAcquired(this))))
            {
                hres = JoyReg_OpenTypeKey(pwszType, sam, REG_OPTION_NON_VOLATILE, phk);
            }
        } else
        {
            RPF("%s: Invalid pwszType (predefined)", s_szProc);
            hres = E_INVALIDARG;
        }
    }
    ExitOleProcR();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputJoyConfig8 | OpenAppStatusKey |
 *
 *          Opens the root key of the application status registry keys.
 *
 *          Hardware vendors can use the sub keys of this key to inspect the 
 *          status of DirectInput applications with respect to the 
 *          functionality they use.  The key is opened with KEY_READ access.
 *
 *          Vendors are cautioned against opening these keys directly (by 
 *          finding the absolute path of the key rather than using this method) 
 *          as the absolute registry path may vary on different Windows 
 *          platforms or in future versions of DirectInput.
 *
 *          The application should use <f RegCloseKey> to close
 *          the registry key.
 *
 *  @cwrap  LPDIRECTINPUTJOYCONFIG8 | LPDIRECTINPUTJOYCONFIG8
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives the opened registry key on success.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>: One or more
 *          parameters was invalid.
 *
 *          <c DIERR_NOTFOUND>: The key is missing on this system.
 *          Applications should proceed as if the key were empty.
 *
 *          <c MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, ErrorCode)>:
 *          A Win32 error code if access to the key is denied by
 *          registry permissions or some other external factor.
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_OpenAppStatusKey(PDJC pdjc, PHKEY phk)
{
    HRESULT hres;
    EnterProcR(IDirectInputJoyConfig8::OpenAppStatusKey,
               (_ "pp", pdjc, phk));


    if(SUCCEEDED(hres = hresPv(pdjc)) &&
       SUCCEEDED(hres = hresFullValidPcbOut(phk, cbX(*phk), 1)))
    {
        PJC this = _thisPvNm(pdjc, djc);

        hres = hresMumbleKeyEx( HKEY_CURRENT_USER, REGSTR_PATH_DINPUT, 
            KEY_READ, REG_OPTION_NON_VOLATILE, phk);
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *      CJoyCfg_New       (constructor)
 *
 *****************************************************************************/

STDMETHODIMP
    CJoyCfg_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(IDirectInputJoyConfig8::<constructor>,
               (_ "p", ppvObj));

    if (SUCCEEDED(hres = hresFullValidPcbOut(ppvObj, cbX(*ppvObj), 3)))
    {
        LPVOID pvTry = NULL;
        hres = Common_NewRiid(CJoyCfg, punkOuter, riid, &pvTry);

        if(SUCCEEDED(hres))
        {
            /* Must use _thisPv in case of aggregation */
            PJC this = _thisPv(pvTry);

            this->fCritInited = fInitializeCriticalSection(&this->crst);
            if( this->fCritInited )
            {
                *ppvObj = pvTry;
                hres = S_OK;
            }
            else
            {
                Common_Unhold(this);
                *ppvObj = NULL;
                hres = E_OUTOFMEMORY;
            }
        }
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

    #pragma BEGIN_CONST_DATA

    #define CJoyCfg_Signature        0x6766434B      /* "JCfg" */

Primary_Interface_Begin(CJoyCfg, IDirectInputJoyConfig8)
CJoyCfg_Acquire,
CJoyCfg_Unacquire,
CJoyCfg_SetCooperativeLevel,
CJoyCfg_SendNotify,
CJoyCfg_EnumTypes,
CJoyCfg_GetTypeInfo,
CJoyCfg_SetTypeInfo,
CJoyCfg_DeleteType,
CJoyCfg_GetConfig,
CJoyCfg_SetConfig,
CJoyCfg_DeleteConfig,
CJoyCfg_GetUserValues,
CJoyCfg_SetUserValues,
CJoyCfg_AddNewHardware,
CJoyCfg_OpenTypeKey,
CJoyCfg_OpenAppStatusKey,
Primary_Interface_End(CJoyCfg, IDirectInputJoyConfig8)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dilist.c ===
/*****************************************************************************
 *
 *  DIList.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      List management.  Really, array management, since our lists
 *      never get very big.
 *
 *      We call them "GPA"s, which stands for "Growable Pointer Array".
 *
 *      There is a more general GXA gizmo in Dr Watson, but we don't
 *      need it yet.  So far, all we need to track is unsorted
 *      lists of pointers.
 *
 *      Yes, there exists a matching concept in COMCTL32, but we can't
 *      use it because
 *
 *      (1) it's not documented,
 *      (2) COMCTL32 puts them into shared memory, which is just
 *          begging for a memory leak.
 *
 *  Contents:
 *
 *      GPA_Init
 *      GPA_Term
 *
 *****************************************************************************/

#include "dinputpr.h"


/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflGpa



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GPA_Print |
 *
 *          Print state of the growing pointer array.
 *
 *  @parm   HGPA | hgpa |
 *
 *  @returns    void
 *
 *****************************************************************************/
void INTERNAL
GPA_Print(HGPA hgpa)
{
    int ipv;
    for (ipv = 0; ipv < hgpa->cpv; ipv++)
    {
		// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
        SquirtSqflPtszV( sqflError,
                        TEXT("ipv=%d,hgpa->rgpv[ipv]=%p"),
                        ipv, hgpa->rgpv[ipv]);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GPA_Append |
 *
 *          Add a new item to the growing pointer array.
 *
 *          Note that we add 8 after doubling, so that we don't get
 *          stuck if cxAlloc is zero.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *  @parm   PV | pv |
 *
 *          Pointer to add.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
GPA_Append(HGPA hgpa, PV pv)
{
    HRESULT hres;

    if (hgpa->cpv >= hgpa->cpvAlloc) {
        hres = ReallocCbPpv(cbX(PV) * (hgpa->cpvAlloc * 2 + 8),
                            &hgpa->rgpv);
        // Prefix: Whistler 45077.   
        if (FAILED(hres) || ( hgpa->rgpv == NULL) ) {
            goto done;
        }

        hgpa->cpvAlloc = hgpa->cpvAlloc * 2 + 8;
    }

    //hgpa->rgpv[hgpa->cpv++] = pv;
    hgpa->rgpv[hgpa->cpv] = pv;
    InterlockedIncrement(&hgpa->cpv);

    hres = S_OK;


done:;
    //GPA_Print(hgpa);
    return hres;

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | GPA_FindPtr |
 *
 *          Determine whether a pointer is in the GPA.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *  @parm   PV | pv |
 *
 *          Pointer to locate.
 *
 *  @returns
 *
 *          Returns a COM error code on failure.
 *
 *          On success, returns the number of items left in the GPA.
 *
 *****************************************************************************/

BOOL EXTERNAL
GPA_FindPtr(HGPA hgpa, PV pv)
{
    BOOL fRc;
    int ipv;

    for (ipv = 0; ipv < hgpa->cpv; ipv++) {
        if (hgpa->rgpv[ipv] == pv) {
            fRc = TRUE;
            goto done;
        }
    }

    fRc = FALSE;

done:;
    return fRc;

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GPA_DeletePtr |
 *
 *          Remove the indicated pointer from the GPA.  The order of
 *          the remaining items is unspecified.
 *
 *          Note that CEm_LL_ThreadProc assumes that no items before
 *          the deleted item are affected by the deletion.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *  @parm   PV | pv |
 *
 *          Pointer to delete.
 *
 *  @returns
 *
 *          Returns a COM error code on failure.
 *
 *          On success, returns the number of items left in the GPA.
 *
 *****************************************************************************/

STDMETHODIMP
GPA_DeletePtr(HGPA hgpa, PV pv)
{
    HRESULT hres;
    int ipv;

    for (ipv = 0; ipv < hgpa->cpv; ipv++) {
        if (hgpa->rgpv[ipv] == pv) {
            //hgpa->rgpv[ipv] = hgpa->rgpv[--hgpa->cpv];
            InterlockedDecrement(&hgpa->cpv);
            hgpa->rgpv[ipv] = hgpa->rgpv[hgpa->cpv];
            hres = hgpa->cpv;
            goto done;
        }
    }

    hres = E_FAIL;

done:;
    //GPA_Print(hgpa);
    return hres;

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GPA_Clone |
 *
 *          Copy the contents of one GPA to another.
 *
 *  @parm   HGPA | hgpaDst |
 *
 *          Handle to destination pointer array.
 *
 *  @parm   HGPA | hgpaSrc |
 *
 *          Handle to source pointer array.
 *
 *****************************************************************************/

STDMETHODIMP
GPA_Clone(HGPA hgpaDst, HGPA hgpaSrc)
{
    HRESULT hres;

    hres = AllocCbPpv(cbCxX(hgpaSrc->cpv, PV), &hgpaDst->rgpv);

    if (SUCCEEDED(hres)) {
        CopyMemory(hgpaDst->rgpv, hgpaSrc->rgpv, cbCxX(hgpaSrc->cpv, PV));
        hgpaDst->cpv = hgpaSrc->cpv;
        hgpaDst->cpvAlloc = hgpaSrc->cpvAlloc;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | GPA_Init |
 *
 *          Initialize a GPA structure with no elements.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *****************************************************************************/

void EXTERNAL
GPA_Init(HGPA hgpa)
{
    hgpa->rgpv = 0;
    hgpa->cpv = 0;
    hgpa->cpvAlloc = 0;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | GPA_Term |
 *
 *          Clean up an existing GPA.
 *
 *  @parm   HGPA | hgpa |
 *
 *          Handle to pointer array.
 *
 *****************************************************************************/

void EXTERNAL
GPA_Term(HGPA hgpa)
{
    FreePpv(&hgpa->rgpv);
    GPA_Init(hgpa);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dimapshp.c ===
/*****************************************************************************
 *
 *  dimapshp.c
 *
 *  Copyright (c) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The IDirectInputMapperW shepherd.
 *
 *      The shepherd does the annoying work of babysitting the
 *      IDirectInputMapperW.
 *
 *      It makes sure nobody parties on bad handles.
 *
 *      It handles cross-process (or even intra-process) effect
 *      management.
 *
 *  Contents:
 *
 *      CMapShep_New
 *
 *****************************************************************************/

#include "dinputpr.h"
#ifdef UNICODE
#undef _UNICODE
#define _UNICODE
#endif // !UNICODE


/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflEShep/*Should we use own area?*/

#pragma BEGIN_CONST_DATA


/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

  Primary_Interface(CMapShep, IDirectInputMapShepherd);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CMapShep |
 *
 *          The <i IDirectInputMapShepherd> object, which
 *          babysits an <i IDirectInputMapperW>.
 *
 *  @field  IDirectInputMapShepherd | dms |
 *
 *          DirectInputMapShepherd object (containing vtbl).
 *
 *  @field  IDirectInputMapperW * | pdimap |
 *
 *          Delegated mapper interface.
 *
 *  @field  HINSTANCE | hinstdimapdll |
 *
 *          The instance handle of the DLL that contains the mapper.
 *
 *****************************************************************************/

typedef struct CMapShep {

    /* Supported interfaces */
    IDirectInputMapShepherd dms;

	IDirectInputMapperW* pdimap;

    HINSTANCE hinstdimapdll;

} CMapShep, MS, *PMS;

typedef IDirectInputMapShepherd DMS, *PDMS;
#define ThisClass CMapShep
#define ThisInterface IDirectInputMapShepherd

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputMapShepherd | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *//**************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputMapShepherd | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInputMapShepherd | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *//**************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputMapShepherd | QIHelper |
 *
 *          We don't have any dynamic interfaces and simply forward
 *          to <f Common_QIHelper>.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *//**************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputMapShepherd | AppFinalize |
 *
 *          We don't have any weak pointers, so we can just
 *          forward to <f Common_Finalize>.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released from the application's perspective.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CMapShep)
Default_AddRef(CMapShep)
Default_Release(CMapShep)

#else

#define CMapShep_QueryInterface   Common_QueryInterface
#define CMapShep_AddRef           Common_AddRef
#define CMapShep_Release          Common_Release

#endif

#define CMapShep_QIHelper         Common_QIHelper
#define CMapShep_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CMapShep_Finalize |
 *
 *          Clean up our instance data.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CMapShep_Finalize(PV pvObj)
{
    PMS this = pvObj;

	Invoke_Release(&this->pdimap);

	if( this->hinstdimapdll)
    {
        FreeLibrary(this->hinstdimapdll);
        this->hinstdimapdll = NULL;
    }

}

/*****************************************************************************
 * ForceUnload
 *****************************************************************************/

void INTERNAL
CMapShep_ForceUnload(PV pvObj)/**why are this two functions same??????**/
{
   PMS this = pvObj;

   Invoke_Release(&this->pdimap);

	if( this->hinstdimapdll)
    {
        FreeLibrary(this->hinstdimapdll);
        this->hinstdimapdll = NULL;
    }

}


/*****************************************************************************
 * InitDll
 *****************************************************************************/

HRESULT INTERNAL
CMapShep_InitDll(PMS this,REFGUID lpDeviceGUID,LPCWSTR lpcwstrFileName)
{

	//do _CreateInstance()
    HRESULT hres = S_OK;

	if (this->hinstdimapdll == NULL)
	{
        hres = _CreateInstance(&IID_IDirectInputMapClsFact/*should be CLSID_CDIMap*/,
					TEXT("dimap.dll"), NULL, &IID_IDirectInputMapIW,
					(LPVOID*) & this->pdimap, &this->hinstdimapdll);
	    if (SUCCEEDED(hres) && this->pdimap != NULL)
		{
			hres = this->pdimap->lpVtbl->Initialize(this->pdimap,
					lpDeviceGUID, lpcwstrFileName, 0);
			if(!SUCCEEDED(hres))
				CMapShep_Finalize(this);
		}
	}
                                           
    return hres;
}


/*****************************************************************************
 * GetActionMap
 *****************************************************************************/

STDMETHODIMP
CMapShep_GetActionMapW
        (
		PDMS pdms,
        REFGUID lpDeviceGUID,
        LPCWSTR lpcwstrFileName,
        LPDIACTIONFORMATW lpDIActionFormat,
        LPCWSTR lpcwstrUserName,
		LPFILETIME lpFileTime,
        DWORD dwFlags
        )
{
	PMS this;
    HRESULT hres = S_OK;
    EnterProcI(IDirectInputMapShepherd::GetActionMapW, (_ "p", pdms));

    this = _thisPvNm(pdms, dms);

    if (!this->hinstdimapdll)
	{
		hres = CMapShep_InitDll(this, lpDeviceGUID, lpcwstrFileName);
	}

	//call the fn
	if (SUCCEEDED(hres) && this->pdimap != NULL)
    {
	    hres = this->pdimap->lpVtbl->GetActionMap(this->pdimap,
				lpDIActionFormat, lpcwstrUserName, lpFileTime, dwFlags );
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 * SaveActionMap
 *****************************************************************************/

STDMETHODIMP
CMapShep_SaveActionMapW
        (
		PDMS pdms,
        REFGUID lpDeviceGUID,
        LPCWSTR lpcwstrFileName,
        LPDIACTIONFORMATW lpDIActionFormat,
		LPCWSTR lpcwstrUserName,
		DWORD dwFlags)
{
	PMS this;
    HRESULT hres = S_OK;
    EnterProcI(IDirectInputMapShepherd::SaveActionMapW, (_ "p", pdms));

    this = _thisPvNm(pdms, dms);

    if (!this->hinstdimapdll)
	{
		hres = CMapShep_InitDll(this, lpDeviceGUID, lpcwstrFileName);
	}

	//call the fn
	if (SUCCEEDED(hres) && this->pdimap != NULL)
    {
	    hres = this->pdimap->lpVtbl->SaveActionMap(this->pdimap,
				lpDIActionFormat, lpcwstrUserName, dwFlags );
    }

//	CMapShep_Finalize(this);

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 * GetImageInfo
 *****************************************************************************/

STDMETHODIMP
CMapShep_GetImageInfoW
        (
		PDMS pdms,
        REFGUID lpDeviceGUID,
        LPCWSTR lpcwstrFileName,
        LPDIDEVICEIMAGEINFOHEADERW lpdiDevImageInfoHeader
        )
{
	PMS this;
    HRESULT hres = S_OK;
    EnterProcI(IDirectInputMapShepherd::GetImageInfoW, (_ "p", pdms));

    this = _thisPvNm(pdms, dms);

    if (!this->hinstdimapdll)
	{
		hres = CMapShep_InitDll(this, lpDeviceGUID, lpcwstrFileName);
	}

	//call the fn
	if (SUCCEEDED(hres) && this->pdimap != NULL)
    {
	    hres = this->pdimap->lpVtbl->GetImageInfo(this->pdimap,
				lpdiDevImageInfoHeader );
    }

    ExitOleProcR();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputMapShepherd | New |
 *
 *          Create a new instance of an IDirectInputMapShepherd object.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          Output pointer for new object.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CMapShep_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IDirectInputMapShepherd::<constructor>, (_ "G", riid));


    hres = Common_NewRiid(CMapShep, punkOuter, riid, ppvObj);

    if (SUCCEEDED(hres)) {
        /* Must use _thisPv in case of aggregation */
        PMS this = _thisPv(*ppvObj);
		this->hinstdimapdll = NULL;

/* In case of mapper we do this inside each method...		
		if (SUCCEEDED(hres = CMap_InitDll(this))) {
      } else {
            Invoke_Release(ppvObj);
        }*/		
    }

    ExitOleProcPpvR(ppvObj);
    return hres;
}

/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

//#define CEShep_Signature        0x50454853      /* "SHEP" */

Interface_Template_Begin(CMapShep)
    Primary_Interface_Template(CMapShep, IDirectInputMapShepherd)
Interface_Template_End(CMapShep)

Primary_Interface_Begin(CMapShep, IDirectInputMapShepherd)
    CMapShep_GetActionMapW,
    CMapShep_SaveActionMapW,
    CMapShep_GetImageInfoW,
Primary_Interface_End(CMapShep, IDirectInputMapShepherd)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dimem.c ===
/*****************************************************************************
 *
 *  DIMem.c
 *
 *  Copyright (c) 1996 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Memory management
 *
 *  Contents:
 *
 *      ReallocCbPpv
 *      AllocCbPpv
 *      FreePpv
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef NEED_REALLOC

/*****************************************************************************
 *
 *      ReallocCbPpv
 *
 *      Change the size of some zero-initialized memory.
 *
 *      This is the single place where all memory is allocated, resized,
 *      and freed.
 *
 *      If you realloc from a null pointer, memory is allocated.
 *      If you realloc to zero-size, memory is freed.
 *
 *      These semantics avoid boundary cases.  For example, it is no
 *      longer a problem trying to realloc something down to zero.
 *      You don't have to worry about special-casing an alloc of 0 bytes.
 *
 *      If an error is returned, the original pointer is UNCHANGED.
 *      This saves you from having to the double-switch around a realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
ReallocCbPpv(UINT cb, PV ppvArg)
{
    HRESULT hres;
    PPV ppv = ppvArg;
    HLOCAL hloc = *ppv;
    if (cb) {                       /* Alloc or realloc */
        if (hloc) {                 /* Realloc */
            hloc = LocalReAlloc(hloc, cb,
                                LMEM_MOVEABLE+LMEM_ZEROINIT);
        } else {                /* Alloc */
            hloc = LocalAlloc(LPTR, cb);
        }
        if (hloc) {
            *ppv = hloc;
            hres = NOERROR;
        } else {
            hres = E_OUTOFMEMORY;
        }
    } else {                    /* Freeing */
        if (hloc) {
            LocalFree(hloc);
            *ppv = 0;           /* All gone */
        } else {
                                /* Nothing to free */
        }
        hres = NOERROR;         
    }

    return hres;
}

/*****************************************************************************
 *
 *      AllocCbPpv
 *
 *      Simple wrapper that forces *ppvObj = 0 before calling Realloc.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    *ppv = 0;
    return ReallocCbPpv(cb, ppv);
}

#else

/*****************************************************************************
 *
 *      AllocCbPpv
 *
 *      Allocate memory into the ppv.
 *
 *****************************************************************************/

STDMETHODIMP EXTERNAL
AllocCbPpv(UINT cb, PPV ppv)
{
    HRESULT hres;
    *ppv = LocalAlloc(LPTR, cb);
    hres = *ppv ? NOERROR : E_OUTOFMEMORY;
    return hres;
}

/*****************************************************************************
 *
 *      FreePpv
 *
 *      Free memory from the ppv.
 *
 *****************************************************************************/

void EXTERNAL
FreePpv(PV ppv)
{
#ifdef _M_IA64
    PV pv = (PV)InterlockedExchange64(ppv, 0);
#else
    PV pv = (PV)InterlockedExchange(ppv, 0);
#endif
    if (pv) {
        FreePv(pv);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dilib5.c ===
/*****************************************************************************
 *
 *  DILib5.c
 *
 *  Copyright (c) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Objects exported statically into our library.
 *
 *  Contents:
 *
 *      c_dfDIMouse2
 *
 *****************************************************************************/

#include "dinputpr.h"


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DIOBJECTDATAFORMAT | c_rgdoiDIMouse2[] |
 *
 *          Device object data formats for mouse-style access.
 *
 *  @global DIDEVICEFORMAT | c_dfDIMouse2 |
 *
 *          Device format for mouse-style access.
 *
 *          A pointer to this structure may be passed to
 *          <mf IDirectInputDevice::SetDataFormat> to indicate that
 *          the device will be accessed in the form of a mouse.
 *
 *          When a device has been set to the mouse data format,
 *          the <mf IDirectInputDevice::GetDeviceState> function
 *          returns a <t DIMOUSESTATE2> structure, and the
 *          <mf IDirectInputDevice::GetDeviceData> function
 *          returns a <t DIDEVICEOBJECTDATA> whose <p dwOfs>
 *          field is a <c DIMOFS_*> value which describes the
 *          object whose data is being reported.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

static DIOBJECTDATAFORMAT c_rgodfDIMouse2[] = {
    { &GUID_XAxis, FIELD_OFFSET(DIMOUSESTATE2,        lX),       DIDFT_AXIS | DIDFT_ANYINSTANCE, },
    { &GUID_YAxis, FIELD_OFFSET(DIMOUSESTATE2,        lY),       DIDFT_AXIS | DIDFT_ANYINSTANCE, },
    { &GUID_ZAxis, FIELD_OFFSET(DIMOUSESTATE2,        lZ),       DIDFT_AXIS | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[0]), DIDFT_BUTTON | DIDFT_ANYINSTANCE, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[1]), DIDFT_BUTTON | DIDFT_ANYINSTANCE, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[2]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[3]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[4]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[5]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[6]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
    { 0,           FIELD_OFFSET(DIMOUSESTATE2, rgbButtons[7]), DIDFT_BUTTON | DIDFT_ANYINSTANCE | DIDFT_OPTIONAL, },
};

const DIDATAFORMAT c_dfDIMouse2 = {
    sizeof(DIDATAFORMAT),
    sizeof(DIOBJECTDATAFORMAT),
    DIDF_RELAXIS,
    sizeof(DIMOUSESTATE2),
    cA(c_rgodfDIMouse2),
    c_rgodfDIMouse2,
};

#pragma END_CONST_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dinput.c ===
/*****************************************************************************
 *
 *  DInput.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *
 *
 *  Contents:
 *
 *      DirectInput8Create()
 *      DllGetClassObject()
 *      DllCanUnloadNow()
 *      DllMain()
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDll

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @topic  The DirectInput synchronization hierarchy |
 *
 *  Extreme caution must be exercised to ensure that the synchronization
 *  hierarchy is preserved.  Failure to observe these rules will result
 *  in a deadlock.
 *
 *  @ex
 *
 *  In the following list, locks must be taken in the order specified.
 *  Furthermore, the Dll critical section and the cross-process mutexes
 *  may never be taken simultaneously.  (They should be considered
 *  to be at the bottom of the hierarchy.)
 *
 *  |
 *
 *      DirectInputEffect
 *      DirectInputDevice
 *      Dll critical section
 *      The cross-process global mutex
 *      The cross-process joystick mutex
 *
 ***************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global DWORD | g_cRef |
 *
 *          DLL reference count.
 *
 *  @global HINSTANCE | g_hinst |
 *
 *          DLL instance handle.
 *
 *  @global LONG | g_lLoadLibrary |
 *
 *          Number of times we have been artificially <f LoadLibrary>'d
 *          to prevent ourselves from being unloaded by a non-OLE
 *          application.  Actually, it's the number of times minus one,
 *          so we can use the interlocked functions to tell whether
 *          the first <f LoadLibrary> is happening or the last
 *          <f FreeLibrary> is happening.
 *
 *          We perform a physical <f LoadLibrary> or <f FreeLibrary>
 *          only on the transition, so as to avoid overflowing the
 *          counter in KERNEL32.
 *
 *  @global HANDLE | g_hVxD |
 *
 *          Handle to VxD, if available.   Win9x only!
 *
 *  @global OPENVXDHANDLE | OpenVxDHandle |
 *
 *          Address of Win9x-only KERNEL32 entry point to convert
 *          a process handle into a VxD handle.  Win9x only!
 *
 *  @global DWORD | g_dwLastBonusPoll |
 *
 *          Last time a bonus poll was made to tickle the SideWinder 
 *          drivers.                                Win9x only!
 *
 *  @global CRITICAL_SECTION | g_crstDll |
 *
 *          Per-process critical section to protect process-global
 *          variables.
 *
 *  @global DWORD | g_flEmulation |
 *
 *          Flags that describe what levels of forced emulation are
 *          active.
 *
 *  @global HHOOK | g_hhkLLHookCheck |
 *
 *          Used only temporarily to test whether low-level hooks
 *          are supported on the system.
 *
 *  @global HANDLE | g_hmtxGlobal |
 *
 *          System-global mutex that protects shared memory blocks
 *          which describe device exclusive acquisition information.
 *
 *  @global HANDLE | g_hfm |
 *
 *          Handle to the file mapping that describes the shared
 *          memory block.  NT requires us to keep the handle open
 *          so that the associated name remains in the namespace.
 *
 *  @global PSHAREDOBJECTPAGE | g_psop |
 *
 *          Pointer to the shared memory block itself.
 *
 *  @global HANDLE | g_hmtxJoy |
 *
 *          System-global mutex that protects shared memory blocks
 *          which describe joystick effects.
 *
 *  @global UINT | g_wmJoyChanged |
 *
 *          Registered window message which is broadcast when joysticks
 *          are reconfigured.
 *
 *  @global LONG | g_lWheelGranularity |
 *
 *          The wheel granularity.  One hardware "click" of the mouse
 *          wheel results in this much reported motion.
 *
 *  @global int | g_cdtoMax |
 *
 *          Total number of elements in the g_pdto array.
 *
 *  @global int | g_cdto |
 *
 *          Number of occupied elements in the g_pdto array.
 *
 *  @global PDWORD | g_rgdwCRCTable |
 *
 *          Pointer to the array of values used for CRC generation.
 *
 *  @global PDEVICETOUSER | g_pdto |
 *
 *          Pointer to the device to owner array.
 *
 *  @global BOOL | g_fCritInited |
 *
 *          True if g_crstDll has been initialized.
 *
 *  @global DIAPPHACKS | g_AppHacks | 
 *
 *          Application hacks.  Initialized to:
 *              fReacquire              FALSE
 *              fNoSubClass             FALSE
 *              nMaxDeviceNameLength    MAX_PATH
 *
 *  @global DWORD | g_dwAppDate |
 *
 *          Application link date stamp, used in generating application ID
 *
 *  @global DWORD | g_dwAppFileLen |
 *
 *          Application file length, used in generating application ID
 *
 *  @global DWORD | g_dwLastMsgSent |
 *
 *          Last message WPARAM broadcast in a g_wmDInputNotify message.
 *          This is one of the DIMSGWP_* values or zero if no message has yet 
 *          been broadcast.  This value only ever increases as applications 
 *          cannot become less identifed as they proceed.  This value is used 
 *          as a test of 
 *
 *  @global UINT | g_wmDInputNotify |
 *
 *          Registered window message which is broadcast when a change of 
 *          application status is detected.
 *
 *
 *****************************************************************************/

DWORD g_cRef;
HINSTANCE g_hinst;
HINSTANCE g_hinstDbg;
LONG g_lLoadLibrary = -1;
#ifndef WINNT
HANDLE g_hVxD = INVALID_HANDLE_VALUE;
OPENVXDHANDLE _OpenVxDHandle;
DWORD g_dwLastBonusPoll;
#endif
CRITICAL_SECTION g_crstDll;
DWORD g_flEmulation;
LPDWORD g_pdwSequence;

#ifdef USE_SLOW_LL_HOOKS
HHOOK g_hhkLLHookCheck;
#endif

HANDLE g_hmtxGlobal;
HANDLE g_hfm;
struct SHAREDOBJECTPAGE *g_psop;
HANDLE g_hmtxJoy;
UINT g_wmJoyChanged;
LONG g_lWheelGranularity;

int g_cdtoMax;
int g_cdto;
struct _DEVICETOUSER *g_pdto;

PDWORD g_rgdwCRCTable;

BOOL g_fCritInited;

#ifdef WORKER_THREAD
MSGWAITFORMULTIPLEOBJECTSEX _MsgWaitForMultipleObjectsEx =
FakeMsgWaitForMultipleObjectsEx;
#endif

CANCELIO _CancelIO = FakeCancelIO;

#ifdef XDEBUG
TRYENTERCRITICALSECTION _TryEnterCritSec = FakeTryEnterCriticalSection;
int g_cCrit = -1;
UINT g_thidCrit;
HANDLE g_thhandleCrit;
#endif

#ifdef DEBUG
TCHAR g_tszLogFile[MAX_PATH];
#endif

DIAPPHACKS g_AppHacks = {FALSE,FALSE,MAX_PATH};
DWORD g_dwAppDate;
DWORD g_dwAppFileLen;
DWORD g_dwLastMsgSent;
UINT  g_wmDInputNotify;

BOOL  g_fRawInput;

#ifdef USE_WM_INPUT
  HWND   g_hwndThread;
  HANDLE g_hEventAcquire;
  HANDLE g_hEventThread;
  HANDLE g_hEventHid;
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllEnterCrit |
 *
 *          Take the DLL critical section.
 *
 *          The DLL critical section is the lowest level critical section.
 *          You may not attempt to acquire any other critical sections or
 *          yield while the DLL critical section is held.  Failure to
 *          comply is a violation of the semaphore hierarchy and will
 *          lead to deadlocks.
 *
 *****************************************************************************/

void EXTERNAL
DllEnterCrit_(LPCTSTR lptszFile, UINT line)
{            

#ifdef XDEBUG
    if ( ! _TryEnterCritSec(&g_crstDll) )
    {
        SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec blocked @%s,%d"), lptszFile, line);    
        EnterCriticalSection(&g_crstDll);
    }

    if (++g_cCrit == 0)
    {
        g_thidCrit     = GetCurrentThreadId();
        g_thhandleCrit = GetCurrentThread();

        SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec Entered @%s,%d"), lptszFile, line);    
    }
    AssertF(g_thidCrit == GetCurrentThreadId());
#else
    EnterCriticalSection(&g_crstDll);
#endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | IsThreadActive |
 *
 *          Check if the thread is still active.
 *
 *****************************************************************************/

BOOL IsThreadActive( HANDLE hThread )
{
    DWORD dwExitCode = 0;

    return (NULL != hThread
            && GetExitCodeThread(hThread, &dwExitCode)
            && STILL_ACTIVE == dwExitCode
            );
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllLeaveCrit |
 *
 *          Leave the DLL critical section.
 *
 *****************************************************************************/

void EXTERNAL
DllLeaveCrit_(LPCTSTR lptszFile, UINT line)
{
#ifdef XDEBUG
    if( IsThreadActive(g_thhandleCrit) ) {
        AssertF(g_thidCrit == GetCurrentThreadId());
    } else {
        SquirtSqflPtszV(sqflCrit, TEXT("Current thread has died."));
    }
    
    AssertF(g_cCrit >= 0);
    if (--g_cCrit < 0)
    {
        g_thidCrit = 0;
    }
    SquirtSqflPtszV(sqflCrit, TEXT("Dll CritSec Leaving @%s,%d"), lptszFile, line);    
#endif
    LeaveCriticalSection(&g_crstDll);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllInCrit |
 *
 *          Nonzero if we are in the DLL critical section.
 *
 *****************************************************************************/

#ifdef XDEBUG

BOOL INTERNAL
DllInCrit(void)
{        
    return g_cCrit >= 0 && g_thidCrit == GetCurrentThreadId();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllAddRef |
 *
 *          Increment the reference count on the DLL.
 *
 *****************************************************************************/

void EXTERNAL
DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
    SquirtSqflPtszV(sqfl, TEXT("DllAddRef -> %d"), g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllRelease |
 *
 *          Decrement the reference count on the DLL.
 *
 *****************************************************************************/

void EXTERNAL
DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
    SquirtSqflPtszV(sqfl, TEXT("DllRelease -> %d"), g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DllLoadLibrary |
 *
 *          Increment the DLL load count.
 *
 *          This is to prevent a non-OLE application from unloading us
 *          while we still have windows subclassed.
 *
 *****************************************************************************/

BOOL EXTERNAL
DllLoadLibrary(void)
{
    BOOL fRes = TRUE;

    AssertF(InCrit());      

    if (InterlockedIncrement(&g_lLoadLibrary) == 0)
    {
        TCHAR tsz[MAX_PATH - 1];

        /*
         *  See hresValidInstanceVer_ for an explanation of why
         *  we need to pass cA() - 1 instead of cA().
         */
        if ( !GetModuleFileName(g_hinst, tsz, cA(tsz) - 1)
             || !LoadLibrary(tsz) )
        {
            /*
             *  Restore the refcount.
             *  There is no race condition here because we are always called 
             *  InCrit so the refcount after the restore can only be the same 
             *  as it was when we entered.  If this should change, we would 
             *  need to take extra precautions as two threads could try to 
             *  LoadLibrary at the same time.  As only one would do the 
             *  physical load, there is no way to let the other know if the 
             *  load failed.
             */
            InterlockedDecrement(&g_lLoadLibrary);
            fRes = FALSE;
            RPF( "LoadLibrary( self ) failed!, le = %d", GetLastError() );
        }
    }
    SquirtSqflPtszV(sqfl, TEXT("DllLoadLibrary -> %d"), g_lLoadLibrary);

    return fRes;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllFreeLibraryAndExitThread |
 *
 *          Worker thread which frees the library in a less dangerous
 *          (I'm loathe to say "safe") manner.
 *
 *          ThreadProcs are prototyped to return a void but since the return 
 *          would follow some form of ExitThread, it will never be reached so 
 *          this function is declared to return void and cast.
 *
 *  @parm   LPVOID | pvContext |
 *
 *          Unused context information.
 *
 *****************************************************************************/

void INTERNAL
DllFreeLibraryAndExitThread(LPVOID pvContext)
{
    /*
     *  Sleep for one extra second to make extra sure that the
     *  DllFreeLibrary thread is out and gone.
     */
    SleepEx(1000, FALSE);

    FreeLibraryAndExitThread(g_hinst, 0);

    /*NOTREACHED*/
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllFreeLibrary |
 *
 *          Decrement the DLL load count.
 *
 *          This undoes a previous <f DllLoadLibrary>.
 *
 *          We can't blindly do a <f FreeLibrary>, because we might
 *          be freeing our last reference, and then we will die because
 *          we won't exist when the <f FreeLibrary> returns.
 *
 *          If we are in the wacky case, then we spin a low-priority
 *          thread whose job is to free us. We create it at low priority
 *          so it will lose the race with this thread, which is busy
 *          getting out of the way.
 *
 *****************************************************************************/

void EXTERNAL
DllFreeLibrary(void)
{
    if (InterlockedDecrement(&g_lLoadLibrary) < 0)
    {
        if (g_cRef)
        {
            /*
             *  There are other references to us, so we can just
             *  go away quietly.
             */
            FreeLibrary(g_hinst);
        } else
        {
            /*
             *  This is the last reference, so we need to create a
             *  worker thread which will call <f FreeLibraryAndExitThread>.
             */
            DWORD thid;
            HANDLE hth;

            hth = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)DllFreeLibraryAndExitThread,
                               0, CREATE_SUSPENDED, &thid);
            if (hth)
            {
                SetThreadPriority(hth, THREAD_PRIORITY_IDLE);
                ResumeThread(hth);
                CloseHandle(hth);
            }
        }
    }
    SquirtSqflPtszV(sqfl, TEXT("DllFreeLibrary -> %d"), g_lLoadLibrary);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllGetClassObject |
 *
 *          Create an <i IClassFactory> instance for this DLL.
 *
 *  @parm   REFCLSID | rclsid |
 *
 *          The object being requested.
 *
 *  @parm   RIID | riid |
 *
 *          The desired interface on the object.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Output pointer.
 *
 *  @comm
 *          The artificial refcount inside <f DllClassObject> helps
 *          to avoid the race condition described in <f DllCanUnloadNow>.
 *          It's not perfect, but it makes the race window smaller.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#ifdef  DEMONSTRATION_FFDRIVER

/*
 *  Build the fake force feedback driver for internal testing.
 */

GUID CLSID_EffectDriver = {
    0x25E609E2,0xB259,0x11CF,0xBF,0xC7,0x44,0x45,0x53,0x54,0x00,0x00
};

#endif

CLSIDMAP c_rgclsidmap[cclsidmap] = {
    {   &CLSID_DirectInput8,         CDIObj_New,     IDS_DIRECTINPUT8,},
    {   &CLSID_DirectInputDevice8,   CDIDev_New,     IDS_DIRECTINPUTDEVICE8,},
#ifdef  DEMONSTRATION_FFDRIVER
    {   &CLSID_EffectDriver,        CJoyEff_New,    0,},
#endif
};

#pragma END_CONST_DATA

STDAPI
DllGetClassObject(REFCLSID rclsid, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    UINT iclsidmap;
    EnterProcR(DllGetClassObject, (_ "G", rclsid));

    if ( g_fCritInited )
    {
        DllAddRef();
        for (iclsidmap = 0; iclsidmap < cA(c_rgclsidmap); iclsidmap++)
        {
            if (IsEqualIID(rclsid, c_rgclsidmap[iclsidmap].rclsid))
            {
                hres = CDIFactory_New(c_rgclsidmap[iclsidmap].pfnCreate,
                                      riid, ppvObj);
                goto done;
            }
        }
        SquirtSqflPtszV(sqfl | sqflError, TEXT("%S: Wrong CLSID"), s_szProc);
        *ppvObj = 0;
        hres = CLASS_E_CLASSNOTAVAILABLE;

        done:;

        ExitOleProcPpv(ppvObj);
        DllRelease();
    } else
    {
        hres = E_OUTOFMEMORY;
        RPF( "Failing DllGetClassObject due to lack of DLL critical section" );
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllCanUnloadNow |
 *
 *          Determine whether the DLL has any outstanding interfaces.
 *
 *          There is an unavoidable race condition between
 *          <f DllCanUnloadNow> and the creation of a new
 *          <i IClassFactory>:  Between the time we return from
 *          <f DllCanUnloaDNow> and the caller inspects the value,
 *          another thread in the same process may decide to call
 *          <f DllGetClassObject>, thus suddenly creating an object
 *          in this DLL when there previously was none.
 *
 *          It is the caller's responsibility to prepare for this
 *          possibility; there is nothing we can do about it.
 *
 *  @returns
 *
 *          Returns <c S_OK> if the DLL can unload, <c S_FALSE> if
 *          it is not safe to unload.
 *
 *****************************************************************************/

STDMETHODIMP
DllCanUnloadNow(void)
{
    HRESULT hres;
#ifdef DEBUG
    if (IsSqflSet(sqfl))
    {
        SquirtSqflPtszV(sqfl, TEXT("DllCanUnloadNow() - g_cRef = %d"), g_cRef);
        Common_DumpObjects();
    }
#endif
    hres = g_cRef ? S_FALSE : S_OK;
    return hres;
}

#ifdef USE_SLOW_LL_HOOKS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | DllLlHookTest |
 *
 *          Tiny hook procedure used to test whether LL hooks are
 *          supported by the operating system.
 *
 *          This function is almost never called.  We install the
 *          hook and immediately remove it.  The only time it
 *          manages to get called is if the user moves the mouse
 *          or presses a key during the microsecond that we exist.
 *
 *          Wait!  In fact, this function is *never* called.  We
 *          do not process messages at any point the hook is installed,
 *          so in fact nothing happens at all.
 *
 *  @parm   int | nCode |
 *
 *          Hook code.
 *
 *  @parm   WPARAM | wp |
 *
 *          Hook-specific code.
 *
 *  @parm   LPARAM | lp |
 *
 *          Hook-specific code.
 *
 *  @returns
 *
 *          Always chains to previous hook.
 *
 *****************************************************************************/

LRESULT CALLBACK
DllLlHookTest(int nCode, WPARAM wp, LPARAM lp)
{
    /*
     *  Note that there is not actually anything wrong here,
     *  but it is a theoretically impossible condition, so I want to
     *  know when it happens.
     */
    AssertF(!TEXT("DllLlHookTest - Unexpected hook"));
    return CallNextHookEx(g_hhkLLHookCheck, nCode, wp, lp);
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllProcessAttach |
 *
 *          Called when the DLL is loaded.
 *
 *          We are not interested in thread attaches and detaches,
 *          so we disable thread notifications for performance reasons.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszKernel32[] = TEXT("KERNEL32");

#ifndef WINNT
char c_szOpenVxDHandle[] = "OpenVxDHandle";
#endif

void INTERNAL
DllProcessAttach(void)
{
    HINSTANCE hinstK32;
#ifdef DEBUG

    WriteProfileString(0, 0, 0);   /* Flush the win.ini cache */
    Sqfl_Init();
    GetProfileString(TEXT("DEBUG"), TEXT("LogFile"), TEXT(""),
                     g_tszLogFile, cA(g_tszLogFile));
    SquirtSqflPtszV(sqfl, TEXT("LoadDll - DInput"));
    SquirtSqflPtszV(sqfl, TEXT("Version %x"), DIRECTINPUT_VERSION );
    SquirtSqflPtszV(sqfl, TEXT("Built %s at %s\n"), TEXT(__DATE__), TEXT(__TIME__) );
#endif


    /*
     *  Disabling thread library calls is important so that
     *  we don't deadlock with ourselves over the critical
     *  section when we spin up the worker thread to handle
     *  low-level hooks.
     */
    DisableThreadLibraryCalls(g_hinst);

    g_fCritInited = fInitializeCriticalSection(&g_crstDll);
    if ( !g_fCritInited )
    {
        RPF( "Failed to initialize DLL critical section" );
    }

    hinstK32 = GetModuleHandle( c_tszKernel32 );


    {
        CANCELIO tmp;

        tmp = (CANCELIO)GetProcAddress(hinstK32, "CancelIo");
        if (tmp)
        {
            _CancelIO = tmp;
        } else
        {
            AssertF(_CancelIO == FakeCancelIO);
        }
    }

#ifdef WINNT
    /*
     *  For now, only look for TryEnterCriticalSection on NT as it is not 
     *  implemented on 9x but the stub is annoying on 98 with dbg kernels.
     */
    {
#ifdef XDEBUG
        TRYENTERCRITICALSECTION tmpCrt;

        tmpCrt = (TRYENTERCRITICALSECTION)GetProcAddress(hinstK32, "TryEnterCriticalSection");
        if (tmpCrt)
        {
            _TryEnterCritSec = tmpCrt;            
        } else
        {
            AssertF(_TryEnterCritSec == FakeTryEnterCriticalSection);
        }
#endif
    }

#else
    _OpenVxDHandle = (OPENVXDHANDLE)GetProcAddress(hinstK32, c_szOpenVxDHandle);
#endif

#ifdef WORKER_THREAD
    {
        MSGWAITFORMULTIPLEOBJECTSEX tmp;

        tmp = (MSGWAITFORMULTIPLEOBJECTSEX)
              GetProcAddress(GetModuleHandle(TEXT("USER32")),
                             "MsgWaitForMultipleObjectsEx");
        if (tmp)
        {
            _MsgWaitForMultipleObjectsEx = tmp;
        } else
        {
            AssertF(_MsgWaitForMultipleObjectsEx ==
                    FakeMsgWaitForMultipleObjectsEx);
        }
    }

    /*
     *  We cannot initialize g_hmtxGlobal here, because we
     *  have no way to report the error back to the caller.
     */
#endif

#ifdef USE_SLOW_LL_HOOKS

    /*
     *  Determine whether low-level input hooks are supported.
     */
    g_hhkLLHookCheck = SetWindowsHookEx(WH_MOUSE_LL, DllLlHookTest,
                                        g_hinst, 0);
    if (g_hhkLLHookCheck)
    {
        UnhookWindowsHookEx(g_hhkLLHookCheck);
    }

#endif

    /*
     *  Warning!  Do not call ExtDll_Init during PROCESS_ATTACH!
     */
    g_wmJoyChanged   = RegisterWindowMessage(MSGSTR_JOYCHANGED);
    g_wmDInputNotify = RegisterWindowMessage(DIRECTINPUT_NOTIFICATION_MSGSTRING);

  #ifdef USE_WM_INPUT
    g_fRawInput      = (DIGetOSVersion() == WINWH_OS);
    if( g_fRawInput ) {
        g_hEventAcquire  = CreateEvent(0x0, 0, 0, 0x0);
        g_hEventThread   = CreateEvent(0x0, 0, 0, 0x0);
        g_hEventHid      = CreateEvent(0x0, 0, 0, 0x0);
    }
  #endif

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllProcessDetach |
 *
 *          Called when the DLL is unloaded.
 *
 *****************************************************************************/

void INTERNAL
DllProcessDetach(void)
{
    extern PLLTHREADSTATE g_plts;

    SquirtSqflPtszV(sqfl | sqflMajor,
                    TEXT("DINPUT8: ProcessDetach. PID:%08x, TID:%08x."),
                    GetCurrentProcessId(), GetCurrentThreadId() );


  #ifdef USE_WM_INPUT
    if (g_hEventAcquire)
    {
        CloseHandle(g_hEventAcquire);
    }

    if (g_hEventThread)
    {
        CloseHandle(g_hEventThread);
    }

    if (g_hEventHid)
    {
        CloseHandle(g_hEventHid);
    }
  #endif

#ifndef WINNT
    if (g_hVxD != INVALID_HANDLE_VALUE)
    {
        CloseHandle(g_hVxD);
    }
#endif

    if (g_psop)
    {
        UnmapViewOfFile(g_psop);
    }

    if (g_hfm)
    {
        CloseHandle(g_hfm);
    }

    if (g_hmtxGlobal)
    {
        CloseHandle(g_hmtxGlobal);
    }

    if (g_hmtxJoy)
    {
        CloseHandle(g_hmtxJoy);
    }

    FreePpv( &g_pdto );
    FreePpv( &g_rgdwCRCTable );

    ExtDll_Term();

    if ( g_fCritInited )
    {
        DeleteCriticalSection(&g_crstDll);
    }

    if ( g_hinstDbg )
    {
        FreeLibrary(g_hinstDbg);
    }
    /*
     *  Output message last so that anything that follows is known to be bad.
     */
    if (g_cRef )
    {
        RPF("unloaded before all objects released. (cRef:%d)\r\n", g_cRef);
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DllMain |
 *
 *          Called to notify the DLL about various things that can happen.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          The instance handle of this DLL.
 *
 *  @parm   DWORD | dwReason |
 *
 *          Notification code.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Not used.
 *
 *  @returns
 *
 *          Returns <c TRUE> to allow the DLL to load.
 *
 *****************************************************************************/

BOOL APIENTRY
DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    
    case DLL_PROCESS_ATTACH:
        g_hinst = hinst;
        DllProcessAttach();
        SquirtSqflPtszV(sqfl | sqflMajor,
                        TEXT("DINPUT8: DLL_PROCESS_ATTACH hinst=0x%p, lpReserved=0x%p"),
                        hinst, lpReserved );
        break;

    case DLL_PROCESS_DETACH:
        DllProcessDetach();
        SquirtSqflPtszV(sqfl | sqflMajor,
                        TEXT("DINPUT8: DLL_PROCESS_DETACH hinst=0x%p, lpReserved=0x%p"),
                        hinst, lpReserved );
        break;
    }
    return 1;
}

/*****************************************************************************
 *
 *  @doc EXTERNAL
 *
 *  @topic Definitions and Ground Rules |
 *
 *  The phrase "undefined behavior" refers to behavior which is not
 *  covered by this specification due to violations of a constraint.
 *  No constraint is imposed by the specification as to the result of
 *  undefined behavior.  It may range from silently ignoring the
 *  situation to a complete system crash.
 *
 *  If this specification does not prescribe a behavior for a particular
 *  situation, the behavior is "undefined".
 *
 *  The phrase "It is an error" indicates that failure to comply
 *  is a violation of the DirectInput specification and results
 *  in "undefined behavior".
 *
 *  The word "shall" is to be interpreted as a
 *  requirement on an application; conversely, "shall not" is to be
 *  interpreted as a prohibition.  Violation of a requirement or
 *  prohibition "is an error".
 *
 *  The word "may" indicates that the indicated behavior is possible
 *  but is not required.
 *
 *  The word "should" indicates a strong suggestion.
 *  If the application violates a "should" requirement, then DirectInput
 *  "may" fail the operation.
 *
 *  Pointer parameters to functions "shall not" be NULL unless explicitly
 *  documented as OPTIONAL.  "It is an error" to pass a pointer to an object
 *  of the wrong type, to an object which is not allocated, or to an
 *  object which has been freed or <f Release>d.
 *
 *  Unless indicated otherwise,
 *  an object pointed to by a pointer parameter documented as an
 *  IN parameter "shall not" be modified by the called procedure.
 *  Conversely, a pointer parameter documented
 *  as an OUT parameter "shall" point to a modifiable object.
 *
 *  When a bitmask of flags is defined, all bits not defined by this
 *  specification are reserved.  Applications "shall not" set reserved
 *  bits and "shall" ignore reserved bits should they be received.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @topic  Initialization and Versions |
 *
 *          In several places, DirectInput requires you to pass an instance
 *          handle and a version number.
 *
 *          The instance handle must correspond to the application or
 *          DLL that is initializing the DirectInput object.
 *
 *          DirectInput uses this value to determine whether the
 *          application or DLL has been certified and to establish
 *          any special behaviors that may be necessary for
 *          backwards-compatibility.
 *
 *          It is an error for a DLL to pass the handle of the
 *          parent application.  For example, an ActiveX control
 *          embedded in a web page which uses DirectInput must
 *          pass its own instance handle and not the handle of the
 *          web browser.  This ensures that DirectInput recognizes
 *          the control and can enable any special behaviors
 *          for the control the behave properly.
 *
 *          The version number parameter specifies which version of
 *          DirectInput the DirectInput subsystem should emulate.
 *
 *          Applications designed for the latest version of DirectInput
 *          should pass the value <c DIRECTINPUT_VERSION> as defined
 *          in dinput.h.
 *
 *          Applications designed for previous versions of DirectInput
 *          should pass a value corresponding to the version of
 *          DirectInput they were designed for.  For example, an
 *          application that was designed to run on DirectInput 3.0
 *          should pass a value of 0x0300.
 *
 *          If you #define <c DIRECTINPUT_VERSION> to 0x0300 before
 *          including the dinput.h header file, then the dinput.h
 *          header file will generate DirectInput 3.0-compatible
 *          structure definitions.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DirectInputCreateHelper |
 *
 *          This function creates a new DirectInput object
 *          which supports the <i IDirectInput> COM interface.
 *
 *          On success, the function returns a pointer to the new object in
 *          *<p lplpDirectInput>.
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInput object.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *  @parm   OUT PPV | ppvObj |
 *          Points to where to return
 *          the pointer to the <i IDirectInput> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown.
 *
 *  @parm   RIID | riid |
 *
 *          The interface the application wants to create.  This will
 *          be either <i IDirectInputA> or <i IDirectInputW>.
 *          If the object is aggregated, then this parameter is ignored.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM>
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *****************************************************************************/

STDMETHODIMP
DirectInputCreateHelper(HINSTANCE hinst, DWORD dwVer,
                        PPV ppvObj, PUNK punkOuter, RIID riid)
{
    HRESULT hres;
    EnterProc(DirectInputCreateHelper,
              (_ "xxxG", hinst, dwVer, punkOuter, riid));

    if (SUCCEEDED(hres = hresFullValidPcbOut(ppvObj, cbX(*ppvObj), 3)))
    {
        if( g_fCritInited )
        {
            LPVOID pvTry = NULL;
            hres = CDIObj_New(punkOuter,
                              punkOuter ? &IID_IUnknown : riid, &pvTry);

            if( SUCCEEDED( hres ) )
            {
                AhAppRegister( dwVer, 0x0 );
            }
                
            if (SUCCEEDED(hres) && punkOuter == 0)
            {
                LPDIRECTINPUT pdi = pvTry;
                hres = pdi->lpVtbl->Initialize(pdi, hinst, dwVer);
                if (SUCCEEDED(hres))
                {
                    *ppvObj = pvTry;
                } else
                {
                    Invoke_Release(&pvTry);
                    *ppvObj = NULL;
                }
            }
        } else
        {
            RPF( "Failing DirectInputCreate due to lack of DLL critical section" );
            hres = E_OUTOFMEMORY;
        }
    }

    ExitOleProcPpv(ppvObj);
    return hres;
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | DirectInput8Create |
 *
 *          <bnew> This function creates a new DirectInput8 object
 *          which supports the <i IDirectInput8> COM interfaces. This function 
 *          allows the app to pass an IID so it does not have to do an extra
 *          QI off some initial interface in order to obtain the one it 
 *          really wanted.  
 *
 *          On success, the function returns a pointer to the new object in
 *          *<p ppvOut>.
 *          <enew>
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInput object.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   REFIID | riidtlf |
 *
 *          The desired interface interface. Currently, valid values are 
 *          IID_IDirectInput8A and IID_IDirectInput8W.
 *
 *  @parm   OUT LPVOID | *ppvOut |
 *
 *          Points to where to return
 *          the pointer to the <i IDirectInput8> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *          Note that if aggregation is requested, the object returned
 *          in *<p lplpDirectInput> will be a pointer to an
 *          <i IUnknown> rather than an <i IDirectInput8>, as required
 *          by OLE aggregation.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lplpDirectInput> parameter is not a valid pointer.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c DIERR_DIERR_OLDDIRECTINPUTVERSION>: The application
 *          requires a newer version of DirectInput.
 *
 *          <c DIERR_DIERR_BETADIRECTINPUTVERSION>: The application
 *          was written for an unsupported prerelease version
 *          of DirectInput.
 *
 *  @comm   Calling this function with <p punkOuter> = NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInput8, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, <p refiid>, <p lplpDirectInput>);
 *          then initializing it with <f Initialize>.
 *
 *          Calling this function with <p punkOuter> != NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInput8, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IUnknown, <p lplpDirectInput>).
 *          The aggregated object must be initialized manually.
 *
 *          Since the IID is passed, there is no need for separate ANSI and 
 *          UNICODE versions of this service however as with other system
 *          services which are sensitive to character set issues,
 *          macros in the header file map a generic version of the IID name 
 *          to the appropriate IID for the character set variation.
 *
 *****************************************************************************/

STDMETHODIMP
DirectInput8Create(HINSTANCE hinst, DWORD dwVer, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter)
{
    HRESULT hres = E_NOINTERFACE;

#ifndef XDEBUG
    TCHAR tszGuid[ctchNameGuid];
    TCHAR tszKey[ctchGuid + 40];    /* 40 is more than enough */
    ULONG lRc;
    HKEY hk;
#endif

    EnterProc(DirectInput8Create, (_ "xxGx", hinst, dwVer, riidltf, ppvOut, punkOuter));

    /* Need to maintain a refcount to keep the Dll Around */
    DllAddRef();

#ifndef XDEBUG
    /* 
     * To provide the Dx CPL with a mechanism to allow developers to hot swap dinput8 
     * retail and debug bits
     *  In the retail version, we will check the CLSID//"CLSID_DirectInput8"/InProcServer32
     *  If it is found that the last n characters of the Dll name matches "Dinput8D.dll" then
     *  we will LoadLibrary Dinput8.dll and call the DirectInput8Create function in dinput8d.dll
     * 
     */    
    // Convert guid to name
    NameFromGUID(tszGuid, &CLSID_DirectInput8);
    // The NameFromGUID function adds a prefix, which is easily gotten rid of
    wsprintf(tszKey, TEXT("CLSID\\%s\\InProcServer32"), tszGuid+ctchNamePrefix);
    // Open the CLSID registry key
    lRc = RegOpenKeyEx(HKEY_CLASSES_ROOT, tszKey, 0,
                       KEY_QUERY_VALUE, &hk);
    if (lRc == ERROR_SUCCESS)
    {
        TCHAR tszDll[MAX_PATH];
        int cb;
        cb = cbX(tszDll);
        lRc = RegQueryValue(hk, 0, tszDll, &cb);
        if (lRc == ERROR_SUCCESS)
        {
            // We are only interested in the last few TCHARs for our comparison
            cb =  lstrlen(tszDll ) - lstrlen(TEXT("dinput8d.dll"));
            if ( ( cb >= 0x0 ) && 
                 ( 0x0 == lstrcmpi(TEXT("dinput8d.dll"), &tszDll[cb])) )
            {
                // We should use the debug binary
                g_hinstDbg = LoadLibrary(tszDll);
                if (g_hinstDbg)
                {
                    typedef HRESULT ( WINAPI * DIRECTINPUTCREATE8) ( HINSTANCE hinst, DWORD dwVersion, REFIID riidltf, LPVOID *ppvOut, LPUNKNOWN punkOuter);
                    DIRECTINPUTCREATE8 _DirectInputCreate8;

                    AssertF(g_hinstDbg != g_hinst );
                    
                    _DirectInputCreate8 = (DIRECTINPUTCREATE8)GetProcAddress( g_hinstDbg, "DirectInput8Create");
                    if ( _DirectInputCreate8 && 
                         g_hinstDbg != g_hinst )
                    {
                        hres = _DirectInputCreate8(hinst, dwVer, riidltf, ppvOut, punkOuter);
                    }
                }
            }
        }
        RegCloseKey(hk);
    }

    if( hres == E_NOINTERFACE)
#endif /* XDEBUG */
    //Can't create an IDirectInputJoyConfig8 interface through this mechanism, only IDirectInput8 interface!
    if (!IsEqualIID(riidltf, &IID_IDirectInputJoyConfig8))
    {
        hres = DirectInputCreateHelper(hinst, dwVer, ppvOut, punkOuter,
                                       riidltf);
    }
    

    DllRelease();

    ExitOleProcPpv(ppvOut);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dinputpr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputpr.h
 *  Content:    private DirectInput include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   96.05.08   raymondc Because it's there
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifndef __DINPUTPR_INCLUDED__
    #define __DINPUTPR_INCLUDED__

    #ifndef WIN32_LEAN_AND_MEAN
        #define WIN32_LEAN_AND_MEAN
    #endif
    #define Not_VxD


/***************************************************************************
 *
 *  Make sure we know what platform we are building for.
 *
 *  INITGUID is defined by guidlib, who doesn't care what platform we
 *  are building for.  (GUIDs are platform-independent.)
 *
 ***************************************************************************/

    #ifndef INITGUID
        #if defined(WINNT) + defined(WIN95) != 1
            #error Must define exactly one of WINNT or WIN95
        #endif
    #endif

/***************************************************************************
 *
 *  Deciding whether we should use UNICODE
 *
 *  Use UNICODE on everything that isn't an X86, because NT is the only
 *  thing that runs on them.
 *
 *  If we *are* X86, then do UNICODE only if the command line says so.
 *
 ***************************************************************************/

    #ifndef _X86_
        #ifndef UNICODE
            #define UNICODE
        #endif
    #endif

    #pragma warning(disable:4115)           /* rpcndr.h: parenthesized type */
    #pragma warning(disable:4201)           /* winnt.h: nameless union */
    #pragma warning(disable:4214)           /* winnt.h: unsigned bitfields */
    #pragma warning(disable:4514)           /* winnt.h: fiber goo */
    #pragma warning(error:4101)             /* unreferenced local variable */


    #define STRICT

    #include <windows.h>
    #include <windowsx.h>
    #include <mmsystem.h>
    #include <mmreg.h>
    #include <objbase.h>
    #include <regstr.h>
    #include <math.h>


    #define DIRECTINPUT_VERSION 0x0800
    #include <dinput.h>
    #include "dinputp.h"
    
    /*
     *  Do sanity checks on header version
     */
    #ifndef DIRECTINPUT_HEADER_VERSION
        #error  DIRECTINPUT_HEADER_VERSION not defined.
    #else
        #if( DIRECTINPUT_HEADER_VERSION < 0x0800 ) 
            #if( DIRECTINPUT_HEADER_VERSION != DIRECTINPUT_VERSION )
                #error Mis-matched DInput header.
            #else
                #define DIRECTINPUT_INTERNAL_VERSION DIRECTINPUT_HEADER_VERSION 
            #endif
        #else
            #define DIRECTINPUT_INTERNAL_VERSION DIRECTINPUT_VERSION
        #endif
    #endif

    #if (_WIN32_WINNT >= 0x0501)
        #define USE_WM_INPUT 1
    #endif

    #ifndef GUIDLIB

/*
 *  Old versions of commctrl.h do not #include <prsht.h> automatically;
 *  therefore we must include it so that <setupapi.h> won't barf.
 *  Fortunately, prsht.h is idempotent, so an extra #include won't hurt.
 */
        #include <prsht.h>

        #include <setupapi.h>
        #include <hidsdi.h>
        #include <cfgmgr32.h>
        #include <winioctl.h>


#ifndef WINNT
        /*
         *  The version of basetyps.h hidclass.h includes on Win9x builds
         *  causes redefinition errors for DEFINE_GUID since we already have
         *  it from objbase.h so we have to null the include.
         */
        #define _BASETYPS_H_
#endif

        #include <hidclass.h>
        #include <stdio.h>

    #endif

    #include <dinputd.h>
    #include "dinputdp.h"
    #include "dinputv.h"
    #include "disysdef.h"
    #include "dinputi.h"
    #include "dihel.h"
    #include "debug.h"
    #include "diem.h"
    #include "..\dimap\dimap.h"
    #include "diextdll.h"
    #include "dihid.h"
    #include "dinputrc.h"

    #include "diwinnt.h"
#ifdef GUIDLIB
    #include <winioctl.h>
#endif
    #include "diport.h"
    #include "gameport.h"
    #include "winuser.h"
    #include "dbt.h"
    #include <lmcons.h>

    #ifdef WINNT
        #include "aclapi.h"
    #endif
    #include "diRiff.h"

    #include "verinfo.h"
    
    #include "ddraw.h"
    #include "d3d8.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dinputi.h ===
/***************************************************************************
 *
 *  Copyright (C) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputi.h
 *  Content:    DirectInput internal include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1996.05.07 raymondc Lost a bet
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifdef __cplusplus
extern "C" {
#endif

    /***************************************************************************
     *
     *  Debug / RDebug / Retail
     *
     *  If either DEBUG or RDEBUG, set XDEBUG.
     *
     *  Retail defines nothing.
     *
     ***************************************************************************/

#if defined(DEBUG) || defined(RDEBUG)
    #define XDEBUG
#endif

    /***************************************************************************
     *
     *                            Turning off stuff...
     *
     *  Turn off these things, because they confuse the bilingualism macros.
     *  Instead, we call then IMumbleT.
     *
     ***************************************************************************/

#undef IDirectInput
#undef IDirectInput2
#undef IDirectInput7
#undef IDirectInput8
#undef IDirectInputDevice
#undef IDirectInputDevice2
#undef IDirectInputDevice7
#undef IDirectInputDevice8

    /*
     *  And <mmsystem.h> defines JOY_POVCENTERED incorrectly...
     */
#undef  JOY_POVCENTERED
#define JOY_POVCENTERED     0xFFFFFFFF

    /*
     *  And older versions of windows.h don't have this definition.
     */
#ifndef HasOverlappedIoCompleted
    #define HasOverlappedIoCompleted(lpOverlapped) \
            ((lpOverlapped)->Internal != STATUS_PENDING)
#endif

    /***************************************************************************
     *
     *                            Abbreviations....
     *
     *  Give shorter names to things we talk about frequently.
     *
     ***************************************************************************/

    typedef LPDIRECTINPUT8  PDI , *PPDI ;
    typedef LPDIRECTINPUT8A PDIA, *PPDIA;
    typedef LPDIRECTINPUT8W PDIW, *PPDIW;

    typedef LPDIRECTINPUTDEVICE8  PDID , *PPDID ;
    typedef LPDIRECTINPUTDEVICE8A PDIDA, *PPDIDA;
    typedef LPDIRECTINPUTDEVICE8W PDIDW, *PPDIDW;

    typedef LPDIRECTINPUTEFFECT  PDIE , *PPDIE ;

    typedef DIOBJECTDATAFORMAT   ODF,   *PODF;
    typedef const ODF                   *PCODF;

    typedef LPUNKNOWN PUNK;
    typedef LPVOID PV, *PPV;
    typedef CONST VOID *PCV;
    typedef REFIID RIID;
    typedef CONST GUID *PCGUID;

    /***************************************************************************
     *
     *      GetProcAddress'd KERNEL32 and USER32 functions.
     *
     ***************************************************************************/
    typedef DWORD (WINAPI *OPENVXDHANDLE)(HANDLE);
    typedef BOOL  (WINAPI *CANCELIO)(HANDLE);
    typedef DWORD (WINAPI *MSGWAITFORMULTIPLEOBJECTSEX)
    (DWORD, LPHANDLE, DWORD, DWORD, DWORD);

    typedef BOOL (WINAPI *TRYENTERCRITICALSECTION)(LPCRITICAL_SECTION);

    extern OPENVXDHANDLE _OpenVxDHandle;
    extern CANCELIO _CancelIO;
    extern MSGWAITFORMULTIPLEOBJECTSEX _MsgWaitForMultipleObjectsEx;
#ifdef XDEBUG
    extern TRYENTERCRITICALSECTION _TryEnterCritSec;
    BOOL WINAPI FakeTryEnterCriticalSection(LPCRITICAL_SECTION lpCrit_sec);
#endif

    DWORD WINAPI
        FakeMsgWaitForMultipleObjectsEx(DWORD, LPHANDLE, DWORD, DWORD, DWORD);

    BOOL WINAPI FakeCancelIO(HANDLE h);


    /***************************************************************************
     *
     *      Our global variables - see dinput.c for documentation
     *
     ***************************************************************************/

    extern HINSTANCE g_hinst;
#ifndef WINNT
    extern HANDLE g_hVxD;
    extern HANDLE g_hVjoyd;
    extern DWORD g_dwLastBonusPoll;
#endif
    extern DWORD g_flEmulation;
    extern LPDWORD g_pdwSequence;

#ifdef USE_SLOW_LL_HOOKS
    extern HHOOK g_hhkLLHookCheck;
    #define g_fUseLLHooks   ((BOOL)(UINT_PTR)g_hhkLLHookCheck)
#endif

    extern HANDLE g_hmtxGlobal;
    extern HANDLE g_hfm;
    extern struct SHAREDOBJECTPAGE *g_psop;
    extern UINT g_wmJoyChanged;
    extern HANDLE g_hmtxJoy;
    extern HINSTANCE g_hinstSetupapi;
    extern LONG g_lWheelGranularity;

    extern int g_cdtoMax;
    extern int g_cdto;
    extern struct _DEVICETOUSER *g_pdto;

    extern BOOL g_fRawInput;
  #ifdef USE_WM_INPUT
    extern HWND g_hwndThread;
    extern HANDLE g_hEventAcquire;
    extern HANDLE g_hEventThread;
    extern HANDLE g_hEventHid;
  #endif
  
    extern PDWORD g_rgdwCRCTable;

    typedef struct _DIAPPHACKS
    {
        BOOL    fReacquire;
        BOOL    fNoSubClass;
        int     nMaxDeviceNameLength;
    } DIAPPHACKS, *LPDIAPPHACKS;

    extern DIAPPHACKS g_AppHacks;
    extern DWORD g_dwAppDate;
    extern DWORD g_dwAppFileLen;
    extern DWORD g_dwLastMsgSent;
    extern UINT g_wmDInputNotify;

    /*****************************************************************************
     *
     *                      Baggage
     *
     *      Stuff I carry everywhere.
     *
     *****************************************************************************/

#define INTERNAL NTAPI  /* Called only within a translation unit */
#define EXTERNAL NTAPI  /* Called from other translation units */
#define INLINE static __inline

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

    /*
     *  Arithmetic on pointers.
     */
#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))

    /*
     * Convert an object (X) to a count of bytes (cb).
     */
#define cbX(X) sizeof(X)

    /*
     * Convert an array name (A) to a generic count (c).
     */
#define cA(a) (cbX(a)/cbX(a[0]))

    /*
     * Convert a count of X's (cx) into a count of bytes
     * and vice versa.
     */
#define  cbCxX(cx, X) ((cx) * cbX(X))
#define  cxCbX(cb, X) ((cb) / cbX(X))

    /*
     * Convert a count of chars (cch), tchars (ctch), wchars (cwch),
     * or dwords (cdw) into a count of bytes, and vice versa.
     */
#define  cbCch(cch)  cbCxX( cch,  CHAR)
#define cbCwch(cwch) cbCxX(cwch, WCHAR)
#define cbCtch(ctch) cbCxX(ctch, TCHAR)
#define  cbCdw(cdw)  cbCxX( cdw, DWORD)

#define  cchCb(cb) cxCbX(cb,  CHAR)
#define cwchCb(cb) cxCbX(cb, WCHAR)
#define ctchCb(cb) cxCbX(cb, TCHAR)
#define  cdwCb(cb) cxCbX(cb, DWORD)

    /*
     * Zero an arbitrary buffer.  It is a common error to get the second
     * and third parameters to memset backwards.
     */
#define ZeroBuf(pv, cb) memset(pv, 0, cb)

    /*
     * Zero an arbitrary object.
     */
#define ZeroX(x) ZeroBuf(&(x), cbX(x))

    /*
     * land -- Logical and.  Evaluate the first.  If the first is zero,
     * then return zero.  Otherwise, return the second.
     */

#define fLandFF(f1, f2) ((f1) ? (f2) : 0)

    /*
     * lor -- Logical or.  Evaluate the first.  If the first is nonzero,
     * return it.  Otherwise, return the second.
     *
     * Unfortunately, due to the *nature* of the C language, this can
     * be implemented only with a GNU extension.  In the non-GNU case,
     * we return 1 if the first is nonzero.
     */

#if defined(__GNUC__)
    #define fLorFF(f1, f2) ((f1) ?: (f2))
#else
    #define fLorFF(f1, f2) ((f1) ? 1 : (f2))
#endif

    /*
     * limp - logical implication.  True unless the first is nonzero and
     * the second is zero.
     */
#define fLimpFF(f1, f2) (!(f1) || (f2))

    /*
     * leqv - logical equivalence.  True if both are zero or both are nonzero.
     */
#define fLeqvFF(f1, f2) (!(f1) == !(f2))

    /*
     *  fInOrder - checks that i1 <= i2 < i3.
     */
#define fInOrder(i1, i2, i3) ((unsigned)((i2)-(i1)) < (unsigned)((i3)-(i1)))

    /*
     *  fHasAllBitsFlFl - checks that all bits in fl2 are set in fl1.
     */
    BOOL INLINE
        fHasAllBitsFlFl(DWORD fl1, DWORD fl2)
    {
        return (fl1 & fl2) == fl2;
    }

    /*
     *  fEqualMask - checks that all masked bits are equal
     */
    BOOL INLINE
        fEqualMaskFlFl(DWORD flMask, DWORD fl1, DWORD fl2)
    {
        return ((fl1 ^ fl2) & flMask) == 0;
    }

    /*
     * Words to keep preprocessor happy.
     */
#define comma ,
#define empty

    /*
     *  Atomically exchange one value for another.
     */
#if defined(_M_IA64) || defined(_M_AMD64)
#define InterlockedExchange64 _InterlockedExchange64
#ifndef RC_INVOKED
#pragma intrinsic(_InterlockedExchange64)
#endif /*RC_INVOKED*/
#define pvExchangePpvPv(ppv, pv) \
        InterlockedExchange((ppv), (pv))
#define pvExchangePpvPv64(ppv, pv) \
        InterlockedExchange64((ppv), (pv))
#else /*_M_IA64*/
#define pvExchangePpvPv(ppv, pv) \
        (PV)InterlockedExchange((PLONG)(ppv), (LONG)(pv))
#define pvExchangePpvPv64(ppv, pv) \
        (PV)InterlockedExchange((PLONG)(ppv), (LONG)(pv))
#endif /*_M_IA64*/

    /*
     *  Creating HRESULTs from a USHORT or from a LASTERROR.
     */
#define hresUs(us) MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(us))
#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))
    /*
     *  or a registry function return code
     */
    HRESULT INLINE
        hresReg( LONG lRc )
    {
        return( (lRc) ? MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(lRc))
                      : S_OK );
    }

    /***************************************************************************
     *
     *  Debugging macros needed by inline functions
     *
     *  The build of debugging goo is in debug.h
     *
     ***************************************************************************/

    int EXTERNAL AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);

#ifdef DEBUG

    #define AssertFPtsz(c, ptsz) \
        ((c) ? 0 : AssertPtszPtszLn(ptsz, TEXT(__FILE__), __LINE__))
    #define ValidateF(c, arg) \
        ((c) ? 0 : (RPF arg, ValidationException(), 0))
    #define ConfirmF(c) \
    ((c) ? 0 : AssertPtszPtszLn(TEXT(#c), TEXT(__FILE__), __LINE__))

#else   /* !DEBUG */

    #define AssertFPtsz(c, ptsz)
    #define ValidateF(c, arg)
    #define ConfirmF(c)     (c)

#endif

    /*
     *  CAssertF - compile-time assertion.
     */
#define CAssertF(c)     switch(0) case c: case 0:

#define AssertF(c)      AssertFPtsz(c, TEXT(#c))

    /***************************************************************************
     *
     *                            Validation Code....
     *
     *  "If it crashes in retail, it must crash in debug."
     *
     *  What we don't want is an app that works fine under debug, but crashes
     *  under retail.
     *
     *  So if we find an invalid parameter in debug that would not have been
     *  detected by retail, let it pass through after a warning.  That way,
     *  the invalid parameter continues onward through the system and creates
     *  as much (or more) havoc in debug as it would under retail.
     *
     *  There used to be _fFastValidXxx functions, but the decision was made
     *  to do full validation always, except in inner-loop methods.
     *
     *  The hresFullValidXxx functions return HRESULTs instead of BOOLs.
     *
     *  Values for Xxx:
     *
     *      Hwnd      - hwnd = window handle
     *      Pdw       - pdw = pointer to a dword
     *      PdwOut    - pdw = pointer to a dword that will be set initially to 0
     *      Pfn       - pfn = function pointer
     *      riid      - riid = pointer to IID
     *      guid      - pguid = pointer to GUID
     *      Esc       - pesc = pointer to DIEFFESCAPE
     *
     *      ReadPx    - p -> structure for reading, X = structure name
     *      WritePx   - p -> structure for writing, X = structure name
     *
     *      ReadPxCb  - p -> structure for reading, X = structure name
     *                  first field of structure is dwSize which must be
     *                  equal to cbX(X).
     *
     *      WritePxCb - p -> structure for writing, X = structure name
     *                  first field of structure is dwSize which must be
     *                  equal to cbX(X).
     *
     *      WritePxCb2 - p -> structure for writing, X = structure name
     *                  first field of structure is dwSize which must be
     *                  equal to cbX(X) or cbX(X2).
     *
     *      ReadPvCb  - p -> buffer, cb = size of buffer
     *      WritePvCb - p -> buffer, cb = size of buffer
     *
     *      Pobj      - p -> internal interface
     *
     *      fl        - fl = incoming flags, flV = valid flags
     *
     ***************************************************************************/

#ifndef XDEBUG

    /*
     *  Wrappers that throw away the szProc and iarg info.
     */

    #define hresFullValidHwnd_(hwnd, z, i)                          \
       _hresFullValidHwnd_(hwnd)                                    \

    #define hresFullValidPcbOut_(pdw, cb, z, i)                         \
       _hresFullValidPcbOut_(pdw, cb)                                   \

    #define hresFullValidReadPxCb_(pv, cb, pszProc, iarg)           \
       _hresFullValidReadPxCb_(pv, cb)                              \

    #define hresFullValidReadPvCb_(pv, cb, pszProc, iarg)           \
       _hresFullValidReadPvCb_(pv, cb)                              \

    #define hresFullValidReadPxCb3_(pv, cb, cb2, cb3, pszProc, iarg)          \
       _hresFullValidReadPxCb3_(pv, cb, cb2, cb3)                   \

    #define hresFullValidWritePxCb_(pv, cb, pszProc, iarg)          \
       _hresFullValidWritePxCb_(pv, cb)                             \

    #define hresFullValidWritePxCb3_(pv, cb, cb2, cb3, pszProc, iarg)          \
       _hresFullValidWritePxCb3_(pv, cb, cb2, cb3)                  \

    #define hresFullValidWriteNoScramblePxCb_(pv, cb, pszProc, iarg)\
       _hresFullValidWriteNoScramblePxCb_(pv, cb)                   \

    #define hresFullValidWritePvCb_(pv, cb, pszProc, iarg)          \
       _hresFullValidWritePvCb_(pv, cb)                             \

    #define hresFullValidFl_(fl, flV, pszProc, iarg)                \
       _hresFullValidFl_(fl, flV)                                   \

    #define hresFullValidPfn_(pfn, pszProc, iarg)                   \
       _hresFullValidPfn_(pfn)                                      \

    #define hresFullValidPitf_(punk, pszProc, iarg)                 \
       _hresFullValidPitf_(punk)                                    \

    #define hresFullValidReadStrA_(psz, cch, pszProc, iarg)         \
       _hresFullValidReadStrA_(psz, cch)                            \

    #define hresFullValidReadStrW_(pwsz, cwch, pszProc, iarg)       \
       _hresFullValidReadStrW_(pwsz, cwch)                          \

    #define hresFullValidHwnd0_(hwnd, pszProc, iarg)                \
       _hresFullValidHwnd0_(hwnd)                                   \

    #define hresFullValidPitf0_(punk, pszProc, iarg)                \
       _hresFullValidPitf0_(punk)                                   \

    #define hresFullValidPesc_(pesc, pszProc, iarg)                 \
       _hresFullValidPesc_(pesc)                                    \

    #define hresFullValidWriteLargePvCb_(pv, cb, pszProc, iarg)     \
       _hresFullValidWriteLargePvCb_(pv, cb)                        \

#endif

    /*
     *  The actual functions.
     */

    STDMETHODIMP hresFullValidHwnd_(HWND hwnd, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidPcbOut_(PV pdw, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidReadPxCb_(PCV pv, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidReadPvCb_(PCV pv, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidReadPxCb3_(PV pv, UINT cb, UINT cb2, UINT cb3, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidWritePxCb_(PV pv, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidWritePxCb3_(PV pv, UINT cb, UINT cb2, UINT cb3, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidWritePvCb_(PV pv, UINT cb, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidFl_(DWORD fl, DWORD flV, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidPfn_(FARPROC pfn, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidPitf_(PUNK punk, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidReadStrA_(LPCSTR psz, UINT cch,
                                        LPCSTR s_szProc, int iarg);
    STDMETHODIMP hresFullValidReadStrW_(LPCWSTR pwsz, UINT cwch,
                                        LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidPesc_(LPDIEFFESCAPE pesc, LPCSTR pszProc, int iarg);
    STDMETHODIMP hresFullValidWriteLargePvCb_(PV pv, UINT cb, LPCSTR pszProc, int iarg);

#ifdef XDEBUG

    STDMETHODIMP
        hresFullValidWriteNoScramblePxCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg);

    #define hresFullValidWriteNoScramblePvCb_(pv, cb, pszProc, iarg)    \
        hresFullValidWritePvCb_(pv, cb, pszProc, MAKELONG(iarg, 1)) \

#else

    /*
     *  Retail doesn't scramble.
     */
    #define _hresFullValidWriteNoScramblePxCb_  \
        _hresFullValidWritePxCb_                \

    #define _hresFullValidWriteNoScramblePxCb3_  \
        _hresFullValidWritePxCb3_                \

    #define hresFullValidWriteNoScramblePvCb_   \
        hresFullValidWritePvCb_                 \

#endif

    HRESULT INLINE
        hresFullValidHwnd0_(HWND hwnd, LPCSTR pszProc, int iarg)
    {
        HRESULT hres;
        if(hwnd)
        {
            hres = hresFullValidHwnd_(hwnd, pszProc, iarg);
        } else
        {
            hres = S_OK;
        }
        return hres;
    }

    HRESULT INLINE
        hresFullValidPitf0_(PUNK punk, LPCSTR pszProc, int iarg)
    {
        HRESULT hres;
        if(punk)
        {
            hres = hresFullValidPitf_(punk, pszProc, iarg);
        } else
        {
            hres = S_OK;
        }
        return hres;
    }

    /*
     *  Wrappers for derived types.
     */

#define hresFullValidRiid_(riid, s_szProc, iarg)                    \
        hresFullValidReadPvCb_(riid, cbX(IID), s_szProc, iarg)      \

    /*
     *  Wrapers that add the szProc and iarg info.
     */

#define hresFullValidHwnd(hwnd, iarg)                               \
        hresFullValidHwnd_(hwnd, s_szProc, iarg)                    \

#define hresFullValidPcbOut(pdw, cb, i)                             \
        hresFullValidPcbOut_(pdw, cb, s_szProc, i)                  \

#define hresFullValidReadPdw_(pdw, z, i)                            \
        hresFullValidReadPvCb_(pdw, cbX(DWORD), z, i)               \

#define hresFullValidRiid(riid, iarg)                               \
        hresFullValidRiid_(riid, s_szProc, iarg)                    \

#define hresFullValidGuid(pguid, iarg)                              \
        hresFullValidReadPvCb_(pguid, cbX(GUID), s_szProc, iarg)    \

#define hresFullValidReadPxCb(pv, X, iarg)                          \
        hresFullValidReadPxCb_(pv, cbX(X), s_szProc, iarg)          \

#define hresFullValidReadPxCb2(pv, X, X2, iarg)                     \
        hresFullValidReadPxCb_(pv, MAKELONG(cbX(X), cbX(X2)),       \
                               s_szProc, iarg)                      \

#define hresFullValidReadPvCb(pv, cb, iarg)                         \
        hresFullValidReadPvCb_(pv, cb, s_szProc, iarg)              \

#define hresFullValidReadPx(pv, X, iarg)                            \
        hresFullValidReadPvCb_(pv, cbX(X), s_szProc, iarg)          \

#define hresFullValidReadPxCb3(pv, X, X2, X3, iarg)                 \
        hresFullValidReadPxCb3_(pv, cbX(X), cbX(X2), cbX(X3),       \
                                s_szProc, iarg)                     \

#define hresFullValidWritePxCb(pv, X, iarg)                         \
        hresFullValidWritePxCb_(pv, cbX(X), s_szProc, iarg)         \

#define hresFullValidWritePxCb2(pv, X, X2, iarg)                    \
        hresFullValidWritePxCb_(pv, MAKELONG(cbX(X), cbX(X2)),      \
                                s_szProc, iarg)                     \

#define hresFullValidWritePxCb3(pv, X, X2, X3, iarg)                \
        hresFullValidWritePxCb3_(pv, cbX(X), cbX(X2), cbX(X3),      \
                                s_szProc, iarg)                     \

#define hresFullValidWriteNoScramblePxCb(pv, X, iarg)               \
        hresFullValidWriteNoScramblePxCb_(pv, cbX(X), s_szProc, iarg)\

#define hresFullValidWriteNoScramblePxCb2(pv, X, X2, iarg)          \
        hresFullValidWriteNoScramblePxCb_(pv, MAKELONG(cbX(X), cbX(X2)),\
                                s_szProc, iarg)\

#define hresFullValidWritePvCb(pv, cb, iarg)                        \
        hresFullValidWritePvCb_(pv, cb, s_szProc, iarg)             \

#define hresFullValidWriteNoScramblePvCb(pv, cb, iarg)              \
        hresFullValidWriteNoScramblePvCb_(pv, cb, s_szProc, iarg)   \

#define hresFullValidWritePx(pv, X, iarg)                           \
        hresFullValidWritePvCb_(pv, cbX(X), s_szProc, iarg)         \

#define hresFullValidReadPdw(pdw, iarg)                             \
        hresFullValidReadPdw_(pdw, s_szProc, iarg)                  \

#define hresFullValidWritePguid(pguid, iarg)                        \
        hresFullValidWritePx(pguid, GUID, iarg)                     \

#define hresFullValidFl(fl, flV, iarg)                              \
        hresFullValidFl_(fl, flV, s_szProc, iarg)                   \

#define hresFullValidPfn(pfn, iarg)                                 \
        hresFullValidPfn_((FARPROC)(pfn), s_szProc, iarg)           \

#define hresFullValidPitf(pitf, iarg)                               \
        hresFullValidPitf_((PUNK)(pitf), s_szProc, iarg)            \

#define hresFullValidReadStrA(psz, cch, iarg)                       \
        hresFullValidReadStrA_(psz, cch, s_szProc, iarg)            \

#define hresFullValidReadStrW(pwsz, cwch, iarg)                     \
        hresFullValidReadStrW_(pwsz, cwch, s_szProc, iarg)          \

#define hresFullValidHwnd0(hwnd, iarg)                              \
        hresFullValidHwnd0_(hwnd, s_szProc, iarg)                   \

#define hresFullValidPitf0(pitf, iarg)                              \
        hresFullValidPitf0_((PUNK)(pitf), s_szProc, iarg)           \

#define hresFullValidPesc(pesc, iarg)                               \
        hresFullValidPesc_(pesc, s_szProc, iarg)                    \

#define hresFullValidWriteLargePvCb(pv, cb, iarg)                   \
        hresFullValidWriteLargePvCb_(pv, cb, s_szProc, iarg)        \

    /*****************************************************************************
     *
     *  @doc INTERNAL
     *
     *  @func   void | ValidationException |
     *
     *          Raises a parameter validation exception in XDEBUG.
     *
     *****************************************************************************/

#define ecValidation (ERROR_SEVERITY_ERROR | hresLe(ERROR_INVALID_PARAMETER))

#ifdef XDEBUG
    #define ValidationException() RaiseException(ecValidation, 0, 0, 0)
#else
    #define ValidationException()
#endif

    /*****************************************************************************
     *
     *      Bilingualism
     *
     *      Special macros that help writing ANSI and UNICODE versions of
     *      the same underlying interface.
     *
     *****************************************************************************/

    /*
     *  _THAT is something you tack onto the end of a "bilingual" interface.
     *  In debug, it expands to the magic third argument which represents
     *  the vtbl the object should have.  In retail, it expands to nothing.
     */
#ifdef XDEBUG
    #define _THAT , PV vtblExpected
    #define THAT_ , vtblExpected
#else
    #define _THAT
    #define THAT_
#endif


    /*
     *  CSET_STUBS creates stubs for ANSI and UNICODE versions of the
     *  same procedure that is not character set-sensitive.
     *
     *  mf   - method function name
     *  arg1 - argument list in prototype form
     *  arg2 - argument list for calling (with _riid appended).
     *
     *  It is assumed that the caller has already defined the symbols
     *  ThisClass and ThisInterface[AWT].
     *
     *  This macro should be used only in DEBUG.  In retail, the common
     *  procedure handles both character sets directly.
     */
#ifdef XDEBUG

    #define   CSET_STUBS(mf, arg1, arg2)                                \
          CSET_STUB(TFORM, mf, arg1, arg2)                              \
          CSET_STUB(SFORM, mf, arg1, arg2)                              \

    #define   CSET_STUB(FORM, mf, arg1, arg2)                           \
         _CSET_STUB(FORM, mf, arg1, arg2, ThisClass, ThisInterface)     \

    #define  _CSET_STUB(FORM, mf, arg1, arg2, cls, itf)                 \
        __CSET_STUB(FORM, mf, arg1, arg2, cls, itf)                     \

    #define __CSET_STUB(FORM, mf, arg1, arg2, cls, itf)                 \
STDMETHODIMP                                                            \
FORM(cls##_##mf) arg1                                                   \
{                                                                       \
    PV vtblExpected = Class_Vtbl(ThisClass, FORM(ThisInterfaceT));      \
    return cls##_##mf arg2;                                             \
}                                                                       \

#endif

    /*
     * TFORM(x) expands to x##A if ANSI or x##W if UNICODE.
     *          This T-izes a symbol, in the sense of TCHAR or PTSTR.
     *
     * SFORM(x) expands to x##W if ANSI or x##A if UNICODE.
     *          This anti-T-izes a symbol.
     */

#ifdef UNICODE
    #define _TFORM(x) x##W
    #define _SFORM(x) x##A
#else
    #define _TFORM(x) x##A
    #define _SFORM(x) x##W
#endif

#define TFORM(x)    _TFORM(x)
#define SFORM(x)    _SFORM(x)

#ifdef UNICODE
    typedef  CHAR     SCHAR;
#else
    typedef WCHAR     SCHAR;
#endif

    typedef       SCHAR * LPSSTR;
    typedef const SCHAR * LPCSSTR;

    /*
     *  SToT(dst, cchDst, src) - convert S to T
     *  TToS(dst, cchDst, src) - convert T to S
     *
     *  Remember, "T" means "ANSI if ANSI, or UNICODE if UNICODE",
     *  and "S" is the anti-T.
     *
     *  So SToT converts to the preferred character set, and TToS converts
     *  to the alternate character set.
     *
     */

#define AToU(dst, cchDst, src) \
    MultiByteToWideChar(CP_ACP, 0, src, -1, dst, cchDst)
#define UToA(dst, cchDst, src) \
    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)

#ifdef UNICODE
    #define SToT AToU
    #define TToS UToA
    #define AToT AToU
    #define TToU(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
    #define UToT(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#else
    #define SToT UToA
    #define TToS AToU
    #define AToT(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
    #define TToU AToU
    #define UToT UToA
#endif

    /*****************************************************************************
     *
     *      Unicode wrappers for Win95
     *
     *****************************************************************************/


#ifndef UNICODE

    #define LoadStringW     _LoadStringW
    int EXTERNAL LoadStringW(HINSTANCE hinst, UINT ids, LPWSTR pwsz, int cwch);

    #define RegDeleteKeyW   _RegDeleteKeyW
    LONG EXTERNAL RegDeleteKeyW(HKEY hk, LPCWSTR pwsz);

#endif

    /*****************************************************************************
     *
     *      Registry access functions
     *
     *****************************************************************************/

//our own version of KEY_ALL_ACCESS, that does not use WRITE_DAC and WRITE_OWNER (see Whistler bug 318865)
#define DI_DAC_OWNER (WRITE_DAC | WRITE_OWNER)
#define DI_KEY_ALL_ACCESS (KEY_ALL_ACCESS & ~DI_DAC_OWNER)

    LONG EXTERNAL
        RegQueryString(HKEY hk, LPCTSTR ptszValue, LPTSTR ptszBuf, DWORD ctchBuf);

    LONG EXTERNAL RegQueryStringValueW(HKEY hk, LPCTSTR ptszValue,
                                       LPWSTR pwszBuf, LPDWORD pcbBuf);

    LONG EXTERNAL RegSetStringValueW(HKEY hk, LPCTSTR ptszValue, LPCWSTR pwszBuf);

    DWORD EXTERNAL RegQueryDIDword(LPCTSTR ptszPath, LPCTSTR ptszValue, DWORD dwDefault);

    STDMETHODIMP
        hresMumbleKeyEx(HKEY hk, LPCTSTR ptszKey, REGSAM sam, DWORD dwOptions, PHKEY phk);

    STDMETHODIMP
        hresRegCopyValues( HKEY hkSrc, HKEY hkDest );

    STDMETHODIMP
        hresRegCopyKey( HKEY hkSrcRoot, PTCHAR szSrcName, PTCHAR szClass, HKEY hkDestRoot, PTCHAR szDestName, HKEY *phkSub );

    STDMETHODIMP
        hresRegCopyKeys( HKEY hkSrc, HKEY hkRoot, PDWORD OPTIONAL pMaxNameLen );

    STDMETHODIMP
        hresRegCopyBranch( HKEY hkSrc, HKEY hkDest );

    /*****************************************************************************
     *
     *      Common Object Managers for the Component Object Model
     *
     *      OLE wrapper macros and structures.  For more information, see
     *      the beginning of common.c
     *
     *****************************************************************************/

    /*****************************************************************************
     *
     *      Pre-vtbl structures
     *
     *      Careful!  If you change these structures, you must also adjust
     *      common.c accordingly.
     *
     *****************************************************************************/

    typedef struct PREVTBL
    {                /* Shared vtbl prefix */
        RIID riid;                          /* Type of this object */
        LONG lib;                          /* offset from start of object */
    } PREVTBL, *PPREVTBL;

    typedef struct PREVTBLP
    {               /* Prefix for primary vtbl */
#ifdef DEBUG
        LPCTSTR tszClass;                   /* Class name (for squirties) */
#endif
        PPV rgvtbl;                         /* Array of standard vtbls */
        UINT cbvtbl;                        /* Size of vtbl array in bytes */
        STDMETHOD(QIHelper)(PV pv, RIID riid, PPV ppvOut); /* QI helper */
        STDMETHOD_(void,AppFinalizeProc)(PV pv);/* App finalization procedure */
        STDMETHOD_(void,FinalizeProc)(PV pv);/* Finalization procedure */
        PREVTBL prevtbl;                    /* lib must be zero */
    } PREVTBLP, *PPREVTBLP;

    /*
     *      A fuller implementation is in common.c.  Out here, we need only
     *      concern ourselves with getting to the primary interface.
     */

#define _thisPv(pitf)                                                   \
        pvSubPvCb(pitf, (*(PPREVTBL*)(pitf))[-1].lib)

#define _thisPvNm(pitf, nm)                                             \
        pvSubPvCb(pitf, FIELD_OFFSET(ThisClass, nm))                    \

#ifndef XDEBUG

    #define hresPvVtbl_(pv, vtbl, pszProc)                              \
       _hresPvVtbl_(pv, vtbl)                                           \

#endif

    HRESULT EXTERNAL
        hresPvVtbl_(PV pv, PV vtbl, LPCSTR pszProc);

#define hresPvVtbl(pv, vtbl)                                            \
        hresPvVtbl_(pv, vtbl, s_szProc)                                 \

#define hresPvI(pv, I)                                                  \
        hresPvVtbl(pv, Class_Vtbl(ThisClass, I))                        \

#define hresPv(pv)                                                      \
        hresPvI(pv, ThisInterface)                                      \

#define hresPvA(pv)                                                     \
        hresPvI(pv, ThisInterfaceA)                                     \

#define hresPvW(pv)                                                     \
        hresPvI(pv, ThisInterfaceW)                                     \

#ifdef XDEBUG

    #define hresPvT(pv)                                                 \
        hresPvVtbl(pv, vtblExpected)                                    \

#else

    #define hresPvT(pv)                                                 \
        hresPv(pv)                                                      \

#endif

    /*****************************************************************************
     *
     *      Declaring interfaces
     *
     *      The extra level of indirection on _Primary_Interface et al
     *      allow the interface name to be a macro which expands to the
     *      *real* name of the interface.
     *
     *****************************************************************************/

#define __Class_Vtbl(C, I)              &c_##I##_##C##VI.vtbl
#define  _Class_Vtbl(C, I)            __Class_Vtbl(C, I)
#define   Class_Vtbl(C, I)             _Class_Vtbl(C, I)

#define Num_Interfaces(C)               cA(c_rgpv##C##Vtbl)

#ifdef  DEBUG

    #define Simple_Interface(C)             Primary_Interface(C, IUnknown); \
                                        Default_QueryInterface(C)       \
                                        Default_AddRef(C)               \
                                        Default_Release(C)
    #define Simple_Vtbl(C)                  Class_Vtbl(C)
    #define Simple_Interface_Begin(C)       Primary_Interface_Begin(C, IUnknown)
    #define Simple_Interface_End(C)         Primary_Interface_End(C, IUnknown)

#else

    #define Simple_Interface(C)             Primary_Interface(C, IUnknown)
    #define Simple_Vtbl(C)                  Class_Vtbl(C)
    #define Simple_Interface_Begin(C)                                   \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_AppFinalize,                                            \
            C##_Finalize,                                               \
            { &IID_##IUnknown, 0 },                                     \
        }, {                                                            \
            Common##_QueryInterface,                                    \
            Common##_AddRef,                                            \
            Common##_Release,                                           \

    #define Simple_Interface_End(C)                                     \
        } };                                                            \

#endif

#define _Primary_Interface(C, I)                                        \
        extern struct S_##C##Vtbl {                                     \
            PREVTBLP prevtbl;                                           \
            I##Vtbl vtbl;                                               \
        } c_##I##_##C##VI                                               \

#define Primary_Interface(C, I)                                         \
       _Primary_Interface(C, I)                                         \

#ifdef DEBUG
    #define _Primary_Interface_Begin(C, I)                              \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            TEXT(#C),                                                   \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_AppFinalize,                                            \
            C##_Finalize,                                               \
            { &IID_##I, 0, },                                           \
        }, {                                                            \
            C##_QueryInterface,                                         \
            C##_AddRef,                                                 \
            C##_Release,                                                \

#else
    #define _Primary_Interface_Begin(C, I)                              \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_AppFinalize,                                            \
            C##_Finalize,                                               \
            { &IID_##I, 0, },                                           \
        }, {                                                            \
            C##_QueryInterface,                                         \
            C##_AddRef,                                                 \
            C##_Release,                                                \

#endif

#define Primary_Interface_Begin(C, I)                                   \
       _Primary_Interface_Begin(C, I)                                   \

#define Primary_Interface_End(C, I)                                     \
        } };                                                            \

#define _Secondary_Interface(C, I)                                      \
        extern struct S_##I##_##C##Vtbl {                               \
            PREVTBL prevtbl;                                            \
            I##Vtbl vtbl;                                               \
        } c_##I##_##C##VI                                               \

#define Secondary_Interface(C, I)                                       \
       _Secondary_Interface(C, I)                                       \

    /*
     *  Secret backdoor for the "private" IUnknown in common.c
     */
#define _Secondary_Interface_Begin(C, I, ofs, Pfx)                      \
        struct S_##I##_##C##Vtbl c_##I##_##C##VI = { {                  \
            &IID_##I,                                                   \
            ofs,                                                        \
        }, {                                                            \
            Pfx##QueryInterface,                                        \
            Pfx##AddRef,                                                \
            Pfx##Release,                                               \

#define Secondary_Interface_Begin(C, I, nm)                             \
       _Secondary_Interface_Begin(C, I, FIELD_OFFSET(C, nm), Common_)   \

#define _Secondary_Interface_End(C, I)                                  \
        } };                                                            \

#define Secondary_Interface_End(C, I, nm)                               \
       _Secondary_Interface_End(C, I)                                   \

#define Interface_Template_Begin(C)                                     \
        PV c_rgpv##C##Vtbl[] = {                                        \

#define Primary_Interface_Template(C, I)                                \
        Class_Vtbl(C, I),                                               \

#define Secondary_Interface_Template(C, I)                              \
        Class_Vtbl(C, I),                                               \

#define Interface_Template_End(C)                                       \
        };                                                              \


    STDMETHODIMP Common_QueryInterface(PV, RIID, PPV);
    STDMETHODIMP_(ULONG) Common_AddRef(PV pv);
    STDMETHODIMP_(ULONG) Common_Release(PV pv);

    STDMETHODIMP_(void) Common_Hold(PV pv);
    STDMETHODIMP_(void) Common_Unhold(PV pv);

    STDMETHODIMP Common_QIHelper(PV, RIID, PPV);
    void EXTERNAL Common_Finalize(PV);

#define Common_AppFinalize      Common_Finalize

#ifndef XDEBUG

    #define _Common_New_(cb, punkOuter, vtbl, pvpObj, z)            \
       __Common_New_(cb, punkOuter, vtbl, pvpObj)                   \

    #define _Common_NewRiid_(cb, vtbl, punkOuter, riid, pvpObj, z)  \
       __Common_NewRiid_(cb, vtbl, punkOuter, riid, pvpObj)         \

#endif

    STDMETHODIMP
        _Common_New_(ULONG cb, PUNK punkOuter, PV vtbl, PPV ppvObj, LPCSTR s_szProc);

    STDMETHODIMP
        _Common_NewRiid_(ULONG cb, PV vtbl, PUNK punkOuter, RIID riid, PPV pvpObj,
                         LPCSTR s_szProc);

#define Common_NewCb(cb, C, punkOuter, ppvObj)                          \
       _Common_New_(cb, punkOuter, Class_Vtbl(C, ThisInterface), ppvObj, s_szProc)

#define Common_New(C, punkOuter, ppvObj)                                \
        Common_NewCb(cbX(C), C, punkOuter, ppvObj)                      \

#define Common_NewCbRiid(cb, C, punkOuter, riid, ppvObj) \
       _Common_NewRiid_(cb, Class_Vtbl(C, ThisInterface), punkOuter, riid, ppvObj, s_szProc)

#define Common_NewRiid(C, punkOuter, riid, ppvObj) \
   _Common_NewRiid_(cbX(C), Class_Vtbl(C, ThisInterface), punkOuter, riid, ppvObj, s_szProc)

#ifdef DEBUG
    PV EXTERNAL Common_IsType(PV pv);
#else
    #define Common_IsType
#endif
#define Assert_CommonType Common_IsType

    STDMETHODIMP Forward_QueryInterface(PV pv, RIID riid, PPV ppvObj);
    STDMETHODIMP_(ULONG) Forward_AddRef(PV pv);
    STDMETHODIMP_(ULONG) Forward_Release(PV pv);

    void EXTERNAL Invoke_Release(PV pv);

#define Common_DumpObjects()

    /*****************************************************************************
     *
     *      OLE wrappers
     *
     *      These basically do the same as IUnknown_Mumble, except that they
     *      avoid side-effects in evaluation by being inline functions.
     *
     *****************************************************************************/

    HRESULT INLINE
        OLE_QueryInterface(PV pv, RIID riid, PPV ppvObj)
    {
        PUNK punk = pv;
        return punk->lpVtbl->QueryInterface(punk, riid, ppvObj);
    }

    ULONG INLINE
        OLE_AddRef(PV pv)
    {
        PUNK punk = pv;
        return punk->lpVtbl->AddRef(punk);
    }

    ULONG INLINE
        OLE_Release(PV pv)
    {
        PUNK punk = pv;
        return punk->lpVtbl->Release(punk);
    }

    /*****************************************************************************
     *
     *      Macros that forward to the common handlers after squirting.
     *      Use these only in DEBUG.
     *
     *      It is assumed that sqfl has been #define'd to the appropriate sqfl.
     *
     *****************************************************************************/

#ifdef  DEBUG

    #define Default_QueryInterface(Class)                       \
STDMETHODIMP                                                    \
Class##_QueryInterface(PV pv, RIID riid, PPV ppvObj)            \
{                                                               \
    SquirtSqflPtszV(sqfl, TEXT(#Class) TEXT("_QueryInterface()")); \
    return Common_QueryInterface(pv, riid, ppvObj);             \
}                                                               \

// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
    #define Default_AddRef(Class)                               \
STDMETHODIMP_(ULONG)                                            \
Class##_AddRef(PV pv)                                           \
{                                                               \
    ULONG ulRc = Common_AddRef(pv);                             \
    SquirtSqflPtszV(sqfl, TEXT(#Class) TEXT("_AddRef(%p) -> %d"), pv, ulRc); \
    return ulRc;                                                \
}                                                               \

// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.    
    #define Default_Release(Class)                              \
STDMETHODIMP_(ULONG)                                            \
Class##_Release(PV pv)                                          \
{                                                               \
    ULONG ulRc = Common_Release(pv);                            \
    SquirtSqflPtszV(sqfl, TEXT(#Class) TEXT("_Release(%p) -> %d"), pv, ulRc); \
    return ulRc;                                                \
}                                                               \

#endif

    /*****************************************************************************
     *
     *      Paranoid callbacks
     *
     *      Callback() performs a callback.  The callback must accept exactly
     *      two parameters, both pointers.  (All our callbacks are like this.)
     *      And it must return a BOOL.
     *
     *****************************************************************************/

    typedef BOOL (FAR PASCAL * DICALLBACKPROC)(LPVOID, LPVOID);

#ifdef XDEBUG
    BOOL EXTERNAL Callback(DICALLBACKPROC, PVOID, PVOID);
#else
    #define Callback(pec, pv1, pv2) pec(pv1, pv2)
#endif

#if 0
    /*****************************************************************************
     *
     *      Groveling into a CONTEXT structure.
     *
     *      This is used to check that a callback procedure is properly
     *      prototyped.  We save the stack register before calling the
     *      procedure and compare it with the stack register on the way back.
     *      If they are different, explode!
     *
     *      ctxEsp is the name of the stack pointer register.
     *
     *****************************************************************************/

    typedef struct STACKINFO
    {
        CONTEXT ctxPre;             /* Thread context before call */
        CONTEXT ctxPost;            /* Thread context after call */
    } STACKINFO, *PSTACKINFO;

    #ifdef XDEBUG

        #if defined(_X86_)
            #define ctxEsp  Esp

        #elif defined(_ALPHA_)
            #define ctxEsp  IntSp

        #elif defined(_MIPS_)
            #define ctxEsp  IntSp

        #elif defined(_PPC_)
            #define ctxEsp  Gpr1

        #else
            #pragma message("I don't know what the stack register is called on this platform")
        #endif

    #endif

    #ifdef ctxEsp

        #define DECLARE_STACKINFO()                                         \
    STACKINFO si                                                            \

        #define PRE_CALLBACK()                                              \
    si.ctxPre.ContextFlags = CONTEXT_CONTROL;                               \
    GetThreadContext(GetCurrentThread(), &si.ctxPre)                        \

        #define POST_CALLBACK()                                             \
    si.ctxPost.ContextFlags = CONTEXT_CONTROL;                              \
    if (GetThreadContext(GetCurrentThread(), &si.ctxPost) &&                \
        si.ctxPre.ctxEsp != si.ctxPost.ctxEsp) {                            \
        RPF("DINPUT: Incorrectly prototyped callback! Crash soon!");        \
        ValidationException();                                              \
    }                                                                       \

    #else

        #define DECLARE_STACKINFO()
        #define PRE_CALLBACK()
        #define POST_CALLBACK()

    #endif

#endif

    /*****************************************************************************
     *
     *      Alternative message cracker macros
     *
     *      Basically the same as HANDLE_MSG, except that it stashes the
     *      answer into hres.
     *
     *****************************************************************************/

#define HRES_MSG(this, msg, fn) \
    case msg: hres = HANDLE_##msg(this, wParam, lParam, fn); break

    /*****************************************************************************
     *
     *      Registry keys and value names
     *
     *****************************************************************************/

#define REGSTR_PATH_DINPUT      TEXT("Software\\Microsoft\\DirectInput")
#define REGSTR_KEY_APPHACK      TEXT("Compatibility")
#define REGSTR_KEY_TEST         TEXT("Test")
#define REGSTR_KEY_KEYBTYPE     REGSTR_KEY_TEST TEXT("\\KeyboardType")
#define REGSTR_VAL_EMULATION    TEXT("Emulation")
#define REGSTR_VAL_GAMEPADDELAY TEXT("GamepadDelay")
#define REGSTR_VAL_JOYNFFCONFIG TEXT("Joystick%dFFConfiguration")
#define REGSTR_VAL_JOYGAMEPORTEMULATOR TEXT("OEMEmulator")
#define REGSTR_VAL_CPLCLSID     TEXT("ConfigCLSID")
#define REGSTR_KEY_JOYPREDEFN   TEXT("predef%d")
#define REGSTR_VAL_JOYOEMCALLOUT TEXT("OEMCallout")
#define REGSTR_VAL_JOYOEMHARDWAREID TEXT("OEMHardwareID")
#define REGSTR_VAL_FLAGS1       TEXT("Flags1")
#define REGSTR_VAL_FLAGS2       TEXT("Flags2")

#define REGSTR_PATH_DITYPEPROP  REGSTR_PATH_PRIVATEPROPERTIES TEXT("\\DirectInput")
#define REGSTR_VAL_JOYOEMMAPFILE TEXT("OEMMapFile")

    /*****************************************************************************
     *
     *      Registered window messages
     *
     *****************************************************************************/

#define MSGSTR_JOYCHANGED       TEXT("MSJSTICK_VJOYD_MSGSTR")

    /*****************************************************************************
     *
     *      mem.c - Memory management
     *
     *      Be extremely careful with FreePv, because it doesn't work if
     *      the pointer is null.
     *
     *****************************************************************************/

#define NEED_REALLOC

    STDMETHODIMP EXTERNAL ReallocCbPpv(UINT cb, PV ppvObj);
    STDMETHODIMP EXTERNAL AllocCbPpv(UINT cb, PV ppvObj);

#ifdef NEED_REALLOC
    #define FreePpv(ppv) (void)ReallocCbPpv(0, ppv)
#else
    void EXTERNAL FreePpv(PV ppv);
    #define FreePpv(ppv) FreePpv(ppv)
#endif
#define FreePv(pv) LocalFree((HLOCAL)(pv))

    /*****************************************************************************
     *
     *      diutil.c - Misc utilities
     *
     *****************************************************************************/

    extern GUID GUID_Null;

#define ctchGuid    (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

    BOOL EXTERNAL ParseGUID(LPGUID pGUID, LPCTSTR ptsz);
    BOOL EXTERNAL ParseVIDPID(PUSHORT puVID, PUSHORT puPID , LPCWSTR ptsz);

#define ctchNamePrefix  12              /* 12 = strlen("DirectInput.") */
#define ctchNameGuid    (ctchNamePrefix + ctchGuid)
    void EXTERNAL NameFromGUID(LPTSTR ptszBuf, PCGUID pGUID);

    typedef STDMETHOD(CREATEDCB)(PUNK, REFGUID, RIID, PPV);

    typedef struct DIOBJECTSTATICDATA
    {
        union
        {
            PCGUID rguidInstance;       /* If a static device */
            UINT   uiButtons;           /* If a HID mouse */
        };
        DWORD   dwDevType;
        union
        {
            CREATEDCB CreateDcb;        /* If a static device */
            UINT      uiAxes;           /* If a HID mouse */
        };
    } DIOBJECTSTATICDATA, *PDIOBJECTSTATICDATA, **PPDIOBJECTSTATICDATA;

    HRESULT EXTERNAL hresRunControlPanel(LPCTSTR ptszCpl);

    HRESULT EXTERNAL DiActionFormatAtoW(const LPDIACTIONFORMATA lpDiAfA,
                                        LPDIACTIONFORMATW* lplpDiAfW);
    
    HRESULT EXTERNAL DiActionFormatWtoW(const LPDIACTIONFORMATW lpDiAfW0,
                                        LPDIACTIONFORMATW* lplpDiAfW);

    void FreeDiActionFormatW(LPDIACTIONFORMATW* lplpDiAfW );


    void EXTERNAL ObjectInfoWToA(LPDIDEVICEOBJECTINSTANCEA pdoiA,
                                 LPCDIDEVICEOBJECTINSTANCEW pdoiW);

    void EXTERNAL EffectInfoWToA(LPDIEFFECTINFOA pdeiA,
                                 LPCDIEFFECTINFOW pdeiW);


#ifndef XDEBUG

    #define hresFindInstanceGUID_(pGUID, pcdcb, z, i)               \
       _hresFindInstanceGUID_(pGUID, pcdcb)                         \

    #define hresValidInstanceVer_(hinst, dwVer, z)                  \
       _hresValidInstanceVer_(hinst, dwVer)                         \

#endif

    HRESULT EXTERNAL hresFindInstanceGUID_(PCGUID pGUID, CREATEDCB *pcdcb,
                                           LPCSTR s_szProc, int iarg);

    HRESULT EXTERNAL
        hresValidInstanceVer_(HINSTANCE hinst, DWORD dwVersion, LPCSTR s_szProc);

#define hresFindInstanceGUID(pGuid, pcdcb, iarg)                    \
        hresFindInstanceGUID_(pGuid, pcdcb, s_szProc, iarg)         \

#define hresValidInstanceVer(hinst, dwVer)                          \
        hresValidInstanceVer_(hinst, dwVer, s_szProc)               \

    HRESULT EXTERNAL DupEventHandle(HANDLE h, LPHANDLE phOut);
    DWORD EXTERNAL GetWindowPid(HWND hwnd);

    PV EXTERNAL pvFindResource(HINSTANCE hinst, DWORD id, LPCTSTR rt);

    void EXTERNAL GetNthString(LPWSTR pwsz, UINT ids, UINT ui);

#define GetNthButtonString(pwsz, ui)    \
        GetNthString(pwsz, IDS_BUTTONTEMPLATE, ui)

#define GetNthAxisString(pwsz, ui)      \
        GetNthString(pwsz, IDS_AXISTEMPLATE, ui)

#define GetNthPOVString(pwsz, ui)       \
        GetNthString(pwsz, IDS_POVTEMPLATE, ui)

    HRESULT EXTERNAL hresDupPtszPptsz(LPCTSTR ptszSrc, LPTSTR *pptszDst);

    BOOL EXTERNAL fInitializeCriticalSection(LPCRITICAL_SECTION pCritSec);

    void EXTERNAL DiCharUpperW(LPWSTR pwsz);

    typedef int ( __stdcall * COMP_FUNC )( PV, PV );

    void ptrPartialQSort( PPV ppL, PPV ppR, COMP_FUNC fpCompare );

    void ptrInsertSort( PPV ppBase, PPV ppLast, COMP_FUNC fpCompare );

    void __cdecl shortsort (char *lo,char *hi,unsigned width,int (__cdecl *comp)(const void *, const void *));

    STDMETHODIMP GetWideUserName
    (
    LPCSTR lpszUserName,
    LPCWSTR lpwszUserName,
    LPWSTR  *ppwszGoodUserName
    );

    DWORD EXTERNAL GetValidDI8DevType
    (   
    DWORD dwDevType,
    DWORD dwNumButtons,
    DWORD dwFlags
    );

    HRESULT DIGetKeyNameText( UINT index, DWORD dwDevType, LPWSTR lpwszName, int nSize );

#define WIN_UNKNOWN_OS 0
#define WIN95_OS       1
#define WIN98_OS       2
#define WINME_OS       3
#define WINNT_OS       4
#define WINWH_OS       5

    DWORD INTERNAL DIGetOSVersion();

    /*****************************************************************************
     *
     *      dilist.c
     *
     *****************************************************************************/

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct GPA |
     *
     *          Growable pointer array.
     *
     *  @field  PPV | rgpv |
     *
     *          The base of the array of pointers.
     *
     *  @field  int | cpv |
     *
     *          The number of pointers in use in the array.
     *
     *  @field  int | cpvAlloc |
     *
     *          The number of pointers allocated in the array.
     *
     *****************************************************************************/

    typedef struct GPA
    {

        PPV rgpv;
        int cpv;
        int cpvAlloc;

    } GPA, *HGPA;

    void EXTERNAL GPA_Init(HGPA hgpa);
    void EXTERNAL GPA_Term(HGPA hgpa);

    STDMETHODIMP GPA_Append(HGPA hgpa, PV pv);
    BOOL EXTERNAL GPA_FindPtr(HGPA hgpa, PV pv);
    STDMETHODIMP GPA_DeletePtr(HGPA hgpa, PV pv);
    STDMETHODIMP GPA_Clone(HGPA hgpaDst, HGPA hgpaSrc);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @func   void | GPA_InitFromZero |
     *
     *          Initialize a GPA structure that is already zero-initialized.
     *
     *  @parm   HGPA | hgpa |
     *
     *          Handle to pointer array.
     *
     *****************************************************************************/

    /*
     *  Nothing needs to be done; zero-init is just fine.
     *
     *  Note: didev.c also has a global GPA, and it assumes that zero-init
     *  is just fine.
     */
#define GPA_InitFromZero(hgpa)

    /*****************************************************************************
     *
     *      dioledup.c
     *
     *****************************************************************************/

    STDMETHODIMP
        DICoCreateInstance(LPTSTR ptszClsid, LPUNKNOWN punkOuter,
                           RIID riid, PPV ppvOut, HINSTANCE *phinst);

    /*****************************************************************************
     *
     *      diexcl.c - Exclusive access management
     *
     *      We also keep GUID uniqueness goo up here, because it is
     *      diexcl.c that manages shared memory.
     *
     *****************************************************************************/

    STDMETHODIMP Excl_Acquire(PCGUID pguid, HWND hwnd, DWORD discl);
    void EXTERNAL Excl_Unacquire(PCGUID pguid, HWND hwnd, DWORD discl);
    STDMETHODIMP Excl_Init(void);

    LONG  EXTERNAL Excl_UniqueGuidInteger(void);
    DWORD EXTERNAL Excl_GetConfigChangedTime();
    void  EXTERNAL Excl_SetConfigChangedTime(DWORD tm);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct GLOBALJOYSTATE |
     *
     *          Structure that records global joystick state information.
     *
     *  @field  DWORD | dwTag |
     *
     *          Counter used to keep track of how many times each joystick's
     *          force feedback driver has been reset.  This is used to make
     *          sure that nobody messes with a joystick that he doesn't own.
     *
     *          Each time the joystick is reset, the corresponding counter
     *          is incremented.  Before we do anything to a device, we check
     *          if the reset counter matches the value stored in the
     *          object.  If not, then it means that the device has been
     *          reset in the meantime and no longer belongs to the caller.
     *
     *  @field  DWORD | dwCplGain |
     *
     *          Control panel (global) gain setting for the joystick.
     *
     *  @field  DWORD | dwDevGain |
     *
     *          Most recent device (local) gain applied to the joystick.
     *
     *          This is cached so that when the global gain changes,
     *          we know what physical gain to apply as a result.
     *
     *****************************************************************************/

    typedef struct GLOBALJOYSTATE
    {
        DWORD   dwTag;
        DWORD   dwCplGain;
        DWORD   dwDevGain;
    } GLOBALJOYSTATE, *PGLOBALJOYSTATE;

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct SHAREDOBJECTHEADER |
     *
     *          A simple header comes in front of the array of objects.
     *
     *          WARNING!  This structure may not change between DEBUG and
     *          RETAIL.  Otherwise, you have problems if one DirectInput
     *          app is using DEBUG and another is using RETAIL.
     *
     *          The global <c g_gsop> variable points to one of these things,
     *          suitably cast.
     *
     *  @field  int | cso |
     *
     *          Number of <t SHAREDOBJECT>s currently in use.  The array
     *          is kept packed for simplicity.
     *
     *  @field  DWORD | dwSequence |
     *
     *          Global sequence number used during data collection.
     *          (Not used if we have a VxD to manage a "really global"
     *          sequence number.)
     *
     *  @field  int | cguid |
     *
     *          Unique integer for GUID generation.
     *
     *  @field  DWORD | rgdwJoy[cMaxJoy] |
     *
     *          Counter used to keep track of how many times each joystick's
     *          force feedback driver has been reset.  This is used to make
     *          sure that nobody messes with a joystick that they don't own.
     *
     *          Each time the joystick is reset, the corresponding counter
     *          is incremented.  Before we do anything to a device, we check
     *          if the reset counter matches the value stored in the
     *          object.  If not, then it means that the device has been
     *          reset in the meantime and no longer belongs to the caller.
     *
     *          Note!  We support up to 16 joysticks.  Hope that'll be enough
     *          for a while.
     *
     *  @field  GLOBALJOYSTATE | rggjs[cMaxJoy] |
     *
     *          Global settings for each joystick.
     *
     *  @field  DWORD | tmConfigChanged
     *
     *          The tick count of last config changed.
     *
     *****************************************************************************/

#define cJoyMax     16              /* Up to 16 joysticks */
    typedef struct SHAREDOBJECTHEADER
    {
        int cso;
        DWORD dwSequence;
        int cguid;
        GLOBALJOYSTATE rggjs[cJoyMax];
        DWORD tmConfigChanged;
    } SHAREDOBJECTHEADER, *PSHAREDOBJECTHEADER;

#define g_psoh  ((PSHAREDOBJECTHEADER)g_psop)

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @topic  The Worker Thread |
     *
     *          Some emulation behaviors (low-level hooks, HID) require
     *          a worker thread to do the data collection.  We multiplex
     *          all such work onto a single worker thread (known as
     *          simple "the" worker thread).
     *
     *          The thread is spun up when the first client needs it
     *          and is taken down when the last client has been released.
     *
     *          To prevent race conditions from crashing us, we addref
     *          our DLL when the thread exists and have the thread
     *          perform a FreeLibrary as its final act.
     *
     *****************************************************************************/

    #define WORKER_THREAD

    /*****************************************************************************
     *
     *      diem.c - Emulation
     *
     *****************************************************************************/

    HRESULT EXTERNAL CEm_AcquireInstance(PVXDINSTANCE *ppvi);
    HRESULT EXTERNAL CEm_UnacquireInstance(PVXDINSTANCE *ppvi);
    HRESULT EXTERNAL CEm_SetBufferSize(PVXDDWORDDATA pvdd);
    HRESULT EXTERNAL CEm_DestroyInstance(PVXDINSTANCE *ppvi);

    HRESULT EXTERNAL CEm_SetDataFormat(PVXDDATAFORMAT pvdf);

    HRESULT EXTERNAL CEm_Mouse_CreateInstance(PVXDDEVICEFORMAT pdevf,
                                              PVXDINSTANCE *ppviOut);

    HRESULT EXTERNAL CEm_Mouse_InitButtons(PVXDDWORDDATA pvdd);

    HRESULT EXTERNAL CEm_Kbd_CreateInstance(PVXDDEVICEFORMAT pdevf,
                                            PVXDINSTANCE *ppviOut);

    HRESULT EXTERNAL CEm_Kbd_InitKeys(PVXDDWORDDATA pvdd);

    HRESULT EXTERNAL CEm_Joy_CreateInstance(PVXDDEVICEFORMAT pdevf,
                                            PVXDINSTANCE *ppviOut);

    HRESULT EXTERNAL CEm_Joy_Ping(PVXDINSTANCE *ppvi);

    HRESULT EXTERNAL CEm_HID_CreateInstance(PVXDDEVICEFORMAT pdevf,
                                            PVXDINSTANCE *ppviOut);

    /*****************************************************************************
     *
     *      diemm.c - Mouse Emulation
     *
     *****************************************************************************/

    void EXTERNAL    CEm_Mouse_AddState(LPDIMOUSESTATE_INT pms, DWORD tm);

    /*****************************************************************************
     *
     *      dinput.c - Basic DLL stuff
     *
     *****************************************************************************/

    void EXTERNAL DllEnterCrit_(LPCTSTR lptszFile, UINT line);
    void EXTERNAL DllLeaveCrit_(LPCTSTR lptszFile, UINT line);

#ifdef DEBUG
    BOOL EXTERNAL DllInCrit(void);
    #define DllEnterCrit() DllEnterCrit_(TEXT(__FILE__), __LINE__)
    #define DllLeaveCrit() DllLeaveCrit_(TEXT(__FILE__), __LINE__)
#else
    #define DllEnterCrit() DllEnterCrit_(NULL, 0x0)
    #define DllLeaveCrit() DllLeaveCrit_(NULL, 0x0)
#endif

    void EXTERNAL DllAddRef(void);
    void EXTERNAL DllRelease(void);

    BOOL EXTERNAL DllLoadLibrary(void);
    void EXTERNAL DllFreeLibrary(void);

#ifdef DEBUG

    extern UINT g_thidCrit;

    #define InCrit() (g_thidCrit == GetCurrentThreadId())

#endif

    /*
     *  Describes the CLSIDs we provide to OLE.
     */

    typedef STDMETHOD(CREATEFUNC)(PUNK punkOuter, RIID riid, PPV ppvOut);

    typedef struct CLSIDMAP
    {
        REFCLSID rclsid;        /* The clsid */
        CREATEFUNC pfnCreate;   /* How to create it */
        UINT    ids;            /* String that describes it */
    } CLSIDMAP, *PCLSIDMAP;

#ifdef DEBUG
    #define DEMONSTRATION_FFDRIVER
#ifdef DOWNLEVEL_COM
    #define cclsidmap   5       /* DirectInput, DirectInputDevice, DirectInput8, DirectInputDevice8, DIEffectDiver */
#else
    #define cclsidmap   3       /* DirectInput8, DirectInputDevice8, DIEffectDiver */
#endif
#else
#ifdef DOWNLEVEL_COM
    #define cclsidmap   4       /* CLSID_DirectInput, CLSID_DirectInputDevice, CLSID_DirectInput8, CLSID_DirectInputDevice8 */
#else
    #define cclsidmap   2       /* CLSID_DirectInput8, CLSID_DirectInputDevice8 */
#endif
#endif

    extern CLSIDMAP c_rgclsidmap[cclsidmap];

    /*****************************************************************************
     *
     *      dicf.c - IClassFactory implementation
     *
     *****************************************************************************/

    STDMETHODIMP CDIFactory_New(CREATEFUNC pfnCreate, RIID riid, PPV ppvObj);

    /*****************************************************************************
     *
     *      didenum.c - IDirectInput device enumeration
     *
     *****************************************************************************/
    
    typedef struct _CDIDEnum CDIDEnum;

    extern GUID rgGUID_Joystick[cJoyMax];

#define GUID_Joystick (rgGUID_Joystick[0])

    void EXTERNAL CDIDEnum_Release(CDIDEnum *pde);
    STDMETHODIMP CDIDEnum_Next(CDIDEnum *pde, LPDIDEVICEINSTANCEW pddiW);
    STDMETHODIMP CDIDEnum_InternalNext(CDIDEnum *pde, LPDIDEVICEINSTANCEW pddiW, LPDIRECTINPUTDEVICE8W *ppdid8W);
    STDMETHODIMP CDIDEnum_New(PDIW pdiW, DWORD dwDevType, DWORD edfl, DWORD dwVer, CDIDEnum **);

    /*****************************************************************************
     *
     *      diobj.c - IDirectInput implementation
     *
     *****************************************************************************/

    HRESULT EXTERNAL CDIObj_TestDeviceFlags(PDIDW pdidW, DWORD diedfl);
    HRESULT EXTERNAL CDIObj_TestDeviceFlagsInternal(PDIDW pdidW, DWORD diedfl);
    HRESULT EXTERNAL CDIObj_FindDeviceInternal(LPCTSTR ptszName, LPGUID pguidOut);

    STDMETHODIMP CDIObj_New(PUNK punkOuter, RIID riid, PPV ppvOut);

    typedef struct _DIMAPPER {
        LPCWSTR                  lpszUserName;
        LPDIACTIONFORMATW        pDiActionFormat;
        LPDIENUMDEVICESBYSEMANTICSCBW pecW;
        LPVOID                   pvRef;
        DWORD                    dwFlags;
    } DIMAPPER, *LPDIMAPPER;

    typedef struct _DIORDERDEV {
        DWORD dwOrder;
        DWORD dwFlags;
        LPDIRECTINPUTDEVICE8W pdid8W;
        DIDEVICEINSTANCEW ddiW;
        FILETIME ftTimeStamp;
    } DIORDERDEV, *LPDIORDERDEV;

    /*****************************************************************************
     *
     *      diaddhw.c - AddNewHardware
     *
     *****************************************************************************/

    HRESULT EXTERNAL AddNewHardware(HWND hwnd, REFGUID rguid);

    /*****************************************************************************
     *
     *      dijoycfg.c - IDirectInputJoyConfig implementation
     *
     *****************************************************************************/

    STDMETHODIMP CJoyCfg_New(PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *  @doc    INLINE
     *
     *  @method BOOL | IsWriteSam |
     *
     *          Nonzero if the registry security access mask will
     *          obtain (or attempt to obtain) write access.
     *
     *  @parm   REGSAM | regsam |
     *
     *          Registry security access mask.
     *
     *****************************************************************************/

    BOOL INLINE
        IsWriteSam(REGSAM sam)
    {
        return sam & (KEY_SET_VALUE | KEY_CREATE_SUB_KEY | MAXIMUM_ALLOWED);
    }

    /*****************************************************************************
     *
     *      dijoyreg.c - Joystick registry services
     *
     *****************************************************************************/
    extern LPCWSTR c_rghwIdPredef[];

    STDMETHODIMP JoyReg_OpenTypeKey(LPCWSTR pwszType, DWORD sam, DWORD dwOptions, PHKEY phk);
    STDMETHODIMP JoyReg_OpenPropKey(LPCWSTR pwszType, DWORD sam, DWORD dwOptions, PHKEY phk);    
    STDMETHODIMP JoyReg_OpenFFKey(HKEY hkType, REGSAM sam, PHKEY phk);

    STDMETHODIMP
        JoyReg_OpenConfigKey(UINT idJoy, DWORD sam, DWORD dwOptions, PHKEY phk);

    STDMETHODIMP JoyReg_GetTypeInfo(LPCWSTR pwszType,
                                    LPDIJOYTYPEINFO pjti, DWORD fl);
    STDMETHODIMP JoyReg_SetTypeInfo(HKEY hkTypesW, LPCWSTR pwszType,
                                    LPCDIJOYTYPEINFO pjti, DWORD fl);

    STDMETHODIMP JoyReg_GetConfig(UINT idJoy, LPDIJOYCONFIG pcfg, DWORD fl);
    STDMETHODIMP JoyReg_SetConfig(UINT idJoy, LPJOYREGHWCONFIG phwc,
                                  LPCDIJOYCONFIG pcfg, DWORD fl);

    STDMETHODIMP JoyReg_GetUserValues(LPDIJOYUSERVALUES pjuv, DWORD fl);
    STDMETHODIMP JoyReg_SetUserValues(LPCDIJOYUSERVALUES pjuv, DWORD fl);


    STDMETHODIMP
        JoyReg_GetSetConfigValue(HKEY hk, LPCTSTR ptszNValue, UINT idJoy,
                                 DWORD reg, PV pvBuf, DWORD cb, BOOL fSet);

#define GSCV_GET        0
#define GSCV_SET        1

#define JoyReg_GetConfigValue(hk, ptsz, id, reg, pv, cb) \
        JoyReg_GetSetConfigValue(hk, ptsz, id, reg, pv, cb, GSCV_GET)

#define JoyReg_SetConfigValue(hk, ptsz, id, reg, pv, cb) \
        JoyReg_GetSetConfigValue(hk, ptsz, id, reg, (PV)(pv), cb, GSCV_SET)


    STDMETHODIMP
        JoyReg_GetValue(HKEY hk, LPCTSTR ptszValue, DWORD reg, PV pvBuf, DWORD cb);

#ifndef WINNT
    STDMETHODIMP
        JoyReg_IsWdmGameport(HKEY hk);
#endif

#if 0
    STDMETHODIMP
        JoyReg_IsWdmGameportFromDeviceInstance( LPTSTR ptszDeviceInst );
#endif

    STDMETHODIMP
        JoyReg_SetValue(HKEY hk, LPCTSTR ptszValue, DWORD reg, PCV pvBuf, DWORD cb);

#ifndef WINNT
    LPSTR EXTERNAL
        JoyReg_JoyIdToDeviceInterface_95(UINT idJoy, PVXDINITPARMS pvip, LPSTR ptszBuf);
#endif

    HRESULT EXTERNAL
        JoyReg_GetPredefTypeInfo(LPCWSTR pwszType, LPDIJOYTYPEINFO pjti, DWORD fl);

    HRESULT EXTERNAL
        hResIdJoypInstanceGUID_95( UINT idJoy, LPGUID  lpguid);

    HRESULT EXTERNAL
        hResIdJoypInstanceGUID_WDM( UINT idJoy, LPGUID  lpguid);

#ifdef WINNT
#define hResIdJoypInstanceGUID(id,lpguid)  hResIdJoypInstanceGUID_WDM(id, lpguid)
#else
#define hResIdJoypInstanceGUID(id,lpguid)  hResIdJoypInstanceGUID_95(id, lpguid)
#endif

#if 0
    HRESULT EXTERNAL JoyReg_GetIDByOemName( LPTSTR szOemName, PUINT pId );
#endif
/*****************************************************************************
*
*      didev.c - IDirectInputDevice implementation
*
*****************************************************************************/

    void EXTERNAL DeviceInfoWToA(LPDIDEVICEINSTANCEA pdiA,
                                 LPCDIDEVICEINSTANCEW pdiW);

    void EXTERNAL Device8WTo8A(LPDIRECTINPUTDEVICE8A *ppdid8A, LPDIRECTINPUTDEVICE8W pdid8W);

    STDMETHODIMP CDIDev_New(PUNK punkOuter, RIID riid, PPV ppvObj);

    /*****************************************************************************
     *
     *      CDIDev_Enter/LeaveCrit are secret backdoors to allow emulation
     *      and effects
     *      to take the device critical section when updating buffers.
     *
     *      CDIDev_InCrit is used for assertion checking.
     *
     *      CDIDev_IsExclAcquired is used by effects to make sure the parent
     *      is acquired for exclusive before attempting to download.
     *
     *      CDIDev_SyncShepHandle is used to get the joystick "tag" which
     *      is used by dieshep.c to determine who owns the joystick.
     *
     *****************************************************************************/

    void EXTERNAL CDIDev_EnterCrit_(struct CDIDev *this, LPCTSTR lptszFile, UINT line);
    void EXTERNAL CDIDev_LeaveCrit_(struct CDIDev *this, LPCTSTR lptszFile, UINT line);

#ifdef DEBUG
    BOOL INTERNAL CDIDev_InCrit(struct CDIDev *this);
    #define CDIDev_EnterCrit(cdidev) CDIDev_EnterCrit_(cdidev, TEXT(__FILE__), __LINE__)
    #define CDIDev_LeaveCrit(cdidev) CDIDev_LeaveCrit_(cdidev, TEXT(__FILE__), __LINE__)
#else
    #define CDIDev_EnterCrit(cdidev) CDIDev_EnterCrit_(cdidev, NULL, 0x0);
    #define CDIDev_LeaveCrit(cdidev) CDIDev_LeaveCrit_(cdidev, NULL, 0x0);
#endif

#ifndef XDEBUG

    #define CDIDev_IsExclAcquired_(pdd, z)                          \
       _CDiDev_IsExclAcquired_(pdd)                                 \

#endif

    STDMETHODIMP CDIDev_IsExclAcquired_(struct CDIDev *this, LPCSTR s_szProc);

#define CDIDev_IsExclAcquired(pdd)                                  \
        CDIDev_IsExclAcquired_(pdd, s_szProc)                       \


    STDMETHODIMP CDIDev_SyncShepHandle(struct CDIDev *this, PSHEPHANDLE psh);

    /*****************************************************************************
     *
     *      CDIDev_SetNotifyEvent is used by the emulation code to
     *      notify the application when the state of the device changes.
     *
     *****************************************************************************/

    void EXTERNAL CDIDev_SetNotifyEvent(struct CDIDev *this);
    void EXTERNAL CDIDev_SetForcedUnacquiredFlag(struct CDIDev *this);

    /*****************************************************************************
     *
     *      CDIDev_NotifyCreate/DestroyEvent is used by CDIEff to
     *      let the parent know when a child effect comes or goes.
     *
     *      CDIDev_FindEffectGUID is used by CDIEff to convert an
     *      effect GUID into an effect cookie dword.
     *
     *      CDIDev_ConvertObjects converts item identifiers in various ways.
     *
     *****************************************************************************/

    HRESULT EXTERNAL
        CDIDev_NotifyCreateEffect(struct CDIDev *this, struct CDIEff *pdeff);
    HRESULT EXTERNAL
        CDIDev_NotifyDestroyEffect(struct CDIDev *this, struct CDIEff *pdeff);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct EFFECTMAPINFO |
     *
     *          Information about an effect, much like a
     *          <t DIEFFECTINFO>, but containing the
     *          effect ID, too.
     *
     *  @field  DWORD | dwId |
     *
     *          The effect ID.  This comes first so we can copy
     *          an <t EFFECTMAPINFO> into a <t DIEFFECTINFO>
     *          all at one go.
     *
     *  @field  GUID | guid |
     *
     *          The effect GUID.
     *
     *  @field  DWORD | dwEffType |
     *
     *          The effect type and flags.
     *
     *  @field  WCHAR | wszName[MAX_PATH] |
     *
     *          The name for the effect.
     *
     *****************************************************************************/

    typedef struct EFFECTMAPINFO
    {
        DIEFFECTATTRIBUTES attr;
        GUID    guid;
        WCHAR   wszName[MAX_PATH];
    } EFFECTMAPINFO, *PEFFECTMAPINFO;
    typedef const EFFECTMAPINFO *PCEFFECTMAPINFO;

    #ifndef XDEBUG

        #define CDIDev_FindEffectGUID_(this, rguid, pemi, z, i)     \
       _CDIDev_FindEffectGUID_(this, rguid, pemi)                   \

    #endif

    #define CDIDev_FindEffectGUID(this, rguid, pemi, iarg)          \
        CDIDev_FindEffectGUID_(this, rguid, pemi, s_szProc, iarg)   \


    STDMETHODIMP
        CDIDev_FindEffectGUID_(struct CDIDev *this, REFGUID rguid,
                               PEFFECTMAPINFO pemi, LPCSTR s_szProc, int iarg);

    STDMETHODIMP
        CDIDev_ConvertObjects(struct CDIDev *this, UINT cdw, LPDWORD rgdw, UINT fl);

    /*
     *  Note that the bonus DEVCO flags live inside the DIDFT_INSTANCEMASK.
     */
    #define DEVCO_AXIS              DIDFT_AXIS
    #define DEVCO_BUTTON            DIDFT_BUTTON
    #define DEVCO_TYPEMASK          DIDFT_TYPEMASK

    #define DEVCO_FFACTUATOR        DIDFT_FFACTUATOR
    #define DEVCO_FFEFFECTTRIGGER   DIDFT_FFEFFECTTRIGGER
    #define DEVCO_ATTRMASK          DIDFT_ATTRMASK

    #define DEVCO_FROMID            0x00000100
    #define DEVCO_FROMOFFSET        0x00000200
    #define DEVCO_FROMMASK          0x00000300
    #define DEVCO_TOID              0x00001000
    #define DEVCO_TOOFFSET          0x00002000
    #define DEVCO_TOMASK            0x00003000


    #if ((DEVCO_FROMMASK | DEVCO_TOMASK) & DIDFT_INSTANCEMASK) !=       \
     (DEVCO_FROMMASK | DEVCO_TOMASK)
        #error DEVCO_FROMMASK and DEVCI_TOMASK should not escape DIDFT_INSTANCEMASK.
    #endif

    #define DEVCO_VALID          (DEVCO_TYPEMASK |      \
                                 DEVCO_ATTRMASK |       \
                                 DEVCO_FROMMASK |       \
                                 DEVCO_TOMASK)


    /*****************************************************************************
     *
     *      dieffv.c - IDirectInputEffectDriver for VJoyD joysticks
     *
     *****************************************************************************/

    STDMETHODIMP CEffVxd_New(PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      dieshep.c - IDirectInputEffectShepherd
     *
     *****************************************************************************/

    STDMETHODIMP CEShep_New(HKEY hk, PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      digendef.c - Default IDirectInputDeviceCallback
     *
     *****************************************************************************/

    /*
     *  We can't call it a DCB because winbase.h already has one for
     *  comm goo.
     */

    typedef IDirectInputDeviceCallback DICB, *PDICB;

    STDMETHODIMP
        CDefDcb_Acquire(PDICB pdcb);

    STDMETHODIMP
        CDefDcb_Unacquire(PDICB pdcb);

    STDMETHODIMP
        CDefDcb_GetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPDIPROPHEADER pdiph);

    STDMETHODIMP
        CDefDcb_SetProperty(PDICB pdcb, LPCDIPROPINFO ppropi, LPCDIPROPHEADER pdiph);

    STDMETHODIMP
        CDefDcb_SetEventNotification(PDICB pdcb, HANDLE h);

    STDMETHODIMP
        CDefDcb_SetCooperativeLevel(PDICB pdcb, HWND hwnd, DWORD dwFlags);

    STDMETHODIMP
        CDefDcb_CookDeviceData(PDICB pdcb, DWORD cdod, LPDIDEVICEOBJECTDATA rgdod);

    STDMETHODIMP
        CDefDcb_CreateEffect(PDICB pdcb, LPDIRECTINPUTEFFECTSHEPHERD *ppes);

    STDMETHODIMP
        CDefDcb_GetFFConfigKey(PDICB pdcb, DWORD sam, PHKEY phk);

    STDMETHODIMP
        CDefDcb_SendDeviceData(PDICB pdcb, DWORD cbdod, LPCDIDEVICEOBJECTDATA rgdod,
                               LPDWORD pdwInOut, DWORD fl);

    STDMETHODIMP
        CDefDcb_Poll(IDirectInputDeviceCallback *pdcb);

    STDMETHODIMP
        CDefDcb_GetVersions(IDirectInputDeviceCallback *pdcb, LPDIDRIVERVERSIONS pvers);

    STDMETHODIMP
        CDefDcb_MapUsage(IDirectInputDeviceCallback *pdcb, DWORD dwUsage, PINT piOut);

    STDMETHODIMP_(DWORD)
        CDefDcb_GetUsage(IDirectInputDeviceCallback *pdcb, int iobj);

    STDMETHODIMP
        CDefDcb_SetDIData(PDICB pdcb, DWORD dwVer, LPVOID lpdihacks);

    STDMETHODIMP
        CDefDcb_BuildDefaultActionMap(PDICB pdcb, LPDIACTIONFORMATW pActionFormat,
                                    DWORD dwFlags, REFGUID guidInst);

    /*****************************************************************************
     *
     *      digenx.c - IDirectInputDeviceCallback that does nothing
     *
     *****************************************************************************/

    extern IDirectInputDeviceCallback c_dcbNil;

#define c_pdcbNil       &c_dcbNil

    /*****************************************************************************
     *
     *      digenm.c - IDirectInputDeviceCallback for mouse
     *
     *****************************************************************************/

    STDMETHODIMP CMouse_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      digenk.c - IDirectInputDeviceCallback for keyboard
     *
     *****************************************************************************/
    extern BYTE g_rgbKbdRMap[];
    STDMETHODIMP CKbd_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      digenj.c - IDirectInputDeviceCallback for joystick
     *
     *****************************************************************************/

    STDMETHODIMP CJoy_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @func   UINT | ibJoyPosAxisFromPosAxis |
     *
     *          Returns the offset of the <p iAxis>'th joystick axis
     *          in the <t JOYPOS> structure.
     *
     *  @parm   UINT | uiAxis |
     *
     *          The index of the requested axis.  X, Y, Z, R, U and V are
     *          respctively zero through five.
     *
     *  @returns
     *
     *          The offset relative to the structure.
     *
     *****************************************************************************/

#define _ibJoyPosAxisFromPosAxis(uiAxis)   \
         (FIELD_OFFSET(JOYPOS, dwX) + cbX(DWORD) * (uiAxis))

    UINT INLINE
        ibJoyPosAxisFromPosAxis(UINT uiPosAxis)
    {
#define CheckAxis(x)                                            \
        CAssertF(_ibJoyPosAxisFromPosAxis(iJoyPosAxis##x)       \
                            == FIELD_OFFSET(JOYPOS, dw##x))     \

        CheckAxis(X);
        CheckAxis(Y);
        CheckAxis(Z);
        CheckAxis(R);
        CheckAxis(U);
        CheckAxis(V);

#undef CheckAxis

        return _ibJoyPosAxisFromPosAxis(uiPosAxis);
    }

    /*****************************************************************************
     *
     *      dieffj.c - Dummy IDirectInputEffectDriver for joystick
     *
     *****************************************************************************/

    STDMETHODIMP CJoyEff_New(PUNK punkOuter, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      dihid.c - IDirectInputDeviceCallback for generic HID devices
     *
     *****************************************************************************/
    STDMETHODIMP CHid_New(PUNK punkOuter, REFGUID rguid, RIID riid, PPV ppvOut);

    /*****************************************************************************
     *
     *      dieff.c - IDirectInputEffect implementation
     *
     *****************************************************************************/

    STDMETHODIMP
        CDIEff_New(struct CDIDev *pdev, LPDIRECTINPUTEFFECTSHEPHERD pes,
                   PUNK punkOuter, RIID riid, PPV ppvObj);

    /*****************************************************************************
     *
     *      dihidusg.c - HID usage converters
     *
     *****************************************************************************/

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct HIDUSAGEMAP |
     *
     *          This structure maps HID usages to GUIDs
     *          or legacy joystick axes.
     *
     *  @field  DWORD | dwUsage |
     *
     *          Packed usage via <f DIMAKEUSAGEDWORD>.
     *
     *  @field  BYTE | bPosAxis |
     *
     *          <t JOYPOS> axis number, where 0 = X, 1 = Y, ..., 5 = V.
     *
     *  @field  BYTE | bSemFlag |
     *
     *          DISEM_FLAGS_* value for axis.
     *
     *  @field  BYTE | bReserved1 |
     *
     *          Byte reserved to improve alignment
     *
     *  @field  BYTE | bReserved2 |
     *
     *          Byte reserved to improve alignment
     *
     *  @field  DWORD | dwSemHint |
     *
     *          A root of a semantic generally appropriate for this axis.
     *
     *  @field  PCGUID | pguid |
     *
     *          Corresponding <t GUID>.
     *
     *****************************************************************************/

    typedef struct HIDUSAGEMAP
    {

        DWORD   dwUsage;
        BYTE    bPosAxis;
        BYTE    bSemFlag;
        BYTE    bReserved1;
        BYTE    bReserved2;
        DWORD   dwSemHint;
        PCGUID  pguid;

    } HIDUSAGEMAP, *PHIDUSAGEMAP;

    PHIDUSAGEMAP EXTERNAL UsageToUsageMap(DWORD dwUsage);

    /*
     *  Flags defined for dwSemHint
     *  The names have the same suffixes as the equivalent HID usages
     *  Values are ORed together for a summary of a device's default semantics
     */
    #define DISEM_HINT_X            0x00000001
    #define DISEM_HINT_Y            0x00000002
    #define DISEM_HINT_Z            0x00000004
    #define DISEM_HINT_WHEEL        0x00000004
    #define DISEM_HINT_RX           0x00000008
    #define DISEM_HINT_RY           0x00000010
    #define DISEM_HINT_RZ           0x00000020
    #define DISEM_HINT_SIXDOF       0x0000003F
    #define DISEM_HINT_THROTTLE     0x00000040
    #define DISEM_HINT_POV          0x00000080
    #define DISEM_HINT_HATSWITCH    0x00000080
    #define DISEM_HINT_ACCELERATOR  0x00000100
    #define DISEM_HINT_BRAKE        0x00000200
    #define DISEM_HINT_CLUTCH       0x00000400
    #define DISEM_HINT_SHIFTER      0x00000800
    #define DISEM_HINT_STEERING     0x00001000
    #define DISEM_HINT_RUDDER       0x00002000
    #define DISEM_HINT_SLIDER       0x00004000
    #define DISEM_HINT_DIAL         0x00004000
    #define DISEM_HINT_ABSOLUTE     0x00008000

    DWORD EXTERNAL GuidToUsage(PCGUID pguid);

    UINT EXTERNAL
        GetHIDString(DWORD Usage, DWORD UsagePage, LPWSTR pwszBuf, UINT cwch);

    void EXTERNAL InsertCollectionNumber(UINT icoll, LPWSTR pwszBuf);

    /*****************************************************************************
     *
     *      disubcls.c - Subclassing
     *
     *****************************************************************************/

    typedef LRESULT
        (CALLBACK *SUBCLASSPROC)(HWND hwnd, UINT wm, WPARAM wp,
                                 LPARAM lp, UINT_PTR uId, ULONG_PTR dwRef);

    BOOL EXTERNAL
        SetWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uId, ULONG_PTR dwRef);

    BOOL EXTERNAL
        GetWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uId, ULONG_PTR *pdwRef);

    BOOL EXTERNAL
        RemoveWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uId);

    LRESULT EXTERNAL
        DefSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp);

    /*****************************************************************************
     *
     *      dical.c - Axis ramps and calibration
     *
     *      Structure names begin with "Joy" for historical reasons.
     *
     *****************************************************************************/

#if defined(_X86_)

    LONG EXTERNAL CCal_MulDiv(LONG lA, LONG lB, LONG lC);

#else

    #define CCal_MulDiv     MulDiv

#endif

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct JOYRAMP |
     *
     *          Parameters for a "ramp".  A ramp looks like this:
     *
     *             r       !
     *             e    dy -      *---
     *             t       !     /
     *             u       !    /
     *             r       !   /
     *             n     y ---*
     *             e       !
     *             d       +--!---!---
     *                        x   dx
     *
     *                  physical position
     *
     *
     *          y, dy = baseline and height
     *
     *          x, dx = initiation level and width
     *
     *          The mapping is
     *
     *
     *          (-infty, x    ] -> y
     *          (x,      x+dx ) -> (y, y+dy)
     *          [x+dx,   infty) -> y+dy
     *
     *          It is very important that the middle range not be taken
     *          if dx = 0.
     *
     *  @field  int | x |
     *
     *          Horizontal value below which we return the baseline.
     *
     *  @field  DWORD | dx |
     *
     *          Width of the ramp.  Beyond this point, we return the
     *          full height.
     *
     *  @field  int | y |
     *
     *          Baseline.
     *
     *  @field  int | dy |
     *
     *          Total height.
     *
     *****************************************************************************/

    typedef struct JOYRAMP
    {

        int     x;
        int     y;
        DWORD   dx;
        int     dy;

    } JOYRAMP, *PJOYRAMP;

    typedef const JOYRAMP *PCJOYRAMP;

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @struct JOYRANGECONVERT |
     *
     *          Parameters for range conversion.
     *
     *          The conversion curve is in five sections.
     *
     *
     *
     *                 !
     *             lmax-                     *----
     *         r       !                    /
     *         e       !                   /
     *         t       !                  /
     *         u     lc-          *------*
     *         r       !         /
     *         n       !        /
     *         e       !       /
     *         d   lmin-------*
     *                 !
     *                 +-!----!---!------!----!----!--
     *                pmin  smin dmin  dmax  smax  pmax
     *
     *                                !
     *                                pc
     *
     *
     *                        physical position
     *
     *
     *      lmin/lmax = logical min/max - This is the smallest/largest
     *          position the app will ever see.
     *
     *      lc = logical center
     *
     *      pmin/pmax = physical min/max - This is the position determined by
     *          calibration to be the value which the hardware reports
     *          when the device is physically at its bottom/upper limit.  Note
     *          that the hardware might report values outside this range.
     *
     *      pc = physical center - This is the nominal neutral location for
     *           the axis
     *
     *      dmin/dmax = dead zone min/max - This is the zone around which
     *          the center is artificially expanded.
     *
     *      smin/smax = saturation min/max - This is the level at which
     *          we treat the axis as being at its most extreme position.
     *
     *  @field  BOOL | fRaw |
     *
     *          Is the axis in raw mode?  If so, then no cooking is performed.
     *
     *  @field  JOYRAMP | rmpLow |
     *
     *          The ramp for below-center.
     *
     *  @field  JOYRAMP | rmpHigh |
     *
     *          The ramp for above-center.
     *
     *  @field  DWORD | dwPmin |
     *
     *          Physical minimum.
     *
     *  @field  DWORD | dwPmax |
     *
     *          Physical maximum.
     *
     *  @field  LONG | lMin |
     *
     *          Logical minimum.
     *
     *  @field  LONG | lCenter |
     *
     *          Logical center.
     *
     *  @field  LONG | lMax |
     *
     *          Logical maximum.
     *
     *  @field  DWORD | dwPc |
     *
     *          Physical center.
     *
     *  @field  DWORD | dwDz |
     *
     *          Dead zone (in ten thousandths, 10000 = 100%).
     *
     *  @field  DWORD | dwSat |
     *
     *          Saturation level (in ten thousands, 10000 = 100%).
     *
     *  @field  BOOL | fPolledPOV |
     *
     *          Whether the axis is a polled POV. Usable only when the axis is a POV.
     *
     *  @field  LONG | lMinPOV[5] |
     *
     *          Mininum ranges of POV directions. Usable only when the axis is a POV.
     *
     *  @field  LONG | lMaxPOV[5] |
     *
     *          Maxinum ranges of POV directions. Usable only when the axis is a POV.
     *
     *
     *****************************************************************************/

    /*
     *  Number of range divisions.  We work in ten thousandths.
     */
#define RANGEDIVISIONS      10000

    typedef struct JOYRANGECONVERT
    {

        BOOL fRaw;
        JOYRAMP rmpLow;
        JOYRAMP rmpHigh;

        DWORD dwPmin;
        DWORD dwPmax;
        DWORD dwPc;
        LONG lMin;
        LONG lMax;
        LONG lC;
        DWORD dwDz;
        DWORD dwSat;

        DWORD  dwCPointsNum;
        CPOINT cp[MAXCPOINTSNUM];  //4 is for deadzone(2) and saturation(2)

      #ifdef WINNT
        BOOL  fPolledPOV;
        LONG  lMinPOV[5];
        LONG  lMaxPOV[5];
      #endif
    } JOYRANGECONVERT, *PJOYRANGECONVERT;

    typedef const JOYRANGECONVERT *PCJOYRANGECONVERT;

    /*****************************************************************************
     *
     *      dical.c functions
     *
     *****************************************************************************/

    void EXTERNAL CCal_CookRange(PJOYRANGECONVERT this, LONG UNALIGNED *pl);
    void EXTERNAL CCal_RecalcRange(PJOYRANGECONVERT this);

    STDMETHODIMP
        CCal_GetProperty(PJOYRANGECONVERT this, REFGUID rguid, LPDIPROPHEADER pdiph);

    STDMETHODIMP
        CCal_SetProperty(PJOYRANGECONVERT this, LPCDIPROPINFO ppropi,
                         LPCDIPROPHEADER pdiph, HKEY hkType);

    /*****************************************************************************
     *
     *  @doc    INTERNAL
     *
     *  @func   LONG | CCal_Midpoint |
     *
     *          Return the midpoint of two values.  Note, however, that
     *          we round <y upward> instead of downward.  This is important,
     *          because many people set the ranges to something like
     *          0 .. 0xFFFF, and we want the midpoint to be 0x8000.
     *
     *          Care must be taken that the intermediate sum does not overflow.
     *
     *  @parm   LONG | lMin |
     *
     *          Lower limit.
     *
     *  @parm   LONG | lMax |
     *
     *          Upper limit.
     *
     *  @returns
     *
     *          The midpoint.
     *
     *****************************************************************************/

    LONG INLINE
        CCal_Midpoint(LONG lMin, LONG lMax)
    {
        /*
         *  Can't do "lMax + lMin" because that might overflow.
         */
        AssertF(lMax >= lMin);
        return lMin + (UINT)(lMax - lMin + 1) / 2;
    }

    /*****************************************************************************
     *
     *      dijoytyp.c
     *
     *****************************************************************************/

    STDMETHODIMP CType_OpenIdSubkey(HKEY, DWORD, REGSAM, PHKEY);
    void EXTERNAL CType_RegGetObjectInfo(HKEY hkType, DWORD dwId,
                                         LPDIDEVICEOBJECTINSTANCEW pdidoiW);
    void EXTERNAL CType_RegGetTypeInfo(HKEY hkType, LPDIOBJECTDATAFORMAT podf, BOOL bHid);
    void EXTERNAL CType_MakeGameCtrlName(PWCHAR wszOutput, DWORD dwDevType, 
        DWORD dwAxes, DWORD dwButtons, DWORD dwPOVs );


    /*****************************************************************************
     *
     *      didevdf.c
     *
     *****************************************************************************/

    HRESULT CDIDev_ActionMap_IsValidMapObject(LPDIACTIONFORMATW paf
        #ifdef XDEBUG
            comma LPCSTR pszProc
            comma UINT argnum
        #endif
    );

    STDMETHODIMP CMap_ValidateActionMapSemantics( LPDIACTIONFORMATW paf,
        DWORD               dwFlags
    );

    STDMETHODIMP CMap_BuildDefaultSysActionMap( LPDIACTIONFORMATW paf, 
        DWORD dwFlags, DWORD dwPhysicalGenre, REFGUID guidDevInst, 
        LPDIDATAFORMAT dfDev, DWORD dwButtonZeroInst
    );

    typedef struct _DIDOBJDEFSEM
    {
        DWORD   dwID;               /* object id of control */
        DWORD   dwSemantic;         /* default semantic match */
    } DIDOBJDEFSEM, *PDIDOBJDEFSEM;

    STDMETHODIMP CMap_BuildDefaultDevActionMap( LPDIACTIONFORMATW paf, DWORD dwFlags,
        REFGUID guidDevInst, PDIDOBJDEFSEM rgObjSem,
        DWORD dwNumAxes, DWORD dwNumPOVs, DWORD dwNumButtons );

    STDMETHODIMP CMap_DeviceValidateActionMap( PV pdd, LPDIACTIONFORMATW paf, DWORD dwFlags, 
                                               PDWORD pdwOut );

    STDMETHODIMP CMap_InitializeCRCTable( void );

    HRESULT CMap_GetDeviceUserName( REFGUID guidDevInst, LPWSTR wszOwner );

    /*****************************************************************************
     *
     *      diaphack.c
     *
     *****************************************************************************/

    BOOL EXTERNAL AhGetAppHacks(LPTSTR tszAppId);
    HRESULT EXTERNAL     AhAppRegister(DWORD dwVer, DWORD dwMapper);


    /*****************************************************************************
     *
     *      dimapshp.c - IDirectInputMapShepherd
     *
     *****************************************************************************/

    STDMETHODIMP CMapShep_New(PUNK punkOuter, RIID riid, PPV ppvObj);

    HRESULT INTERNAL
    _CreateInstance(REFCLSID rclsid, LPCTSTR ptszDll, LPUNKNOWN punkOuter,
                RIID riid, PPV ppvOut, HINSTANCE *phinst);

    /*****************************************************************************
     *
     *      diraw.c
     *
     *****************************************************************************/
  #ifdef USE_WM_INPUT
    #define DIRAW_NONEXCL       0
    #define DIRAW_EXCL          1
    #define DIRAW_NOHOTKEYS     2
    
    HRESULT CDIRaw_RegisterRawInputDevice( UINT uirim, DWORD dwOrd, HWND hwnd);
    HRESULT CDIRaw_UnregisterRawInputDevice( UINT uirim, HWND hwnd );
    BOOL    CDIRaw_OnInput(MSG *pmsg);
    HRESULT INTERNAL CDIRaw_Mouse_InitButtons();
    int     EXTERNAL DIRaw_GetKeyboardType(int nTypeFlag);
  #endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dinputrc.h ===
/***************************************************************************
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputrc.h
 *  Content:    DirectInput internal resource header file
 *
 ***************************************************************************/


/*****************************************************************************
 *
 *  Strings
 *
 *****************************************************************************/

/*
 *  IDS_STDMOUSE
 *
 *      Friendly name for the standard mouse device.
 */
#define IDS_STDMOUSE            16

/*
 *  IDS_STDKEYBOARD
 *
 *      Friendly name for the standard keyboard device.
 */
#define IDS_STDKEYBOARD         17

/*
 *  IDS_STDJOYSTICK
 *
 *      Friendly name for the standard joystick devices.
 *
 *      This string contains a %d.
 */
#define IDS_STDJOYSTICK         18

/*
 *  IDS_DIRECTINPUT
 *
 *      CLSID name for OLE registration.
 */
#define IDS_DIRECTINPUT8         19

/*
 *  IDS_DIRECTINPUTDEVICE
 *
 *      CLSID name for OLE registration.
 */
#define IDS_DIRECTINPUTDEVICE8   20

/*
 *  IDS_BUTTONTEMPLATE
 *
 *      Template for generic button name.
 */
#define IDS_BUTTONTEMPLATE      28

/*
 *  IDS_AXISTEMPLATE
 *
 *      Template for generic axis name.
 */
#define IDS_AXISTEMPLATE        29

/*
 *  IDS_POVTEMPLATE
 *
 *      Template for generic POV name.
 */
#define IDS_POVTEMPLATE         30

/*
 *  IDS_COLLECTIONTEMPLATE
 *
 *      Template for generic collection name.
 */
#define IDS_COLLECTIONTEMPLATE  31

/*
 *  IDS_COLLECTIONTEMPLATEFORMAT
 *
 *      Template for generic collection name with room for a "%s"
 *      where the friendly name is kept.
 */
#define IDS_COLLECTIONTEMPLATEFORMAT 32


/*
 *  IDS_STDGAMEPORT
 *
 *      Friendly name for the standard gameport devices.
 *
 *      This string contains a %d.
 */

#define IDS_STDGAMEPORT         33

/*
 *  IDS_STDSERIALPORT
 *
 *      Friendly name for the standard serialport devices.
 *
 *      This string contains a %d.
 */

#define IDS_STDSERIALPORT       34

/*
 *  IDS_UNKNOWNTEMPLATE
 *
 *      Template for Unknown device object.
 */
#define IDS_UNKNOWNTEMPLATE     35

/*
 *  IDS_DEFAULTUSER
 *
 *      Default name for user if no other could be found.
 *      (was unused IDS_UNKNOWNTEMPLATEFORMAT)
 */
#define IDS_DEFAULTUSER         36

/*
 *  IDS_MOUSEOBJECT+0 ... IDS_MOUSEOBJECT+255
 *
 *      Friendly names for mouse device objects.
 */
#define IDS_MOUSEOBJECT         0x0100


/*
 *  IDS_KEYBOARDOBJECT_UNKNOWN
 *
 *      Name for key for which no string name could be found.
 */
#define IDS_KEYBOARDOBJECT_UNKNOWN  0x01FF

/*
 *  IDS_KEYBOARDOBJECT+0 ... IDS_KEYBOARDOBJECT+255
 *
 *      Friendly names for keyboard objects.
 */
#define IDS_KEYBOARDOBJECT      0x0200

/*
 *  IDS_JOYSTICKOBJECT+0 ... IDS_JOYSTICKOBJECT+255
 *
 *      Friendly names for joystick objects.
 */
#define IDS_JOYSTICKOBJECT      0x0300

/*
 *  IDS_PREDEFJOYTYPE+0 ... IDS_PREDEFJOYTYPE+255
 *
 *      Friendly names for predefined joystick types.
 */
#define IDS_PREDEFJOYTYPE       0x0400

/* Gap of 256 string IDs for alignment */

/*
 *  IDS_PAGE_GENERIC+0 ... IDS_PAGE_GENERIC+511
 *
 *      Friendly names for HID Usage Page = Generic
 */
#define IDS_PAGE_GENERIC        0x0600

/*
 *  IDS_PAGE_VEHICLE+0 ... IDS_PAGE_VEHICLE+511
 *
 *      Friendly names for HID Usage Page = Vehicle
 */
#define IDS_PAGE_VEHICLE        0x0800

/*
 *  IDS_PAGE_VR+0 ... IDS_PAGE_VR+511
 *
 *      Friendly names for HID Usage Page = VR
 */
#define IDS_PAGE_VR             0x0A00

/*
 *  IDS_PAGE_SPORT+0 ... IDS_PAGE_SPORT+511
 *
 *      Friendly names for HID Usage Page = Sport Controls
 */
#define IDS_PAGE_SPORT          0x0C00

/*
 *  IDS_PAGE_GAME+0 ... IDS_PAGE_GAME+511
 *
 *      Friendly names for HID Usage Page = Game Controls
 */
#define IDS_PAGE_GAME           0x0E00

/*
 *  IDS_PAGE_LED+0 ... IDS_PAGE_LED+511
 *
 *      Friendly names for HID Usage Page = LEDs
 */
#define IDS_PAGE_LED            0x1000

/*
 *  IDS_PAGE_TELEPHONY+0 ... IDS_PAGE_TELEPHONY+511
 *
 *      Friendly names for HID Usage Page = Telephony
 */
#define IDS_PAGE_TELEPHONY      0x1200

/*
 *  IDS_PAGE_CONSUMER+0 ... IDS_PAGE_CONSUMER+511
 *
 *      Friendly names for HID Usage Page = Consumer
 */
#define IDS_PAGE_CONSUMER       0x1400

/*
 *  IDS_PAGE_DIGITIZER+0 ... IDS_PAGE_DIGITIZER+511
 *
 *      Friendly names for HID Usage Page = Digitizer
 */
#define IDS_PAGE_DIGITIZER      0x1600

/*
 *  IDS_PAGE_KEYBOARD+0 ... IDS_PAGE_KEYBOARD+511
 *
 *      Friendly names for HID Usage Page = Keyboard
 */
#define IDS_PAGE_KEYBOARD       0x1800


/*
 *  IDS_PAGE_PID+0 ... IDS_PAGE_PID+511
 *
 *      Friendly names for HID Usage Page = PID
 */
#define IDS_PAGE_PID            0x1A00

/*****************************************************************************
 *
 *  RCDATA
 *
 *  Japanese keyboard translation tables are stored in resources.
 *
 *  This lets us change them at the last minute without too much risk.
 *
 *  It also keeps them out of our image.
 *
 *****************************************************************************/

#define IDDATA_KBD_NEC98        1
#define IDDATA_KBD_NEC98LAPTOP  IDDATA_KBD_NEC98    /* The same */
#define IDDATA_KBD_NEC98_106    2
#define IDDATA_KBD_JAPAN106     3
#define IDDATA_KBD_JAPANAX      4
#define IDDATA_KBD_J3100        5
#define IDDATA_KBD_PCENH        6
#define IDDATA_KBD_NEC98_NT     7
#define IDDATA_KBD_NEC98LAPTOP_NT IDDATA_KBD_NEC98_NT /* The same */
#define IDDATA_KBD_NEC98_106_NT 8

/*****************************************************************************
 *
 *  RCDATA
 *
 *  The mapping between HID usages
 *
 *  This lets us change them at the last minute without too much risk.
 *
 *  It also keeps them out of our image.
 *
 *****************************************************************************/

#define IDDATA_HIDMAP           9

/*****************************************************************************
 * Template for Generic Joystick Names
 *
 * Modified from MsJstick.
 *
 * Assigning a default name to A HID device, when there is none in the registry
 *
 * Note, string IDs for PLAIN_STICK, GAMEPAD, DRIVE_CTRL and FLIGHT_CTRL must 
 * stay contiguous and in order.
 *
 *****************************************************************************/


#define IDS_TEXT_TEMPLATE    0x0002000
#define IDS_PLAIN_STICK      0x0002001
#define IDS_GAMEPAD          0x0002002
#define IDS_DRIVE_CTRL       0x0002003
#define IDS_FLIGHT_CTRL      0x0002004
#define IDS_HEAD_TRACKER     0x0002005
#define IDS_DEVICE_NAME      0x0002006
#define IDS_WITH_POV         0x0002007

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dinputv.h ===
/*==========================================================================
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dinputv.h
 *  Content:    private DirectInput VxD include file
 *
 ***************************************************************************/

#ifndef __DINPUTV_INCLUDED__
#define __DINPUTV_INCLUDED__

/* XLATOFF */
#ifdef __cplusplus
extern "C" {
#endif
/* XLATON */



/****************************************************************************
 *
 *      DeviceIOCtl codes for DINPUT.VXD
 *
 *      IOCTL_FIRST is where DINPUT keeps its IOCTL codes.  Modify it
 *      if necessary to move DINPUT's IOCTLs to a new location.
 *
 *      All DINPUT IOCTLs are private between DINPUT.DLL and DINPUT.VXD.
 *      You can change them with impunity.
 *
 ***************************************************************************/

#define IOCTL_FIRST     0x0100

/* H2INCSWITCHES -t -f */

#if 0
/* Declare some types so h2inc will get them */
typedef LONG HWND;
typedef LONG DWORD;
#endif

/* Declare some more types for Win9x builds and h2inc */
#ifndef MAXULONG_PTR
typedef DWORD   ULONG_PTR;
typedef DWORD   *PULONG_PTR;
typedef DWORD   UINT_PTR;
typedef DWORD   *PULONG_PTR;
#endif //MAXULONG_PTR

/****************************************************************************
 *
 *      The shared portion of the VXDINSTANCE structure.
 *
 *      Instance "handles" are really pointers to a VXDINSTANCE structure.
 *
 ***************************************************************************/

typedef struct VXDINSTANCE {            /* vi */
    ULONG   fl;                         /* Flags */
    void *  pState;                     /* Instantaneous device state */
    DIDEVICEOBJECTDATA_DX3  *pBuffer;   /* Device object data buffer */
    DIDEVICEOBJECTDATA_DX3  *pEnd;      /* End of buffer */
    DIDEVICEOBJECTDATA_DX3  *pHead;     /* Where new data appears */
    DIDEVICEOBJECTDATA_DX3  *pTail;     /* Oldest object data */
    ULONG   fOverflow;                  /* Did the buffer overflow? */
                                        /* (exactly 0 or 1) */
    struct CDIDev *pdd;                 /* For misc communication */
    HWND hwnd;                          /* The cooperative window */
} VXDINSTANCE, *PVXDINSTANCE;

#define VIFL_CAPTURED_BIT   0
#define VIFL_CAPTURED       0x00000001  /* Device is captured (exclusive) */

#define VIFL_ACQUIRED_BIT   1
#define VIFL_ACQUIRED       0x00000002  /* Device is acquired */

#define VIFL_RELATIVE_BIT   2
#define VIFL_RELATIVE       0x00000004  /* Device wants relative data */

#define VIFL_EMULATED_BIT   3
#define VIFL_EMULATED       0x00000008  /* Device uses emulation */

#define VIFL_UNPLUGGED_BIT  4
#define VIFL_UNPLUGGED      0x00000010  /* Device is disconnected */

#define VIFL_NOWINKEY_BIT   5
#define VIFL_NOWINKEY       0x00000020  /* The Window Key are disabled */

#ifdef WANT_TO_FIX_MANBUG43879
  #define VIFL_FOREGROUND_BIT 7
  #define VIFL_FOREGROUND     0x00000080  /* Device is foreground */
#endif

#define VIFL_INITIALIZE_BIT 8
#define VIFL_INITIALIZE     0x00000100  /* This flag is set during the acquisition
                                           of a HID device so that we can get the
                                           initial device state successfully. */

/*
 *  The high word of fl contains device-specific flags.  They are
 *  currently used to record emulation information, and they aren't
 *  really device-specific because we have so few emulation flags.
 *
 *  The high word is just the emulation flags shifted upwards.
 */
#define DIGETEMFL(fl)       ((fl) >> 16)
#define DIMAKEEMFL(fl)      ((fl) << 16)

/****************************************************************************
 *
 *      System-defined IOCTL codes
 *
 ***************************************************************************/

#define IOCTL_GETVERSION        0x0000

/****************************************************************************
 *
 *      DINPUT-class IOCTLs
 *
 ***************************************************************************/

/*
 *  IN: None
 *
 *  OUT: None
 *
 *  The foreground window has lost activation.  Force all exclusively
 *  acquired devices to be unacquired.
 *
 *  This IOCTL is no longer used.  (Actually, it was never used.)
 *
 */
#define IOCTL_INPUTLOST         (IOCTL_FIRST + 0)


typedef struct VXDDEVICEFORMAT { /* devf */
    ULONG   cbData;             /* Size of device data */
    ULONG   cObj;               /* Number of objects in data format */
    DIOBJECTDATAFORMAT *rgodf;  /* Array of descriptions */
    ULONG_PTR   dwExtra;            /* Extra dword for private communication */
    DWORD   dwEmulation;        /* Flags controlling emulation */
} VXDDEVICEFORMAT, *PVXDDEVICEFORMAT;

/*
 *  IN: An instance handle that needs to be cleaned up.
 *
 *  OUT: None.
 *
 */
#define IOCTL_DESTROYINSTANCE   (IOCTL_FIRST + 1)

/*
 *  pDfOfs is an array of DWORDs.  Each entry corresponds to a byte in the
 *  device data format the meaning depends on the DLL client but it must 
 *  always be -1 if the client isn't tracking this object.  In DX7 and 
 *  before the value is the offset in the *client* data format which records 
 *  the data.  In DX8 the value is the device object index for the object 
 *  reporting at this device offset.
 *
 *  For example, for DX7, if the object at device offset 4 is to be reported 
 *  at client data offset 12, then pDfOfs[4] = 12.
 *
 *  For DX8, if the first two device objects are DWORD values then the object 
 *  at device offset 4 is the second object so pDfOfs[4] = 1.
 */
typedef struct VXDDATAFORMAT {  /* vdf */
    VXDINSTANCE *pvi;           /* Instance identifier */
    ULONG   cbData;             /* Size of device data */
    DWORD * pDfOfs;             /* Array of data format offsets */
} VXDDATAFORMAT, *PVXDDATAFORMAT;

/*
 *  IN: PVXDDATAFORMAT.
 *
 *  OUT: None
 *
 *  The application has changed the data format.  Notify the VxD so that
 *  data can be collected appropriately.
 *
 */
#define IOCTL_SETDATAFORMAT     (IOCTL_FIRST + 2)

/*
 *  IN: An instance handle to be acquired.
 *
 *  OUT: None.
 *
 */
#define IOCTL_ACQUIREINSTANCE   (IOCTL_FIRST + 3)

/*
 *  IN: An instance handle to be unacquired.
 *
 *  OUT: None.
 *
 */
#define IOCTL_UNACQUIREINSTANCE (IOCTL_FIRST + 4)

typedef struct VXDDWORDDATA {   /* vdd */
    VXDINSTANCE *pvi;           /* Instance identifier */
    ULONG   dw;                 /* Some dword */
} VXDDWORDDATA, *PVXDDWORDDATA;

/*
 *  IN: VXDDWORDDATA (dw = ring 0 handle)
 *
 *  OUT: None.
 *
 */
#define IOCTL_SETNOTIFYHANDLE   (IOCTL_FIRST + 5)

/*
 *  IN: VXDDWORDDATA (dw = buffer size)
 *
 *  OUT: None.
 *
 */
#define IOCTL_SETBUFFERSIZE     (IOCTL_FIRST + 6)

/****************************************************************************
 *
 *      Mouse class IOCTLs
 *
 ***************************************************************************/

/*
 *  IN: VXDDEVICEFORMAT (dwExtra = number of axes)
 *
 *  OUT: Instance handle
 */
#define IOCTL_MOUSE_CREATEINSTANCE (IOCTL_FIRST + 7)

/*
 *  IN: VXDDWORDDATA; dw is a BYTE[4] of initial mouse button states
 *
 *  OUT: None
 */
#define IOCTL_MOUSE_INITBUTTONS (IOCTL_FIRST + 8)

/****************************************************************************
 *
 *      Keyboard class IOCTLs
 *
 ***************************************************************************/

/*
 *  IN: VXDDEVICEFORMAT (dwExtra = keyboard type translation table)
 *
 *  OUT: Instance handle
 */
#define IOCTL_KBD_CREATEINSTANCE (IOCTL_FIRST + 9)

/*
 *  IN: VXDDWORDDATA; dw is a bitmask
 *      1 = KANA key is down, 2 = CAPITAL key is down
 *
 *  OUT: None
 */
#define IOCTL_KBD_INITKEYS       (IOCTL_FIRST + 10)

/****************************************************************************
 *
 *      Joystick class IOCTLs
 *
 ***************************************************************************/

/*
 *  IN: VXDDEVICEFORMAT (dwExtra = joystick id number)
 *
 *  OUT: Instance handle
 */
#define IOCTL_JOY_CREATEINSTANCE (IOCTL_FIRST + 11)

/*
 *  IN: An instance handle to be pinged
 *
 *  OUT: Instance handle
 */
#define IOCTL_JOY_PING           (IOCTL_FIRST + 12)

/*
 *  IN: DWORD external joystick ID
 *
 *  OUT: VXDINITPARMS containing goo we get from VJOYD.
 *
 */
typedef struct VXDINITPARMS {   /* vip */
    ULONG   hres;               /* result */
    ULONG   dwSize;             /* Which version of VJOYD are we? */
    ULONG   dwFlags;            /* Describes the device */
    ULONG   dwId;               /* Internal joystick ID */
    ULONG   dwFirmwareRevision;
    ULONG   dwHardwareRevision;
    ULONG   dwFFDriverVersion;
    ULONG   dwFilenameLengths;
    void *  pFilenameBuffer;
    DWORD   Usages[6];          /* X, Y, Z, R, U, V */
    DWORD   dwPOV0usage;
    DWORD   dwPOV1usage;
    DWORD   dwPOV2usage;
    DWORD   dwPOV3usage;
} VXDINITPARMS, *PVXDINITPARMS;

/*
 * Flags returned in VXDINITPARMS
 */
#define VIP_UNIT_ID             0x00000001L /* unit id is valid */
#define VIP_ISHID               0x00000002L /* This is a HID device */
#define VIP_SENDSNOTIFY         0x00000004L /* Driver will notify */

#define IOCTL_JOY_GETINITPARMS   (IOCTL_FIRST + 13)

/*
 *  IN: VXDFFIO describing FF I/O request
 *
 *      pvArgs points to an array of arguments.  We rely on several
 *      quirks of fate for this to work.
 *
 *      1.  STDCALL pushes arguments on the stack from right to left,
 *          so the address of the first argument can be used as a
 *          structure pointer.
 *
 *      2.  All the VJOYD interfaces pass arguments in registers.
 *
 *      3.  The registers used by VJOYD interfaces are always in the
 *          order eax, ecx, edx, esi, edi, matching the order in which
 *          the arguments are passed to IDirectInputEffectDriver.
 *
 *  OUT: HRESULT containing result code
 *
 */
/* XLATOFF */
#include <pshpack4.h>
/* XLATON */
typedef struct VXDFFIO { /* ffio */
    DWORD   dwIOCode;           /* I/O code */
    void *  pvArgs;             /* Array of arguments */
} VXDFFIO, *PVXDFFIO;
/* XLATOFF */
#include <poppack.h>
/* XLATON */

#define FFIO_ESCAPE             0
#define FFIO_SETGAIN            1
#define FFIO_SETFFSTATE         2
#define FFIO_GETFFSTATE         3
#define FFIO_DOWNLOADEFFECT     4
#define FFIO_DESTROYEFFECT      5
#define FFIO_STARTEFFECT        6
#define FFIO_STOPEFFECT         7
#define FFIO_GETEFFECTSTATUS    8
#define FFIO_MAX                9

#define IOCTL_JOY_FFIO           (IOCTL_FIRST + 14)

/****************************************************************************
 *
 *      Misc services
 *
 ***************************************************************************/

/*
 *  IN: Nothing
 *
 *  OUT: Pointer to dword sequence pointer
 */
#define IOCTL_GETSEQUENCEPTR    (IOCTL_FIRST + 15)

/****************************************************************************
 *
 *      Back to Joystick
 *
 ***************************************************************************/

/*
 *  Define these again, because NT doesn't have vjoyd
 *  and because vjoyd.inc doesn't define them.
 */
#define JOYPF_X             0x00000001
#define JOYPF_Y             0x00000002
#define JOYPF_Z             0x00000004
#define JOYPF_R             0x00000008
#define JOYPF_U             0x00000010
#define JOYPF_V             0x00000020
#define JOYPF_POV0          0x00000040
#define JOYPF_POV1          0x00000080
#define JOYPF_POV2          0x00000100
#define JOYPF_POV3          0x00000200
#define JOYPF_POV(n)        (JOYPF_POV0 << (n))
#define JOYPF_BTN0          0x00000400
#define JOYPF_BTN1          0x00000800
#define JOYPF_BTN2          0x00001000
#define JOYPF_BTN3          0x00002000
#define JOYPF_ALLAXES       0x0000003F
#define JOYPF_ALLCAPS       0x00003FFF

#define JOYPF_POSITION      0x00010000
#define JOYPF_VELOCITY      0x00020000
#define JOYPF_ACCELERATION  0x00040000
#define JOYPF_FORCE         0x00080000
#define JOYPF_ALLMODES      0x000F0000
#define JOYPF_NUMMODES      4

/*
 *  IN: DWORD external joystick ID
 *
 *  OUT: array of DWORDs listing which axes are valid where
 *
 */
typedef struct VXDAXISCAPS {    /* vac */
    DWORD   dwPos;              /* Axis positions */
    DWORD   dwVel;              /* Axis velocities */
    DWORD   dwAccel;            /* Axis accelerations */
    DWORD   dwForce;            /* Axis forces */
} VXDAXISCAPS, *PVXDAXISCAPS;

#define IOCTL_JOY_GETAXES       (IOCTL_FIRST + 16)

/****************************************************************************
 *
 *      Mouse random
 *
 ***************************************************************************/

/*
 *  IN: Nothing
 *
 *  OUT: Pointer to dword wheel granularity.
 */
#define IOCTL_MOUSE_GETWHEEL    (IOCTL_FIRST + 17)

/****************************************************************************
 *
 *      New IOCTLs for DX8, stuck on the end to improve chances of cross 
 *      version compatibility.
 *
 ***************************************************************************/

/*
 *  IN: Nothing
 *
 *  OUT: Nothing
 */
#define IOCTL_JOY_CONFIGCHANGED    (IOCTL_FIRST + 18)

/*
 *  IN: An instance handle to be pinged
 *
 *  OUT: Instance handle
 *
 *  This is used by the post dinput.dll versions of the DLL to avoid 
 *  unacquiring all instances of a device on a poll failure.
 */
#define IOCTL_JOY_PING8           (IOCTL_FIRST + 19)

/****************************************************************************
 *
 *      End of IOCTL table
 *
 ***************************************************************************/

#define IOCTL_MAX               (IOCTL_FIRST + 20)


/* XLATOFF */
#ifdef __cplusplus
};
#endif
/* XLATON */

#endif  /* __DINPUTV_INCLUDED__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diobj.c ===
/*****************************************************************************
 *
 *  DIObj.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      The IDirectInput main interface.
 *
 *  Contents:
 *
 *      CDIObj_New
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDi


#define DIDEVTYPE_DEVICE_ORDER            1
#define DIDEVTYPE_HID_MOUSE_ORDER         2
#define DIDEVTYPE_HID_KEYBOARD_ORDER      3
#define DIDEVTYPE_MOUSE_ORDER             4
#define DIDEVTYPE_KEYBOARD_ORDER          5
#define DIDEVTYPE_SUPPLEMENTAL_ORDER      6
#define MAX_ORDER                         (DI8DEVTYPE_MAX - DI8DEVTYPE_MIN + DIDEVTYPE_SUPPLEMENTAL_ORDER + 2)
#define INVALID_ORDER                     (MAX_ORDER + 1)

#define MAX_DEVICENUM                     32

DIORDERDEV g_DiDevices[MAX_DEVICENUM];  //all devices that are attached
int g_nCurDev;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct CDIObj |
 *
 *          The <i IDirectInput> object, from which other things come.
 *
 *          The A and W versions are simply alternate interfaces on the same
 *          underlying object.
 *
 *          There really isn't anything interesting in the structure
 *          itself.
 *
 *
 *  @field  IDirectInputA | diA |
 *
 *          ANSI DirectInput object (containing vtbl).
 *
 *  @field  IDirectInputW | diW |
 *
 *          UNICODE DirectInput object (containing vtbl).
 *
 *  @field  IDirectInputJoyConfig *| pdjc |
 *
 *          Aggregated joystick configuration interface (if created).
 *
 *  @field  BOOL | fCritInited:1 |
 *
 *          Set if the critical section has been initialized.
 *
 *  @field  CRITICAL_SECTION | crst |
 *
 *          Critical section that guards thread-sensitive data.
 *****************************************************************************/

typedef struct CDIObj
{

    /* Supported interfaces */
    TFORM(IDirectInput8)   TFORM(di);
    SFORM(IDirectInput8)   SFORM(di);

    DWORD dwVersion;

    IDirectInputJoyConfig *pdjc;

    BOOL fCritInited:1;

    CRITICAL_SECTION crst;

} CDIObj, DDI, *PDDI;

#define ThisClass CDIObj

    #define ThisInterface TFORM(IDirectInput8)
    #define ThisInterfaceA      IDirectInput8A
    #define ThisInterfaceW      IDirectInput8W
    #define ThisInterfaceT      IDirectInput8

/*****************************************************************************
 *
 *      Declare the interfaces we will be providing.
 *
 *****************************************************************************/

Primary_Interface(CDIObj, TFORM(ThisInterfaceT));
Secondary_Interface(CDIObj, SFORM(ThisInterfaceT));

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | QueryInterface |
 *
 *          Gives a client access to other interfaces on an object.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interface.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *  @xref   OLE documentation for <mf IUnknown::QueryInterface>.
 *
 *//**************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | AddRef |
 *
 *          Increments the reference count for the interface.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::AddRef>.
 *
 *****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | Release |
 *
 *          Decrements the reference count for the interface.
 *          If the reference count on the object falls to zero,
 *          the object is freed from memory.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @returns
 *
 *          Returns the object reference count.
 *
 *  @xref   OLE documentation for <mf IUnknown::Release>.
 *
 *****************************************************************************/

#ifdef DEBUG

Default_QueryInterface(CDIObj)
Default_AddRef(CDIObj)
Default_Release(CDIObj)

#else

    #define CDIObj_QueryInterface   Common_QueryInterface
    #define CDIObj_AddRef           Common_AddRef
    #define CDIObj_Release          Common_Release

#endif

#define CDIObj_AppFinalize      Common_AppFinalize

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc   void | CDIObj | EnterCrit |
 *
 *          Enter the object critical section.
 *
 *  @doc    INTERNAL
 *
 *  @mfunc   void | CDIObj | LeaveCrit |
 *
 *          Leave the object critical section.
 *
 *****************************************************************************/

void INLINE
CDIObj_EnterCrit(PDDI this)
{
    EnterCriticalSection(&this->crst);
}
void INLINE
CDIObj_LeaveCrit(PDDI this)
{
    LeaveCriticalSection(&this->crst);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | IDirectInput | QIHelper |
 *
 *          We will dynamically create <i IDirectInputJoyConfig>
 *          and aggregate it with us.
 *
 *  @parm   IN REFIID | riid |
 *
 *          The requested interface's IID.
 *
 *  @parm   OUT LPVOID * | ppvObj |
 *
 *          Receives a pointer to the obtained interfacethis->pdix[iobj].dwOfs.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_QIHelper(PDDI this, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcI(CDIObj_QIHelper, (_ "pG", this, riid));

    if ( IsEqualIID(riid, &IID_IDirectInputJoyConfig8) )
    {

        *ppvObj = 0;                /* In case the New fails */

        CDIObj_EnterCrit(this);
        if ( this->pdjc == 0 )
        {
            hres = CJoyCfg_New((PUNK)this, &IID_IUnknown, (PPV)&this->pdjc);
        } else
        {
            hres = S_OK;
        }
        CDIObj_LeaveCrit(this);

        if ( SUCCEEDED(hres) )
        {
            /*
             *  This QI will addref us if it succeeds.
             */
            hres = OLE_QueryInterface(this->pdjc, riid, ppvObj);
        } else
        {
            this->pdjc = 0;
        }

    } else
    {
        hres = Common_QIHelper(this, riid, ppvObj);
    }

    ExitOleProcPpv(ppvObj);
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIObj_Finalize |
 *
 *          Clean up our instance data.
 *
 *  @parm   PV | pvObj |
 *
 *          Object being released.  Note that it may not have been
 *          completely initialized, so everything should be done
 *          carefully.
 *
 *****************************************************************************/

void INTERNAL
CDIObj_Finalize(PV pvObj)
{
    PDDI this = pvObj;

    Invoke_Release(&this->pdjc);

    if ( this->fCritInited )
    {
        DeleteCriticalSection(&this->crst);
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInput | CreateDeviceHelper |
 *
 *          Creates and initializes an instance of a device which is
 *          specified by the GUID and IID.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          See <mf IDirectInput::CreateDevice>.
 *
 *  @parm   OUT PPV | ppvObj |
 *
 *          See <mf IDirectInput::CreateDevice>.
 *
 *  @parm   IN LPUNKNOWN | punkOuter |
 *
 *          See <mf IDirectInput::CreateDevice>.
 *
 *  @parm   IN RIID | riid |
 *
 *          The interface the application wants to create.  This will
 *          be either <i IDirectInputDeviceA> or <i IDirectInputDeviceW>.
 *          If the object is aggregated, then this parameter is ignored.
 *
 *  @returns
 *
 *          Returns a COM error code.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_CreateDeviceHelper(PDDI this, PCGUID pguid, PPV ppvObj,
                          PUNK punkOuter, RIID riid)
{
    HRESULT hres;
    EnterProc(CDIObj_CreateDeviceHelper,
              (_ "pGxG", this, pguid, punkOuter, riid));

    /*
     *  CDIDev_New will validate the punkOuter and ppvObj.
     *
     *  IDirectInputDevice_Initialize will validate the pguid.
     *
     *  riid is known good (since it came from CDIObj_CreateDeviceW
     *  or CDIObj_CreateDeviceA).
     */

    hres = CDIDev_New(punkOuter, punkOuter ? &IID_IUnknown : riid, ppvObj);

    if ( SUCCEEDED(hres) && punkOuter == 0 )
    {
        PDID pdid = *ppvObj;
        hres = IDirectInputDevice_Initialize(pdid, g_hinst,
                                             this->dwVersion, pguid);
        if ( SUCCEEDED(hres) )
        {
        } else
        {
            Invoke_Release(ppvObj);
        }

    }

    ExitOleProcPpv(ppvObj);
    return(hres);

}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | CreateDevice |
 *
 *          Creates and initializes an instance of a device which is
 *          specified by the GUID and IID.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   REFGUID | rguid |
 *          Identifies the instance of the
 *          device for which the indicated interface
 *          is requested.  The <mf IDirectInput::EnumDevices> method
 *          can be used to determine which instance GUIDs are supported by
 *          the system.
 *
 *  @parm   OUT LPDIRECTINPUTDEVICE * | lplpDirectInputDevice |
 *          Points to where to return
 *          the pointer to the <i IDirectInputDevice> interface, if successful.
 *
 *  @parm   IN LPUNKNOWN | punkOuter | Pointer to controlling unknown
 *          for OLE aggregation, or 0 if the interface is not aggregated.
 *          Most callers will pass 0.
 *
 *  @comm   Calling this function with <p punkOuter> = NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInputDevice, NULL,
 *          CLSCTX_INPROC_SERVER, <p riid>, <p lplpDirectInputDevice>);
 *          then initializing it with <f Initialize>.
 *
 *          Calling this function with <p punkOuter> != NULL
 *          is equivalent to creating the object via
 *          <f CoCreateInstance>(&CLSID_DirectInputDevice, <p punkOuter>,
 *          CLSCTX_INPROC_SERVER, &IID_IUnknown, <p lplpDirectInputDevice>).
 *          The aggregated object must be initialized manually.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p ppvOut> parameter is not a valid pointer.
 *
 *          <c DIERR_OUTOFMEMORY> = <c E_OUTOFMEMORY>:
 *          Out of memory.
 *
 *          <c DIERR_NOINTERFACE> = <c E_NOINTERFACE>
 *          The specified interface is not supported by the object.
 *
 *          <c DIERR_DEVICENOTREG> = The device instance does not
 *          correspond to a device that is registered with DirectInput.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_CreateDeviceW(PV pdiW, REFGUID rguid, PPDIDW ppdidW, PUNK punkOuter)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::CreateDevice,
               (_ "pGp", pdiW, rguid, punkOuter));

    if ( SUCCEEDED(hres = hresPvI(pdiW, ThisInterfaceW)) )
    {
        PDDI this = _thisPvNm(pdiW, diW);

        hres = CDIObj_CreateDeviceHelper(this, rguid, (PPV)ppdidW,
                                         punkOuter, &IID_IDirectInputDevice8W);
    }

    ExitOleProcPpv(ppdidW);
    return(hres);
}

STDMETHODIMP
CDIObj_CreateDeviceA(PV pdiA, REFGUID rguid, PPDIDA ppdidA, PUNK punkOuter)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::CreateDevice,
               (_ "pGp", pdiA, rguid, punkOuter));

    if ( SUCCEEDED(hres = hresPvI(pdiA, ThisInterfaceA)) )
    {
        PDDI this = _thisPvNm(pdiA, diA);

        hres = CDIObj_CreateDeviceHelper(this, rguid, (PPV)ppdidA,
                                         punkOuter, &IID_IDirectInputDevice8A);
    }

    ExitOleProcPpv(ppdidA);
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIObj_TestDeviceFlags |
 *
 *          Determines whether the device matches the specified flags.
 *          Phantom devices are treated as not really there.
 *
 *  @parm   PDIDW | pdidW |
 *
 *          Device to be queried.
 *
 *  @parm   DWORD | edfl |
 *
 *          Enumeration flags.  It is one or more <c DIEDFL_*> values.
 *
 *          The bits in the enumeration flags are in two categories.*
 *
 *          Normal flags are the ones whose presence requires that
 *          the corresponding bit in the device flags also be set.
 *
 *          Inverted flags (<c DIEDFL_INCLUDEMASK>) are the ones whose
 *          absence requires that the corresponding bit in the device
 *          flags also be absent.
 *
 *          By inverting the inclusion flags in both the enumeration
 *          flags and the actual device flags, and then treating the
 *          whole thing as a bunch of normal flags, we get the desired
 *          behavior for the inclusion flags.
 *
 *  @returns
 *
 *          <c S_OK> if the device meets the criteria.
 *
 *          <c S_FALSE> if the device does not meet the criteria.
 *          Note that <mf DirectInput::GetDeviceStatus> relies on
 *          this specific return value.
 *
 *          Other error code as appropriate.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CDIObj_TestDeviceFlags(PDIDW pdidW, DWORD edfl)
{
    HRESULT hres;
    DIDEVCAPS_DX3 dc;
    EnterProcI(CDIObj_TestDeviceFlags, (_ "px", pdidW, edfl));

    /*
     *  We intentionally use a DIDEVCAPS_DX3 because going for
     *  a full DIDEVCAPS_DX5 requires us to load the force
     *  feedback driver which is pointless for our current
     *  goal.
     */
    dc.dwSize = cbX(dc);

    hres = IDirectInputDevice_GetCapabilities(pdidW, (PV)&dc);

    AssertF(dc.dwSize == cbX(dc));

    CAssertF(DIEDFL_ATTACHEDONLY == DIDC_ATTACHED);
    CAssertF(DIEDFL_FORCEFEEDBACK == DIDC_FORCEFEEDBACK);
    CAssertF(DIEDFL_INCLUDEALIASES == DIDC_ALIAS);
    CAssertF(DIEDFL_INCLUDEPHANTOMS == DIDC_PHANTOM);
    CAssertF(DIEDFL_INCLUDEHIDDEN == DIDC_HIDDEN);

    if ( SUCCEEDED(hres) )
    {
        if ( fHasAllBitsFlFl(dc.dwFlags ^ DIEDFL_INCLUDEMASK,
                             edfl ^ DIEDFL_INCLUDEMASK) )
        {
            hres = S_OK;
        } else
        {
            /*
             *  Note: DX3 and DX5 returned E_DEVICENOTREG for
             *  phantom devices.  Now we return S_FALSE. Let's
             *  hope nobody gets upset.
             */
            hres = S_FALSE;
        }
    }

    ExitOleProc();
    return(hres);
}


/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | EnumDevices |
 *
 *          Enumerates the DirectInput devices that are attached to
 *          or could be attached to the computer.
 *
 *          For example, an external game port may support a joystick
 *          or a steering wheel, but only one can be plugged in at a
 *          time.  <mf IDirectInput::EnumDevices> will enumerate both
 *          devices.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   DWORD | dwDevType |
 *
 *          Device type filter.  If 0, then all device types are
 *          enumerated.  Otherwise, it is either a <c DIDEVCLASS_*> value,
 *          indicating the device class that should be enumerated or a
 *          <c DIDEVTYPE_*> value, indicating the device type that should be 
 *          enumerated.
 *
 *  @parm   LPDIENUMDEVICESCALLBACK | lpCallback |
 *          Points to an application-defined callback function.
 *          For more information, see the description of the
 *          <f DIEnumDevicesProc> callback function.
 *
 *  @parm   IN LPVOID | pvRef |
 *          Specifies a 32-bit application-defined
 *          value to be passed to the callback function.  This value
 *          may be any 32-bit value; it is prototyped as an <t LPVOID>
 *          for convenience.
 *
 *  @parm   DWORD | fl |
 *          Optional flags which control the enumeration.  The
 *          following flags are defined and may be combined.
 *
 *          <c DIEDFL_ATTACHEDONLY>: Enumerate only attached devices.
 *
 *          <c DIEDFL_FORCEFEEDBACK>: Enumerate only devices which
 *          support force feedback.  This flag is new for DirectX 5.0.
 *
 *          <c DIEDFL_INCLUDEALIASES>: Include alias devices in the
 *          enumeration.  If this flag is not specified, then devices
 *          which are aliases of other devices (indicated by the
 *          <c DIDC_ALIAS> flag in the <e DIDEVCAPS.dwFlags> field
 *          of the <t DIDEVCAPS> structure) will be excluded from
 *          the enumeration.  This flag is new for DirectX 5.0a.
 *
 *          <c DIEDFL_INCLUDEPHANTOMS>: Include phantom devices in the
 *          enumeration.  If this flag is not specified, then devices
 *          which are phantoms (indicated by the
 *          <c DIDC_PHANTOM> flag in the <e DIDEVCAPS.dwFlags> field
 *          of the <t DIDEVCAPS> structure) will be excluded from
 *          the enumeration.  This flag is new for DirectX 5.0a.
 *
 *          The default is
 *          <c DIEDFL_ALLDEVICES>: Enumerate all installed devices.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          Note that if the callback stops the enumeration prematurely,
 *          the enumeration is considered to have succeeded.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p fl> parameter contains invalid flags, or the callback
 *          procedure returned an invalid status code.
 *
 *  @cb     BOOL CALLBACK | DIEnumDevicesProc |
 *
 *          An application-defined callback function that receives
 *          DirectInput devices as a result of a call to the
 *          <om IDirectInput::EnumDevices> method.
 *
 *  @parm   IN LPDIDEVICEINSTANCE | lpddi |
 *
 *          Structure that describes the device instance.
 *
 *
 *  @parm   IN OUT LPVOID | pvRef |
 *          Specifies the application-defined value given in the
 *          <mf IDirectInput::EnumDevices> function.
 *
 *  @returns
 *
 *          Returns <c DIENUM_CONTINUE> to continue the enumeration
 *          or <c DIENUM_STOP> to stop the enumeration.
 *
 *//**************************************************************************
 *
 *      In DEBUG/RDEBUG, if the callback returns a bogus value, raise
 *      a validation exception.
 *
 *****************************************************************************/

HRESULT INLINE
CDIObj_EnumDevices_IsValidTypeFilter(DWORD dwDevType)
{
    HRESULT hres;

    /*
     *  First make sure the type mask is okay.
     */
    if( ( GET_DIDEVICE_TYPE( dwDevType ) < DI8DEVCLASS_MAX )
     || ( ( GET_DIDEVICE_TYPE( dwDevType ) >= DI8DEVTYPE_MIN )
       && ( GET_DIDEVICE_TYPE( dwDevType ) < DI8DEVTYPE_MAX ) ) )
    {
        /*
         *  Now make sure attribute masks are okay.
         */
        if ( dwDevType & DIDEVTYPE_ENUMMASK & ~DIDEVTYPE_ENUMVALID )
        {
            RPF("IDirectInput::EnumDevices: Invalid dwDevType");
            hres = E_INVALIDARG;
        } else
        {
            hres = S_OK;
        }

    } else
    {
        RPF("IDirectInput::EnumDevices: Invalid dwDevType");
        hres = E_INVALIDARG;
    }
    return(hres);
}

STDMETHODIMP
CDIObj_EnumDevicesW(PV pdiW, DWORD dwDevType,
                    LPDIENUMDEVICESCALLBACKW pec, LPVOID pvRef, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::EnumDevices,
               (_ "pxppx", pdiW, dwDevType, pec, pvRef, fl));

    if ( SUCCEEDED(hres = hresPvI(pdiW, ThisInterfaceW)) &&
         SUCCEEDED(hres = hresFullValidPfn(pec, 2)) &&
         SUCCEEDED(hres = CDIObj_EnumDevices_IsValidTypeFilter(dwDevType)) &&
         SUCCEEDED(hres = hresFullValidFl(fl, DIEDFL_VALID, 4)) )
    {
        PDDI this = _thisPvNm(pdiW, diW);

        if ( SUCCEEDED(hres = hresValidInstanceVer(g_hinst, this->dwVersion)) )
        {

            CDIDEnum *pde;

            hres = CDIDEnum_New(&this->diW, dwDevType, fl, this->dwVersion, &pde);
            if ( SUCCEEDED(hres) )
            {
                DIDEVICEINSTANCEW ddiW;
                ddiW.dwSize = cbX(ddiW);

                while ( (hres = CDIDEnum_Next(pde, &ddiW)) == S_OK )
                {
                    BOOL fRc;

                    /*
                     *  WARNING!  "goto" here!  Make sure that nothing
                     *  is held while we call the callback.
                     */
                    fRc = Callback(pec, &ddiW, pvRef);

                    switch ( fRc )
                    {
                        case DIENUM_STOP: goto enumdoneok;
                        case DIENUM_CONTINUE: break;
                        default:
                            RPF("%s: Invalid return value from callback", s_szProc);
                            ValidationException();
                            break;
                    }
                }

                AssertF(hres == S_FALSE);
                enumdoneok:;
                CDIDEnum_Release(pde);

                hres = S_OK;
            }
        }
    }

    ExitOleProcR();
    return(hres);
}


BOOL INTERNAL CDIObj_InternalDeviceEnumProcW(LPDIDEVICEINSTANCEW pddiW, LPDIRECTINPUTDEVICE8W pdid8W, LPVOID pv);


STDMETHODIMP
CDIObj_InternalEnumDevicesW(PV pdiW, DWORD dwDevType, LPVOID pvRef, DWORD fl)
{
    HRESULT hres;
    CDIDEnum *pde;
        
    PDDI this = _thisPvNm(pdiW, diW);

    hres = CDIDEnum_New(&this->diW, dwDevType, fl, this->dwVersion, &pde);
    if ( SUCCEEDED(hres) )
    {
        DIDEVICEINSTANCEW ddiW;
        LPDIRECTINPUTDEVICE8W pdid8W;

        ddiW.dwSize = cbX(ddiW);

        while ( (hres = CDIDEnum_InternalNext(pde, &ddiW, &pdid8W)) == S_OK )
        {
            BOOL fRc;

            fRc = CDIObj_InternalDeviceEnumProcW(&ddiW, pdid8W, pvRef);

            switch ( fRc )
            {
                case DIENUM_STOP: goto enumdoneok;
                case DIENUM_CONTINUE: break;
                default:
                    ValidationException();
                    break;
            }
        }

        AssertF(hres == S_FALSE);
        enumdoneok:;
        CDIDEnum_Release(pde);

        hres = S_OK;
    }

    return(hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIObj_EnumDevicesCallbackA |
 *
 *          Wrapper function for <mf IDirectInput::EnumDevices>
 *          which translates the UNICODE parameters to ANSI.
 *
 *  @parm   IN LPCDIDECICEINSTANCEW | pdiW |
 *
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *  @parm   IN OUT PV | pvRef |
 *
 *          Pointer to <t struct ENUMDEVICESINFO> which describes
 *          the original callback.
 *
 *  @returns
 *
 *          Returns whatever the original callback returned.
 *
 *****************************************************************************/

typedef struct ENUMDEVICESINFO
{
    LPDIENUMDEVICESCALLBACKA pecA;
    PV pvRef;
} ENUMDEVICESINFO, *PENUMDEVICESINFO;

BOOL CALLBACK
CDIObj_EnumDevicesCallback(LPCDIDEVICEINSTANCEW pdiW, PV pvRef)
{
    PENUMDEVICESINFO pedi = pvRef;
    BOOL fRc;
    DIDEVICEINSTANCEA diA;
    EnterProc(CDIObj_EnumDevicesCallback,
              (_ "GGxWWp", &pdiW->guidInstance, &pdiW->guidProduct,
               &pdiW->dwDevType,
               pdiW->tszProductName, pdiW->tszInstanceName,
               pvRef));

    diA.dwSize = cbX(diA);
    DeviceInfoWToA(&diA, pdiW);

    fRc = pedi->pecA(&diA, pedi->pvRef);

    ExitProcX(fRc);
    return(fRc);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @method HRESULT | IDirectInputA | EnumDevices |
 *
 *          ANSI version of <mf IDirectInput::EnumDevices>.
 *          We wrap the operation.
 *
 *  @parm   IN LPGUID | lpGUIDDeviceType |
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *  @parm   LPDIENUMDEVICESCALLBACKA | lpCallbackA |
 *          Same as <mf IDirectInput::EnumDevices>, except ANSI.
 *
 *  @parm   IN LPVOID | pvRef |
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *  @parm   DWORD | fl |
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_EnumDevicesA(PV pdiA, DWORD dwDevType,
                    LPDIENUMDEVICESCALLBACKA pec, LPVOID pvRef, DWORD fl)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::EnumDevices,
               (_ "pxppx", pdiA, dwDevType, pec, pvRef, fl));

    /*
     *  EnumDevicesW will validate the rest.
     */
    if ( SUCCEEDED(hres = hresPvI(pdiA, ThisInterfaceA)) &&
         SUCCEEDED(hres = hresFullValidPfn(pec, 1)) )
    {
        ENUMDEVICESINFO edi = { pec, pvRef};
        PDDI this = _thisPvNm(pdiA, diA);
        hres = CDIObj_EnumDevicesW(&this->diW, dwDevType,
                                   CDIObj_EnumDevicesCallback, &edi, fl);
    }

    ExitOleProcR();
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | GetDeviceStatus |
 *
 *          Determine whether a device is currently attached.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   REFGUID | rguid |
 *
 *          Identifies the instance of the
 *          device whose status is being checked.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *          <c DI_NOTATTACHED> = <c S_FALSE>: The device is not
 *          attached.
 *
 *          <c E_FAIL>: DirectInput could not determine
 *          whether the device is attached.
 *
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          device does not exist.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_GetDeviceStatus(PV pdi, REFGUID rguid _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::GetDeviceStatus, (_ "pG", pdi, rguid));

    if ( SUCCEEDED(hres = hresPvT(pdi)) )
    {
        PDDI this = _thisPv(pdi);
        PDIDW pdidW;

        hres = IDirectInput_CreateDevice(&this->diW, rguid, (PV)&pdidW, 0);
        if ( SUCCEEDED(hres) )
        {
            hres = CDIObj_TestDeviceFlags(pdidW, DIEDFL_ATTACHEDONLY);
            OLE_Release(pdidW);
        }
    }

    ExitOleProc();
    return(hres);
}

#ifdef XDEBUG

CSET_STUBS(GetDeviceStatus, (PV pdi, REFGUID rguid), (pdi, rguid THAT_))

#else

    #define CDIObj_GetDeviceStatusA         CDIObj_GetDeviceStatus
    #define CDIObj_GetDeviceStatusW         CDIObj_GetDeviceStatus

#endif

#ifdef DO_THE_IMPOSSIBLE

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | SetAttachedDevice |
 *
 *          Informs DirectInput that a new device has been attached
 *          to the system by the user.  This is useful when an application
 *          asks the user to attach a currently installed device but does
 *          not want to launch the DirectInput control panel.
 *
 *          DirectInput needs to be informed that the device has
 *          been attached for internal bookkeeping purposes.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN LPDIRECTINPUTDEVICE | lpDIDevice |
 *
 *          Identifies the device which has been attached.
 *
 *  @returns
 *
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *  @devnote
 *
 *          This method is not implemented in the current release
 *          of DirectInput.
 *
 *          This won't work.  We need to receive a port, too.
 *          And how can the app create a <p lpDIDevice> in the
 *          first place for a device that does not exist?
 *          I guess I just don't understand.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_SetAttachedDevice(PV pdi, PV pdid _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::SetAttachedDevice, (_ "pp", pdi, pdid));

    if ( SUCCEEDED(hres = hresPvT(pdi)) )
    {
        PDDI this = _thisPv(pdi);

        hres = E_NOTIMPL;
    }

    ExitOleProc();
    return(hres);
}

    #ifdef XDEBUG

CSET_STUBS(SetAttachedDevice, (PV pdi, PV pdid), (pdi, pdid THAT_))

    #else

        #define CDIObj_SetAttachedDeviceA       CDIObj_SetAttachedDevice
        #define CDIObj_SetAttachedDeviceW       CDIObj_SetAttachedDevice

    #endif

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | RunControlPanel |
 *
 *          Run the DirectInput control panel so that the user can
 *          install a new input device or modify the setup.
 *
 *          This function will not run third-party control panels.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN HWND | hwndOwner |
 *
 *          Identifies the window handle that will be used as the
 *          parent window for subsequent UI.  NULL is a valid parameter,
 *          indicating that there is no parent window.
 *
 *  @parm   DWORD | dwFlags |
 *
 *          No flags are currently defined.  This parameter "must" be
 *          zero.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *  @devnote
 *
 *          The <p dwFlags> is eventually going to allow
 *          <c DIRCP_MODAL> to request a modal control panel.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

STDMETHODIMP
CDIObj_RunControlPanel(PV pdi, HWND hwndOwner, DWORD fl _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::RunControlPanel, (_ "pxx", pdi, hwndOwner, fl));

    if ( SUCCEEDED(hres = hresPvT(pdi)) &&
         SUCCEEDED(hres = hresFullValidHwnd0(hwndOwner, 1)) &&
         SUCCEEDED(hres = hresFullValidFl(fl, DIRCP_VALID, 2)) )
    {

        PDDI this = _thisPv(pdi);

        if ( SUCCEEDED(hres = hresValidInstanceVer(g_hinst, this->dwVersion)) )
        {

            /*
             *  We used to run "directx.cpl,@0,3" but directx.cpl is not
             *  redistributable; it comes only with the SDK.  So we just
             *  run the system control panel.
             */

            hres = hresRunControlPanel(TEXT(""));
        }
    }

    ExitOleProc();
    return(hres);
}

#ifdef XDEBUG

CSET_STUBS(RunControlPanel, (PV pdi, HWND hwndOwner, DWORD fl),
           (pdi, hwndOwner, fl THAT_))

#else

    #define CDIObj_RunControlPanelA         CDIObj_RunControlPanel
    #define CDIObj_RunControlPanelW         CDIObj_RunControlPanel

#endif

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | Initialize |
 *
 *          Initialize a DirectInput object.
 *
 *          The <f DirectInputCreate> method automatically
 *          initializes the DirectInput object device after creating it.
 *          Applications normally do not need to call this function.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Instance handle of the application or DLL that is creating
 *          the DirectInput object.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version number of the dinput.h header file that was used.
 *
 *          See the section titled "Initialization and Versions"
 *          for more information.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device is attached.
 *
 *          <c DIERR_DIERR_OLDDIRECTINPUTVERSION>: The application
 *          requires a newer version of DirectInput.
 *
 *          <c DIERR_DIERR_BETADIRECTINPUTVERSION>: The application
 *          was written for an unsupported prerelease version
 *          of DirectInput.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_Initialize(PV pdi, HINSTANCE hinst, DWORD dwVersion _THAT)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::Initialize, (_ "pxx", pdi, hinst, dwVersion));

    if ( SUCCEEDED(hres = hresPvT(pdi)) )
    {
        PDDI this = _thisPv(pdi);

        if ( SUCCEEDED(hres = hresValidInstanceVer(hinst, dwVersion)) )
        {
            this->dwVersion = dwVersion;
        }

    }

#ifndef DX_FINAL_RELEASE
{
        #pragma message("BETA EXPIRATION TIME BOMB!  Remove for final build!")
        SYSTEMTIME st;
        GetSystemTime(&st);

        if ( st.wYear > DX_EXPIRE_YEAR ||
             ((st.wYear == DX_EXPIRE_YEAR) && (MAKELONG(st.wDay, st.wMonth) > MAKELONG(DX_EXPIRE_DAY, DX_EXPIRE_MONTH)))
        ) {
            MessageBox(0, DX_EXPIRE_TEXT,
                          TEXT("Microsoft DirectInput"), MB_OK);
        }
}
#endif

    ExitOleProc();
    return(hres);
}

#ifdef XDEBUG

CSET_STUBS(Initialize, (PV pdi, HINSTANCE hinst, DWORD dwVersion),
           (pdi, hinst, dwVersion THAT_))

#else

    #define CDIObj_InitializeA              CDIObj_Initialize
    #define CDIObj_InitializeW              CDIObj_Initialize

#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIObj_FindDeviceInternal |
 *
 *          The worker function for
 *          <mf IDirectInput2::FindDevice> which works only for HID devices.
 *
 *          For more details, see <mf IDirectInput2::FindDevice>.
 *
 *  @parm   LPCTSTR | ptszName |
 *
 *          The name of the device relative to the class <t GUID>.
 *
 *  @parm   OUT LPGUID | pguidOut |
 *
 *          Pointer to a <t GUID> which receives the instance
 *          <t GUID> for the device, if the device is found.
 *
 *****************************************************************************/

HRESULT EXTERNAL
CDIObj_FindDeviceInternal(LPCTSTR ptszName, LPGUID pguidOut)
{
    HRESULT hres;

    /*
     *  Look twice.  If it's not found the first time,
     *  then refresh the cache and try again in case
     *  it was for a device that was recently added.
     *  (In fact, it will likely be a device that was
     *  recently added, because FindDevice is usually
     *  called in response to a Plug and Play event.)
     */
    hres = hresFindHIDDeviceInterface(ptszName, pguidOut);
    if ( FAILED(hres) )
    {
        DIHid_BuildHidList(TRUE);
        hres = hresFindHIDDeviceInterface(ptszName, pguidOut);
    }
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput2 | FindDevice |
 *
 *          Obtain the instance <t GUID> for a device given
 *          its class <t GUID> and an opaque name.
 *
 *          This method can be used by applications which register
 *          for Plug and Play notifications and are notified by
 *          Plug and Play that a new device has been added
 *          to the system.  The Plug and Play notification will
 *          be in the form of a class <t GUID> and a device name.
 *          The application can pass the <t GUID> and name to
 *          this method to obtain the instance <t GUID> for
 *          the device, which can then be passed to
 *          <mf IDirectInput::CreateDevice> or
 *          <mf IDirectInput::GetDeviceStatus>.
 *
 *  @cwrap  LPDIRECTINPUT2 | lpDirectInput2
 *
 *  @parm   REFGUID | rguidClass |
 *
 *          Class <t GUID> identifying the device class
 *          for the device the application wishes to locate.
 *
 *          The application obtains the class <t GUID> from the
 *          Plug and Play device arrival notification.
 *
 *  @parm   LPCTSTR | ptszName |
 *
 *          The name of the device relative to the class <t GUID>.
 *
 *          The application obtains the class name from the
 *          Plug and Play device arrival notification.
 *
 *  @parm   OUT LPGUID | pguidInstance |
 *
 *          Pointer to a <t GUID> which receives the instance
 *          <t GUID> for the device, if the device is found.
 *
 *  @returns
 *          Returns a COM error code.  The following error codes are
 *          intended to be illustrative and not necessarily comprehensive.
 *
 *          <c DI_OK> = <c S_OK>: The device was found, and its
 *          instance <t GUID> has been stored in <p pguidInstance>.
 *
 *          <c DIERR_DEVICENOTREG> = The <t GUID> and name do not
 *          correspond to a device that is registered with DirectInput.
 *          For example, they may refer to a storage device rather
 *          than an input device.
 *
 *****************************************************************************/

    #define cchNameMax      MAX_PATH

STDMETHODIMP
TFORM(CDIObj_FindDevice)(PV pdiT, REFGUID rguid,
                         LPCTSTR ptszName, LPGUID pguidOut)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::FindDevice,
               (_ "pGs", pdiT, rguid, ptszName));

    if ( SUCCEEDED(hres = TFORM(hresPv)(pdiT)) &&
         SUCCEEDED(hres = hresFullValidGuid(rguid, 1)) &&
         SUCCEEDED(hres = TFORM(hresFullValidReadStr)(ptszName,
                                                      cchNameMax, 2)) &&
         SUCCEEDED(hres = hresFullValidWritePvCb(pguidOut, cbX(GUID), 3)) )
    {

        if ( IsEqualIID(rguid, &GUID_HIDClass) )
        {
            hres = CDIObj_FindDeviceInternal(ptszName, pguidOut);
        } else
        {
            hres = DIERR_DEVICENOTREG;
        }
    }

    ExitOleProc();
    return(hres);
}

STDMETHODIMP
SFORM(CDIObj_FindDevice)(PV pdiS, REFGUID rguid,
                         LPCSSTR psszName, LPGUID pguidOut)
{
    HRESULT hres;
    TCHAR tsz[cchNameMax];
    EnterProcR(IDirectInput8::FindDevice,
               (_ "pGS", pdiS, rguid, psszName));

    /*
     *  TFORM(CDIObj_FindDevice) will validate the rguid and pguidOut.
     */
    if ( SUCCEEDED(hres = SFORM(hresPv)(pdiS)) &&
         SUCCEEDED(hres = SFORM(hresFullValidReadStr)(psszName, cA(tsz), 2)) )
    {
        PDDI this = _thisPvNm(pdiS, SFORM(di));

        SToT(tsz, cA(tsz), psszName);

        hres = TFORM(CDIObj_FindDevice)(&this->TFORM(di), rguid, tsz, pguidOut);
    }

    ExitOleProc();
    return(hres);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @mfunc  HRESULT | IDirectInput | New |
 *
 *          Create a new instance of an IDirectInput object.
 *
 *  @parm   IN PUNK | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   IN RIID | riid |
 *          Desired interface to new object.
 *
 *  @parm   OUT PPV | ppvObj |
 *          Output pointer for new object.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
CDIObj_New(PUNK punkOuter, RIID riid, PPV ppvObj)
{
    HRESULT hres;
    EnterProcR(IDirectInput8::CreateInstance, (_ "Gp", riid, ppvObj));

    hres = Excl_Init();
    
    if ( SUCCEEDED(hres) )
    {

        /*
         *  Note that we cannot use Common_NewRiid for an object
         *  that aggregates other interfaces!
         *
         *  The reason is that Common_NewRiid will perform
         *  a QI as part of the initialization, but we cannot handle
         *  the QI until after we've been initialized and are
         *  ready to mess with aggregated goo.
         */

        if ( SUCCEEDED(hres = hresFullValidRiid(riid, 2)) )
        {
            if ( fLimpFF(punkOuter, IsEqualIID(riid, &IID_IUnknown)) )
            {

                hres = Common_New(CDIObj, punkOuter, ppvObj);

                if ( SUCCEEDED(hres) )
                {
                    PDDI this = _thisPv(*ppvObj);
                    
                    this->fCritInited = fInitializeCriticalSection(&this->crst);
                    if ( this->fCritInited )
                    {
                        /*
                         *  Only after the object is ready do we QI for the
                         *  requested interface.  And the reason is that the
                         *  QI might cause us to create an aggregated buddy,
                         *  which we can't do until we've been initialized.
                         *
                         *  Don't do this extra QI if we are ourselves aggregated,
                         *  or we will end up giving the wrong punk to the caller!
                         */
                        if ( punkOuter == 0 )
                        {
                            hres = OLE_QueryInterface(this, riid, ppvObj);
                            OLE_Release(this);
                        }
                        if ( FAILED(hres) )
                        {
                            Invoke_Release(ppvObj);
                        }
                    } else
                    {
                        Common_Unhold(this);
                        *ppvObj = NULL;
                        hres = E_OUTOFMEMORY;
                    }
                }
            } else
            {
                RPF("CreateDevice: IID must be IID_IUnknown if created for aggregation");
                *ppvObj = 0;
                hres = CLASS_E_NOAGGREGATION;
            }
        }
    }

    ExitOleProcPpvR(ppvObj);
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIObj_IsDeviceUsedByUser |
 *
 *          To Test whether the device is used by the user as specified by pdm->lpszUserName.
 *
 *  @parm   IN LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Device Instance.
 *
 *  @parm   IN LPDIMAPPER | pdm |
 *
 *          pointer to DIMAPPER structure
 *
 *  @returns
 *
 *          TRUE: device is used by the user
 *          FALSE: otherwise
 *
 *****************************************************************************/

BOOL INTERNAL
CDIObj_IsDeviceUsedByUser( LPDIDEVICEINSTANCEW pddiW, LPDIMAPPER pdm )
{
    HRESULT hres;
    BOOL fRtn = FALSE;
    WCHAR wszUserName[UNLEN+1];

    hres = CMap_GetDeviceUserName( &pddiW->guidInstance, wszUserName );

    if( hres == S_OK ) {
        DWORD dwLen = 0;

        dwLen = lstrlenW(pdm->lpszUserName);
        if(memcmp(pdm->lpszUserName, wszUserName, dwLen*2) == 0)
        {
            fRtn = TRUE;
        }    
    }

    return(fRtn);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIObj_IsDeviceAvailable |
 *
 *          To Test whether the device is still available.
 *
 *  @parm   IN LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Device Instance.
 *
 *  @parm   IN LPDIMAPPER | pdm |
 *
 *          pointer to DIMAPPER structure
 *
 *  @returns
 *
 *          TRUE: device is available
 *          FALSE: not available
 *
 *****************************************************************************/

BOOL INTERNAL
CDIObj_IsDeviceAvailable( LPDIDEVICEINSTANCEW pddiW, LPDIMAPPER pdm )
{
    HRESULT hres;
    BOOL fAvailable = FALSE;
    WCHAR wszUserName[UNLEN+1];

    hres = CMap_GetDeviceUserName( &pddiW->guidInstance, wszUserName );

    if( hres != S_OK ) {
        fAvailable = TRUE;
    }

    return(fAvailable);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIObj_IsUserConfigured |
 *
 *          To Test whether the device has been configured by user.
 *
 *  @parm   IN LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Device Instance.
 *
 *  @parm   IN LPDIMAPPER | pdm |
 *
 *          pointer to DIMAPPER structure
 *
 *  @returns
 *
 *          TRUE: user configured
 *          FALSE: not configured
 *
 *****************************************************************************/

BOOL INTERNAL
CDIObj_IsUserConfigured( LPDIDEVICEINSTANCEW pddiW, LPDIMAPPER pdm )
{
    LPDIACTIONFORMATW pdiaf = pdm->pDiActionFormat;
    BOOL fConfigured = FALSE;
    DWORD i;

    for ( i=0; i<pdiaf->dwNumActions; i++ )
    {
        if ( IsEqualGUID(&pdiaf->rgoAction[i].guidInstance, &pddiW->guidInstance) )
        {
            fConfigured = (pdiaf->rgoAction[i].dwHow & DIAH_USERCONFIG) ? TRUE: FALSE;
            break;
        }
    }

    return(fConfigured);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | CDIObj_GetMappedActionNum |
 *
 *          Get the number of the actions which have been mapped to controls.
 *
 *  @parm   IN LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Device Instance.
 *
 *  @parm   IN LPDIMAPPER | pdm |
 *
 *          Pointer to DIMAPPER structure
 *
 *  @returns
 *
 *          Number of mapped actions
 *
 *****************************************************************************/

int INTERNAL
CDIObj_GetMappedActionNum( LPDIDEVICEINSTANCEW pddiW, LPDIMAPPER pdm )
{
    LPDIACTIONFORMATW pdiaf = pdm->pDiActionFormat;
    DWORD i;
    int num = 0;

    for ( i=0; i<pdiaf->dwNumActions; i++ )
    {
        if ( IsEqualGUID(&pdiaf->rgoAction[i].guidInstance, &pddiW->guidInstance) )
        {
            if ( pdiaf->rgoAction[i].dwHow & DIAH_MAPMASK )
            {
                num++;
            }
        }
    }

    return(num);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | CDIObj_GetMappedPriorities |
 *
 *          Get the priorities of the mapeed actions.
 *
 *  @parm   IN LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Device Instance.
 *
 *  @parm   IN LPDIMAPPER | pdm |
 *
 *          Pointer to DIMAPPER structure
 *
 *  @returns
 *
 *          The priorities of mapped actions. Can be DIEDBS_MAPPEDPRI1,
 *          DIEDBS_MAPPEDPRI2, or the OR of both.
 *
 *****************************************************************************/

DWORD INTERNAL
CDIObj_GetMappedPriorities( LPDIDEVICEINSTANCEW pddiW, LPDIMAPPER pdm )
{
    LPDIACTIONFORMATW pdiaf = pdm->pDiActionFormat;
    DWORD i;
    DWORD pri = 0;

    for ( i=0; i<pdiaf->dwNumActions; i++ )
    {
        if( pri == ( DIEDBS_MAPPEDPRI1 | DIEDBS_MAPPEDPRI2 ) ) {
            break;
        }

        if ( IsEqualGUID(&pdiaf->rgoAction[i].guidInstance, &pddiW->guidInstance) &&
             pdiaf->rgoAction[i].dwHow & DIAH_MAPMASK
        )
        {
            if( DISEM_PRI_GET(pdiaf->rgoAction[i].dwSemantic) == 0 )
            {
                pri |= DIEDBS_MAPPEDPRI1;
            } else if( DISEM_PRI_GET(pdiaf->rgoAction[i].dwSemantic) == 1 ) {
                pri |= DIEDBS_MAPPEDPRI2;
            }
        }
    }

    return(pri);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   int | CDIObj_GetDeviceOrder |
 *
 *          Get the number of the actions which have been mapped to controls.
 *
 *  @parm   IN LPDIDEVICEINSTANCEW | pddiW |
 *
 *          Device Instance.
 *
 *  @parm   IN LPDIMAPPER | pdm |
 *
 *          pointer to DIMAPPER structure
 *
 *  @returns
 *
 *          The order of the device
 *
 *  @comm
 *         The order (DWORD) is consisted of three parts:
 *             HIWORD: HIBYTE: the order defined in the genre
 *                     LOWBYTE: none, can be used later
 *             LOWORD: HIBYTE - mapped action number
 *                     LOWBYTE - Force Feedback (1) or not (0)
 *
 *****************************************************************************/

#define GET_MAPPED_ACTION_NUM(x) ((x & 0x0000ff00) >> 8)

DWORD INTERNAL
CDIObj_GetDeviceOrder( LPDIDEVICEINSTANCEW pddiW, LPDIMAPPER pdm )
{
    WORD wHighWord, wLowWord;
    BYTE byDevOrder, byFF, byMappedActions;
    DWORD dwGenre, dwJoyType;
    BYTE byOrder;

    AssertF(pddiW);
    AssertF(pdm->pDiActionFormat);

    if ( CDIObj_IsUserConfigured( pddiW, pdm ) )
    {
        byDevOrder = MAX_ORDER;
    } else
    {
        switch( GET_DIDEVICE_TYPE(pddiW->dwDevType) )
        {
            case DI8DEVTYPE_DEVICE:
                if( !(pdm->dwFlags & DIEDBSFL_NONGAMINGDEVICES) ) 
                {
                    byDevOrder = INVALID_ORDER;    
                } else {
                    byDevOrder = DIDEVTYPE_DEVICE_ORDER;
                }

                break;
    
            case DI8DEVTYPE_MOUSE:
                if( pddiW->dwDevType & DIDEVTYPE_HID ) 
                {
                    if( !(pdm->dwFlags & DIEDBSFL_MULTIMICEKEYBOARDS) ) {
                        byDevOrder = INVALID_ORDER;    
                    } else {
                        byDevOrder = DIDEVTYPE_HID_MOUSE_ORDER;
                    }
                } else {
                    byDevOrder = DIDEVTYPE_MOUSE_ORDER;
                }

                break;

            case DI8DEVTYPE_KEYBOARD:
                if( pddiW->dwDevType & DIDEVTYPE_HID ) 
                {
                    if( !(pdm->dwFlags & DIEDBSFL_MULTIMICEKEYBOARDS) ) {
                        byDevOrder = INVALID_ORDER;    
                    } else {
                        byDevOrder = DIDEVTYPE_HID_KEYBOARD_ORDER;
                    }
                } else {
                    byDevOrder = DIDEVTYPE_KEYBOARD_ORDER;
                }
                
                break;
    
            case DI8DEVTYPE_JOYSTICK:
            case DI8DEVTYPE_GAMEPAD:
            case DI8DEVTYPE_DRIVING:
            case DI8DEVTYPE_FLIGHT:
            case DI8DEVTYPE_1STPERSON:
            case DI8DEVTYPE_SCREENPOINTER:
            case DI8DEVTYPE_REMOTE:
            case DI8DEVTYPE_DEVICECTRL:
                dwJoyType = GET_DIDEVICE_TYPE(pddiW->dwDevType);
                dwGenre = DISEM_VIRTUAL_GET(pdm->pDiActionFormat->dwGenre);
    
                AssertF(dwGenre <= DISEM_MAX_GENRE);
                AssertF(dwJoyType < DI8DEVTYPE_MAX);
                AssertF(dwJoyType != 0);
    
                for ( byOrder=DI8DEVTYPE_MIN; byOrder<DI8DEVTYPE_MAX; byOrder++ )
                {
                    if ( DiGenreDeviceOrder[dwGenre][byOrder-DI8DEVTYPE_MIN] == dwJoyType )
                    {
                        break;
                    }
                }
    
                /*
                 * If the device is not on the default list, set its order as 
                 *  DIDEVTYPE_NOTDEFAULTDEVICE_ORDER + 1
                 */
                byDevOrder = DI8DEVTYPE_MAX - byOrder + DIDEVTYPE_SUPPLEMENTAL_ORDER + 1;
                break;
    

            case DI8DEVTYPE_SUPPLEMENTAL:
                byDevOrder = DIDEVTYPE_SUPPLEMENTAL_ORDER;
                break;

        } 
    }

    if( byDevOrder != INVALID_ORDER ) {
        byFF = IsEqualGUID(&pddiW->guidFFDriver, &GUID_Null) ? 0 : 1;
        byMappedActions = (UCHAR) CDIObj_GetMappedActionNum( pddiW, pdm );
    
        wLowWord = MAKEWORD( byFF, byMappedActions );
        wHighWord = MAKEWORD( 0, byDevOrder );

        return(MAKELONG( wLowWord, wHighWord ));
    } else {
        return 0;
    }

}

/*****************************************************************************
 *
 *      CDIObj_DeviceEnumProc
 *
 *      Device enumeration procedure which is called one for each device.
 *
 *****************************************************************************/

BOOL INTERNAL
CDIObj_InternalDeviceEnumProcW(LPDIDEVICEINSTANCEW pddiW, LPDIRECTINPUTDEVICE8W pdid8W, LPVOID pv)
{
    LPDIMAPPER pdm = pv;
    HRESULT hres = S_OK;
    BOOL fRc = DIENUM_CONTINUE;
    BOOL fContinue = FALSE;
    DWORD dwDevOrder;

    if ( g_nCurDev >= MAX_DEVICENUM )
    {
        fRc = DIENUM_STOP;
        goto _done;
    }

    AssertF(pdid8W);
    AssertF(pdm->pDiActionFormat);

    hres = pdid8W->lpVtbl->BuildActionMap(pdid8W, pdm->pDiActionFormat, pdm->lpszUserName, 
                                          pdm->lpszUserName ? DIDBAM_DEFAULT : DIDBAM_HWDEFAULTS);

    if ( SUCCEEDED(hres) )
    {
        if ( (pdm->dwFlags & DIEDBSFL_AVAILABLEDEVICES) || 
             (pdm->dwFlags & DIEDBSFL_THISUSER) ) 
        {
            if( ((pdm->dwFlags & DIEDBSFL_AVAILABLEDEVICES) && CDIObj_IsDeviceAvailable(pddiW,pdm)) ||
                ((pdm->dwFlags & DIEDBSFL_THISUSER) && CDIObj_IsDeviceUsedByUser(pddiW,pdm))
            ) {
                fContinue = TRUE;
            }
        } else {
            fContinue = TRUE;
        }
             
        if( fContinue && 
            ((dwDevOrder = CDIObj_GetDeviceOrder(pddiW, pdm)) != 0) )
        {
#ifdef DEBUG
            DWORD   dbgRef;
#endif

#ifdef DEBUG
            dbgRef =
#endif
            pdid8W->lpVtbl->AddRef(pdid8W);
            g_DiDevices[g_nCurDev].dwOrder = dwDevOrder;
            g_DiDevices[g_nCurDev].dwFlags = CDIObj_GetMappedPriorities( pddiW, pdm );
            g_DiDevices[g_nCurDev].pdid8W = pdid8W;
            memcpy( &g_DiDevices[g_nCurDev].ftTimeStamp, &pdm->pDiActionFormat->ftTimeStamp, sizeof(FILETIME) );
            memcpy( &g_DiDevices[g_nCurDev].ddiW, pddiW, sizeof(*pddiW) );
            g_nCurDev ++;

            fRc = DIENUM_CONTINUE;
        }
    }

    _done:
    
    return(fRc);
}

/*****************************************************************************
 *
 *      compare
 *
 *      Compare func used in shortsort
 *
 *****************************************************************************/

int __cdecl compare( const void *arg1, const void *arg2 )
{
    DWORD dw1 = ((LPDIORDERDEV)arg1)->dwOrder;
    DWORD dw2 = ((LPDIORDERDEV)arg2)->dwOrder;

    /*
     * Compare the device order
     * If necessary, we can compare seperately: devtype, mapped action number, FF device
     */
    if ( dw1 < dw2 )
    {
        return(1);
    } else if ( dw1 > dw2 )
    {
        return(-1);
    } else
    {
        return(0);
    }
}

void FreeDiActionFormatW(LPDIACTIONFORMATW* lplpDiAfW )
{
    FreePpv(lplpDiAfW);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | IsValidMapObjectA |
 *
 *          Validates a LPDIACTIONFORMATW including strings
 *
 *  @parm   const LPDIACTIONFORMATW | lpDiAfW | 
 *
 *          Original.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/
HRESULT
IsValidMapObjectA
(
    LPDIACTIONFORMATA paf
#ifdef XDEBUG
    comma LPCSTR pszProc
    comma UINT argnum
#endif
)
{
    HRESULT hres;

    hres  = CDIDev_ActionMap_IsValidMapObject
    ( (LPDIACTIONFORMATW)paf
#ifdef XDEBUG
    comma pszProc
    comma argnum
#endif
    );

    if( SUCCEEDED( hres ) )
    {
        if( paf->dwSize != cbX(DIACTIONFORMATA) )
        {
            D( RPF("IDirectInputDevice::%s: Invalid DIACTIONFORMATA.dwSize 0x%08x",
                pszProc, paf->dwSize ); )
            hres = E_INVALIDARG;
        }
    }

    if(SUCCEEDED(hres))
    {
        DWORD i;
        LPDIACTIONA lpDiAA;
        // Compute the size for each of the text strings in array of DIACTIONs
        for ( i = 0x0, lpDiAA = paf->rgoAction;
            i < paf->dwNumActions && SUCCEEDED(hres) ;
            i++, lpDiAA++ )
        {
            // Handle the NULL ptr case
            if ( NULL != lpDiAA->lptszActionName )
            {
                hres = hresFullValidReadStrA_(lpDiAA->lptszActionName, MAX_JOYSTRING, pszProc, argnum);
            }
        }
    }

    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | IsValidMapObjectW |
 *
 *          Validates a LPDIACTIONFORMATW including strings
 *
 *  @parm   const LPDIACTIONFORMATW | lpDiAfW | 
 *
 *          Original.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/
HRESULT
IsValidMapObjectW
(
    LPDIACTIONFORMATW paf
#ifdef XDEBUG
    comma LPCSTR pszProc
    comma UINT argnum
#endif
)
{
    HRESULT hres;

    hres  = CDIDev_ActionMap_IsValidMapObject
    ( paf
#ifdef XDEBUG
    comma pszProc
    comma argnum
#endif
    );

    if( SUCCEEDED( hres ) )
    {
        if( paf->dwSize != cbX(DIACTIONFORMATW) )
        {
            D( RPF("IDirectInputDevice::%s: Invalid DIACTIONFORMATW.dwSize 0x%08x",
                pszProc, paf->dwSize ); )
            hres = E_INVALIDARG;
        }
    }
    
    if(SUCCEEDED(hres))
    {
        DWORD i;
        LPDIACTIONW lpDiAW;
        // Compute the size for each of the text strings in array of DIACTIONs
        for ( i = 0x0, lpDiAW = paf->rgoAction;
            i < paf->dwNumActions && SUCCEEDED(hres) ;
            i++, lpDiAW++ )
        {
            // Handle the NULL ptr case
            if ( NULL != lpDiAW->lptszActionName )
            {
                hres = hresFullValidReadStrW_(lpDiAW->lptszActionName, MAX_JOYSTRING, pszProc, argnum);
            }
        }
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DiActionFormatWtoW |
 *
 *          Copies LPDIACTIONFORMATW to  LPDIACTIONFORMATW
 *
 *  @parm   const LPDIACTIONFORMATW | lpDiAfW | 
 *
 *          Original.
 *
 *  @parm   LPDIACTIONFORMATW* | lplpDiAfW | 
 *
 *          Address of a pointer to a <t DIACTIONFORMATW> that receives the converted
 *          ACTIONFORMAT.
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

HRESULT EXTERNAL DiActionFormatWtoW
(
    const LPDIACTIONFORMATW lpDiAfW0,
    LPDIACTIONFORMATW* lplpDiAfW
)
{
    DWORD cbAlloc;
    PDWORD pdwStrLen0, pdwStrLen;
    LPDIACTIONFORMATW lpDiAfW;
    LPDIACTIONW lpDiAW0;
    LPDIACTIONW lpDiAW;
    DWORD i;
    HRESULT hres;

    EnterProcI(DiActionFormatWtoW, (_ "xx", lpDiAfW0, lplpDiAfW));

    // Internal function, no validation

    *lplpDiAfW = NULL;

    /*
     *  PREFIX complains (mb:37926 - items 3 & 4) that we could be requesting 
     *  a zero byte allocation which would not allocate anything.  This is 
     *  never the case because CDIDev_ActionMap_IsValidMapObject tests that 
     *  dwNumActions is less than 2^24.  Assert in debug for extra safety.
     */
    AssertF( (lpDiAfW0->dwNumActions +1) * cbX(*pdwStrLen0) );
    hres = AllocCbPpv( (lpDiAfW0->dwNumActions +1) * cbX(*pdwStrLen0) , &pdwStrLen0);

    if ( SUCCEEDED(hres) )
    {
        pdwStrLen = pdwStrLen0;
        // Compute the amount of memory required to clone the DIACTIONFORMATA
        cbAlloc =
        /* 1: The Action Format array */
        lpDiAfW0->dwSize
        /* 2: Each of the DIACTION arrays */
        + lpDiAfW0->dwActionSize * lpDiAfW0->dwNumActions;

        // Compute the size for each of the text strings in array of DIACTIONs
        for ( i = 0x0, lpDiAW0 = lpDiAfW0->rgoAction;
            i < lpDiAfW0->dwNumActions ;
            i++, lpDiAW0++ )
        {
            // Handle the NULL ptr case
            if ( !lpDiAW0->lptszActionName )
            {
                *pdwStrLen++ = 0;
            }
            else
            {
                if ( (UINT_PTR)lpDiAW0->lptszActionName > (UINT_PTR)0xFFFF )
                {
                    /* 3: Text string in each DIACTION array*/
                    // Conversion from A to U, need  multiplier
                    *pdwStrLen = cbX(lpDiAW0->lptszActionName[0]) * ( lstrlenW(lpDiAW0->lptszActionName) + 1 );
                    cbAlloc += *pdwStrLen++;
                }
                else
                { 
                    // Use resource strings
                    WCHAR wsz[MAX_PATH];
                    if (lpDiAfW0->hInstString > 0)
                    {
                        //find out the length of the string
                        *pdwStrLen = LoadStringW(lpDiAfW0->hInstString, lpDiAW0->uResIdString, (LPWSTR) &wsz, MAX_PATH);
                    }
                    else
                    {
                        *pdwStrLen = 0;
                    }
                    cbAlloc += *pdwStrLen++;
                }
            }
        }

        if ( SUCCEEDED( hres = AllocCbPpv(cbAlloc, &lpDiAfW) ) )
        {
            DWORD dwLen;
            DWORD cb;

            pdwStrLen = pdwStrLen0;

            // 1: Copy the DIACTIONFORMAT
            *lpDiAfW = *lpDiAfW0;
            cb = lpDiAfW0->dwSize;

            // 2: Block copy the DIACTION array
            lpDiAfW->rgoAction = (LPDIACTIONW)( (char*)lpDiAfW + cb);
            dwLen = lpDiAfW0->dwActionSize * lpDiAfW0->dwNumActions;
            memcpy(lpDiAfW->rgoAction, lpDiAfW0->rgoAction, dwLen);
            cb += dwLen;

            // 3: ActionName
            for ( i = 0x0, lpDiAW0=lpDiAfW0->rgoAction, lpDiAW=lpDiAfW->rgoAction;
                i < lpDiAfW0->dwNumActions ;
                i++, lpDiAW0++, lpDiAW++ )
            {
                if ( (UINT_PTR)lpDiAW0->lptszActionName > (UINT_PTR)0xFFFF )
                {
                    WCHAR* wsz =  (WCHAR*) ((char*)lpDiAfW+cb);
                    lpDiAW->lptszActionName = wsz;

                    dwLen = *pdwStrLen++;

                    memcpy(wsz, lpDiAW0->lptszActionName, dwLen);

                    cb += dwLen  ;
                } else
                {
                    //  Handle resource strings
                    //  OK for now, as long as UI always uses CloneDiActionFormatW
                    WCHAR* wsz =  (WCHAR*) ((char*)lpDiAfW+cb);

                    dwLen = *pdwStrLen++;
                    if ((dwLen != 0) && (LoadStringW(lpDiAfW0->hInstString, lpDiAW0->uResIdString, wsz, dwLen)))
                    {
                        //If we found a length last time there must be a resource module
                        AssertF( lpDiAfW0->hInstString > 0 );

                        //Found and loaded the string
                        lpDiAW->lptszActionName = wsz;
                    }
                    else
                    {
                        //No hinstance or length 0 or didn't load the string
                        lpDiAW->lptszActionName = NULL;
                    }

                    cb += dwLen;
                }
            }


            // If we have not done something goofy, the memory allocates should match
            // the memory we used
            AssertF(cbAlloc == cb );

            *lplpDiAfW = lpDiAfW;
        }

        FreePpv(&pdwStrLen0);
    }

    ExitOleProc();
    return(hres);
}

/*****************************************************************************
 *
 *      CDIMap_EnumDevicesBySemantics
 *
 *      Enum Suitable Devices.
 *
 *****************************************************************************/

STDMETHODIMP CDIObj_EnumDevicesBySemanticsW(
                                           PV                       pDiW,
                                           LPCWSTR                  lpszUserName,
                                           LPDIACTIONFORMATW        pDiActionFormat,
                                           LPDIENUMDEVICESBYSEMANTICSCBW   pecW,
                                           LPVOID                   pvRef,
                                           DWORD                    dwFlags
                                           )
{
    HRESULT hres;

    EnterProcR(IDirectInput8::EnumDevicesBySemantics,
               (_ "pppppx", pDiW, lpszUserName, pDiActionFormat, pecW, pvRef, dwFlags));

    if ( SUCCEEDED(hres = hresPvI(pDiW, ThisInterfaceW)) &&
         SUCCEEDED(hres = IsValidMapObjectW(pDiActionFormat D(comma s_szProc comma 2))) &&
         (lpszUserName == NULL || SUCCEEDED(hres = hresFullValidReadStrW(lpszUserName, UNLEN+1, 1))) &&
         SUCCEEDED(hres = hresFullValidPfn(pecW, 3)) &&
         SUCCEEDED(hres = hresFullValidFl(dwFlags, DIEDBSFL_VALID, 5)) &&
         SUCCEEDED(hres = CMap_ValidateActionMapSemantics(pDiActionFormat, DIDBAM_PRESERVE))
       )
    {
        PDDI this = _thisPvNm(pDiW, diW);

        if ( SUCCEEDED(hres = hresValidInstanceVer(g_hinst, this->dwVersion)) )
        {
            DIMAPPER dm;
            LPDIACTIONFORMATW lpDiAfW;

            if ( SUCCEEDED(hres= DiActionFormatWtoW(pDiActionFormat, &lpDiAfW)) )
            {
                dm.lpszUserName = lpszUserName;
                dm.pDiActionFormat = lpDiAfW;
                dm.pecW = pecW;
                dm.pvRef = pvRef;
                dm.dwFlags = dwFlags;

                if( dwFlags == 0 ) {
                    dwFlags |= DIEDFL_ATTACHEDONLY;
                }

                dwFlags &= ~DIEDBSFL_AVAILABLEDEVICES;
                dwFlags &= ~DIEDBSFL_THISUSER;
                dwFlags &= ~DIEDBSFL_MULTIMICEKEYBOARDS;
                dwFlags &= ~DIEDBSFL_NONGAMINGDEVICES;

                ZeroX(g_DiDevices);
                g_nCurDev = 0;
    
                hres = CDIObj_InternalEnumDevicesW( pDiW,
                                                    0,  //enum all tyeps of devices
                                                    (LPVOID)&dm,
                                                    dwFlags //only enum attached devices
                                                  );
    
                /*
                 * For short array sorting (size <= 8), shortsort is better than qsort.
                 */
                if ( SUCCEEDED(hres) && g_nCurDev )
                {
                    int ndev;
                    int nNewDev = -1;
                    FILETIME ft = { 0, 0 };
                    FILETIME ftMostRecent;
    
                    shortsort( (char *)&g_DiDevices[0], (char *)&g_DiDevices[g_nCurDev-1], sizeof(DIORDERDEV), compare );
                    SquirtSqflPtszV(sqflDi | sqflVerbose,
                                    TEXT("EnumDevicesBySemantics: %d devices enumed"), g_nCurDev );
    
                    for ( ndev=0; ndev<g_nCurDev; ndev++ )
                    {
                        if( (g_DiDevices[ndev].ftTimeStamp.dwHighDateTime != DIAFTS_NEWDEVICEHIGH) &&
                            (g_DiDevices[ndev].ftTimeStamp.dwLowDateTime != DIAFTS_NEWDEVICELOW) &&
                            (CompareFileTime(&g_DiDevices[ndev].ftTimeStamp, &ft) == 1)   ) // first device is newer
                        {
                            nNewDev = ndev;
                            memcpy( &ft, &g_DiDevices[ndev].ftTimeStamp, sizeof(FILETIME) );
                        }
                    }

                    if( nNewDev != -1 ) {
                        g_DiDevices[nNewDev].dwFlags |= DIEDBS_RECENTDEVICE;
                        memcpy( &ftMostRecent, &g_DiDevices[nNewDev].ftTimeStamp, sizeof(FILETIME) );
                    }

                    for ( ndev=0; ndev<g_nCurDev; ndev++ )
                    {
                        // find RECENT devices and set flag.
                        if( (nNewDev != -1) && (ndev != nNewDev) ) {
                            if( (ftMostRecent.dwHighDateTime == g_DiDevices[ndev].ftTimeStamp.dwHighDateTime) &&
                                (ftMostRecent.dwLowDateTime - g_DiDevices[ndev].ftTimeStamp.dwLowDateTime < 100000000 ) )//10 seconds difference
                            {
                                g_DiDevices[ndev].dwFlags |= DIEDBS_RECENTDEVICE;
                            }
                        }
                        
                        // find NEW devices and set flag
                        if( (g_DiDevices[ndev].ftTimeStamp.dwLowDateTime == DIAFTS_NEWDEVICELOW) &&
                            (g_DiDevices[ndev].ftTimeStamp.dwHighDateTime == DIAFTS_NEWDEVICEHIGH) ) 
                        {
                                g_DiDevices[ndev].dwFlags |= DIEDBS_NEWDEVICE;
                        }
                    }
                    
                    if( !IsBadCodePtr((PV)pecW) ) {
                        for ( ndev=0; ndev<g_nCurDev; ndev++ )
                        {
                            LPDIDEVICEINSTANCEW pddiW = &g_DiDevices[ndev].ddiW;

                            SquirtSqflPtszV(sqflDi | sqflVerbose,
                                            TEXT("EnumDevicesBySemantics: device %d - %s: %d action(s) mapped"),
                                            ndev+1, pddiW->tszProductName, GET_MAPPED_ACTION_NUM(g_DiDevices[ndev].dwOrder) );

                            if ( pddiW )
                            {
#ifdef DEBUG
                                DWORD   dbgRef;
#endif
                                DWORD   dwDeviceRemaining = g_nCurDev-ndev-1;

                                AssertF(g_DiDevices[ndev].pdid8W);
                                AssertF(g_DiDevices[ndev].pdid8W->lpVtbl);

                                if( g_DiDevices[ndev].pdid8W && g_DiDevices[ndev].pdid8W->lpVtbl ) 
                                {
                                    BOOL fRc;

                                    fRc = pecW(pddiW, g_DiDevices[ndev].pdid8W, g_DiDevices[ndev].dwFlags, dwDeviceRemaining, pvRef);

                                    if( fRc == DIENUM_STOP ) {
                                        for ( ; ndev<g_nCurDev; ndev++ ) {
                                            g_DiDevices[ndev].pdid8W->lpVtbl->Release(g_DiDevices[ndev].pdid8W);
                                        }

                                        break;
                                    }

#ifdef DEBUG
                                    dbgRef =
#endif
                                    g_DiDevices[ndev].pdid8W->lpVtbl->Release(g_DiDevices[ndev].pdid8W);
                                }
                            }
                        }
                    }
                }
                
                FreeDiActionFormatW(&lpDiAfW);
            }
        }
    }

    ExitOleProcR();
    return(hres);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | CDIObj_EnumDevicesBySemanticsCallbackA |
 *
 *          Wrapper function for <mf IDirectInput::EnumDevicesBySemantics>
 *          which translates the UNICODE parameters to ANSI.
 *
 *  @parm   IN LPCDIDECICEINSTANCEW | pdiW |
 *
 *          Same as <mf IDirectInput::EnumDevices>.
 *
 *  @parm   IN OUT PV | pvRef |
 *
 *          Pointer to <t struct ENUMDEVICESBYSEMANTICSINFO> which describes
 *          the original callback.
 *
 *  @returns
 *
 *          Returns whatever the original callback returned.
 *
 *****************************************************************************/

typedef struct ENUMDEVICESBYSEMANTICSINFO
{
    LPDIENUMDEVICESBYSEMANTICSCBA pecA;
    PV pvRef;
} ENUMDEVICESBYSEMANTICSINFO, *PENUMDEVICESBYSEMANTICSINFO;

BOOL CALLBACK
CDIObj_EnumDevicesBySemanticsCallback(LPCDIDEVICEINSTANCEW pdiW, LPDIRECTINPUTDEVICE8W pdid8W, DWORD dwFlags, DWORD dwDeviceRemaining, PV pvRef)
{
    PENUMDEVICESBYSEMANTICSINFO pesdi = pvRef;
    BOOL fRc;
    DIDEVICEINSTANCEA diA;
    LPDIRECTINPUTDEVICE8A pdid8A = NULL;

    EnterProc(CDIObj_EnumDevicesBySemanticsCallback,
              (_ "GGxWWp", &pdiW->guidInstance, &pdiW->guidProduct,
               &pdiW->dwDevType,
               pdiW->tszProductName, pdiW->tszInstanceName,
               pvRef));

    diA.dwSize = cbX(diA);
    DeviceInfoWToA(&diA, pdiW);
    Device8WTo8A(&pdid8A, pdid8W);

    fRc = pesdi->pecA(&diA, pdid8A, dwFlags, dwDeviceRemaining, pesdi->pvRef);

    ExitProcX(fRc);
    return(fRc);
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | EnumDevicesBySemantics |
 *
 *          Enumerates devices suitable for the application specified
 *          <t DIACTIONFORMAT>.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  ISSUE-2001/03/29-timgill Need to fix auto docs
 *  @parm   LPTSTR  | lptszActionMap |
 *
 *          Friendly name for the application.
 *
 *  @parm   REFGUID | rguid |
 *
 *          Unique GUID to identify the application.
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/
STDMETHODIMP CDIObj_EnumDevicesBySemanticsA
(
PV                       pDiA,
LPCSTR                   lpszUserName,
LPDIACTIONFORMATA        pDiActionFormat,
LPDIENUMDEVICESBYSEMANTICSCBA   pecA,
LPVOID                   pvRef,
DWORD                    dwFlags
)
{
    HRESULT hres;

    EnterProcR(IDirectInput8::EnumDevicesBySemantics,
               (_ "pppppx", pDiA, lpszUserName, pDiActionFormat, pecA, pvRef, dwFlags));

    /*
     *  EnumDevicesBySemanticsW will validate the rest.
     */
    if ( SUCCEEDED(hres = hresPvI(pDiA, ThisInterfaceA)) &&
         SUCCEEDED(hres = IsValidMapObjectA(pDiActionFormat D(comma s_szProc comma 2))) &&
         (lpszUserName == NULL || SUCCEEDED(hres = hresFullValidReadStrA(lpszUserName, UNLEN+1, 1))) &&
         SUCCEEDED(hres = hresFullValidPfn(pecA, 3)) &&
         SUCCEEDED(hres = hresFullValidFl(dwFlags, DIEDBSFL_VALID, 5))
       )
    {
        PDDI this = _thisPvNm(pDiA, diA);
        ENUMDEVICESBYSEMANTICSINFO esdi = { pecA, pvRef};
        WCHAR wszUserName[MAX_PATH];
        DIACTIONFORMATW diafW;
        LPDIACTIONW rgoActionW;

        wszUserName[0] = L'\0';
        if( lpszUserName ) {
            AToU(wszUserName, MAX_PATH, lpszUserName);
        }

        /*
         *  Assert that the structure can be copied as:
         *      a)  dwSize
         *      b)  everything else
         *      c)  the app name
         */
        CAssertF( FIELD_OFFSET( DIACTIONFORMATW, dwSize ) == 0 );
        CAssertF( FIELD_OFFSET( DIACTIONFORMATA, dwSize ) == 0 );

        CAssertF( FIELD_OFFSET( DIACTIONFORMATW, dwSize ) + cbX( ((LPDIACTIONFORMATW)0)->dwSize )
               == FIELD_OFFSET( DIACTIONFORMATW, dwActionSize ) );
        #if defined(_WIN64)
            CAssertF( ( ( cbX( DIACTIONFORMATW ) - cbX( ((LPDIACTIONFORMATW)0)->tszActionMap ) )
                      - ( cbX( DIACTIONFORMATA ) - cbX( ((LPDIACTIONFORMATA)0)->tszActionMap ) ) 
                    < MAX_NATURAL_ALIGNMENT ) );
        #else
            CAssertF( ( cbX( DIACTIONFORMATW ) - cbX( ((LPDIACTIONFORMATW)0)->tszActionMap ) )
                   == ( cbX( DIACTIONFORMATA ) - cbX( ((LPDIACTIONFORMATA)0)->tszActionMap ) ) );
        #endif

        CAssertF( FIELD_OFFSET( DIACTIONFORMATW, tszActionMap ) 
               == FIELD_OFFSET( DIACTIONFORMATA, tszActionMap ) );
        CAssertF( cA( ((LPDIACTIONFORMATW)0)->tszActionMap ) == cA( ((LPDIACTIONFORMATA)0)->tszActionMap ) );

        //Init diafW fields
        diafW.dwSize = cbX(DIACTIONFORMATW);

        memcpy( &diafW.dwActionSize, &pDiActionFormat->dwActionSize, 
            FIELD_OFFSET( DIACTIONFORMATW, tszActionMap ) - FIELD_OFFSET( DIACTIONFORMATW, dwActionSize ) );

        AToU(diafW.tszActionMap,  cbX(pDiActionFormat->tszActionMap), pDiActionFormat->tszActionMap);

        if ( SUCCEEDED( hres = AllocCbPpv( cbCxX(pDiActionFormat->dwNumActions, DIACTIONW), &rgoActionW) ) )
        {
            memcpy( rgoActionW, pDiActionFormat->rgoAction, sizeof(DIACTIONA) * pDiActionFormat->dwNumActions );
            diafW.rgoAction = rgoActionW;

            hres = CDIObj_EnumDevicesBySemanticsW(&this->diW, wszUserName,
                                                  &diafW,
                                                  CDIObj_EnumDevicesBySemanticsCallback,
                                                  &esdi, dwFlags);
            FreePpv(&rgoActionW);
        }
    }

    ExitOleProcR();
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresValidSurface |
 *
 *          Tests the interface pointer for a valid surface of sufficient 
 *          dimensions to display the UI and with a supported pixel format.
 *
 *  @parm   IUnknown* | lpUnkDDSTarget | 
 *
 *          Pointer to an interface which must be validated as a COM object
 *          before calling this function.
 *
 *  @returns
 *
 *          <c DI_OK> = <c S_OK>: The operation completed successfully.
 *          <c DIERR_INVALIDPARAM> = <c E_INVALIDARG>:  The
 *          <p lpUnkDDSTarget> parameter is not valid.
 *          A DirectDraw or D3D error if one was returned.
 *          or a Standard OLE <t HRESULT>.
 *
 *****************************************************************************/


HRESULT INLINE hresValidSurface
(
    IUnknown*   lpUnkDDSTarget
) 
{
    HRESULT     hres;
    IUnknown*   lpSurface = NULL;

/*
 *  Short on time, so take short-cuts in validation debug error messages
 */
#ifdef XDEBUG
    CHAR        s_szProc[] = "IDirectInput8::ConfigureDevices";
#endif
    #define     ArgIS   2

    if( SUCCEEDED( hres = lpUnkDDSTarget->lpVtbl->QueryInterface( 
        lpUnkDDSTarget, &IID_IDirect3DSurface8, (LPVOID*)&lpSurface ) ) )
    {
        D3DSURFACE_DESC SurfDesc;

        hres = ((IDirect3DSurface8*)lpSurface)->lpVtbl->GetDesc( ((IDirect3DSurface8*)lpSurface), &SurfDesc );

        if( FAILED( hres ) )
        {
            RPF( "%s: Arg %d: Unable to GetDesc on surface, error 0x%08x", s_szProc, ArgIS, hres );
            /*
             *  D3D returns real HRESULTs which can be returned to the caller
             */
        }
        else
        {
            if( ( SurfDesc.Width < 640 ) || ( SurfDesc.Height < 480 ) )
            {
                RPF( "%s: Arg %d: cannot use %d by %d surface", 
                    s_szProc, ArgIS, SurfDesc.Width, SurfDesc.Height );
                hres = E_INVALIDARG;
            }
            else
            {
                switch( SurfDesc.Format )
                {
                case D3DFMT_R8G8B8:
                case D3DFMT_A8R8G8B8:
                case D3DFMT_X8R8G8B8:
                case D3DFMT_R5G6B5:
                case D3DFMT_X1R5G5B5:
                case D3DFMT_A1R5G5B5:
                    SquirtSqflPtszV(sqfl | sqflVerbose,
                        TEXT("ConfigureDevices: validated %d by %d format %d surface"), 
                        SurfDesc.Width, SurfDesc.Height, SurfDesc.Format );
                    break;
                default:
                    RPF( "%s: Arg %d: cannot use surface format %d ", s_szProc, ArgIS, SurfDesc.Format );
                    hres = E_INVALIDARG;
                    break;
                }
            }
        }
    }
    else
    {
        DDSURFACEDESC2 SurfDesc;
        SurfDesc.dwSize = cbX( SurfDesc );

        if( SUCCEEDED(hres = lpUnkDDSTarget->lpVtbl->QueryInterface(
            lpUnkDDSTarget, &IID_IDirectDrawSurface7, (LPVOID*) &lpSurface)) )
        {
            hres = ((IDirectDrawSurface7*)lpSurface)->lpVtbl->GetSurfaceDesc( ((IDirectDrawSurface7*)lpSurface), &SurfDesc );
        }
        else if( SUCCEEDED(hres = lpUnkDDSTarget->lpVtbl->QueryInterface(
            lpUnkDDSTarget, &IID_IDirectDrawSurface4, (LPVOID*) &lpSurface )) )
        {
            hres = ((IDirectDrawSurface4*)lpSurface)->lpVtbl->GetSurfaceDesc( ((IDirectDrawSurface4*)lpSurface), &SurfDesc );
        }

        if( FAILED( hres ) )
        {
            if( lpSurface )
            {
                RPF( "%s: Arg %d: failed GetSurfaceDesc, error 0x%08x", s_szProc, ArgIS, hres );
            }
            else
            {
                RPF( "%s: Arg %d: failed QI for supported surface interfaces from %p, error 0x%08x", 
                    s_szProc, ArgIS, lpSurface, hres );
            }
            /*
             *  DDraw returns real HRESULTs which can be returned to the caller
             */
        }
        else if( ( SurfDesc.dwWidth < 640 ) || ( SurfDesc.dwHeight < 480 ) )
        {
            RPF( "%s: Arg %d: cannot use %d by %d surface", 
                s_szProc, ArgIS, SurfDesc.dwWidth, SurfDesc.dwHeight );
            hres = E_INVALIDARG;
        }
        else
        {
            /*
             *  Check for the eqivalent of the DX8 surfaces: 
             *      A8R8G8B8, X8R8G8B8, R8G8B8, A1R5G5B5, X1R5G5B5, R5G6B5
             */
            if( SurfDesc.ddpfPixelFormat.dwFlags & DDPF_RGB )
            {
                if( SurfDesc.ddpfPixelFormat.dwRGBBitCount > 16 )
                {
                    AssertF( ( SurfDesc.ddpfPixelFormat.dwRGBBitCount == 32 )
                           ||( SurfDesc.ddpfPixelFormat.dwRGBBitCount == 24 ) );
                    /*
                     *  All of these must be R8 G8 B8
                     */
                    if( ( SurfDesc.ddpfPixelFormat.dwRBitMask == 0x00FF0000 )
                     && ( SurfDesc.ddpfPixelFormat.dwGBitMask == 0x0000FF00 )
                     && ( SurfDesc.ddpfPixelFormat.dwBBitMask == 0x000000FF ) )
                    {
                        SquirtSqflPtszV(sqfl | sqflVerbose,
                            TEXT("ConfigureDevices: validated %d by %d format R8G8B8 %d bit surface"), 
                            SurfDesc.dwWidth, SurfDesc.dwHeight, SurfDesc.ddpfPixelFormat.dwRGBBitCount );
                    }
                    else
                    {
                        RPF( "%s: Arg %d: cannot use surface pixel format", s_szProc, ArgIS );
                        hres = E_INVALIDARG;
                    }
                }
                else
                {
                    if( SurfDesc.ddpfPixelFormat.dwRGBBitCount == 16 )
                    {
                        /*
                         *  Allow R5 G5 B5 and R5 G6 B5
                         */
                        if( ( SurfDesc.ddpfPixelFormat.dwBBitMask == 0x0000001F )
                         && ( ( SurfDesc.ddpfPixelFormat.dwGBitMask == 0x000003E0 )
                           && ( SurfDesc.ddpfPixelFormat.dwRBitMask == 0x00007C00 ) )
                         || ( ( SurfDesc.ddpfPixelFormat.dwGBitMask == 0x000007E0 )
                           && ( SurfDesc.ddpfPixelFormat.dwRBitMask == 0x0000F800 ) ) )
                        {
                            SquirtSqflPtszV(sqfl | sqflVerbose,
                                TEXT("ConfigureDevices: validated %d by %d format 16 bit surface"), 
                                SurfDesc.dwWidth, SurfDesc.dwHeight );
                        }
                        else
                        {
                            RPF( "%s: Arg %d: cannot use 16 bit surface pixel format", s_szProc, ArgIS );
                            hres = E_INVALIDARG;
                        }
                    }
                    else
                    {
                        RPF( "%s: Arg %d: cannot use %d bit surface pixel format", 
                            s_szProc, ArgIS, SurfDesc.ddpfPixelFormat.dwRGBBitCount );
                        hres = E_INVALIDARG;
                    }
                }
            }
            else
            {
                RPF( "%s: Arg %d: cannot use non RGB surface, Surface.dwFlags = 0x%08x", 
                    s_szProc, ArgIS, SurfDesc.ddpfPixelFormat.dwFlags );
                hres = E_INVALIDARG;
            }
        }
    }

    if( lpSurface != NULL )
    {
        lpSurface->lpVtbl->Release( lpSurface );
    }

    return hres;

    #undef ArgIS
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @method HRESULT | IDirectInput | ConfigureDevices |
 *
 *          Configures the devices by attaching mappings provided  in
 *          <t DIACTIONFORMAT> to appropriate device controls.
 *
 *  @cwrap  LPDIRECTINPUT | lpDirectInput
 *
 *  @parm   LPCTSTR       | lpctszUserName | 
 *
 *          User Name.
 *
 *  @parm   LPDIACTIONFORMAT | lpDiActionFormat |
 *
 *          Pointer to the <t DIACTIONFORMAT> structure containing the action map.
 *
 *
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/


STDMETHODIMP CDIObj_ConfigureDevicesCore
(
PV                                                          pDiW,
LPDICONFIGUREDEVICESCALLBACK                                lpdiCallback,
LPDICONFIGUREDEVICESPARAMSW                                 lpdiCDParams,
DWORD                                                       dwFlags,
LPVOID                                                      pvRefData                                               
)

{
    //the real ConfigureDevices()
    //some stuff should have been validated already
    HRESULT hres = S_OK;

    EnterProcI(IDirectInput8::ConfigureDevicesCore,
              (_ "pppup", pDiW, lpdiCallback,lpdiCDParams, dwFlags, pvRefData));

    if( SUCCEEDED( hres = hresFullValidFl( dwFlags, DICD_VALID, 3 ) )
     && SUCCEEDED( hres = hresFullValidReadPvCb( &(lpdiCDParams->dics), sizeof(DICOLORSET), 2 ) ) )
    {
        /*
         *  lpUnkDDSTarget and lpdiCallback are "coupled", because the only 
         *  function of the callback is to display the updates to the surface
         *  either they are both NULL, or they are both non-NULL and valid.
         *  otherwise, it is an error.
         */
        if( lpdiCallback == NULL )
        {
            if( lpdiCDParams->lpUnkDDSTarget == NULL )
            {
                hres = S_OK;
            }
            else
            {
                RPF( "%s: Arg %d or %d: neither or both of callback and surface must be NULL", 
                    s_szProc, 1, 2 );
                hres = E_INVALIDARG;
            }
        }
        else if( lpdiCDParams->lpUnkDDSTarget == NULL )
        {
            RPF( "%s: Arg %d or %d: neither or both of surface and callback must be NULL", 
                s_szProc, 2, 1 );
            hres = E_INVALIDARG;
        }
        else if( SUCCEEDED( hres = hresFullValidPfn( lpdiCallback, 1 ) )
              && SUCCEEDED( hres = hresFullValidPitf( lpdiCDParams->lpUnkDDSTarget, 2 ) ) )
        {
            hres = hresValidSurface( lpdiCDParams->lpUnkDDSTarget );
        }

        if( SUCCEEDED( hres ) )
        {
            //load the framework
            HINSTANCE hinst;
            IDirectInputActionFramework* pDIAcFrame = NULL;
            TCHAR tszName[ctchNameGuid];
            TCHAR tszClsid[ctchGuid];

            NameFromGUID(tszName, &CLSID_CDirectInputActionFramework);
            memcpy(tszClsid, &tszName[ctchNamePrefix], cbX(tszClsid) );

            hres = DICoCreateInstance(tszClsid, NULL, &IID_IDIActionFramework, (LPVOID*) & pDIAcFrame, &hinst);

            if( SUCCEEDED(hres) )
            {
                //for getting default user name, if needed
                LPWSTR pwszUserName = NULL;

                //can't pass NULL user name down to the framework -- need to get the default user name
                if( lpdiCDParams->lptszUserNames == NULL )
                {
                    hres = GetWideUserName(NULL, NULL, &pwszUserName);
                    lpdiCDParams->lptszUserNames = pwszUserName;
                    lpdiCDParams->dwcUsers = 1;
                }

                if( SUCCEEDED(hres) )
                {
                    //call the framework
                    hres = pDIAcFrame->lpVtbl->ConfigureDevices
                                            (
                                            pDIAcFrame,
                                            lpdiCallback,
                                            lpdiCDParams,
                                            dwFlags,
                                            pvRefData);

                    if( SUCCEEDED(hres) )
                    {
                        SquirtSqflPtszV( sqfl | sqflVerbose,
                            TEXT("Default Remapping UI returned 0x%08x"), hres );
                    }
                    else
                    {
                        SquirtSqflPtszV( sqfl | sqflError,
                            TEXT("Default Remapping UI returned error 0x%08x"), hres );
                    }

                    //release pwsUserName, if we have used it
                    FreePpv(&pwszUserName);
                }

                FreeLibrary( hinst );
            }
        }
    }

    ExitOleProc();
    return hres;
}




STDMETHODIMP CDIObj_ConfigureDevicesW
(
PV                                                          pDiW,
LPDICONFIGUREDEVICESCALLBACK                                lpdiCallback,
LPDICONFIGUREDEVICESPARAMSW                                 lpdiCDParams,
DWORD                                                       dwFlags,
LPVOID                                                      pvRefData
)
{
    HRESULT hres = S_OK;


    EnterProcR(IDirectInput8::ConfigureDevices,
               (_ "pppxp", pDiW, lpdiCallback,lpdiCDParams, dwFlags, pvRefData));
               
    //validate all the ptrs
    if ( (SUCCEEDED(hres = hresPvI(pDiW, ThisInterfaceW)) &&
         (SUCCEEDED(hres = hresFullValidReadPvCb(lpdiCDParams, sizeof(DICONFIGUREDEVICESPARAMSW), 2))) &&
         ((lpdiCDParams->lptszUserNames == NULL) || (SUCCEEDED(hres = hresFullValidReadStrW((LPWSTR)(lpdiCDParams->lptszUserNames), MAX_JOYSTRING * (lpdiCDParams->dwcUsers), 2)))) &&
    (SUCCEEDED(hres = hresFullValidReadPvCb(lpdiCDParams->lprgFormats, lpdiCDParams->dwcFormats*sizeof(DIACTIONFORMATW), 2)))))
    {

    if( lpdiCDParams->dwSize != cbX(DICONFIGUREDEVICESPARAMSW) )
        {
            RPF("IDirectInput::%s: Invalid DICONFIGUREDEVICESPARAMSW.dwSize 0x%08x",
                lpdiCDParams->dwSize ); 
            hres = E_INVALIDARG;
        }

        if (SUCCEEDED(hres))
    {

        PDDI this = _thisPvNm(pDiW, diW);

        //params structure
        DICONFIGUREDEVICESPARAMSW diconfparamsW;
        //to translate each DIACTIONFORMAT
        LPDIACTIONFORMATW* lpDiAfW = NULL;
        //the cloning array of DIACTIONFORMATs
        LPDIACTIONFORMATW* lpDAFW = NULL;
        //to traverse the old array
        LPDIACTIONFORMATW lpDIFormat;
        //to traverse the new array
        LPDIACTIONFORMATW lpDIF;
        //user names
        LPWSTR lpUserNames = NULL;
        //DIACTIONFORMATs cloned
        DWORD clonedF = 0;
        //length of user names
        DWORD strLen = 0;
    
        //zero out
        ZeroMemory(&diconfparamsW, sizeof(DICONFIGUREDEVICESPARAMSW));
        //set the size
        diconfparamsW.dwSize = sizeof(DICONFIGUREDEVICESPARAMSW);


        //1. Validate and translate each LPDIACTIONFORMAT in the array
        lpDIFormat = (lpdiCDParams->lprgFormats);
        //allocate the new array
        hres = AllocCbPpv(lpdiCDParams->dwcFormats * sizeof(DIACTIONFORMATW), &diconfparamsW.lprgFormats);
        if (FAILED(hres))
        { 
            goto cleanup;
        }
        lpDIF = diconfparamsW.lprgFormats;
        //allocate the cloning array
        hres = AllocCbPpv(lpdiCDParams->dwcFormats * sizeof(DIACTIONFORMATW), &lpDAFW);
        if (FAILED(hres))
        { 
            goto cleanup;
        }
        lpDiAfW = lpDAFW;
        //clone
        for (clonedF = 0; clonedF < lpdiCDParams->dwcFormats; clonedF ++)
        {
                //validate
            hres = IsValidMapObjectW(lpDIFormat D(comma s_szProc comma 2));
            if (FAILED(hres))
            {
                goto cleanup;
            }
            //translate
            hres = DiActionFormatWtoW(lpDIFormat, lpDiAfW); 
            if (FAILED(hres))
            {
                goto cleanup;
            }
            //save
            *lpDIF = *(*lpDiAfW);
            //move on
            lpDIFormat++;
            lpDiAfW++;
            lpDIF++;
        }
        //if everything went fine, should have cloned all
        AssertF(clonedF == lpdiCDParams->dwcFormats);

        //2. Copy the user names
        if (lpdiCDParams->lptszUserNames != NULL)
        {
            DWORD countN;
            WCHAR* lpName = lpdiCDParams->lptszUserNames;
            for (countN = 0; countN < lpdiCDParams->dwcUsers; countN ++)
            {
                DWORD Len;
                hres = hresFullValidReadStrW(lpName, MAX_JOYSTRING, 2);
                if (FAILED(hres))
                {
                    goto cleanup;
                }
                Len = lstrlenW(lpName);
                //if length is 0  -- and we haven't reached the correct user count yet -
                //then it is an error
                if (Len == 0)
                {
                    hres = DIERR_INVALIDPARAM;
                    goto cleanup;
                }
                //move on to the next user name
                strLen += Len + 1;
                lpName += Len + 1;
            }
            //if everything went fine, should have traversed all the user names
            AssertF(countN == lpdiCDParams->dwcUsers);
            //allocate
                        hres = AllocCbPpv( (strLen + 1) * 2, &lpUserNames );
                if (FAILED(hres))
                        {
                goto cleanup;
                        }
            //copy
                memcpy(lpUserNames, lpdiCDParams->lptszUserNames, strLen*2);
            diconfparamsW.lptszUserNames = lpUserNames;
         }
  

        //3. Populate the rest of the structure
        diconfparamsW.dwcUsers = lpdiCDParams->dwcUsers;
        diconfparamsW.dwcFormats = clonedF;
        diconfparamsW.hwnd = lpdiCDParams->hwnd;
        diconfparamsW.dics = lpdiCDParams->dics;
        diconfparamsW.lpUnkDDSTarget = lpdiCDParams->lpUnkDDSTarget;
                
        //4. Call the framework
        hres = CDIObj_ConfigureDevicesCore
                        (
                        &this->diW,
                        lpdiCallback,
                        &diconfparamsW,
                        dwFlags,
                        pvRefData);

cleanup:;

        //free the space for the new array
        FreePpv(&diconfparamsW.lprgFormats);
        //free as many DIACTIONFORMATs as were created
        if (lpDAFW)
        {
            lpDiAfW = lpDAFW;
            for (clonedF; clonedF > 0; clonedF--)
            {
                FreeDiActionFormatW(lpDiAfW);
                lpDiAfW++;      
            }
            //delete the entire block
            FreePpv(&lpDAFW);
        }

        //delete the user names
        FreePpv(&lpUserNames);

         }
    }

    ExitOleProc();
    return(hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DiActionFormatAtoW |
 *
 *          Copies LPDIACTIONFORMATA to  LPDIACTIONFORMATW
 *
 *  @parm   const LPDIACTIONFORMATA | lpDiAfA | 
 *
 *          Original.
 *
 *  @parm   LPDIACTIONFORMATW* | lplpDiAfW |
 *
 *          Address of a pointer to a <t DIACTIONFORMATW> that receives the converted
 *          ACTIONFORMAT.
 *  @returns
 *
 *          Standard OLE <t HRESULT>.
 *
 *****************************************************************************/

HRESULT EXTERNAL DiActionFormatAtoW
(
const LPDIACTIONFORMATA lpDiAfA,
LPDIACTIONFORMATW* lplpDiAfW
)
{
    DWORD cbAlloc;
    PDWORD pdwStrLen, pdwStrLen0;
    LPDIACTIONFORMATW lpDiAfW;
    LPDIACTIONA lpDiAA;
    LPDIACTIONW lpDiAW;
    DWORD i;
    HRESULT hres;

    EnterProcI(DiActionFormatAtoW, (_ "xx", lpDiAfA, lplpDiAfW));

    // Internal function, no validation

    *lplpDiAfW = NULL;

    /*
     *  PREFIX complains (mb:37926 - item 2) that we could be requesting a 
     *  zero byte allocation which would not allocate anything.  This is 
     *  never the case because CDIDev_ActionMap_IsValidMapObject tests that 
     *  dwNumActions is less than 2^24.  Assert in debug for extra safety.
     */
    AssertF( (lpDiAfA->dwNumActions +1)*cbX(*pdwStrLen0) );
    hres = AllocCbPpv( (lpDiAfA->dwNumActions +1)*cbX(*pdwStrLen0) , &pdwStrLen0);

    if ( SUCCEEDED(hres) )
    {
        // Compute the amount of memory required to clone the DIACTIONFORMATA
        cbAlloc =
        /* 1: The wide form of the Action Format array */
        cbX(DIACTIONFORMATW)
        /* 2: Each of the DIACTION arrays */
        + lpDiAfA->dwActionSize * lpDiAfA->dwNumActions;

        pdwStrLen = pdwStrLen0;

        // Compute the size for each of the text strings in array of DIACTIONs
        for ( i = 0x0, lpDiAA = lpDiAfA->rgoAction;
            i < lpDiAfA->dwNumActions ;
            i++, lpDiAA++ )
        {
            // Handle the NULL ptr case
            if ( NULL != lpDiAA->lptszActionName )
            {
                /* 3: Text string in each DIACTION array*/
                // Conversion from A to U, need  multiplier
                // ISSUE-2001/03/29-timgill (MarcAnd), A to U conversions are not always 1 to 1.
                *pdwStrLen =  lstrlenA(lpDiAA->lptszActionName) + 1;
                cbAlloc += cbX(lpDiAW->lptszActionName[0]) * ( *pdwStrLen++ );
            }
        }

        if ( SUCCEEDED( hres = AllocCbPpv(cbAlloc, &lpDiAfW) ) )
        {
            DWORD dwLen;
            DWORD cb;

            pdwStrLen = pdwStrLen0;

            // 1: Copy the DIACTIONFORMAT
            /*
             *  Assert that the structure can be copied as:
             *      a)  dwSize
             *      b)  everything else
             *      c)  the app name
             */
            CAssertF( FIELD_OFFSET( DIACTIONFORMATW, dwSize ) == 0 );
            CAssertF( FIELD_OFFSET( DIACTIONFORMATA, dwSize ) == 0 );

            CAssertF( FIELD_OFFSET( DIACTIONFORMATW, dwSize ) + cbX( ((LPDIACTIONFORMATW)0)->dwSize )
                   == FIELD_OFFSET( DIACTIONFORMATW, dwActionSize ) );
            #if defined(_WIN64)
                CAssertF( ( ( cbX( DIACTIONFORMATW ) - cbX( ((LPDIACTIONFORMATW)0)->tszActionMap ) )
                          - ( cbX( DIACTIONFORMATA ) - cbX( ((LPDIACTIONFORMATA)0)->tszActionMap ) ) 
                        < MAX_NATURAL_ALIGNMENT ) );
            #else
                CAssertF( ( cbX( DIACTIONFORMATW ) - cbX( ((LPDIACTIONFORMATW)0)->tszActionMap ) )
                       == ( cbX( DIACTIONFORMATA ) - cbX( ((LPDIACTIONFORMATA)0)->tszActionMap ) ) );
            #endif

            CAssertF( FIELD_OFFSET( DIACTIONFORMATW, tszActionMap ) 
                   == FIELD_OFFSET( DIACTIONFORMATA, tszActionMap ) );
            CAssertF( cA( ((LPDIACTIONFORMATW)0)->tszActionMap ) == cA( ((LPDIACTIONFORMATA)0)->tszActionMap ) );

            //  Init counts and lpDiAfW fields 
            dwLen = lpDiAfA->dwActionSize * lpDiAfA->dwNumActions;
            cb = lpDiAfW->dwSize = cbX(DIACTIONFORMATW);

            memcpy( &lpDiAfW->dwActionSize, &lpDiAfA->dwActionSize, 
                FIELD_OFFSET( DIACTIONFORMATW, tszActionMap ) - FIELD_OFFSET( DIACTIONFORMATW, dwActionSize ) );

            AToU(lpDiAfW->tszActionMap,  cbX(lpDiAfA->tszActionMap), lpDiAfA->tszActionMap);


            // 2: Block copy the DIACTION array
            CAssertF(cbX(*lpDiAfW->rgoAction) == cbX(*lpDiAfA->rgoAction) )
            lpDiAfW->rgoAction = (LPDIACTIONW)( (char*)lpDiAfW + cb);
            dwLen = lpDiAfA->dwActionSize * lpDiAfA->dwNumActions;
            memcpy(lpDiAfW->rgoAction, lpDiAfA->rgoAction, dwLen);
            cb += dwLen;

            // 3: ActionName
            // Convert each of the strings in the ACTION array  from A to W
            for ( i = 0x0, lpDiAA=lpDiAfA->rgoAction, lpDiAW=lpDiAfW->rgoAction;
                i < lpDiAfW->dwNumActions ;
                i++, lpDiAA++, lpDiAW++ )
            {
                if ( lpDiAA->lptszActionName != NULL )
                {
                    WCHAR* wsz =  (WCHAR*) ((char*)lpDiAfW+cb);
                    lpDiAW->lptszActionName = wsz;

                    dwLen = (*pdwStrLen++);

                    AToU( wsz, dwLen, lpDiAA->lptszActionName);

                    cb += dwLen * cbX(lpDiAW->lptszActionName[0]) ;
                } else
                {
                    //  Resource strings are handled in DiActionFormatWtoW
                    //  OK for now, as long as UI always uses CloneDiActionFormatW
                    lpDiAW->lptszActionName = NULL;
                }
            }


            // If we have not done something goofy, the memory allocates should match
            // the memory we used
            AssertF(cbAlloc == cb );
            *lplpDiAfW = lpDiAfW;

        }
        FreePpv(&pdwStrLen0);
    }

    ExitOleProc();
    return(hres);
}


STDMETHODIMP CDIObj_ConfigureDevicesA
(
PV                                                          pDiA,
LPDICONFIGUREDEVICESCALLBACK                                lpdiCallback,
LPDICONFIGUREDEVICESPARAMSA                                 lpdiCDParams,
DWORD                                                       dwFlags,
LPVOID                                                      pvRefData
)
{

    HRESULT hres = S_OK;

    EnterProcR(IDirectInput8::ConfigureDevices,
               (_ "pppxp", pDiA, lpdiCallback, lpdiCDParams, dwFlags, pvRefData));

    /*
     *  ConfigureDevicesCore will validate the rest.
     */
    if ( (SUCCEEDED(hres = hresPvI(pDiA, ThisInterfaceA)) &&
          (SUCCEEDED(hres = hresFullValidReadPvCb(lpdiCDParams, sizeof(DICONFIGUREDEVICESPARAMSA), 2)) &&
          ((lpdiCDParams->lptszUserNames == NULL) || (SUCCEEDED(hres = hresFullValidReadStrA((LPSTR)(lpdiCDParams->lptszUserNames), MAX_JOYSTRING * (lpdiCDParams->dwcUsers), 2)))) &&
      (SUCCEEDED(hres = hresFullValidReadPvCb(lpdiCDParams->lprgFormats, lpdiCDParams->dwcFormats*sizeof(DIACTIONFORMATA), 2))))))

    {

        if( lpdiCDParams->dwSize != cbX(DICONFIGUREDEVICESPARAMSA) )
        {
            RPF("IDirectInput::%s: Invalid DICONFIGUREDEVICESPARAMSA.dwSize 0x%08x",
                lpdiCDParams->dwSize );
            hres = E_INVALIDARG;
        }


    if (SUCCEEDED(hres))
    {

        PDDI this = _thisPvNm(pDiA, diA);

        //params structure
        DICONFIGUREDEVICESPARAMSW diconfparamsW;
        //to translate each DIACTIONFORMAT
        LPDIACTIONFORMATW* lpDiAfW = NULL;
        //the new array of DIACTIONFORMATs
        LPDIACTIONFORMATW* lpDAFW = NULL;
        //to traverse the old array
        LPDIACTIONFORMATA lpDIFormat;
        //to traverse the new array
        LPDIACTIONFORMATW lpDIF;
        //to keep the new user name
        LPWSTR lpUserNames = NULL;
        //to know how many DIACTIONFORMATS we have cloned successfully
        DWORD clonedF = 0;
        //kength of user names string
        DWORD strLen = 0;

        //zero out
        ZeroMemory(&diconfparamsW, sizeof(DICONFIGUREDEVICESPARAMSW));
        //set the size
        diconfparamsW.dwSize = sizeof(DICONFIGUREDEVICESPARAMSW);

        //1. Validate and translate each LPDIACTIONFORMAT in the array
        lpDIFormat = (lpdiCDParams->lprgFormats);
        //allocate the new array
        hres = AllocCbPpv(lpdiCDParams->dwcFormats * sizeof(DIACTIONFORMATW), &diconfparamsW.lprgFormats);
        if (FAILED(hres))
        { 
            goto cleanup;
        }
        lpDIF = diconfparamsW.lprgFormats;
        //allocate the cloning array
        hres = AllocCbPpv(lpdiCDParams->dwcFormats * sizeof(DIACTIONFORMATW), &lpDAFW);
        if (FAILED(hres))
        { 
            goto cleanup;
        }
        lpDiAfW = lpDAFW;
        //clone
        for (clonedF = 0; clonedF < lpdiCDParams->dwcFormats; clonedF ++)
        {
                //validate
            hres = IsValidMapObjectA(lpDIFormat D(comma s_szProc comma 2));
            if (FAILED(hres))
            {
                goto cleanup;
            }
            //translate
            hres = DiActionFormatAtoW(lpDIFormat, lpDiAfW); 
            if (FAILED(hres))
            {
                goto cleanup;
            }
            //save
            *lpDIF = *(*lpDiAfW);
            //move on
            lpDIFormat++;
            lpDiAfW++;
            lpDIF++;
        }
        //if everything went fine, should have cloned all
        AssertF(clonedF == lpdiCDParams->dwcFormats);       
                 
        
        //2. Copy the user names
        if (lpdiCDParams->lptszUserNames != NULL)
        {
            DWORD countN;
            DWORD Len;
            //to traverse new user names
            WCHAR* lpNameW;
            CHAR* lpName = lpdiCDParams->lptszUserNames;
            //go throught all the user names
            for ( countN = 0; countN < lpdiCDParams->dwcUsers; countN ++)
            {  
                hres = hresFullValidReadStrA(lpName, MAX_JOYSTRING, 2);
                if (FAILED(hres))
                {
                    goto cleanup;
                }
                Len = lstrlenA(lpName);
                //if length is 0  -- and we haven't reached the correct user count yet -
                //then it is an error
                if (Len == 0)
                {
                    hres = DIERR_INVALIDPARAM;
                    goto cleanup;
                }
                //move on to the next user name
                strLen += Len + 1;
                lpName += Len + 1;
            }   
            //if everything went fine, should have traversed all the user names
            AssertF(countN == lpdiCDParams->dwcUsers);
            //allocate
            hres = AllocCbPpv( (strLen + 1) * 2, &lpUserNames );
            if (FAILED(hres))
            {
                goto cleanup;
            }
            //translate
            //AToU stops at the first '\0', so we have to go in a loop
            lpName = lpdiCDParams->lptszUserNames;
            lpNameW = lpUserNames;
            //go throught all the user names
            for ( countN = 0; countN < lpdiCDParams->dwcUsers; countN ++)
            {  
                Len = lstrlenA(lpName);
                AToU(lpNameW, Len + 1, lpName);
                lpName += Len + 1;
                lpNameW += Len + 1;
            }
            //save
            diconfparamsW.lptszUserNames = lpUserNames;
        }

                
        //3. Populate the rest of the structure
        diconfparamsW.dwcUsers = lpdiCDParams->dwcUsers;
        diconfparamsW.dwcFormats = clonedF;
        diconfparamsW.hwnd = lpdiCDParams->hwnd;
        diconfparamsW.dics = lpdiCDParams->dics;
        diconfparamsW.lpUnkDDSTarget = lpdiCDParams->lpUnkDDSTarget;
                        
        //4.Call the framework
        hres = CDIObj_ConfigureDevicesCore
                        (
                        &this->diW,
                        lpdiCallback,
                        &diconfparamsW,
                        dwFlags,
                        pvRefData);
    
        


cleanup:;

        //free the sapce for the array
        FreePpv(&diconfparamsW.lprgFormats);
        //free as many DIACTIONFORMATs as were created
        if (lpDAFW)
        {
            lpDiAfW = lpDAFW;
            for (clonedF; clonedF > 0; clonedF--)
            {
                FreeDiActionFormatW(lpDiAfW);
                lpDiAfW++;      
            }
            //delete the entire block
            FreePpv(&lpDAFW);
        }    
        //free the user names, if allocated
        FreePpv(&lpUserNames);
    }
    }

    ExitOleProc();
    return(hres);
}


/*****************************************************************************
 *
 *      The long-awaited vtbls and templates
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define CDIObj_Signature        0x504E4944      /* "DINP" */

Interface_Template_Begin(CDIObj)
Primary_Interface_Template(CDIObj, TFORM(ThisInterfaceT))
Secondary_Interface_Template(CDIObj, SFORM(ThisInterfaceT))
Interface_Template_End(CDIObj)

Primary_Interface_Begin(CDIObj, TFORM(ThisInterfaceT))
TFORM(CDIObj_CreateDevice),
TFORM(CDIObj_EnumDevices),
TFORM(CDIObj_GetDeviceStatus),
TFORM(CDIObj_RunControlPanel),
TFORM(CDIObj_Initialize),
TFORM(CDIObj_FindDevice),
TFORM(CDIObj_EnumDevicesBySemantics),
TFORM(CDIObj_ConfigureDevices),
Primary_Interface_End(CDIObj, TFORM(ThisInterfaceT))

Secondary_Interface_Begin(CDIObj, SFORM(ThisInterfaceT), SFORM(di))
SFORM(CDIObj_CreateDevice),
SFORM(CDIObj_EnumDevices),
SFORM(CDIObj_GetDeviceStatus),
SFORM(CDIObj_RunControlPanel),
SFORM(CDIObj_Initialize),
SFORM(CDIObj_FindDevice),
SFORM(CDIObj_EnumDevicesBySemantics),
SFORM(CDIObj_ConfigureDevices),
Secondary_Interface_End(CDIObj, SFORM(ThisInterfaceT), SFORM(di))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dioledup.c ===
/*****************************************************************************
 *
 *  DIOleDup.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Functions that sort-of duplicate what OLE does.
 *
 *  Contents:
 *
 *      DICoCreateInstance
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflOleDup


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | _CreateInstance |
 *
 *          Worker function for <f DICoCreateInstance>.
 *
 *  @parm   REFCLSID | rclsid |
 *
 *          The <t CLSID> to create.
 *
 *  @parm   LPCTSTR | ptszDll |
 *
 *          The name of the DLL to load.
 *
 *  @parm   LPUNKNOWN | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   RIID | riid |
 *
 *          Interface to obtain.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Receives a pointer to the created object if successful.
 *
 *  @parm   HINSTANCE * | phinst |
 *
 *          Receives the instance handle of the in-proc DLL that was
 *          loaded.  <f FreeLibrary> this DLL when you are finished
 *          with the object.
 *
 *          Note that since we don't implement a binder, this means
 *          that you cannot give the returned pointer away to anybody
 *          you don't control; otherwise, you won't know when to
 *          free the DLL.
 *
 *  @returns
 *
 *          Standard OLE status code.
 *
 *****************************************************************************/

HRESULT INTERNAL
_CreateInstance(REFCLSID rclsid, LPCTSTR ptszDll, LPUNKNOWN punkOuter,
                RIID riid, PPV ppvOut, HINSTANCE *phinst)
{
    HRESULT hres;
    HINSTANCE hinst;

    hinst = LoadLibrary(ptszDll);
    if (hinst) {
        LPFNGETCLASSOBJECT DllGetClassObject;

        DllGetClassObject = (LPFNGETCLASSOBJECT)
                            GetProcAddress(hinst, "DllGetClassObject");

        if (DllGetClassObject) {
            IClassFactory *pcf;

            hres = DllGetClassObject(rclsid, &IID_IClassFactory, &pcf);
            if (SUCCEEDED(hres)) {
                hres = pcf->lpVtbl->CreateInstance(pcf, punkOuter,
                                                   riid, ppvOut);
                pcf->lpVtbl->Release(pcf);

                /*
                 *  Some people forget to adhere to
                 *  the OLE spec, which requires that *ppvOut be
                 *  set to zero on failure.
                 */
                if (FAILED(hres)) {
                    if (*ppvOut) {
                        RPF("ERROR! CoCreateInstance: %s forgot to zero "
                            "out *ppvOut on failure path", ptszDll);
                    }
                    *ppvOut = 0;
                }

            }
        } else {
            /*
             *  DLL does not export GetClassObject.
             */
            hres = REGDB_E_CLASSNOTREG;
        }

        if (SUCCEEDED(hres)) {
            *phinst = hinst;
        } else {
            FreeLibrary(hinst);
        }
    } else {
        /*
         *  DLL does not exist.
         */
        hres = REGDB_E_CLASSNOTREG;
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DICoCreateInstance |
 *
 *          Private version of CoCreateInstance that doesn't use OLE.
 *
 *  @parm   LPTSTR | ptszClsid |
 *
 *          The string version of the <t CLSID> to create.
 *
 *  @parm   LPUNKNOWN | punkOuter |
 *
 *          Controlling unknown for aggregation.
 *
 *  @parm   RIID | riid |
 *
 *          Interface to obtain.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Receives a pointer to the created object if successful.
 *
 *  @parm   HINSTANCE * | phinst |
 *
 *          Receives the instance handle of the in-proc DLL that was
 *          loaded.  <f FreeLibrary> this DLL when you are finished
 *          with the object.
 *
 *          Note that since we don't implement a binder, this means
 *          that you cannot give the returned pointer away to anybody
 *          you don't control; otherwise, you won't know when to
 *          free the DLL.
 *
 *  @returns
 *
 *          Standard OLE status code.
 *
 *****************************************************************************/

STDMETHODIMP
DICoCreateInstance(LPTSTR ptszClsid, LPUNKNOWN punkOuter,
                   RIID riid, PPV ppvOut, HINSTANCE *phinst)
{
    HRESULT hres;
    CLSID clsid;
    EnterProcI(DICoCreateInstance, (_ "spG", ptszClsid, punkOuter, riid));

    *ppvOut = 0;
    *phinst = 0;

    if (ParseGUID(&clsid, ptszClsid)) {
        HKEY hk;
        LONG lRc;
        TCHAR tszKey[ctchGuid + 40];    /* 40 is more than enough */

        /*
         *  Look up the CLSID in HKEY_CLASSES_ROOT.
         */
        wsprintf(tszKey, TEXT("CLSID\\%s\\InProcServer32"), ptszClsid);

        lRc = RegOpenKeyEx(HKEY_CLASSES_ROOT, tszKey, 0,
                           KEY_QUERY_VALUE, &hk);
        if (lRc == ERROR_SUCCESS) {
            TCHAR tszDll[MAX_PATH];
            DWORD cb;

            cb = cbX(tszDll);
            lRc = RegQueryValue(hk, 0, tszDll, &cb);

            if (lRc == ERROR_SUCCESS) {
                TCHAR tszModel[20];     /* more than enough */

                lRc = RegQueryString(hk, TEXT("ThreadingModel"),
                                     tszModel, cA(tszModel));
                if (lRc == ERROR_SUCCESS &&
                    ((lstrcmpi(tszModel, TEXT("Both"))==0x0) ||
                     (lstrcmpi(tszModel, TEXT("Free"))==0x0))) {

                    hres = _CreateInstance(&clsid, tszDll, punkOuter,
                                           riid, ppvOut, phinst);

                } else {
                    /*
                     *  No threading model or bad threading model.
                     */
                    hres = REGDB_E_CLASSNOTREG;
                }
            } else {
                /*
                 *  No InprocServer32.
                 */
                hres = REGDB_E_CLASSNOTREG;
            }

            RegCloseKey(hk);

        } else {
            /*
             *  CLSID not registered.
             */
            hres = REGDB_E_CLASSNOTREG;
        }
    } else {
        /*
         *  Invalid CLSID string.
         */
        hres = REGDB_E_CLASSNOTREG;
    }

    ExitOleProcPpv(ppvOut);
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diriff.h ===
#ifndef __RIFF_H__
#define __RIFF_H__
/****************************************************************************

	MODULE:     	RIFF.H
	Tab settings: 	Every 4 spaces

	Copyright 1996, Microsoft Corporation, 	All Rights Reserved.

	PURPOSE:    	Classes for reading and writing RIFF files
    
	CLASSES:
		CRIFFFile	Encapsulates common RIFF file functionality

	Author(s):	Name:
	----------	----------------
		DMS		Daniel M. Sangster

	Revision History:
	-----------------
	Version Date            Author  Comments
	1.0  	25-Jul-96       DMS     Created

	COMMENTS:
****************************************************************************/


// the four-character codes (FOURCC) needed for .FRC RIFF format

#define FCC_FORCE_EFFECT_RIFF		mmioFOURCC('F','O','R','C')

#define FCC_INFO_LIST				mmioFOURCC('I','N','F','O')
#define FCC_INFO_NAME_CHUNK			mmioFOURCC('I','N','A','M')
#define FCC_INFO_COMMENT_CHUNK		mmioFOURCC('I','C','M','T')
#define FCC_INFO_SOFTWARE_CHUNK		mmioFOURCC('I','S','F','T')
#define FCC_INFO_COPYRIGHT_CHUNK	mmioFOURCC('I','C','O','P')

#define FCC_TARGET_DEVICE_CHUNK		mmioFOURCC('t','r','g','t')

#define FCC_TRACK_LIST				mmioFOURCC('t','r','a','k')

#define FCC_EFFECT_LIST				mmioFOURCC('e','f','c','t')
#define FCC_ID_CHUNK				mmioFOURCC('i','d',' ',' ')
#define FCC_DATA_CHUNK				mmioFOURCC('d','a','t','a')
#define FCC_IMPLICIT_CHUNK			mmioFOURCC('i','m','p','l')
#define FCC_SPLINE_CHUNK			mmioFOURCC('s','p','l','n')

#define MAX_SIZE_SNAME              (64)

HRESULT RIFF_Open
    (
    LPCSTR          lpszFilename,
    UINT            nOpenFlags,
    PHANDLE         lphmmio,
    LPMMCKINFO      lpmmck,
    PDWORD          pdwEffectSize
    );

HRESULT
    RIFF_ReadEffect
    (
    HMMIO           hmmio, 
    LPDIFILEEFFECT  lpDiFileEf 
    );


HRESULT RIFF_WriteEffect
    (
     HMMIO          hmmio,
     LPDIFILEEFFECT lpDiFileEf
     );


HRESULT RIFF_Close
    (
    HMMIO           hmmio, 
    UINT            nFlags
    );

#endif //__RIFF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diport.c ===
/*****************************************************************************
 *
 *  DIPort.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Support functions for Gameport/Serialport enumeration.
 *
 *  Contents:
 *
 *
 *
 *****************************************************************************/

#include "dinputpr.h"

/*
 * We can reuse some code from diHidEnm.c
 */
#define DIPort_GetDevicePath(hdev, pdid, didd, dinf) \
        DIHid_GetDevicePath(hdev, pdid, didd, dinf)

#define DIPort_GetDeviceInstanceId(hdev, pdinf, tszId) \
        DIHid_GetDeviceInstanceId(hdev, pdinf, tszId)

#define DIPort_GetInstanceGUID(hk, lpguid)  \
        DIHid_GetInstanceGUID(hk, lpguid)

#define DIPort_GetRegistryProperty(ptszId, dwProperty, pdiph)    \
        DIHid_GetRegistryProperty(ptszId, dwProperty, pdiph)

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#undef  sqfl
#define sqfl sqflPort

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global PBUSDEVICE | g_pBusDevice |
 *
 *          List of known GamePort/SerialPort devices.
 *
 *****************************************************************************/

static BUSDEVICE g_pBusDevice[] =
{
    {
        D(TEXT("GamePort Bus") comma)
        NULL,
        &GUID_GAMEENUM_BUS_ENUMERATOR,
        0x0,
        IOCTL_GAMEENUM_EXPOSE_HARDWARE,
        IOCTL_GAMEENUM_REMOVE_HARDWARE,
        IOCTL_GAMEENUM_PORT_DESC,
        IOCTL_GAMEENUM_PORT_PARAMETERS,
        IOCTL_GAMEENUM_EXPOSE_SIBLING,
        IOCTL_GAMEENUM_REMOVE_SELF,
        IDS_STDGAMEPORT,
        JOY_HWS_ISGAMEPORTBUS
    },

    /***************
    No defination for serial port devices yet !
    {
        D(TEXT("SerialPort Bus") comma )
        NULL,
        &GUID_SERENUM_BUS_ENUMERATOR,
        0x0,
        IOCTL_SERIALENUM_EXPOSE_HARDWARE,
        IOCTL_SERIALENUM_REMOVE_HARDWARE,
        IOCTL_SERIALENUM_PORT_DESC,
        IOCTL_SERIALENUM_PORT_PARAMETERS,
        IOCTL_SERIALENUM_EXPOSE_SIBLING,
        IOCTL_SERIALENUM_REMOVE_SELF,
        IDS_STDSERIALPORT,
        JOY_HWS_ISSERIALPORTBUS
    },
    ****************/
};


#pragma BEGIN_CONST_DATA

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL INTERNAL | SearchDevTree |
 *
 *          Helper routine that searches the device tree for
 *          a desired device device.
 *
 *  @parm   IN DEVINST | dnStart |
 *          Starting point for the search.
 *
 *  @parm   IN DEVINST | dnSeek |
 *          The device instance we are looking for.
 *
 *  @parm   IN PULONG   | pRecurse |
 *          To limit the number of recursions.
 *
 *  @returns    BOOL
 *          True on success.
 *
 *****************************************************************************/
CONFIGRET INTERNAL
    SearchDevTree
    (
    DEVINST dnStart,
    DEVINST dnSeek,
    PUINT   pRecurse
    )
{
#define MAX_RECURSION   ( 4 )

    CONFIGRET   cr;

    EnterProcI(SearchDevTree, (_"xxx", dnStart, dnSeek, pRecurse));

    cr = CR_SUCCESS;
    for( *pRecurse = 0x0; *pRecurse < MAX_RECURSION && cr == CR_SUCCESS; (*pRecurse)++)
    {
        cr = CM_Get_Parent(&dnSeek, dnSeek, 0 );
        if( dnStart == dnSeek )
        {
            break;  
        }
    }    
    if( dnStart != dnSeek )
    {
        cr = CR_NO_SUCH_DEVNODE;
    }
#undef MAX_RECURSION

#if 0 // Using Recursion 
    if( *pRecurse > MAX_RECURSION )
    {
        return CR_NO_SUCH_DEVNODE;
    }

    if( dnSeek == dnStart )
    {
        return CR_SUCCESS;
    }

    do
    {
        DEVINST dnNode;

        cr = CM_Get_Child(&dnNode, dnStart, 0 );
        if( cr == CR_SUCCESS )
        {
            CAssertF(CR_SUCCESS == 0x0 );
            if( CR_SUCCESS == SearchDevTree(dnNode, dnSeek, pRecurse) )
            {
                return cr;
            }
        }
        cr = CM_Get_Sibling(&dnStart, dnStart, 0);

    }while( cr == CR_SUCCESS );
#endif  // No recursion 

    return cr;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PBUSDEVICEINFO | pbdiFromphdi |
 *
 *          Locates Gameport/Serialport information given a device instance of
 *          one of its children.
 *          Returns NULL if the device instance is not a child of
 *          any known gameports/serialports
 *
 *          Internal Routine, parameters already validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN PHIDDEVICEINFO | phdi |
 *
 *          Address of a HIDDEVICEINFO structure
 *
 *  @returns
 *
 *          Pointer to the <t BUSDEVICEINFO> that describes
 *          the parent bus.
 *
 *****************************************************************************/
PBUSDEVICEINFO INTERNAL
    pbdiFromphdi
    (
    IN PHIDDEVICEINFO phdi
    )
{
    PBUSDEVICEINFO pbdi_Found;
    PBUSDEVICE     pBusDevice;
    int iBusType;

    EnterProcI(pbdiFromphdi, (_"x", phdi));

    AssertF(InCrit());
    AssertF(phdi != NULL );

    pbdi_Found = NULL;
    for( iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice) && pbdi_Found == NULL;
       iBusType++, pBusDevice++ )
    {
        HDEVINFO hdev;
        /*
         *  Now talk to SetupApi to get info about the device.
         */
        hdev = SetupDiCreateDeviceInfoList(NULL, NULL);

        if(hdev != INVALID_HANDLE_VALUE  )
        {
            SP_DEVINFO_DATA dinf_hid;

            ZeroX(dinf_hid);

            dinf_hid.cbSize = cbX(SP_DEVINFO_DATA);

            /* Get SP_DEVINFO_DATA for the HID device */
            if( pBusDevice->pbdl != NULL  &&
                phdi!= NULL  &&
                SetupDiOpenDeviceInfo(hdev, phdi->ptszId, NULL, 0, &dinf_hid))
            {
                int igdi;
                PBUSDEVICEINFO pbdi;
                SP_DEVINFO_DATA dinf_bus;

                ZeroX(dinf_bus);

                dinf_bus.cbSize = cbX(SP_DEVINFO_DATA);

                /*
                 * Loop through all known gameports/serialports and look for a gameport/serialport
                 * that is a parent of the HID device
                 */

                for(igdi = 0, pbdi = pBusDevice->pbdl->rgbdi;
                   igdi < pBusDevice->pbdl->cgbi && pbdi_Found == NULL ;
                   igdi++, pbdi++)
                {
                    if(SetupDiOpenDeviceInfo(hdev, pbdi->ptszId, NULL, 0, &dinf_bus))
                    {
                        ULONG Recurse = 0x0;
                        if( CR_SUCCESS == SearchDevTree(dinf_bus.DevInst, dinf_hid.DevInst, &Recurse) )
                        {
                            pbdi_Found = pbdi;
                            break;
                        }
                    }
                }
            }
            SetupDiDestroyDeviceInfoList(hdev);
        }
    }
    ExitProcX((UINT_PTR)pbdi_Found);
    return pbdi_Found;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PBUSDEVICEINFO | pbdiFromGUID |
 *
 *          Locates Gameport/Serialport information given a device instance of
 *          one of its children.
 *          Returns NULL if the device instance is not a child of
 *          any known gameports/serialports
 *
 *          Internal Routine, parameters already validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN PCGUID | pguid |
 *
 *          The instance GUID to be located.
 *
 *  @returns
 *
 *          Pointer to the <t BUSDEVICEINFO> that describes
 *          the parent bus.
 *
 *****************************************************************************/
PBUSDEVICEINFO EXTERNAL
    pbdiFromGUID
    (
    IN PCGUID pguid
    )
{
    PBUSDEVICEINFO pbdi_Found;
    PBUSDEVICE     pBusDevice;
    int iBusType;

    EnterProcI(pbdiFromGUID, (_"G", &pguid));

    AssertF(InCrit());

    pbdi_Found = NULL;
    for( iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice) && pbdi_Found == NULL;
       iBusType++, pBusDevice++ )
    {
        /*
         * Loop through all known gameports/serialports and look for a gameport/serialport
         * that is a parent of the HID device
         */
        PBUSDEVICEINFO pbdi;
        int igdi;
        for(igdi = 0, pbdi = pBusDevice->pbdl->rgbdi;
           igdi < pBusDevice->pbdl->cgbi && pbdi_Found == NULL ;
           igdi++, pbdi++)
        {
            if( IsEqualGUID(pguid, &pbdi->guid)  )
            {
                pbdi_Found = pbdi;
            }
        }
    }
    ExitProcX((UINT_PTR)pbdi_Found);
    return pbdi_Found;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFrompbdi |
 *
 *          Locates a HID device attached to a given Gameport/Serialport
 *          Returns NULL if no devices are currently attached to a known port.
 *
 *          Internal Routine, parameters already validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN PBUSDEVICEINFO | pbdi |
 *
 *          Address of the <t BUSDEVICEINFO> structure that
 *          describes the gameport/serialport.
 *
 *  @returns
 *
 *          Pointer to one of the <t HIDDEVICEINFO> that describes
 *          the device. ( Gamport may have multiple devices attached ).
 *
 *****************************************************************************/

PHIDDEVICEINFO INTERNAL
    phdiFrompbdi
    (
    IN PBUSDEVICEINFO pbdi
    )
{
    PHIDDEVICEINFO phdi_Found;
    HDEVINFO hdev;

    EnterProcI(phdiFrompbdi, (_"x", pbdi));

    AssertF(InCrit());
    AssertF(pbdi != NULL );

    /* Enumurate the HID devices */
    DIHid_BuildHidList(TRUE);

    phdi_Found = NULL;
    /*
     *  Now talk to SetupApi to get info about the device.
     */
    hdev = SetupDiCreateDeviceInfoList(NULL, NULL);

    if(hdev != INVALID_HANDLE_VALUE)
    {
        SP_DEVINFO_DATA dinf_bus;

        dinf_bus.cbSize = cbX(SP_DEVINFO_DATA);

        if( pbdi != NULL && SetupDiOpenDeviceInfo(hdev, pbdi->ptszId, NULL, 0, &dinf_bus))
        {
            int ihdi;
            PHIDDEVICEINFO phdi;
            SP_DEVINFO_DATA dinf_hid;
            dinf_hid.cbSize = cbX(SP_DEVINFO_DATA);

            if( g_phdl )
            {
                for(ihdi = 0, phdi = g_phdl->rghdi ;
                   ihdi < g_phdl->chdi && phdi_Found == NULL ;
                   ihdi++, phdi++)
                {
                    if(SetupDiOpenDeviceInfo(hdev, phdi->ptszId, NULL, 0, &dinf_hid))
                    {
                        ULONG Recurse = 0x0;
                        if(CR_SUCCESS == SearchDevTree(dinf_bus.DevInst, dinf_hid.DevInst, &Recurse) )
                        {
                            phdi_Found = phdi;
                        }
                    }
                }
            }
        }
        SetupDiDestroyDeviceInfoList(hdev);
    }

    ExitProcX((UINT_PTR)phdi_Found);
    return phdi_Found;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   PPORTDEVICEINFO | pbdiFromJoyId |
 *
 *          Locates Gameport/Serialport information given a device id of
 *          a joystick .
 *
 *          Returns NULL if the device instance is not a child of
 *          any known gameports/serialports
 *
 *          Internal Routine, parameters already validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN int | idJoy |
 *
 *          The Joystick ID of the child device that will be associated
 *          to a known gameport/serialport.
 *
 *  @returns
 *
 *          Pointer to the <t BUSDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PBUSDEVICEINFO EXTERNAL
    pbdiFromJoyId
    (
    IN int idJoy
    )
{
    GUID guid;
    HRESULT hres;
    PBUSDEVICEINFO pbdi;

    EnterProcI(pbdiFromJoyId, (_"x", idJoy));
    AssertF(InCrit());

    pbdi = NULL;

    /* Find the GUID that corresponds to the Joystick ID */
    hres = hResIdJoypInstanceGUID_WDM(idJoy, &guid);
    
#ifndef WINNT
    if( FAILED(hres) ) {
        hres = hResIdJoypInstanceGUID_95(idJoy, &guid);
    }
#endif

    if( SUCCEEDED(hres) )
    {
        PHIDDEVICEINFO phdi;
        phdi = phdiFindHIDInstanceGUID(&guid);

        if( phdi != NULL )
        {
            pbdi = pbdiFromphdi(phdi);
        }
    }

    ExitProcX((UINT_PTR)pbdi);
    return pbdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIBusDevice_Expose |
 *
 *  Attaches a gameport/serialport device to the Gameport/SerialPort Bus
 *
 *  @parm   IN PBUSDEVICEINFO | pbdi |
 *          Address of a BUSDEVICEINFO structure.
 *
 *  @parm   IN OUT PBUS_REGDATA    | pRegData |
 *          Gameport/Serialport specific data. The Handle to the opened device
 *          is returned in this structure
 *
 *
 *  @returns
 *          BOOL. True indicates success.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    DIBusDevice_Expose
    (
    IN     PBUSDEVICEINFO  pbdi,
    IN OUT PBUS_REGDATA    pRegData
    )
{
    HRESULT hres;
    BOOL frc;
    PHIDDEVICEINFO  phdi;

    EnterProcI(DIBusDevice_Expose, (_ "pp", pbdi, pRegData));

    AssertF(DllInCrit() );
    AssertF(pbdi!= NULL );

    phdi = phdiFrompbdi(pbdi);

    if( pRegData && pRegData->dwSize != cbX(*pRegData) )
    {
        hres = E_INVALIDARG;
    } else if( phdi != NULL )
    {
        hres = E_ACCESSDENIED;
    } else
    {
        HANDLE hf;

        /* There is a weird condition where the HID device does not appear on a previous
         * Add, (drivers not loaded, user cancelled loading of some files, etc
         * In such cases we need to tell GameEnum to remove the device before proceeding
         * any further
         */
        if( pbdi->fAttached || pRegData->hHardware != NULL )
        {
            DIBusDevice_Remove(pbdi);
        }
        AssertF(pbdi->fAttached == FALSE);

        // Open a File handle to the gameport/serialport device so we can send it IOCTLS
        hf = CreateFile(pbdi->pdidd->DevicePath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0,                /* no SECURITY_ATTRIBUTES */
                        OPEN_EXISTING,
                        0,                /* attributes */
                        0);               /* template */

        if( hf != INVALID_HANDLE_VALUE )
        {
            DWORD cbRc;
            GAMEENUM_PORT_DESC  Desc;
            Desc.Size = cbX(Desc) ;

            Sleep(50);  //need sleep a while to wait for the device is ready to accept commands.
            
            /* Get the gameport bus properties */
            frc = DeviceIoControl (hf,
                                   pbdi->pBusDevice->ioctl_DESC,
                                   &Desc, cbX(Desc),
                                   &Desc, cbX(Desc),
                                   &cbRc, NULL);
            if( frc  && cbRc == cbX(Desc) )
            {
                PGAMEENUM_EXPOSE_HARDWARE pExpose;
                DWORD cbExpose;
                cbExpose = cbX(*pExpose) + cbX(pRegData->wszHardwareId);

                hres = AllocCbPpv( cbExpose, & pExpose);

                if( SUCCEEDED(hres ) )
                {
                    typedef struct _OEMDATA
                    {
                        ULONG   uVID_uPID;
                        ULONG   joy_hws_dwFlags;
                        ULONG   dwFlags1;
                        ULONG   Reserved;
                    } OEMDATA, *POEMDATA;

                    POEMDATA    pOemData = (POEMDATA)(&pExpose->OemData);
                    CAssertF(2*sizeof(*pOemData) == sizeof(pExpose->OemData))

                    pOemData->uVID_uPID = MAKELONG(pRegData->uVID, pRegData->uPID);
                    pOemData->joy_hws_dwFlags = pRegData->hws.dwFlags;
                    pOemData->dwFlags1 = pRegData->dwFlags1;

                    /*
                     *  Make sure only known analog devices cause the 
                     *  compatible hardware ID to be exposed.
                     *  This is done so that no in-box drivers will match for 
                     *  an unsupported digital joystick so users will be 
                     *  prompted to use an unsigned IHV driver rather than 
                     *  silently loading the generic analog joystick driver.
                     */
                    if( ( pRegData->dwFlags1 & JOYTYPE_ANALOGCOMPAT )
                     || ( ( pRegData->uVID == MSFT_SYSTEM_VID )
                       && ( ( pRegData->uPID & 0xff00 ) == MSFT_SYSTEM_PID ) ) )
                    {
                        pExpose->Flags = GAMEENUM_FLAG_COMPATIDCTRL;
                    }
                    else
                    {
                        pExpose->Flags = GAMEENUM_FLAG_COMPATIDCTRL | GAMEENUM_FLAG_NOCOMPATID ;
                    }

                    pExpose->Size            = cbX(*pExpose) ;
                    pExpose->PortHandle      = Desc.PortHandle;
                    pExpose->NumberJoysticks = pRegData->nJoysticks;

                    pRegData->nAxes          = 2;

                    if( pExpose->NumberJoysticks != 2 )
                    {
                        AssertF( pExpose->NumberJoysticks == 1);
                        if( pRegData->hws.dwFlags & JOY_HWS_HASZ )
                        {
                            pRegData->nAxes++;
                        }
                        if( pRegData->hws.dwFlags & JOY_HWS_HASR )
                        {
                            pRegData->nAxes++;
                        }
                        pExpose->NumberButtons   = (USHORT)pRegData->hws.dwNumButtons;
                    }
                    else
                    {
                        pOemData++;
                        pOemData->uVID_uPID = MAKELONG(pRegData->uVID, pRegData->uPID);
                        pOemData->joy_hws_dwFlags = JOY_HWS_XISJ2X | JOY_HWS_YISJ2Y;
                        pExpose->NumberButtons = 2;
                    }

                    pExpose->NumberAxis = pRegData->nAxes;

                    /*
                     *  The SideWinder driver uses the OEMData field in a 
                     *  sibling expose to pass internal data (this ptrs) from 
                     *  one instance to another.  Since these fields are 
                     *  supposed to be for the OEMData we have a Flags1 field 
                     *  to allow the data to be zeroed for a DInput expose for 
                     *  drivers that don't want the normal data.
                     */

                    if ( pRegData->dwFlags1 & JOYTYPE_ZEROGAMEENUMOEMDATA )                      
                    {
                        ZeroBuf(pExpose->OemData, sizeof(pExpose->OemData) );
                    }

                    CopyMemory(pExpose->HardwareIDs, pRegData->wszHardwareId, cbX(pRegData->wszHardwareId) );

                    Sleep(50);

                    if( frc = DeviceIoControl (hf,
                                               pbdi->pBusDevice->ioctl_EXPOSE,
                                               pExpose, cbExpose,
                                               pExpose, cbExpose,
                                               &cbRc, NULL )
                        && cbRc == cbExpose )
                    {
                        PVOID hHardwareOld = pRegData->hHardware;

                        pbdi->fAttached = TRUE;
                        pRegData->hHardware = pExpose->HardwareHandle;
                        DIBusDevice_SetRegData(pbdi->hk,  pRegData);

                        /*
                         * If we have dealt with this device before then the hHardwareOld
                         * will be non null, and we have sufficient reason to believe that the
                         * expose will succeed.
                         *
                         * This test needs to be removed to fix manbug: 39554. 
                         * For new created device, we need wait for a while to let phdi be ready.
                         * 
                         */
                        //if(hHardwareOld)
                        {
                            int i;

                            for(i = 0; (i < 20) && (phdiFrompbdi(pbdi) == NULL); i++ )
                            {
                                Sleep(50);
                            }
                        }

                    } else // DeviceIOControl (EXPOSE) Failed
                    {
                        hres = E_FAIL;
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%S: IOCTL_PORTENUM_EXPOSE_HARDWARE failed  ")
                                        TEXT("Error = %d"),
                                        s_szProc, GetLastError());
                    }
                    FreePpv(&pExpose);
                } else // Alloc failed
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: AllocCbPpv  failed  "),
                                    s_szProc);
                }
            } else // IOCTL FAILED
            {
                hres = E_FAIL;
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%S: IOCTL_PORTENUM_PORT_DESC failed ")
                                TEXT("Error = %d"),
                                s_szProc, GetLastError());
            }

            CloseHandle(hf);
        } else
        {
            hres = E_FAIL;
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%S: CreateFile(%s) failed  ")
                            TEXT("Error = %d"),
                            s_szProc, pbdi->pdidd->DevicePath, GetLastError());
        }
    }
    ExitBenignProcX(hres);

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIBusDevice_Remove |
 *
 *  Removes the FDO for a gameport/serialport device.
 *
 *  @parm   IN HANDLE | hf |
 *          Handle to the GamePort/SerialPort Bus device file object
 *
 *  @parm   IN PPORT_REGDATA    | pRegData |
 *          Structure that contains registry data. What we need from here is the
 *          handle to the hardware.
 *
 *  @returns
 *          BOOL. True for success.
 *
 *****************************************************************************/

HRESULT INTERNAL
    DIBusDevice_Remove
    (
    IN PBUSDEVICEINFO  pbdi
    )
{
    HRESULT hres;
    BUS_REGDATA RegData;

    EnterProcI(DIBus_Remove, (_ "p", pbdi));

    hres = DIBusDevice_GetRegData(pbdi->hk,  &RegData);

    //
    //  Delete our registry goo, so this device
    //  will not show up on subsequent reboots
    //
    DIBusDevice_SetRegData(pbdi->hk,  NULL);

    if( SUCCEEDED(hres) )
    {
        HANDLE hf;
        BOOL frc;

        // Open a File handle to the gameport/serialport device so we can send it IOCTLS
        hf = CreateFile(pbdi->pdidd->DevicePath,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        0,                /* no SECURITY_ATTRIBUTES */
                        OPEN_EXISTING,
                        0,                /* attributes */
                        0);               /* template */

        if( hf != INVALID_HANDLE_VALUE )
        {

            DWORD cbRc;
            GAMEENUM_REMOVE_HARDWARE Remove;

            Remove.Size = cbX(Remove);
            Remove.HardwareHandle = RegData.hHardware;

            frc = DeviceIoControl (hf,
                                   pbdi->pBusDevice->ioctl_REMOVE,
                                   &Remove, cbX(Remove),
                                   &Remove, cbX(Remove),
                                   &cbRc, NULL) ;
            if( frc &&  cbRc == cbX(Remove) )
            {
                pbdi->fAttached = FALSE;
            } else // DeviceIoControl ( REMOVE_HARDWARE ) Failed
            {
                hres = E_FAIL;
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%S: DeviceIOControl(REMOVE_HARDWARE) failed  ")
                                TEXT("Error = %d"),
                                s_szProc, GetLastError());
            }
            CloseHandle(hf);
        }
    }

    ExitBenignOleProc();

    return hres;
}




/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIPort_SetRegData |
 *
 *          Sets up registry data under the $hk$/Config subkey for the gameport
 *          device.
 *
 *  @parm   IN HKEY | hk |
 *          A handle to the parent key where the registry data will be written.
 *
 *  @parm   IN PGAMEPORT_REGDATA | pRegData |
 *          Pointer to a structure containing data to be written to the registry.
 *
 *  @returns
 *          BOOL. True for success
 *
 *****************************************************************************/
HRESULT INTERNAL
    DIBusDevice_SetRegData
    (
    IN HKEY hk,
    IN PBUS_REGDATA pRegData
    )
{
    LONG    lrc;
    HRESULT hres = S_OK;

    EnterProcI(DIPort_SetRegData, (_ "xpx", hk, pRegData ));

    if( pRegData != NULL )
    {

        if( ( lrc =  RegSetValueEx(hk, TEXT("Config"), 0, REG_BINARY,
                                   (PV) (pRegData), cbX(*pRegData)) )  == ERROR_SUCCESS )
        {
            hres = S_OK;
        } else // RegSetValueEx FAILED
        {
            hres = E_FAIL;
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("%S: RegSetValueEx() failed ")
                            TEXT("Error = %d"),
                            s_szProc, lrc);
        }
    } else
    {
        lrc = RegDeleteValue(hk, TEXT("Config"));
    }

    ExitOleProc();
    return (hres);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIPort_GetRegData |
 *
 *          Gets registry data from the $hk$/Config subkey for the gameport
 *          device.
 *
 *  @parm   IN HKEY | hk |
 *          A handle to the parent key where the registry.
 *
 *  @parm   IN PGAMEPORT_REGDATA | pRegData |
 *          Address of a pointer to the structure where the registry data
 *          will be read into.
 *
 *  @returns
 *          HRESULT
 *****************************************************************************/
HRESULT INTERNAL
    DIBusDevice_GetRegData
    (
    IN HKEY hk,
    OUT PBUS_REGDATA pRegData
    )
{
    LONG    lRc;
    DWORD cb;
    HRESULT hres;

    EnterProcI(DIPort_GetRegData, (_ "xpx", hk, pRegData ));

    cb = cbX(*pRegData);

    lRc = RegQueryValueEx( hk, TEXT("Config"), 0, 0 , (PV)(pRegData), &cb );

    if( lRc == ERROR_SUCCESS && pRegData->dwSize == cbX(*pRegData ) )
    {
        hres = S_OK;
    } else
    {
        DIBusDevice_SetRegData(hk, NULL );
        ZeroX(*pRegData);
        hres = E_FAIL;

        SquirtSqflPtszV(sqfl | sqflBenign,
                        TEXT("%S: RegQueryValueEx(Config) failed ")
                        TEXT("Error = %d, ( pRegData->cbSize(%d) == cbX(*pRegData)(%d)) "),
                        s_szProc, lRc, pRegData->dwSize, cbX(*pRegData) );
    }

    ExitBenignOleProc();
    return ( hres ) ;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIBus_BuildListEntry |
 *
 *          Builds a single entry in the list of GAMEPORT/SERIALPORT devices.
 *
 *  @parm   HDEVINFO | hdev |
 *
 *          Device list being enumerated.
 *
 *  @parm   PSP_DEVICE_INTERFACE_DATA | pdid |
 *
 *          Describes the device that was enumerated.
 *
 *  @returns
 *
 *          Nonzero on success.
 *
 *****************************************************************************/

BOOL INTERNAL
    DIBusDevice_BuildListEntry
    (
    HDEVINFO hdev,
    PSP_DEVICE_INTERFACE_DATA pdid,
    PBUSDEVICE pBusDevice
    )
{
    BOOL fRc = TRUE;
    //HKEY hkDev;
	HKEY hkDin;
    PBUSDEVICEINFO pbdi;
    PBUSDEVICELIST pbdl;
    PSP_DEVICE_INTERFACE_DETAIL_DATA pdidd;
    BOOL    fAlreadyExist;

    HRESULT hres;

    EnterProcI(DIBus_BuildListEntry, (_ "xp", hdev, pdid));

    pbdl = pBusDevice->pbdl;

    fAlreadyExist = FALSE;

    /* GetDevicePath is expecting a NULL */
    pdidd = NULL;
    
    if( DIPort_GetDevicePath(hdev, pdid, &pdidd, NULL) )
    {
        int ibdi;
        //Check whether the device has been in the list
        for( ibdi = 0; ibdi < pbdl->cgbi; ibdi++)
        {
            if( pbdl->rgbdi[ibdi].pdidd )
            {
                if( lstrcmp( pdidd->DevicePath, pbdl->rgbdi[ibdi].pdidd->DevicePath ) == 0 )
                {
                    //already in the list
                    fAlreadyExist = TRUE;
                    break;
                }
            }
        }
        FreePpv(&pdidd);
    }

    if( fAlreadyExist == TRUE )
    {
        fRc = TRUE;
    } else
    {
        /*
         *  Make sure there is room for this device in the list.
         *  Grow by doubling.
         */
        if( pbdl->cgbi >= pbdl->cgbiAlloc)
        {
            /*
             *  Assert that we never ask for zero bytes here
             */
            AssertF( cbGdlCbdi( pbdl->cgbiAlloc * 2) );
            hres = ReallocCbPpv( cbGdlCbdi( pbdl->cgbiAlloc * 2), &pBusDevice->pbdl );
            if( FAILED(hres) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%S: Realloc failed"), s_szProc);
                fRc = FALSE;
                goto done;
            }
            /*
             *  Prefix warns (Win:170673) that pBusDevice->pbdl could be zero 
             *  if we asked for zero bytes above but the size requested cannot 
             *  be zero so this has been asserted.  Note the fix for (W:45084) 
             *  was incorrect so it has been removed.
             */
            pbdl = pBusDevice->pbdl;
            pbdl->cgbiAlloc *= 2;
        }

        AssertF( pbdl->cgbi < pbdl->cgbiAlloc);
        pbdi        = &pbdl->rgbdi[pbdl->cgbi];
        pbdi->pBusDevice = pBusDevice;
        pbdi->hk    = 0;
        pbdi->idJoy = JOY_BOGUSID;

        /*
         *  Open the registry key for the device so we can obtain
         *  auxiliary information.
         */
        {
			//Open our own reg key under MediaProperties/DirectInput,
			//creating it if necessary.
			hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
								   REGSTR_PATH_DITYPEPROP,
								   DI_KEY_ALL_ACCESS, 
								   REG_OPTION_NON_VOLATILE, 
								   &hkDin);
			if (SUCCEEDED(hres))
			{
				//Create the Gameports reg key
				HKEY hkGameports;
				hres = hresMumbleKeyEx(hkDin,
									   TEXT("Gameports"),
									   DI_KEY_ALL_ACCESS,
									   REG_OPTION_NON_VOLATILE,
									   &hkGameports);
				if (SUCCEEDED(hres))
				{
					//Create a reg key corresponding to the instance number.
					//Since we do this for every gameport enumerated, the number in the list
					//indicates the instance number.
					TCHAR tszInst[3];
					wsprintf(tszInst, TEXT("%u"), pbdl->cgbi);

					hres = hresMumbleKeyEx(hkGameports,
									   tszInst,
									   DI_KEY_ALL_ACCESS,
									   REG_OPTION_NON_VOLATILE,
									   &pbdi->hk);

					if(SUCCEEDED(hres))
					{
						SP_DEVINFO_DATA dinf;
						dinf.cbSize = cbX(SP_DEVINFO_DATA);

						/*
						 *  Get the instance GUID and the path to
						 *  the GAMEPORT/SERIALPORT device so we can talk to it.
						 */
						if(DIPort_GetDevicePath(hdev, pdid, &pbdi->pdidd, &dinf) &&
						   DIPort_GetDeviceInstanceId(hdev, &dinf, &pbdi->ptszId) &&
						   DIPort_GetInstanceGUID(pbdi->hk, &pbdi->guid) )
						{
							HANDLE hf;
							hf = CreateFile(pbdi->pdidd->DevicePath,
											GENERIC_READ | GENERIC_WRITE,
											FILE_SHARE_READ | FILE_SHARE_WRITE,
											0,                /* no SECURITY_ATTRIBUTES */
											OPEN_EXISTING,
											0,                /* attributes */
											0);               /* template */

							if( hf != INVALID_HANDLE_VALUE )
							{

								BUS_REGDATA  RegData;
								ZeroX(RegData);

								CloseHandle(hf);

								// Bump up the counter
								fRc = TRUE;
								pbdl->cgbi++;

								hres = DIBus_InitId(pBusDevice->pbdl);

								if( SUCCEEDED(hres) )
								{
									hres = DIBusDevice_GetRegData(pbdi->hk, &RegData);
								}

								if(  SUCCEEDED(hres)  )
								{
									/* There is a pathological case which can cause endless bluescreen's
									 * If the HID driver causes a bluescreen, and we keep reattaching
									 * it, we are sunk !!
									 * To guard against this possiblity we reattach a device on reboot
									 * only if we are sure that it succeeded the first time around
									 */
									if( RegData.fAttachOnReboot == FALSE )
									{
										DIBusDevice_Remove(pbdi);

										SquirtSqflPtszV(sqfl | sqflError,
														TEXT("%S: DIPortDevice_Expose FAILED, ")
														TEXT("Driver did not load property the first time around "),
														s_szProc);
									} else if( pbdi->fAttached == FALSE )
									{
										hres = DIBusDevice_Expose( pbdi,  &RegData );
										if( SUCCEEDED( hres ) || hres == E_ACCESSDENIED )
										{
											pbdi->fAttached = TRUE;
										} else
										{
											SquirtSqflPtszV(sqfl | sqflError,
															TEXT("%S: DIPortDevice_Expose FAILED ")
															TEXT("hres = %d"),
															s_szProc, hres);
										}
									}
								}

							} else
							{
								fRc = FALSE;

								SquirtSqflPtszV(sqfl | sqflError,
												TEXT("%S: CreateFile(%s) failed  ")
												TEXT("Error = %d"),
												s_szProc, pbdi->pdidd->DevicePath, GetLastError());
							}

						} else
						{
							SquirtSqflPtszV(sqfl | sqflError,
											TEXT("%S: Unable to get device path"),
											s_szProc);
							pbdi->hk = 0x0;
							fRc = FALSE;
						}

						/*
						 *  If we failed, then free the goo we already got.
						 */
						if(!fRc)
						{
							if( pbdi->hk )
								RegCloseKey(pbdi->hk);
							pbdi->hk = 0;
							FreePpv(&pbdi->pdidd);
							FreePpv(&pbdi->ptszId);
							fRc = FALSE;
						}

					} else
					{
						SquirtSqflPtszV(sqfl | sqflError,
										TEXT("%S: RegCreateKeyEx failed on Instance, error "),
										s_szProc);
						fRc = FALSE;
					}

					RegCloseKey(hkGameports);

				} else // RegCreateKeyEx FAILED
				{
					SquirtSqflPtszV(sqfl | sqflError,
									TEXT("%S: RegCreateKeyEx failed on Gameports, error "),
									s_szProc);
					fRc = FALSE;
				}

				RegCloseKey(hkDin);
			}
			else
			{
				SquirtSqflPtszV(sqfl | sqflError,
									TEXT("%S: RegOpenKeyEx failed on DirectInput"),
									s_szProc);
				fRc = FALSE;
			}

        } 
    }
    done:;
    ExitProcF(fRc);
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | DIPort_EmptyList |
 *
 *          Empty the list of GAMEPORT/SERIALPORT devices.
 *
 *          This function must be called under the DLL critical section.
 *
 *****************************************************************************/

void INTERNAL
    DIBus_EmptyList
    (
    PBUSDEVICELIST *ppbdl
    )
{
    PBUSDEVICELIST pbdl = *ppbdl;

    AssertF(InCrit());

    if( pbdl )
    {
        int igdi;
        for(igdi = 0; igdi < pbdl->cgbi; igdi++)
        {
            FreePpv(&pbdl->rgbdi[igdi].pdidd);
            FreePpv(&pbdl->rgbdi[igdi].ptszId);
            if( pbdl->rgbdi[igdi].hk)
            {
                RegCloseKey( pbdl->rgbdi[igdi].hk);
            }
        }
        /*
         *  We invalidated all the pointers, so make sure
         *  nobody looks at them.
         */
        pbdl->cgbi = 0;
        FreePpv(&pbdl);
        *ppbdl = NULL;
    }
}

void EXTERNAL
    DIBus_FreeMemory()
{
    int iBusType;
    PBUSDEVICE pBusDevice;

    for( iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice);
       iBusType++, pBusDevice++ )
    {
        DIBus_EmptyList(&pBusDevice->pbdl);
    }
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | DIPort_InitId |
 *
 *          Initializes Joystick IDs for JoyConfig and legacy APIs
 *          Store the joystick IDs the registry under the %%DirectX/JOYID key.
 *
 *****************************************************************************/

#undef  PORTID_BOGUS
#define PORTID_BOGUS    ( 0xffffffff )

HRESULT EXTERNAL
    DIBus_InitId(PBUSDEVICELIST pbdl)
{
    HRESULT hres = FALSE;
    LONG    lRc;
    DWORD   cb;
    int     igdi;
    BOOL    fNeedId;
    BOOL    rfPortId[cgbiMax];     /* Bool Array for to determine which IDs are in use */
    PBUSDEVICEINFO pbdi;

    EnterProcI(DIBus_InitId, (_ ""));

    fNeedId = FALSE;

    AssertF(DllInCrit());

    ZeroX(rfPortId );


    if( pbdl != NULL )
    {
        /* Iterate over to find used IDs */
        for( igdi = 0, pbdi = pbdl->rgbdi ;
           igdi < pbdl->cgbi ;
           igdi++, pbdi++ )
        {
            pbdi->idPort = PORTID_BOGUS;  // Default
        
            cb = cbX(pbdi->idPort);
            if( ( lRc = RegQueryValueEx(pbdi->hk, TEXT("ID"),
                                        0, 0, (PV)&pbdi->idPort, &cb) == ERROR_SUCCESS ) )
            {
                if(    rfPortId[pbdi->idPort]           // Collision in GameId
                       || pbdi->idPort > cgbiMax  )       // Wrror
                {
                    pbdi->idPort = PORTID_BOGUS;
                    fNeedId = TRUE;
                } else  // Valid idPort
                {
                    rfPortId[pbdi->idPort] = TRUE;

                }
            } else // RegQueryValue("ID") does not exist
            {
                fNeedId = TRUE;
            }
        }

        if( fNeedId )
        {
            /*
             * We have Examined all GamePort/SerialPort Ids found used IDs
             * and determined some device needs an Id
             */
            /* Iterate to assign unused Id's */
            for( igdi = 0, pbdi = pbdl->rgbdi;
               igdi < pbdl->cgbi ;
               igdi++, pbdi++ )
            {
                if( pbdi->idPort == PORTID_BOGUS  )
                {
                    /* Get an Unused ID */
                    for( pbdi->idPort = 0x0;
                       pbdi->idPort < cgbiMax;
                       pbdi->idPort++ )
                    {
                        if( rfPortId[pbdi->idPort] == FALSE )
                            break;
                    }
                    rfPortId[pbdi->idPort] = TRUE;

                    if( lRc = RegSetValueEx(pbdi->hk, TEXT("ID"), 0, REG_BINARY,
                                            (PV)&pbdi->idPort, cbX(pbdi->idPort)) == ERROR_SUCCESS )
                    {

                    } else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%S: RegSetValueEx(JOYID) FAILED ")
                                        TEXT("Error = %d"),
                                        s_szProc, lRc);
                        hres = FALSE;
                    }
                }
            }
        }
    }

    ExitOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIBus_CheckList |
 *
 *          Check the list of HID devices and free any that cannot be opened
 *
 *          This function must be called under the DLL critical section.
 *
 *****************************************************************************/

void INTERNAL
    DIBus_CheckList(PBUSDEVICELIST pbdl)
{
    HANDLE hf;

    AssertF(InCrit());

    /*
     *  Free all the information of the device that cannot be opened
     */
    if(pbdl)
    {
        int ibdi;

        PBUSDEVICEINFO pbdi;
        for(ibdi = 0, pbdl->cgbi = 0; ibdi < pbdl->cgbiAlloc; ibdi++)
        {
            pbdi = &pbdl->rgbdi[ibdi];
            if( pbdi && pbdi->pdidd )
            {
                /*
                 *  Open the device
                 */
                hf = CreateFile(pbdi->pdidd->DevicePath,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                0,                /* no SECURITY_ATTRIBUTES */
                                OPEN_EXISTING,
                                0,                /* attributes */
                                0);               /* template */

                if(hf == INVALID_HANDLE_VALUE)
                {
                    FreePpv(&pbdi->pdidd);
                    FreePpv(&pbdi->ptszId);
                    if(pbdi->hk)
                    {
                        RegCloseKey(pbdi->hk);
                    }
                    ZeroX( pbdi );
                } else
                {
                    pbdl->cgbi++;
                    CloseHandle(hf);
                }
            }
        }

        //re-order the existing devices, put them at the front of the hid list.
        for(ibdi = 0; ibdi < pbdl->cgbi; ibdi++)
        {
            if( !pbdl->rgbdi[ibdi].pdidd )
            {
                int ibdi2;

                //find the existing device from the biggest index in the hid list.
                for( ibdi2 = pbdl->cgbiAlloc; ibdi2 >= ibdi+1; ibdi2-- )
                {
                    if( pbdl->rgbdi[ibdi2].pdidd )
                    {
                        memcpy( &pbdl->rgbdi[ibdi], &pbdl->rgbdi[ibdi2], sizeof(BUSDEVICEINFO) );
                        ZeroX( pbdl->rgbdi[ibdi2] );
                    }
                }
            }
        }

    }

    return;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   void | DIBus_BuildList |
 *
 *          Builds the list of GAMEPORT/SERIALPORT devices.
 *
 *  @parm   BOOL | fForce |
 *
 *          If nonzero, we force a rebuild of the GAMEPORT/SERIALPORT list.
 *          Otherwise, we rebuild only if the list hasn't
 *          been rebuilt recently.
 *
 *****************************************************************************/

#define MSREBUILDRATE       20000                /* Twenty seconds */

ULONG EXTERNAL
    DIBus_BuildList( IN BOOL fForce )
{
    HRESULT hres;
    PBUSDEVICE pBusDevice;
    ULONG cDevices;
    int iBusType;
    DWORD    dwTickCount;

    EnterProcI(DIBus_BuildList, (_ "u", fForce));

    DllEnterCrit();

    /*
     *  Decide whether or not to rebuild once (don't want to half rebuild)
     */
    dwTickCount = GetTickCount();

    // Force implies a complete rebuild of the list. 
    if(fForce) 
    {
        DIBus_FreeMemory();
    }
    
    DIHid_BuildHidList(fForce);

    hres = S_OK;
    for( cDevices = iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice);
       iBusType++, pBusDevice++ )
    {
        PBUSDEVICELIST pbdl;
        pbdl = pBusDevice->pbdl;

        if( HidD_GetHidGuid &&                          /* HID support */
            ( fForce ||                                 /* Forcing rebuild, or */
              pBusDevice->tmLastRebuild == 0 ||         /* Never built before, or */
              dwTickCount - pBusDevice->tmLastRebuild > MSREBUILDRATE )
          )
        {
            HDEVINFO hdev;

            /* delete devices that disappeared since we last looked */
            DIBus_CheckList(pbdl);

            hdev = SetupDiGetClassDevs((LPGUID)pBusDevice->pcGuid, 0, 0,
                                       DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);

            if(hdev != INVALID_HANDLE_VALUE)
            {
                /*
                 *  There is no way to query the number of devices.
                 *  You just have to keep incrementing until you run out.
                 *
                 *  If we already have a pbdl, then re-use it.  Else, create
                 *  a new one.  Alloc up to the minimum starting point.
                 */

                if( pBusDevice->pbdl == NULL )
                {
                    /*
                     *  Prefix warns that we leak this memory (mb:34688) but 
                     *  we keep a reference in our global list so we can free 
                     *  the memory when we're done with it.
                     */
                    hres = AllocCbPpv(cbGdlCbdi(cgbiInit), &pBusDevice->pbdl );

                    if(SUCCEEDED(hres))
                    {
                        pbdl = pBusDevice->pbdl;
                        pbdl->cgbi = 0;
                        pbdl->cgbiAlloc = cgbiInit;
                    }
                }

                if( SUCCEEDED(hres) )
                {
                    int idev;

                    /*
                     *  To avoid infinite looping on
                     *  internal *boo-boo's*, break on any
                     *  error once we have tried more than
                     *  cgbiMax devices, since that's the most
                     *  GAMEPORT/SERIALPORT will ever give us.
                     */
                    for(idev = 0; idev < cgbiMax; idev++)
                    {
                        SP_DEVICE_INTERFACE_DATA did;

                        AssertF( pbdl->cgbi <= pbdl->cgbiAlloc);

                        /* 
                         *  Note, pnp.c doesn't initialize this so we have to
                         */
                        did.cbSize = cbX(did);
                        if(SetupDiEnumDeviceInterfaces(hdev, 0, (LPGUID)pBusDevice->pcGuid,
                                                       idev, &did))
                        {
                            if(DIBusDevice_BuildListEntry(hdev, &did, &g_pBusDevice[iBusType] ))
                            {
                                //pbdl->cgbi++;
                            } else
                            {
                                /* Skip erroneous items */
                                SquirtSqflPtszV(sqfl | sqflError,
                                                TEXT("DIBus_BuildListEntry ")
                                                TEXT("failed?"));
                            }

                        } else

                            if(GetLastError() == ERROR_NO_MORE_ITEMS)
                        {
                            break;

                        } else
                        {
                            /* Skip erroneous items */
                            SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("SetupDiEnumDeviceInterface ")
                                            TEXT("failed? le=%d"), GetLastError());
                        }

                    }

                }

                SetupDiDestroyDeviceInfoList(hdev);
                pBusDevice->tmLastRebuild = GetTickCount();
            }
        }

        if(pbdl) { cDevices += pbdl->cgbi; }
    }
    
    /* New gameport devices may be exposed. Pick them up too */
    DIHid_BuildHidList(FALSE);
    
    DllLeaveCrit();
    ExitProc();
    return (cDevices);
}

PBUSDEVICELIST EXTERNAL
    pbdlFromGUID
    (
    IN PCGUID pcGuid
    )
{
    PBUSDEVICELIST  pbdl_Found = NULL;
    PBUSDEVICE      pBusDevice;
    int iBusType;

    for( iBusType = 0x0, pBusDevice = g_pBusDevice;
       iBusType < cA(g_pBusDevice);
       iBusType++, pBusDevice++ )
    {
        if( IsEqualGUID(pBusDevice->pcGuid, pcGuid) )
        {
            pbdl_Found = pBusDevice->pbdl;
            break;
        }
    }
    return pbdl_Found;
}




/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIBusDevice_ExposeEx |
 *
 *          Attache a HID device to all available ports.
 *
 *  @parm   IN HANDLE | hf |
 *          Handle the the Gameport/SerialPort File object
 *
 *  @parm   IN OUT PBUS_REGDATA    | pRegData |
 *          Gameport/Serialport specific data. The Handle to the opened device
 *          is returned in this structure
 *
 *
 *  @returns
 *          BOOL. True indicates success.
 *
 *****************************************************************************/
HRESULT EXTERNAL
    DIBusDevice_ExposeEx
    (
    IN PBUSDEVICELIST  pbdl,
    IN PBUS_REGDATA    pRegData
    )
{
    HRESULT hres, hres1;
    int ibdi;

    EnterProcI(DIBusDevice_ExposeEx, (_ "xx", pbdl, pRegData));

    /*
     * The return code a little strange for this function
     * If the Expose succeeds for any gameport then
     * we will return that error code.
     * If the expose fails for all gameports,
     * then we will return the amalgam of
     * all the error codes.
     */
    if( pbdl->cgbi == 0x0 )
    {
        hres = hres1 = DIERR_DEVICENOTREG;
    } else
    {
        hres = S_OK;
    }
    
    for( ibdi = 0x0; ibdi < pbdl->cgbi; ibdi++)
    {
        HRESULT hres0;
        PBUSDEVICEINFO   pbdi;

        hres1 = hres0 = DIERR_DEVICENOTREG;

        pbdi = &(pbdl->rgbdi[ibdi]);

        if( pbdi->fAttached == FALSE )
        {
            pbdi->fDeleteIfNotConnected = TRUE;

            hres0 = DIBusDevice_Expose(pbdi, pRegData);
            if( FAILED(hres0) )
            {
                hres |= hres0;
            } else
            {
                hres1 = hres0;
            }
        } else {
        	hres = DIERR_DEVICEFULL;
        }
    }

    if(SUCCEEDED(hres1))
    {
        hres = hres1;
    }

    ExitOleProc();
    return hres;
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIBusDevice_GetTypeInfo |
 *
 *          Gets typeinfo for bus device.
 *
 *  @parm   IN PCGUID | pcguid |
 *          GUID that identifies the gameport
 *
 *  @parm   OUT LPDIJOTYPEINFO    | pjti |
 *          Typeinfo stuct filled in by this function
 *
 *  @parm   IN DWORD | fl |
 *          Flags that specify what fields to fill out.
 *
 *  @returns
 *          HRESULT.
 *
 *****************************************************************************/
HRESULT EXTERNAL
    DIBusDevice_GetTypeInfo
    (
    PCGUID pcguid,
    LPDIJOYTYPEINFO pjti,
    DWORD           fl
    )
{
    HRESULT hres;
    PBUSDEVICEINFO pbdi;
    EnterProcI(DIBusDevice_GetTypeInfo, (_ "Gp", pcguid, pjti));

    hres = E_FAIL;
    DllEnterCrit();

    if( NULL != ( pbdi = pbdiFromGUID(pcguid) ) )
    {
        DIPROPSTRING dips;

        if(fl & DITC_REGHWSETTINGS)
        {
            pjti->hws.dwFlags = pbdi->pBusDevice->dwJOY_HWS_ISPORTBUS | JOY_HWS_AUTOLOAD ;
            pjti->hws.dwNumButtons = MAKELONG( pbdi->idPort, 0x0 );
        }

        if( fl & DITC_CLSIDCONFIG )
        {
            pjti->clsidConfig = pbdi->guid;
        }

        if(fl & DITC_DISPLAYNAME)
        {
            if(FAILED( hres = DIPort_GetRegistryProperty(pbdi->ptszId, SPDRP_FRIENDLYNAME, &dips.diph) ) )
            {
                if( FAILED( hres = DIPort_GetRegistryProperty(pbdi->ptszId, SPDRP_DEVICEDESC, &dips.diph) ) )
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: No device name | friendly name for gameport %d "),
                                    s_szProc, pbdi->idPort);
                }
            }
            if( SUCCEEDED(hres) )
            {
                /*
                 *  Prefix warns (Wi:228282) that dips.wsz could be 
                 *  uninitialized however one of the above GetRegistryProperty 
                 *  functions has succeeded leaving a worst case of a NULL 
                 *  terminator having been copied there.
                 */
                lstrcpyW(pjti->wszDisplayName, dips.wsz);
            }
        }

    #ifndef WINNT
        if(fl & DITC_CALLOUT)
        {
            ZeroX(pjti->wszCallout);
        }
    #endif
    
        if(fl & DITC_HARDWAREID)
        {
            ZeroX(pjti->wszHardwareId);
        }

        if( fl & DITC_FLAGS1 )
        {
            pjti->dwFlags1 = 0x0;
        }

        hres = S_OK;
    } else
    {
        hres = E_FAIL;
        SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("%S: GUID not a port GUID "),
                        s_szProc);
    }

    DllLeaveCrit();
    ExitProcX(hres);

    return hres;

}


HRESULT EXTERNAL DIPort_SnapTypes(LPWSTR *ppwszz)
{
    LONG cDevices;
    HRESULT hres = E_FAIL;

    cDevices = DIBus_BuildList(FALSE);

    if( cDevices)
    {
        DllEnterCrit();
        hres = AllocCbPpv(cbCwch( cDevices  * MAX_JOYSTRING) , ppwszz);
        if( SUCCEEDED(hres) )
        {
            int iBusType, igdi;
            PBUSDEVICE     pBusDevice;
            LPWSTR pwsz = *ppwszz;

            for(iBusType = 0x0, pBusDevice = g_pBusDevice;
               iBusType < 1;
               iBusType++, pBusDevice++ )
            {
                PBUSDEVICEINFO pbdi;
                for(igdi = 0, pbdi = pBusDevice->pbdl->rgbdi;
                   igdi < pBusDevice->pbdl->cgbi;
                   igdi++, pbdi++)
                {
                    TCHAR tszGuid[MAX_JOYSTRING];
                    NameFromGUID(tszGuid, &pbdi->guid);

                    #ifdef UNICODE
                        lstrcpyW(pwsz, &tszGuid[ctchNamePrefix]);
                        pwsz += lstrlenW(pwsz) + 1;
                    #else
                        TToU(pwsz, cA(pwsz), &tszGuid[ctchNamePrefix]);
                        pwsz += lstrlenW(pwsz) + 1;
                    #endif
                }
            }
            *pwsz = L'\0';              /* Make it ZZ */
        }
        DllLeaveCrit();
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dithunk.h ===
/*****************************************************************************
 *
 *  DiThunk.h
 *
 *  Copyright (c) 1997-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Template thunks for Windows 95 device manager.
 *
 *****************************************************************************/
/*****************************************************************************
 *
 *  dithunk.c
 *
 *****************************************************************************/

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct KERNELPROCADDR |
 *
 *          Kernel procedure addresses.
 *
 *          Careful!  This must match dithunk.c::c_rgpszKernel32.
 *
 ***************************************************************************/

typedef struct KERNELPROCADDR { /* kpa */

    /* By ordinal */
    HINSTANCE   (NTAPI *LoadLibrary16)(LPCSTR);
    BOOL        (NTAPI *FreeLibrary16)(HINSTANCE);
    FARPROC     (NTAPI *GetProcAddress16)(HINSTANCE, LPCSTR);

    /* By name */
    LPVOID      (NTAPI   *MapLS)(LPVOID);
    void        (NTAPI   *UnMapLS)(LPVOID);
    LPVOID      (NTAPI   *MapSL)(LPVOID);
    LPVOID      (NTAPI   *MapSLFix)(LPVOID);
    void        (NTAPI   *UnMapSLFixArray)(int, LPVOID);

    /* Warning: GetKernelProcAddresses assumes that QT_Thunk is last */
    void        (__cdecl *QT_Thunk)(void);

} KERNELPROCADDR;

extern KERNELPROCADDR g_kpa;

int __cdecl TemplateThunk(FARPROC fp, PCSTR pszSig, ...);

#define MAKELP(sel, ofs)            (PV)MAKELPARAM(ofs, sel)

BOOL EXTERNAL Thunk_GetKernelProcAddresses(void);

HINSTANCE EXTERNAL
Thunk_GetProcAddresses(FARPROC *rgfp, LPCSTR *rgpsz,
                       UINT cfp, LPCSTR pszLibrary);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diraw.c ===
/*****************************************************************************
 *
 *  DIRaw.c
 *
 *  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      DirectInput Raw Input Device processor.
 *
 *  Contents:
 *
 *      CDIRaw_RegisterRawInputDevice
 *      CDIRaw_UnregisterRawInputDevice
 *      CDIRaw_ProcessInput
 *      CDIRaw_OnInput
 *
 *****************************************************************************/

#include "dinputpr.h"

#ifdef USE_WM_INPUT

#include "ntddkbd.h"

#define sqfl sqflRaw

extern DIMOUSESTATE_INT s_msEd; //in diemm.c
extern ED s_edMouse;            //in diemm.c
extern ED s_edKbd;              //in diemk.c
extern LPBYTE g_pbKbdXlat;      //in diemk.c

static RAWMOUSE s_absrm;
static BOOL s_fFirstRaw;

#ifndef RIDEV_INPUTSINK
  // RIDEV_INPUTSINK is defined in winuserp.h
  #define RIDEV_INPUTSINK   0x00000100
#endif

#ifndef RIDEV_NOHOTKEYS
  #define RIDEV_NOHOTKEYS   0x00000200
#endif

RAWINPUTDEVICE ridOn[] = {
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_MOUSE,    RIDEV_INPUTSINK },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_MOUSE,    RIDEV_NOLEGACY | RIDEV_CAPTUREMOUSE },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD, RIDEV_INPUTSINK },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD, RIDEV_NOLEGACY | RIDEV_NOHOTKEYS },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD, RIDEV_NOHOTKEYS },
};

RAWINPUTDEVICE ridOff[] = {
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_MOUSE,    RIDEV_REMOVE },
    { HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_KEYBOARD, RIDEV_REMOVE },
};


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULE | CDIRaw_RegisterRawInputDevice |
 *
 *          register raw input device.
 *
 *  @parm   IN UINT | uirim |
 *
 *          the type of device: RIM_TYPEMOUSE or RIM_TYPEKEYBOARD
 *
 *  @parm   IN DWORD | dwOrd |
 *
 *          dwOrd determines which item of ridOn will be used for registration.
 *
 *  @parm   IN HWND | hwnd |
 *
 *          the window handler used by RegisterRawInputDevices.
 *
 *  @returns
 *
 *          S_OK - successful
 *          E_FAIL - otherwise
 *
 *****************************************************************************/

HRESULT CDIRaw_RegisterRawInputDevice( UINT uirim, DWORD dwOrd, HWND hwnd)
{
    HRESULT hres;

    AssertF( (uirim == RIM_TYPEMOUSE) || (uirim == RIM_TYPEKEYBOARD) );

    if( hwnd ) {
        ridOn[uirim*2+dwOrd].hwndTarget = hwnd;
    }

    if( RegisterRawInputDevices &&
        RegisterRawInputDevices(&ridOn[uirim*2+dwOrd], 1, sizeof(RAWINPUTDEVICE)) ) {
        SquirtSqflPtszV(sqfl, TEXT("RegisterRawInputDevice: %s, mode: %s, hwnd: 0x%08lx"),
                            uirim==0 ? TEXT("mouse"):TEXT("keyboard"), 
                            dwOrd==0 ? TEXT("NONEXCL") : dwOrd==1 ? TEXT("EXCL") : TEXT("NOWIN"),
                            hwnd);
        hres = S_OK;
    } else {
        hres = E_FAIL;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULE | CDIRaw_UnregisterRawInputDevice |
 *
 *          unregister raw input device.
 *
 *  @parm   IN UINT | uirim |
 *
 *          the type of device: RIM_TYPEMOUSE or RIM_TYPEKEYBOARD
 *
 *  @parm   IN HWND | hwnd |
 *
 *          the window handler used by RegisterRawInputDevices.
 *
 *  @returns
 *
 *          S_OK - successful
 *          E_FAIL - otherwise
 *
 *****************************************************************************/

HRESULT CDIRaw_UnregisterRawInputDevice( UINT uirim, HWND hwnd )
{
    HRESULT hres;

    AssertF( (uirim == RIM_TYPEMOUSE) || (uirim == RIM_TYPEKEYBOARD) );

    if( hwnd ) {
        ridOn[uirim].hwndTarget = hwnd;
    }

    if( RegisterRawInputDevices &&
        RegisterRawInputDevices(&ridOff[uirim], 1, sizeof(RAWINPUTDEVICE)) ) {
        SquirtSqflPtszV(sqfl, TEXT("UnregisterRawInputDevice: %s, hwnd: 0x%08lx"),
                            uirim==0 ? TEXT("mouse"):TEXT("keyboard"), hwnd);
        hres = S_OK;
    } else {
        hres = E_FAIL;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIRaw_ProcessInput |
 *
 *          Process raw input device data.
 *
 *  @parm   IN PRAWINPUT | pRawInput |
 *
 *          pointer to RAWINPUT data
 *
 *  @returns
 *
 *          void
 *
 *****************************************************************************/

void CDIRaw_ProcessInput(PRAWINPUT pRawInput)
{
    HANDLE hDevice = pRawInput->header.hDevice;

    if ( g_plts ) {
        if( g_plts->rglhs[LLTS_MSE].cHook && pRawInput->header.dwType == RIM_TYPEMOUSE )
        {
            DIMOUSESTATE_INT ms;
            RAWMOUSE        *prm = &pRawInput->data.mouse;

            memcpy(ms.rgbButtons, s_msEd.rgbButtons, cbX(ms.rgbButtons));

            if( prm->usFlags & MOUSE_MOVE_ABSOLUTE ) {
                if( s_fFirstRaw ) {
                    memcpy( &s_absrm, prm, sizeof(RAWMOUSE) );
                    s_fFirstRaw = FALSE;
                    return;
                } else {
                    RAWMOUSE rm;

                    memcpy( &rm, prm, sizeof(RAWMOUSE) );

                    prm->lLastX -= s_absrm.lLastX;
                    prm->lLastY -= s_absrm.lLastY;
                    if ( prm->usButtonFlags & RI_MOUSE_WHEEL ) {
                        prm->usButtonData -= s_absrm.usButtonData;
                    }

                    memcpy( &s_absrm, &rm, sizeof(RAWMOUSE) );
                }
            }

            ms.lX = prm->lLastX;
            ms.lY = prm->lLastY;
            if ( prm->usButtonFlags & RI_MOUSE_WHEEL ) {
                ms.lZ = (short)prm->usButtonData;
            } else {
                ms.lZ = 0;
            }

            if( prm->usButtonFlags & RI_MOUSE_LEFT_BUTTON_DOWN ) {
                ms.rgbButtons[0] = 0x80;
            } else if (prm->usButtonFlags & RI_MOUSE_LEFT_BUTTON_UP ) {
                ms.rgbButtons[0] = 0x00;
            }

            if( prm->usButtonFlags & RI_MOUSE_RIGHT_BUTTON_DOWN ) {
                ms.rgbButtons[1] = 0x80;
            } else if (prm->usButtonFlags & RI_MOUSE_RIGHT_BUTTON_UP) {
                ms.rgbButtons[1] = 0x00;
            }

            if( prm->usButtonFlags & RI_MOUSE_MIDDLE_BUTTON_DOWN ) {
                ms.rgbButtons[2] = 0x80;
            } else if( prm->usButtonFlags & RI_MOUSE_MIDDLE_BUTTON_UP ) {
                ms.rgbButtons[2] = 0x00;
            }

            if( prm->usButtonFlags & RI_MOUSE_BUTTON_4_DOWN ) {
                ms.rgbButtons[3] = 0x80;
            } else if( prm->usButtonFlags & RI_MOUSE_BUTTON_4_UP ) {
                ms.rgbButtons[3] = 0x00;
            }

            if( prm->usButtonFlags & RI_MOUSE_BUTTON_5_DOWN ) {
                ms.rgbButtons[4] = 0x80;
            } else if ( prm->usButtonFlags & RI_MOUSE_BUTTON_5_UP ) {
                ms.rgbButtons[4] = 0x00;
            }

            #if 0
            {
                char buf[128];
                static DWORD cnt = 0;

                wsprintfA(buf, "%d: x: %ld (%ld), y: %ld (%ld), z: %ld, rgb[0]: 0x%lx, rgb[4]: 0x%lx", cnt, prm->lLastX,ms.lX, prm->lLastY, ms.lY, (short)prm->usButtonData,*(DWORD *)ms.rgbButtons,*(DWORD *)&ms.rgbButtons[4]);
                RPF(buf);
                cnt++;
            }
            #endif

            CEm_Mouse_AddState(&ms, GetTickCount());

        } else
        if ( g_plts->rglhs[LLTS_KBD].cHook && pRawInput->header.dwType == RIM_TYPEKEYBOARD ) {
            RAWKEYBOARD *prk = &pRawInput->data.keyboard;
            BYTE bAction, bScan;
            static BOOL fE1 = FALSE;

            bAction = (prk->Flags & KEY_BREAK) ? 0 : 0x80;
            bScan   = (BYTE)prk->MakeCode;

            if( prk->Flags & KEY_E0 ) {
                if( bScan == 0x2A ) {  //special extra scancode when pressing PrtScn
                    return;
                } else {
                    bScan |= 0x80;
                }
            } else if( prk->Flags & KEY_E1 ) {  //special key: PAUSE
                fE1 = TRUE;

                // now, we need to bypass 0x1d key for compitibility with low level hook.
                if( bScan == 0x1d ) {
                    return;
                }
            }

            if( fE1 ) {
                // This is the work around for bug 288535.
                // But we really don't want to fix it in this way.
                //if( !bAction ) {
                //  Sleep(80);
                //}
                bScan |= 0x80;
                fE1 = FALSE;
            }

            AssertF(g_pbKbdXlat);
            if( bScan != 0x45 && bScan != 0xc5 ) {
                bScan = g_pbKbdXlat[bScan];
            }

            #if 0
            {
                char buf[128];
                static DWORD cnt = 0;
                
                wsprintfA(buf, "%d: bAction: 0x%lx, bScan: 0x%lx, Flags: 0x%lx, Make: 0x%lx", cnt, bAction, bScan, prk->Flags,prk->MakeCode);
                RPF(buf);
                cnt++;
            }
            #endif

            CEm_AddEvent(&s_edKbd, bAction, bScan, GetTickCount());
        }
    }

    return;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CDIRaw_OnInput |
 *
 *          WM_INPUT message handler used by CEm_LL_ThreadProc (in diem.c).
 *
 *  @parm   IN MSG * | pmsg |
 *
 *          pointer to MSG
 *
 *  @returns
 *
 *          TRUE = Successful
 *          FALSE = otherwise
 *
 *****************************************************************************/

BOOL CDIRaw_OnInput(MSG *pmsg)
{
    BOOL  fRtn = FALSE;
    HRAWINPUT hRawInput = (HRAWINPUT)pmsg->lParam;
    PRAWINPUT pRawInput;
    UINT cbSize;
    BYTE pbBuf[512];
    BOOL fMalloc;
    UINT uiRtn;

    //
    // Firstly, get the size of this Raw Input.
    //
    if ( (uiRtn = GetRawInputData(hRawInput, RID_INPUT, NULL, &cbSize, sizeof(RAWINPUTHEADER))) != 0) {
        return FALSE;
    }

    //
    // Allocate required memory.
    //
    if( cbSize < cbX(pbBuf) ) {
        pRawInput = (PRAWINPUT)pbBuf;
        fMalloc = FALSE;
    } else {
        pRawInput = (PRAWINPUT)malloc(cbSize);
        if (pRawInput == NULL) {
            RPF("Failed to allocate pRawInput\n");
            return FALSE;
        }
        fMalloc = TRUE;
    }

    //
    // Receive the content of the Raw Input.
    //
    if (GetRawInputData(hRawInput, RID_INPUT, pRawInput, &cbSize, sizeof(RAWINPUTHEADER)) > 0) {
        //
        // Call the handler of ours, to start/continue/stop drawing.
        //
        CDIRaw_ProcessInput(pRawInput);
    }

    // no longer needed.
    if( fMalloc ) {
        free(pRawInput);
        pRawInput = NULL;
    }

    return fRtn;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | CDIRaw_Mouse_InitButtons |
 *
 *          Initialize the mouse state in preparation for acquisition.
 *
 *****************************************************************************/

HRESULT INTERNAL
CDIRaw_Mouse_InitButtons(void)
{
    if (s_edMouse.cAcquire < 0) {
        s_fFirstRaw = TRUE;
    }

    return S_OK;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   int | DIRaw_GetKeyboardType |
 *
 *          Return keyboard type (nTypeFlag==0) or subtype (nTypeFlag==1).
 *
 *****************************************************************************/

int EXTERNAL
DIRaw_GetKeyboardType(int nTypeFlag)
{
    PRAWINPUTDEVICELIST pList = NULL;
    UINT  uiNumDevices = 0;
    DWORD dwType;
    int   nResult = 0;

    if (GetRawInputDeviceList(NULL, &uiNumDevices, sizeof(RAWINPUTDEVICELIST)) == (UINT)-1) {
        SquirtSqflPtszV(sqfl, TEXT("DIRaw_GetKeyboardType: failed to get the number of devices."));
        goto _DIRAWGKT_EXIT;
    }

    if( uiNumDevices ) {
        pList = malloc(sizeof(RAWINPUTDEVICELIST) * uiNumDevices);
        if( !pList ) {
            SquirtSqflPtszV(sqfl, TEXT("DIRaw_GetKeyboardType: malloc failed."));
            goto _DIRAWGKT_EXIT;
        }
        
        if (GetRawInputDeviceList(pList, &uiNumDevices, sizeof(RAWINPUTDEVICELIST)) == (UINT)-1) {
            SquirtSqflPtszV(sqfl, TEXT("DIRaw_GetKeyboardType:  failed to get device list."));
            goto _DIRAWGKT_EXIT;
        } else {
            UINT  i;
            UINT  uiLen;
            UINT  cbSize;
            RID_DEVICE_INFO info;

            info.cbSize = sizeof(RID_DEVICE_INFO);

            for (i = 0; i<uiNumDevices; ++i) 
            {
                if (pList[i].dwType == RIM_TYPEKEYBOARD) 
                {
                    uiLen = 0;

                    // Get device name
                    if (GetRawInputDeviceInfo(pList[i].hDevice, RIDI_DEVICENAME, NULL, &uiLen)) {
                        continue;
                    }

                    // Get device type info.
                    cbSize = sizeof(RID_DEVICE_INFO);
                    if (GetRawInputDeviceInfo(pList[i].hDevice, RIDI_DEVICEINFO, &info, &cbSize) == (UINT)-1) {
                        continue;
                    }

                    if( nTypeFlag == 0 || nTypeFlag == 1)   //keyboard type or subtype
                    {
                        dwType = info.keyboard.dwType;
                        if( dwType == 4 || dwType == 7 || dwType == 8 ) {
                            nResult = (nTypeFlag==0) ? info.keyboard.dwType : info.keyboard.dwSubType;
                            break;
                        }
                    } else 
                    {
                        RPF("DIRaw_GetKeyboardType: wrong argument, %d is not supported.", nTypeFlag);
                    }
                }
            }
        }
    }

_DIRAWGKT_EXIT:
    if( pList ) {
        free(pList);
    }

    if( !nResult ) {
        nResult = GetKeyboardType(nTypeFlag);
    }

    SquirtSqflPtszV(sqfl, TEXT("DIRaw_GetKeyboardType: %s: %d"),
                          nTypeFlag==0 ? TEXT("type"):TEXT("sybtype"), nResult);
    
    return nResult;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diriff.c ===
/****************************************************************************

    MODULE:     	RIFF.CPP
    Tab settings: 	Every 4 spaces

    Copyright 1996, Microsoft Corporation, 	All Rights Reserved.

    PURPOSE:    	Classes for reading and writing RIFF files
    
    CLASSES:
        CRIFFFile	Encapsulates common RIFF file functionality

    Author(s):	Name:
    ----------	----------------
        DMS		Daniel M. Sangster

    Revision History:
    -----------------
    Version Date            Author  Comments
    1.0  	25-Jul-96       DMS     Created

    COMMENTS:
****************************************************************************/
#include "dinputpr.h"
#define sqfl sqflDev


/* 
 * This function converts MMIO errors to HRESULTS
 */
HRESULT INLINE hresMMIO(UINT mmioErr)
{
    switch(mmioErr)
    {
    case 0x0:                       return  S_OK;
    case MMIOERR_FILENOTFOUND:      return  hresLe(ERROR_FILE_NOT_FOUND);/* file not found */
    case MMIOERR_OUTOFMEMORY:       return  hresLe(ERROR_OUTOFMEMORY);  /* out of memory */
    case MMIOERR_CANNOTOPEN:        return  hresLe(ERROR_OPEN_FAILED);  /* cannot open */
    case MMIOERR_CANNOTCLOSE:       return  S_FALSE;                    /* cannot close */
    case MMIOERR_CANNOTREAD:        return  hresLe(ERROR_READ_FAULT);   /* cannot read */
    case MMIOERR_CANNOTWRITE:       return  hresLe(ERROR_WRITE_FAULT);  /* cannot write */
    case MMIOERR_CANNOTSEEK:        return  hresLe(ERROR_SEEK);         /* cannot seek */
    case MMIOERR_CANNOTEXPAND:      return  hresLe(ERROR_SEEK);           /* cannot expand file */
    case MMIOERR_CHUNKNOTFOUND:     return  hresLe(ERROR_SECTOR_NOT_FOUND);  /* chunk not found */
    case MMIOERR_UNBUFFERED:        return  E_FAIL;
    case MMIOERR_PATHNOTFOUND:      return  hresLe(ERROR_PATH_NOT_FOUND);/* path incorrect */
    case MMIOERR_ACCESSDENIED:      return  hresLe(ERROR_ACCESS_DENIED); /* file was protected */
    case MMIOERR_SHARINGVIOLATION:  return  hresLe(ERROR_SHARING_VIOLATION); /* file in use */
    case MMIOERR_NETWORKERROR:      return  hresLe(ERROR_UNEXP_NET_ERR); /* network not responding */
    case MMIOERR_TOOMANYOPENFILES:  return  hresLe(ERROR_TOO_MANY_OPEN_FILES); /* no more file handles  */
    case MMIOERR_INVALIDFILE:       return  hresLe(ERROR_BAD_FORMAT);    /* default error file error */
    default:                        return  E_FAIL;   
    }

}


HRESULT INLINE RIFF_Ascend(HMMIO hmmio, LPMMCKINFO lpmmckinfo)
{
    return hresMMIO( mmioAscend(hmmio, lpmmckinfo, 0) );
}

HRESULT INLINE RIFF_Descend(HMMIO hmmio, LPMMCKINFO lpmmckinfo, LPMMCKINFO lpmmckinfoParent, UINT nFlags)
{
    return hresMMIO(mmioDescend(hmmio, lpmmckinfo, lpmmckinfoParent, nFlags));
}

HRESULT INLINE RIFF_CreateChunk(HMMIO hmmio, LPMMCKINFO lpmmckinfo, UINT nFlags)
{
    // set cksize to zero to overcome a bug in release version of mmioAscend
    // which does not correctly write back the size of the chunk
    lpmmckinfo->cksize = 0;

    return hresMMIO(mmioCreateChunk(hmmio, lpmmckinfo, nFlags));
}


HRESULT INLINE RIFF_Read(HMMIO hmmio, LPVOID pBuf, LONG nCount)
{
    return (nCount == mmioRead(hmmio, (char*)pBuf, nCount)) ? S_OK: hresLe(ERROR_READ_FAULT);
}          

HRESULT INLINE RIFF_Write(HMMIO hmmio, const LPVOID pBuf, LONG nCount)
{
    return ( nCount == mmioWrite(hmmio, (char*)pBuf, nCount)) ? S_OK : hresLe(ERROR_WRITE_FAULT);
}

HRESULT RIFF_Close(HMMIO hmmio, UINT nFlags)
{
    return hresMMIO(mmioClose(hmmio, nFlags));
}

/*
 * Opens a RIFF file for read / write
 * Reads/Writes a GUID that servers as our signature
 */
HRESULT RIFF_Open
    (
    LPCSTR      lpszFilename,
    UINT        nOpenFlags,
    PHANDLE     phmmio,
    LPMMCKINFO  lpmmck,
    PDWORD      pdwEffectSz
    )
{
    HRESULT     hres = S_OK;
    MMIOINFO    mmInfo;
    HMMIO       hmmio;
	LPSTR		lpszFile = (LPSTR)lpszFilename;

    ZeroX(mmInfo);

	//There is a problem in mmio that causes somewhat unpredictable behaviour  under certain conditions --
	//in particular, if using drag-n-drop, it may happen so that mmioOpenA() opens 1 file for reading
	//and completely different file for writing, if only the file name is specified.
	//So we need to check whether we have only the file name or the path (path will contain a \).
	if (strchr(lpszFilename, '\\') == NULL)
	{
		//Put the current directory before the file name to give the absolute path.
		//Apparently mmio doesn't have a problem if given absolute path.
		CHAR szFullPath[MAX_PATH];
		DWORD dwWritten = GetFullPathNameA(lpszFilename, MAX_PATH, (LPSTR)&szFullPath, NULL);
		if (( dwWritten != 0) && (dwWritten <= MAX_PATH))
		{
			lpszFile = (LPSTR)&szFullPath;
		}
	}

	//There is a problem in mmioOpenA() that makes it leak when the file specified to open for reading
	//doesn't exist.
	//To avoid the leak, we need to check overselves whether we're opening for reading and 
	//whether the file exists.
	if( nOpenFlags == ( MMIO_READ | MMIO_ALLOCBUF) )
    {
		HANDLE h = CreateFileA(lpszFile, 
							GENERIC_READ,
							0,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL);
		if (h == INVALID_HANDLE_VALUE)
		{
			//set the error code
			hres = hresLe(GetLastError());
			goto done;
		}
		else
		{
			//the file is there; close handle
			CloseHandle(h);
		}
	}


    // go ahead and open the file, if we can
    hmmio = mmioOpenA(lpszFile, &mmInfo, nOpenFlags);

    if(mmInfo.wErrorRet)
    {
        hres = hresMMIO(mmInfo.wErrorRet);
        AssertF(FAILED(hres));
    }

   // if( nOpenFlags & ( MMIO_READ | MMIO_ALLOCBUF) )
	 if( nOpenFlags == ( MMIO_READ | MMIO_ALLOCBUF) )
    {
        if(SUCCEEDED(hres))
        {
            // locate and descend into FORC RIFF chunk
            lpmmck->fccType = FCC_FORCE_EFFECT_RIFF;
            hres = RIFF_Descend(hmmio, lpmmck, NULL, MMIO_FINDRIFF);
        }

        if(SUCCEEDED(hres))
        {
            GUID GUIDVersion;
            //read the guid
            hres = RIFF_Read(hmmio, &GUIDVersion, sizeof(GUID));

            if(SUCCEEDED(hres))
            {
                if(IsEqualGUID(&GUIDVersion, &GUID_INTERNALFILEEFFECT))
                {
                
                } else
                {
                    hres = hresLe(ERROR_BAD_FORMAT);
                }
            }
        }

    } 
	//else if( nOpenFlags & ( MMIO_WRITE | MMIO_ALLOCBUF) )
	else if( nOpenFlags & ( MMIO_WRITE) )
    {

        // create the FORC RIFF chunk
        lpmmck->fccType = FCC_FORCE_EFFECT_RIFF;
        hres = RIFF_CreateChunk(hmmio, lpmmck, MMIO_CREATERIFF);

        if(SUCCEEDED(hres))
        {
            //write the version GUID
            hres = RIFF_Write(hmmio, (PV)&GUID_INTERNALFILEEFFECT, sizeof(GUID));
        }
    } else
    {
        hres = E_FAIL;
    }

    *phmmio = hmmio;

done:;
    return hres;
}



/*****************************************************************************
 *
 * internal
 * RIFF_ReadEffect
 *
 *  Reads a single Effect from a RIFF file
 *  
 *  The callee bears the responsibility to free the TypeSpecificParameterBlock
 *  for the effect.
 *       
 *
 *****************************************************************************/

#ifdef _M_IA64
//This is hack to read 32 bit files on ia64, since someone decided to write 
//pointers to file.
//Copied from dinput.h and modified.
typedef struct DIEFFECT_FILE32 {
    DWORD dwSize;                   /* sizeof(DIEFFECT)     */
    DWORD dwFlags;                  /* DIEFF_*              */
    DWORD dwDuration;               /* Microseconds         */
    DWORD dwSamplePeriod;           /* Microseconds         */
    DWORD dwGain;
    DWORD dwTriggerButton;          /* or DIEB_NOTRIGGER    */
    DWORD dwTriggerRepeatInterval;  /* Microseconds         */
    DWORD cAxes;                    /* Number of axes       */

/*Make sure size is same on both 1386 and ia64.
    LPDWORD rgdwAxes;
    LPLONG rglDirection;
    LPDIENVELOPE lpEnvelope;
*/  DWORD rgdwAxes;                 /* Array of axes        */
    DWORD rglDirection;             /* Array of directions  */
    DWORD lpEnvelope;               /* Optional             */

    DWORD cbTypeSpecificParams;     /* Size of params       */

/*Make sure size is same on both 1386 and ia64.
    LPVOID lpvTypeSpecificParams;
*/  DWORD lpvTypeSpecificParams;    /* Pointer to params    */

//#if(DIRECTINPUT_VERSION >= 0x0600)//Out since file format does not change.
    DWORD  dwStartDelay;            /* Microseconds         */
//#endif /* DIRECTINPUT_VERSION >= 0x0600 *///Out since file format does not change.
} DIEFFECT_FILE32, *LPDIEFFECT_FILE32;
#endif /*_M_IA64*/

HRESULT
    RIFF_ReadEffect
    (
    HMMIO      hmmio, 
    LPDIFILEEFFECT lpDiFileEf 
    )
{
    HRESULT hres = E_FAIL;
    MMCKINFO mmckinfoEffectLIST;
    MMCKINFO mmckinfoDataCHUNK;
    LPDIEFFECT peff = (LPDIEFFECT)lpDiFileEf->lpDiEffect;

    // descend into the effect list
    mmckinfoEffectLIST.fccType = FCC_EFFECT_LIST;
    hres = RIFF_Descend(hmmio, &mmckinfoEffectLIST, NULL, MMIO_FINDLIST);
   
    if(SUCCEEDED(hres))
    {
        //read the name
        hres = RIFF_Read(hmmio, lpDiFileEf->szFriendlyName, MAX_SIZE_SNAME);
    }

    if(SUCCEEDED(hres))
    {
#ifdef _M_IA64

        DIEFFECT_FILE32 eff32;
        //read the effect structure
        hres = RIFF_Read(hmmio, &eff32, sizeof(eff32));

        AssertF( eff32.dwSize == sizeof(eff32) );
        if( eff32.dwSize != sizeof(eff32) )
        {
            hres = ERROR_BAD_FORMAT;
        }
        else
        {
            peff->dwSize=sizeof(*peff);
            peff->dwFlags=eff32.dwFlags;
            peff->dwDuration=eff32.dwDuration;
            peff->dwSamplePeriod=eff32.dwSamplePeriod;
            peff->dwGain=eff32.dwGain;
            peff->dwTriggerButton=eff32.dwTriggerButton;
            peff->dwTriggerRepeatInterval=eff32.dwTriggerRepeatInterval;
            peff->cAxes=eff32.cAxes;
            peff->cbTypeSpecificParams=eff32.cbTypeSpecificParams;
            peff->lpvTypeSpecificParams=(LPVOID)(DWORD_PTR)eff32.lpvTypeSpecificParams;
            peff->dwStartDelay=eff32.dwStartDelay;
        }

#else /*_M_IA64*/

        // Reading the effect structure will zap out the following,
        // so we make a copy before the read.
        LPDIENVELOPE    lpEnvelope  = peff->lpEnvelope;
        LPDWORD         rgdwAxes    = peff->rgdwAxes;
        LPLONG          rglDirection= peff->rglDirection;
        
        //read the effect structure
        hres = RIFF_Read(hmmio, peff, sizeof(DIEFFECT));
        
        AssertF( peff->dwSize == sizeof(DIEFFECT) );
        if( peff->dwSize != sizeof(DIEFFECT) )
        {
            hres = ERROR_BAD_FORMAT;
        }
        else
        {
            if(peff->lpEnvelope)		peff->lpEnvelope    =   lpEnvelope;
            if(peff->rgdwAxes)			peff->rgdwAxes      =   rgdwAxes;
            if(peff->rglDirection)		peff->rglDirection  =   rglDirection;
        }

#endif /*_M_IA64*/

	    if(SUCCEEDED(hres))
        {    
            AssertF(peff->cAxes < DIEFFECT_MAXAXES);
            if(peff->cAxes >= DIEFFECT_MAXAXES)
            {
                hres = ERROR_BAD_FORMAT;
            }
        }
    }

	if(SUCCEEDED(hres))
    {
        // read the Effect GUID
        hres = RIFF_Read(hmmio, &lpDiFileEf->GuidEffect, sizeof(GUID));
    }


	if(SUCCEEDED(hres))
    {
        UINT nRepeatCount;
        //read in the repeat count
        hres = RIFF_Read(hmmio, &nRepeatCount, sizeof(nRepeatCount));
    }


    if(SUCCEEDED(hres) && peff->rgdwAxes)
    {
        // descend the data chunk
        mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
        hres = RIFF_Descend(hmmio, &mmckinfoDataCHUNK, NULL, MMIO_FINDCHUNK);
		if(SUCCEEDED(hres))
		{
			//read the axes
			hres = RIFF_Read(hmmio, peff->rgdwAxes, cbX(*peff->rgdwAxes)*(peff->cAxes));
			hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
		}
	}

    if(SUCCEEDED(hres) && peff->rglDirection)
    {
		//descend the data chunk
        mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
        hres = RIFF_Descend(hmmio, &mmckinfoDataCHUNK, NULL, MMIO_FINDCHUNK);
		if(SUCCEEDED(hres))
		{
			//read the direction
			hres = RIFF_Read(hmmio, peff->rglDirection, cbX(*peff->rglDirection)*(peff->cAxes));
			hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
		}
    }

    if(SUCCEEDED(hres) && peff->lpEnvelope )
    {
	
		//descend the data chunk
        mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
        hres = RIFF_Descend(hmmio, &mmckinfoDataCHUNK, NULL, MMIO_FINDCHUNK);
		if(SUCCEEDED(hres))
		{
			hres = RIFF_Read(hmmio, peff->lpEnvelope, sizeof(DIENVELOPE));
			hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
		}
    }


    if(SUCCEEDED(hres) && (peff->cbTypeSpecificParams > 0))
    {
        // get the param structure, if any 
        hres = AllocCbPpv( peff->cbTypeSpecificParams, &peff->lpvTypeSpecificParams );

        if( SUCCEEDED( hres ) )
        {
			//descend the data chunk
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_Descend(hmmio, &mmckinfoDataCHUNK, NULL, MMIO_FINDCHUNK);
			if(SUCCEEDED(hres))
			{
				hres = RIFF_Read(hmmio, peff->lpvTypeSpecificParams, peff->cbTypeSpecificParams);
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }


    if(SUCCEEDED(hres))
    {
		 // ascend the effect chunk
		 hres = RIFF_Ascend(hmmio, &mmckinfoEffectLIST);
    }
    return hres;
}


/*
 * RIFF_WriteEffect
 *
 *  Writes a single Effect structure to a RIFF file
 *
 *  The effect structure is quite complex. It contains pointers
 *  to a number of other structures. This function checks for
 *  valid data before it writes out the effect structure
 */

HRESULT RIFF_WriteEffect
    (HMMIO hmmio,
     LPDIFILEEFFECT    lpDiFileEf
    )
{

    HRESULT hres = E_FAIL;
    LPDIEFFECT peff = (LPDIEFFECT)lpDiFileEf->lpDiEffect;
    MMCKINFO mmckinfoEffectLIST;
    MMCKINFO mmckinfoDataCHUNK;
	LPDWORD rgdwAxes = NULL;
	LPLONG rglDirection = NULL;
	LPDIENVELOPE lpEnvelope = NULL;
	LPVOID lpvTypeSpecPar = NULL;

    EnterProcI(RIFF_WriteEffect, (_ "xx", hmmio, lpDiFileEf));

    // create the effect LIST
    mmckinfoEffectLIST.fccType = FCC_EFFECT_LIST;
    hres = RIFF_CreateChunk(hmmio, &mmckinfoEffectLIST, MMIO_CREATELIST);

	//save the effect ptrs and write flags to the file, instead of ptrs
	if (peff->rgdwAxes)
	{
		rgdwAxes = peff->rgdwAxes;
		peff->rgdwAxes = (LPDWORD)DIEP_AXES;
	}
	if (peff->rglDirection)
	{
		rglDirection = peff->rglDirection;
		peff->rglDirection = (LPLONG)DIEP_DIRECTION;
	}
	if (peff->lpEnvelope)
	{
		lpEnvelope = peff->lpEnvelope;
		peff->lpEnvelope = (LPDIENVELOPE)DIEP_ENVELOPE;
	}
	if ((peff->cbTypeSpecificParams > 0) && (peff->lpvTypeSpecificParams != NULL))
	{
		lpvTypeSpecPar = peff->lpvTypeSpecificParams;
		peff->lpvTypeSpecificParams = (LPVOID)DIEP_TYPESPECIFICPARAMS;
	}

	
    if(SUCCEEDED(hres))
    {
        hres = hresFullValidReadStrA(lpDiFileEf->szFriendlyName, MAX_JOYSTRING,1);

        if(SUCCEEDED(hres))
        {
            //write the name, only MAX_SIZE_SNAME characters
            hres = RIFF_Write(hmmio, lpDiFileEf->szFriendlyName, MAX_SIZE_SNAME);
        }
    }

    if(SUCCEEDED(hres))
    {
        hres = (peff && IsBadReadPtr(peff, cbX(DIEFFECT_DX5))) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
            hres = (peff && IsBadReadPtr(peff, peff->dwSize)) ? E_POINTER : S_OK;
        }
        
        if(SUCCEEDED(hres))
        {
            //write the effect structure
#ifdef _M_IA64
            DIEFFECT_FILE32 eff32;
            ZeroMemory(&eff32,sizeof(eff32));
            eff32.dwSize=sizeof(eff32);
            eff32.dwFlags=peff->dwFlags;
            eff32.dwDuration=peff->dwDuration;
            eff32.dwSamplePeriod=peff->dwSamplePeriod;
            eff32.dwGain=peff->dwGain;
            eff32.dwTriggerButton=peff->dwTriggerButton;
            eff32.dwTriggerRepeatInterval=peff->dwTriggerRepeatInterval;
            eff32.cAxes=peff->cAxes;
            eff32.cbTypeSpecificParams=peff->cbTypeSpecificParams;
            eff32.lpvTypeSpecificParams=(DWORD)(DWORD_PTR)peff->lpvTypeSpecificParams;
            eff32.dwStartDelay=peff->dwStartDelay;
            hres = RIFF_Write(hmmio, &eff32, eff32.dwSize);
#else /*_M_IA64*/
            hres = RIFF_Write(hmmio, peff, peff->dwSize);
#endif /*_M_IA64*/
        }
    }

	//restore the ptrs
	if (rgdwAxes != NULL)
	{
		peff->rgdwAxes = rgdwAxes;
	}

	if (rglDirection != NULL)
	{
		peff->rglDirection = rglDirection;
	}

	if (lpEnvelope != NULL)
	{
		peff->lpEnvelope = lpEnvelope;
	}

	if (lpvTypeSpecPar != NULL)
	{
		peff->lpvTypeSpecificParams = lpvTypeSpecPar;
	}


	if(SUCCEEDED(hres))
    {
        // write the Effect GUID
        hres = RIFF_Write(hmmio, &lpDiFileEf->GuidEffect, sizeof(GUID));
    }


	//write 1 as the repeat count
	if(SUCCEEDED(hres))
    {
		UINT nRepeatCount = 1;
        hres = RIFF_Write(hmmio, &nRepeatCount, sizeof(DWORD));
    }


    if(SUCCEEDED(hres) && rgdwAxes )
    {
        hres = (IsBadReadPtr(rgdwAxes, (*rgdwAxes)*cbX(peff->cAxes))) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
			// create the data CHUNK
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_CreateChunk(hmmio, &mmckinfoDataCHUNK, 0);
			//write the axes
			if(SUCCEEDED(hres))
			{
				hres = RIFF_Write(hmmio, rgdwAxes, sizeof(*rgdwAxes)*(peff->cAxes));
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }

    if(SUCCEEDED(hres) && rglDirection)
    {

        hres = (IsBadReadPtr(rglDirection, cbX(*rglDirection)*(peff->cAxes))) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
			// create the data CHUNK
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_CreateChunk(hmmio, &mmckinfoDataCHUNK, 0);
			if(SUCCEEDED(hres))
			{
				//write the direction
				hres = RIFF_Write(hmmio, rglDirection, sizeof(*rglDirection)*(peff->cAxes));
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }


    //write the envelope, if one is present
    if(SUCCEEDED(hres) &&
       (lpEnvelope != NULL) )
    {

        hres = (IsBadReadPtr(lpEnvelope, cbX(*lpEnvelope))) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
			// create the data CHUNK
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_CreateChunk(hmmio, &mmckinfoDataCHUNK, 0);
			//write the envelope
			if(SUCCEEDED(hres))
			{
				hres = RIFF_Write(hmmio, lpEnvelope, lpEnvelope->dwSize);
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }


    //write the type-specific
    if(SUCCEEDED(hres) &&
       (peff->cbTypeSpecificParams > 0) && 
       (peff->lpvTypeSpecificParams != NULL) )
    {

        hres = (IsBadReadPtr(lpvTypeSpecPar, peff->cbTypeSpecificParams)) ? E_POINTER : S_OK;
        if(SUCCEEDED(hres))
        {
			// create the data CHUNK
			mmckinfoDataCHUNK.ckid = FCC_DATA_CHUNK;
			hres = RIFF_CreateChunk(hmmio, &mmckinfoDataCHUNK, 0);
			//write the params
			if(SUCCEEDED(hres))
			{
				hres = RIFF_Write(hmmio, lpvTypeSpecPar, peff->cbTypeSpecificParams);
				hres = RIFF_Ascend(hmmio, &mmckinfoDataCHUNK);
			}
        }
    }


    if(SUCCEEDED(hres))
    {
        // ascend the effect chunk
        hres = RIFF_Ascend(hmmio, &mmckinfoEffectLIST);
    }

    ExitOleProc();
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\disubcls.c ===
/*****************************************************************************
 *
 *  DISubCls.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      "Safe subclassing" code, stolen from comctl32.
 *
 *      Originally written by francish.  Stolen by raymondc.
 *
 *  Contents:
 *
 *      SetWindowSubclass
 *      GetWindowSubclass
 *      RemoveWindowSubclass
 *      DefSubclassProc
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflSubclass

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @topic  DirectInput Subclassing |
 *
 *
 * This module defines helper functions that make subclassing windows safe(er)
 * and easy(er).  The code maintains a single property on the subclassed window
 * and dispatches various "subclass callbacks" to its clients a required.  The
 * client is provided reference data and a simple "default processing" API.
 *
 * Semantics:
 *  A "subclass callback" is identified by a unique pairing of a callback
 * function pointer and an unsigned ID value.  Each callback can also store a
 * single DWORD of reference data, which is passed to the callback function
 * when it is called to filter messages.  No reference counting is performed
 * for the callback, it may repeatedly call the SetWindowSubclass API to alter
 * the value of its reference data element as desired.
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SUBCLASS_CALL |
 *
 *          Structure which tracks a single subclassing client.
 *
 *          Although a linked list would have made the code slightly
 *          simpler, this module uses a packed callback array to avoid
 *          unneccessary fragmentation.
 *
 *  @field  SUBCLASSPROC | pfnSubclass |
 *
 *          The subclass procedure.  If this is zero, it means that
 *          the node is dying and should be ignored.
 *
 *  @field  UINT | uIdSubclass |
 *
 *          Unique subclass identifier.
 *
 *  @field  DWORD | dwRefData |
 *
 *          Optional reference data for subclass procedure.
 *
 *****************************************************************************/

typedef struct SUBCLASS_CALL {
    SUBCLASSPROC    pfnSubclass;
    UINT_PTR        uIdSubclass;
    ULONG_PTR       dwRefData;
} SUBCLASS_CALL, *PSUBCLASS_CALL;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SUBCLASS_FRAME |
 *
 *          Structure which tracks the state of an active call to the
 *          window's window procedure.
 *
 *          Each time the window procedure is entered, we create a new
 *          <t SUBCLASS_FRAME>, which remains active until the last
 *          subclass procedure returns, at which point the frame is
 *          torn down.
 *
 *          The subclass frames are stored on the stack.  So walking
 *          the frame chain causes you to wander through the stack.
 *
 *  @field  UINT | uCallIndex |
 *
 *          Index of next callback to call.
 *
 *  @field  UINT | uDeepestCall |
 *
 *          Deepest <e SUBCLASS_FRAME.uCallIndex> on the stack.
 *
 *  @field  SUBCLASS_FRAME * | pFramePrev |
 *
 *          The previous subclass frame.
 *
 *  @field  PSUBCLASS_HEADER | pHeader |
 *
 *          The header associated with this frame.
 *
 *****************************************************************************/

typedef struct SUBCLASS_FRAME {
    UINT uCallIndex;
    UINT uDeepestCall;
    struct SUBCLASS_FRAME *pFramePrev;
    struct SUBCLASS_HEADER *pHeader;
} SUBCLASS_FRAME, *PSUBCLASS_FRAME;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct SUBCLASS_HEADER |
 *
 *          Structure which tracks the subclass goo associated with
 *          a window.  A pointer to this structure is kept in a private
 *          window property.
 *
 *  @field  UINT | uRefs |
 *
 *          Subclass count.  This is the number of valid entries
 *          in the <p CallArray>.
 *
 *  @field  UINT | uAlloc |
 *
 *          Number of allocated <t SUBCLASS_CALL> nodes in the array.
 *
 *  @field  UINT | uCleanup |
 *
 *          Index of the call node to clean up.
 *
 *  @field  WORD | dwThreadId |
 *
 *          Thread id of the window with which the structure is associated.
 *
 *  @field  PSUBCLASS_FRAME | pFrameCur |
 *
 *          Pointer to the current subclass frame.
 *
 *  @field  SUBCLASS_CALL | CallArray[1] |
 *
 *          Base of the packed call node array.
 *
 *****************************************************************************/

typedef struct SUBCLASS_HEADER {
    UINT uRefs;
    UINT uAlloc;
    UINT uCleanup;
    DWORD dwThreadId;
    PSUBCLASS_FRAME pFrameCur;
    SUBCLASS_CALL CallArray[1];
} SUBCLASS_HEADER, *PSUBCLASS_HEADER;

#define CALLBACK_ALLOC_GRAIN (3)        /* 1 defproc, 1 subclass, 1 spare */

LRESULT CALLBACK
MasterSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp);


LRESULT INTERNAL
CallNextSubclassProc(PSUBCLASS_HEADER pHeader, HWND hwnd, UINT wm,
                     WPARAM wp, LPARAM lp);

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | SubclassDeath |
 *
 *          This function is called if we ever enter one of our subclassing
 *          procedures without our reference data (and hence without the
 *          previous <t WNDPROC>).
 *
 *          Hitting this represents a catastrophic failure in the
 *          subclass code.
 *
 *          The function resets the <t WNDPROC> of the window to
 *          <f DefWindowProc> to avoid faulting.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window that just got hosed.
 *
 *  @parm   UINT | wm |
 *
 *          Window message that caused us to realize that we are hosed.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *****************************************************************************/


LRESULT INTERNAL
SubclassDeath(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    /*
     * WE SHOULD NEVER EVER GET HERE
     */
    // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
	SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Fatal! SubclassDeath in window %p"),
                    hwnd);
    AssertF(0);

    /*
     * We call the outside world, so we'd better not have the critsec.
     */
    AssertF(!InCrit());

    /*
     * In theory, we could save the original WNDPROC in a separate property,
     * but that just wastes memory for something that should never happen.
     */
#ifdef WINNT
    SetWindowLongPtr( hwnd, GWLP_WNDPROC, (LONG_PTR)(DefWindowProc));
#else
    SubclassWindow(hwnd, DefWindowProc);
#endif

    return DefWindowProc(hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   WNDPROC | GetWindowProc |
 *
 *          Returns the <t WNDPROC> of the specified window.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window to be inspected.
 *
 *  @returns
 *
 *          The <t WNDPROC> of the specified window.
 *
 *****************************************************************************/

WNDPROC INLINE
GetWindowProc(HWND hwnd)
{
#ifdef WINNT
    return (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
#else
    return (WNDPROC)GetWindowLong(hwnd, GWL_WNDPROC);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @global ATOM | g_atmDISubclass |
 *
 *          This is the global <t ATOM> we use to store our
 *          <t SUBCLASS_HEADER> property on whatever windows come our way.
 *
 *          If the <p WIN95_HACK> symbol is defined, then we will work
 *          around a bug in Windows 95 where Windows "helpfully"
 *          <f GlobalDeleteAtom>'s all properties that are on a window
 *          when the window dies.  See Francis's original explanation
 *          in subclass.c.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszDISubclass[] = TEXT("DirectInputSubclassInfo");

#pragma END_CONST_DATA

#ifdef WIN95_HACK
ATOM g_atmDISubclass;
#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSUBCLASS_HEADER | FastGetSubclassHeader |
 *
 *          Obtains the <t SUBCLASS_HEADER> for the specified window.
 *
 *          This function succeeds on any thread, although the value
 *          is meaningless from the wrong process.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @returns
 *
 *          Pointer to the <t SUBCLASS_HEADER> associated with the window,
 *          or <c NULL> if the window is not subclassed by us.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INLINE
FastGetSubclassHeader(HWND hwnd)
{
#ifdef WIN95_HACK
    /*
     *  The right thing happens if g_atmDISubclass is 0, namely,
     *  the property is not found.  Unfortunately, NT RIPs when
     *  you do this, so we'll be polite and not RIP.
     */
    if (g_atmDISubclass) {
        return (PSUBCLASS_HEADER)GetProp(hWnd, (PV)g_atmDISubclass);
    } else {
        return 0;
    }
#else
    return (PSUBCLASS_HEADER)GetProp(hwnd, c_tszDISubclass);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSUBCLASS_HEADER | GetSubclassHeader |
 *
 *          Obtains the <t SUBCLASS_HEADER> for the specified window.
 *          It fails if the caller is in the wrong process, but will
 *          allow the caller to get the header from a different thread.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @returns
 *
 *          Pointer to the <t SUBCLASS_HEADER> associated with the window,
 *          or <c NULL> if the window is not subclass by us yet, or 1 
 *          if it belongs to another process.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INTERNAL
GetSubclassHeader(HWND hwnd)
{
    DWORD idProcess;

    /*
     *  Make sure we're in the right process.
     *
     *  Must use our helper function to catch bad scenarios like
     *  the goofy Windows 95 console window which lies about its
     *  owner.
     */

    idProcess = GetWindowPid(hwnd);

    if (idProcess == GetCurrentProcessId()) {   /* In the right process */
        return FastGetSubclassHeader(hwnd);
    } else {
        if (idProcess) {
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("XxxWindowSubclass: ")
                            TEXT("wrong process for window %p"), hwnd);
        }
        return (PSUBCLASS_HEADER)1;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | SetSubclassHeader |
 *
 *          Sets the <t SUBCLASS_HEADER> for the specified window.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The value to set.
 *
 *  @parm   PSUBCLASS_FRAME | pFrameFixup |
 *
 *          The active frames, which need to be walked and fixed up
 *          to refer to the new <t SUBCLASS_HEADER>.
 *
 *****************************************************************************/

BOOL INTERNAL
SetSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader,
                  PSUBCLASS_FRAME pFrameFixup)
{
    BOOL fRc;

    AssertF(InCrit());      /* We are partying on the header and frame list */

#ifdef WIN95_HACK
    if (g_atmDISubclass == 0) {
        ATOM atm;
        /*
         *  HACK: we are intentionally incrementing the refcount on this atom
         *  WE DO NOT WANT IT TO GO BACK DOWN so we will not delete it in
         *  process detach (see comments for g_atmDISubclass in subclass.c
         *  for more info).
         */
        atm = GlobalAddAtom(c_tszDISubclass);
        if (atm) {
            g_atmDISubclass = atm;  /* In case the old atom got nuked */
        }
    }
#endif

    /*
     *  Update the frame list if required.
     */
    while (pFrameFixup) {
        pFrameFixup->pHeader = pHeader;
        pFrameFixup = pFrameFixup->pFramePrev;
    }

    /*
     *  If we have a window to update, then update/remove the property
     *  as required.
     */
    if (hwnd) {
        if (!pHeader) {
#ifdef WIN95_HACK
            /*
             * HACK: we remove with an ATOM so the refcount won't drop
             *          (see comments for g_atmDISubclass above)
             */
            RemoveProp(hwnd, (PV)g_atmDISubclass);
#else
			// 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqfl, TEXT("SetSubclassHeader: Removing %p"),
                            pHeader);
            RemoveProp(hwnd, c_tszDISubclass);
#endif
            fRc = 1;
        } else {
#ifdef WIN95_HACK
            /*
             * HACK: we add using a STRING so the refcount will go up
             *          (see comments for g_atmDISubclass above)
             */
#endif
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl, TEXT("SetSubclassHeader: Adding %p"),
                            pHeader);
            fRc = SetProp(hwnd, c_tszDISubclass, pHeader);
            if (!fRc) {
                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
				SquirtSqflPtszV(sqfl | sqflError, TEXT("SetWindowSubclass: ")
                                TEXT("couldn't subclass window %p"), hwnd);
            }
        }
    } else {
        fRc = 1;                /* Weird vacuous success */
    }

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | FreeSubclassHeader |
 *
 *          Toss the subclass header for the specified window.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The value being tossed.
 *
 *****************************************************************************/

void INTERNAL
FreeSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader)
{
    AssertF(InCrit());          /* we will be removing the subclass header */

    /*
     *  Sanity checking...
     */
    if (pHeader) {
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl, TEXT("FreeSubclassHeader: Freeing %p"),
                        pHeader);
        SetSubclassHeader(hwnd, 0, pHeader->pFrameCur); /* Clean up the header */
        LocalFree(pHeader);
    } else {
        AssertF(0);
    }

}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ReallocSubclassHeader |
 *
 *          Change the size of the subclass header as indicated.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The current header.
 *
 *  @parm   UINT | uCallbacks |
 *
 *          Desired size.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INTERNAL
ReAllocSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader, UINT uCallbacks)
{
    UINT uAlloc;

    AssertF(InCrit());      /* we will be replacing the subclass header */

    /*
     *  Granularize the allocation.
     */
    uAlloc = CALLBACK_ALLOC_GRAIN *
        ((uCallbacks + CALLBACK_ALLOC_GRAIN - 1) / CALLBACK_ALLOC_GRAIN);

    /*
     *  Do we need to change the allocation?
     */
    if (!pHeader || (uAlloc != pHeader->uAlloc)) {
        /*
         * compute bytes required
         */
        uCallbacks = uAlloc * sizeof(SUBCLASS_CALL) + sizeof(SUBCLASS_HEADER);

        /*
         * And try to alloc / realloc.
         */
        if (SUCCEEDED(ReallocCbPpv(uCallbacks, &pHeader))) {
            /*
             * Update info.
             */
            pHeader->uAlloc = uAlloc;

            if (SetSubclassHeader(hwnd, pHeader, pHeader->pFrameCur)) {
            } else {
                FreeSubclassHeader(hwnd, pHeader);
                pHeader = 0;
            }
        } else {
            pHeader = 0;
        }
    }

    AssertF(pHeader);
    return pHeader;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CallOriginalWndProc |
 *
 *          This procedure is the default <t SUBCLASSPROC> which is always
 *          installed when we subclass a window.  The original window
 *          procedure is installed as the reference data for this
 *          callback.  It simply calls the original <t WNDPROC> and
 *          returns its result.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   UINT | wm |
 *
 *          Window message that needs to go to the original <t WNDPROC>.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          ID number (not used).
 *
 *  @parm   DWORD | dwRefData |
 *
 *          Reference data for subclass procedure (original <t WNDPROC>).
 *
 *****************************************************************************/

LRESULT CALLBACK
CallOriginalWndProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp,
                    UINT_PTR uIdSubclass, ULONG_PTR dwRefData)
{
    /*
     * dwRefData should be the original window procedure
     */
    AssertF(dwRefData);

    /*
     * and call it.
     */
    return CallWindowProc((WNDPROC)dwRefData, hwnd, wm, wp, lp);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSUBCLASS_HEADER | AttachSubclassHeader |
 *
 *          This procedure makes sure that a given window is subclassed by us.
 *          It maintains a reference count on the data structures associated
 *          with our subclass.  if the window is not yet subclassed by us
 *          then this procedure installs our subclass procedure and
 *          associated data structures.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INTERNAL
AttachSubclassHeader(HWND hwnd)
{
    PSUBCLASS_HEADER pHeader;

    /*
     *  We party on the subclass call chain here
     */
    AssertF(InCrit());

    /*
     *  Yes, we subclass the window out of context, but we are careful
     *  to avoid race conditions.  There is still a problem if some
     *  other DLL tries to un-subclass a window just as we are subclassing
     *  it.  But there's nothing you can do about it, and besides,
     *  what are the odds...?
     */

    /*
     * If haven't already subclassed the window then do it now
     */
    pHeader = GetSubclassHeader(hwnd);

    if( pHeader == (PSUBCLASS_HEADER)1 )
    {
        /*
         * It's all gone horribly wrong.
         * This can happen when the application uses joyXXX functions in Winmm.dll.
         */
        pHeader = 0;
    }
    else if (pHeader == 0) {
        /*
         * attach our header data to the window
         * we need space for two callbacks:
         * the subclass and the original proc
         */
        pHeader = ReAllocSubclassHeader(hwnd, 0, 2);
        if (pHeader) {
            SUBCLASS_CALL *pCall;

            /*
             *  Set up the first node in the array to call
             *  the original WNDPROC.  Do this before subclassing
             *  to avoid a race if the window receives a message
             *  after we have installed our subclass but before
             *  we can save the original WNDPROC.
             */
            AssertF(pHeader->uAlloc);

            pCall = pHeader->CallArray;
            pCall->pfnSubclass = CallOriginalWndProc;
            pCall->uIdSubclass = 0;
            pCall->dwRefData   = (ULONG_PTR)GetWindowProc(hwnd);

            /*
             * init our subclass refcount...
             */
            pHeader->uRefs = 1;

            pHeader->dwThreadId = GetWindowThreadProcessId(hwnd, NULL);

            /*
             *  Super-paranoid.  We must must not race with another
             *  instance of ourselves trying to un-subclass.
             */
            AssertF(InCrit());

            /*
             *  Save the new "old" wndproc in case we raced with
             *  somebody else trying to subclass.
             */
#ifdef WINNT
            pCall->dwRefData = (ULONG_PTR)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)MasterSubclassProc);
#else
            pCall->dwRefData = (DWORD)SubclassWindow(hwnd, MasterSubclassProc);
#endif
            if (pCall->dwRefData) {
                DllLoadLibrary();   /* Make sure we don't get unloaded */
            } else {                /* clean up and get out */
                FreeSubclassHeader(hwnd, pHeader);
                pHeader = 0;
            }
        }
    }

    return pHeader;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DetachSubclassHeader |
 *
 *          This procedure attempts to detach the subclass header from
 *          the specified window.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          Header to detach.
 *
 *  @parm   BOOL | fForce |
 *
 *          Nonzero if we should detach even if we are not the top-level
 *          subclass.
 *
 *****************************************************************************/

void INTERNAL
DetachSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader, BOOL fForce)
{
    WNDPROC wndprocOld;

    AssertF(InCrit());      /* we party on the subclass call chain here */
    AssertF(pHeader);       /* fear */

    /*
     *  If we are not being forced to remove and the window is still
     *  valid then sniff around a little and decide if it's a good
     *  idea to detach now.
     */
    if (!fForce && hwnd) {
        AssertF(pHeader == FastGetSubclassHeader(hwnd)); /* paranoia */

        /* should always have the "call original" node */
        AssertF(pHeader->uRefs);

        /*
         *  We can't have active clients.
         *  We can't have people still on our stack.
         */
        if (pHeader->uRefs <= 1 && !pHeader->pFrameCur) {

            /*
             *  We must be in the correct context.
             */
            if (pHeader->dwThreadId == GetCurrentThreadId()) {

                /*
                 *  We kept the original window procedure as refdata for our
                 *  CallOriginalWndProc subclass callback.
                 */
                wndprocOld = (WNDPROC)pHeader->CallArray[0].dwRefData;
                AssertF(wndprocOld);

                /*
                 *  Make sure we are the top of the subclass chain.
                 */
                if (GetWindowProc(hwnd) == MasterSubclassProc) {

                    /*
                     * go ahead and try to detach
                     */
#ifdef WINNT
                    if (SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)wndprocOld)) {
#else
                    if (SubclassWindow(hwnd, wndprocOld)) {
#endif
                        SquirtSqflPtszV(sqfl, TEXT("DetachSubclassHeader: ")
                                        TEXT("Unhooked"));
                    } else {
                        AssertF(0);         /* just plain shouldn't happen */
                        goto failed;
                    }
                } else {            /* Not at top of chain; can't do it */
                    SquirtSqflPtszV(sqfl, TEXT("DetachSubclassHeader: ")
                                    TEXT("Somebody else subclassed"));
                    goto failed;
                }
            } else {                /* Out of context. Try again later. */
                SendNotifyMessage(hwnd, WM_NULL, 0, 0L);
                goto failed;
            }
        } else {
			// 7/18/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
            SquirtSqflPtszV(sqfl, TEXT("DetachSubclassHeader: ")
                            TEXT("Still %d users, %p frame"),
                            pHeader->uRefs, pHeader->pFrameCur);
            goto failed;
        }
    }

#if 0
#ifdef DEBUG
    {
    /*
     * warn about anybody who hasn't unhooked yet
     */
    UINT uCur;    
    SUBCLASS_CALL *pCall;
    
    uCur = pHeader->uRefs;
    pCall = pHeader->CallArray + uCur;
    /* don't complain about our 'call original' node */
    while (--uCur) {
        pCall--;
        if (pCall->pfnSubclass) {
            /*
             * always warn about these they could be leaks
             */
            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl | sqflError, TEXT("warning: orphan subclass: ")
                            TEXT("fn %p, id %08x, dw %08x"),
                            pCall->pfnSubclass, pCall->uIdSubclass,
                            pCall->dwRefData);
        }
    }
    }
#endif
#endif
    /*
     * free the header now
     */
    FreeSubclassHeader(hwnd, pHeader);

    DllFreeLibrary();               /* Undo LoadLibrary when we hooked */


failed:;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | PurgeSingleCallNode |
 *
 *          Purges a single dead node in the call array.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The header associated with the window.
 *          The <p uCleanup> field is the index of the node being
 *          cleaned up.
 *
 *****************************************************************************/

void INTERNAL
PurgeSingleCallNode(HWND hwnd, PSUBCLASS_HEADER pHeader)
{

    AssertF(InCrit());      /* we will try to re-arrange the call array */

    if (pHeader->uCleanup) {/* Sanity check */
        UINT uRemain;

        SquirtSqflPtszV(sqfl,
                TEXT("PurgeSingleCallNode: Purging number %d"),
                pHeader->uCleanup);

        /*
         * and a little paranoia
         */
        AssertF(pHeader->CallArray[pHeader->uCleanup].pfnSubclass == 0);

        AssertF(fLimpFF(pHeader->pFrameCur,
                        pHeader->uCleanup < pHeader->pFrameCur->uDeepestCall));

        /*
         * are there any call nodes above the one we're about to remove?
         */
        uRemain = pHeader->uRefs - pHeader->uCleanup;
        if (uRemain > 0) {
            /*
             * yup, need to fix up the array the hard way
             */
            SUBCLASS_CALL *pCall;
            SUBCLASS_FRAME *pFrame;
            UINT uCur, uMax;

            /*
             * move the remaining nodes down into the empty space
             */
            pCall = pHeader->CallArray + pHeader->uCleanup;
            /*
             *  Since the souce and destination overlap (unless there's only 
             *  one node remaining) the behavior of memcpy is undefined.
             *  memmove (aka MoveMemory) would guarantee the correct 
             *  behavior but requires the runtime library.
             *  Since this is the only function we require in retail from the 
             *  RTL, it is not worth the 22% bloat we gain from using the 
             *  static version and using the dynamic version is a load time 
             *  and redist test hit.  So copy the array one element at a time.
             */
            for( uCur = 0; uCur < uRemain; uCur++ )
            {
                memcpy( &pCall[uCur], &pCall[uCur+1], sizeof(*pCall) );
            }

            /*
             * update the call indices of any active frames
             */
            uCur = pHeader->uCleanup;
            pFrame = pHeader->pFrameCur;
            while (pFrame) {
                if (pFrame->uCallIndex >= uCur) {
                    pFrame->uCallIndex--;

                    if (pFrame->uDeepestCall >= uCur) {
                        pFrame->uDeepestCall--;
                    }
                }

                pFrame = pFrame->pFramePrev;
            }

            /*
             * now search for any other dead call nodes in the remaining area
             */
            uMax = pHeader->uRefs - 1;  /* we haven't decremented uRefs yet */
            while (uCur < uMax && pCall->pfnSubclass)  {
                pCall++;
                uCur++;
            }
            pHeader->uCleanup = (uCur < uMax) ? uCur : 0;
        } else {
            /*
             * No call nodes above.  This case is easy.
             */
            pHeader->uCleanup = 0;
        }

        /*
         * finally, decrement the client count
         */
        pHeader->uRefs--;
        SquirtSqflPtszV(sqfl, TEXT("warning: PurgeSingleCallNode: ")
                        TEXT("Still %d refs"), pHeader->uRefs);

    } else {
        AssertF(0);         /* Nothing to do! */
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | CompactSubclassHeader |
 *
 *          Attempts to compact the subclass array, freeing the
 *          subclass header if the array is empty.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The header associated with the window.
 *
 *****************************************************************************/

void INTERNAL
CompactSubclassHeader(HWND hwnd, PSUBCLASS_HEADER pHeader)
{
    AssertF(InCrit());      /* we will try to re-arrange the call array */

    /*
     * we must handle the "window destroyed unexpectedly during callback" case
     */
    if (hwnd) {
        /*
         *  Clean out as many dead callbacks as possible.
         *
         *  The "DeepestCall" test is an optimization so we don't go
         *  purging call nodes when no active frame cares.
         *
         *  (I'm not entirely conviced of this.  I mean, we have to
         *  purge it eventually anyway, right?)
         */
        while (pHeader->uCleanup &&
               fLimpFF(pHeader->pFrameCur,
                       pHeader->uCleanup < pHeader->pFrameCur->uDeepestCall)) {
            PurgeSingleCallNode(hwnd, pHeader);
        }

        /*
         * do we still have clients?
         */
        if (pHeader->uRefs > 1) {
            SquirtSqflPtszV(sqfl, TEXT("CompactSubclassHeader: ")
                            TEXT("Still %d users"), pHeader->uRefs);
            /*
             * yes, shrink our allocation, leaving room for at least one client
             */
            ReAllocSubclassHeader(hwnd, pHeader, pHeader->uRefs + 1);
            goto done;
        }
    }

    /*
     *  There are no clients left, or the window is gone.
     *  Try to detach and free
     */
    DetachSubclassHeader(hwnd, pHeader, FALSE);

done:;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PSUBCLASS_CALL | FindCallRecord |
 *
 *          Searches for a call record with the specified subclass proc
 *          and id, and returns its address.  If no such call record is
 *          found then NULL is returned.
 *
 *          This is a helper function used when we need to track down
 *          a callback because the client is changing its refdata or
 *          removing it.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The header in which to search.
 *
 *  @parm   SUBCLASSPROC | pfnSubclass |
 *
 *          Subclass callback procedure to locate.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          Instance identifier associated with the callback.
 *
 *****************************************************************************/

SUBCLASS_CALL * INTERNAL
FindCallRecord(PSUBCLASS_HEADER pHeader, SUBCLASSPROC pfnSubclass,
               UINT_PTR uIdSubclass)
{
    SUBCLASS_CALL *pCall;
    UINT uCallIndex;

    AssertF(InCrit());      /* we'll be scanning the call array */

    /*
     * scan the call array.  note that we assume there is always at least
     * one member in the table (our CallOriginalWndProc record)
     */
    uCallIndex = pHeader->uRefs;
    pCall = &pHeader->CallArray[uCallIndex];
    do {
        uCallIndex--;
        pCall--;
        if ((pCall->pfnSubclass == pfnSubclass) &&
            (pCall->uIdSubclass == uIdSubclass))
        {
            return pCall;
        }
    } while (uCallIndex != (UINT)-1);

    return NULL;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | GetWindowSubclass |
 *
 *          Retrieves the reference data for the specified window
 *          subclass callback.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   SUBCLASSPROC | pfnSubclass |
 *
 *          Subclass callback procedure to locate.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          Instance identifier associated with the callback.
 *
 *  @parm   LPDWORD | pdwRefData |
 *
 *          Output pointer.
 *
 *****************************************************************************/

BOOL EXTERNAL
GetWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
                  PULONG_PTR pdwRefData)
{
    BOOL fRc;
    ULONG_PTR dwRefData;

    DllEnterCrit();

    /*
     * sanity
     */
    if (IsWindow(hwnd) && pfnSubclass) {
        PSUBCLASS_HEADER pHeader;
        SUBCLASS_CALL *pCall;

        /*
         * if we've subclassed it and they are a client then get the refdata
         */
        pHeader = GetSubclassHeader(hwnd);
        if (pHeader &&
            (pHeader != (PSUBCLASS_HEADER)1) && 
            (pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass)) != 0) {
            /*
             * fetch the refdata and note success
             */
            fRc = 1;
            dwRefData = pCall->dwRefData;
        } else {
            fRc = 0;
            dwRefData = 0;
        }

    } else {                            /* Invalid window handle */
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl | sqflError, TEXT("GetWindowSubclass: ")
                        TEXT("Bad window %p or callback %p"),
                        hwnd, pfnSubclass);
        fRc = 0;
        dwRefData = 0;
    }

    /*
     * we always fill in/zero pdwRefData regradless of result
     */
    if (pdwRefData) {
        *pdwRefData = dwRefData;
    }

    DllLeaveCrit();

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | SetWindowSubclass |
 *
 *          Installs/updates a window subclass callback.  Subclass
 *          callbacks are identified by their callback address and id pair.
 *          If the specified callback/id pair is not yet installed then
 *          the procedure installs the pair.  If the callback/id pair is
 *          already installed, then this procedure changes the reference
 *          data for the pair.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   SUBCLASSPROC | pfnSubclass |
 *
 *          Subclass callback procedure to install or modify.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          Instance identifier associated with the callback.
 *
 *  @parm   DWORD | dwRefData |
 *
 *          Reference data to associate with the callback/id.
 *
 *****************************************************************************/

BOOL EXTERNAL
SetWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
                  ULONG_PTR dwRefData)
{
    BOOL fRc;

    /*
     * sanity
     */
    if (IsWindow(hwnd) && pfnSubclass) {
        SUBCLASS_HEADER *pHeader;

        /*
         * we party on the subclass call chain here
         */
        DllEnterCrit();

        /*
         * actually subclass the window
         */
        /*
         *  Prefix gets confused (mb:34501) by this.  I assume this is because 
         *  AttachSubclassHeader returns a pointer to allocated memory but we 
         *  allow the pointer to go out of context without saving it.  This is 
         *  OK because AttachSubclassHeader already saved it for us.
         */
        pHeader = AttachSubclassHeader(hwnd);
        if (pHeader) {
            SUBCLASS_CALL *pCall;

            /*
             * find a call node for this caller
             */
            pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass);
            if (pCall == NULL) {
                /*
                 * not found, alloc a new one
                 */
                SUBCLASS_HEADER *pHeaderT =
                    ReAllocSubclassHeader(hwnd, pHeader, pHeader->uRefs + 1);

                if (pHeaderT) {
                    pHeader = pHeaderT;
                    pCall = &pHeader->CallArray[pHeader->uRefs++];
                } else {
                    /*
                     * re-query in case it is already gone
                     */
                    pHeader = FastGetSubclassHeader(hwnd);
                    if (pHeader) {
                        CompactSubclassHeader(hwnd, pHeader);
                    }
                    goto bail;
                }

            }

            /*
             * fill in the subclass call data
             */
            pCall->pfnSubclass = pfnSubclass;
            pCall->uIdSubclass = uIdSubclass;
            pCall->dwRefData   = dwRefData;

            // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
			SquirtSqflPtszV(sqfl,
                    TEXT("SetWindowSubclass: Added %p/%d as %d"),
                    pfnSubclass, uIdSubclass, pHeader->uRefs - 1);

            fRc = 1;

        } else {                        /* Unable to subclass */
        bail:;
            fRc = 0;
        }
        DllLeaveCrit();
    } else {
        fRc = 0;                        /* Invalid parameter */
    }

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | RemoveWindowSubclass |
 *
 *          Removes a subclass callback from a window.
 *          Subclass callbacks are identified by their
 *          callback address and id pair.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   SUBCLASSPROC | pfnSubclass |
 *
 *          Subclass callback procedure to remove.
 *
 *  @parm   UINT | uIdSubclass |
 *
 *          Instance identifier associated with the callback.
 *
 *****************************************************************************/

BOOL EXTERNAL
RemoveWindowSubclass(HWND hwnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass)
{
    BOOL fRc;

    /*
     * sanity
     */
    if (IsWindow(hwnd) && pfnSubclass) {
        SUBCLASS_HEADER *pHeader;

        /*
         * we party on the subclass call chain here
         */
        DllEnterCrit();

        /*
         * obtain our subclass data and find the callback to remove.
         */
        pHeader = GetSubclassHeader(hwnd);
        if (pHeader && (pHeader != (PSUBCLASS_HEADER)1) ) {
            SUBCLASS_CALL *pCall;

            /*
             * find the callback to remove
             */
            pCall = FindCallRecord(pHeader, pfnSubclass, uIdSubclass);

            if (pCall) {
                UINT uCall;

                /*
                 *  disable this node.
                 */
                pCall->pfnSubclass = 0;

                /*
                 *  Remember that we have something to clean up.
                 *
                 *  Set uCleanup to the index of the shallowest node that
                 *  needs to be cleaned up.  CompactSubclassHeader will
                 *  clean up everything from uCleanup onward.
                 */

                uCall = (UINT)(pCall - pHeader->CallArray);
                if (fLimpFF(pHeader->uCleanup, uCall < pHeader->uCleanup)) {
                    pHeader->uCleanup = uCall;
                }

                // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
				SquirtSqflPtszV(sqfl,
                        TEXT("RemoveWindowSubclass: Removing %p/%d as %d"),
                        pfnSubclass, uIdSubclass, uCall);

                /*
                 * now try to clean up any unused nodes
                 */
                CompactSubclassHeader(hwnd, pHeader);

                /*
                 * the call above can realloc or free the subclass
                 * header for this window, so make sure we don't use it.
                 */
                D(pHeader = 0);

                fRc = 1;

            } else {                /* Not found */
                fRc = 0;
            }
        } else {                    /* Never subclassed (ergo not found) */
            fRc = 0;
        }

        /*
         * release the critical section and return the result
         */
        DllLeaveCrit();
    } else {
        fRc = 0;                    /* Validation failed */
    }
    return fRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | DefSubclassProc |
 *
 *          Calls the next handler in the window's subclass chain.
 *          The last handler in the subclass chain is installed by us,
 *          and calls the original window procedure for the window.
 *
 *          Every subclass procedure should call <f DefSubclassProc>
 *          in order to allow the message to be processed by other handlers.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window in question.
 *
 *  @parm   UINT | wm |
 *
 *          Window message that needs to go to the original <t WNDPROC>.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *****************************************************************************/

LRESULT EXTERNAL
DefSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    LRESULT lResult;

    /*
     * make sure the window is still valid
     */
    if (IsWindow(hwnd)) {
        PSUBCLASS_HEADER pHeader;

        /*
         * take the critical section while we figure out who to call next
         */
        AssertF(!InCrit());
        DllEnterCrit();

        /*
         * complain if we are being called improperly
         */
        pHeader = FastGetSubclassHeader(hwnd);
        if (pHeader &&
            pHeader->pFrameCur &&
            GetCurrentThreadId() == pHeader->dwThreadId) {

            /*
             * call the next proc in the subclass chain
             *
             * WARNING: this call temporarily releases the critical section
             * WARNING: pHeader is invalid when this call returns
             */
            lResult = CallNextSubclassProc(pHeader, hwnd, wm, wp, lp);
            D(pHeader = 0);

        } else {
            SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("DefSubclassProc: Called improperly"));
            lResult = 0;
        }
        DllLeaveCrit();

    } else {
        // 7/19/2000(a-JiTay): IA64: Use %p format specifier for 32/64-bit pointers.
		SquirtSqflPtszV(sqfl | sqflError,
                        TEXT("DefSubclassProc: %P not a window"),
                        hwnd);
        lResult = 0;
    }

    return lResult;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | UpdateDeepestCall |
 *
 *          Updates the deepest call index for the specified frame.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame in question.
 *
 *****************************************************************************/

void INTERNAL
UpdateDeepestCall(SUBCLASS_FRAME *pFrame)
{
    AssertF(InCrit());  /* we are partying on the frame list */

    /*
     *  My deepest call equals my current call or my parent's
     *  deepest call, whichever is deeper.
     */
    if (pFrame->pFramePrev &&
        (pFrame->pFramePrev->uDeepestCall < pFrame->uCallIndex)) {
        pFrame->uDeepestCall = pFrame->pFramePrev->uDeepestCall;
    } else {
        pFrame->uDeepestCall = pFrame->uCallIndex;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | EnterSubclassFrame |
 *
 *          Sets up a new subclass frame for the specified header,
 *          saving away the previous one.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          Header in question.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Brand new frame to link in.
 *
 *****************************************************************************/

void INLINE
EnterSubclassFrame(PSUBCLASS_HEADER pHeader, SUBCLASS_FRAME *pFrame)
{
    AssertF(InCrit());  /* we are partying on the header and frame list */

    /*
     * fill in the frame and link it into the header
     */
    pFrame->uCallIndex   = pHeader->uRefs + 1;
    pFrame->pFramePrev   = pHeader->pFrameCur;
    pFrame->pHeader      = pHeader;
    pHeader->pFrameCur   = pFrame;

    /*
     * initialize the deepest call index for this frame
     */
    UpdateDeepestCall(pFrame);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | LeaveSubclassFrame |
 *
 *          Tear down the current subclass frame, restoring the previous one.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame going away.
 *
 *****************************************************************************/

PSUBCLASS_HEADER INLINE
LeaveSubclassFrame(SUBCLASS_FRAME *pFrame)
{
    PSUBCLASS_HEADER pHeader;

    AssertF(InCrit());  /* we are partying on the header */

    /*
     * unlink the frame from its header (if it still exists)
     */
    pHeader = pFrame->pHeader;
    if (pHeader) {
        pHeader->pFrameCur = pFrame->pFramePrev;
    }

    return pHeader;
}

#ifdef SUBCLASS_HANDLEEXCEPTIONS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | SubclassFrameException |
 *
 *          Clean up when a exception is thrown from a subclass frame.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame to clean up.
 *
 *****************************************************************************/

void INTERNAL
SubclassFrameException(SUBCLASS_FRAME *pFrame)
{
    /*
     * clean up the current subclass frame
     */
    AssertF(!InCrit());
    DllEnterCrit();

    SquirtSqflPtszV(sqfl | sqflError, TEXT("SubclassFrameException: ")
                    TEXT("cleaning up subclass frame after exception"));
    LeaveSubclassFrame(pFrame);
    DllLeaveCrit();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | MasterSubclassProc |
 *
 *          The window procedure we install to dispatch subclass
 *          callbacks.
 *
 *          It maintains a linked list of "frames" through the stack
 *          which allow <f DefSubclassProc> to call the right subclass
 *          procedure in multiple-message scenarios.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window under attack.
 *
 *  @parm   UINT | wm |
 *
 *          Window message.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *****************************************************************************/

LRESULT CALLBACK
MasterSubclassProc(HWND hwnd, UINT wm, WPARAM wp, LPARAM lp)
{
    SUBCLASS_HEADER *pHeader;
    LRESULT lResult;

    /*
     * prevent people from partying on the callback chain while we look at it
     */
    AssertF(!InCrit());
    DllEnterCrit();

    /*
     * We'd better have our data.
     */
    pHeader = FastGetSubclassHeader(hwnd);
    if (pHeader) {
        SUBCLASS_FRAME Frame;

        /*
         * set up a new subclass frame and save away the previous one
         */
        EnterSubclassFrame(pHeader, &Frame);

#ifdef SUBCLASS_HANDLEEXCEPTIONS
        __try    /* protect our state information from exceptions */
#endif
        {
            /*
             * go ahead and call the subclass chain on this frame
             *
             * WARNING: this call temporarily releases the critical section
             * WARNING: pHeader is invalid when this call returns
             */
            lResult =
                CallNextSubclassProc(pHeader, hwnd, wm, wp, lp);
            D(pHeader = 0);
        }
#ifdef SUBCLASS_HANDLEEXCEPTIONS
        __except (SubclassFrameException(&Frame), EXCEPTION_CONTINUE_SEARCH)
        {
            AssertF(0);
        }
#endif

        AssertF(InCrit());

        /*
         * restore the previous subclass frame
         */
        pHeader = LeaveSubclassFrame(&Frame);

        /*
         *  Do postprocessing if the header is still here.
         */
        if (pHeader) {

            /*
             *  was the window nuked (somehow)
             *  without us seeing the WM_NCDESTROY?
             */
            if (!IsWindow(hwnd)) {
                /*
                 * EVIL! somebody subclassed after us and didn't pass on WM_NCDESTROY
                 */
                AssertF(!TEXT("unknown subclass proc swallowed a WM_NCDESTROY"));

                /* go ahead and clean up now */
                hwnd = 0;
                wm = WM_NCDESTROY;
            }

            /*
             * if we are returning from a WM_NCDESTROY then we need to clean up
             */
            if (wm == WM_NCDESTROY) {
                DetachSubclassHeader(hwnd, pHeader, TRUE);
            } else {

                /*
                 * is there any pending cleanup, or are all our clients gone?
                 */
                if (pHeader->uCleanup ||
                    (!pHeader->pFrameCur && (pHeader->uRefs <= 1))) {
                    CompactSubclassHeader(hwnd, pHeader);
                    D(pHeader = 0);
                }
            }

            /*
             * all done
             */

        } else {
            /*
             *  Header is gone.  We already cleaned up in a nested frame.
             */
        }
        DllLeaveCrit();
        AssertF(!InCrit());

    } else {                            /* Our property vanished! */
        DllLeaveCrit();
        lResult = SubclassDeath(hwnd, wm, wp, lp);
    }

    return lResult;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | EnterSubclassCallback |
 *
 *          Finds the next callback in the subclass chain and updates
 *          <p pFrame> to indicate that we are calling it.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          Controlling header.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame to update.
 *
 *  @parm   SUBCLASS_CALL * | pCallChosen |
 *
 *          The call selected for calling.
 *
 *****************************************************************************/

UINT INTERNAL
EnterSubclassCallback(PSUBCLASS_HEADER pHeader, SUBCLASS_FRAME *pFrame,
                      SUBCLASS_CALL *pCallChosen)
{
    SUBCLASS_CALL *pCall;
    UINT uDepth;

    /*
     * we will be scanning the subclass chain and updating frame data
     */
    AssertF(InCrit());

    /*
     * scan the subclass chain for the next callable subclass callback
     * Assert that the loop will terminate.
     */
    AssertF(pHeader->CallArray[0].pfnSubclass);
    pCall = pHeader->CallArray + pFrame->uCallIndex;
    uDepth = 0;
    do {
        uDepth++;
        pCall--;

    } while (!pCall->pfnSubclass);

    /*
     * copy the callback information for the caller
     */
    pCallChosen->pfnSubclass = pCall->pfnSubclass;
    pCallChosen->uIdSubclass = pCall->uIdSubclass;
    pCallChosen->dwRefData   = pCall->dwRefData;

    /*
     * adjust the frame's call index by the depth we entered
     */
    pFrame->uCallIndex -= uDepth;

    /*
     * keep the deepest call index up to date
     */
    UpdateDeepestCall(pFrame);

    return uDepth;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | LeaveSubclassCallback |
 *
 *          Get out one level.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame to update.
 *
 *  @parm   UINT | uDepth |
 *
 *          Who just finished.
 *
 *****************************************************************************/

void INLINE
LeaveSubclassCallback(SUBCLASS_FRAME *pFrame, UINT uDepth)
{
    /*
     * we will be updating subclass frame data
     */
     AssertF(InCrit());

    /*
     * adjust the frame's call index by the depth we entered and return
     */
    pFrame->uCallIndex += uDepth;

    /*
     * keep the deepest call index up to date
     */
    UpdateDeepestCall(pFrame);
}

#ifdef SUBCLASS_HANDLEEXCEPTIONS

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | SubclassCallbackException |
 *
 *          Clean up when a subclass callback throws an exception.
 *
 *  @parm   PSUBCLASS_FRAME | pFrame |
 *
 *          Frame to clean up.
 *
 *  @parm   UINT | uDepth |
 *
 *          Where we were.
 *
 *****************************************************************************/

void INTERNAL
SubclassCallbackException(SUBCLASS_FRAME *pFrame, UINT uDepth)
{
    /*
     * clean up the current subclass callback
     */
    AssertF(!InCrit());
    DllEnterCrit();
    SquirtSqflPtszV(sqfl | sqflError, TEXT("SubclassCallbackException: ")
                    TEXT("cleaning up subclass callback after exception"));
    LeaveSubclassCallback(pFrame, uDepth);
    DllLeaveCrit();
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LRESULT | CallNextSubclassProc |
 *
 *          Calls the next subclass callback in the subclass chain.
 *
 *          WARNING: this call temporarily releases the critical section.
 *
 *          WARNING: <p pHeader> is invalid when this call returns.
 *
 *  @parm   PSUBCLASS_HEADER | pHeader |
 *
 *          The header that is tracking the state.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window under attack.
 *
 *  @parm   UINT | wm |
 *
 *          Window message.
 *
 *  @parm   WPARAM | wp |
 *
 *          Meaning depends on window message.
 *
 *  @parm   LPARAM | lp |
 *
 *          Meaning depends on window message.
 *
 *****************************************************************************/

LRESULT INTERNAL
CallNextSubclassProc(PSUBCLASS_HEADER pHeader, HWND hwnd, UINT wm,
                     WPARAM wp, LPARAM lp)
{
    SUBCLASS_CALL Call;
    SUBCLASS_FRAME *pFrame;
    LRESULT lResult;
    UINT uDepth;

    AssertF(InCrit());  /* sanity */
    AssertF(pHeader);   /* paranoia */

    /*
     * get the current subclass frame
     */
    pFrame = pHeader->pFrameCur;
    AssertF(pFrame);

    /*
     * get the next subclass call we need to make
     */
    uDepth = EnterSubclassCallback(pHeader, pFrame, &Call);

    /*
     * leave the critical section so we don't deadlock in our callback
     *
     * WARNING: pHeader is invalid when this call returns
     */
    DllLeaveCrit();
    D(pHeader = 0);

    /*
     * we call the outside world so prepare to deadlock if we have the critsec
     */
    AssertF(!InCrit());

#ifdef SUBCLASS_HANDLEEXCEPTIONS
    __try    /* protect our state information from exceptions */
#endif
    {
        /*
         * call the chosen subclass proc
         */
        AssertF(Call.pfnSubclass);

        lResult = Call.pfnSubclass(hwnd, wm, wp, lp,
                                   Call.uIdSubclass, Call.dwRefData);
    }
#ifdef SUBCLASS_HANDLEEXCEPTIONS
    __except (SubclassCallbackException(pFrame, uDepth),
        EXCEPTION_CONTINUE_SEARCH)
    {
        AssertF(0);
    }
#endif

    /*
     * we left the critical section before calling out so re-enter it
     */
    AssertF(!InCrit());
    DllEnterCrit();

    /*
     * finally, clean up and return
     */
    LeaveSubclassCallback(pFrame, uDepth);
    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diport.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       digsport.h
 *  Content:    DirectInput internal include file for HID
 *
 ***************************************************************************/


#ifndef __DIPORT_H
    #define __DIPORT_H

/* Forward define */
typedef struct _BUSDEVICE BUSDEVICE, *PBUSDEVICE;



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct BUS_REGDATA
 *          Persistent Data, written to the registry for each gameport device. 
 *          Contains information on how to reexpose the analog joystick device
 *          on reboot. 
 *
 *  @field  DWORD | dwSize |
 *          Size of the structure. 
 *
 *  @field  USHORT | uVID |
 *          Vendor ID.
 *
 *  @field  USHORT | uPID |
 *          Product ID.
 *
 *  @field  USHORT | nJoysticks |
 *          Number of joysticks attached to this gameport. 
 *
 *  @field  USHORT | nAxes |
 *          Number of axes in each joystick. 
 *
 *  @field  PVOID | hHardwareHandle |
 *          Hardware handle returned by EXPOSE IOCTL to gameenum.
 *          Needed to remove the joystick device. 
 *
 *  @field  BOOLEAN | fAttachOnReboot |
 *          Flag that is cleared when a device is exposed and set when 
 *          the device is found to be OK.  Used to prevent reloading 
 *          of a device that crashes immediately.
 *
 *  @field  JOYREGHWSSETTINGS | hws |
 *          Joystick Hardware settings. 
 *
 *  @field  WCHAR | wszHardwareId |
 *          PnP hardware ID for the joystick. 
 * 
 *****************************************************************************/

typedef struct _BUS_REGDATA
{
    /* Size of structure */
    DWORD               dwSize;
    /* VID PID for this device */
    USHORT              uVID;
    USHORT              uPID;
    /* Number of joysticks to expose */
    USHORT              nJoysticks;
    USHORT              nAxes;
    /* Hardware settings for joystick */
    PVOID               hHardware;
    /* Flag whether or not device should be re-exposed */
    BOOLEAN             fAttachOnReboot;
    /* Joystick Hardware settings */
    JOYREGHWSETTINGS    hws;
    DWORD               dwFlags1;
    /* An array of (zero terminated wide character
     * strings).  The array itself also null terminated
     */
    WCHAR   wszHardwareId[MAX_JOYSTRING];

} BUS_REGDATA, *PBUS_REGDATA;



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct BUSDEVICEINFO
 *          Data about each instance of bus devices ( gameport / serial port, etc .. )
 *
 *  @field  PBUSDEVICE | pBusDevice |
 *          Address of the BusDevice struct.
 *
 *  @field  PSP_DEVICE_INTERFACE_DETAIL_DATA | pdidd |
 *          Device interface detail data. 
 *
 *  @field  GUID | guid |
 *          Instance GUID for the device.
 *
 *  @field  int | idPort |
 *          Unique ID for the gameport. 
 *
 *  @field  int | idJoy |
 *          Id of one of the joysticks attached to this gameport. 
 *
 *  @field  HKEY | hk |
 *          Registry key that contains configuration information.
 *          Sadly, we must keep it open because there is no way to
 *          obtain the name of the key, and the only way to open the
 *          key is inside an enumeration.
 *
 *  @field  LPTSTR  | ptszId |
 *          Device path to access the gameport for read / write. 
 *
 *  @field  BOOL    | fAttached |
 *          True is device is attached.
 *
 *  @field  BOOL    | fDeleteIfNotConnected |
 *          Flag that indicates that the device should be deleted if it
 *          is not connected. 
 *
 *******************************************************************************/

typedef struct _BUSDEVICEINFO
{
    PBUSDEVICE pBusDevice;
    PSP_DEVICE_INTERFACE_DETAIL_DATA    pdidd;
    GUID                                guid;
    int                                 idPort;
    int                                 idJoy;
    HKEY                                hk;
    LPTSTR                              ptszId;
    BOOL                                fAttached;
    BOOL                                fDeleteIfNotConnected;
} BUSDEVICEINFO, *PBUSDEVICEINFO;


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct BUSDEVICELIST |
 *
 *          Records information about all the HID devices.
 *
 *  @field  int | cbdi |
 *
 *          Number of items in the list that are in use.
 *
 *  @field  int | cbdiAlloc |
 *
 *          Number of items allocated in the list.
 *
 *  @field  BUSDEVICEINFO | rgbdi[0] |
 *
 *          Variable-size array of device information structures.
 *
 *****************************************************************************/

typedef struct _BUSDEVICELIST
{
    int cgbi;
    int cgbiAlloc;
    BUSDEVICEINFO rgbdi[0];
} BUSDEVICELIST, *PBUSDEVICELIST;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @struct BUSDEVICE |
 *
 *          Data specific to each bus ( gameport / serialPort ).
 *
 *  @field  PBUSDEVICE | pbdl |
 *          List of devices on a bus. 
 *
 *  @field  PCGUID  | pcGuid |
 *          Device GUID for the bus. 
 *
 *  @field  DWORD   | tmLastRebuild |
 *          Last time the bus device list was rebuild. 
 *
 *  @field  const int | ioctl_EXPOSE |
 *          IOCTL to expose a device.
 *
 *  @field  const int | ioclt_REMOVE |
 *          IOCTL to remove a device. 
 *
 *  @field  const int | ioctl_DESC |
 *          IOCTL to obtain description of the bus.
 *
 *  @field  const int | ioctl_PARAMETERS |
 *
 *  @field  const int | ioctl_EXPOSE_SIBLING |
 *
 *  @field  const int | ioctl_REMOVE_SELF |
 *
 *  @field  const int | dw_IDS_STDPORT |
 *          index into the IDS String table for text associated with device.
 *
 *  @field  const int | dw_JOY_HWS_ISPORTBUS |
 *
 *****************************************************************************/

typedef struct _BUSDEVICE
{
    D(TCHAR wszBusType[MAX_PATH];)
    PBUSDEVICELIST pbdl;
    PCGUID pcGuid;
    DWORD tmLastRebuild;
    const int ioctl_EXPOSE;
    const int ioctl_REMOVE;
    const int ioctl_DESC;
    const int ioctl_PARAMETERS;
    const int ioctl_EXPOSE_SIBLING;
    const int ioctl_REMOVE_SELF;
    const int dwIDS_STDPORT;
    const int dwJOY_HWS_ISPORTBUS;
} BUSDEVICE, *PBUSDEVICE;

extern BUSDEVICE g_pBusDevice[];


    #define cbGdlCbdi(cbdi)         FIELD_OFFSET(BUSDEVICELIST, rgbdi[cbdi])

/*
 *  We choose our starting point at 2 devices, since most machines
 *  will have one gameport/serialport bus.
 *  The maximum number is chosen at randomn
 */

    #define cgbiMax                 32
    #define cgbiInit                2   // Most machines will have only one gameport bus, two serialports


    #define MAX_PORT_BUSES  16


PBUSDEVICEINFO INTERNAL
    pbdiFromphdi
    (
    IN PHIDDEVICEINFO phdi
    );

PHIDDEVICEINFO INTERNAL
    phdiFrompbdi
    (
    IN PBUSDEVICEINFO pbdi
    );

PBUSDEVICEINFO EXTERNAL
    pbdiFromJoyId
    (
    IN int idJoy
    );

PBUSDEVICEINFO EXTERNAL
    pbdiFromGUID
    (
    IN PCGUID pguid    
    );

HRESULT EXTERNAL
    DIBusDevice_Expose
    (
    IN HANDLE hf,
    IN OUT PBUS_REGDATA pRegData
    );


HRESULT INTERNAL
    DIBusDevice_Remove
    (
    IN PBUSDEVICEINFO  pbdi
    );


HRESULT INTERNAL
    DIBusDevice_SetRegData
    (
    IN HKEY hk,
    IN PBUS_REGDATA pRegData
    );


HRESULT INTERNAL
    DIBusDevice_GetRegData
    (
    IN HKEY hk,
    OUT PBUS_REGDATA pRegData
    );


BOOL INTERNAL
    DIBusDevice_BuildListEntry
    (
    HDEVINFO hdev,
    PSP_DEVICE_INTERFACE_DATA pdid,
    PBUSDEVICE pBusDevice
    );


void INTERNAL
    DIBus_EmptyList
    (
    PBUSDEVICELIST *ppbdl 
    );

void EXTERNAL
    DIBus_FreeMemory();

HRESULT EXTERNAL
    DIBus_InitId
    (
     PBUSDEVICELIST pbdl
    );


ULONG EXTERNAL
    DIBus_BuildList
    (
    IN BOOL fForce
    );

PBUSDEVICELIST EXTERNAL 
    pbdlFromGUID
    ( 
    IN PCGUID pcGuid 
    );

HRESULT EXTERNAL
    DIBusDevice_ExposeEx
    (
    IN PBUSDEVICELIST  pbdl,
    IN PBUS_REGDATA    pRegData
    );

HRESULT EXTERNAL
    DIBusDevice_GetTypeInfo
    (
        PCGUID guid,
        LPDIJOYTYPEINFO pjti,
        DWORD fl
    );

HRESULT EXTERNAL DIPort_SnapTypes(LPWSTR *ppwszz);

#endif /* __DIPORT_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\guids.c ===
/*****************************************************************************
 *
 *  guids.c
 *
 *  Copyright (c) 1998 - 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *****************************************************************************/

#define INITGUID
#include <dinputpr.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diregutl.c ===
/*****************************************************************************
 *
 *  DIRegUtl.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Registry utility functions.
 *
 *  Contents:
 *
 *
 *****************************************************************************/
#include "dinputpr.h"

/*****************************************************************************
 *
 *  The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflRegUtils


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegQueryString |
 *
 *          Wrapper for <f RegQueryValueEx> that reads a
 *          string value from the registry.  An annoying quirk
 *          is that on Windows NT, the returned string might
 *          not end in a null terminator, so we might need to add
 *          one manually.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   LPTSTR | ptsz |
 *
 *          Output buffer.
 *
 *  @parm   DWORD | ctchBuf |
 *
 *          Size of output buffer.
 *
 *  @returns
 *
 *          Registry error code.
 *
 *****************************************************************************/

LONG EXTERNAL
    RegQueryString(HKEY hk, LPCTSTR ptszValue, LPTSTR ptszBuf, DWORD ctchBuf)
{
    LONG lRc;
    DWORD reg;

    #ifdef UNICODE
    DWORD cb;

    /*
     *  NT quirk: Non-null terminated strings can exist.
     */
    cb = cbCtch(ctchBuf);
    lRc = RegQueryValueEx(hk, ptszValue, 0, &reg, (PV)ptszBuf, &cb);
    if(lRc == ERROR_SUCCESS)
    {
        if(reg == REG_SZ)
        {
            /*
             *  Check the last character.  If it is not NULL, then
             *  append a NULL if there is room.
             */
            DWORD ctch = ctchCb(cb);
            if(ctch == 0)
            {
                ptszBuf[ctch] = TEXT('\0');
            } else if(ptszBuf[ctch-1] != TEXT('\0'))
            {
                if(ctch < ctchBuf)
                {
                    ptszBuf[ctch] = TEXT('\0');
                } else
                {
                    lRc = ERROR_MORE_DATA;
                }
            }
        } else
        {
            lRc = ERROR_INVALID_DATA;
        }
    }


    #else

    /*
     *  This code is executed only on Win95, so we don't have to worry
     *  about the NT quirk.
     */

    lRc = RegQueryValueEx(hk, ptszValue, 0, &reg, (PV)ptszBuf, &ctchBuf);

    if(lRc == ERROR_SUCCESS && reg != REG_SZ)
    {
        lRc = ERROR_INVALID_DATA;
    }


    #endif

    return lRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegQueryStringValueW |
 *
 *          Wrapper for <f RegQueryValueEx> that handles ANSI/UNICODE
 *          issues, as well as treating a nonexistent key as if it
 *          were a null string.
 *
 *          Note that the value name is still a <t LPCTSTR>.
 *
 *          It is assumed that the thing being read is a string.
 *          Don't use this function to read binary data.
 *
 *          You cannot use this function to query the necessary
 *          buffer size (again, because I'm lazy).  It's not as
 *          simple as doubling the ansi size, because DBCS may
 *          result in a non-linear translation function.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          UNICODE output buffer.
 *
 *  @parm   LPDWORD | pcbBuf |
 *
 *          Size of UNICODE output buffer.  May not exceed
 *          cbCwch(MAX_PATH).
 *
 *  @returns
 *
 *          Registry error code.  On error, the output buffer is
 *          set to a null string.  On an ERROR_MORE_DATA, the
 *          output buffer is null-terimated.
 *
 *****************************************************************************/

LONG EXTERNAL
    RegQueryStringValueW(HKEY hk, LPCTSTR ptszValue,
                         LPWSTR pwszBuf, LPDWORD pcbBuf)
{
    LONG lRc;

    #ifdef UNICODE

    AssertF(*pcbBuf > 0);
    AssertF(*pcbBuf <= cbCwch(MAX_PATH));

    /*
     *  NT quirk: Non-null terminated strings can exist.
     */
    lRc = RegQueryString(hk, ptszValue, pwszBuf, ctchCb(*pcbBuf));

    #else

    /*
     *  NT quirk: Non-null terminated strings can exist.  Fortunately,
     *  this code is executed only on Win95, which terminates properly.
     */
    DWORD cb;
    TCHAR tszBuf[MAX_PATH];

    AssertF(*pcbBuf > 0);
    AssertF(*pcbBuf <= cbCwch(MAX_PATH));

    /*
     *  ISSUE-2001/03/29-timgill Incorrect size returned in single case
     *  Note that we do not get the size perfect in the DBCS case.
     *
     *  Fortunately, the slop is on the high end, where hopefully
     *  nobody lives or will notice.
     *
     *  Is it worth fixing?
     */

    cb = cwchCb(*pcbBuf);
    lRc = RegQueryValueEx(hk, ptszValue, 0, 0, (PV)tszBuf, &cb);

    if(lRc == ERROR_SUCCESS)
    {
        DWORD cwch;

        /*
         *  Convert the string up to UNICODE.
         */
        cwch = AToU(pwszBuf, cwchCb(*pcbBuf), tszBuf);
        *pcbBuf = cbCwch(cwch);

        /*
         *  If the buffer was not big enough, the return value
         *  will be zero.
         */
        if(cwch == 0 && tszBuf[0])
        {
            lRc = ERROR_MORE_DATA;
        } else
        {
            lRc = ERROR_SUCCESS;
        }

    }
    #endif

    /*
     *  If the buffer was too small, then null-terminate it just
     *  to make sure.
     */
    if(lRc == ERROR_MORE_DATA)
    {
        if(*pcbBuf)
        {
            pwszBuf[cwchCb(*pcbBuf)-1] = TEXT('\0');
        }
    } else

        /*
         *  If it was some other error, then wipe out the buffer
         *  so the caller won't get confused.
         */
        if(lRc != ERROR_SUCCESS)
    {
        pwszBuf[0] = TEXT('\0');
        /*
         *  If the error was that the key doesn't exist, then
         *  treat it as if it existed with a null string.
         */
        if(lRc == ERROR_FILE_NOT_FOUND)
        {
            lRc = ERROR_SUCCESS;
        }
    }

    return lRc;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegSetStringValueW |
 *
 *          Wrapper for <f RegSetValueEx> that handles ANSI/UNICODE
 *          issues, as well as converting null strings into nonexistent
 *          values.
 *
 *          Note that the value name is still a <t LPCTSTR>.
 *
 *          It is assumed that the thing being written is a string.
 *          Don't use this function to write binary data.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   LPCWSTR | pwsz |
 *
 *          UNICODE value to write.  A null pointer is valid, indicating
 *          that the key should be deleted.
 *
 *  @returns
 *
 *          Registry error code.
 *
 *****************************************************************************/

LONG EXTERNAL
    RegSetStringValueW(HKEY hk, LPCTSTR ptszValue, LPCWSTR pwszData)
{
    DWORD cwch;
    LONG lRc;

    if(pwszData)
    {
        cwch = lstrlenW(pwszData);
    } else
    {
        cwch = 0;
    }

    if(cwch)
    {
#ifdef UNICODE
        lRc = RegSetValueExW(hk, ptszValue, 0, REG_SZ,
                             (PV)pwszData, cbCwch(cwch+1));
#else

        DWORD ctch;
        TCHAR tszBuf[MAX_PATH];

        /*
         *  Convert the string down to ANSI.
         */
        ctch = UToA(tszBuf, cA(tszBuf), pwszData);

        if(ctch)
        {
            lRc = RegSetValueEx(hk, ptszValue, 0, REG_SZ,
                                (PV)tszBuf, cbCtch(ctch+1));
        } else
        {
            lRc = ERROR_CANTWRITE;
        }

#endif

    } else
    {
        lRc = RegDeleteValue(hk, ptszValue);

        /*
         *  It is not an error if the key does not already exist.
         */
        if(lRc == ERROR_FILE_NOT_FOUND)
        {
            lRc = ERROR_SUCCESS;
        }
    }

    return lRc;
}

#ifndef UNICODE
/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegDeleteKeyW |
 *
 *          Wrapper for <f RegDeleteKeyA> on non-UNICODE platforms.
 *
 *  @parm   IN HKEY | hk |
 *
 *          Parent registry key.
 *
 *  @parm   LPCWSTR | pwsz |
 *
 *          Subkey name.
 *
 *  @returns
 *
 *          Registry error code.
 *
 *****************************************************************************/

LONG EXTERNAL
    RegDeleteKeyW(HKEY hk, LPCWSTR pwsz)
{
    LONG lRc;
    CHAR szBuf[MAX_PATH];

    /*
     *  Convert the string down to ANSI.
     */
    UToA(szBuf, cA(szBuf), pwsz);

    lRc = RegDeleteKeyA(hk, szBuf);

    return lRc;
}
#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresMumbleKeyEx |
 *
 *          Either open or create the key, depending on the degree
 *          of access requested.
 *
 *  @parm   HKEY | hk |
 *
 *          Base key.
 *
 *  @parm   LPCTSTR | ptszKey |
 *
 *          Name of subkey, possibly NULL.
 *
 *  @parm   REGSAM | sam |
 *
 *          Security access mask.
 *
 *  @parm   DWORD   | dwOptions |
 *          Options for RegCreateEx
 *
 *  @parm   PHKEY | phk |
 *
 *          Receives output key.
 *
 *  @returns
 *
 *          Return value from <f RegOpenKeyEx> or <f RegCreateKeyEx>,
 *          converted to an <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
    hresMumbleKeyEx(HKEY hk, LPCTSTR ptszKey, REGSAM sam, DWORD dwOptions, PHKEY phk)
{
    HRESULT hres;
    LONG lRc;
	BOOL bWinXP = FALSE;

    /*
     *  If caller is requesting write access, then create the key.
     *  Else just open it.
     */
    if(IsWriteSam(sam))
    {
		// on WinXP, we strip out WRITE_DAC and WRITE_OWNER bits
		if (DIGetOSVersion() == WINWH_OS)
		{
			sam &= ~DI_DAC_OWNER;
			bWinXP = TRUE;
		}
        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);

        if( lRc == ERROR_SUCCESS )
        {
            // Don't need to create it already exists
        } else
        {
    #ifdef WINNT
            EXPLICIT_ACCESS     ExplicitAccess;
            PACL                pACL;
            DWORD               dwErr;
            SECURITY_DESCRIPTOR SecurityDesc;
            DWORD               dwDisposition;
            SECURITY_ATTRIBUTES sa;
			PSID pSid = NULL;
			SID_IDENTIFIER_AUTHORITY authority = SECURITY_WORLD_SID_AUTHORITY;


            // Describe the access we want to create the key with
            ZeroMemory (&ExplicitAccess, sizeof(ExplicitAccess) );
			//set the access depending on the OS (see Whistler bug 318865)
			if (bWinXP == TRUE)
			{
				ExplicitAccess.grfAccessPermissions = DI_KEY_ALL_ACCESS;
			}
			else
			{
				ExplicitAccess.grfAccessPermissions = KEY_ALL_ACCESS;
			}
            ExplicitAccess.grfAccessMode = GRANT_ACCESS;     
            ExplicitAccess.grfInheritance =  SUB_CONTAINERS_AND_OBJECTS_INHERIT;

			if (AllocateAndInitializeSid(
						&authority,
						1, 
						SECURITY_WORLD_RID,  0, 0, 0, 0, 0, 0, 0,
						&pSid
						))
			{
				BuildTrusteeWithSid(&(ExplicitAccess.Trustee), pSid );

				dwErr = SetEntriesInAcl( 1, &ExplicitAccess, NULL, &pACL );


				if( dwErr == ERROR_SUCCESS )
				{
					AssertF( pACL );

					if( InitializeSecurityDescriptor( &SecurityDesc, SECURITY_DESCRIPTOR_REVISION ) )
					{
						if( SetSecurityDescriptorDacl( &SecurityDesc, TRUE, pACL, FALSE ) )
						{
							// Initialize a security attributes structure.
							sa.nLength = sizeof (SECURITY_ATTRIBUTES);
							sa.lpSecurityDescriptor = &SecurityDesc;
							sa.bInheritHandle = TRUE;// Use the security attributes to create a key.
        
							lRc = RegCreateKeyEx
								  (
								  hk,									// handle of an open key
								  ptszKey,								// address of subkey name
								  0,									// reserved
								  NULL,									// address of class string
								  dwOptions,							// special options flag
								  ExplicitAccess.grfAccessPermissions,  // desired security access
								  &sa,									// address of key security structure
								  phk,									// address of buffer for opened handle
								  &dwDisposition						// address of disposition value buffer);
								  );
                        
						}
						else
						{
							SquirtSqflPtszV( sqflError | sqflRegUtils,
											 TEXT("SetSecurityDescriptorDacl failed lastError=0x%x "),
											 GetLastError());
						}
					}
					else
					{
						SquirtSqflPtszV( sqflError | sqflRegUtils,
										 TEXT("InitializeSecurityDescriptor failed lastError=0x%x "),
										 GetLastError());
					}
            
					LocalFree( pACL );
				} 
				else
				{
					SquirtSqflPtszV( sqflError | sqflRegUtils,
									 TEXT("SetEntriesInACL failed, dwErr=0x%x"), dwErr );
				}
			}
			else
			{
			   SquirtSqflPtszV( sqflError | sqflRegUtils,
				   TEXT("AllocateAndInitializeSid failed lastError=0x%x "), GetLastError());

			}

			//Cleanup pSid
			if (pSid != NULL)
			{
				FreeSid(pSid);
			}


            if( lRc != ERROR_SUCCESS )
            {
				SquirtSqflPtszV( sqflError,
							TEXT("Failed to create regkey %s with security descriptor, lRc=0x%x "),
                             ptszKey, lRc);
            }
    #else
            lRc = RegCreateKeyEx(hk, ptszKey, 0, 0,
                                 dwOptions,
                                 sam, 0, phk, 0);
    #endif 
		}

    } else
    {
        lRc = RegOpenKeyEx(hk, ptszKey, 0, sam, phk);
    }

    if(lRc == ERROR_SUCCESS)
    {
        hres = S_OK;
    } else
    {
        if(lRc == ERROR_KEY_DELETED || lRc == ERROR_BADKEY)
        {
            lRc = ERROR_FILE_NOT_FOUND;
        }
        hres = hresLe(lRc);
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LONG | RegQueryDIDword |
 *
 *          Read a dword value from a sub key of the DirectInput part of the 
 *          registry.
 *
 *  @parm   LPCTSTR | ptszSubKey |
 *
 *          Optional path from root of DirectInput registry.
 *
 *  @parm   LPCTSTR | ptszValue |
 *
 *          Value name.
 *
 *  @parm   DWORD | dwDefault |
 *
 *          Default value to use if there was an error.
 *
 *  @returns
 *
 *          The value read, or the default.
 *
 *****************************************************************************/

DWORD EXTERNAL
    RegQueryDIDword(LPCTSTR ptszPath, LPCTSTR ptszValue, DWORD dwDefault)
{
    HKEY hk;
    DWORD dw;

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DINPUT, 0,
                    KEY_QUERY_VALUE, &hk) == 0)
    {
        DWORD cb = cbX(dw);

        if( ptszPath )
        {
            HKEY hkSub;

            if(RegOpenKeyEx(hk, ptszPath, 0,
                            KEY_QUERY_VALUE, &hkSub) == 0)
            {
                RegCloseKey( hk );
                hk = hkSub;
            }
        }

        if(RegQueryValueEx(hk, ptszValue, 0, 0, (LPBYTE)&dw, &cb) == 0 &&
           cb == cbX(dw))
        {
        } else
        {
            dw = dwDefault;
        }
        RegCloseKey(hk);
    } else
    {
        dw = dwDefault;
    }
    return dw;
}


//
// A registry key that is opened by an application can be deleted
// without error by another application in both Windows 95 and
// Windows NT. This is by design.
DWORD EXTERNAL
    DIWinnt_RegDeleteKey
    (
    HKEY hStartKey ,
    LPCTSTR pKeyName
    )
{

    #define MAX_KEY_LENGTH  ( 256 )
    DWORD   dwRtn, dwSubKeyLength;
    TCHAR   szSubKey[MAX_KEY_LENGTH]; // (256) this should be dynamic.
    HKEY    hKey;

    // do not allow NULL or empty key name
    if( pKeyName &&  lstrlen(pKeyName))
    {
        if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
                                0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
        {
            while(dwRtn == ERROR_SUCCESS )
            {
                dwSubKeyLength = MAX_KEY_LENGTH;
                dwRtn=RegEnumKeyEx(
                                  hKey,
                                  0,       // always index zero
                                  szSubKey,
                                  &dwSubKeyLength,
                                  NULL,
                                  NULL,
                                  NULL,
                                  NULL
                                  );

                if(dwRtn == ERROR_SUCCESS)
                {
                    dwRtn = DIWinnt_RegDeleteKey(hKey, szSubKey);
                } else if(dwRtn == ERROR_NO_MORE_ITEMS)
                {
                    dwRtn = RegDeleteKey(hStartKey, pKeyName);
                    break;
                }
            }
            RegCloseKey(hKey);
            // Do not save return code because error
            // has already occurred
        }
    } else
        dwRtn = ERROR_BADKEY;

    return dwRtn;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRegCopyValues |
 *
 *          Copy all the values from one key to another.
 *
 *  @parm   HKEY | hkSrc |
 *
 *          Key with values to be copied 
 *              (must be opened with at least KEY_READ access).
 *
 *  @parm   HKEY | hkDest |
 *
 *          Key to receive copies (must be opened with at least KEY_WRITE).
 *
 *  @returns
 *
 *          S_OK if all values were successfully copied
 *          S_FALSE if there were no values to copy.
 *          Or a memory allocation error code or the failing registry function 
 *          return code converted to a <t HRESULT>.
 *
 *****************************************************************************/
STDMETHODIMP
    hresRegCopyValues( HKEY hkSrc, HKEY hkDest )
{
    HRESULT hres;
    LONG    lRc;
    DWORD   cItems;
    DWORD   MaxNameLen;
    DWORD   MaxDataLen;
    DWORD   NameLen;
    DWORD   DataLen;
    PTCHAR  tszName;
    PBYTE   pData;
    DWORD   Type;

    EnterProcI(hresRegCopyValues, (_ "xx", hkSrc, hkDest));

    lRc = RegQueryInfoKey( hkSrc,           // Key, 
                           NULL, NULL, NULL,// Class, cbClass, Reserved,
                           NULL, NULL, NULL,// NumSubKeys, MaxSubKeyLen, MaxClassLen,
                           &cItems,         // NumValues, 
                           &MaxNameLen,     // MaxValueNameLen,
                           &MaxDataLen,     // MaxValueLen,
                           NULL, NULL );    // Security descriptor, last write

    if( lRc == ERROR_SUCCESS )
    {
        if( cItems )
        {
            MaxNameLen++; // Take account of NULL terminator
            hres = AllocCbPpv( MaxDataLen + MaxNameLen * sizeof(tszName[0]), &pData );
            if( FAILED(hres) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Out of memory copying registry values") );
            }
            else
            {
                tszName = (PTCHAR)(pData + MaxDataLen);

                do
                {
                    DataLen = MaxDataLen;
                    NameLen = MaxNameLen;
                    lRc = RegEnumValue( hkSrc, --cItems, tszName, &NameLen,
                                         NULL, &Type, pData, &DataLen );
                    if( lRc != ERROR_SUCCESS )
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("RegEnumValues failed during copy values, code 0x%08x"), lRc );
                        break;
                    }
                    else
                    {
                        lRc = RegSetValueEx( hkDest, tszName, 0, Type, pData, DataLen );
                        if( lRc != ERROR_SUCCESS )
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("Failed to copy value %s code %x"), tszName, lRc );
                            break;
                        }
                    }
                } while( cItems );

                FreePpv( &pData );

                if( lRc != ERROR_SUCCESS )
                {
                    hres = hresReg( lRc );
                }
                else
                {
                    hres = S_OK;
                }
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl, TEXT("No values to copy") );
            hres = S_FALSE;
        }
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("RegQueryInfoKey failed during value copy, code 0x%08x"), lRc );
        hres = hresReg(lRc);
    }

    ExitOleProc();

    return( hres );
} /* hresRegCopyValues */


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRegCopyKey |
 *
 *          Make an empty copy of a key.
 *
 *  @parm   HKEY | hkSrcRoot |
 *
 *          The Key under the key name to be copied exists.
 *              (must be opened with at least KEY_READ).
 *
 *  @parm   PTCHAR | szSrcName |
 *          Name of key to copy
 *
 *  @parm   PTCHAR | szClass |
 *          Class of key to copy
 *
 *  @parm   HKEY | hkDestRoot |
 *
 *          The Key under which the copy will be created
 *              (must be opened with at least KEY_WRITE).
 *
 *  @parm   PTCHAR | szSrcName |
 *          Name of new key
 *
 *  @parm   PHKEY | phkSub |
 *
 *          The optional pointer to an HKEY to recieve the opened key if it is 
 *          successfully created.  If this is NULL, the key is closed.
 *
 *  @returns
 *
 *          S_OK if the new key was created.
 *          S_FALSE if the new key already existed
 *          Or the return value of a failing registry function or 
 *          GetSecurityInfo converted to a <t HRESULT>.
 *
 *****************************************************************************/
STDMETHODIMP
    hresRegCopyKey( HKEY hkSrcRoot, PTCHAR szSrcName, PTCHAR szClass, 
        HKEY hkDestRoot, PTCHAR szDestName, HKEY *phkSub )
{
    LONG    lRc;
    HKEY    hkSub;
    DWORD   dwDisposition;
    HRESULT hres;


#ifdef WINNT
    HKEY                    hkSrc;
#endif

    EnterProcI(hresRegCopyKey, (_ "xssxs", hkSrcRoot, szSrcName, szClass, hkDestRoot, szDestName));
#ifdef WINNT

    lRc = RegOpenKeyEx( hkSrcRoot, szSrcName, 0, KEY_READ, &hkSrc );

    if( lRc == ERROR_SUCCESS )
    {
        SECURITY_ATTRIBUTES     sa;
        SECURITY_INFORMATION    si;

        sa.nLength = sizeof( sa );
        sa.bInheritHandle = TRUE;
        si = OWNER_SECURITY_INFORMATION;

        lRc = GetSecurityInfo( hkSrc, SE_REGISTRY_KEY, 
                               si,           
                               NULL, NULL, // Don't care about SID or SID group
                               NULL, NULL, // Don't care about DACL or SACL
                               &sa.lpSecurityDescriptor );

        RegCloseKey( hkSrc );

        if( lRc == ERROR_SUCCESS )
        {
            lRc = RegCreateKeyEx(  hkDestRoot,
                                   szDestName,
                                   0,
                                   szClass,
                                   REG_OPTION_NON_VOLATILE,
                                   KEY_WRITE,
                                   &sa,
                                   &hkSub,
                                   &dwDisposition );

            LocalFree( sa.lpSecurityDescriptor );
            if( lRc != ERROR_SUCCESS ) 
            {
                SquirtSqflPtszV(sqfl | sqflBenign,
                    TEXT("Failed to RegCreateKeyEx for key name %s, code 0x%08x"), szDestName, lRc );
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl | sqflBenign,
                TEXT("Failed to GetSecurityInfo for key name %s, code 0x%08x"), szSrcName, lRc );
        }
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("Failed to RegOpenKeyEx for key name %s, code 0x%08x"), szSrcName, lRc );
    }

#else
    /* On Win9x the source is not used as the name and class is all we need */
    hkSrcRoot;
    szSrcName;

    lRc = RegCreateKeyEx(  hkDestRoot,
                           szDestName,
                           0,
                           szClass,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hkSub,
                           &dwDisposition );
    if( lRc != ERROR_SUCCESS ) 
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("Failed to RegCreateKeyEx for key name %s, code 0x%08x"), szDestName, lRc );
    }
#endif /* WINNT */

    if( lRc == ERROR_SUCCESS ) 
    {
        if( phkSub )
        {
            *phkSub = hkSub;
        }
        else
        {
            RegCloseKey( hkSub );
        }
        
        hres =( dwDisposition == REG_CREATED_NEW_KEY ) ? S_OK : S_FALSE;
    }
    else
    {
        hres = hresReg( lRc );
    }

    ExitOleProc();

    return( hres );

} /* hresRegCopyKey */

                    


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRegCopyKeys |
 *
 *          Copy all the keys under the source key to the root.
 *
 *  @parm   HKEY | hkSrc |
 *
 *          Key be copied (must be opened with at least KEY_READ access).
 *
 *  @parm   HKEY | hkRoot |
 *
 *          The Key under which the copy will be created
 *              (must be opened with at least KEY_WRITE).
 *
 *  @parm   PDWORD | pMaxNameLen |
 *
 *          An optional pointer to a value which will be filled with the number 
 *          of characters, incl. the NULL terminator, in the longest key name.
 *
 *  @returns
 *
 *          S_OK if all keys were successfully copied
 *          S_FALSE if there were no keys to copy.
 *          Or the memory allocation error code or the failing registry 
 *          function return code converted to a <t HRESULT>.
 *
 *****************************************************************************/
STDMETHODIMP
    hresRegCopyKeys( HKEY hkSrc, HKEY hkRoot, PDWORD OPTIONAL pMaxNameLen )
{
    HRESULT             hres;
    LONG                lRc;
    DWORD               cSubKeys;
    DWORD               MaxNameLen;
    DWORD               cbName;
    PTCHAR              szKeyName;
    DWORD               MaxClassLen;
    DWORD               cbClass;
    PTCHAR              szClassName;

    EnterProcI(hresRegCopyKeys, (_ "xx", hkSrc, hkRoot ));

    lRc = RegQueryInfoKey(  hkSrc,              // handle to key to query
                            NULL, NULL, NULL,   // Class, cbClass, Reserved
                            &cSubKeys,          // NumSubKeys
                            &MaxNameLen,        // MaxSubKeyLen
                            &MaxClassLen,       // MaxClassLen
                            NULL, NULL, NULL,   // NumValues, MaxValueNameLen, MaxValueLen
                            NULL, NULL );       // Security descriptor, last write

    if( lRc == ERROR_SUCCESS )
    {
        if( cSubKeys )
        {
            // Make space for NULL terminators
            MaxNameLen++;
            MaxClassLen++;

            if( pMaxNameLen )
            {
                *pMaxNameLen = MaxNameLen;
            }

            /*
             *  There are keys to copy so allocate buffer sapce for the key and 
             *  key class names.
             */
            /*
             *  Prefix warns (mb:34678) that things would go horribly wrong if 
             *  (MaxNameLen + MaxClassLen) * sizeof(szClassName[0]) == 0 
             *  however this cannot happen unless RegQueryInfoKey has some 
             *  catestrophic failure _and_ returned OK.
             */
            AssertF( (MaxNameLen + MaxClassLen) * sizeof(szClassName[0]) != 0 );
            hres = AllocCbPpv( (MaxNameLen + MaxClassLen) * sizeof(szClassName[0]), &szKeyName );
            if( FAILED( hres ) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Out of memory copying subkeys") );
            }
            else
            {
                szClassName = &szKeyName[MaxNameLen];

                //  redefine Max*Len to cbMax* for the loop
                MaxNameLen *= sizeof( szKeyName[0] );
                MaxNameLen *= sizeof( szClassName[0] );

                cSubKeys--;
                do
                {
                    cbName = MaxNameLen;
                    cbClass = MaxClassLen;

                    lRc = RegEnumKeyEx( hkSrc,      // Key containing subkeys to enumerate
                                        cSubKeys,   // index of subkey to enumerate
                                        szKeyName,  // address of buffer for subkey name
                                        &cbName,    // address for size of subkey buffer
                                        NULL,       // reserved
                                        szClassName,// address of buffer for class string
                                        &cbClass,   // address for size of class buffer
                                        NULL );     // address for time key last written to

                    if( lRc == ERROR_SUCCESS )
                    {
                        hres = hresRegCopyKey( hkSrc, szKeyName, szClassName, hkRoot, szKeyName, NULL );
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflError,
                            TEXT("RegEnumKeyEx failed during copy keys, code 0x%08x"), lRc );
                        hres = hresReg( hres );
                    }

                    if( FAILED( hres ) )
                    {
                        break;
                    }
                } while( cSubKeys-- ); 
                FreePpv(&szKeyName);
            }
        }
        else
        {
            SquirtSqflPtszV(sqfl, TEXT("No keys to copy") );
            hres = S_FALSE;
        }
    }
    else
    {
        SquirtSqflPtszV(sqfl | sqflBenign,
            TEXT("RegQueryInfoKey failed during value key, code 0x%08x"), lRc );
        hres = hresReg(lRc);
    }

    ExitOleProc();    

    return( hres );
} /* hresRegCopyKeys */


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRegCopyBranch |
 *
 *          Copy the contents of one key including sub-keys to another.
 *          Since this function calls itself to copy the contents of subkeys,
 *          the local variables should be kept to a minimum.
 *
 *  @parm   HKEY | hkSrc |
 *
 *          Key to be copied (must be opened with at least KEY_READ access).
 *
 *  @parm   HKEY | hkDest |
 *
 *          Key to receive copy (must be opened with at least KEY_WRITE).
 *
 *  @returns
 *
 *          S_OK if the copy completed succesfully 
 *          or the return value from <f hresRegCopyValues>, 
 *          <f hresRegCopyKeys>, memory allocation error or a registry 
 *          function failure code converted to a <t HRESULT>.
 *
 *****************************************************************************/

STDMETHODIMP
    hresRegCopyBranch( HKEY hkSrc, HKEY hkDest )
{
    HKEY    hkSrcSub; 
    HKEY    hkDestSub;
    HRESULT hres;
    DWORD   dwIdx;
    DWORD   cbMaxName;
    DWORD   cbKeyName;
    PTCHAR  szKeyName;

    EnterProcI(hresRegCopyBranch, (_ "xx", hkSrc, hkDest));

    hres = hresRegCopyValues( hkSrc, hkDest );

    if( SUCCEEDED( hres ) )
    {
        hres = hresRegCopyKeys( hkSrc, hkDest, &cbMaxName );

        if( hres == S_FALSE )
        {
            /* No keys to recurse into */
            hres = S_OK;
        }
        else if( hres == S_OK )
        {
            /*
             *  Assert that a non-zero size buffer is requested
             */
            AssertF( cbMaxName * sizeof(szKeyName[0]) );
            hres = AllocCbPpv( cbMaxName * sizeof(szKeyName[0]), &szKeyName );

            if( SUCCEEDED( hres ) )
            {
                for( dwIdx=0; SUCCEEDED( hres ); dwIdx++ )
                {
                    cbKeyName = cbMaxName;

                    /*
                     *  Prefix warns (mb:34669 & win:170672) that szKeyName 
                     *  could be NULL if the above alloc was for zero bytes.  
                     *  This cannot happen as cbMaxName is the length of the 
                     *  longest key name, incremented to leave space for null 
                     *  termination on a successful call to RegQueryInfoKey 
                     *  when at least one key was found.
                     */
                    hres = hresReg( RegEnumKeyEx( hkSrc, dwIdx, 
                                                  szKeyName, &cbKeyName,
                                                  NULL, NULL, NULL, NULL ) );  // Reserved, szClass, cbClass, Last Write
                    if( SUCCEEDED( hres ) )
                    {
                        hres = hresReg( RegOpenKeyEx( hkSrc, szKeyName, 0, KEY_READ, &hkSrcSub ) );

                        if( SUCCEEDED( hres ) )
                        {
                            hres = hresReg( RegOpenKeyEx( hkDest, szKeyName, 0, KEY_WRITE, &hkDestSub ) );
                            if( SUCCEEDED( hres ) )
                            {
                                hres = hresRegCopyBranch( hkSrcSub, hkDestSub );
                            }
                            else
                            {
                                SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("Failed to open destination subkey %s for recursion, code 0x%04x"),
                                    szKeyName, LOWORD(hres) );
                            }
                        }
                        else
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("Failed to open source subkey %s for recursion, code 0x%04x"),
                                szKeyName, LOWORD(hres) );
                        }
                    }
                    else
                    {
                        if( hres == hresReg( ERROR_NO_MORE_ITEMS ) )
                        {
                            /* Recursed all keys */
                            hres = S_OK;
                            break;
                        }
                        else
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("Failed RegEnumKeyEx during subkey recursion, code 0x%04x"),
                                LOWORD(hres) );
                        }
                    }
                }

                FreePpv( &szKeyName );
            }
            else
            {
                SquirtSqflPtszV(sqfl | sqflError,
                    TEXT("Out of memory recursing subkeys") );
            }
        }
        else
        {
            if( SUCCEEDED( hres ) )
            {
                RPF( "Unexpected success code 0x%08x from hresRegCopyKeys", hres );
            }
        }
    }

    ExitOleProc();

    return( hres );

} /* hresRegCopyBranch */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\direg.c ===
/*****************************************************************************
 *
 *  DIReg.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      OLE self-registration.
 *
 *  Contents:
 *
 *      DllRegisterServer()
 *      DllUnregisterServer()
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflDll

/*****************************************************************************
 *
 *      RegSetStringEx
 *
 *      Add a REG_SZ to hkey\sub::value.
 *
 *****************************************************************************/

void INTERNAL
RegSetStringEx(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData)
{
    LONG lRc = RegSetValueEx(hk, ptszValue, 0, REG_SZ,
                             (PV)ptszData, cbCtch(lstrlen(ptszData)+1));
}

/*****************************************************************************
 *
 *      RegDelStringEx
 *
 *      Remove a REG_SZ from hkey\sub::value.  The data is ignored.
 *      It's passed so that RegDelStringEx matches the prototype for a
 *      REGSTRINGACTION.
 *
 *****************************************************************************/

void INTERNAL
RegDelStringEx(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData)
{
    LONG lRc = RegDeleteValue(hk, ptszValue);
}

/*****************************************************************************
 *
 *      RegCloseFinish
 *
 *      Just close the subkey already.
 *
 *****************************************************************************/

void INTERNAL
RegCloseFinish(HKEY hk, LPCTSTR ptszSub, HKEY hkSub)
{
    LONG lRc = RegCloseKey(hkSub);
}

/*****************************************************************************
 *
 *      RegDelFinish
 *
 *      Delete a key if there is nothing in it.
 *
 *      OLE unregistration rules demand that you not delete a key if OLE
 *      has added something to it.
 *
 *****************************************************************************/

void INTERNAL
RegDelFinish(HKEY hk, LPCTSTR ptszSub, HKEY hkSub)
{
    LONG lRc;
    DWORD cKeys = 0, cValues = 0;
    RegQueryInfoKey(hkSub, 0, 0, 0, &cKeys, 0, 0, &cValues, 0, 0, 0, 0);
    RegCloseKey(hkSub);
    if ((cKeys | cValues) == 0) {

#ifdef WINNT
        lRc = DIWinnt_RegDeleteKey(hk, ptszSub);
#else
        lRc = RegDeleteKey(hk, ptszSub);
#endif

    } else {
        lRc = 0;
    }
}


#ifdef WINNT //The following are only used on WINNT

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | RegSetPermissionsOnDescendants |
 *
 *			Sets the specified permissions on all descendants of the specified key.
 *
 *  @parm   HKEY | hKey |
 *
 *          The reg key on whose descendants we're operating.
 *
 *  @parm   SECURITY_DESCRIPTOR* | psd |
 *
 *          Ptr to the SECURITY_DESCRIPTOR we're using.
 *
 *  @returns
 *
 *          Nothing.
 *			Note that this recurses while having TCHAR szKeyName[MAX_PATH+1]
 *			for each level. If stack space is a concern, can allocate it on the heap,
 *			and free after obtain the HKEY (i.e. before recursing).
 *
 *****************************************************************************/

void INTERNAL
RegSetPermissionsOnDescendants(HKEY hKey, SECURITY_DESCRIPTOR* psd)
{
	DWORD dwIndex = 0;
	LONG lRetCode = ERROR_SUCCESS;

	while (lRetCode == ERROR_SUCCESS)
	{
		TCHAR szKeyName[MAX_PATH+1];
		DWORD cbKeyName = MAX_PATH+1;
		lRetCode = RegEnumKeyEx(hKey, 
							dwIndex,
							szKeyName,
							&cbKeyName,
							NULL, NULL, NULL, NULL);

		if (lRetCode == ERROR_SUCCESS)
		{
			LONG lRetSub;
			HKEY hkSubKey;
			lRetSub = RegOpenKeyEx(hKey, szKeyName, 0, DI_KEY_ALL_ACCESS | WRITE_DAC, &hkSubKey);
			if (lRetSub == ERROR_SUCCESS)
			{
				//set security on it and its descendants
				lRetSub = RegSetKeySecurity(hkSubKey,
											(SECURITY_INFORMATION)DACL_SECURITY_INFORMATION,
											psd);
				RegSetPermissionsOnDescendants(hkSubKey, psd);
				RegCloseKey(hkSubKey);
					
				if(lRetSub != ERROR_SUCCESS) 
				{
					RPF("Couldn't RegSetKeySecurity on %hs", szKeyName);
				}
			}
			else
			{
				RPF("Couldn't open enumed subkey %hs", szKeyName);
			}

			dwIndex++;
		}
	}

}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | RegSetSecurity |
 *
 *      Set the security of 
 *        SYSTEM\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\Joystick\\OEM
 *        SYSTEM\\CurrentControlSet\\Control\\MediaResources\\Joystick\\Dinput.dll
 *      to be accessible to Everyone on Win2K,
 *.		to be accessible to Everyone but without WRITE_DAC and WRITE_OWNER permissions on WinXP;
 *        SYSTEM\\CurrentControlSet\\Control\\MediaProperties\\PrivateProperties\\DirectInput
 *		to be accessible to Everyone but without WRITE_DAC and WRITE_OWNER permissions on Win2k and WinXP.
 *
 *  @returns
 *
 *          S_OK on success, E_FAIL on error.
 *
 *****************************************************************************/

HRESULT INTERNAL
RegSetSecurity(void)
{
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_WORLD_SID_AUTHORITY;
    PSID pEveryoneSid = NULL;
    SECURITY_DESCRIPTOR sd;
    PACL pDacl = NULL;
    DWORD dwAclSize;
    HKEY hkOEM, hkJoy, hkDin, hkPP, hkMedR, hkJDi;
    LONG lRetCode;
    BOOL bSuccess = FALSE; // assume this function fails
	BOOL bWinXP = FALSE;

	//determine whether we're running on Win2k or WinXP, since we would like
	//on Win2k to emulate the same behaviour as previously, but set different reg key
	//permissions on WinXp (see Whistler bugs 318865, 326784).
	if (DIGetOSVersion() == WINWH_OS)
	{
		bWinXP = TRUE;
	}

    //
    // open the keys for WRITE_DAC access
    //
	//MediaProperties/PrivateProperties/DirectInput
	lRetCode = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        REGSTR_PATH_PRIVATEPROPERTIES,
        0,
        KEY_WRITE,
        &hkPP
        );

	if(lRetCode != ERROR_SUCCESS) {
		RPF("Couldn't open REGSTR_PATH_PRIVATEPROPERTIES");
        return E_FAIL;
    }
    
	lRetCode = RegCreateKeyEx(
        hkPP,
        TEXT("DirectInput"),
        0,
		NULL,
		REG_OPTION_NON_VOLATILE,
        DI_KEY_ALL_ACCESS | WRITE_DAC,
		NULL,
        &hkDin,
		NULL
        );

    if(lRetCode != ERROR_SUCCESS) {
		RPF("Couldn't open DirectInput");
        return E_FAIL;
    }

	//MediaResources/Joystick/Dinput.dll
	lRetCode = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		REGSTR_PATH_MEDIARESOURCES,
		0,
		KEY_WRITE,
		&hkMedR
		);

	if(lRetCode != ERROR_SUCCESS) {
		RPF("Couldn't open REGSTR_PATH_MEDIARESOURCES");
		return E_FAIL;
	}

	//on Win2K, we need to create MediaResources\Joystick\Dinput.dll reg key w/ KEY_ALL_ACCESS (Whistler bug 326874)
	if (bWinXP == TRUE)
	{   
		lRetCode = RegCreateKeyEx(
			hkMedR,
			TEXT("Joystick"),
			0,
			NULL,
			REG_OPTION_NON_VOLATILE,
			KEY_WRITE,
			NULL,
			&hkJoy,
			NULL
        );

		if(lRetCode != ERROR_SUCCESS) {
			RPF("Couldn't open Joystick");
			return E_FAIL;
		}

		lRetCode = RegCreateKeyEx(
			hkJoy,
			TEXT("Dinput.dll"),
			0,
			NULL,
			REG_OPTION_NON_VOLATILE,
			DI_KEY_ALL_ACCESS | WRITE_DAC,
			NULL,
			&hkJDi,
			NULL
			);

		if(lRetCode != ERROR_SUCCESS) {
			RPF("Couldn't open Dinput.dll");
			return E_FAIL;
		}

		//MediaProperties/Joystick/OEM
		lRetCode = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,
			REGSTR_PATH_JOYOEM,
			0,
			WRITE_DAC | KEY_ENUMERATE_SUB_KEYS,
			&hkOEM
			);

		if(lRetCode != ERROR_SUCCESS) {
			RPF("Couldn't open REGSTR_PATH_JOYOEM");
			return E_FAIL;
		}
	}
	else
	{
		lRetCode = RegCreateKeyEx(
        hkMedR,
        TEXT("Joystick"),
        0,
		NULL,
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
		NULL,
        &hkJoy,
		NULL
        );

		if(lRetCode != ERROR_SUCCESS) {
			RPF("Couldn't open Joystick");
			return E_FAIL;
		}

		lRetCode = RegCreateKeyEx(
			hkJoy,
			TEXT("Dinput.dll"),
			0,
			NULL,
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS,
			NULL,
			&hkJDi,
			NULL
			);

		if(lRetCode != ERROR_SUCCESS) {
			RPF("Couldn't open Dinput.dll");
			return E_FAIL;
		}
	}


    //
    // prepare a Sid representing any Interactively logged-on user
    //
    if(!AllocateAndInitializeSid(
        &sia,
        1,
        SECURITY_WORLD_RID,
        0, 0, 0, 0, 0, 0, 0,
        &pEveryoneSid
      )) 
    {
		RPF("Couldn't AllocateAndInitializeSid");
        goto cleanup;
    }

    //
    // compute size of new acl
    //
    dwAclSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)
        + GetLengthSid(pEveryoneSid);

    //
    // allocate storage for Acl
    //
    pDacl = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize);
    if(pDacl == NULL) {
		RPF("pACl is NULL");
    	goto cleanup;
    }

    if(!InitializeAcl(pDacl, dwAclSize, ACL_REVISION)) {
		RPF("Couldn't InitializeAcl");
        goto cleanup;
    }

    //
    // grant the Interactive Sid KEY_READ access to the perf key
    //
    if(!AddAccessAllowedAceEx(
        pDacl,
        ACL_REVISION,
		CONTAINER_INHERIT_ACE,
        DI_KEY_ALL_ACCESS,
        pEveryoneSid
      ))
    {
		RPF("Couldn't AddAccessAllowedAceEx");
        goto cleanup;
    }

    if(!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) 
    {
		RPF("Couldn't InitilizeSecurityDescriptor");
        goto cleanup;
    }

    if(!SetSecurityDescriptorDacl(&sd, TRUE, pDacl, FALSE)) 
    {
		RPF("Couldn't SetSecurityDescriptorDacl");
        goto cleanup;
    }

	//make sure that it is not overwritten by the parent's security changes
	if(!SetSecurityDescriptorControl(&sd, SE_DACL_PROTECTED, SE_DACL_PROTECTED))
	{
		RPF("Couldn't SetSecurityDescriptorControl");
		goto cleanup;
	}

    //
    // apply the security descriptor to the registry keys and their subkeys
    //
	//MediaProperties/PrivateProperties/DirectInput and its subkeys
	lRetCode = RegSetKeySecurity(
        hkDin,
        (SECURITY_INFORMATION)DACL_SECURITY_INFORMATION,
        &sd
        );

    if(lRetCode != ERROR_SUCCESS) {
		RPF("Couldn't RegSetKeySecurity on DirectInput");
        goto cleanup;
    }

	RegSetPermissionsOnDescendants(hkDin, &sd);


	//on WinXP, we set the same permissions on Joystick/OEM and MediaResources/Joystick/Dinput.dll and their subkeys
	if (bWinXP == TRUE)
	{
		//Joystick/OEM
		lRetCode = RegSetKeySecurity(
			hkOEM,
			(SECURITY_INFORMATION)DACL_SECURITY_INFORMATION,
			&sd
			);

		if(lRetCode != ERROR_SUCCESS) {
			RPF("Couldn't RegSetKeySecurity on OEM");
			goto cleanup;
		}

		RegSetPermissionsOnDescendants(hkOEM, &sd);

		//MediaResources/Joystick/Dinput.dll and its subkeys
		lRetCode = RegSetKeySecurity(
			hkJDi,
			(SECURITY_INFORMATION)DACL_SECURITY_INFORMATION,
			&sd
			);

		if(lRetCode != ERROR_SUCCESS) {
			RPF("Couldn't RegSetKeySecurity on Dinput.dll");
			goto cleanup;
		}

		RegSetPermissionsOnDescendants(hkJDi, &sd);

		//indicate success
		bSuccess = TRUE;
	}
	else
	{	
		//on Win2K, we leave Joystick/OEM keys alone, 
		//and give full access to MediaResources\Joystick\Dinput.dll and its subkeys to everyone
		PACL pDaclFull = NULL;
		pDaclFull = (PACL)HeapAlloc(GetProcessHeap(), 0, dwAclSize);
		if(pDaclFull == NULL) {
			RPF("pAClFull is NULL");
    		goto cleanupW2k;
		}

		if(!InitializeAcl(pDaclFull, dwAclSize, ACL_REVISION)) {
			RPF("Couldn't InitializeAcl");
			goto cleanupW2k;
		}

		if(!AddAccessAllowedAceEx(
			pDaclFull,
			ACL_REVISION,
			CONTAINER_INHERIT_ACE,
			KEY_ALL_ACCESS,
			pEveryoneSid
		  ))
		{
			RPF("Couldn't AddAccessAllowedAceEx");
			goto cleanupW2k;
		}

		if(!SetSecurityDescriptorDacl(&sd, TRUE, pDaclFull, FALSE)) 
		{
			RPF("Couldn't SetSecurityDescriptorDacl");
			goto cleanupW2k;
		}

		//make sure that it is not overwritten by the parent's security changes
		if(!SetSecurityDescriptorControl(&sd, SE_DACL_PROTECTED, SE_DACL_PROTECTED))
		{
			RPF("Couldn't SetSecurityDescriptorControl");
			goto cleanupW2k;
		}

		//apply it to the key and its subkeys
		lRetCode = RegSetKeySecurity(
			hkJoy,
			(SECURITY_INFORMATION)DACL_SECURITY_INFORMATION,
			&sd
			);

		if(lRetCode != ERROR_SUCCESS) {
			RPF("Couldn't RegSetKeySecurity on Dinput.dll");
			goto cleanupW2k;
		}

		lRetCode = RegSetKeySecurity(
			hkJDi,
			(SECURITY_INFORMATION)DACL_SECURITY_INFORMATION,
			&sd
			);

		if(lRetCode != ERROR_SUCCESS) {
			RPF("Couldn't RegSetKeySecurity on Dinput.dll");
			goto cleanupW2k;
		}

		RegSetPermissionsOnDescendants(hkJDi, &sd);

		//indicate success
		bSuccess = TRUE;

cleanupW2k:;
		if(pDaclFull != NULL) 
		{
			HeapFree(GetProcessHeap(), 0, pDaclFull);
		}
	}


cleanup:

    RegCloseKey(hkOEM);
	RegCloseKey(hkJDi);
	RegCloseKey(hkDin);
	RegCloseKey(hkPP);
	RegCloseKey(hkMedR);
	RegCloseKey(hkJoy);

    //
    // free allocated resources
    //
    if(pDacl != NULL) {
        HeapFree(GetProcessHeap(), 0, pDacl);
    }

    if(pEveryoneSid != NULL) {
        FreeSid(pEveryoneSid);
    }
    
    if(bSuccess) {
        return S_OK;
    } else {
        return E_FAIL;
    }
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DummyRegSetSecurity |
 *
 *			Do nothing
 *
 *  @returns
 *
 *          S_OK.
 *
 *****************************************************************************/

HRESULT INTERNAL
DummyRegSetSecurity(void)
{
	return S_OK;
}

#endif //WINNT


/*****************************************************************************
 *
 *      REGVTBL
 *
 *      Functions for dorking with a registry key, either coming or going.
 *
 *****************************************************************************/

typedef struct REGVTBL {
    /* How to create/open a key */
    LONG (INTERNAL *KeyAction)(HKEY hk, LPCTSTR ptszSub, PHKEY phkOut);

    /* How to create/delete a string */
    void (INTERNAL *StringAction)(HKEY hk, LPCTSTR ptszValue, LPCTSTR ptszData);

    /* How to finish using a key */
    void (INTERNAL *KeyFinish)(HKEY hk, LPCTSTR ptszSub, HKEY hkSub);
 
#ifdef WINNT
    /* How to set security on OEM key */
    HRESULT (INTERNAL *SetSecurity)( void );
#endif //WINNT

} REGVTBL, *PREGVTBL;
typedef const REGVTBL *PCREGVTBL;

#ifdef WINNT
const REGVTBL c_vtblAdd = { RegCreateKey, RegSetStringEx, RegCloseFinish, RegSetSecurity };
const REGVTBL c_vtblDel = {   RegOpenKey, RegDelStringEx,   RegDelFinish, DummyRegSetSecurity };
#else
const REGVTBL c_vtblAdd = { RegCreateKey, RegSetStringEx, RegCloseFinish };
const REGVTBL c_vtblDel = {   RegOpenKey, RegDelStringEx,   RegDelFinish };
#endif //WINNT

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllServerAction |
 *
 *          Register or unregister our objects with OLE/COM/ActiveX/
 *          whatever its name is.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

extern const TCHAR c_tszNil[];

#define ctchClsid       ctchGuid

const TCHAR c_tszClsidGuid[] =
TEXT("CLSID\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}");

const TCHAR c_tszInProcServer32[] = TEXT("InProcServer32");
const TCHAR c_tszThreadingModel[] = TEXT("ThreadingModel");
const TCHAR c_tszBoth[] = TEXT("Both");

#pragma END_CONST_DATA

void INTERNAL
DllServerAction(PCREGVTBL pvtbl)
{
    TCHAR tszThisDll[MAX_PATH];
    UINT iclsidmap;

    GetModuleFileName(g_hinst, tszThisDll, cA(tszThisDll));

    for (iclsidmap = 0; iclsidmap < cclsidmap; iclsidmap++) {
        TCHAR tszClsid[7+ctchClsid];
        HKEY hkClsid;
        HKEY hkSub;
        REFCLSID rclsid = c_rgclsidmap[iclsidmap].rclsid;

        wsprintf(tszClsid, c_tszClsidGuid,
                 rclsid->Data1, rclsid->Data2, rclsid->Data3,
                 rclsid->Data4[0], rclsid->Data4[1],
                 rclsid->Data4[2], rclsid->Data4[3],
                 rclsid->Data4[4], rclsid->Data4[5],
                 rclsid->Data4[6], rclsid->Data4[7]);

        if (pvtbl->KeyAction(HKEY_CLASSES_ROOT, tszClsid, &hkClsid) == 0) {
            TCHAR tszName[127];

            /* Do the type name */
            LoadString(g_hinst, c_rgclsidmap[iclsidmap].ids,
                       tszName, cA(tszName));
            pvtbl->StringAction(hkClsid, 0, tszName);

            /* Do the in-proc server name and threading model */
            if (pvtbl->KeyAction(hkClsid, c_tszInProcServer32, &hkSub) == 0) {
                pvtbl->StringAction(hkSub, 0, tszThisDll);
                pvtbl->StringAction(hkSub, c_tszThreadingModel, c_tszBoth);
                pvtbl->KeyFinish(hkClsid, c_tszInProcServer32, hkSub);
            }

            pvtbl->KeyFinish(HKEY_CLASSES_ROOT, tszClsid, hkClsid);

        }
    }
    
  #ifdef WINNT
    pvtbl->SetSecurity();
  #endif
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllRegisterServer |
 *
 *          Register our classes with OLE/COM/ActiveX/whatever its name is.
 *
 *****************************************************************************/

void EXTERNAL
DllRegisterServer(void)
{
    DllServerAction(&c_vtblAdd);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllUnregisterServer |
 *
 *          Unregister our classes from OLE/COM/ActiveX/whatever its name is.
 *
 *****************************************************************************/

void EXTERNAL
DllUnregisterServer(void)
{
    DllServerAction(&c_vtblDel);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\makefile.inc ===
$(O)\guids.obj: ..\guids.c
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_COMPILER_NAME) @<<$(CL_RSP) -Fo"$(MAKEDIR)\$@" $(USECXX_FLAG) "$(MAKEDIR)\$**"
$(NP_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\dithunk.c ===
/*****************************************************************************
 *
 *  DiThunk.c
 *
 *  Copyright (c) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Template thunks for Windows 95 device manager.
 *
 *  Contents:
 *
 *      Thunk_Init
 *      Thunk_Term
 *
 *****************************************************************************/

#include "dinputpr.h"
#include "dithunk.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflThunk


KERNELPROCADDR g_kpa;

#pragma BEGIN_CONST_DATA

/*
 *  Careful!  This must match KERNELPROCADDR ...
 */
static LPCSTR c_rgpszKernel32[] = {
    (LPVOID) 35,            /* LoadLibrary16 */
    (LPVOID) 36,            /* FreeLibrary16 */
    (LPVOID) 37,            /* GetProcAddress16 */

    "MapLS",
    "UnMapLS",
    "MapSL",
    "MapSLFix",
    "UnMapSLFixArray",
    "QT_Thunk",
};

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | TemplateThunk |
 *
 *          Call down, passing all sorts of random parameters.
 *
 *          Parameter signature is as follows:
 *
 *          p = 0:32 pointer to convert to 16:16 pointer
 *
 *          l = a 32-bit integer
 *
 *          s = a 16-bit integer
 *
 *
 *          P = returns a pointer
 *
 *          L = returns a 32-bit integer
 *
 *          S = returns a 16-bit signed integer
 *
 *          U = returns a 16-bit unsigned integer
 *
 ***************************************************************************/

#pragma warning(disable:4035)           /* no return value (duh) */

#ifdef WIN95
#ifdef SLOW_BUT_READABLE

__declspec(naked) int
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    BYTE rgbThunk[60];          /* For private use of QT_Thunk */
    LPVOID *ppvArg;
    int i;
    LPVOID pv;
    int iRc;

    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;
        sub     esp, __LOCAL_SIZE;
        push    ebx;
        push    edi;
        push    esi;

    }

    /* Thunk all the parameters according to the signature */
    ppvArg = (LPVOID)(&pszSig+1);
    for (i = 0; ; i++) {
        pv = ppvArg[i];
        switch (pszSig[i]) {
        case 'p':
            pv = ppvArg[i] = MapLS(pv);
            __asm push pv;
            break;

        case 'l':
            __asm push pv;
            break;

        case 's':
            __asm mov eax, pv;
            __asm push ax;
            break;

        default: goto doneThunk;
        }
    }

doneThunk:;

    /* Call the 16:16 procedure */
    __asm {
        mov     edx, fp;
        mov     ebx, ebp;
        lea     ebp, rgbThunk+64;               /* Required by QT_Thunk */
    }
        g_kpa.QT_Thunk();
    __asm {
        mov     ebp, ebx;
        shl     eax, 16;                        /* Convert DX:AX to EAX */
        shrd    eax, edx, 16;
        mov     iRc, eax;
    }

    /* Now unthunk the parameters */
    ppvArg = (LPVOID)(&pszSig+1);
    for (i = 0; ; i++) {
        switch (pszSig[i]) {
        case 'p':
            UnMapLS(ppvArg[i]);
            break;

        case 'l':
        case 's':
            break;

        default: goto doneUnthunk;
        }
    }

doneUnthunk:;

    /* Thunk the return value */
    switch (pszSig[i]) {
    case 'L':
        break;

    case 'U':
        iRc = LOWORD(iRc);
        break;

    case 'S':
        iRc = (short)iRc;
        break;

    case 'P':
        iRc = (int)MapSL((LPVOID)iRc);
        break;
    }

    __asm {
        mov     eax, iRc;
        pop     esi;
        pop     edi;
        pop     ebx;
        mov     esp, ebp;
        pop     ebp;
        ret;
    }
}

#else               /* Fast but illegible */

__declspec(naked) int
TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    __asm {

        /* Function prologue */
        push    ebp;
        mov     ebp, esp;
        sub     esp, 60;                /* QT_Thunk needs 60 bytes */
        push    ebx;
        push    edi;
        push    esi;

        /* Thunk all the parameters according to the signature */

        lea     esi, pszSig+4;          /* esi -> next arg */
        mov     ebx, pszSig;            /* ebx -> signature string */
thunkLoop:;
        mov     al, [ebx];
        inc     ebx;                    /* al = pszSig++ */
        cmp     al, 'p';                /* Q: Pointer? */
        jz      thunkPtr;               /* Y: Do the pointer */
        cmp     al, 'l';                /* Q: Long? */
        jz      thunkLong;              /* Y: Do the long */
        cmp     al, 's';                /* Q: Short? */
        jnz     thunkDone;              /* N: Done */

                                        /* Y: Do the short */
        lodsd;                          /* eax = *ppvArg++ */
        push    ax;                     /* Push the short */
        jmp     thunkLoop;

thunkPtr:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        call    dword ptr g_kpa.MapLS;  /* Map it */
        mov     [esi][-4], eax;         /* Save it for unmapping */
        push    eax;
        jmp     thunkLoop;

thunkLong:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        jmp     thunkLoop;
thunkDone:

        /* Call the 16:16 procedure */

        mov     edx, fp;
        call    dword ptr g_kpa.QT_Thunk;
        shl     eax, 16;                /* Convert DX:AX to EDX */
        shld    edx, eax, 16;

        /* Translate the return code according to the signature */

        mov     al, [ebx][-1];          /* Get return code type */
        cmp     al, 'P';                /* Pointer? */
        jz      retvalPtr;              /* Y: Do the pointer */
        cmp     al, 'S';                /* Signed? */
        jz      retvalSigned;           /* Y: Do the signed short */
        cmp     al, 'U';                /* Unsigned? */
        mov     edi, edx;               /* Assume long or void */
        jnz     retvalOk;               /* N: Then long or void */

        movzx   edi, dx;                /* Sign-extend short */
        jmp     retvalOk;

retvalPtr:
        push    edx;                    /* Pointer */
        call    dword ptr g_kpa.MapSL;  /* Map it up */
        jmp     retvalOk;

retvalSigned:                           /* Signed */
        movsx   edi, dx;                /* Sign-extend short */
        jmp     retvalOk;

retvalOk:                               /* Return value in EDI */

        /* Now unthunk the parameters */

        lea     esi, pszSig+4;          /* esi -> next arg */
        mov     ebx, pszSig;            /* ebx -> signature string */
unthunkLoop:;
        mov     al, [ebx];
        inc     ebx;                    /* al = pszSig++ */
        cmp     al, 'p';                /* Pointer? */
        jz      unthunkPtr;             /* Y: Do the pointer */
        cmp     al, 'l';                /* Long? */
        jz      unthunkSkip;            /* Y: Skip it */
        cmp     al, 's';                /* Short? */
        jnz     unthunkDone;            /* N: Done */
unthunkSkip:
        lodsd;                          /* eax = *ppvArg++ */
        jmp     unthunkLoop;

unthunkPtr:
        lodsd;                          /* eax = *ppvArg++ */
        push    eax;
        call    dword ptr g_kpa.UnMapLS;/* Unmap it */
        jmp     unthunkLoop;

unthunkDone:

        /* Done */

        mov     eax, edi;
        pop     esi;
        pop     edi;
        pop     ebx;
        mov     esp, ebp;
        pop     ebp;
        ret;
    }
}

#endif

#else // Not X86
int __cdecl TemplateThunk(FARPROC fp, PCSTR pszSig, ...)
{
    return 0;
}
#endif

#pragma BEGIN_CONST_DATA

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   FARPROC | GetProcOrd |
 *
 *          GetProcAddress on a DLL by ordinal.
 *
 *          Win95 does not let you GetProcAddress on KERNEL32 by ordinal,
 *          so we need to do it the evil way.
 *
 *  @parm   HINSTANCE | hinstDll |
 *
 *          The instance handle of the DLL we want to get the ordinal
 *          from.  The only DLL you need to use this function for is
 *          KERNEL32.
 *
 *  @parm   UINT | ord |
 *
 *          The ordinal you want to retrieve.
 *
 ***************************************************************************/

#define poteExp(pinth) (&(pinth)->OptionalHeader. \
                          DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT])

FARPROC NTAPI
GetProcOrd(HINSTANCE hinstDll, UINT ord)
{
    FARPROC fp;

    /*
     *  Make sure the MZ header is good.
     */

    PIMAGE_DOS_HEADER pidh = (LPVOID)hinstDll;
    if (!IsBadReadPtr(pidh, sizeof(*pidh)) &&
        pidh->e_magic == IMAGE_DOS_SIGNATURE) {

        /*
         *  Make sure the PE header is good.
         */
        PIMAGE_NT_HEADERS pinth = pvAddPvCb(pidh, pidh->e_lfanew);
        if (!IsBadReadPtr(pinth, sizeof(*pinth)) &&
            pinth->Signature == IMAGE_NT_SIGNATURE) {

            /*
             *  Make sure the export table is good and the ordinal
             *  is within range.
             */
            PIMAGE_EXPORT_DIRECTORY pedt =
                              pvAddPvCb(pidh, poteExp(pinth)->VirtualAddress);
            if (!IsBadReadPtr(pedt, sizeof(*pedt)) &&
                (ord - pedt->Base) < pedt->NumberOfFunctions) {

                PDWORD peat = pvAddPvCb(pidh, (DWORD)pedt->AddressOfFunctions);
                fp = (FARPROC)pvAddPvCb(pidh, peat[ord - pedt->Base]);
                if ((DWORD)cbSubPvPv(fp, peat) >= poteExp(pinth)->Size) {
                    /* fp is valid */
                } else {                /* Note: We don't support forwarding */
                    fp = 0;
                }
            } else {
                fp = 0;
            }
        } else {
            fp = 0;
        }
    } else {
        fp = 0;
    }

    return fp;
}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | GetKernelProcAddresses |
 *
 *          Get all the necessary proc addresses from Kernel.
 *
 ***************************************************************************/

BOOL EXTERNAL
Thunk_GetKernelProcAddresses(void)
{
    DllEnterCrit();

    if (g_kpa.QT_Thunk == 0) {
        HINSTANCE hinstK32 = GetModuleHandle(TEXT("KERNEL32"));

        if (hinstK32) {
            int i;
            FARPROC *rgfpKpa = (LPVOID)&g_kpa;

            for (i = 0; i < cA(c_rgpszKernel32); i++) {
                if (HIWORD((UINT_PTR)c_rgpszKernel32[i])) {
                    rgfpKpa[i] = GetProcAddress(hinstK32, c_rgpszKernel32[i]);
                } else {
                    rgfpKpa[i] = GetProcOrd(hinstK32, (UINT)(UINT_PTR)c_rgpszKernel32[i]);
                }
                if (!rgfpKpa[i]) break;     /* Aigh! */
            }
        }
    }

    DllLeaveCrit();

    return (BOOL)(UINT_PTR)g_kpa.QT_Thunk;

}

/***************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HINSTANCE | ThunkGetProcAddresses |
 *
 *          Get all the necessary proc addresses.
 *
 ***************************************************************************/

HINSTANCE EXTERNAL
Thunk_GetProcAddresses(FARPROC *rgfp, LPCSTR *rgpsz,
                       UINT cfp, LPCSTR pszLibrary)
{
    HINSTANCE hinst;

    hinst = g_kpa.LoadLibrary16(pszLibrary);
    if (hinst >= (HINSTANCE)32) {
        UINT ifp;
        for (ifp = 0; ifp < cfp; ifp++) {
            rgfp[ifp] = g_kpa.GetProcAddress16(hinst, rgpsz[ifp]);
            if (!rgfp[ifp]) {
                g_kpa.FreeLibrary16(hinst);
                hinst = 0;
                break;
            }
        }
    } else {
        hinst = 0;
    }

    return hinst;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\bc9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\bcnt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\win95\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\win95a\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diwinnt.h ===
/***************************************************************************
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       DIWdm.h
 *  Content:    DirectInput internal include file for Winnt
 *
 ***************************************************************************/
#ifndef DIWdm_H
#define DIWdm_H

#define JOY_BOGUSID    ( cJoyMax + 1 )

HRESULT EXTERNAL
DIWdm_SetJoyId
(
    IN PCGUID   guid,
    IN int      idJoy
);

PHIDDEVICEINFO EXTERNAL
phdiFindJoyId
(
    IN  int idJoy
);

HRESULT INTERNAL
DIWdm_SetLegacyConfig
(
    IN  int idJoy
);

BOOL EXTERNAL
DIWdm_InitJoyId( void );

DWORD EXTERNAL
DIWinnt_RegDeleteKey
(
    IN HKEY hStartKey ,
    IN LPCTSTR pKeyName
);

HRESULT EXTERNAL
DIWdm_SetConfig
(
    UINT idJoy,
    LPJOYREGHWCONFIG jwc,
    LPCDIJOYCONFIG pcfg,
    DWORD fl
);

HRESULT EXTERNAL
DIWdm_DeleteConfig
(
    int idJoy
);


HRESULT EXTERNAL
DIWdm_JoyHidMapping
(
    IN  int             idJoy,
    OUT PVXDINITPARMS   pvip,   OPTIONAL
    OUT LPDIJOYCONFIG   pcfg,   OPTIONAL
    OUT LPDIJOYTYPEINFO pdijti  OPTIONAL
);

LPTSTR EXTERNAL
JoyReg_JoyIdToDeviceInterface
(
    IN  UINT            idJoy,
    OUT PVXDINITPARMS   pvip,
    OUT LPTSTR          ptszBuf
);

#endif // DIWdm_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\win9x\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diutil.c ===
/*****************************************************************************
 *
 *  DIUtil.c
 *
 *  Copyright (c) 1996 - 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Misc helper functions.
 *
 *  Contents:
 *
 *
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflUtil


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   LPCTSTR | _ParseHex |
 *
 *          Parse a hex string encoding cb bytes (at most 4), then expect 
 *          the tchDelim to appear afterwards.  If tchDelim is 0, then no 
 *          delimiter is expected.
 *
 *          Store the result into the indicated LPBYTE (using only the
 *          size requested), updating it, and return a pointer to the
 *          next unparsed character, or 0 on error.
 *
 *          If the incoming pointer is also 0, then return 0 immediately.
 *          
 *  @parm   IN LPCTSTR | ptsz |
 *
 *          The string to parse.  
 *
 *  @parm   IN OUT LPBYTE * | ppb |
 *
 *          Pointer to the address of the destination buffer.
 *
 *  @parm   IN int | cb |
 *
 *          The size in bytes of the buffer.
 *
 *  @parm   IN TCHAR | tchDelim |
 *
 *          The delimiter charater to end the sequence or zero if none is 
 *          expected.
 *
 *  @returns
 *
 *          Returns a pointer to the next unparsed character, or 0 on error.
 *
 *  @comm
 *          Stolen from TweakUI.
 *
 *          Prefix takes a strong dislike to this function, reporting that 
 *          all callers could use uninitialized memory when the function 
 *          succeeds.
 *          The problem appears to be that Prefix is unable to determine that 
 *          if the source string can successfully be read, the destination is 
 *          always completely filled (the whole passed destination size) with 
 *          the binary value of the source string.  Since all callers always 
 *          pass the size of the variable to which the destination buffer 
 *          pointer points, the memory is always completely initialized but 
 *          it seems reasonable that Prefix would raise a warning. 
 *
 *****************************************************************************/

LPCTSTR INTERNAL
    _ParseHex(LPCTSTR ptsz, LPBYTE *ppb, int cb, TCHAR tchDelim)
{
    if(ptsz)
    {
        int i = cb * 2;
        DWORD dwParse = 0;

        do
        {
            DWORD uch;
            uch = (TBYTE)*ptsz - TEXT('0');
            if(uch < 10)
            {             /* a decimal digit */
            } else
            {
                uch = (*ptsz | 0x20) - TEXT('a');
                if(uch < 6)
                {          /* a hex digit */
                    uch += 10;
                } else
                {
                    return 0;           /* Parse error */
                }
            }
            dwParse = (dwParse << 4) + uch;
            ptsz++;
        } while(--i);

        if(tchDelim && *ptsz++ != tchDelim) return 0; /* Parse error */

        for(i = 0; i < cb; i++)
        {
            (*ppb)[i] = ((LPBYTE)&dwParse)[i];
        }
        *ppb += cb;
    }
    return ptsz;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | ParseGUID |
 *
 *          Take a string and convert it into a GUID, return success/failure.
 *
 *  @parm   OUT LPGUID | lpGUID |
 *
 *          Receives the parsed GUID on success.
 *
 *  @parm   IN LPCTSTR | ptsz |
 *
 *          The string to parse.  The format is
 *
 *      { <lt>dword<gt> - <lt>word<gt> - <lt>word<gt>
 *                      - <lt>byte<gt> <lt>byte<gt>
 *                      - <lt>byte<gt> <lt>byte<gt> <lt>byte<gt>
 *                        <lt>byte<gt> <lt>byte<gt> <lt>byte<gt> }
 *
 *  @returns
 *
 *          Returns zero if <p ptszGUID> is not a valid GUID.
 *
 *
 *  @comm
 *
 *          Stolen from TweakUI.
 *
 *****************************************************************************/

BOOL EXTERNAL
    ParseGUID(LPGUID pguid, LPCTSTR ptsz)
{
    if(lstrlen(ptsz) == ctchGuid - 1 && *ptsz == TEXT('{'))
    {
        ptsz++;
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 4, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 2, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 2, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1, TEXT('-'));
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1,       0  );
        ptsz = _ParseHex(ptsz, (LPBYTE *)&pguid, 1, TEXT('}'));
        return (BOOL)(UINT_PTR)ptsz;
    } else
    {
        return 0;
    }
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | ParseVIDPID |
 *
 *          Take a string formatted as VID_%04&PID_%04.
 *
 *  @parm   OUT PUSHORT | puVID |
 *
 *          Receives the parsed VID.
 *  
 *  @parm   OUT PUSHORT | puPID |
 *      
 *          Receives the parsed PID. 
 *
 *  @parm   IN LPCTSTR | ptsz |
 *
 *
 *  @returns
 *
 *          Returns zero on failure.
 *
 *
 *  @comm
 *
 *          Stolen from TweakUI.
 *
 *****************************************************************************/

//                    VID _ XXXX  &  PID  _ YYYY
#define ctchVIDPID  ( 3 + 1 + 4 + 1 + 3 + 1 + 4 )

#define VID_        TEXT("VID_")
#define VID_offset  (3+1)
#define PID_        TEXT("&PID_")
#define PID_offset  (3+1+4+1+3+1)

BOOL EXTERNAL
    ParseVIDPID(PUSHORT puVID, PUSHORT puPID , LPCWSTR pwsz)
{    
    LPCTSTR ptsz;    
#ifndef UNICODE
    TCHAR    tsz[MAX_JOYSTRING];
    UToT( tsz, cA(tsz), pwsz );
    ptsz = tsz;
#else
   ptsz = pwsz;
#endif

    if( _ParseHex(ptsz+VID_offset, (LPBYTE *)&puVID, 2, TEXT('&'))  &&
        _ParseHex(ptsz+PID_offset, (LPBYTE *)&puPID, 2, 0) )
        {
            return TRUE;
        }
   return FALSE;
}




/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | NameFromGUID |
 *
 *          Convert a GUID into an ASCII string that will be used
 *          to name it in the global namespace.
 *
 *          We use the name "DirectInput.{guid}".
 *
 *          Names are used in the following places:
 *
 *          <c g_hmtxGlobal> names a mutex based on
 *          <c IID_IDirectInputW> to gate access to the
 *          shared memory block used to manage exclusive access.
 *
 *          <c g_psop> names a shared memory block based on
 *          <c IID_IDirectInputDeviceW> to record information
 *          about exclusive access.
 *
 *          <c g_hmtxJoy> names a mutex based on
 *          <c IID_IDirectInputDevice2A> to gate access to the
 *          shared memory block used to track joystick effects.
 *
 *  @parm   LPTSTR | ptszBuf |
 *
 *          Output buffer to receive the converted name.  It must
 *          be <c ctchNameGuid> characters in size.
 *
 *  @parm   PCGUID | pguid |
 *
 *          The GUID to convert.
 *
 *
 *****************************************************************************/

    #pragma BEGIN_CONST_DATA

/* Note: If you change this string, you need to change ctchNameGuid to match */
TCHAR c_tszNameFormat[] =
    TEXT("DirectInput.{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}");

    #pragma END_CONST_DATA


void EXTERNAL
    NameFromGUID(LPTSTR ptszBuf, PCGUID pguid)
{
    int ctch;

    ctch = wsprintf(ptszBuf, c_tszNameFormat,
                    pguid->Data1, pguid->Data2, pguid->Data3,
                    pguid->Data4[0], pguid->Data4[1],
                    pguid->Data4[2], pguid->Data4[3],
                    pguid->Data4[4], pguid->Data4[5],
                    pguid->Data4[6], pguid->Data4[7]);

    AssertF(ctch == ctchNameGuid - 1);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PV | pvFindResource |
 *
 *          Handy wrapper that finds and loads a resource.
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Module instance handle.
 *
 *  @parm   DWORD | id |
 *
 *          Resource identifier.
 *
 *  @parm   LPCTSTR | rt |
 *
 *          Resource type.
 *
 *  @returns
 *
 *          Pointer to resource, or 0.
 *
 *****************************************************************************/

PV EXTERNAL
    pvFindResource(HINSTANCE hinst, DWORD id, LPCTSTR rt)
{
    HANDLE hrsrc;
    PV pv;

    hrsrc = FindResource(hinst, (LPTSTR)(LONG_PTR)(id), rt);
    if(hrsrc)
    {
        pv = LoadResource(hinst, hrsrc);
    } else
    {
        pv = 0;
    }
    return pv;
}

#ifndef UNICODE

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   UINT | LoadStringW |
 *
 *          Implementation of LoadStringW for platforms on which Unicode is
 *          not supported.  Does exactly what LoadStringW would've done
 *          if it existed.
 *
 *  @parm   IN HINSTANCE | hinst |
 *
 *          Module instance handle.
 *
 *  @parm   UINT | ids |
 *
 *          String id number.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          UNICODE output buffer.
 *
 *  @parm   UINT | cwch |
 *
 *          Size of UNICODE output buffer.
 *
 *  @returns
 *
 *          Number of characters copied, not including terminating null.
 *
 *  @comm
 *
 *          Since the string is stored in the resource as UNICODE,
 *          we just take it out ourselves.  If we go through
 *          <f LoadStringA>, we may end up losing characters due
 *          to character set translation.
 *
 *****************************************************************************/

int EXTERNAL
    LoadStringW(HINSTANCE hinst, UINT ids, LPWSTR pwsz, int cwch)
{
    PWCHAR pwch;

    AssertF(cwch);
    ScrambleBuf(pwsz, cbCwch(cwch));

    /*
     *  String tables are broken up into "bundles" of 16 strings each.
     */
    pwch = pvFindResource(hinst, 1 + ids / 16, RT_STRING);
    if(pwch)
    {
        /*
         *  Now skip over the strings in the resource until we
         *  hit the one we want.  Each entry is a counted string,
         *  just like Pascal.
         */
        for(ids %= 16; ids; ids--)
        {
            pwch += *pwch + 1;
        }
        cwch = min(*pwch, cwch - 1);
        memcpy(pwsz, pwch+1, cbCwch(cwch)); /* Copy the goo */
    } else
    {
        cwch = 0;
    }
    pwsz[cwch] = TEXT('\0');            /* Terminate the string */
    return cwch;
}

#endif

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | GetNthString |
 *
 *          Generate a generic numbered object name.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          Output buffer of <c MAX_PATH> characters.
 *
 *  @parm   UINT | ids |
 *
 *          String containing number template.
 *
 *  @parm   UINT | ui |
 *
 *          Button number.
 *
 *****************************************************************************/

void EXTERNAL
    GetNthString(LPWSTR pwsz, UINT ids, UINT ui)
{
    TCHAR tsz[256];
#ifndef UNICODE
    TCHAR tszOut[MAX_PATH];
#endif

    LoadString(g_hinst, ids, tsz, cA(tsz));
#ifdef UNICODE
    wsprintfW(pwsz, tsz, ui);
#else
    wsprintf(tszOut, tsz, ui);
    TToU(pwsz, MAX_PATH, tszOut);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresRunControlPanel |
 *
 *          Run the control panel with the specified applet.
 *
 *  @parm   LPCTSTR | ptszApplet |
 *
 *          Applet name.
 *
 *  @returns
 *
 *          <c S_OK> if we started the applet.
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

TCHAR c_tszControlExeS[] = TEXT("control.exe %s");

#pragma END_CONST_DATA

HRESULT EXTERNAL
    hresRunControlPanel(LPCTSTR ptszCpl)
{
    HRESULT hres;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR tsz[MAX_PATH];
    EnterProc(hresRunControlPanel, (_ "s", ptszCpl));

    ZeroX(si);
    si.cb = cbX(si);
    wsprintf(tsz, c_tszControlExeS, ptszCpl);
    if(CreateProcess(0, tsz, 0, 0, 0, 0, 0, 0, &si, &pi))
    {
        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);
        hres = S_OK;
    } else
    {
        hres = hresLe(GetLastError());
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ObjectInfoWToA |
 *
 *          Convert a <t DIDEVICEOBJECTINSTANCEW>
 *          to a <t DIDEVICEOBJECTINSTANCE_DX3A>
 *          or a <t DIDEVICEOBJECTINSTANCE_DX5A>.
 *
 *  @parm   LPDIDIDEVICEOBJECTINSTANCEA | pdoiA |
 *
 *          Destination.
 *
 *  @parm   LPCDIDIDEVICEOBJECTINSTANCEW | pdoiW |
 *
 *          Source.
 *
 *****************************************************************************/

void EXTERNAL
    ObjectInfoWToA(LPDIDEVICEOBJECTINSTANCEA pdoiA,
                   LPCDIDEVICEOBJECTINSTANCEW pdoiW)
{
    EnterProc(ObjectInfoWToA, (_ "pp", pdoiA, pdoiW));

    AssertF(pdoiW->dwSize == sizeof(DIDEVICEOBJECTINSTANCEW));

    AssertF(IsValidSizeDIDEVICEOBJECTINSTANCEA(pdoiA->dwSize));
    pdoiA->guidType  = pdoiW->guidType;
    pdoiA->dwOfs     = pdoiW->dwOfs;
    pdoiA->dwType    = pdoiW->dwType;
    pdoiA->dwFlags   = pdoiW->dwFlags;

    UToA(pdoiA->tszName, cA(pdoiA->tszName), pdoiW->tszName);

    if(pdoiA->dwSize >= cbX(DIDEVICEOBJECTINSTANCE_DX5A))
    {
        pdoiA->dwFFMaxForce        = pdoiW->dwFFMaxForce;
        pdoiA->dwFFForceResolution = pdoiW->dwFFForceResolution;
        pdoiA->wCollectionNumber   = pdoiW->wCollectionNumber;
        pdoiA->wDesignatorIndex    = pdoiW->wDesignatorIndex;
        pdoiA->wUsagePage          = pdoiW->wUsagePage;
        pdoiA->wUsage              = pdoiW->wUsage;
        pdoiA->dwDimension         = pdoiW->dwDimension;
        pdoiA->wExponent           = pdoiW->wExponent;
        pdoiA->wReportId           = pdoiW->wReportId;
    }

    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | EffectInfoWToA |
 *
 *          Convert a <t DIEFFECTINFOW> to a <t DIEFFECTINFOA>
 *
 *  @parm   LPDIEFFECTINFOA | pdeiA |
 *
 *          Destination.
 *
 *  @parm   LPCDIEFFECTINFOW | pdeiW |
 *
 *          Source.
 *
 *****************************************************************************/

void EXTERNAL
    EffectInfoWToA(LPDIEFFECTINFOA pdeiA, LPCDIEFFECTINFOW pdeiW)
{
    EnterProc(EffectInfoWToA, (_ "pp", pdeiA, pdeiW));

    AssertF(pdeiW->dwSize == sizeof(DIEFFECTINFOW));

    AssertF(pdeiA->dwSize == cbX(*pdeiA));
    pdeiA->guid            = pdeiW->guid;
    pdeiA->dwEffType       = pdeiW->dwEffType;
    pdeiA->dwStaticParams  = pdeiW->dwStaticParams;
    pdeiA->dwDynamicParams = pdeiW->dwDynamicParams;

    UToA(pdeiA->tszName, cA(pdeiA->tszName), pdeiW->tszName);
    ExitProc();
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresValidInstanceVer |
 *
 *          Check the <t HINSTANCE> and version number received from
 *          an application.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          Purported module instance handle.
 *
 *  @parm   DWORD | dwVersion |
 *
 *          Version the application is asking for.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    hresValidInstanceVer_(HINSTANCE hinst, DWORD dwVersion, LPCSTR s_szProc)
{
    HRESULT hres;
    TCHAR tszScratch[4];

    EnterProcS(hresValidInstanceVer, (_ "xxs", hinst, dwVersion, s_szProc));
    /*
     *  You would think that passing a zero-sized buffer to
     *  GetModuleFileName would return the necessary buffer size.
     *
     *  You would be right.  Except that the Win95 validation layer
     *  doesn't realize that this was a valid scenario, so the call
     *  fails in the validation layer and never reached Kernel.
     *
     *  So we read it into a small scratch buffer.  The scratch buffer
     *  must be at least 2 characters; if we passed only 1, then
     *  GetModuleFileName won't be able to write any characters and
     *  will return 0.
     *
     *  Now it turns out that there's a bug in NT where, if you
     *  pass a buffer size of 4, but the actual name is longer than
     *  4, it writes 4 characters, PLUS A NULL TERMINATOR, thereby
     *  smashing your stack and making you fault randomly.
     *
     *  I spent two hours trying to figure that out.
     *
     *  Therefore, you must pass one *less* than the buffer size
     *  to GetModuleFileName, because it will overwrite your buffer
     *  by one.
     */

    if( ( hinst != 0 )
     && GetModuleFileName(hinst, tszScratch, cA(tszScratch) - 1) )
    {
        if(dwVersion == DIRECTINPUT_INTERNAL_VERSION)
        {
            hres = S_OK;
        } else if ( dwVersion == 0 ) {
            RPF("%s: DinputInput object has not been initialized, or the version is given as 0.",
                s_szProc);
            hres = DIERR_NOTINITIALIZED;
        } else if(dwVersion < DIRECTINPUT_VERSION)
        {
            RPF("%s: Incorrect dwVersion(0x%x); program was written with beta SDK. This version 0x%x",
                s_szProc, dwVersion, DIRECTINPUT_VERSION);
            hres = DIERR_BETADIRECTINPUTVERSION;
        } else
        {
            RPF("%s: Incorrect dwVersion(0x%x); program needs newer version of dinput. This version 0x%x",
                s_szProc, dwVersion, DIRECTINPUT_VERSION);
            hres = DIERR_OLDDIRECTINPUTVERSION;
        }

    } else
    {
        RPF("%s: Invalid HINSTANCE", s_szProc);
        hres = E_INVALIDARG;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DupEventHandle |
 *
 *          Duplicate an event handle intra-process-ly.  If the incoming
 *          handle is NULL, then so is the output handle (and the call
 *          succeeds).
 *
 *  @parm   HANDLE | h |
 *
 *          Source handle.
 *
 *  @parm   LPHANDLE | phOut |
 *
 *          Receives output handle.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    DupEventHandle(HANDLE h, LPHANDLE phOut)
{
    HRESULT hres;
    EnterProc(DupEventHandle, (_ "p", h));

    if(h)
    {
        HANDLE hProcessMe = GetCurrentProcess();
        if(DuplicateHandle(hProcessMe, h, hProcessMe, phOut,
                           EVENT_MODIFY_STATE, 0, 0))
        {
            hres = S_OK;
        } else
        {
            hres = hresLe(GetLastError());
        }
    } else
    {
        *phOut = h;
        hres = S_OK;
    }

    ExitOleProc();
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | GetWindowPid |
 *
 *          Simple wrapper that returns the PID of a window.
 *
 *          Here is also where we do goofy hacks for DOS boxes
 *          on Win95.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle.
 *
 *  @returns
 *
 *          PID or 0.
 *
 *****************************************************************************/

DWORD EXTERNAL
    GetWindowPid(HWND hwnd)
{
    DWORD pid;

    if(IsWindow(hwnd) &&
       GetWindowThreadProcessId(hwnd, &pid) )
    {
#ifndef WINNT
           /*
            *  The Winoldap console window belongs to another
            *  process but Win95 lies and says that it belongs
            *  to you but it doesn't.
            */
            if ( GetProp(hwnd, TEXT("flWinOldAp")) != 0 )
            {
                pid = 0;
            }
#endif
    } else
    {
        pid = 0;
    }

    return pid;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresDupPtszPptsz |
 *
 *          OLEish version of strdup.
 *
 *  @parm   LPCTSTR | ptszSrc |
 *
 *          Source string being duplicated.
 *
 *  @parm   LPTSTR * | pptszDst |
 *
 *          Receives the duplicated string.
 *
 *  @returns
 *
 *          <c S_OK> or an error code.
 *
 *****************************************************************************/

HRESULT EXTERNAL
    hresDupPtszPptsz(LPCTSTR ptszSrc, LPTSTR *pptszDst)
{
    HRESULT hres;

    hres = AllocCbPpv(cbCtch(lstrlen(ptszSrc) + 1), pptszDst);

    if(SUCCEEDED(hres))
    {
        lstrcpy(*pptszDst, ptszSrc);
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | fInitializeCriticalSection |
 *
 *          Initialize the give critical section, returning 0 if an exception 
 *          is thrown, else 0.
 *
 *  @parm   LPCRITICAL_SECTION | pCritSec |
 *
 *          Pointer to an uninitialized critical section.
 *
 *****************************************************************************/

BOOL EXTERNAL
    fInitializeCriticalSection(LPCRITICAL_SECTION pCritSec)
{
    BOOL fres = 1;
    EnterProc(fInitializeCriticalSection, (_ "" ));

    AssertF( pCritSec );
    __try
    {
        InitializeCriticalSection( pCritSec );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        fres = 0;
    }

    ExitProcF( fres );
    return fres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DiCharUpperW |
 *
 *          This function converts a wide-character string or a single wide-character
 *          to uppercase. Since Win9x doesn't implement CharUpperW, we have to implement
 *          ourselves.
 *
 *  @parm   LPWSTR | pwsz |
 *
 *          The string to be converted
 *
 *  @returns
 *
 *          void
 *
 *****************************************************************************/

void EXTERNAL 
    DiCharUpperW(LPWSTR pwsz)
{
    int idx;
    int iLen = lstrlenW(pwsz);

    #define DIFF  (L'a' - L'A')
    
    for( idx=0; idx<iLen; idx++ )
    {
        if( (pwsz[idx] >= L'a') && (pwsz[idx] <= L'z') ){
            pwsz[idx] -= DIFF;
        }
    }

    #undef DIFF
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ptrSwap |
 *
 *          swaps the pointers pointed to by the two parameters
 *
 *  @parm   void ** | ppA |
 *
 *          pointer to first pointer
 *
 *  @parm   void ** | ppB |
 *
 *          pointer to second pointer
 *
 *****************************************************************************/
void __inline ptrSwap( PPV ppA, PPV ppB )
{
    PV pTemp = *ppB;
    *ppB = *ppA;
    *ppA = pTemp;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ptrPartialQSort |
 *
 *          Partially sort the passed (sub)set of an array of pointers to 
 *          structures such that resultant array is contains sub arrays which 
 *          are sorted with respect to each other though locally unsorted.
 *          Once partially sorted, a simple sort may be used to complete the 
 *          sort.
 *
 *  @parm   void ** | ppL |
 *          Pointer to lowest element in the (sub)array to sort
 *
 *  @parm   void ** | ppR |
 *          Pointer to highest element in the (sub)array to sort
 *
 *  @parm   COMP_FUNC | fpCompare | 
 *          Pointer to function returning analog of strcmp for strings, but 
 *          supplied by caller for comparing elements of the array.
 *
 *****************************************************************************/

void ptrPartialQSort
( 
    PPV         ppL, 
    PPV         ppR, 
    COMP_FUNC   fpCompare 
)
{
    while( ( ppR - ppL ) > 8 )
    {
        /*
         *  First pick a pivot by sorting the first last and middle
         *  values in the sub array.
         */
        {
            PPV ppMid = ppL + ( ( ppR - ppL ) / 2 );

            if( fpCompare( *ppL, *ppMid ) > 0 )
            {
                ptrSwap( ppL, ppMid );
            }
            if( fpCompare( *ppL, *ppR ) > 0 )
            {
                ptrSwap( ppL, ppR );
            }
            if( fpCompare( *ppMid, *ppR ) > 0 )
            {
                ptrSwap( ppMid, ppR );
            }

            /*
             *  Now we have a reasonable chance of a good pivot, move it 
             *  out of the way.
             */
            ptrSwap( ppMid, ppR-1 );
        }

        /*
         *  Now sort the remainder into high and low parts
         */

        {
            PPV ppHi = ppR - 1;
            PV  pPivot = *ppHi;
            PPV ppLo = ppL;

            for( ;; )
            {
                while( fpCompare( *(++ppLo), pPivot ) < 0 );

                while( fpCompare( *(--ppHi), pPivot ) > 0 );

                if( ppLo >= ppHi ) break;

                ptrSwap( ppLo, ppHi );
            }
        
            /*
             *  Put the pivot back between the two parts as it must be in 
             *  order relative to all the items on each side of it.
             */
            ptrSwap( ppLo, ppR - 1 );

            /*
             *  Recurse on the smaller part and continue with the larger
             */
            if( ppLo - ppL > ppR - ppLo )
            {
                /*
                 *  Left part is larger
                 */
                ptrPartialQSort( ppLo + 1, ppR, fpCompare );
                ppR = ppLo - 1;
            }
            else
            {
                /*
                 *  Right part is larger
                 */
                ptrPartialQSort( ppL, ppLo - 1, fpCompare );
                ppL = ppLo + 1;
            }
        }
    }
}



/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | ptrInsertSort |
 *
 *          Sort the passed (sub)set of an array of pointers to structures.
 *          This sort is not suitable for large arrays.
 *
 *  @parm   void ** | ppBase |
 *          Pointer to lowest element in the (sub)array to sort
 *
 *  @parm   void ** | ppLast |
 *          Pointer to highest element in the (sub)array to sort
 *
 *  @parm   COMP_FUNC | fpCompare | 
 *          Pointer to function returning analog of strcmp for strings, but 
 *          supplied by caller for comparing elements of the array.
 *
 *****************************************************************************/

void ptrInsertSort
( 
    PPV         ppBase, 
    PPV         ppLast, 
    COMP_FUNC   fpCompare 
)
{
    
    PPV ppOuter;

    for( ppOuter = ppBase + 1; ppOuter <= ppLast; ppOuter++ )
    {
        PV  pTemp = *ppOuter;
        PPV ppInner;

        for( ppInner = ppOuter - 1; ppInner >= ppBase; ppInner-- )
        {
            if( fpCompare( pTemp, *ppInner ) > 0 )
            {
                *(ppInner+1) = *ppInner;
            }
            else
            {
                break;
            }
        }

        *(ppInner+1) = pTemp;
    }
        
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | swap |
 *
 *          swaps the two array elements of size width
 *
 *  @parm   char * | a |
 *
 *          pointer to first elements to swap
 *
 *  @parm   char * | b |
 *
 *          pointer to second elements to swap
 *
 *  @parm   unsigned | width |
 *
 *          width in bytes of each array element
 *
 *  @returns
 *
 *          void
 *
 *****************************************************************************/

static void __cdecl swap (
    char *a,
    char *b,
    unsigned width
    )
{
    char tmp;

    if ( a != b )
    {
        /* Do the swap one character at a time to avoid potential alignment
           problems. */
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | shortsort |
 *
 *      sorts the sub-array of elements between lo and hi (inclusive)
 *      side effects:  sorts in place
 *      assumes that lo is less than hi
 *
 *  @parm   char * | lo |
 *          pointer to low element to sort
 *
 *  @parm   char * | hi |
 *          pointer to high element to sort
 *
 *  @parm   unsigned | width |
 *          width in bytes of each array element
 *
 *  @parm   int (*func)() | comp | 
 *           pointer to function returning analog of strcmp for
 *           strings, but supplied by user for comparing the array elements.
 *           it accepts 2 pointers to elements and returns neg if 1 lt 2, 0 if
 *           1 eq 2, pos if 1 gt 2.
 *
 *  @returns
 *
 *          void
 *
 *****************************************************************************/

void __cdecl shortsort (
    char *lo,
    char *hi,
    unsigned width,
    int (__cdecl *comp)(const void *, const void *)
    )
{
    char *p, *max;

    /* Note: in assertions below, i and j are alway inside original bound of
       array to sort. */

    while (hi > lo) {
        /* A[i] <= A[j] for i <= j, j > hi */
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            /* A[i] <= A[max] for lo <= i < p */
            if (comp(p, max) > 0) {
                max = p;
            }
            /* A[i] <= A[max] for lo <= i <= p */
        }

        /* A[i] <= A[max] for lo <= i <= hi */

        swap(max, hi, width);

        /* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

        hi -= width;

        /* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | GetWideUserName |
 *
 *          Get a wide string for a user.
 *          If both of the IN parameters are NULL, memory is allocated for a
 *          MULTI_SZ string and set to the output pointer.  The sting is 
 *          filled with the current user name if available, else a localizable 
 *          default sting.
 *          If a UNICODE name is supplied, it is validated and assigned to the 
 *          output string pointer.  
 *          If an ANSI name is supplied, it is validated and memory is 
 *          allocated into which the translated SZ UNICODE name is written.
 *          Note it is the caller's responsibility to free the memory in 
 *          either of the cases in which is is allocated.
 *          Also note that in the case of an error no memory needs to be
 *          freed.
 *
 *  @parm   LPCSTR | lpszUserName |
 *
 *          A specific ANSI user name.
 *
 *  @parm   LPCWSTR | lpwszUserName |
 *
 *          A specific UNICODE user name.
 *
 *  @parm   LPWSTR* | ppwszGoodUserName |
 *
 *          A pointer to a pointer to the wide user name.
 *
 *  @returns
 *
 *          <c S_OK> if the output string is valid
 *          or an error code reflecting what went wrong.
 *
 *****************************************************************************/
STDMETHODIMP GetWideUserName
(
    IN  LPCSTR lpszUserName,
    IN  LPCWSTR lpwszUserName,
    OUT LPWSTR  *ppwszGoodUserName
)
{
    HRESULT hres = S_OK;

    EnterProcI(GetWideUserName, (_ "AW", lpszUserName, lpwszUserName ));

    if( lpwszUserName )
    {
        /*
         *  Just validate and copy the pointer
         */
        if( SUCCEEDED( hres = hresFullValidReadStrW( lpwszUserName, UNLEN+1, 2 ) ) )
        {
            *ppwszGoodUserName = (LPWSTR)lpwszUserName;
        }
    }
    else if( lpszUserName )
    {
        /*
         *  If an ANSI user name has been passed translate it
         */
        if( SUCCEEDED( hres = hresFullValidReadStrA( lpszUserName, UNLEN+1, 1 ) ) )
        {
            int UserNameLen = lstrlenA( lpszUserName ) + 1;

            hres = AllocCbPpv( cbX(*lpwszUserName) * UserNameLen, ppwszGoodUserName );
            if( SUCCEEDED( hres ) )
            {
                AToU( *ppwszGoodUserName, UserNameLen, lpszUserName );
            }
        }
    }
    else
    {
        DWORD   dwUserNameLen = UNLEN + 1;

#ifdef WINNT
        hres = AllocCbPpv( (dwUserNameLen+1) * 2, ppwszGoodUserName );
        if( SUCCEEDED( hres ) )
        {
            if( GetUserNameW( *ppwszGoodUserName, &dwUserNameLen ) )
            {
#else
        hres = AllocCbPpv( (dwUserNameLen+1) * 3, ppwszGoodUserName );
        if( SUCCEEDED( hres ) )
        {
            if( GetUserNameA( (PCHAR)(&((*ppwszGoodUserName)[UNLEN+2])), &dwUserNameLen ) )
            {
                AToU( *ppwszGoodUserName, dwUserNameLen, (PCHAR)(&((*ppwszGoodUserName)[UNLEN+2])) );
#endif
                /*
                 *  We allocated _and_zeroed_ an extra wchar for double 
                 *  termination.  Assert nobody messed it up and then 
                 *  make sure we don't free the extra.
                 */
                AssertF( (*ppwszGoodUserName)[dwUserNameLen] == L'\0' );
                dwUserNameLen++;
            }
            else
            {
                /*
                 *  If we felt the need, we could follow this recovery path
                 *  only if ( GetLastError() == ERROR_NOT_LOGGED_ON ) and
                 *  report some error or follow some alternate recovery
                 *  otherwise but unless a problem is found with always using
                 *  the default, this seems safer.
                 */
                dwUserNameLen = LoadStringW( g_hinst, IDS_DEFAULTUSER, *ppwszGoodUserName, UNLEN+1 );
                if( dwUserNameLen )
                {
                    /*
                     *  Double terminate the string for ConfigureDevices
                     */
                    dwUserNameLen += 2; 
                    (*ppwszGoodUserName)[dwUserNameLen-1] = L'\0';    
                    SquirtSqflPtszV(sqflUtil | sqflBenign,
                        TEXT("Failed to GetUserName, using default") );
                }
                else
                {
                    SquirtSqflPtszV(sqflUtil | sqflError,
                        TEXT("Failed to GetUserName and default, le = %d"), GetLastError() );
                    hres = E_FAIL;
                }
            }

            /*
             *  Chances are we have way more space than we need
             *  NOTE, in the failure case, this reallocs to zero thus
             *  freeing the memory.
             *  If we have a valid sting, failure to realloc just means
             *  using more memory that we need to for a little while.
             *  If we don't have a string, ReallocCbPpv cannot fail.
             */
            ReallocCbPpv( dwUserNameLen*2, ppwszGoodUserName );


#ifndef WINNT
        }
    }
#else       /*  Reduce bracket matching insanity even though these don't match */
        }
    }
#endif

#ifdef XDEBUG
    if( SUCCEEDED( hres ) )
    {
        AssertF( SUCCEEDED( hresFullValidReadStrW( *ppwszGoodUserName, UNLEN+1, 2 ) ) );
    }
    else
    {
        /*
         *  If a passed string was invalid, we never allocated any memory so 
         *  don't worry about this uninitialized output value for this error.
         */
        if( hres != E_INVALIDARG )
        {
            AssertF( *ppwszGoodUserName == NULL );
        }
    }
#endif

    ExitOleProc();

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | GetValidDI8DevType |
 *
 *          Return a valid type and subtype based on the ones passed, the 
 *          number of buttons and axis/pov caps.
 *          
 *  @parm   DWORD | dwDevType |
 *
 *          Value to be checked, only the type and sub type bits are used.
 *
 *  @parm   DWORD | dwNumButtons |
 *
 *          Number of buttons on device, only used when checking devices mja
 *
 *  @parm   DWORD | dwFlags |
 *
 *          Flags determining any axis/pov requirements. mja
 *
 *  @returns
 *
 *          Zero if the type and subtype are not a valid combination for DX8.
 *          
 *
 *****************************************************************************/

#pragma BEGIN_CONST_DATA

#define MAKE_DI8TYPE_LIMITS( type ) { type##_MIN, type##_MAX, type##_MIN_BUTTONS, type##_MIN_CAPS },
struct
{
    BYTE SubTypeMin;
    BYTE SubTypeMax;
    BYTE MinButtons;
    BYTE HWCaps;
}   c_rgSubTypeDetails[] = {
    { 0, 1, 0, 0 },   /* DI8DEVTYPEDEVICE has no subtype or limits */
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEMOUSE )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEKEYBOARD )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEJOYSTICK )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEGAMEPAD )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEDRIVING )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEFLIGHT )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPE1STPERSON )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEDEVICECTRL )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPESCREENPTR )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPEREMOTE )
    MAKE_DI8TYPE_LIMITS( DI8DEVTYPESUPPLEMENTAL )
};
#undef MAKE_DI8TYPE_LIMITS

#pragma END_CONST_DATA


DWORD EXTERNAL GetValidDI8DevType
(   
    DWORD dwDevType,
    DWORD dwNumButtons,
    DWORD dwFlags
)
{
    BYTE bDevTypeIdx = GET_DIDEVICE_TYPE( dwDevType ) - DI8DEVTYPE_MIN;

    CAssertF( cA( c_rgSubTypeDetails ) == DI8DEVTYPE_MAX - DI8DEVTYPE_MIN );

    if( ( (__int8)bDevTypeIdx >= 0 )
     && ( bDevTypeIdx < DI8DEVTYPE_MAX - DI8DEVTYPE_MIN ) 
     && ( GET_DIDEVICE_SUBTYPE( dwDevType ) >= c_rgSubTypeDetails[bDevTypeIdx].SubTypeMin )
     && ( GET_DIDEVICE_SUBTYPE( dwDevType ) < c_rgSubTypeDetails[bDevTypeIdx].SubTypeMax ) )
    {
        /*
         *  MinButtons of zero means no minimum buttons OR caps
         */
        if( !c_rgSubTypeDetails[bDevTypeIdx].MinButtons
         || ( ( dwNumButtons >= c_rgSubTypeDetails[bDevTypeIdx].MinButtons )
           && ( ( dwFlags & c_rgSubTypeDetails[bDevTypeIdx].HWCaps )
             == c_rgSubTypeDetails[bDevTypeIdx].HWCaps ) ) )
        {
            return dwDevType & ( DIDEVTYPE_TYPEMASK | DIDEVTYPE_SUBTYPEMASK );
        }
        else
        {
            return ( dwDevType & DIDEVTYPE_TYPEMASK ) | MAKE_DIDEVICE_TYPE( 0, DI8DEVTYPE_LIMITEDGAMESUBTYPE );
        }
    }
    else
    {
        return 0;
    }
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DIGetKeyNameTextHelper |
 *
 *          return key name of a key.
 *          
 *  @parm   IN UINT | uiScanCode |
 *
 *          scan code of the key.
 *
 *  @parm   OUT LPWSTR | lpwszName |
 *
 *          The buffer that will hold the returned key name.
 *
 *  @parm   int | nSize |
 *
 *          The length of lpwszName.
 *
 *  @returns
 *
 *          TRUE - if successfully get a key name.
 *          FALSE - otherwise
 *
 *****************************************************************************/

BOOL DIGetKeyNameTextHelper( UINT uiScanCode, LPWSTR lpwszName, int nSize )
{
    HKL   hkl;
    DWORD dwThread, dwProcessId;
    UINT  uiVk;
    BYTE  kbuf[256] = "";
    int   nResult;

    // we only want to use this method to resolve alpha & punct keys.
    if( uiScanCode > 0x53 ) {  
        return FALSE;
    }
    
    //Get the active window's thread
    dwThread=GetWindowThreadProcessId(GetActiveWindow(), &dwProcessId);
    //Get the active window's keyboard layout
    hkl=GetKeyboardLayout(dwThread);
    
    uiVk = MapVirtualKeyEx( uiScanCode, 3, hkl );
#ifdef WINNT
    nResult = ToUnicodeEx(uiVk, uiScanCode, kbuf, lpwszName, nSize, 0, hkl);
#else
    nResult = ToAsciiEx(uiVk, uiScanCode, kbuf, lpwszName, 0, hkl);
#endif

    if( (nResult != 1) || 
        (!iswalpha(lpwszName[0]) && !iswpunct(lpwszName[0])) ) 
    {
        return FALSE;
    } else {
        WCHAR wc;
        
        wc = towupper( lpwszName[0] );
        lpwszName[0] = wc;
    }
    
    return TRUE;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULE | DIGetKeyNameText |
 *
 *          return key name of a key.
 *          
 *  @parm   IN UINT | index |
 *
 *          the index of g_rgbKbdRMap[].
 *
 *  @parm   IN DWORD | dwDevType |
 *
 *          the DevType of the key.
 *
 *  @parm   OUT LPWSTR | lpwszName |
 *
 *          The buffer that will hold the returned key name.
 *
 *  @parm   int | nSize |
 *
 *          The length of lpwszName.
 *
 *  @returns
 *
 *          S_OK - if successfully get a key name.
 *          DIERR_OBJECTNOTFOUND - otherwise
 *
 *****************************************************************************/

HRESULT DIGetKeyNameText( UINT index, DWORD dwDevType, LPWSTR lpwszName, int nSize )
{
    HRESULT hres;
    DWORD dwScancode;
    LONG  lp;
    DWORD dw;
    BOOL  fSpecKey = FALSE;
    DWORD dwSpecKeys[] = { 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,  //number
                           0x90, 0x99, 0xa0, 0xa1, 0xa2, 0xa4, 0xae, 0xb0, 0xb2, 
                           0xde, 0xdf, 0xe3, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 
                           0xeb, 0xec, 0xed };
        
    dwScancode = (DWORD)g_rgbKbdRMap[index];
    lp =  ((dwScancode & 0x7F) << 16) | ((dwScancode & 0x80) << 17);
    
    for( dw = 0; dw < cA(dwSpecKeys); dw++ ) {
        if( dwSpecKeys[dw] == dwScancode ) {
            fSpecKey = TRUE;
            break;
        }
    }
        
    if( !fSpecKey ) {   
        if( !DIGetKeyNameTextHelper(dwScancode, lpwszName, nSize) ) {
            GetKeyNameTextW(lp, lpwszName, nSize);
          #ifndef UNICODE
            if( GetLastError() == ERROR_CALL_NOT_IMPLEMENTED )
            {
                CHAR szName[MAX_PATH];
                GetKeyNameTextA( lp, szName, cA(szName) );
                AToU( lpwszName, cA(szName), szName );
            }
          #endif
        }
    }
        
    if( lpwszName[0] == TEXT('\0') &&
        (dwScancode != 0x56 && dwScancode != 0x73 && dwScancode != 0x7E )
    ) {
        LoadStringW(g_hinst,
                    IDS_KEYBOARDOBJECT + DIDFT_GETINSTANCE(dwDevType),
                    lpwszName, nSize);
    }
    
    if( lpwszName[0] == L'\0' ) {
        hres = DIERR_OBJECTNOTFOUND;
    } else {
        hres = S_OK;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   DWORD | DIGetOSVersion |
 *
 *          Return the OS version on which DInput8.dll is running.
 *          
 *  @returns
 *
 *          WIN95_OS, WIN98_OS, WINME_OS, WINNT_OS, WINWH_OS, or WIN_UNKNOWN_OS.
 *
 *****************************************************************************/

DWORD DIGetOSVersion()
{
    OSVERSIONINFO osVerInfo;
    DWORD dwVer;

    if( GetVersion() < 0x80000000 ) {
        dwVer = WINNT_OS;
    } else {
        dwVer = WIN95_OS;  //assume Windows 95 for safe
    }

    osVerInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    // If GetVersionEx is supported, then get more details.
    if( GetVersionEx( &osVerInfo ) )
    {
        // Win2K
        if( osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT )
        {
            // Whistler: Major = 5 & Build # > 2195
            if( osVerInfo.dwMajorVersion == 5 && osVerInfo.dwBuildNumber > 2195 )
            {
                dwVer = WINWH_OS;
            } else {
                dwVer = WINNT_OS;
            }
        }
        // Win9X
        else
        {
            if( (HIBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 4) ) 
            {
                // WinMe: Major = 4, Minor = 90
                if( (LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) == 90) )
                {
                    dwVer = WINME_OS;
                } else if ( (LOBYTE(HIWORD(osVerInfo.dwBuildNumber)) > 0) ) {
                    dwVer = WIN98_OS;
                } else {
                    dwVer = WIN95_OS;
                }
            }
        }
    }

    return dwVer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\diwinnt.c ===
/*****************************************************************************
 *
 *  DIWdm.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      WINNT specific functions.
 *
 *  Contents:
 *
 *      hResIdJoyInstanceGUID
 *      DIWdm_SetLegacyConfig
 *      DIWdm_InitJoyId
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *      The sqiffle for this file.
 *
 *****************************************************************************/

#define sqfl sqflWDM

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIWdm_SetJoyId |
 *          Given a guid for a HID device and a Joystick ID.
 *          This function will swap the old joystick ID for the device
 *          specified by the guid ( pcguid ) for the new ID specified in 
 *          idJoy
 *
 *  @parm   IN UINT | idJoy |
 *
 *          The Joyid the the HID device specified  by pcguid should have. 
 *
 *  @parm   OUT LPGUID | pcguid |
 *
 *          GUID that specifies a HID device. 
 *
 *  @returns
 *          HRESULT
 *
 *****************************************************************************/
HRESULT EXTERNAL
    DIWdm_SetJoyId
    (
    IN PCGUID   pcguid,
    IN int      idJoy
    )
{
    PHIDDEVICEINFO  phdi;
    HRESULT         hres;
    BOOL            fConfigChanged = FALSE;

    EnterProcI(DIWdm_SetJoyId, (_"Gu", pcguid, idJoy));

    //PostDx7 patch:
    // No point setting the joystick entries in the registry
    // if the ID of the joystick is -1.
    if( idJoy == -1 )
    {
        return E_FAIL;
    }

    DllEnterCrit();

    hres = S_OK;

    /* Get pointer to HIDDEVICEINFO from the GUID */
    phdi = phdiFindHIDInstanceGUID(pcguid);
    if(phdi != NULL )
    {
        PHIDDEVICEINFO  phdiSwap = NULL;
        GUID            guidInstanceOld;
        LONG            lRc;
        int             idJoySwap;

        /* Swap the ID's */
        idJoySwap = phdi->idJoy;
        phdi->idJoy = idJoy;

        phdiSwap = NULL;
        /* Get the GUID for the old ID */
        if( SUCCEEDED( hres = hResIdJoypInstanceGUID_WDM(idJoySwap, &guidInstanceOld)) )
        {
            /* Get pointer to HIDDEVICEINFO for old ID */
            phdiSwap  = phdiFindHIDInstanceGUID(&guidInstanceOld);
            if( phdiSwap )
            {
                phdiSwap->idJoy = idJoySwap;
            } else
            {
                // Old device disappeared !
            }

        } else
        {
            DIJOYCONFIG c_djcReset = {
                cbX(c_djcReset),                   /* dwSize               */
                { 0},                              /* guidInstance         */
                { 0},                              /* hwc                  */
                DI_FFNOMINALMAX,                   /* dwGain               */
                { 0},                              /* wszType              */
                { 0},                              /* wszCallout           */
            };

            hres = JoyReg_SetConfig(idJoySwap, &c_djcReset.hwc,&c_djcReset, DIJC_SETVALID) ;
            if( FAILED(hres) )
            {
                SquirtSqflPtszV(sqfl | sqflError,
                                TEXT("%S: JoyReg_SetConfig to NULL FAILED  "),
                                s_szProc );
            }

        }

        /* Set the new ID and LegacyConfig */
        if( phdi )
        {
            if( lRc = RegSetValueEx(phdi->hk, TEXT("Joystick Id"), 0, REG_BINARY,
                                    (PV)&idJoy, cbX(idJoy)) == ERROR_SUCCESS )
            {
                /*
                 * This extra RegSetValueEx on "Joystick Id" is to keep the 
                 * compatibility with Win2k Gold. 
                 * See Windows bug 395416 for detail.
                 */
                RegSetValueEx(phdi->hkOld, TEXT("Joystick Id"), 0, REG_BINARY,
                                    (PV)&idJoy, cbX(idJoy));

                if( SUCCEEDED( hres = DIWdm_SetLegacyConfig(idJoy)) )
                {
                    fConfigChanged = TRUE;
                }
            }
        }

        /* Set old ID and legacy Config */
        if( (phdiSwap != NULL) && (phdiSwap != phdi) )
        {
            if( lRc = RegSetValueEx(phdiSwap->hk, TEXT("Joystick Id"), 0, REG_BINARY,
                                    (PV)&idJoySwap, cbX(idJoySwap)) == ERROR_SUCCESS )
            {
                /*
                 * This extra RegSetValueEx on "Joystick Id" is to keep the 
                 * compatibility with Win2k Gold. 
                 * See Windows bug 395416 for detail.
                 */
                RegSetValueEx(phdiSwap->hkOld, TEXT("Joystick Id"), 0, REG_BINARY,
                                    (PV)&idJoySwap, cbX(idJoySwap));

                if( SUCCEEDED( hres = DIWdm_SetLegacyConfig(idJoySwap) ) )
                {
                    fConfigChanged = TRUE;
                }
            }
        } else if( phdiSwap == NULL )
        {
            // Old Device disappeared !
            if( SUCCEEDED( hres = DIWdm_SetLegacyConfig(idJoySwap) ) )
            {
               fConfigChanged = TRUE;
            }
        }
    } else
    {
        hres = E_FAIL;
        RPF("ERROR %s: invalid guid.", s_szProc);
    }

  #ifndef WINNT
    if( SUCCEEDED(hres) )
    {
        /*
         * Make sure the new Ids do not cause any collisions
         */
        DIWdm_InitJoyId();
    }
  #endif

    if( fConfigChanged ) {
      #ifdef WINNT
        Excl_SetConfigChangedTime( GetTickCount() );
        PostMessage(HWND_BROADCAST, g_wmJoyChanged, 0, 0L);   
      #else
        joyConfigChanged(0);
      #endif
    }

    DllLeaveCrit();

    ExitOleProc();

    return hres;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | hResIdJoyInstanceGUID_WDM |
 *
 *          Maps a HID JoyStick ID to a DeviceInstance GUID
 *
 *          The parameters have already been validated.
 *
 *
 *  @parm   IN UINT | idJoy |
 *
 *          The Joyid of the HID device to be located.
 *
 *  @parm   OUT LPGUID | lpguid |
 *
 *          The Device Instance GUID corresponding to the JoystickID
 *          If a mapping is not found GUID_NULL is passed back in lpguid
 *
 *  @returns
 *          HRESULT
 *
 *****************************************************************************/
HRESULT EXTERNAL hResIdJoypInstanceGUID_WDM
    (
    IN  UINT idJoy,
    OUT LPGUID lpguid
    )
{
    HRESULT hres = DIERR_NOTFOUND;
    EnterProc( hResIdJoypInstanceGUID_WDM, ( _ "ux", idJoy, lpguid) );

    /* Zap the guid for failure case */
    ZeroBuf(lpguid, cbX(*lpguid) );

    if( idJoy > cJoyMax )
    {
        hres = DIERR_NOMOREITEMS;
    } else
    {
        DllEnterCrit();    

        /* Build the HID list if it is too old */
        DIHid_BuildHidList(FALSE);

        /* Make sure there is some HID device */
        if(g_phdl)
        {
            int ihdi;
            PHIDDEVICEINFO  phdi;

            /* Search over all HID devices */
            for(ihdi = 0, phdi = g_phdl->rghdi;
               ihdi < g_phdl->chdi;
               ihdi++, phdi++)
            {
                /* Check for matching ID */
                if(idJoy == (UINT)phdi->idJoy)
                {
                    hres = S_OK;
                    /* Copy the GUID */
                    *lpguid = phdi->guid;
                    break;
                }
            }
        }
        DllLeaveCrit();
    }

    ExitBenignOleProc();
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   PHIDDEVICEINFO | phdiFindJoyId |
 *
 *          Locates information given a joystick ID for a HID device.
 *
 *          The parameters have already been validated.
 *
 *          The DLL critical must be held across the call; once the
 *          critical section is released, the returned pointer becomes
 *          invalid.
 *
 *  @parm   IN int | idJoy |
 *
 *          The Id of the joystick to be located.
 *
 *  @returns
 *
 *          Pointer to the <t HIDDEVICEINFO> that describes
 *          the device.
 *
 *****************************************************************************/

PHIDDEVICEINFO EXTERNAL
    phdiFindJoyId(int idJoy )
{
    PHIDDEVICEINFO phdi;

    EnterProcI(phdiFindJoyId, (_"u", idJoy));

    /* We should have atleast one HID device */
    if(g_phdl)
    {
        int ihdi;

        /* Loop over all HID devices */
        for(ihdi = 0, phdi = g_phdl->rghdi; ihdi < g_phdl->chdi;
           ihdi++, phdi++)
        {
            /* Match */
            if(idJoy == phdi->idJoy)
            {
                goto done;
            }
        }
    }
    phdi = 0;

    done:;

    ExitProcX((UINT_PTR)phdi);
    return phdi;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DIWdm_SetLegacyConfig |
 *
 *          Sets up the registry keys so that a joystick HID device
 *          can be "seen" by legacy APIs and the Control Panel.
 *          Primarily, this routine sets up the structs that are passed
 *          to JoyReg_SetConfig routine.
 *
 *  @parm   IN int  | idJoy |
 *
 *          Joystick ID.
 *
 *  @returns HRESULT 
 *
 *****************************************************************************/
//ISSUE-2001/03/29-timgill Fix unicode madness
HRESULT INTERNAL DIWdm_SetLegacyConfig
    (
    IN  int idJoy
    )
{
    HRESULT hres;
    DIJOYCONFIG         cfg;
    BOOL                fNeedType;
    BOOL                fNeedConfig;
    BOOL                fNeedNone;
    HKEY                hk;
    DIJOYTYPEINFO       dijti;
    PHIDDEVICEINFO      phdi;
    WCHAR               wszType[cA(VID_PID_TEMPLATE)];
#ifndef UNICODE
    char szType[cbX(VID_PID_TEMPLATE)];
#endif

    EnterProcI(DIWdm_SetLegacyConfig, (_ "u", idJoy));

    if( idJoy == -1 )
    {
        // Dx7Gold Patch:
        // ID == -1 implies this device is not joystick.
        // Do not write any entries to the registry
        return E_FAIL;
    }

    ZeroX(dijti);
    dijti.dwSize = cbX(dijti);

    fNeedType = fNeedConfig = TRUE;
    fNeedNone = FALSE;


    /*
     *  1. Find out what the WinMM registry data is saying now
     */
    CAssertF( JOY_HW_NONE == 0 );
    hres = JoyReg_OpenConfigKey(idJoy, KEY_QUERY_VALUE, 0x0, &hk);
    if( SUCCEEDED(hres) )
    {
        /* Get the type name from the registry */
        JoyReg_GetConfigValue(
                             hk, REGSTR_VAL_JOYNOEMNAME, idJoy, REG_SZ,
                             &cfg.wszType, cbX(cfg.wszType) );
        hres = JoyReg_GetConfigValue(
                                    hk, REGSTR_VAL_JOYNCONFIG, idJoy, REG_BINARY,
                                    &cfg.hwc, cbX(cfg.hwc) );
        RegCloseKey(hk);
    } else
    {
        cfg.wszType[0] = '\0';
    }
    if( FAILED( hres ) )
    {
        cfg.hwc.dwType = JOY_HW_NONE;
    }

    /*
     *  2. If the config info is in sync with WDM then don't rewrite 
     */
    phdi = phdiFindJoyId(idJoy);
    if( phdi )
    {
        /*
         *  The type key for HID devices is "VID_xxxx&PID_yyyy",
         *  mirroring the format used by plug and play.
         */

        if( ( LOWORD(phdi->guidProduct.Data1) == MSFT_SYSTEM_VID )
            &&( ( HIWORD(phdi->guidProduct.Data1) >= MSFT_SYSTEM_PID + JOY_HW_PREDEFMIN ) 
                &&( HIWORD(phdi->guidProduct.Data1) < MSFT_SYSTEM_PID + JOY_HW_PREDEFMAX ) ) )
        {
            /* Predefined type definitions don't go into the registry */
            fNeedType = FALSE;

            /*
             *  Predefined types are determined by the dwType value so fix 
             *  only it if that is wrong.
             */
            if( cfg.hwc.dwType + MSFT_SYSTEM_PID == HIWORD(phdi->guidProduct.Data1) )
            {
                fNeedConfig = FALSE;
            } else
            {
                /*
                 *  Get type info so that JOY_HWS_* flags start with correct values.
                 */
                wszType[0] = L'#';
                wszType[1] = L'0' + HIWORD(phdi->guidProduct.Data1) - MSFT_SYSTEM_PID;
                wszType[2] = L'\0';
                JoyReg_GetPredefTypeInfo(wszType, &dijti, DITC_INREGISTRY | DITC_DISPLAYNAME);        
            }
        } else
        {
            /*
             * This should work, but it doesn't in Win98.
             *
             *   ctch = wsprintfW(wszType, L"VID_%04X&PID_%04X",
             *                LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
             */

#ifdef UNICODE
            wsprintfW(wszType, VID_PID_TEMPLATE,
                      LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
            CharUpperW(wszType);
#else
            wsprintf(szType, VID_PID_TEMPLATE,
                     LOWORD(phdi->guidProduct.Data1), HIWORD(phdi->guidProduct.Data1));
            CharUpper( szType );
            AToU( wszType, cA(wszType), szType );
#endif
        }
    } else
    {
        /*
         *  There is no WDM device so flag for deletion if the WinMM data is wrong
         */
        if( ( cfg.hwc.dwType != JOY_HW_NONE ) || ( cfg.wszType[0] != L'\0' ) )
        {
            fNeedNone = TRUE;
            fNeedType = fNeedConfig = FALSE;
        }
    }


    if( fNeedType ) /* Not already decided against (predefined type) */
    {
        /* Does the registry have the correct device ? */

        /*
         * lstrcmpW doesn't work in Win9x, bad. We have to use our own DiChauUpperW, 
         * then memcmp. Also, the wsprintf template has to use 'X' not 'x'.
         */
        
        DiCharUpperW(cfg.wszType);
        if( (memcmp(cfg.wszType, wszType, cbX(wszType)) == 0x0) 
            && (cfg.hwc.dwType >= JOY_HW_PREDEFMAX) )
        {
            fNeedConfig = FALSE;   
        }

        /* Check the type key */
        hres = JoyReg_GetTypeInfo(wszType, &dijti, DITC_INREGISTRY);
        if( SUCCEEDED(hres) )
        {
            fNeedType = FALSE;
        }
    }

    /*
     *  No failures up to this point should be returned
     */
    hres = S_OK;


    /*
     *  3. If something is missing, find the data from WDM and set it straight
     */
    if( fNeedType || fNeedConfig )
    {
        if( fNeedConfig ) {
            ZeroX(cfg);
            cfg.dwSize   = cbX(cfg);

            hres = DIWdm_JoyHidMapping(idJoy, NULL, &cfg, &dijti );
        } else {

            hres = DIWdm_JoyHidMapping(idJoy, NULL, NULL, &dijti );
        }

        if( SUCCEEDED(hres) )
        {
            if( fNeedType == TRUE)
            {
                hres = hresMumbleKeyEx(HKEY_LOCAL_MACHINE, 
                                       REGSTR_PATH_JOYOEM, 
                                       DI_KEY_ALL_ACCESS, 
                                       REG_OPTION_NON_VOLATILE, 
                                       &hk);

                if( SUCCEEDED(hres) )
                {
                    hres = JoyReg_SetTypeInfo(hk,
                                              cfg.wszType,
                                              &dijti,
                                              DITC_REGHWSETTINGS | DITC_DISPLAYNAME | DITC_HARDWAREID );
                    if( SUCCEEDED(hres ) )
                    {
                    } else // SetTypeinfo FAILED
                        SquirtSqflPtszV(sqfl | sqflError,
                                        TEXT("%S: JoyReg_SetTypeInfo FAILED  "),
                                        s_szProc );

                    RegCloseKey(hk);
                } else // SetTypeinfo FAILED
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: JoyReg_OpenTypeKey FAILED  "),
                                    s_szProc );
            }

            if( fNeedConfig )
            {
                hres = JoyReg_SetConfig(idJoy,
                                        &cfg.hwc,
                                        &cfg,
                                        DIJC_INREGISTRY);

                if( SUCCEEDED(hres) )
                {
                  #ifdef WINNT
                    Excl_SetConfigChangedTime( GetTickCount() );
                    PostMessage (HWND_BROADCAST, g_wmJoyChanged, idJoy+1, 0L);
                  #else
                    joyConfigChanged(0);
                  #endif
                } else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT(",JoyReg_SetConfig FAILED hres=%d"),
                                    hres);
                }
            }
        } else // DIWdm_GetJoyHidMapping FAILED 
        {
            fNeedNone = TRUE;
        }
    }

    /*
     *  4. If WinMM has data for a device that WDM does not, delete it
     */
    if( fNeedNone )
    {
        ZeroX( cfg );
        cfg.dwSize = cbX( cfg );
        cfg.dwGain = DI_FFNOMINALMAX;

        if(SUCCEEDED(hres = JoyReg_SetConfig(idJoy, &cfg.hwc,
                                             &cfg, DIJC_SETVALID)) &&
           SUCCEEDED(hres = JoyReg_OpenConfigKey(idJoy, MAXIMUM_ALLOWED,
                                                 REG_OPTION_VOLATILE, &hk)))
        {
            TCHAR tsz[MAX_JOYSTRING];

            wsprintf(tsz, TEXT("%u"), idJoy + 1);
          #ifdef WINNT
            DIWinnt_RegDeleteKey(hk, tsz);
          #else
            RegDeleteKey(hk, tsz);
          #endif
            RegCloseKey(hk);

            hres = S_OK;
        }
    }

    ExitProcX(hres);

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DIWdm_InitJoyId |
 *
 *          Initializes Joystick IDs for JoyConfig and legacy APIs
 *          Store the joystick IDs the registry under the %%DirectX/JOYID key.
 *
 *****************************************************************************/

BOOL EXTERNAL
    DIWdm_InitJoyId( void )
{
    BOOL    fRc;
    LONG    lRc;
    int     ihdi;
    int     idJoy;
    BOOL    fNeedId;
    BOOL    rfJoyId[cJoyMax];     /* Bool Array for to determine which IDs are in use */
    PHIDDEVICEINFO phdi;
    HRESULT hres = E_FAIL;

    EnterProcI(DIWdm_InitJoyId, (_ ""));

    DllEnterCrit();

    fRc = TRUE;
    ZeroX(rfJoyId );
    fNeedId = FALSE;


    /* Iterate over all HID devices to find used IDs */
    for( ihdi = 0, phdi = g_phdl->rghdi ;
       (g_phdl != NULL) && (phdi != NULL) && (phdi->fAttached) && (ihdi < g_phdl->chdi) ;
       ihdi++, phdi++ )
    {
        /* We need joyIDs only for HID game controller devices */
        if( ( GET_DIDEVICE_TYPE( phdi->osd.dwDevType ) >= DI8DEVTYPE_GAMEMIN ) 
         && ( phdi->osd.dwDevType & DIDEVTYPE_HID ) )
        {
            idJoy = phdi->idJoy ;

            /* Validate the ID. */
            if( idJoy < cJoyMax && rfJoyId[idJoy] != TRUE )
            {
                rfJoyId[idJoy] = TRUE;
                hres = DIWdm_SetLegacyConfig(idJoy);
                if( FAILED ( hres ) )
                {
                    fRc = FALSE;
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: DIWdm_SetLegacyConfig() FAILED ")
                                    TEXT("idJoy=%d FAILED hres = %d"),
                                    s_szProc, idJoy, hres );
                }
            } else 
            {
                /* ID either over the limit OR is already used */
                phdi->idJoy = JOY_BOGUSID;
                fNeedId = TRUE;
            }
        }
    }

    /* Are there devices that need an ID */
    if( fNeedId )
    {
        /*
         * We have Examined all Joystick Ids found used IDs
         * and determined some device needs an Id
         */
        /* Iterate to assign unused Id's */
        for( ihdi = 0, phdi = g_phdl->rghdi;
           ihdi < g_phdl->chdi ;
           ihdi++, phdi++ )
        {
            /* We need joyIDs only for HID game controller devices */
            if( ( GET_DIDEVICE_TYPE( phdi->osd.dwDevType ) >= DI8DEVTYPE_GAMEMIN ) 
             && ( phdi->osd.dwDevType & DIDEVTYPE_HID ) )
            {
                idJoy = phdi->idJoy;
                if( idJoy == JOY_BOGUSID  )
                {
                    /* Get an Unused ID */
                    for(idJoy = 0x0;
                       idJoy < cJoyMax;
                       idJoy++ )
                    {
                        if( rfJoyId[idJoy] == FALSE )
                            break;
                    }

                    if( idJoy < cJoyMax )
                    {
                        rfJoyId[idJoy] = TRUE;
                        phdi->idJoy  = idJoy;
                        if( lRc = RegSetValueEx(phdi->hk, TEXT("Joystick Id"), 0, REG_BINARY,
                                                (PV)&idJoy, cbX(idJoy)) == ERROR_SUCCESS )
                        {
                            /*
                             * This extra RegSetValueEx on "Joystick Id" is to keep the 
                             * compatibility with Win2k Gold. 
                             * See Windows bug 395416 for detail.
                             */
                            RegSetValueEx(phdi->hkOld, TEXT("Joystick Id"), 0, REG_BINARY,
                                                (PV)&idJoy, cbX(idJoy));

                            /* Setup Registry data for legacy API's */
                            hres = DIWdm_SetLegacyConfig(idJoy);

                            if( FAILED ( hres ) )
                            {
                                fRc = FALSE;
                                SquirtSqflPtszV(sqfl | sqflError,
                                                TEXT("%S: DIWdm_SetLegacyConfig() FAILED")
                                                TEXT(" idJoy=%d hres = %d"),
                                                s_szProc, idJoy, hres );
                            }
                        } else
                        {
                            SquirtSqflPtszV(sqfl | sqflError,
                                            TEXT("%S: RegSetValueEx(JOYID) FAILED ")
                                            TEXT("Error = %d"),
                                            s_szProc, lRc);
                            fRc = FALSE;
                        }
                    }
                }
            }
        }
    }

    DllLeaveCrit();

    ExitBenignProcF(fRc);

    return fRc;
}

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | DIWdm_SetConfig |
 *
 *          Sets config for analog joysticks. This function is an
 *          extention of the JoyCfg_SetConfig function for NT.
 *          It associates a gameport/serialport bus with a legacy (HID) device and
 *          sends an IOCTL to the gameport/serialport bus to attach the device.
 *          The IOCLT takes the hardware ID[] which is got from
 *          the Joystick OEM types entry
 *          (HKLM\CurrentControlSet\Control\Media\PrivateProperties\Joystick\OEM)
 *          Some time later PnP realizes that a new device has been added, and hunts for
 *          an inf file that matches the HardwareId.
 *
 *          When the new HID device finally shows up, we look for the gameport/serialport that
 *          the HID device is associated with and try to give it the requested idJoy.
 *
 *
 *  @parm   IN UINT | idJoy |
 *
 *          ID of Joystick
 *
 *  @parm   IN LPJOYREGHWCONFIG | pjwc |
 *
 *          Address of JOYREGHWCONFIG structure that contains config info for the joystick
 *
 *  @parm   IN LPCDIJOYCONFIG  | pcfg |
 *
 *          Address of DIJOYCONFIG structure that contains config info for the joystick
 *
 *  @parm   IN DWORD | fl |
 *
 *          Flags
 *
 *  @returns
 *
 *          DIERR_INVALIDPARAM  This function needs DX6.1a functionality.
 *          DIERR_UNSUPPORTED   Autoload devices cannot be added through this API. 
 *          DIERR_NOTFOUND      TypeInfo not found in the registry.
 *          E_ACCESSDENIED      Gameport is configured to use another device.
 *          E_FAIL              CreateFile on Gameport device failed. 
 *                              Could not send IOCTL to gameport device.    
 *
 *****************************************************************************/

HRESULT EXTERNAL
    DIWdm_SetConfig
    (
    IN UINT             idJoy,
    IN LPJOYREGHWCONFIG pjwc,
    IN LPCDIJOYCONFIG   pcfg,
    IN DWORD            fl
    )
{
    HRESULT hres;
    EnterProc(DIWdm_SetConfig, (_"uppu", idJoy, pjwc, pcfg, fl));

    DllEnterCrit();

    hres = E_FAIL;

    if( pcfg->dwSize < cbX(DIJOYCONFIG_DX6 ))
    {
        /* This function needs DX5B2 functionality */
        hres = DIERR_INVALIDPARAM;
    } else if( pjwc->hws.dwFlags & JOY_HWS_AUTOLOAD )
    {
        /* Device cannot be autoload */
        hres = DIERR_UNSUPPORTED;
    } else
    {
        DIJOYTYPEINFO dijti;
        BUS_REGDATA RegData;

        ZeroX(dijti);
        dijti.dwSize = cbX(dijti);

        ZeroX(RegData);
        RegData.dwSize     = cbX(RegData);
        RegData.nJoysticks = 1; 

        /* Is this a predefined joystick type ? */
        if(pcfg->wszType[0] == TEXT('#'))
        {
#define JoyCfg_TypeFromChar(tch)   ((tch) - L'0')
            hres = JoyReg_GetPredefTypeInfo(pcfg->wszType,
                                            &dijti, DITC_INREGISTRY | DITC_HARDWAREID);

            RegData.uVID = MSFT_SYSTEM_VID;
            RegData.uPID = MSFT_SYSTEM_PID + JoyCfg_TypeFromChar(pcfg->wszType[1]);

            if(JoyCfg_TypeFromChar(pcfg->wszType[1]) == JOY_HW_TWO_2A_2B_WITH_Y  )
            {
                RegData.nJoysticks = 2;
                pjwc->hws.dwFlags = 0x0;
            }
#undef JoyCfg_TypeFromChar
        } else
        {
            hres = JoyReg_GetTypeInfo(pcfg->wszType,
                                      &dijti, DITC_INREGISTRY | DITC_HARDWAREID | DITC_DISPLAYNAME );

            if( SUCCEEDED(hres) )
            {
                USHORT uVID, uPID;
                PWCHAR pCurrChar;
                PWCHAR pLastSlash = NULL;

                /* Find the last slash in the hardwareId, any VID/PID should follow directly */
                for( pCurrChar = dijti.wszHardwareId; *pCurrChar != L'\0'; pCurrChar++ )
                {
                    if( *pCurrChar == L'\\' )
                    {
                        pLastSlash = pCurrChar;
                    }
                }

                /*
                 *  If the hardware ID has no separator, treat the device as 
                 *  though JOY_HWS_AUTOLOAD were set because we cannot expose 
                 *  a non-PnP device without a hardware ID.
                 */
                if( pLastSlash++ )
                {
                    /* 
                     *  If the hardwareId does contain a VIDPID, try the type 
                     *  name.  Some auto-detect types require this.
                     *
                     *  Prefix gets messed up in ParseVIDPID (mb:34573) and warns 
                     *  that uVID is uninitialized when ParseVIDPID returns TRUE.
                     */
                    if( ParseVIDPID( &uVID, &uPID, pLastSlash )
                     || ParseVIDPID( &uVID, &uPID, pcfg->wszType ) )
                    {
                        RegData.uVID = uVID;
                        RegData.uPID = uPID;        
                    }
                    else
                    {
                        SquirtSqflPtszV(sqfl | sqflBenign,
                                        TEXT("%hs: cannot find VID and PID for non-PnP type %ls"),
                                        s_szProc, pcfg->wszType);
                    }
                }
                else
                {
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%hs: invalid hardware ID for non-PnP type %ls"),
                                    s_szProc, pcfg->wszType);
                    hres = DIERR_UNSUPPORTED;
                }


            }
        }



        if( SUCCEEDED(hres) )
        {
            PBUSDEVICEINFO pbdi;
            PBUSDEVICELIST pbdl;

            /* Copy over the hardwareID */
            lstrcpyW(RegData.wszHardwareId, dijti.wszHardwareId);
            RegData.hws = pjwc->hws;
            RegData.dwFlags1 = dijti.dwFlags1;

            pbdi = pbdiFromGUID(&pcfg->guidGameport);

            // Attach device to the gameport
            if( pbdi )
            {
                // Set the Joystick ID for the gameport/serialport
                pbdi->idJoy = idJoy;

                // We know which instance of the gameport. 
                hres = DIBusDevice_Expose(pbdi, &RegData); 
            } else if( NULL != ( pbdl = pbdlFromGUID(&pcfg->guidGameport ) ) )
            {
                // We don't kwow which instance of the gameport
                // only which bus. 
                // We will expose the device on all instances of the
                // gameport and later delete devices when we find they
                // are not connected. 
                hres = DIBusDevice_ExposeEx(pbdl, &RegData);
            } else
            {
                hres = DIERR_DEVICENOTREG;
            }


            if( SUCCEEDED(hres) )
            {
                /* Device is not present */
                pjwc->dwUsageSettings &= ~JOY_US_PRESENT;

                /* Definately volatile */
                pjwc->dwUsageSettings |=  JOY_US_VOLATILE;

            }
        }
    }

    ExitOleProc();
    DllLeaveCrit();

    return hres;
} /* DIWdm_SetConfig */

/*****************************************************************************
 *
 *  @doc    EXTERNAL
 *
 *  @func   HRESULT | DIWdm_DeleteConfig |
 *
 *          WDM extension for JoyCfd::DeleteConfig. On WDM a legacy(HID) device will
 *          keep reappearing as long as the gameport bus is aware of it. So when a
 *          legacy(HID) device is deleted, we need to find out he associated gameport bus
 *          and tell him to stop attaching the device.
 *
 *  @parm   IN UINT | idJoy |
 *
 *          ID of Joystick
 *
 *  @returns
 *
 *          HRESULT code
 *          DIERR_DEVICENOTREG:     Device is not a WDM device
 *          DIERR_UNSUPPORTED:      Device is WDM but not gameport
 *          S_OK:                   Device Persistance removed.  
 *
 *****************************************************************************/


HRESULT EXTERNAL
    DIWdm_DeleteConfig( int idJoy )
{
    HRESULT hres = S_OK;
    PBUSDEVICEINFO  pbdi = NULL;
    PHIDDEVICEINFO  phdi = NULL;

    EnterProcI(DIWdm_DeleteConfig, (_"u", idJoy));
    DllEnterCrit();

    DIHid_BuildHidList(FALSE);

    /*
     * pbdi (BUSDEVICEINFO) must be obtained before we remove the device
     */
    phdi = phdiFindJoyId(idJoy);
    if(phdi != NULL )
    {
        pbdi = pbdiFromphdi(phdi);
    } else
    {
        hres = DIERR_DEVICENOTREG;
        goto _done;
    }


    if( SUCCEEDED(hres) 
        && phdi != NULL 
        && pbdi != NULL )
    {
        lstrcpy( g_tszIdLastRemoved, pbdi->ptszId );
        g_tmLastRemoved = GetTickCount();

        // If the device is a bus device ( Non USB )
        // it needs some help in removal. 
        hres = DIBusDevice_Remove(pbdi); 

        //If the device has been successfully removed,
        //then we need remember it in phdi list in case
        //the PnP doesn't function well.
        if( pbdi->fAttached == FALSE )
        {
            phdi->fAttached = FALSE;
        }

    } else
    {
        //HDEVINFO hdev;

        // Device is USB, we do not support removing
        // USB devices from the CPL. User is encouraged to 
        // Yank out the device or go to the device manager to 
        // remove it. 

        // This is true in Win2K. But in Win9X, since VJOYD also works with USB,
        // when we swap id, we need delete it first.

        hres = DIERR_UNSUPPORTED;
        
#if 0
        // In case we wanted to support removing USB devices from 
        // the game cpl. Here is the code ... 

        /*
         *  Talk to SetupApi to delete the device.
         *  This should not be necessary, but I have
         *  to do this to work around a PnP bug whereby
         *  the device is not removed after I send a remove
         *  IOCTL to gameenum.
         */
        hdev = SetupDiCreateDeviceInfoList(NULL, NULL);
        if( phdi && hdev != INVALID_HANDLE_VALUE)
        {
            SP_DEVINFO_DATA dinf;

            dinf.cbSize = cbX(SP_DEVINFO_DATA);

            /* Get SP_DEVINFO_DATA for the HID device */
            if(SetupDiOpenDeviceInfo(hdev, phdi->ptszId, NULL, 0, &dinf))
            {
                /* Delete the device */
                if( SetupDiCallClassInstaller(DIF_REMOVE,
                                              hdev,
                                              &dinf) )
                {
                    // SUCCESS 
                } else
                {
                    hres = E_FAIL;
                    SquirtSqflPtszV(sqfl | sqflError,
                                    TEXT("%S: SetupDiClassInstalled(DIF_REMOVE) FAILED  "),
                                    s_szProc );
                }
            }
            SetupDiDestroyDeviceInfoList(hdev);
        }
#endif
    }

_done:

    /*
     * Force a remake of the HID list
     * Some devices may have disappered
     * It helps to sleep for some time to give
     * PnP and its worker threads to spin.
     */
    Sleep(10);

    DIHid_BuildHidList(TRUE);
    DllLeaveCrit();

    ExitOleProc();

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\valid.c ===
/*****************************************************************************
 *
 *  Valid.c
 *
 *  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  Abstract:
 *
 *      Validate services.  On a validation error that would not have
 *      been caught in retail, we throw an exception.
 *
 *  Contents:
 *
 *      fFullValidPhwnd
 *      fFullValidPpdw
 *      fFullValidPpfn
 *      fFullValidReadPx
 *      fFullValidWritePx
 *
 *****************************************************************************/

#include "dinputpr.h"

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidHwnd |
 *
 *          Validate a window handle completely.
 *
 *  @parm   HWND | hwnd |
 *
 *          Window handle to validate.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_HANDLE> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidHwnd_(HWND hwnd, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (IsWindow(hwnd)) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: not a window handle", s_szProc, iarg);
        hres = E_HANDLE;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPvCb_ |
 *
 *          Validate that a buffer is readable or writeable.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   PFNBAD | pfnBad |
 *
 *          Function that determines whether the buffer is bad.
 *          Should be <f IsBadReadPtr> or <f IsBadWritePtr>.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *          High word indicates how many bytes should not be
 *          scrambled.
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

typedef BOOL (WINAPI *PFNBAD)(PCV pv, UINT_PTR cb);

#ifndef XDEBUG

#define hresFullValidPvCb_(pv, cb, pfnBad, z, i)                    \
       _hresFullValidPvCb_(pv, cb, pfnBad)                          \

#endif

STDMETHODIMP
hresFullValidPvCb_(PCV pv, UINT cb, PFNBAD pfnBad, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (!pfnBad(pv, LOWORD(cb))) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, LOWORD(iarg));
        hres = E_POINTER;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWritePvCb_ |
 *
 *          Validate that a buffer is writeable.  Also scrambles it
 *          if special goo doesn't need to be done.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWritePvCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    hres = hresFullValidPvCb_(pv, cb, (PFNBAD)IsBadWritePtr, s_szProc, iarg);
#ifdef XDEBUG
    if (SUCCEEDED(hres) && HIWORD(iarg) == 0) {
        ScrambleBuf(pv, cb);
    }
#endif
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWriteLargePvCb_ |
 *
 *          Validate that a large buffer is writeable.  
 *          "Large" means 64K or more. 
 *          Also scrambles it if special goo doesn't need to be done.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWriteLargePvCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if( !IsBadWritePtr( pv, cb ) ) 
    {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, LOWORD(iarg));
        hres = E_POINTER;
    }
#ifdef XDEBUG
    if (SUCCEEDED(hres) && HIWORD(iarg) == 0) {
        ScrambleBuf(pv, cb);
    }
#endif
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadPvCb_ |
 *
 *          Validate that a buffer is readable.
 *
 *  @parm   PV | pv |
 *
 *          Buffer address.
 *
 *  @parm   UINT | cb |
 *
 *          Size of buffer in bytes.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadPvCb_(PCV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    return hresFullValidPvCb_(pv, cb, (PFNBAD)IsBadReadPtr, s_szProc, iarg);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPxCb_ |
 *
 *          Validate that a sized structure is readable or writeable.
 *
 *  @parm   PCV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.  If the structure is being validated for
 *          writing, then all fields beyond the <p dwSize> are scrambled
 *          in XDEBUG.
 *
 *  @parm   UINT | cbHiLo |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   STRUCTPROC | pfnStruct |
 *
 *          Function which validates that a structure is readable or writable.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not readable or writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

typedef STDMETHOD(STRUCTPROC)(PCV pv, UINT cb
                                   RD(comma LPCSTR s_szProc comma int iarg));

#ifndef XDEBUG

#define hresFullValidPxCb_(pv, cbHiLo, pfnStruct, z, i)             \
       _hresFullValidPxCb_(pv, cbHiLo, pfnStruct)                   \

#endif

STDMETHODIMP
hresFullValidPxCb_(PCV pv, UINT cbHiLo, STRUCTPROC pfnStruct,
                   LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    /*
     *  Raymond frequently suffers a brain lapse and passes
     *  a cbX(LPMUMBLE) instead of a cbX(MUMBLE).
     */
    AssertF(LOWORD(cbHiLo) != cbX(DWORD));
    AssertF(HIWORD(cbHiLo) != cbX(DWORD));

    if (!IsBadReadPtr(pv, cbX(DWORD))) {

        DWORD cbIn = *(LPDWORD)pv;

        /*
         *  The leading "cbIn &&" prevents the HIWORD(cbHiLo)==0 case from
         *  accidentally allowing a size of zero to sneak past.
         */

        if (cbIn && (cbIn == LOWORD(cbHiLo) || cbIn == HIWORD(cbHiLo))) {

            hres = pfnStruct(pv, cbIn RD(comma s_szProc comma iarg));
            if (SUCCEEDED(hres)) {
                if (HIWORD(iarg)) {
                    ScrambleBuf(pvAddPvCb(pv, HIWORD(iarg)),
                                cbIn - HIWORD(iarg));
                }
            }
        } else {
            RPF("ERROR %s: arg %d: invalid dwSize x%x", s_szProc, LOWORD(iarg), cbIn);
            hres = E_INVALIDARG;
        }
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, LOWORD(iarg));
        hres = E_POINTER;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPxCb3_ |
 *
 *          Validate that a sized structure is readable or writeable.
 *
 *  @parm   PCV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.  If the structure is being validated for
 *          writing, then all fields beyond the <p dwSize> are scrambled
 *          in XDEBUG.
 *
 *  @parm   UINT | cb |
 *
 *          Expected sizes of the structure.
 *
 *  @parm   UINT | cb2 |
 *
 *          Expected sizes of the alternate structure.
 *
 *  @parm   UINT | cb3 |
 *
 *          Expected sizes of the alternate structure.
 *
 *  @parm   STRUCTPROC | pfnStruct |
 *
 *          Function which validates that a structure is readable or writable.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not readable or writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

#ifndef XDEBUG

#define hresFullValidPxCb3_(pv, cb, cb2, cb3, pfnStruct, z, i)             \
       _hresFullValidPxCb3_(pv, cb, cb2, cb3, pfnStruct)                   \

#endif

STDMETHODIMP
hresFullValidPxCb3_(PCV pv, UINT cb, UINT cb2, UINT cb3, STRUCTPROC pfnStruct,
                   LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    /*
     *  Raymond frequently suffers a brain lapse and passes
     *  a cbX(LPMUMBLE) instead of a cbX(MUMBLE).
     */
    AssertF(cb  != cbX(DWORD));
    AssertF(cb2 != cbX(DWORD));
    AssertF(cb3 != cbX(DWORD));

    if (!IsBadReadPtr(pv, cbX(DWORD))) {

        DWORD cbIn = *(LPDWORD)pv;

        /*
         *  The leading "cbIn &&" prevents the HIWORD(cbHiLo)==0 case from
         *  accidentally allowing a size of zero to sneak past.
         */

        if (cbIn && (cbIn == cb || cbIn == cb2 || cbIn == cb3)) {

            hres = pfnStruct(pv, cbIn RD(comma s_szProc comma iarg));
            if (SUCCEEDED(hres)) {
                if (HIWORD(iarg)) {
                    ScrambleBuf(pvAddPvCb(pv, HIWORD(iarg)),
                                cbIn - HIWORD(iarg));
                }
            }
        } else {
            RPF("ERROR %s: arg %d: invalid dwSize", s_szProc, LOWORD(iarg));
            hres = E_INVALIDARG;
        }
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, LOWORD(iarg));
        hres = E_POINTER;
    }

    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWritePxCb_ |
 *
 *          Validate that a sized structure is writeable.  The contents
 *          of the structure are scrambled before returning.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cbHiLo |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWritePxCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    /*
     *  We need to distinguish hresFullValidWritePvCb_ and
     *  _hresFullValidWritePvCb_ manually, because the preprocessor
     *  can't do it.
     *
     *  We also need to put a cbX(DWORD) into the high word of the iarg
     *  so that the size field won't get demolished.
     */
#ifdef XDEBUG
    return hresFullValidPxCb_(pv, cb, (STRUCTPROC)hresFullValidWritePvCb_,
                                      s_szProc, MAKELONG(iarg, cbX(DWORD)));
#else
    return hresFullValidPxCb_(pv, cb, (STRUCTPROC)_hresFullValidWritePvCb_,
                                      s_szProc, iarg);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadPxCb3_ |
 *
 *          Validate that a sized structure is readable.  The contents
 *          of the structure are scrambled before returning.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cb |
 *
 *          One expected size of the structure.  
 *
 *  @parm   UINT | cb2 |
 *
 *          Expected sizes of the alternate structure.
 *
 *  @parm   UINT | cb3 |
 *
 *          Expected sizes of the alternate structure.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not readable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadPxCb3_(PV pv, UINT cb, UINT cb2, UINT cb3, LPCSTR s_szProc, int iarg)
{
    /*
     *  We need to distinguish hresFullValidReadPvCb_ and
     *  _hresFullValidReadPvCb_ manually, because the preprocessor
     *  can't do it.
     */
#ifdef XDEBUG
    return hresFullValidPxCb3_(pv, cb, cb2, cb3, (STRUCTPROC)hresFullValidReadPvCb_,
                                      s_szProc, iarg);
#else
    return hresFullValidPxCb3_(pv, cb, cb2, cb3, (STRUCTPROC)_hresFullValidReadPvCb_,
                                      s_szProc, iarg);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWritePxCb3_ |
 *
 *          Validate that a sized structure is writeable.  The contents
 *          of the structure are scrambled before returning.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cb |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   UINT | cb2 |
 *
 *          Expected sizes of the alternate structure.
 *
 *  @parm   UINT | cb3 |
 *
 *          Expected sizes of the alternate structure.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWritePxCb3_(PV pv, UINT cb, UINT cb2, UINT cb3, LPCSTR s_szProc, int iarg)
{
    /*
     *  We need to distinguish hresFullValidWritePvCb_ and
     *  _hresFullValidWritePvCb_ manually, because the preprocessor
     *  can't do it.
     *
     *  We also need to put a cbX(DWORD) into the high word of the iarg
     *  so that the size field won't get demolished.
     */
#ifdef XDEBUG
    return hresFullValidPxCb3_(pv, cb, cb2, cb3, (STRUCTPROC)hresFullValidWritePvCb_,
                                      s_szProc, MAKELONG(iarg, cbX(DWORD)));
#else
    return hresFullValidPxCb3_(pv, cb, cb2, cb3, (STRUCTPROC)_hresFullValidWritePvCb_,
                                      s_szProc, iarg);
#endif
}

#ifdef XDEBUG

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidWriteNoScramblePxCb_ |
 *
 *          Validate that a sized structure is writeable.  The contents
 *          of the structure are not scrambled.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cbHiLo |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not writeable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidWriteNoScramblePxCb_(PV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    return hresFullValidPxCb_(pv, cb, (STRUCTPROC)hresFullValidWritePvCb_,
                                      s_szProc, MAKELONG(iarg, cb));
}
#endif


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadPxCb_ |
 *
 *          Validate that a sized structure is readable.
 *
 *  @parm   PV | pv |
 *
 *          Structure address.  The first field of the structure must
 *          be a <p dwSize>.
 *
 *  @parm   UINT | cbHiLo |
 *
 *          Expected sizes of the structure.  One valid size is in the
 *          low word.  An optional alternate valid size is in the high
 *          word.  (The alternate valid size is needed because some
 *          structures changed size between DirectX 3 and DirectX 5.)
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the buffer is not readable.
 *
 *          <c E_INVALIDARG> if the buffer size is incorrect.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadPxCb_(PCV pv, UINT cb, LPCSTR s_szProc, int iarg)
{
    /*
     *  We need to distinguish hresFullValidReadPvCb_ and
     *  _hresFullValidReadPvCb_ manually, because the preprocessor
     *  can't do it.
     */
#ifdef XDEBUG
    return hresFullValidPxCb_(pv, cb, hresFullValidReadPvCb_, s_szProc, iarg);
#else
    return hresFullValidPxCb_(pv, cb, _hresFullValidReadPvCb_, s_szProc, iarg);
#endif
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidFl_ |
 *
 *          Validate that no invalid flags are passed.
 *
 *  @parm   DWORD | fl |
 *
 *          Flags passed by the caller.
 *
 *  @parm   DWORD | flV |
 *
 *          Flags which are valid.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidFl_(DWORD fl, DWORD flV, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if ((fl & ~flV) == 0) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid flags", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPfn_ |
 *
 *          Validate that the parameter is a valid code pointer.
 *
 *          Actually, <f IsValidCodePtr> on Win32 is broken, but
 *          tough.
 *
 *  @parm   FARPROC | pfn |
 *
 *          Procedure to "validate".
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the parameter is invalid.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPfn_(FARPROC pfn, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (!IsBadCodePtr(pfn)) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid callback address", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPitf_ |
 *
 *          Validate that the parameter is an interface pointer.
 *
 *          We don't look at it very hard.
 *
 *  @parm   PUNK | punk |
 *
 *          <i IUnknown> to "validate".
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the pointer itself is bogus.
 *
 *          <c E_INVALIDARG> if something inside the pointer is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPitf_(PUNK punk, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    if (!IsBadReadPtr(punk, cbX(*punk))) {
        IUnknownVtbl *pvtbl = punk->lpVtbl;
        if (!IsBadReadPtr(pvtbl, cbX(*pvtbl))) {
            if (!IsBadCodePtr((FARPROC)pvtbl->QueryInterface) &&
                !IsBadCodePtr((FARPROC)pvtbl->AddRef) &&
                !IsBadCodePtr((FARPROC)pvtbl->Release)) {
                hres = S_OK;
            } else {
                RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
                hres = E_INVALIDARG;
            }
        } else {
            RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
            hres = E_INVALIDARG;
        }
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
        hres = E_POINTER;
    }

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPcbOut_ |
 *
 *          Validate that the parameter is a valid place to stick an
 *          output result.  We also smas it to zero.
 *
 *  @parm   PV | pcb |
 *
 *          Pointer to "validate".
 *
 *  @parm   UINT | cb |
 *
 *          Size of data pcb points to.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_POINTER> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPcbOut_(PV pcb, UINT cb, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    if (!IsBadWritePtr(pcb, cb)) {
        memset(pcb,0,cb);
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid pointer", s_szProc, iarg);
        hres = E_POINTER;
    }
    return hres;
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadStrA_ |
 *
 *          Validate that the parameter is a valid readable
 *          ANSI string of maximum length <p cch>.
 *
 *          Note that we cannot use <f IsBadStringPtr> because
 *          <f IsBadStringPtr> handles the "string too long"
 *          case incorrectly.  Instead, we use <f lstrlenA>.
 *
 *  @parm   LPCSTR | psz |
 *
 *          String to "validate".
 *
 *  @parm   UINT | cch |
 *
 *          Maximum string length, including null terminator.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadStrA_(LPCSTR psz, UINT cch, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    UINT cchT;

    /*
     *  lstrlenA returns 0 if the parameter is invalid.
     *  It also returns 0 if the string is null.
     */
    cchT = (UINT)lstrlenA(psz);

    if (cchT == 0) {
        /*
         *  The ambiguous case.  See if it's really a null string.
         */
        if (IsBadReadPtr(psz, cbCch(1)) || psz[0]) {
            RPF("ERROR %s: arg %d: invalid ANSI string", s_szProc, iarg);
            hres = E_INVALIDARG;
        } else {
            hres = S_OK;
        }
    } else if (cchT < cch) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid ANSI string", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidReadStrW_ |
 *
 *          Validate that the parameter is a valid readable
 *          UNICODE string of maximum length <p cwch>.
 *
 *          Note that we cannot use <f IsBadStringPtr> because
 *          <f IsBadStringPtr> handles the "string too long"
 *          case incorrectly.  Instead, we use <f lstrlenW>.
 *
 *  @parm   LPCWSTR | pwsz |
 *
 *          String to "validate".
 *
 *  @parm   UINT | cwch |
 *
 *          Maximum string length, including null terminator.
 *
 *  @parm   LPCSTR | s_szProc |
 *
 *          Name of calling procedure.
 *
 *  @parm   int | iarg |
 *
 *          Parameter index.  (First parameter is 1.)
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidReadStrW_(LPCWSTR pwsz, UINT cwch, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;
    UINT cwchT;

    hres = E_INVALIDARG;
    /*
     *  lstrlenW returns 0 if the parameter is invalid.
     *  It also returns 0 if the string is null.
     */
    cwchT = (UINT)lstrlenW(pwsz);

    if (cwchT == 0) {
        /*
         *  The ambiguous case.  See if it's really a null string.
         */
        if (IsBadReadPtr(pwsz, cbCwch(1)) || pwsz[0]) {
            RPF("ERROR %s: arg %d: invalid UNICODE string", s_szProc, iarg);
            hres = E_INVALIDARG;
        } else {
            hres = S_OK;
        }
    } else if (cwchT < cwch) {
        hres = S_OK;
    } else {
        RPF("ERROR %s: arg %d: invalid UNICODE string", s_szProc, iarg);
        hres = E_INVALIDARG;
    }
    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | hresFullValidPesc_ |
 *
 *          Validate that the parameter is a valid <t DIEFFESCAPE>
 *          structure.
 *
 *          This is merely a wrapper around other validation methods.
 *
 *  @parm   LPDIEFFESCAPE | pesc |
 *
 *          Structure to "validate".
 *
 *  @returns
 *
 *          <c S_OK> if the parameter is valid.
 *
 *          <c E_INVALIDARG> if the pointer itself is bogus.
 *
 *****************************************************************************/

STDMETHODIMP
hresFullValidPesc_(LPDIEFFESCAPE pesc, LPCSTR s_szProc, int iarg)
{
    HRESULT hres;

    if (SUCCEEDED(hres = hresFullValidWriteNoScramblePxCb(pesc, DIEFFESCAPE,
                                                          iarg)) &&
        SUCCEEDED(hres = hresFullValidReadPvCb(pesc->lpvInBuffer,
                                               pesc->cbInBuffer, iarg)) &&
        SUCCEEDED(hres = hresFullValidWriteNoScramblePvCb(pesc->lpvOutBuffer,
                                                pesc->cbOutBuffer, iarg))) {
    } else {
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\dll\sources.inc ===
!IF 0

Copyright (c) 1996  Microsoft Corporation

Module Name:

    Sources.inc

    Abstract:

    Common makefile settings for DInput.

Author:

    RaymondC and a-MarcAn 1996-10-17

History:
    Date        By          Reason
    ====        ==          ======
    1996-       RaymondC    first version
    1996-10-17  a-MarcAn    tidied and adjusted for checkin to windows\media
			    disabled NTTARGETFILE0
    1996-12-06  RaymondC    Split NT and 95 versions
    1997-01-09  a-MarcAn    Set to OS version 0x403

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!ifndef DXROOT
DXROOT=$(BASEDIR)\MultiMedia\DirectX
!endif

!INCLUDE $(DXROOT)\Project.mk

# we have to be able to run w/ all versions of IE but prsht.h insists
# on IE 4.0 if you pass WIN32_WINNT_VERSION of 0x0500
WIN32_IE_VERSION=0x0400

!IFDEF TARGET_WIN95
#
# CHICAGO_PRODUCT: Suppress -DWINNT
# USE_MAPSYM: Create a .sym file
# ALT_PROJECT_TARGET: Alternate drop point (yes, they call it `chicago')
# WIN32_DEFINE: The things we #define; _WIN32_WINNT is the important one
#               because it's that one that gives us WH_*_LL.
#               We need 0x0403 to get WH_*_LL in SP3 tree
#
DLLBASE=0x70000000
CHICAGO_PRODUCT = 1
ALT_PROJECT_TARGET = WIN9x
C_DEFINES=$(C_DEFINES) -DWIN95 -D_X86_
WIN32_DEFINE = -DWIN32=100 -D_WIN32_WINDOWS=0x0400 -D_WIN32_WINNT=0x0400

! IF $(FREEBUILD)
#Win9x Free Build
#USE_NOLIBS=1
TARGETLIBS= $(SDK_LIB_PATH)\exsup.lib
#DLLENTRY=DllMain
DLLENTRY=_DllMainCRTStartup        
! ELSE
# Win9x Chk Build        
USE_LIBCMT=1
DLLENTRY=_DllMainCRTStartup

! ENDIF

! ELSE
#Win2k Build
DLLENTRY=DllMain

! IF defined( DIRECTX_REDIST )
WIN32_WINNT_VERSION=0x0500
! ENDIF

C_DEFINES=$(C_DEFINES) -DWINNT -DUNICODE

!ENDIF

USE_MAPSYM = 1

C_DEFINES=$(C_DEFINES) -DNOWINRES -DUSE_SLOW_LL_HOOKS -DHID_SUPPORT

MAJORCOMP=windows
MINORCOMP=media
UMTYPE=windows

TARGETNAME=dinput8

!IF !$(FREEBUILD) && defined( DIRECTX_REDIST )
TARGETNAME=$(TARGETNAME)d
!ENDIF

TARGETTYPE=DYNLINK
TARGETPATH=obj


INCLUDES=$(INCLUDES); \
        ..\;\
        $(DXROOT)\inc;\

CONDITIONAL_INCLUDES=\
    commctrl.rh      \
    version.h        \
    ieverp.h         \
    $(CONDITIONAL_INCLUDES)

NTTARGETFILES=

#
# 04/10/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\kernel32.lib     \
	   $(SDK_LIB_PATH)\advapi32.lib     \
	   $(SDK_LIB_PATH)\user32.lib       \
	   $(SDK_LIB_PATH)\uuid.lib         \
           $(TARGETLIBS)         

LINKER_FLAGS=$(LINKER_FLAGS) -SECTION:share,RWS

!IF !$(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDEBUG /D_DEBUG
!endif


SOURCES=\
    ..\assert.c     \
    ..\common.c     \
    ..\diaphack.c   \
    ..\dicf.c       \
    ..\didev.c      \
    ..\didevdf.c    \
    ..\didevef.c    \
    ..\diem.c       \
    ..\diemm.c      \
    ..\diemk.c      \
    ..\diemh.c      \
    ..\digenj.c     \
    ..\dical.c      \
    ..\dijoytyp.c   \
    ..\dieffj.c     \
    ..\dieffv.c     \
    ..\dieshep.c    \
    ..\digenk.c     \
    ..\digenm.c     \
    ..\digenx.c     \
    ..\digendef.c   \
    ..\dihel.c      \
    ..\dimem.c      \
    ..\dinput.c     \
    ..\diobj.c      \
    ..\dieff.c      \
    ..\didenum.c    \
    ..\dihidenm.c   \
    ..\dihidusg.c   \
    ..\dihid.c      \
    ..\dihidini.c   \
    ..\dihiddat.c   \
    ..\diguid.c     \
    ..\dijoycfg.c   \
    ..\dithunk.c    \
    ..\diaddhw.c    \
    ..\dijoyreg.c   \
    ..\direg.c      \
    ..\disubcls.c   \
    ..\diexcl.c     \
    ..\diutil.c     \
    ..\dilist.c     \
    ..\dioledup.c   \
    ..\diregutl.c   \
    ..\diextdll.c   \
    ..\valid.c      \
    ..\diwinnt.c    \
    ..\dijoyhid.c   \
    ..\diport.c     \
    ..\dinput.rc    \
    ..\guids.c      \
    ..\diriff.c     \
    ..\diraw.c      \
    ..\dilib1.c     \
    ..\dilib2.c     \
    ..\dilib3.c     \
    ..\dilib4.c     \
    ..\dilib5.c     \
    ..\dimapshp.c   \

DLLDEF=..\dinput.def

PRECOMPILED_INCLUDE=..\dinputpr.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\tdonuts\ddutil.cpp ===
//-----------------------------------------------------------------------------
// File: ddutil.cpp
//
// Desc: Routines for loading bitmap and palettes from resources
//
//
// Copyright (c) 1995-1999 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------
#define STRICT
#include <windows.h>
#include <windowsx.h>
#include <ddraw.h>
#include "ddutil.h"




//-----------------------------------------------------------------------------
// Name: DDUtil_LoadBitmap()
// Desc: Create a DirectDrawSurface from a bitmap resource.
//-----------------------------------------------------------------------------
LPDIRECTDRAWSURFACE7 DDUtil_LoadBitmap( LPDIRECTDRAW7 pDD, LPCSTR strBitmap,
									    int dx, int dy )
{
    HBITMAP              hbm;
    BITMAP               bm;
    DDSURFACEDESC2       ddsd;
    LPDIRECTDRAWSURFACE7 pdds;

    // Try to load the bitmap as a resource, if that fails, try it as a file
    hbm = (HBITMAP)LoadImage( GetModuleHandle(NULL), strBitmap, IMAGE_BITMAP,
		                      dx, dy, LR_CREATEDIBSECTION );
    if( NULL == hbm )
        hbm = (HBITMAP)LoadImage( NULL, strBitmap, IMAGE_BITMAP, dx, dy,
                                  LR_LOADFROMFILE | LR_CREATEDIBSECTION );
    if( NULL == hbm )
        return NULL;

    // Get size of the bitmap
    GetObject( hbm, sizeof(bm), &bm );

    // Create a DirectDrawSurface for this bitmap
    ZeroMemory( &ddsd, sizeof(ddsd) );
    ddsd.dwSize         = sizeof(ddsd);
    ddsd.dwFlags        = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH;
    ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN;
    ddsd.dwWidth        = bm.bmWidth;
    ddsd.dwHeight       = bm.bmHeight;
    
	if( FAILED( pDD->CreateSurface( &ddsd, &pdds, NULL ) ) )
        return NULL;

    DDUtil_CopyBitmap( pdds, hbm, 0, 0, 0, 0 );
    DeleteObject( hbm );
    return pdds;
}




//-----------------------------------------------------------------------------
// Name: DDUtil_ReLoadBitmap()
// Desc: Load a bitmap from a file or resource into a directdraw surface.
//       normaly used to re-load a surface after a restore.
//-----------------------------------------------------------------------------
HRESULT DDUtil_ReLoadBitmap( LPDIRECTDRAWSURFACE7 pdds, LPCSTR strBitmap )
{
    HBITMAP hbm;
    HRESULT hr;

    // Try to load the bitmap as a resource, if that fails, try it as a file
    hbm = (HBITMAP)LoadImage( GetModuleHandle(NULL), strBitmap, IMAGE_BITMAP,
		                      0, 0, LR_CREATEDIBSECTION );
    if( NULL == hbm )
        hbm = (HBITMAP)LoadImage( NULL, strBitmap, IMAGE_BITMAP, 0, 0,
                                  LR_LOADFROMFILE | LR_CREATEDIBSECTION );
    if( NULL == hbm )
    {
        OutputDebugString( "DDUtil_ReLoadBitmap: handle is null\n" );
        return E_FAIL;
    }

    hr = DDUtil_CopyBitmap( pdds, hbm, 0, 0, 0, 0 );
    if( FAILED( hr ) )
        OutputDebugString( "DDUtil_ReLoadBitmap: copy bitmap failed\n" );

    DeleteObject( hbm );
    return hr;
}




//-----------------------------------------------------------------------------
// Name: DDUtil_CopyBitmap()
// Desc: Draw a bitmap into a DirectDrawSurface
//-----------------------------------------------------------------------------
HRESULT DDUtil_CopyBitmap( LPDIRECTDRAWSURFACE7 pdds, HBITMAP hbm,
						   int x, int y, int dx, int dy )
{
    HDC            hdcImage;
    HDC            hdc;
    BITMAP         bm;
    DDSURFACEDESC2 ddsd;
    HRESULT        hr = E_FAIL;

    if( hbm == NULL || pdds == NULL )
        return E_FAIL;

    // Make sure this surface is restored.
    pdds->Restore();

    // Select bitmap into a memoryDC so we can use it.
    hdcImage = CreateCompatibleDC( NULL );
    if( !hdcImage )
    {
        OutputDebugString("createcompatible dc failed\n");
        SelectObject( hdcImage, hbm );
        // Get size of the bitmap
        GetObject( hbm, sizeof(bm), &bm );
        dx = ( dx == 0 ? bm.bmWidth  : dx );  // Use the passed size, unless zero
        dy = ( dy == 0 ? bm.bmHeight : dy );
    
        // Get size of surface.
        ddsd.dwSize  = sizeof(ddsd);
        ddsd.dwFlags = DDSD_HEIGHT | DDSD_WIDTH;
        pdds->GetSurfaceDesc( &ddsd );
    
        if( SUCCEEDED( hr = pdds->GetDC( &hdc ) ) )
        {
            StretchBlt( hdc, 0, 0, ddsd.dwWidth, ddsd.dwHeight, hdcImage,
    			        x, y, dx, dy, SRCCOPY );
            pdds->ReleaseDC( hdc );
        }
    
        DeleteDC( hdcImage );
    }
	return hr;
}




//-----------------------------------------------------------------------------
// Name: DDUtil_LoadPalette()
// Desc: Create a DirectDraw palette object from a bitmap resource
//       if the resource does not exist or NULL is passed create a
//       default 332 palette.
//-----------------------------------------------------------------------------
LPDIRECTDRAWPALETTE DDUtil_LoadPalette( LPDIRECTDRAW7 pDD, LPCSTR strBitmap )
{
    LPDIRECTDRAWPALETTE pPalette;
    int                 i;
    int                 n;
    int                 file;
    HRSRC               hRes;
    BITMAPINFOHEADER*   pbi;
    PALETTEENTRY        pe[256];
    RGBQUAD*            prgb;

    // Build a 332 palette as the default.
    for( i = 0; i < 256; i++ )
    {
        pe[i].peRed   = (BYTE)( ( (i>>5) & 0x07 ) * 255 / 7 );
        pe[i].peGreen = (BYTE)( ( (i>>2) & 0x07 ) * 255 / 7 );
        pe[i].peBlue  = (BYTE)( ( (i>>0) & 0x03 ) * 255 / 3 );
        pe[i].peFlags = (BYTE)0;
    }

	if( strBitmap )
	{
	    // Get a pointer to the bitmap resource.
		if( hRes = FindResource( NULL, strBitmap, RT_BITMAP ) )
		{
			pbi = (BITMAPINFOHEADER*)LockResource( LoadResource( NULL, hRes ) );
			if( NULL == pbi )
				OutputDebugString("lock resource failed\n");
			prgb = (RGBQUAD*)( (BYTE*)pbi + pbi->biSize );
			if( NULL == pbi || pbi->biSize < sizeof(BITMAPINFOHEADER) )
				n = 0;
			else if( pbi->biBitCount > 8 )
				n = 0;
			else if( pbi->biClrUsed == 0 )
				n = 1 << pbi->biBitCount;
			else
				n = pbi->biClrUsed;

			// A DIB color table has its colors stored BGR not RGB
			// so flip them around.
			for( i = 0; i < n; i++ )
			{
				pe[i].peRed   = prgb[i].rgbRed;
				pe[i].peGreen = prgb[i].rgbGreen;
				pe[i].peBlue  = prgb[i].rgbBlue;
				pe[i].peFlags = 0;
			}
		}
	    else if( ( file = _lopen( strBitmap, OF_READ ) ) != -1 )
		{
			BITMAPFILEHEADER bf;
			BITMAPINFOHEADER bi;

			_lread( file, &bf, sizeof(bf) );
			_lread( file, &bi, sizeof(bi) );
			_lread( file, pe, sizeof(pe) );
			_lclose( file );
        
			if( bi.biSize != sizeof(BITMAPINFOHEADER) )
				n = 0;
			else if( bi.biBitCount > 8 )
				n = 0;
			else if( bi.biClrUsed == 0 )
				n = 1 << bi.biBitCount;
			else
				n = bi.biClrUsed;

			//  A DIB color table has its colors stored BGR not RGB
			//  so flip them around.
			for (i = 0; i < n; i++)
			{
				BYTE r = pe[i].peRed;

				pe[i].peRed  = pe[i].peBlue;
				pe[i].peBlue = r;
			}
		}
    }

	// Return the newly created palette
    if( FAILED( pDD->CreatePalette( DDPCAPS_8BIT, pe, &pPalette, NULL ) ) )
		return NULL;
	return pPalette;
}




//-----------------------------------------------------------------------------
// Name: DDUtil_ColorMatch()
// Desc: Convert a RGB color to a pysical color.
//       We do this by leting GDI SetPixel() do the color matching
//       then we lock the memory and see what it got mapped to.
//-----------------------------------------------------------------------------
DWORD DDUtil_ColorMatch( LPDIRECTDRAWSURFACE7 pdds, COLORREF rgb )
{
    COLORREF       rgbT = CLR_INVALID;
    HDC            hdc;
    DWORD          dw = CLR_INVALID;
    DDSURFACEDESC2 ddsd;
    HRESULT        hr;

    //  Use GDI SetPixel to color match for us
    if( rgb != CLR_INVALID && SUCCEEDED( pdds->GetDC( &hdc ) ) )
    {
        rgbT = GetPixel( hdc, 0, 0 );     // Save current pixel value
        SetPixel( hdc, 0, 0, rgb );       // Set our value
        pdds->ReleaseDC( hdc );
    }

    // Now lock the surface so we can read back the converted color
    ddsd.dwSize = sizeof(ddsd);
    while( ( hr = pdds->Lock( NULL, &ddsd, 0, NULL ) ) == DDERR_WASSTILLDRAWING )
	{
		// Wait for surface to be free
	}
    if( SUCCEEDED( hr ) )
    {
        dw = *(DWORD *)ddsd.lpSurface;                 // Get DWORD
        if( ddsd.ddpfPixelFormat.dwRGBBitCount < 32 )
            dw &= (1 << ddsd.ddpfPixelFormat.dwRGBBitCount) - 1;  // Mask it to bpp
        pdds->Unlock( NULL );
    }

    // Now put the color that was there back.
    if( rgbT != CLR_INVALID && rgb != CLR_INVALID && SUCCEEDED( pdds->GetDC(&hdc) ) )
    {
        SetPixel( hdc, 0, 0, rgbT );
        pdds->ReleaseDC( hdc );
    }

    return dw;
}




//-----------------------------------------------------------------------------
// Name: DDUtil_SetColorKey()
// Desc: Set a color key for a surface, given a RGB.
//       If you pass CLR_INVALID as the color key, the pixel
//       in the upper-left corner will be used.
//-----------------------------------------------------------------------------
HRESULT DDUtil_SetColorKey( LPDIRECTDRAWSURFACE7 pdds, COLORREF rgb )
{
    DDCOLORKEY ddck;
    ddck.dwColorSpaceLowValue  = DDUtil_ColorMatch( pdds, rgb );
    ddck.dwColorSpaceHighValue = ddck.dwColorSpaceLowValue;
    
	return pdds->SetColorKey( DDCKEY_SRCBLT, &ddck );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\directx\dinput\dx8\tdonuts\diutil.cpp ===
//-----------------------------------------------------------------------------
// File: diutil.cpp
//
// Desc: DirectInput support
//
// Copyright (C) 1995-1999 Microsoft Corporation. All Rights Reserved.
//-----------------------------------------------------------------------------
#define STRICT
#incl