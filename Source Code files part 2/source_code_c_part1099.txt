   acccording to whether it was preempted or not.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

Return Value:

    None.

--*/

{
    PKPRCB Prcb;
    PKPRCB TargetPrcb;
    BOOLEAN Preempted;
    KPRIORITY Priority;
    PKPROCESS Process;
    ULONG Processor;
    KPRIORITY ThreadPriority;
    PKTHREAD Thread1;
    KAFFINITY IdleSet;
    KAFFINITY Affinity;
    KAFFINITY FavoredSMTSet;


    //
    // Save value of thread's preempted flag, set thread preempted FALSE,
    // capture the thread priority, and set clear the read wait time.
    //

    Preempted = Thread->Preempted;
    Thread->Preempted = FALSE;
    ThreadPriority = Thread->Priority;
    Thread->WaitTime = KiQueryLowTickCount();

    //
    // If the thread's process is not in memory, then insert the thread in
    // the process ready queue and inswap the process.
    //

    Process = Thread->ApcState.Process;
    if (Process->State != ProcessInMemory) {
        Thread->State = Ready;
        Thread->ProcessReadyQueue = TRUE;
        InsertTailList(&Process->ReadyListHead, &Thread->WaitListEntry);
        if (Process->State == ProcessOutOfMemory) {
            Process->State = ProcessInTransition;
            InterlockedPushEntrySingleList(&KiProcessInSwapListHead,
                                           &Process->SwapListEntry);

            KiSetSwapEvent();
        }

        return;

    } else if (Thread->KernelStackResident == FALSE) {

        //
        // The thread's kernel stack is not resident. Increment the process
        // stack count, set the state of the thread to transition, insert
        // the thread in the kernel stack inswap list, and set the kernel
        // stack inswap event.
        //

        Process->StackCount += 1;
        Thread->State = Transition;
        InterlockedPushEntrySingleList(&KiStackInSwapListHead,
                                       &Thread->SwapListEntry);

        KiSetSwapEvent();
        return;

    } else {

        //
        // Assume we will succeed in scheduling this thread.
        //

        Thread->State = Standby;

        //
        // If there is an idle processor, then schedule the thread on an
        // idle processor giving preference to:
        //
        // (a) the thread's ideal processor,
        //
        // (b) if the thread has a soft (preferred affinity set) and
        //     that set contains an idle processor, reduce the set to
        //     the intersection of the two sets.
        //
        // (c) if the processors are Simultaneous Multi Threaded, and the
        //     set contains physical processors with no busy logical
        //     processors, reduce the set to that subset.
        //
        // (d) if this thread last ran on a member of this remaining set,
        //     select that processor, otherwise,
        //
        // (e) if there are processors amongst the remainder which are
        //     not sleeping, reduce to that subset.
        //
        // (f) select the leftmost processor from this set.
        //

#if defined(NT_UP)

        Prcb = KiProcessorBlock[0];
        if (KiIdleSummary != 0) {
            KiIdleSummary = 0;
            KiIncrementSwitchCounter(IdleLast);
            Prcb->NextThread = Thread;
            return;
        }

#else

        Processor = Thread->IdealProcessor;

#if defined(NT_SMT)

        FavoredSMTSet = KiProcessorBlock[Processor]->MultiThreadProcessorSet;

#endif

        Affinity = Thread->Affinity;

        if (Affinity & Thread->SoftAffinity) {
            Affinity &= Thread->SoftAffinity;
        }

        IdleSet = KiIdleSummary & Affinity;

        if (IdleSet != 0) {
            Prcb = KeGetCurrentPrcb();
            if ((IdleSet & AFFINITY_MASK(Processor)) == 0) {

                //
                // Ideal processor is not available.
                //
                // Next highest priority to a physical processor in
                // which all logical processors are idle.
                //

#if defined(NT_SMT)

                if (IdleSet & KiIdleSMTSummary) {
                    IdleSet &= KiIdleSMTSummary;
                }

#endif

                //
                // Try processor this thread last ran on.
                //

                Processor = Thread->NextProcessor;
                if ((IdleSet & AFFINITY_MASK(Processor)) == 0) {
                    if ((IdleSet & Prcb->SetMember) == 0) {

                        //
                        // Select from idle processors.
                        //

                        //
                        // Try ANY logical processor in the same
                        // physical processor as the Ideal Processor.
                        //

#if defined(NT_SMT)

                        if (IdleSet & FavoredSMTSet) {
                            IdleSet &= FavoredSMTSet;
                        } else {

                            //
                            // No logical processor in the ideal set, try
                            // same set as thread last ran in.
                            //

                            FavoredSMTSet = KiProcessorBlock[Processor]->MultiThreadProcessorSet;
                            if (IdleSet & FavoredSMTSet) {
                                IdleSet &= FavoredSMTSet;
                            }
                        }

#endif

                        if ((IdleSet & ~PoSleepingSummary) != 0) {

                            //
                            // Choose an idle processor which is
                            // not sleeping.
                            //

                            IdleSet &= ~PoSleepingSummary;
                        }

                        KeFindFirstSetLeftAffinity(IdleSet, &Processor);
                        KiIncrementSwitchCounter(IdleAny);

                    } else {
                        Processor = Prcb->Number;
                        KiIncrementSwitchCounter(IdleCurrent);
                    }

                } else {
                    KiIncrementSwitchCounter(IdleLast);
                }

            } else {
                KiIncrementSwitchCounter(IdleIdeal);
            }

            TargetPrcb = KiProcessorBlock[Processor];
            Thread->NextProcessor = (CCHAR)Processor;
            ClearMember(Processor, KiIdleSummary);
            TargetPrcb->NextThread = Thread;

            //
            // Update the idle set summary (SMT) to indicate this
            // physical processor is not all idle.
            //

#if defined(NT_SMT)

            KiIdleSMTSummary &= ~TargetPrcb->MultiThreadProcessorSet;
            TargetPrcb->MultiThreadSetMaster->MultiThreadSetBusy = TRUE;

#endif

            if ((PoSleepingSummary & AFFINITY_MASK(Processor)) &&
                (Processor != (ULONG)Prcb->Number)) {
                KiIpiSend(AFFINITY_MASK(Processor), IPI_DPC);
            }

            return;
        }

#endif

        //
        // No idle processors, try to preempt a thread in either the
        // standby or running state.
        //

#if !defined(NT_UP)

        if ((Affinity & AFFINITY_MASK(Processor)) == 0) {

            //
            // Check if thread can run in the same place it
            // ran last time.
            //

            Processor = Thread->NextProcessor;
            if ((Affinity & AFFINITY_MASK(Processor)) == 0) {

                //
                // Select leftmost processor from the available
                // set.
                //

                KeFindFirstSetLeftAffinity(Affinity, &Processor);
            }
        }

        Thread->NextProcessor = (CCHAR)Processor;
        Prcb = KiProcessorBlock[Processor];

#endif

        Thread1 = Prcb->NextThread;
        if (Thread1 != NULL) {
            if (ThreadPriority > Thread1->Priority) {

                PKSPIN_LOCK_QUEUE ContextSwap;

                //
                // Preempt the thread scheduled to run on the selected
                // processor.
                //

                Thread1->Preempted = TRUE;

                //
                // The thread could migrate from Standby to Running under the
                // context swap lock.
                //

#if !defined(NT_UP)

                ContextSwap = &(KeGetCurrentPrcb()->LockQueue[LockQueueContextSwapLock]);
                KeAcquireQueuedSpinLockAtDpcLevel(ContextSwap);
                if (Prcb->NextThread != NULL) {

                    //
                    // The thread is still in Standby state, substitute the
                    // new selected thread.
                    //

                    Prcb->NextThread = Thread;
                    KeReleaseQueuedSpinLockFromDpcLevel(ContextSwap);
                    KiReadyThread(Thread1);
                    KiIncrementSwitchCounter(PreemptLast);
                    return;

                } else {

                    //
                    // The thread has migrated to the running state.
                    //

                    KeReleaseQueuedSpinLockFromDpcLevel(ContextSwap);
                    Prcb->NextThread = Thread;
                    KiRequestDispatchInterrupt(Thread->NextProcessor);
                    KiIncrementSwitchCounter(PreemptLast);
                    return;
                }

#else

                Prcb->NextThread = Thread;
                KiReadyThread(Thread1);
                KiIncrementSwitchCounter(PreemptLast);
                return;

#endif

            }

        } else {
            Thread1 = Prcb->CurrentThread;
            if (ThreadPriority > Thread1->Priority) {
                Thread1->Preempted = TRUE;
                Prcb->NextThread = Thread;
                KiRequestDispatchInterrupt(Thread->NextProcessor);
                KiIncrementSwitchCounter(PreemptLast);
                return;
            }
        }
    }

    //
    // No thread can be preempted. Insert the thread in the dispatcher
    // queue selected by its priority. If the thread was preempted and
    // runs at a realtime priority level, then insert the thread at the
    // front of the queue. Else insert the thread at the tail of the queue.
    //

    Thread->State = Ready;
    if (Preempted != FALSE) {
        InsertHeadList(&KiDispatcherReadyListHead[ThreadPriority],
                       &Thread->WaitListEntry);

    } else {
        InsertTailList(&KiDispatcherReadyListHead[ThreadPriority],
                       &Thread->WaitListEntry);
    }

    SetMember(ThreadPriority, KiReadySummary);
    return;
}

PKTHREAD
FASTCALL
KiSelectNextThread (
    IN ULONG Processor
    )

/*++

Routine Description:

    This function selects the next thread to run on the specified processor.

Arguments:

    Processor - Supplies the processor number.

Return Value:

    The address of the selected thread object.

--*/

{

    PKPRCB Prcb;
    PKTHREAD Thread;

    //
    // Attempt to find a ready thread to run.
    //
    // If a thread was not found, then select the idle thread and
    // set the processor member in the idle summary.
    //

    if ((Thread = KiFindReadyThread(Processor, 0)) == NULL) {
        Prcb = KiProcessorBlock[Processor];
        KiIncrementSwitchCounter(SwitchToIdle);
        Thread = Prcb->IdleThread;
        KiIdleSummary |= AFFINITY_MASK(Processor);

        //
        // If all logical processors of the physical processor are idle,
        // then update the idle SMT set summary.
        //

#if defined(NT_SMT)

        if ((KiIdleSummary & Prcb->MultiThreadProcessorSet) ==
                        Prcb->MultiThreadProcessorSet) {

            KiIdleSMTSummary |= Prcb->MultiThreadProcessorSet;
            Prcb->MultiThreadSetMaster->MultiThreadSetBusy = FALSE;
        }

#endif

    }

    //
    // Return address of selected thread object.
    //

    return Thread;
}

KAFFINITY
FASTCALL
KiSetAffinityThread (
    IN PKTHREAD Thread,
    IN KAFFINITY Affinity
    )

/*++

Routine Description:

    This function sets the affinity of a specified thread to a new value.
    If the new affinity is not a proper subset of the parent process affinity
    or is null, then a bugcheck occurs. If the specified thread is running on
    or about to run on a processor for which it is no longer able to run, then
    the target processor is rescheduled. If the specified thread is in a ready
    state and is not in the parent process ready queue, then it is rereadied
    to reevaluate any additional processors it may run on.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Affinity - Supplies the new of set of processors on which the thread
        can run.

Return Value:

    The previous affinity of the specified thread is returned as the function
    value.

--*/

{

    KAFFINITY OldAffinity;
    PKPRCB Prcb;
    PKPROCESS Process;
    ULONG Processor;
    KPRIORITY ThreadPriority;
    PKTHREAD Thread1;

    //
    // Capture the current affinity of the specified thread and get address
    // of parent process object.
    //

    OldAffinity = Thread->UserAffinity;
    Process = Thread->ApcStatePointer[0]->Process;

    //
    // If new affinity is not a proper subset of the parent process affinity
    // or the new affinity is null, then bugcheck.
    //

    if (((Affinity & Process->Affinity) != (Affinity)) || (!Affinity)) {
        KeBugCheck(INVALID_AFFINITY_SET);
    }

    //
    // Set the thread user affinity to the specified value.
    //
    // If the thread is not current executing with system affinity active,
    // then set the thread current affinity and switch on the thread state.
    //

    Thread->UserAffinity = Affinity;
    if (Thread->SystemAffinityActive == FALSE) {
        Thread->Affinity = Affinity;
        switch (Thread->State) {

            //
            // Ready State.
            //
            // If the thread is not in the process ready queue, then remove
            // it from its current dispatcher ready queue and reready it for
            // execution.
            //

        case Ready:
            if (Thread->ProcessReadyQueue == FALSE) {
                RemoveEntryList(&Thread->WaitListEntry);
                ThreadPriority = Thread->Priority;
                if (IsListEmpty(&KiDispatcherReadyListHead[ThreadPriority]) != FALSE) {
                    ClearMember(ThreadPriority, KiReadySummary);
                }

                KiReadyThread(Thread);
            }

            break;

            //
            // Standby State.
            //
            // If the target processor is not in the new affinity set, then
            // set the next thread to null for the target processor, select
            // a new thread to run on the target processor, and reready the
            // thread for execution.
            //
            // It is possible for a thread to transition from Standby to
            // Running even though the dispatcher lock is held by this
            // processor.   The context swap lock must be taken to ensure
            // correct behavior (in this rare case).
            //

        case Standby:
            Processor = Thread->NextProcessor;
            Prcb = KiProcessorBlock[Processor];
            if ((Prcb->SetMember & Affinity) == 0) {
                Thread1 = KiSelectNextThread(Processor);
                Thread1->State = Standby;
                KeAcquireQueuedSpinLockAtDpcLevel(
                    &KeGetCurrentPrcb()->LockQueue[LockQueueContextSwapLock]);
                if (Prcb->NextThread != NULL) {

                    //
                    // The thread is still in Standby state, substitute
                    // the new selected thread.
                    //

                    Prcb->NextThread = Thread1;
                    KeReleaseQueuedSpinLockFromDpcLevel(
                        &KeGetCurrentPrcb()->LockQueue[LockQueueContextSwapLock]);
                    KiReadyThread(Thread);
                } else {

                    //
                    // The thread has become ready.
                    //

                    KeReleaseQueuedSpinLockFromDpcLevel(
                        &KeGetCurrentPrcb()->LockQueue[LockQueueContextSwapLock]);
                    Prcb->NextThread = Thread1;
                    KiRequestDispatchInterrupt(Processor);
                }
            }

            break;

            //
            // Running State.
            //
            // If the target processor is not in the new affinity set and
            // another thread has not already been selected for execution
            // on the target processor, then select a new thread for the
            // target processor, and cause the target processor to be
            // redispatched.
            //

        case Running:
            Processor = Thread->NextProcessor;
            Prcb = KiProcessorBlock[Processor];

            //
            // It is possible the thread is just switching from
            // Standby to Running on an idle processor which is
            // not holding the dispatcher lock.
            //

            if (((Prcb->SetMember & Affinity) == 0) &&
                ((Prcb->NextThread == NULL) || (Prcb->NextThread == Thread))) {
                Thread1 = KiSelectNextThread(Processor);
                Thread1->State = Standby;
                Prcb->NextThread = Thread1;
                KiRequestDispatchInterrupt(Processor);
            }

            break;

            //
            // Initialized, Terminated, Waiting, Transition case - For these
            // states it is sufficient to just set the new thread affinity.
            //

        default:
            break;
        }
    }

    //
    // Return the previous user affinity.
    //

    return OldAffinity;
}

VOID
FASTCALL
KiSetPriorityThread (
    IN PKTHREAD Thread,
    IN KPRIORITY Priority
    )

/*++

Routine Description:

    This function set the priority of the specified thread to the specified
    value. If the thread is in the standby or running state, then the processor
    may be redispatched. If the thread is in the ready state, then some other
    thread may be preempted.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    Priority - Supplies the new thread priority value.

Return Value:

    None.

--*/

{

    PKPRCB Prcb;
    ULONG Processor;
    KPRIORITY ThreadPriority;
    PKTHREAD Thread1;

    ASSERT(Priority <= HIGH_PRIORITY);

    //
    // Capture the current priority of the specified thread.
    //

    ThreadPriority = Thread->Priority;

    //
    // If the new priority is not equal to the old priority, then set the
    // new priority of the thread and redispatch a processor if necessary.
    //

    if (Priority != ThreadPriority) {
        Thread->Priority = (SCHAR)Priority;

        //
        // Case on the thread state.
        //

        switch (Thread->State) {

            //
            // Ready case - If the thread is not in the process ready queue,
            // then remove it from its current dispatcher ready queue. If the
            // new priority is less than the old priority, then insert the
            // thread at the tail of the dispatcher ready queue selected by
            // the new priority. Else reready the thread for execution.
            //

        case Ready:
            if (Thread->ProcessReadyQueue == FALSE) {
                RemoveEntryList(&Thread->WaitListEntry);
                if (IsListEmpty(&KiDispatcherReadyListHead[ThreadPriority])) {
                    ClearMember(ThreadPriority, KiReadySummary);
                }

                if (Priority < ThreadPriority) {
                    InsertTailList(&KiDispatcherReadyListHead[Priority],
                                   &Thread->WaitListEntry);

                    SetMember(Priority, KiReadySummary);

                } else {
                    KiReadyThread(Thread);
                }
            }

            break;

            //
            // Standby case - If the thread's priority is being lowered, then
            // attempt to find another thread to execute. If a new thread is
            // found, then put the new thread in the standby state, and reready
            // the old thread.
            //

        case Standby:

            if (Priority < ThreadPriority) {

#if defined(NT_UP)

                Thread1 = KiFindReadyThread(0, Priority + 1);
                if (Thread1 != NULL) {
                    Prcb = KiProcessorBlock[0];
                    Thread1->State = Standby;
                    Prcb->NextThread = Thread1;
                    KiReadyThread(Thread);
                }

#else

                Processor = Thread->NextProcessor;
                Thread1 = KiFindReadyThread(Processor, Priority + 1);
                if (Thread1 != NULL) {
                    Prcb = KiProcessorBlock[Processor];
                    Thread1->State = Standby;
                    KeAcquireQueuedSpinLockAtDpcLevel(
                        &KeGetCurrentPrcb()->LockQueue[LockQueueContextSwapLock]);

                    if (Prcb->NextThread != NULL) {

                        //
                        // The thread is still in Standby state, substitute
                        // the new selected thread.
                        //

                        Prcb->NextThread = Thread1;
                        KeReleaseQueuedSpinLockFromDpcLevel(
                            &KeGetCurrentPrcb()->LockQueue[LockQueueContextSwapLock]);

                        KiReadyThread(Thread);

                    } else {

                        //
                        // The thread has transitioned from Standby
                        // to running, treat as if running.
                        //

                        KeReleaseQueuedSpinLockFromDpcLevel(
                            &KeGetCurrentPrcb()->LockQueue[LockQueueContextSwapLock]);

                        Prcb->NextThread = Thread1;
                        KiRequestDispatchInterrupt(Processor);
                    }
                }

#endif

            }

            break;

            //
            // Running case - If there is not a thread in the standby state
            // on the thread's processor and the thread's priority is being
            // lowered, then attempt to find another thread to execute. If
            // a new thread is found, then put the new thread in the standby
            // state, and request a redispatch on the thread's processor.
            //

        case Running:

            if (Priority < ThreadPriority) {

#if defined(NT_UP)

                Prcb = KiProcessorBlock[0];
                if (Prcb->NextThread == NULL) {
                    Thread1 = KiFindReadyThread(0, Priority + 1);
                    if (Thread1 != NULL) {
                        Thread1->State = Standby;
                        Prcb->NextThread = Thread1;
                    }
                }

#else

                Processor = Thread->NextProcessor;
                Prcb = KiProcessorBlock[Processor];

                //
                // It is possible the thread is just switching from
                // Standby to Running on an idle processor which has
                // not yet cleared the NextThread field.
                //

                if ((Prcb->NextThread == NULL) ||
                    (Prcb->NextThread == Thread)) {
                    Thread1 = KiFindReadyThread(Processor, Priority + 1);
                    if (Thread1 != NULL) {
                        Thread1->State = Standby;
                        Prcb->NextThread = Thread1;
                        KiRequestDispatchInterrupt(Processor);
                    }
                }
#endif

            }

            break;

            //
            // Initialized, Terminated, Waiting, Transition case - For
            // these states it is sufficient to just set the new thread
            // priority.
            //

        default:
            break;
        }
    }

    return;
}

VOID
KiSuspendThread (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is the kernel routine for the builtin suspend APC of a
    thread. It is executed as the result of queuing the builtin suspend
    APC and suspends thread execution by waiting nonalerable on the thread's
    builtin suspend semaphore. When the thread is resumed, execution of
    thread is continued by simply returning.

Arguments:

    NormalContext - Not used.

    SystemArgument1 - Not used.

    SystemArgument2 - Not used.

Return Value:

    None.

--*/

{

    PKTHREAD Thread;

    //
    // Get the address of the current thread object and Wait nonalertable on
    // the thread's builtin suspend semaphore.
    //

    Thread = KeGetCurrentThread();
    KeWaitForSingleObject(&Thread->SuspendSemaphore,
                          Suspended,
                          KernelMode,
                          FALSE,
                          NULL);

    return;
}

LONG_PTR
FASTCALL
KiSwapThread (
    VOID
    )

/*++

Routine Description:

    This function selects the next thread to run on the current processor
    and swaps thread context to the selected thread. When the execution
    of the current thread is resumed, the IRQL is lowered to its previous
    value and the wait status is returned as the function value.

    N.B. This function is only called by the wait functions. On entry to this
         routine the dispatcher lock is held. On exit from this routine the
         dispatcher lock is not held and the IRQL is lowered to its value at
         the start of the wait operation.

Arguments:

    None.

Return Value:

    The wait completion status is returned as the function value.

--*/

{

    PKTHREAD NewThread;
    CCHAR Number;
    PKTHREAD OldThread;
    BOOLEAN Pending;
    PKPRCB Prcb;
    KIRQL WaitIrql;
    LONG_PTR WaitStatus;

    //
    // If a thread has already been selected to run on the current processor,
    // then select that thread.
    //

    Prcb = KeGetCurrentPrcb();
    OldThread = Prcb->CurrentThread;
    if ((NewThread = Prcb->NextThread) != NULL) {
        Prcb->NextThread = NULL;

    } else {

        //
        // Attempt to find a ready thread to run.
        //
        // If a thread was not found, then select the idle thread and set the
        // processor member in the idle summary.
        //

        Number = Prcb->Number;
        if ((NewThread = KiFindReadyThread(Number, 0)) == NULL) {
            KiIncrementSwitchCounter(SwitchToIdle);
            NewThread = Prcb->IdleThread;
            KiIdleSummary |= AFFINITY_MASK(Number);

            //
            // If all logical processors of the physical processor are idle,
            // then update the idle SMT set summary.
            //

#if defined(NT_SMT)

            if ((KiIdleSummary & Prcb->MultiThreadProcessorSet) ==
                            Prcb->MultiThreadProcessorSet) {
                KiIdleSMTSummary |= Prcb->MultiThreadProcessorSet;
                Prcb->MultiThreadSetMaster->MultiThreadSetBusy = FALSE;
            }

#endif

        }
    }

    //
    // Swap context to the new thread.
    //
    // If a kernel APC should be delivered on return from the context swap,
    // then deliver the kernel APC.
    //

    Pending = KiSwapContext(NewThread);
    WaitIrql = OldThread->WaitIrql;
    WaitStatus = OldThread->WaitStatus;
    if (Pending != FALSE) {
        KeLowerIrql(APC_LEVEL);
        KiDeliverApc(KernelMode, NULL, NULL);
        WaitIrql = 0;
    }

    //
    // Lower IRQL to its level before the wait operation and return the wait
    // status.
    //

    KeLowerIrql(WaitIrql);
    return WaitStatus;
}

UCHAR
KeFindNextRightSetAffinity (
    ULONG Number,
    KAFFINITY Set
    )

/*++

Routine Description:

    This function locates the left most set bit in the set immediately to
    the right of the specified bit. If no bits are set to the right of the
    specified bit, then the left most set bit in the complete set is located.

    N.B. Set must contain at least one bit.

Arguments:

    Number - Supplies the bit number from which the search to to begin.

    Set - Supplies the bit mask to search.

Return Value:

    The number of the found set bit is returned as the function value.

--*/

{

    KAFFINITY NewSet;
    ULONG Temp;

    ASSERT(Set != 0);

    //
    // Get a mask with all bits to the right of bit "Number" set.
    //

    NewSet = (AFFINITY_MASK(Number) - 1) & Set;

    //
    // If no bits are set to the right of the specified bit number, then use
    // the complete set.
    //

    if (NewSet == 0) {
        NewSet = Set;
    }

    //
    // Find leftmost bit in this set.
    //

    KeFindFirstSetLeftAffinity(NewSet, &Temp);
    return (UCHAR)Temp;
}

#if 0
VOID
KiVerifyReadySummary (
    VOID
    )

/*++

Routine Description:

    This function verifies the correctness of ready summary.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Summary;
    PKTHREAD Thread;

    extern ULONG InitializationPhase;

    //
    // If initilization has been completed, then check the ready summary
    //

    if (InitializationPhase == 2) {

        //
        // Scan the ready queues and compute the ready summary.
        //

        Summary = 0;
        for (Index = 0; Index < MAXIMUM_PRIORITY; Index += 1) {
            if (IsListEmpty(&KiDispatcherReadyListHead[Index]) == FALSE) {
                Summary |= (1 << Index);
            }
        }

        //
        // If the computed summary does not agree with the current ready
        // summary, then break into the debugger.
        //

        if (Summary != KiReadySummary) {
            DbgBreakPoint();
        }

        //
        // If the priority of the current thread or the next thread is
        // not greater than or equal to all ready threads, then break
        // into the debugger.
        //

        Thread = KeGetCurrentPrcb()->NextThread;
        if (Thread == NULL) {
            Thread = KeGetCurrentPrcb()->CurrentThread;
        }

        if ((1 << Thread->Priority) < (Summary & ((1 << Thread->Priority) - 1))) {
            DbgBreakPoint();
        }
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\semphobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    semphobj.c

Abstract:

    This module implements the kernel semaphore object. Functions
    are provided to initialize, read, and release semaphore objects.

Author:

    David N. Cutler (davec) 28-Feb-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macro is used to check that an input semaphore is
// really a ksemaphore and not something else, like deallocated pool.
//

#define ASSERT_SEMAPHORE(E) {                    \
    ASSERT((E)->Header.Type == SemaphoreObject); \
}


VOID
KeInitializeSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN LONG Count,
    IN LONG Limit
    )

/*++

Routine Description:

    This function initializes a kernel semaphore object. The initial
    count and limit of the object are set to the specified values.

Arguments:

    Semaphore - Supplies a pointer to a dispatcher object of type
        semaphore.

    Count - Supplies the initial count value to be assigned to the
        semaphore.

    Limit - Supplies the maximum count value that the semaphore
        can attain.

Return Value:

    None.

--*/

{

    //
    // Initialize standard dispatcher object header and set initial
    // count and maximum count values.
    //

    Semaphore->Header.Type = SemaphoreObject;
    Semaphore->Header.Size = sizeof(KSEMAPHORE) / sizeof(LONG);
    Semaphore->Header.SignalState = Count;
    InitializeListHead(&Semaphore->Header.WaitListHead);
    Semaphore->Limit = Limit;
    return;
}

LONG
KeReadStateSemaphore (
    IN PRKSEMAPHORE Semaphore
    )

/*++

Routine Description:

    This function reads the current signal state of a semaphore object.

Arguments:

    Semaphore - Supplies a pointer to a dispatcher object of type
        semaphore.

Return Value:

    The current signal state of the semaphore object.

--*/

{

    ASSERT_SEMAPHORE( Semaphore );

    //
    // Return current signal state of semaphore object.
    //

    return Semaphore->Header.SignalState;
}

LONG
KeReleaseSemaphore (
    IN PRKSEMAPHORE Semaphore,
    IN KPRIORITY Increment,
    IN LONG Adjustment,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This function releases a semaphore by adding the specified adjustment
    value to the current semaphore count and attempts to satisfy as many
    Waits as possible. The previous signal state of the semaphore object
    is returned as the function value.

Arguments:

    Semaphore - Supplies a pointer to a dispatcher object of type
        semaphore.

    Increment - Supplies the priority increment that is to be applied
        if releasing the semaphore causes a Wait to be satisfied.

    Adjustment - Supplies value that is to be added to the current
        semaphore count.

    Wait - Supplies a boolean value that signifies whether the call to
        KeReleaseSemaphore will be immediately followed by a call to one
        of the kernel Wait functions.

Return Value:

    The previous signal state of the semaphore object.

--*/

{

    LONG NewState;
    KIRQL OldIrql;
    LONG OldState;
    PRKTHREAD Thread;

    ASSERT_SEMAPHORE( Semaphore );
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the current signal state of the semaphore object and
    // compute the new count value.
    //

    OldState = Semaphore->Header.SignalState;
    NewState = OldState + Adjustment;

    //
    // If the new state value is greater than the limit or a carry occurs,
    // then unlock the dispatcher database, and raise an exception.
    //

    if ((NewState > Semaphore->Limit) || (NewState < OldState)) {
        KiUnlockDispatcherDatabase(OldIrql);
        ExRaiseStatus(STATUS_SEMAPHORE_LIMIT_EXCEEDED);
    }

    //
    // Set the new signal state of the semaphore object and set the wait
    // next value. If the previous signal state was Not-Signaled (i.e.
    // the count was zero), and the wait queue is not empty, then attempt
    // to satisfy as many Waits as possible.
    //

    Semaphore->Header.SignalState = NewState;
    if ((OldState == 0) && (IsListEmpty(&Semaphore->Header.WaitListHead) == FALSE)) {
        KiWaitTest(Semaphore, Increment);
    }

    //
    // If the value of the Wait argument is TRUE, then return to the
    // caller with IRQL raised and the dispatcher database locked. Else
    // release the dispatcher database lock and lower IRQL to its
    // previous value.
    //

    if (Wait != FALSE) {
        Thread = KeGetCurrentThread();
        Thread->WaitNext = Wait;
        Thread->WaitIrql = OldIrql;

    } else {
        KiUnlockDispatcherDatabase(OldIrql);
    }

    //
    // Return previous signal state of sempahore object.
    //

    return OldState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\timersup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    timersup.c

Abstract:

    This module contains the support routines for the timer object. It
    contains functions to insert and remove from the timer queue.

Author:

    David N. Cutler (davec) 13-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Define forward referenced function prototypes.
//

LOGICAL
FASTCALL
KiInsertTimerTable (
    LARGE_INTEGER Interval,
    LARGE_INTEGER CurrentTime,
    IN PKTIMER Timer
    );

LOGICAL
FASTCALL
KiInsertTreeTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER Interval
    )

/*++

Routine Description:

    This function inserts a timer object in the timer queue.

    N.B. This routine assumes that the dispatcher data lock has been acquired.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    Interval - Supplies the absolute or relative time at which the time
        is to expire.

Return Value:

    If the timer is inserted in the timer tree, than a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER TimeDifference;

    //
    // Clear the signal state of timer if the timer period is zero and set
    // the inserted state to TRUE.
    //

    Timer->Header.Inserted = TRUE;
    Timer->Header.Absolute = FALSE;
    if (Timer->Period == 0) {
        Timer->Header.SignalState = FALSE;
    }

    //
    // If the specified interval is not a relative time (i.e., is an absolute
    // time), then convert it to relative time.
    //

    if (Interval.HighPart >= 0) {
        KiQuerySystemTime(&SystemTime);
        TimeDifference.QuadPart = SystemTime.QuadPart - Interval.QuadPart;

        //
        // If the resultant relative time is greater than or equal to zero,
        // then the timer has already expired.
        //

        if (TimeDifference.HighPart >= 0) {
            Timer->Header.SignalState = TRUE;
            Timer->Header.Inserted = FALSE;
            return FALSE;
        }

        Interval = TimeDifference;
        Timer->Header.Absolute = TRUE;
    }

    //
    // Get the current interrupt time, insert the timer in the timer table,
    // and return the inserted state.
    //

    KiQueryInterruptTime(&CurrentTime);
    return KiInsertTimerTable(Interval, CurrentTime, Timer);
}

LOGICAL
FASTCALL
KiReinsertTreeTimer (
    IN PKTIMER Timer,
    IN ULARGE_INTEGER DueTime
    )

/*++

Routine Description:

    This function reinserts a timer object in the timer queue.

    N.B. This routine assumes that the dispatcher data lock has been acquired.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    DueTime - Supplies the absolute time the timer is to expire.

Return Value:

    If the timer is inserted in the timer tree, than a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER Interval;

    //
    // Clear the signal state of timer if the timer period is zero and set
    // the inserted state to TRUE.
    //

    Timer->Header.Inserted = TRUE;
    if (Timer->Period == 0) {
        Timer->Header.SignalState = FALSE;
    }

    //
    // Compute the interval between the current time and the due time.
    // If the resultant relative time is greater than or equal to zero,
    // then the timer has already expired.
    //

    KiQueryInterruptTime(&CurrentTime);
    Interval.QuadPart = CurrentTime.QuadPart - DueTime.QuadPart;
    if (Interval.QuadPart >= 0) {
        Timer->Header.SignalState = TRUE;
        Timer->Header.Inserted = FALSE;
        return FALSE;
    }

    //
    // Insert the timer in the timer table and return the inserted state.
    //

    return KiInsertTimerTable(Interval, CurrentTime, Timer);
}

LOGICAL
FASTCALL
KiInsertTimerTable (
    LARGE_INTEGER Interval,
    LARGE_INTEGER CurrentTime,
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function inserts a timer object in the timer table.

    N.B. This routine assumes that the dispatcher data lock has been acquired.

Arguments:

    Interval - Supplies the relative timer before the timer is to expire.

    CurrentTime - supplies the current interrupt time.

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    If the timer is inserted in the timer tree, than a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    PKTIMER NextTimer;
    ULONG SearchCount;

    //
    // Compute the timer table index and set the timer expiration time.
    //

    Index = KiComputeTimerTableIndex(Interval, CurrentTime, Timer);

    //
    // If the timer is due before the first entry in the computed list
    // or the computed list is empty, then insert the timer at the front
    // of the list and check if the timer has already expired. Otherwise,
    // insert then timer in the sorted order of the list searching from
    // the back of the list forward.
    //
    // N.B. The sequence of operations below is critical to avoid the race
    //      condition that exists between this code and the clock interrupt
    //      code that examines the timer table lists to detemine when timers
    //      expire.
    //

    ListHead = &KiTimerTableListHead[Index];
    NextEntry = ListHead->Blink;

#if DBG

    SearchCount = 0;

#endif

    while (NextEntry != ListHead) {

        //
        // Compute the maximum search count.
        //

#if DBG

        SearchCount += 1;
        if (SearchCount > KiMaximumSearchCount) {
            KiMaximumSearchCount = SearchCount;
        }

#endif

        NextTimer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
        if (Timer->DueTime.QuadPart >= NextTimer->DueTime.QuadPart) {
            break;
        }

        NextEntry = NextEntry->Blink;
    }

    InsertHeadList(NextEntry, &Timer->TimerListEntry);
    if (NextEntry == ListHead) {

        //
        // The computed list is empty or the timer is due to expire before
        // the first entry in the list.
        //

        KiQueryInterruptTime(&CurrentTime);
        if (Timer->DueTime.QuadPart <= (ULONG64)CurrentTime.QuadPart) {

            //
            // The timer is due to expire before the current time. Remove the
            // timer from the computed list, set its status to Signaled, and
            // set its inserted state to FALSE.
            //

            KiRemoveTreeTimer(Timer);
            Timer->Header.SignalState = TRUE;
            Timer->Header.Inserted = FALSE;
        }
    }

    return Timer->Header.Inserted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\timerobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    timerobj.c

Abstract:

    This module implements the kernel timer object. Functions are
    provided to initialize, read, set, and cancel timer objects.

Author:

    David N. Cutler (davec) 2-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, KeQueryTimerDueTime)
#endif

//
// The following assert macro is used to check that an input timer is
// really a ktimer and not something else, like deallocated pool.
//

#define ASSERT_TIMER(E) {                                     \
    ASSERT(((E)->Header.Type == TimerNotificationObject) ||   \
           ((E)->Header.Type == TimerSynchronizationObject)); \
}

VOID
KeInitializeTimer (
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function initializes a kernel timer object.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    None.

--*/

{

    //
    // Initialize extended timer object with a type of notification and a
    // period of zero.
    //

    KeInitializeTimerEx(Timer, NotificationTimer);
    return;
}

VOID
KeInitializeTimerEx (
    IN PKTIMER Timer,
    IN TIMER_TYPE Type
    )

/*++

Routine Description:

    This function initializes an extended kernel timer object.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    Type - Supplies the type of timer object; NotificationTimer or
        SynchronizationTimer;

Return Value:

    None.

--*/

{
    //
    // Initialize standard dispatcher object header and set initial
    // state of timer.
    //

    Timer->Header.Type = TimerNotificationObject + Type;
    Timer->Header.Inserted = FALSE;
    Timer->Header.Size = sizeof(KTIMER) / sizeof(LONG);
    Timer->Header.SignalState = FALSE;

#if DBG

    Timer->TimerListEntry.Flink = NULL;
    Timer->TimerListEntry.Blink = NULL;

#endif

    InitializeListHead(&Timer->Header.WaitListHead);
    Timer->DueTime.QuadPart = 0;
    Timer->Period = 0;
    return;
}

VOID
KeClearTimer (
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function clears the signal state of an timer object.

Arguments:

    Event - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    None.

--*/

{

    ASSERT_TIMER(Timer);

    //
    // Clear signal state of timer object.
    //

    Timer->Header.SignalState = 0;
    return;
}

BOOLEAN
KeCancelTimer (
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function cancels a timer that was previously set to expire at
    a specified time. If the timer is not currently set, then no operation
    is performed. Canceling a timer does not set the state of the timer to
    Signaled.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    A boolean value of TRUE is returned if the the specified timer was
    currently set. Else a value of FALSE is returned.

--*/

{

    BOOLEAN Inserted;
    KIRQL OldIrql;

    ASSERT_TIMER(Timer);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level, lock the dispatcher database, and
    // capture the timer inserted status. If the timer is currently set,
    // then remove it from the timer list.
    //

    KiLockDispatcherDatabase(&OldIrql);
    Inserted = Timer->Header.Inserted;
    if (Inserted != FALSE) {
        KiRemoveTreeTimer(Timer);
    }

    //
    // Unlock the dispatcher database, lower IRQL to its previous value, and
    // return boolean value that signifies whether the timer was set of not.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Inserted;
}

BOOLEAN
KeReadStateTimer (
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function reads the current signal state of a timer object.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    The current signal state of the timer object.

--*/

{

    ASSERT_TIMER(Timer);

    //
    // Return current signal state of timer object.
    //

    return (BOOLEAN)Timer->Header.SignalState;
}

BOOLEAN
KeSetTimer (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN PKDPC Dpc OPTIONAL
    )

/*++

Routine Description:

    This function sets a timer to expire at a specified time. If the timer is
    already set, then it is implicitly canceled before it is set to expire at
    the specified time. Setting a timer causes its due time to be computed,
    its state to be set to Not-Signaled, and the timer object itself to be
    inserted in the timer list.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    DueTime - Supplies an absolute or relative time at which the timer
        is to expire.

    Dpc - Supplies an optional pointer to a control object of type DPC.

Return Value:

    A boolean value of TRUE is returned if the the specified timer was
    currently set. Else a value of FALSE is returned.

--*/

{

    //
    // Set the timer with a period of zero.
    //

    return KeSetTimerEx(Timer, DueTime, 0, Dpc);
}

BOOLEAN
KeSetTimerEx (
    IN PKTIMER Timer,
    IN LARGE_INTEGER DueTime,
    IN LONG Period OPTIONAL,
    IN PKDPC Dpc OPTIONAL
    )

/*++

Routine Description:

    This function sets a timer to expire at a specified time. If the timer is
    already set, then it is implicitly canceled before it is set to expire at
    the specified time. Setting a timer causes its due time to be computed,
    its state to be set to Not-Signaled, and the timer object itself to be
    inserted in the timer list.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

    DueTime - Supplies an absolute or relative time at which the timer
        is to expire.

    Period - Supplies an optional period for the timer in milliseconds.

    Dpc - Supplies an optional pointer to a control object of type DPC.

Return Value:

    A boolean value of TRUE is returned if the the specified timer was
    currently set. Else a value of FALSE is returned.

--*/

{

    BOOLEAN Inserted;
    LARGE_INTEGER Interval;
    KIRQL OldIrql;
    LARGE_INTEGER SystemTime;

    ASSERT_TIMER(Timer);
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the timer inserted status and if the timer is currently
    // set, then remove it from the timer list.
    //

    Inserted = Timer->Header.Inserted;
    if (Inserted != FALSE) {
        KiRemoveTreeTimer(Timer);
    }

    //
    // Clear the signal state, set the period, set the DPC address, and
    // insert the timer in the timer tree. If the timer is not inserted
    // in the timer tree, then it has already expired and as many waiters
    // as possible should be continued, and a DPC, if specified should be
    // queued.
    //
    // N.B. The signal state must be cleared in case the period is not
    //      zero.
    //

    Timer->Header.SignalState = FALSE;
    Timer->Dpc = Dpc;
    Timer->Period = Period;
    if (KiInsertTreeTimer((PRKTIMER)Timer, DueTime) == FALSE) {
        if (IsListEmpty(&Timer->Header.WaitListHead) == FALSE) {
            KiWaitTest(Timer, TIMER_EXPIRE_INCREMENT);
        }

        //
        // If a DPC is specfied, then call the DPC routine.
        //

        if (Dpc != NULL) {
            KiQuerySystemTime(&SystemTime);
            KeInsertQueueDpc(Timer->Dpc,
                             ULongToPtr(SystemTime.LowPart),
                             ULongToPtr(SystemTime.HighPart));
        }

        //
        // If the timer is periodic, then compute the next interval time
        // and reinsert the timer in the timer tree.
        //
        // N.B. Even though the timer insertion is relative, it can still
        //      fail if the period of the timer elapses in between computing
        //      the time and inserting the timer. If this happens, then the
        //      the insertion is retried.
        //

        if (Period != 0) {
            Interval.QuadPart = Int32x32To64(Timer->Period, - 10 * 1000);
            do {
            } while (KiInsertTreeTimer(Timer, Interval) == FALSE);
        }
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous
    // value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Return boolean value that signifies whether the timer was set of
    // not.
    //

    return Inserted;
}

ULONGLONG
KeQueryTimerDueTime (
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function returns the InterruptTime at which the timer is
    pending.   0 is returned if the timer is not pending.

    N.B. This function may only be called by the system sleep code.

Arguments:

    Timer - Supplies a pointer to a dispatcher object of type timer.

Return Value:

    Returns the amount of time remaining on the timer, or 0 if the
    timer is not pending.

--*/

{

    KIRQL OldIrql;
    LARGE_INTEGER InterruptTime;
    ULONGLONG DueTime;

    ASSERT_TIMER(Timer);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the timer is currently pending, compute its due time
    //

    DueTime = 0;
    if (Timer->Header.Inserted) {
        DueTime = Timer->DueTime.QuadPart;
    }

    //
    // Unlock the dispatcher database and lower IRQL to its previous
    // value, and return the due time
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return DueTime;
}

VOID
KeCheckForTimer(
    IN PVOID BlockStart,
    IN SIZE_T BlockSize
    )
/*++

Routine Description:

    This function is used for debugging by checking all timers
    to see if any is in the memory block passed.  If so, the
    system bugchecks.

Arguments:

    BlockStart - Base address to check for timer.

    BlockSize - Size (in bytes) to check in the memory block.

Return Value:

    None.

--*/
{
    ULONG Index;
    PLIST_ENTRY ListHead;
    PLIST_ENTRY NextEntry;
    KIRQL OldIrql;
    PKTIMER Timer;
    PUCHAR Address;
    PUCHAR Start;
    PUCHAR End;

    //
    // Compute the ending memory location.
    //

    Start = (PUCHAR)BlockStart;
    End = Start + BlockSize;

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Run the entire timer database and check for any timers in
    // the memory block
    //

    Index = 0;
    do {
        ListHead = &KiTimerTableListHead[Index];
        NextEntry = ListHead->Flink;
        while (NextEntry != ListHead) {
            Timer = CONTAINING_RECORD(NextEntry, KTIMER, TimerListEntry);
            Address = (PUCHAR)Timer;
            NextEntry = NextEntry->Flink;

            //
            // Check this timer object is not in the range.
            // In each of the following, we check that the object
            // does not overlap the range, for example, if the timer
            // object (in this first check), starts one dword before
            // the range being checked, we have an overlap and should
            // stop.
            //

            if ((Address > (Start - sizeof(KTIMER))) &&
                (Address < End)) {
                KeBugCheckEx(TIMER_OR_DPC_INVALID,
                             0x0,
                             (ULONG_PTR)Address,
                             (ULONG_PTR)Start,
                             (ULONG_PTR)End);
            }

            if (Timer->Dpc) {

                //
                // Check the timer's DPC object isn't in the range.
                //

                Address = (PUCHAR)Timer->Dpc;
                if ((Address > (Start - sizeof(KDPC))) &&
                    (Address < End)) {
                    KeBugCheckEx(TIMER_OR_DPC_INVALID,
                                 0x1,
                                 (ULONG_PTR)Address,
                                 (ULONG_PTR)Start,
                                 (ULONG_PTR)End);
                }

                //
                // Check the timer's DPC routine is not in the range.
                //

                Address = (PUCHAR)Timer->Dpc->DeferredRoutine;
                if (Address >= Start && Address < End) {
                    KeBugCheckEx(TIMER_OR_DPC_INVALID,
                                 0x2,
                                 (ULONG_PTR)Address,
                                 (ULONG_PTR)Start,
                                 (ULONG_PTR)End);
                }
            }
        }

        Index += 1;
    } while(Index < TIMER_TABLE_SIZE);


    //
    // Unlock the dispatcher database and lower IRQL to its previous value
    //

    KiUnlockDispatcherDatabase(OldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\wait.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    wait.c

Abstract:

    This module implements the generic kernel wait routines. Functions
    are provided to delay execution, wait for multiple objects, wait for
    a single object, and ot set a client event and wait for a server event.

    N.B. This module is written to be a fast as possible and not as small
        as possible. Therefore some code sequences are duplicated to avoid
        procedure calls. It would also be possible to combine wait for
        single object into wait for multiple objects at the cost of some
        speed. Since wait for single object is the most common case, the
        two routines have been separated.

Author:

    David N. Cutler (davec) 23-Mar-89

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Test for alertable condition.
//
// If alertable is TRUE and the thread is alerted for a processor
// mode that is equal to the wait mode, then return immediately
// with a wait completion status of ALERTED.
//
// Else if alertable is TRUE, the wait mode is user, and the user APC
// queue is not empty, then set user APC pending, and return immediately
// with a wait completion status of USER_APC.
//
// Else if alertable is TRUE and the thread is alerted for kernel
// mode, then return immediately with a wait completion status of
// ALERTED.
//
// Else if alertable is FALSE and the wait mode is user and there is a
// user APC pending, then return immediately with a wait completion
// status of USER_APC.
//

#define TestForAlertPending(Alertable) \
    if (Alertable) { \
        if (Thread->Alerted[WaitMode] != FALSE) { \
            Thread->Alerted[WaitMode] = FALSE; \
            WaitStatus = STATUS_ALERTED; \
            break; \
        } else if ((WaitMode != KernelMode) && \
                  (IsListEmpty(&Thread->ApcState.ApcListHead[UserMode])) == FALSE) { \
            Thread->ApcState.UserApcPending = TRUE; \
            WaitStatus = STATUS_USER_APC; \
            break; \
        } else if (Thread->Alerted[KernelMode] != FALSE) { \
            Thread->Alerted[KernelMode] = FALSE; \
            WaitStatus = STATUS_ALERTED; \
            break; \
        } \
    } else if ((WaitMode != KernelMode) && (Thread->ApcState.UserApcPending)) { \
        WaitStatus = STATUS_USER_APC; \
        break; \
    }

VOID
KiAdjustQuantumThread (
    IN PKTHREAD Thread
    )

/*++

Routine Description:

    If the current thread is not a time critical or realtime thread, then
    adjust its quantum in accordance with the adjustment that would have
    occured if the thread had actually waited.

Arguments:

    Thread - Supplies a pointer to the current thread.

Return Value:

    None.

--*/

{
    PKPRCB Prcb;
    PKPROCESS Process;
    PKTHREAD NewThread;
    SCHAR ThreadPriority;

    if ((Thread->Priority < LOW_REALTIME_PRIORITY) &&
        (Thread->BasePriority < TIME_CRITICAL_PRIORITY_BOUND)) {
        Thread->Quantum -= WAIT_QUANTUM_DECREMENT;
        if (Thread->Quantum <= 0) {
            Process = Thread->ApcState.Process;
            Thread->Quantum = Process->ThreadQuantum;
            ThreadPriority = Thread->Priority - (Thread->PriorityDecrement + 1);
            if (ThreadPriority < Thread->BasePriority) {
                ThreadPriority = Thread->BasePriority;
            }

            Thread->PriorityDecrement = 0;
            if (ThreadPriority != Thread->Priority) {
                KiSetPriorityThread(Thread, ThreadPriority);

            } else {
                Prcb = KeGetCurrentPrcb();
                if (Prcb->NextThread == NULL) {
                    NewThread = KiFindReadyThread(Thread->NextProcessor,
                                                  ThreadPriority);
                    if (NewThread != NULL) {
                        NewThread->State = Standby;
                        Prcb->NextThread = NewThread;
                    }
                }
            }
        }
    }

    return;
}

//
// The following macro initializes thread local variables for the delay
// execution thread kernel service while context switching is disabled.
//
// N.B. IRQL must be raised to DPC level prior to the invocation of this
//      macro.
//
// N.B. Initialization is done in this manner so this code does not get
//      executed inside the dispatcher lock.
//

#define InitializeDelayExecution()                                          \
    Thread->WaitBlockList = WaitBlock;                                      \
    Thread->WaitStatus = 0;                                                 \
    WaitBlock->NextWaitBlock = WaitBlock;                                   \
    Timer->Header.WaitListHead.Flink = &WaitBlock->WaitListEntry;           \
    Timer->Header.WaitListHead.Blink = &WaitBlock->WaitListEntry;           \
    Thread->Alertable = Alertable;                                          \
    Thread->WaitMode = WaitMode;                                            \
    Thread->WaitReason = DelayExecution;                                    \
    Thread->WaitListEntry.Flink = NULL;                                     \
    StackSwappable = KiIsKernelStackSwappable(WaitMode, Thread);            \
    Thread->WaitTime = KiQueryLowTickCount()
        
NTSTATUS
KeDelayExecutionThread (
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Interval
    )

/*++

Routine Description:

    This function delays the execution of the current thread for the specified
    interval of time.

Arguments:

    WaitMode  - Supplies the processor mode in which the delay is to occur.

    Alertable - Supplies a boolean value that specifies whether the delay
        is alertable.

    Interval - Supplies a pointer to the absolute or relative time over which
        the delay is to occur.

Return Value:

    The wait completion status. A value of STATUS_SUCCESS is returned if
    the delay occurred. A value of STATUS_ALERTED is returned if the wait
    was aborted to deliver an alert to the current thread. A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{

    LARGE_INTEGER DueTime;
    LARGE_INTEGER NewTime;
    PLARGE_INTEGER OriginalTime;
    PKPRCB Prcb;
    KPRIORITY Priority;
    PRKQUEUE Queue;
    LOGICAL StackSwappable;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;
    NTSTATUS WaitStatus;

    //
    // Set constant variables.
    //

    Thread = KeGetCurrentThread();
    OriginalTime = Interval;
    Timer = &Thread->Timer;
    WaitBlock = &Thread->WaitBlock[TIMER_WAIT_BLOCK];

    //
    // If the dispatcher database is already held, then initialize the thread
    // local variables. Otherwise, raise IRQL to DPC level, initialize the
    // thread local variables, and lock the dispatcher database.
    //

    if (Thread->WaitNext == FALSE) {
        goto WaitStart;
    }

    Thread->WaitNext = FALSE;
    InitializeDelayExecution();

    //
    // Start of delay loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the middle
    // of the delay or a kernel APC is pending on the first attempt through
    // the loop.
    //

    do {

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending and the previous IRQL was less than
        // APC_LEVEL, then a kernel APC was queued by another processor just
        // after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher
        // database was locked.
        //
        // N.B. that this can only happen in a multiprocessor system.
        //

        if (Thread->ApcState.KernelApcPending && (Thread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(Thread->WaitIrql);

        } else {

            //
            // Test for alert pending.
            //

            TestForAlertPending(Alertable);

            //
            // Insert the timer in the timer tree.
            //
            // N.B. The constant fields of the timer wait block are
            //      initialized when the thread is initialized. The
            //      constant fields include the wait object, wait key,
            //      wait type, and the wait list entry link pointers.
            //

            if (KiInsertTreeTimer(Timer, *Interval) == FALSE) {

                //
                // If the thread is not a realtime thread, then drop the
                // thread priority to the base priority.
                //

                Prcb = KeGetCurrentPrcb();
                Priority = Thread->Priority;
                if (Priority < LOW_REALTIME_PRIORITY) {
                    if (Priority != Thread->BasePriority) {
                        Thread->PriorityDecrement = 0;
                        KiSetPriorityThread(Thread, Thread->BasePriority);
                    }
                }

                //
                // If a new thread has not been selected, then attempt to round
                // robin the thread with other threads at the same priority.
                //

                if (Prcb->NextThread == NULL) {
                    Prcb->NextThread = KiFindReadyThread(Thread->NextProcessor,
                                                         Thread->Priority);
                }

                //
                // If a new thread has been selected for execution, then
                // switch immediately to the selected thread.
                //

                if (Prcb->NextThread != NULL) {

                    //
                    // Give the current thread a new quantum and switch
                    // context to selected thread.
                    //
                    // N.B. Control is returned at the original IRQL.
                    //

                    Thread->Preempted = FALSE;
                    Thread->Quantum = Thread->ApcState.Process->ThreadQuantum;

                    ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

                    //
                    // Reready the thread without it being able to run on
                    // another processor immediately.
                    //

                    Thread->State = Ready;
                    InsertTailList(&KiDispatcherReadyListHead[Thread->Priority],
                                   &Thread->WaitListEntry);

                    SetMember(Thread->Priority, KiReadySummary);
                    WaitStatus = (NTSTATUS)KiSwapThread();
                    goto WaitComplete;

                } else {
                    WaitStatus = STATUS_SUCCESS;
                    break;
                }
            }

            DueTime.QuadPart = Timer->DueTime.QuadPart;

            //
            // If the current thread is processing a queue entry, then attempt
            // to activate another thread that is blocked on the queue object.
            //

            Queue = Thread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher
            // state to Waiting, and insert the thread in the wait list if
            // the kernel stack of the current thread is swappable.
            //

            Thread->State = Waiting;
            if (StackSwappable != FALSE) {
                InsertTailList(&KiWaitListHead, &Thread->WaitListEntry);
            }

            //
            // Switch context to selected thread.
            //
            // N.B. Control is returned at the original IRQL.
            //

            ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

            WaitStatus = (NTSTATUS)KiSwapThread();

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then return the wait status.
            //

        WaitComplete:

            if (WaitStatus != STATUS_KERNEL_APC) {
                if (WaitStatus == STATUS_TIMEOUT) {
                    WaitStatus = STATUS_SUCCESS;
                }

                return WaitStatus;
            }

            //
            // Reduce the time remaining before the time delay expires.
            //

            Interval = KiComputeWaitInterval(OriginalTime,
                                             &DueTime,
                                             &NewTime);
        }

        //
        // Raise IRQL to DPC level, initialize the thread local variables,
        // and lock the dispatcher database.
        //

WaitStart:

#if defined(NT_UP)

        Thread->WaitIrql = KeRaiseIrqlToDpcLevel();

#else

        Thread->WaitIrql = KeRaiseIrqlToSynchLevel();

#endif

        InitializeDelayExecution();
        KiLockDispatcherDatabaseAtSynchLevel();

    } while (TRUE);

    //
    // The thread is alerted or a user APC should be delivered. Unlock the
    // dispatcher database, lower IRQL to its previous value, and return the
    // wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    return WaitStatus;
}

//
// The following macro initializes thread local variables for the wait
// for multiple objects kernel service while context switching is disabled.
//
// N.B. IRQL must be raised to DPC level prior to the invocation of this
//      macro.
//
// N.B. Initialization is done in this manner so this code does not get
//      executed inside the dispatcher lock.
//

#define InitializeWaitMultiple()                                            \
    Thread->WaitBlockList = WaitBlockArray;                                 \
    Thread->WaitStatus = 0;                                                 \
    InitializeListHead(&Timer->Header.WaitListHead);                        \
    Thread->Alertable = Alertable;                                          \
    Thread->WaitMode = WaitMode;                                            \
    Thread->WaitReason = (UCHAR)WaitReason;                                 \
    Thread->WaitListEntry.Flink = NULL;                                     \
    StackSwappable = KiIsKernelStackSwappable(WaitMode, Thread);            \
    Thread->WaitTime= KiQueryLowTickCount()

NTSTATUS
KeWaitForMultipleObjects (
    IN ULONG Count,
    IN PVOID Object[],
    IN WAIT_TYPE WaitType,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL,
    IN PKWAIT_BLOCK WaitBlockArray OPTIONAL
    )

/*++

Routine Description:

    This function waits until the specified objects attain a state of
    Signaled. The wait can be specified to wait until all of the objects
    attain a state of Signaled or until one of the objects attains a state
    of Signaled. An optional timeout can also be specified. If a timeout
    is not specified, then the wait will not be satisfied until the objects
    attain a state of Signaled. If a timeout is specified, and the objects
    have not attained a state of Signaled when the timeout expires, then
    the wait is automatically satisfied. If an explicit timeout value of
    zero is specified, then no wait will occur if the wait cannot be satisfied
    immediately. The wait can also be specified as alertable.

Arguments:

    Count - Supplies a count of the number of objects that are to be waited
        on.

    Object[] - Supplies an array of pointers to dispatcher objects.

    WaitType - Supplies the type of wait to perform (WaitAll, WaitAny).

    WaitReason - Supplies the reason for the wait.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

    WaitBlockArray - Supplies an optional pointer to an array of wait blocks
        that are to used to describe the wait operation.

Return Value:

    The wait completion status. A value of STATUS_TIMEOUT is returned if a
    timeout occurred. The index of the object (zero based) in the object
    pointer array is returned if an object satisfied the wait. A value of
    STATUS_ALERTED is returned if the wait was aborted to deliver an alert
    to the current thread. A value of STATUS_USER_APC is returned if the
    wait was aborted to deliver a user APC to the current thread.

--*/

{

    LARGE_INTEGER DueTime;
    ULONG Index;
    LARGE_INTEGER NewTime;
    PKMUTANT Objectx;
    PLARGE_INTEGER OriginalTime;
    PRKQUEUE Queue;
    LOGICAL StackSwappable;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    PRKWAIT_BLOCK WaitBlock;
    BOOLEAN WaitSatisfied;
    NTSTATUS WaitStatus;
    PKWAIT_BLOCK WaitTimer;

    //
    // Set constant variables.
    //

    Thread = KeGetCurrentThread();
    OriginalTime = Timeout;
    Timer = &Thread->Timer;
    WaitTimer = &Thread->WaitBlock[TIMER_WAIT_BLOCK];

    //
    // If a wait block array has been specified, then the maximum number of
    // objects that can be waited on is specified by MAXIMUM_WAIT_OBJECTS.
    // Otherwise the builtin wait blocks in the thread object are used and
    // the maximum number of objects that can be waited on is specified by
    // THREAD_WAIT_OBJECTS. If the specified number of objects is not within
    // limits, then bug check.
    //

    if (ARGUMENT_PRESENT(WaitBlockArray)) {
        if (Count > MAXIMUM_WAIT_OBJECTS) {
            KeBugCheck(MAXIMUM_WAIT_OBJECTS_EXCEEDED);
        }

    } else {
        if (Count > THREAD_WAIT_OBJECTS) {
            KeBugCheck(MAXIMUM_WAIT_OBJECTS_EXCEEDED);
        }

        WaitBlockArray = &Thread->WaitBlock[0];
    }

    //
    // If the dispatcher database is already held, then initialize the thread
    // local variables. Otherwise, raise IRQL to DPC level, initialize the
    // thread local variables, and lock the dispatcher database.
    //

    if (Thread->WaitNext == FALSE) {
        goto WaitStart;
    }

    Thread->WaitNext = FALSE;
    InitializeWaitMultiple();

    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the middle
    // of the wait or a kernel APC is pending on the first attempt through
    // the loop.
    //

    do {

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending and the previous IRQL was less than
        // APC_LEVEL, then a kernel APC was queued by another processor just
        // after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher
        // database was locked.
        //
        // N.B. that this can only happen in a multiprocessor system.
        //

        if (Thread->ApcState.KernelApcPending && (Thread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(Thread->WaitIrql);

        } else {

            //
            // Construct wait blocks and check to determine if the wait is
            // already satisfied. If the wait is satisfied, then perform
            // wait completion and return. Else put current thread in a wait
            // state if an explicit timeout value of zero is not specified.
            //

            WaitSatisfied = TRUE;
            for (Index = 0; Index < Count; Index += 1) {

                //
                // Test if wait can be satisfied immediately.
                //

                Objectx = (PKMUTANT)Object[Index];

                ASSERT(Objectx->Header.Type != QueueObject);

                if (WaitType == WaitAny) {

                    //
                    // If the object is a mutant object and the mutant object
                    // has been recursively acquired MINLONG times, then raise
                    // an exception. Otherwise if the signal state of the mutant
                    // object is greater than zero, or the current thread is
                    // the owner of the mutant object, then satisfy the wait.
                    //

                    if (Objectx->Header.Type == MutantObject) {
                        if ((Objectx->Header.SignalState > 0) ||
                            (Thread == Objectx->OwnerThread)) {
                            if (Objectx->Header.SignalState != MINLONG) {
                                KiWaitSatisfyMutant(Objectx, Thread);
                                WaitStatus = (NTSTATUS)(Index | Thread->WaitStatus);
                                goto NoWait;

                            } else {
                                KiUnlockDispatcherDatabase(Thread->WaitIrql);
                                ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED);
                            }
                        }

                    //
                    // If the signal state is greater than zero, then satisfy
                    // the wait.
                    //

                    } else if (Objectx->Header.SignalState > 0) {
                        KiWaitSatisfyOther(Objectx);
                        WaitStatus = (NTSTATUS)(Index);
                        goto NoWait;
                    }

                } else {

                    //
                    // If the object is a mutant object and the mutant object
                    // has been recursively acquired MAXLONG times, then raise
                    // an exception. Otherwise if the signal state of the mutant
                    // object is less than or equal to zero and the current
                    // thread is not the  owner of the mutant object, then the
                    // wait cannot be satisfied.
                    //

                    if (Objectx->Header.Type == MutantObject) {
                        if ((Thread == Objectx->OwnerThread) &&
                            (Objectx->Header.SignalState == MINLONG)) {
                            KiUnlockDispatcherDatabase(Thread->WaitIrql);
                            ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED);

                        } else if ((Objectx->Header.SignalState <= 0) &&
                                  (Thread != Objectx->OwnerThread)) {
                            WaitSatisfied = FALSE;
                        }

                    //
                    // If the signal state is less than or equal to zero, then
                    // the wait cannot be satisfied.
                    //

                    } else if (Objectx->Header.SignalState <= 0) {
                        WaitSatisfied = FALSE;
                    }
                }

                //
                // Construct wait block for the current object.
                //

                WaitBlock = &WaitBlockArray[Index];
                WaitBlock->Object = (PVOID)Objectx;
                WaitBlock->WaitKey = (CSHORT)(Index);
                WaitBlock->WaitType = (USHORT)WaitType;
                WaitBlock->Thread = Thread;
                WaitBlock->NextWaitBlock = &WaitBlockArray[Index + 1];
            }

            //
            // If the wait type is wait all, then check to determine if the
            // wait can be satisfied immediately.
            //

            if ((WaitType == WaitAll) && (WaitSatisfied)) {
                WaitBlock->NextWaitBlock = &WaitBlockArray[0];
                KiWaitSatisfyAll(WaitBlock);
                WaitStatus = (NTSTATUS)Thread->WaitStatus;
                goto NoWait;
            }

            //
            // Test for alert pending.
            //

            TestForAlertPending(Alertable);

            //
            // The wait cannot be satisifed immediately. Check to determine if
            // a timeout value is specified.
            //

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // If the timeout value is zero, then return immediately without
                // waiting.
                //

                if (!(Timeout->LowPart | Timeout->HighPart)) {
                    WaitStatus = (NTSTATUS)(STATUS_TIMEOUT);
                    goto NoWait;
                }

                //
                // Initialize a wait block for the thread specific timer,
                // initialize timer wait list head, insert the timer in the
                // timer tree, and increment the number of wait objects.
                //
                // N.B. The constant fields of the timer wait block are
                //      initialized when the thread is initialized. The
                //      constant fields include the wait object, wait key,
                //      wait type, and the wait list entry link pointers.
                //

                WaitBlock->NextWaitBlock = WaitTimer;
                WaitBlock = WaitTimer;
                if (KiInsertTreeTimer(Timer, *Timeout) == FALSE) {
                    WaitStatus = (NTSTATUS)STATUS_TIMEOUT;
                    goto NoWait;
                }

                DueTime.QuadPart = Timer->DueTime.QuadPart;
            }

            //
            // Close up the circular list of wait control blocks.
            //

            WaitBlock->NextWaitBlock = &WaitBlockArray[0];

            //
            // Insert wait blocks in object wait lists.
            //

            WaitBlock = &WaitBlockArray[0];
            do {
                Objectx = (PKMUTANT)WaitBlock->Object;
                InsertTailList(&Objectx->Header.WaitListHead, &WaitBlock->WaitListEntry);
                WaitBlock = WaitBlock->NextWaitBlock;
            } while (WaitBlock != &WaitBlockArray[0]);

            //
            // If the current thread is processing a queue entry, then attempt
            // to activate another thread that is blocked on the queue object.
            //

            Queue = Thread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher state
            // to Waiting, and insert the thread in the wait list.
            //

            Thread->State = Waiting;
            if (StackSwappable != FALSE) {
                InsertTailList(&KiWaitListHead, &Thread->WaitListEntry);
            }

            //
            // Switch context to selected thread.
            //
            // Control is returned at the original IRQL.
            //

            ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

            WaitStatus = (NTSTATUS)KiSwapThread();

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then return the wait status.
            //

            if (WaitStatus != STATUS_KERNEL_APC) {
                return WaitStatus;
            }

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // Reduce the amount of time remaining before timeout occurs.
                //

                Timeout = KiComputeWaitInterval(OriginalTime,
                                                &DueTime,
                                                &NewTime);
            }
        }

        //
        // Raise IRQL to DPC level, initialize the thread local variables,
        // and lock the dispatcher database.
        //

WaitStart:

#if defined(NT_UP)

        Thread->WaitIrql = KeRaiseIrqlToDpcLevel();

#else

        Thread->WaitIrql = KeRaiseIrqlToSynchLevel();

#endif

        InitializeWaitMultiple();
        KiLockDispatcherDatabaseAtSynchLevel();

    } while (TRUE);

    //
    // The thread is alerted or a user APC should be delivered. Unlock the
    // dispatcher database, lower IRQL to its previous value, and return
    // the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    return WaitStatus;

    //
    // The wait has been satisfied without actually waiting.
    //
    // If the thread priority that is less than time critical, then reduce
    // the thread quantum. If a quantum end occurs, then reduce the thread
    // priority.
    //

NoWait:

    KiAdjustQuantumThread(Thread);

    //
    // Unlock the dispatcher database, lower IRQL to its previous value, and
    // return the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    return WaitStatus;
}

//
// The following macro initializes thread local variables for the wait
// for single object kernel service while context switching is disabled.
//
// N.B. IRQL must be raised to DPC level prior to the invocation of this
//      macro.
//
// N.B. Initialization is done in this manner so this code does not get
//      executed inside the dispatcher lock.
//

#define InitializeWaitSingle()                                              \
    Thread->WaitBlockList = WaitBlock;                                      \
    WaitBlock->Object = Object;                                             \
    WaitBlock->WaitKey = (CSHORT)(STATUS_SUCCESS);                          \
    WaitBlock->WaitType = WaitAny;                                          \
    Thread->WaitStatus = 0;                                                 \
    if (ARGUMENT_PRESENT(Timeout)) {                                        \
        WaitBlock->NextWaitBlock = WaitTimer;                               \
        WaitTimer->NextWaitBlock = WaitBlock;                               \
        Timer->Header.WaitListHead.Flink = &WaitTimer->WaitListEntry;       \
        Timer->Header.WaitListHead.Blink = &WaitTimer->WaitListEntry;       \
    } else {                                                                \
        WaitBlock->NextWaitBlock = WaitBlock;                               \
    }                                                                       \
    Thread->Alertable = Alertable;                                          \
    Thread->WaitMode = WaitMode;                                            \
    Thread->WaitReason = (UCHAR)WaitReason;                                 \
    Thread->WaitListEntry.Flink = NULL;                                     \
    StackSwappable = KiIsKernelStackSwappable(WaitMode, Thread);            \
    Thread->WaitTime= KiQueryLowTickCount()

NTSTATUS
KeWaitForSingleObject (
    IN PVOID Object,
    IN KWAIT_REASON WaitReason,
    IN KPROCESSOR_MODE WaitMode,
    IN BOOLEAN Alertable,
    IN PLARGE_INTEGER Timeout OPTIONAL
    )

/*++

Routine Description:

    This function waits until the specified object attains a state of
    Signaled. An optional timeout can also be specified. If a timeout
    is not specified, then the wait will not be satisfied until the object
    attains a state of Signaled. If a timeout is specified, and the object
    has not attained a state of Signaled when the timeout expires, then
    the wait is automatically satisfied. If an explicit timeout value of
    zero is specified, then no wait will occur if the wait cannot be satisfied
    immediately. The wait can also be specified as alertable.

Arguments:

    Object - Supplies a pointer to a dispatcher object.

    WaitReason - Supplies the reason for the wait.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

    Alertable - Supplies a boolean value that specifies whether the wait is
        alertable.

    Timeout - Supplies a pointer to an optional absolute of relative time over
        which the wait is to occur.

Return Value:

    The wait completion status. A value of STATUS_TIMEOUT is returned if a
    timeout occurred. A value of STATUS_SUCCESS is returned if the specified
    object satisfied the wait. A value of STATUS_ALERTED is returned if the
    wait was aborted to deliver an alert to the current thread. A value of
    STATUS_USER_APC is returned if the wait was aborted to deliver a user
    APC to the current thread.

--*/

{

    LARGE_INTEGER DueTime;
    LARGE_INTEGER NewTime;
    PKMUTANT Objectx;
    PLARGE_INTEGER OriginalTime;
    PRKQUEUE Queue;
    LOGICAL StackSwappable;
    PRKTHREAD Thread;
    PRKTIMER Timer;
    PKWAIT_BLOCK WaitBlock;
    NTSTATUS WaitStatus;
    PKWAIT_BLOCK WaitTimer;

    //
    // Collect call data.
    //

#if defined(_COLLECT_WAIT_SINGLE_CALLDATA_)

    RECORD_CALL_DATA(&KiWaitSingleCallData);

#endif

    ASSERT((PsGetCurrentThread()->StartAddress != (PVOID)KeBalanceSetManager) || (ARGUMENT_PRESENT(Timeout)));

    //
    // Set constant variables.
    //

    Thread = KeGetCurrentThread();
    Objectx = (PKMUTANT)Object;
    OriginalTime = Timeout;
    Timer = &Thread->Timer;
    WaitBlock = &Thread->WaitBlock[0];
    WaitTimer = &Thread->WaitBlock[TIMER_WAIT_BLOCK];

    //
    // If the dispatcher database is already held, then initialize the thread
    // local variables. Otherwise, raise IRQL to DPC level, initialize the
    // thread local variables, and lock the dispatcher database.
    //

    if (Thread->WaitNext == FALSE) {
        goto WaitStart;
    }

    Thread->WaitNext = FALSE;
    InitializeWaitSingle();

    //
    // Start of wait loop.
    //
    // Note this loop is repeated if a kernel APC is delivered in the middle
    // of the wait or a kernel APC is pending on the first attempt through
    // the loop.
    //

    do {

        //
        // Test to determine if a kernel APC is pending.
        //
        // If a kernel APC is pending and the previous IRQL was less than
        // APC_LEVEL, then a kernel APC was queued by another processor just
        // after IRQL was raised to DISPATCH_LEVEL, but before the dispatcher
        // database was locked.
        //
        // N.B. that this can only happen in a multiprocessor system.
        //

        if (Thread->ApcState.KernelApcPending && (Thread->WaitIrql < APC_LEVEL)) {

            //
            // Unlock the dispatcher database and lower IRQL to its previous
            // value. An APC interrupt will immediately occur which will result
            // in the delivery of the kernel APC if possible.
            //

            KiUnlockDispatcherDatabase(Thread->WaitIrql);

        } else {

            //
            // If the object is a mutant object and the mutant object has been
            // recursively acquired MINLONG times, then raise an exception.
            // Otherwise if the signal state of the mutant object is greater
            // than zero, or the current thread is the owner of the mutant
            // object, then satisfy the wait.
            //

            ASSERT(Objectx->Header.Type != QueueObject);

            if (Objectx->Header.Type == MutantObject) {
                if ((Objectx->Header.SignalState > 0) ||
                    (Thread == Objectx->OwnerThread)) {
                    if (Objectx->Header.SignalState != MINLONG) {
                        KiWaitSatisfyMutant(Objectx, Thread);
                        WaitStatus = (NTSTATUS)(Thread->WaitStatus);
                        goto NoWait;

                    } else {
                        KiUnlockDispatcherDatabase(Thread->WaitIrql);
                        ExRaiseStatus(STATUS_MUTANT_LIMIT_EXCEEDED);
                    }
                }

            //
            // If the signal state is greater than zero, then satisfy the wait.
            //

            } else if (Objectx->Header.SignalState > 0) {
                KiWaitSatisfyOther(Objectx);
                WaitStatus = (NTSTATUS)(0);
                goto NoWait;
            }

            //
            // Construct a wait block for the object.
            //

            //
            // Test for alert pending.
            //

            TestForAlertPending(Alertable);

            //
            // The wait cannot be satisifed immediately. Check to determine if
            // a timeout value is specified.
            //

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // If the timeout value is zero, then return immediately without
                // waiting.
                //

                if (!(Timeout->LowPart | Timeout->HighPart)) {
                    WaitStatus = (NTSTATUS)(STATUS_TIMEOUT);
                    goto NoWait;
                }

                //
                // Insert the timer in the timer tree.
                //
                // N.B. The constant fields of the timer wait block are
                //      initialized when the thread is initialized. The
                //      constant fields include the wait object, wait key,
                //      wait type, and the wait list entry link pointers.
                //

                if (KiInsertTreeTimer(Timer, *Timeout) == FALSE) {
                    WaitStatus = (NTSTATUS)STATUS_TIMEOUT;
                    goto NoWait;
                }

                DueTime.QuadPart = Timer->DueTime.QuadPart;
            }

            //
            // Insert wait block in object wait list.
            //

            InsertTailList(&Objectx->Header.WaitListHead, &WaitBlock->WaitListEntry);

            //
            // If the current thread is processing a queue entry, then attempt
            // to activate another thread that is blocked on the queue object.
            //

            Queue = Thread->Queue;
            if (Queue != NULL) {
                KiActivateWaiterQueue(Queue);
            }

            //
            // Set the thread wait parameters, set the thread dispatcher state
            // to Waiting, and insert the thread in the wait list.
            //

            Thread->State = Waiting;
            if (StackSwappable != FALSE) {
                InsertTailList(&KiWaitListHead, &Thread->WaitListEntry);
            }

            //
            // Switch context to selected thread.
            //
            // Control is returned at the original IRQL.
            //

            ASSERT(Thread->WaitIrql <= DISPATCH_LEVEL);

            WaitStatus = (NTSTATUS)KiSwapThread();

            //
            // If the thread was not awakened to deliver a kernel mode APC,
            // then return wait status.
            //

            if (WaitStatus != STATUS_KERNEL_APC) {
                return WaitStatus;
            }

            if (ARGUMENT_PRESENT(Timeout)) {

                //
                // Reduce the amount of time remaining before timeout occurs.
                //

                Timeout = KiComputeWaitInterval(OriginalTime,
                                                &DueTime,
                                                &NewTime);
            }
        }

        //
        // Raise IRQL to DPC level, initialize the thread local variables,
        // and lock the dispatcher database.
        //

WaitStart:

#if defined(NT_UP)

        Thread->WaitIrql = KeRaiseIrqlToDpcLevel();

#else

        Thread->WaitIrql = KeRaiseIrqlToSynchLevel();

#endif

        InitializeWaitSingle();
        KiLockDispatcherDatabaseAtSynchLevel();

    } while (TRUE);

    //
    // The thread is alerted or a user APC should be delivered. Unlock the
    // dispatcher database, lower IRQL to its previous value, and return
    // the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    return WaitStatus;

    //
    // The wait has been satisfied without actually waiting.
    //
    // If the thread priority that is less than time critical, then reduce
    // the thread quantum. If a quantum end occurs, then reduce the thread
    // priority.
    //

NoWait:

    KiAdjustQuantumThread(Thread);

    //
    // Unlock the dispatcher database, lower IRQL to its previous value, and
    // return the wait status.
    //

    KiUnlockDispatcherDatabase(Thread->WaitIrql);
    return WaitStatus;
}

NTSTATUS
KiSetServerWaitClientEvent (
    IN PKEVENT ServerEvent,
    IN PKEVENT ClientEvent,
    IN ULONG WaitMode
    )

/*++

Routine Description:

    This function sets the specified server event and waits on specified
    client event. The wait is performed such that an optimal switch to
    the waiting thread occurs if possible. No timeout is associated with
    the wait, and thus, the issuing thread will wait until the client event
    is signaled or an APC is delivered.

Arguments:

    ServerEvent - Supplies a pointer to a dispatcher object of type event.

    ClientEvent - Supplies a pointer to a dispatcher object of type event.

    WaitMode  - Supplies the processor mode in which the wait is to occur.

Return Value:

    The wait completion status. A value of STATUS_SUCCESS is returned if
    the specified object satisfied the wait. A value of STATUS_USER_APC is
    returned if the wait was aborted to deliver a user APC to the current
    thread.

--*/

{

    //
    // Set sever event and wait on client event atomically.
    //

    KeSetEvent(ServerEvent, EVENT_INCREMENT, TRUE);
    return KeWaitForSingleObject(ClientEvent,
                                 WrEventPair,
                                 (KPROCESSOR_MODE)WaitMode,
                                 FALSE,
                                 NULL);
}

PLARGE_INTEGER
FASTCALL
KiComputeWaitInterval (
    IN PLARGE_INTEGER OriginalTime,
    IN PLARGE_INTEGER DueTime,
    IN OUT PLARGE_INTEGER NewTime
    )

/*++

Routine Description:

    This function recomputes the wait interval after a thread has been
    awakened to deliver a kernel APC.

Arguments:

    OriginalTime - Supplies a pointer to the original timeout value.

    DueTime - Supplies a pointer to the previous due time.

    NewTime - Supplies a pointer to a variable that receives the
        recomputed wait interval.

Return Value:

    A pointer to the new time is returned as the function value.

--*/

{

    //
    // If the original wait time was absolute, then return the same
    // absolute time. Otherwise, reduce the wait time remaining before
    // the time delay expires.
    //

    if (OriginalTime->QuadPart >= 0) {
        return OriginalTime;

    } else {
        KiQueryInterruptTime(NewTime);
        NewTime->QuadPart -= DueTime->QuadPart;
        return NewTime;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\waitsup.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    waitsup.c

Abstract:

    This module contains the support routines necessary to support the
    generic kernel wait functions. Functions are provided to test if a
    wait can be satisfied, to satisfy a wait, and to unwwait a thread.

Author:

    David N. Cutler (davec) 24-Mar-1989

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
FASTCALL
KiUnlinkThread (
    IN PRKTHREAD Thread,
    IN LONG_PTR WaitStatus
    )

/*++

Routine Description:

    This function unlinks a thread from the appropriate wait queues and sets
    the thread's wait completion status.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    WaitStatus - Supplies the wait completion status.

Return Value:

    None.

--*/

{

    PKQUEUE Queue;
    PKTIMER Timer;
    PRKWAIT_BLOCK WaitBlock;

    //
    // Set wait completion status, remove wait blocks from object wait
    // lists, and remove thread from wait list.
    //

    Thread->WaitStatus |= WaitStatus;
    WaitBlock = Thread->WaitBlockList;
    do {
        RemoveEntryList(&WaitBlock->WaitListEntry);
        WaitBlock = WaitBlock->NextWaitBlock;
    } while (WaitBlock != Thread->WaitBlockList);

    if (Thread->WaitListEntry.Flink != NULL) {
        RemoveEntryList(&Thread->WaitListEntry);
    }

    //
    // If thread timer is still active, then cancel thread timer.
    //

    Timer = &Thread->Timer;
    if (Timer->Header.Inserted != FALSE) {
        KiRemoveTreeTimer(Timer);
    }

    //
    // If the thread is processing a queue entry, then increment the
    // count of currently active threads.
    //

    Queue = Thread->Queue;
    if (Queue != NULL) {
        Queue->CurrentCount += 1;
    }

    return;
}

VOID
FASTCALL
KiUnwaitThread (
    IN PRKTHREAD Thread,
    IN LONG_PTR WaitStatus,
    IN KPRIORITY Increment,
    IN PLIST_ENTRY ThreadList OPTIONAL
    )

/*++

Routine Description:

    This function unwaits a thread, sets the thread's wait completion status,
    calculates the thread's new priority, and either readies the thread for
    execution or adds the thread to a list of threads to be readied later.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    WaitStatus - Supplies the wait completion status.

    Increment - Supplies the priority increment that is to be applied to
        the thread's priority.

    ThreadList - Supplies an optional pointer to a listhead.  

Return Value:

    None.

--*/

{

    KPRIORITY NewPriority;
    PKPROCESS Process;

    //
    // Unlink thread from the appropriate wait queues and set the wait
    // completion status.
    //

    KiUnlinkThread(Thread, WaitStatus);

    //
    // If the thread runs at a realtime priority level, then reset the
    // thread quantum. Otherwise, compute the next thread priority and
    // charge the thread for the wait operation.
    //

    Process = Thread->ApcState.Process;
    if (Thread->Priority < LOW_REALTIME_PRIORITY) {
        if ((Thread->PriorityDecrement == 0) &&
            (Thread->DisableBoost == FALSE)) {
            NewPriority = Thread->BasePriority + Increment;

            //
            // If the specified thread is from a process with a foreground
            // memory priority, then add the foreground boost separation.
            //

            if (((PEPROCESS)Process)->Vm.Flags.MemoryPriority == MEMORY_PRIORITY_FOREGROUND) {
                NewPriority += PsPrioritySeperation;
            }

            //
            // If the new thread priority is greater than the current thread
            // priority, then boost the thread priority, but not above low
            // real time minus one.
            //

            if (NewPriority > Thread->Priority) {
                if (NewPriority >= LOW_REALTIME_PRIORITY) {
                    NewPriority = LOW_REALTIME_PRIORITY - 1;
                }

                //
                // If the new thread priority is greater than the thread base
                // priority plus the specified increment (i.e., the foreground
                // separation was added), then set the priority decrement to
                // remove the separation boost after one quantum.
                //

                if (NewPriority > (Thread->BasePriority + Increment)) {
                    Thread->PriorityDecrement =
                        (SCHAR)(NewPriority - Thread->BasePriority - Increment);

                    Thread->DecrementCount = ROUND_TRIP_DECREMENT_COUNT;
                }

                Thread->Priority = (SCHAR)NewPriority;
            }
        }

        if (Thread->BasePriority >= TIME_CRITICAL_PRIORITY_BOUND) {
            Thread->Quantum = Process->ThreadQuantum;

        } else {

            //
            // If the thread is being unwaited to execute a kernel APC,
            // then do not charge the thread any quantum. The wait code
            // will charge quantum after the kernel APC has executed and
            // the wait is actually satisifed.
            //
        
            if (WaitStatus != STATUS_KERNEL_APC) {
                Thread->Quantum -= WAIT_QUANTUM_DECREMENT;
                if (Thread->Quantum <= 0) {
                    Thread->Quantum = Process->ThreadQuantum;
                    Thread->Priority -= (Thread->PriorityDecrement + 1);
                    if (Thread->Priority < Thread->BasePriority) {
                        Thread->Priority = Thread->BasePriority;
                    }
    
                    Thread->PriorityDecrement = 0;
                }
            }
        }
    
    } else {
        Thread->Quantum = Process->ThreadQuantum;
    }

    //
    // If a thread list is specified, then add the thread to the enb of the
    // specified list. Otherwise, ready the thread for execution.
    //

    if (ARGUMENT_PRESENT(ThreadList)) {
        InsertTailList(ThreadList, &Thread->WaitListEntry);

    } else {
        KiReadyThread(Thread);
    }

    return;
}

VOID
KeBoostCurrentThread(
    VOID
    )

/*++

Routine Description:

    This function boosts the priority of the current thread for one quantum,
    then reduce the thread priority to the base priority of the thread.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKTHREAD Thread;

    //
    // Get current thread address, raise IRQL to synchronization level, and
    // lock the dispatcher database
    //

    Thread = KeGetCurrentThread();

redoboost:
    KiLockDispatcherDatabase(&OldIrql);

    //
    // If a priority boost is not already active for the current thread
    // and the thread priority is less than 14, then boost the thread
    // priority to 14 and give the thread a large quantum. Otherwise,
    // if a priority boost is active, then decrement the round trip
    // count. If the count goes to zero, then release the dispatcher
    // database lock, lower the thread priority to the base priority,
    // and then attempt to boost the priority again. This will give
    // other threads a chance to run. If the count does not reach zero,
    // then give the thread another large qunatum.
    //
    // If the thread priority is above 14, then no boost is applied.
    //

    if ((Thread->PriorityDecrement == 0) && (Thread->Priority < 14)) {
        Thread->PriorityDecrement = 14 - Thread->BasePriority;
        Thread->DecrementCount = ROUND_TRIP_DECREMENT_COUNT;
        Thread->Priority = 14;
        Thread->Quantum = Thread->ApcState.Process->ThreadQuantum * 2;

    } else if (Thread->PriorityDecrement != 0) {
        Thread->DecrementCount -= 1;
        if (Thread->DecrementCount == 0) {
            KiUnlockDispatcherDatabase(OldIrql);
            KeSetPriorityThread(Thread, Thread->BasePriority);
            goto redoboost;

        } else {
            Thread->Quantum = Thread->ApcState.Process->ThreadQuantum * 2;
        }
    }

    KiUnlockDispatcherDatabase(OldIrql);
    return;
}

VOID
FASTCALL
KiWaitSatisfyAll (
    IN PRKWAIT_BLOCK WaitBlock
    )

/*++

Routine Description:

    This function satisfies a wait all and performs any side effects that
    are necessary.

Arguments:

    WaitBlock - Supplies a pointer to a wait block.

Return Value:

    None.

--*/

{

    PKMUTANT Object;
    PRKTHREAD Thread;
    PRKWAIT_BLOCK WaitBlock1;

    //
    // If the wait type was WaitAny, then perform neccessary side effects on
    // the object specified by the wait block. Else perform necessary side
    // effects on all the objects that were involved in the wait operation.
    //

    WaitBlock1 = WaitBlock;
    Thread = WaitBlock1->Thread;
    do {
        if (WaitBlock1->WaitKey != (CSHORT)STATUS_TIMEOUT) {
            Object = (PKMUTANT)WaitBlock1->Object;
            KiWaitSatisfyAny(Object, Thread);
        }

        WaitBlock1 = WaitBlock1->NextWaitBlock;
    } while (WaitBlock1 != WaitBlock);

    return;
}

VOID
FASTCALL
KiWaitTest (
    IN PVOID Object,
    IN KPRIORITY Increment
    )

/*++

Routine Description:

    This function tests if a wait can be satisfied when an object attains
    a state of signaled. If a wait can be satisfied, then the subject thread
    is unwaited with a completion status that is the WaitKey of the wait
    block from the object wait list. As many waits as possible are satisfied.

Arguments:

    Object - Supplies a pointer to a dispatcher object.

Return Value:

    None.

--*/

{

    PKEVENT Event;
    PLIST_ENTRY ListHead;
    PRKWAIT_BLOCK NextBlock;
    PKMUTANT Mutant;
    LIST_ENTRY ReadyList;
    PRKTHREAD Thread;
    PLIST_ENTRY ThreadEntry;
    PRKWAIT_BLOCK WaitBlock;
    PLIST_ENTRY WaitEntry;
    NTSTATUS WaitStatus;

    //
    // As long as the signal state of the specified object is Signaled and
    // there are waiters in the object wait list, then try to satisfy a wait.
    //

    Event = (PKEVENT)Object;
    ListHead = &Event->Header.WaitListHead;
    WaitEntry = ListHead->Flink;
    InitializeListHead(&ReadyList);
    while ((Event->Header.SignalState > 0) &&
           (WaitEntry != ListHead)) {

        WaitBlock = CONTAINING_RECORD(WaitEntry, KWAIT_BLOCK, WaitListEntry);
        Thread = WaitBlock->Thread;
        WaitStatus = STATUS_KERNEL_APC;

        //
        // N.B. The below code only satisfies the wait for wait any types.
        //      Wait all types are satisfied in the wait code itself. This
        //      is done with a eye to the future when the dispatcher lock is
        //      split into a lock per waitable object type and a scheduling
        //      state lock. For now, a kernel APC is simulated for wait all
        //      types.
        //

        if (WaitBlock->WaitType == WaitAny) {
            WaitStatus = (NTSTATUS)WaitBlock->WaitKey;
            KiWaitSatisfyAny((PKMUTANT)Event, Thread);
        }

        KiUnwaitThread(Thread, WaitStatus, Increment, &ReadyList);
        WaitEntry = ListHead->Flink;
    }

    //
    // Ready any threads which have been made eligible to run. This
    // must be done AFTER the event is no longer needed to avoid running
    // the thread which owns the event before this routine is finished
    // looking at it.
    //

    while (!IsListEmpty(&ReadyList)) {
        ThreadEntry = RemoveHeadList(&ReadyList);
        Thread = CONTAINING_RECORD(ThreadEntry, KTHREAD, WaitListEntry);
        KiReadyThread(Thread);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\yield.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    yield.c

Abstract:

    This module implements the function to yield execution for one quantum
    to any other runnable thread.

Author:

    David N. Cutler (davec) 15-Mar-1996

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

NTSTATUS
NtYieldExecution (
    VOID
    )

/*++

Routine Description:

    This function yields execution to any ready thread for up to one
    quantum.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PRKPRCB Prcb;
    KPRIORITY Priority;
    NTSTATUS Status;
    PRKTHREAD Thread;

    //
    // If any other threads are ready, then attempt to yield execution.
    //

    Status = STATUS_NO_YIELD_PERFORMED;
    if (KiReadySummary != 0) {

        //
        // If a thread has not already been selected for execution, then
        // attempt to select another thread for execution.
        //

        Thread = KeGetCurrentThread();
        KiLockDispatcherDatabase(&Thread->WaitIrql);
        Prcb = KeGetCurrentPrcb();
        if (Prcb->NextThread == NULL) {
            Prcb->NextThread = KiFindReadyThread(Thread->NextProcessor, 1);
        }

        //
        // If a new thread has been selected for execution, then switch
        // immediately to the selected thread.
        //

        if (Prcb->NextThread != NULL) {

            //
            // Give the current thread a new quantum, simulate a quantum
            // end, insert the current thread in the appropriate ready list,
            // and switch context to selected thread.
            //

            Thread->Quantum = Thread->ApcState.Process->ThreadQuantum;
            Thread->State = Ready;
            Priority = Thread->Priority;
            if (Priority < LOW_REALTIME_PRIORITY) {
                Priority = Priority - Thread->PriorityDecrement - 1;
                if (Priority < Thread->BasePriority) {
                    Priority = Thread->BasePriority;
                }

                Thread->PriorityDecrement = 0;

            }

            Thread->Priority = (SCHAR)Priority;

            InsertTailList(&KiDispatcherReadyListHead[Priority],
                           &Thread->WaitListEntry);

            SetMember(Priority, KiReadySummary);
            KiSwapThread();
            Status = STATUS_SUCCESS;

        } else {
            KiUnlockDispatcherDatabase(Thread->WaitIrql);
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\alignem.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Digital Equipment Corporation

Module Name:

    alignem.c

Abstract:

    This module implements the code necessary to emulate unaligned data
    references.

Author:

    David N. Cutler (davec) 17-Jun-1991
    Joe Notarangelo         14-May-1992

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Function prototypes for emulation routines
//
ULONGLONG
KiEmulateLoadLong(
   IN PULONG UnalignedAddress
   );

ULONGLONG
KiEmulateLoadQuad(
   IN PUQUAD UnalignedAddress
   );

ULONGLONG
KiEmulateLoadFloatIEEESingle(
   IN PULONG UnalignedAddress
   );

ULONGLONG
KiEmulateLoadFloatIEEEDouble(
   IN PUQUAD UnalignedAddress
   );

VOID
KiEmulateStoreLong(
   IN PULONG UnalignedAddress,
   IN ULONGLONG  Data
   );

VOID
KiEmulateStoreQuad(
   IN PUQUAD UnalignedAddress,
   IN ULONGLONG Data
   );

VOID
KiEmulateStoreFloatIEEESingle(
   IN PULONG UnalignedAddress,
   IN ULONGLONG  Data
   );

VOID
KiEmulateStoreFloatIEEEDouble(
   IN PUQUAD UnalignedAddress,
   IN ULONGLONG  Data
   );

VOID
KiEnablePALAlignmentFixups(
    VOID
    );

VOID
KiDisablePALAlignmentFixups(
    VOID
    );

VOID
KiProfileInterrupt(
   IN KPROFILE_SOURCE ProfileSource,
   IN PKTRAP_FRAME TrapFrame
   );


VOID
KiEnableAlignmentExceptions(
    VOID
    )
/*++

Routine Description:

    Enables alignment exceptions on the current processor by
    disabling automatic PAL code alignment fixups. PAL is
    called to turn off automatic fixups only if CPU is
    21164 or greater.

Arguments:

    None

Return Value:

    None

--*/

{
    if (KeProcessorLevel >= PROCESSOR_ALPHA_21164) {
        KiDisablePALAlignmentFixups();
    }
}


VOID
KiDisableAlignmentExceptions(
    VOID
    )
/*++

Routine Description:

    Disables alignment exceptions on the current processor by
    enabling automatic PAL code alignment fixups. PAL is
    called to turn on automatic fixups only if CPU is
    21164 or greater and KiEnableAlignmentFaultExceptions==0

    If KiEnableAlignmentFaultExceptions is either 1 or 2, then
    the kernel always needs to see alignment faults, so PAL
    automatic alignment fixups should not be enabled

Arguments:

    None

Return Value:

    None

--*/

{
    if ((KeProcessorLevel >= PROCESSOR_ALPHA_21164) &&
        (KiEnableAlignmentFaultExceptions == 0)) {
        KiEnablePALAlignmentFixups();
    }
}


BOOLEAN
KiEmulateReference (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PKEXCEPTION_FRAME  ExceptionFrame,
    IN OUT PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    Routine emulates an unaligned data reference from user part
    of the address space.

Arguments:

    ExceptionRecord - Supplies a pointer to the exception record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame

Return Value:

    True is returned if reference is successfully emulated,
    otherwise False is returned.

--*/

{

    ULONGLONG Data;
    PVOID  EffectiveAddress;
    PVOID  ExceptionAddress;
    ULONG  Fa;
    ULONG  Opcode;
    KPROCESSOR_MODE PreviousMode;
    ULONG  Ra;
    KIRQL  OldIrql;

    //
    // Call out to profile interrupt if alignment profiling is active
    //
    if (KiProfileAlignmentFixup) {

        if (++KiProfileAlignmentFixupCount >= KiProfileAlignmentFixupInterval) {

            KeRaiseIrql(PROFILE_LEVEL, &OldIrql);
            KiProfileAlignmentFixupCount = 0;
            KiProfileInterrupt(ProfileAlignmentFixup, TrapFrame);
            KeLowerIrql(OldIrql);

        }
    }

    //
    // Save original exception address in case another exception occurs
    //

    ExceptionAddress = ExceptionRecord->ExceptionAddress;

    //
    // The ExceptionInformation in the ExceptionRecord has already
    // recorded information we need to emulate the access.
    //
    // ExceptionInformation:
    //                [0]   =  opcode
    //                [1]   =  destination register
    //                [2]   =  effective address of access

    Opcode = (ULONG)ExceptionRecord->ExceptionInformation[0];
    Ra = (ULONG)ExceptionRecord->ExceptionInformation[1];
    Fa = Ra + 32;     // convert to floating register name for floating opcodes
    EffectiveAddress = (PVOID)ExceptionRecord->ExceptionInformation[2];

    //
    // Capture previous mode from trap frame not current thread.
    //

    PreviousMode = (KPROCESSOR_MODE)(((PSR *)(&TrapFrame->Psr))->MODE);

    //
    // Any exception that occurs during the attempted emulation will cause
    // the emulation to be aborted.  The new exception code and information
    // will be copied to the original exception record and FALSE will be
    // returned.  If the unaligned access was not from kernel mode then
    // probe the effective address before performing the emulation.
    //

    try {

        switch (Opcode) {

        //
        // load longword
        //

        case LDL_OP:
            if( PreviousMode != KernelMode ){
                ProbeForRead( EffectiveAddress,
                              sizeof(LONG),
                              sizeof(UCHAR) );
            }
            Data = KiEmulateLoadLong( EffectiveAddress );
            KiSetRegisterValue( Ra,
                                Data,
                                ExceptionFrame,
                                TrapFrame );

            break;

        //
        // load quadword
        //

        case LDQ_OP:
            if( PreviousMode != KernelMode ){
                ProbeForRead( EffectiveAddress,
                              sizeof(LONGLONG),
                              sizeof(UCHAR) );
            }
            Data = KiEmulateLoadQuad( EffectiveAddress );
            KiSetRegisterValue( Ra,
                                Data,
                                ExceptionFrame,
                                TrapFrame );

            break;

        //
        // load IEEE single float
        //

        case LDS_OP:
            if( PreviousMode != KernelMode ){
                ProbeForRead( EffectiveAddress,
                              sizeof(float),
                              sizeof(UCHAR) );
            }
            Data = KiEmulateLoadFloatIEEESingle( EffectiveAddress );
            KiSetRegisterValue( Fa,
                                Data,
                                ExceptionFrame,
                                TrapFrame );

            break;

        //
        // load IEEE double float
        //

        case LDT_OP:
            if( PreviousMode != KernelMode ){
                ProbeForRead( EffectiveAddress,
                              sizeof(DOUBLE),
                              sizeof(UCHAR) );
            }
            Data = KiEmulateLoadFloatIEEEDouble( EffectiveAddress );
            KiSetRegisterValue( Fa,
                                Data,
                                ExceptionFrame,
                                TrapFrame );

            break;

        //
        // Load word unsigned.
        //

        case LDWU_OP :
            if (PreviousMode != KernelMode) {
                ProbeForRead(EffectiveAddress,
                             sizeof(SHORT),
                             sizeof(UCHAR));
            }
            Data = (ULONGLONG)*(UNALIGNED USHORT *)EffectiveAddress;
            KiSetRegisterValue(Ra,
                               Data,
                               ExceptionFrame,
                               TrapFrame);

            break;

        //
        // store longword
        //

        case STL_OP:
            if( PreviousMode != KernelMode ){
                ProbeForWrite( EffectiveAddress,
                               sizeof(LONG),
                               sizeof(UCHAR) );
            }
            Data = KiGetRegisterValue( Ra,
                                       ExceptionFrame,
                                       TrapFrame );
            KiEmulateStoreLong( EffectiveAddress, (ULONG)Data );

            break;

        //
        // store quadword
        //

        case STQ_OP:
            if( PreviousMode != KernelMode ){
                ProbeForWrite( EffectiveAddress,
                               sizeof(LONGLONG),
                               sizeof(UCHAR) );
            }
            Data = KiGetRegisterValue( Ra,
                                       ExceptionFrame,
                                       TrapFrame );
            KiEmulateStoreQuad( EffectiveAddress, Data );

            break;

        //
        // store IEEE float single
        //

        case STS_OP:
            if( PreviousMode != KernelMode ){
                ProbeForWrite( EffectiveAddress,
                               sizeof(float),
                               sizeof(UCHAR) );
            }
            Data = KiGetRegisterValue( Fa,
                                       ExceptionFrame,
                                       TrapFrame );
            KiEmulateStoreFloatIEEESingle( EffectiveAddress, Data );

            break;

        //
        // store IEEE float double
        //

        case STT_OP:
            if( PreviousMode != KernelMode ){
                ProbeForWrite( EffectiveAddress,
                               sizeof(DOUBLE),
                               sizeof(UCHAR) );
            }
            Data = KiGetRegisterValue( Fa,
                                       ExceptionFrame,
                                       TrapFrame );
            KiEmulateStoreFloatIEEEDouble( EffectiveAddress, Data );

            break;

        //
        // Store word.
        //

        case STW_OP :
            if (PreviousMode != KernelMode) {
                ProbeForWrite(EffectiveAddress,
                              sizeof(SHORT),
                              sizeof(UCHAR));
            }
            Data = KiGetRegisterValue(Ra,
                                      ExceptionFrame,
                                      TrapFrame);
            *(UNALIGNED USHORT *)EffectiveAddress = (USHORT)Data;

            break;

        //
        // all other instructions are not emulated
        //

        default:
            return FALSE;
        }

        TrapFrame->Fir += 4;
        return TRUE;

    } except (KiCopyInformation(ExceptionRecord,
                                (GetExceptionInformation())->ExceptionRecord)) {

        //
        // Preserve the original exception address
        //

        ExceptionRecord->ExceptionAddress = ExceptionAddress;

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\allproc.c ===
/*++

Copyright (c) 1990  Microsoft Corporation
Copyright (c) 1993  Digital Equipment Corporation

Module Name:

    allproc.c

Abstract:

    This module allocates and initializes kernel resources required
    to start a new processor, and passes a complete processor state
    structure to the HAL to obtain a new processor.

Author:

    David N. Cutler 29-Apr-1993
    Joe Notarangelo 30-Nov-1993

Environment:

    Kernel mode only.

Revision History:

--*/


#include "ki.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, KeStartAllProcessors)
#pragma alloc_text(INIT, KiAllProcessorsStarted)

#endif

#if defined(KE_MULTINODE)

PHALNUMAQUERYNODEAFFINITY KiQueryNodeAffinity;

//
// Statically preallocate enough KNODE structures to allow MM
// to allocate pages by node during system initialization.  As
// processors are brought online, real KNODE structures are
// allocated in the appropriate memory for the node.
//
// This statically allocated set will be deallocated once the
// system is initialized.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#endif

KNODE KiNodeInit[MAXIMUM_CCNUMA_NODES];

#endif

//
// Define macro to round up to 64-byte boundary and define block sizes.
//

#define ROUND_UP(x) ((sizeof(x) + 64) & (~64))
#define BLOCK1_SIZE ((3 * KERNEL_STACK_SIZE) + PAGE_SIZE)
#define BLOCK2_SIZE (ROUND_UP(KPRCB) + ROUND_UP(KNODE) + ROUND_UP(ETHREAD) + 64)

//
// Macros to compute whether an address is physically addressable.
//

#if defined(_AXP64_)

#define IS_KSEG_ADDRESS(v)                                      \
    (((v) >= KSEG43_BASE) &&                                    \
     ((v) < KSEG43_LIMIT) &&                                    \
     (KSEG_PFN(v) < ((KSEG2_BASE - KSEG0_BASE) >> PAGE_SHIFT)))

#define KSEG_PFN(v) ((ULONG)(((v) - KSEG43_BASE) >> PAGE_SHIFT))
#define KSEG0_ADDRESS(v) (KSEG0_BASE | ((v) - KSEG43_BASE))

#else

#define IS_KSEG_ADDRESS(v) (((v) >= KSEG0_BASE) && ((v) < KSEG2_BASE))
#define KSEG_PFN(v) ((ULONG)(((v) - KSEG0_BASE) >> PAGE_SHIFT))
#define KSEG0_ADDRESS(v) (v)

#endif

//
// Define forward referenced prototypes.
//

VOID
KiStartProcessor (
    IN PLOADER_PARAMETER_BLOCK Loaderblock
    );

VOID
KeStartAllProcessors(
    VOID
    )

/*++

Routine Description:

    This function is called during phase 1 initialization on the master boot
    processor to start all of the other registered processors.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    ULONG_PTR MemoryBlock1;
    ULONG_PTR MemoryBlock2;
    ULONG Number;
    ULONG PcrPage;
    PKPRCB Prcb;
    KPROCESSOR_STATE ProcessorState;
    struct _RESTART_BLOCK *RestartBlock;
    BOOLEAN Started;
    LOGICAL SpecialPoolState;
    UCHAR NodeNumber = 0;

#if defined(KE_MULTINODE)

    KAFFINITY NewProcessorAffinity;
    PKNODE Node;
    NTSTATUS Status;

    //
    // If this is a NUMA system, find out the number of nodes and the
    // processors which belong to each node.
    //

    if (KeNumberNodes > 1) {
        for (NodeNumber = 0; NodeNumber < KeNumberNodes; NodeNumber++) {

            Node = KeNodeBlock[NodeNumber];

            //
            // Ask HAL which processors belong to this node and
            // what Node Color to use for page coloring.
            //

            Status = KiQueryNodeAffinity(NodeNumber,
                                         &Node->ProcessorMask);

            if (!NT_SUCCESS(Status)) {
                DbgPrint(
                    "KE/HAL: NUMA Hal failed to return info for Node %i.\n",
                    NodeNumber);
                DbgPrint("KE/HAL: Reverting to non NUMA configuration.\n");
                ASSERT(NT_SUCCESS(Status));
                KeNumberNodes = 1;
            } else {

                //
                // In the unlikely event that processor 0 is not
                // on node 0, now would be the perfect time to
                // fix it.
                //

                if (Node->ProcessorMask & 1) {
                    KeGetCurrentPrcb()->ParentNode = Node;
                }
            }
        }
    }

#endif

    //
    // If the registered number of processors is greater than the maximum
    // number of processors supported, then only allow the maximum number
    // of supported processors.
    //

    if (KeRegisteredProcessors > MAXIMUM_PROCESSORS) {
        KeRegisteredProcessors = MAXIMUM_PROCESSORS;
    }

    //
    // Initialize the processor state that will be used to start each of
    // processors. Each processor starts in the system initialization code
    // with address of the loader parameter block as an argument.
    //

    RtlZeroMemory(&ProcessorState, sizeof(KPROCESSOR_STATE));
    ProcessorState.ContextFrame.IntA0 = (ULONGLONG)(LONG_PTR)KeLoaderBlock;
    ProcessorState.ContextFrame.Fir = (ULONGLONG)(LONG_PTR)KiStartProcessor;
    Number = 1;
    while (Number < KeRegisteredProcessors) {

#if defined(KE_MULTINODE)

        NewProcessorAffinity = 1 << Number;

        for (NodeNumber = 0; NodeNumber < KeNumberNodes; NodeNumber++) {
            Node = KeNodeBlock[NodeNumber];
            if (Node->ProcessorMask & NewProcessorAffinity) {
                break;
            }
        }

        if (NodeNumber == KeNumberNodes) {

            //
            // This should only happen when we're about to ask
            // for one processor more than is in the system.  We
            // could bail here but we have always depended on
            // the HAL to tell us we're done.   Set up as if
            // on Node 0 so MM and friends won't be referencing
            // uninitialized structures.
            //

            NodeNumber = 0;
            Node = KeNodeBlock[0];
        }

#endif

        //
        // Allocate a DPC stack, an idle thread kernel stack, a panic
        // stack, a PCR page, a processor block, and an executive thread
        // object. If the allocation fails or the allocation cannot be
        // made from unmapped nonpaged pool, then stop starting processors.
        //
        // Disable any special pooling that the user may have set in the
        // registry as the next couple of allocations must come from KSEG0.
        //

        SpecialPoolState = MmSetSpecialPool(FALSE);
        MemoryBlock1 = (ULONG_PTR)ExAllocatePool(NonPagedPool, BLOCK1_SIZE);
        if (IS_KSEG_ADDRESS(MemoryBlock1) == FALSE) {
            MmSetSpecialPool(SpecialPoolState);
            if ((PVOID)MemoryBlock1 != NULL) {
                ExFreePool((PVOID)MemoryBlock1);
            }

            break;
        }

        MemoryBlock2 = (ULONG_PTR)ExAllocatePool(NonPagedPool, BLOCK2_SIZE);
        if (IS_KSEG_ADDRESS(MemoryBlock2) == FALSE) {
            MmSetSpecialPool(SpecialPoolState);
            ExFreePool((PVOID)MemoryBlock1);
            if ((PVOID)MemoryBlock2 != NULL) {
                ExFreePool((PVOID)MemoryBlock2);
            }

            break;
        }

        MmSetSpecialPool(SpecialPoolState);

        //
        // Zero both blocks of allocated memory.
        //

        RtlZeroMemory((PVOID)MemoryBlock1, BLOCK1_SIZE);
        RtlZeroMemory((PVOID)MemoryBlock2, BLOCK2_SIZE);

        //
        // Set address of interrupt stack in loader parameter block.
        //

        KeLoaderBlock->u.Alpha.PanicStack =
                        KSEG0_ADDRESS(MemoryBlock1 + (1 * KERNEL_STACK_SIZE));

        //
        // Set address of idle thread kernel stack in loader parameter block.
        //

        KeLoaderBlock->KernelStack =
                        KSEG0_ADDRESS(MemoryBlock1 + (2 * KERNEL_STACK_SIZE));

        ProcessorState.ContextFrame.IntSp =
                            (ULONGLONG)(LONG_PTR)KeLoaderBlock->KernelStack;

        //
        // Set address of panic stack in loader parameter block.
        //

        KeLoaderBlock->u.Alpha.DpcStack =
                        KSEG0_ADDRESS(MemoryBlock1 + (3 * KERNEL_STACK_SIZE));

        //
        // Set the page frame of the PCR page in the loader parameter block.
        //

        PcrPage = KSEG_PFN(MemoryBlock1 + (3 * KERNEL_STACK_SIZE));
        KeLoaderBlock->u.Alpha.PcrPage = PcrPage;

        //
        // Set the address of the processor block and executive thread in the
        // loader parameter block.
        //

        KeLoaderBlock->Prcb = KSEG0_ADDRESS((MemoryBlock2  + 63) & ~63);
        KeLoaderBlock->Thread = KeLoaderBlock->Prcb +
                                ROUND_UP(KPRCB) +
                                ROUND_UP(KNODE);

#if defined(KE_MULTINODE)

        //
        // If this is the first processor on this node, use the
        // space allocated for KNODE as the KNODE.
        //

        if (KeNodeBlock[NodeNumber] == &KiNodeInit[NodeNumber]) {
            Node = (PKNODE)(KeLoaderBlock->Prcb + ROUND_UP(KPRCB));
            *Node = KiNodeInit[NodeNumber];
            KeNodeBlock[NodeNumber] = Node;
        }

        ((PKPRCB)KeLoaderBlock->Prcb)->ParentNode = Node;

#else

        ((PKPRCB)KeLoaderBlock->Prcb)->ParentNode = KeNodeBlock[0];

#endif

        //
        // Attempt to start the next processor. If attempt is successful,
        // then wait for the processor to get initialized. Otherwise,
        // deallocate the processor resources and terminate the loop.
        //

        Started = HalStartNextProcessor(KeLoaderBlock, &ProcessorState);
        if (Started == FALSE) {
            ExFreePool((PVOID)MemoryBlock1);
            ExFreePool((PVOID)MemoryBlock2);
            break;

        } else {

            //
            // Wait until boot is finished on the target processor before
            // starting the next processor. Booting is considered to be
            // finished when a processor completes its initialization and
            // drops into the idle loop.
            //

            Prcb = (PKPRCB)(KeLoaderBlock->Prcb);
            RestartBlock = Prcb->RestartBlock;
            while (RestartBlock->BootStatus.BootFinished == 0) {
                KiMb();
            }
        }

        Number += 1;
    }
    //
    //
    // All processors have been stated.
    //

    KiAllProcessorsStarted();

#endif

    //
    // Reset and synchronize the performance counters of all processors, by
    // applying a null adjustment to the interrupt time
    //

    KiAdjustInterruptTime(0);
    return;
}

#if !defined(NT_UP)
VOID
KiAllProcessorsStarted(
    VOID
    )

/*++

Routine Description:

    This routine is called once all processors in the system
    have been started.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG i;

#if defined(KE_MULTINODE)

    //
    // Make sure there are no references to the temporary nodes
    // used during initialization.
    //

    for (i = 0; i < KeNumberNodes; i++) {
        if (KeNodeBlock[i] == &KiNodeInit[i]) {

            //
            // No processor started on this node so no new node
            // structure has been allocated.   This is possible
            // if the node contains only memory or IO busses.  At
            // this time we need to allocate a permanent node
            // structure for the node.
            //

            KeNodeBlock[i] = ExAllocatePoolWithTag(NonPagedPool,
                                                   sizeof(KNODE),
                                                   '  eK');
            if (KeNodeBlock[i]) {
                *KeNodeBlock[i] = KiNodeInit[i];
            }
        }
    }

    for (i = KeNumberNodes; i < MAXIMUM_CCNUMA_NODES; i++) {
        KeNodeBlock[i] = NULL;
    }

#endif

    if (KeNumberNodes == 1) {

        //
        // For Non NUMA machines, Node 0 gets all processors.
        //

        KeNodeBlock[0]->ProcessorMask = KeActiveProcessors;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\buserror.c ===
/*++

Copyright (c) 1993  Digital Equipment Corporation

Module Name:

    buserror.c

Abstract:

    This module implements the code necessary to process machine checks.

Author:

    Joe Notarangelo 11-Feb-1993

Environment:

    Kernel mode only.

Revision History:


--*/

#include "ki.h"



VOID
KiMachineCheck (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to process a machine check.  If the vendor
    has supplied a machine check handler with its HAL then the machine
    check handler is called.  If the routine returns TRUE indicating
    that the error has been handled then execution resumes, otherwise,
    a bugcheck is raised.

    If no machine check handler is registered or it does not indicate
    that the error has been handled, then this routine will attempt
    default handling.  Default handling consists of checking the
    machine check status in the exception record.  If the status indicates
    that the machine check is correctable or retryable then return and
    resume execution, otherwise a bugcheck is raised.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    None.

--*/

{

    if( ((ULONG_PTR)PCR->MachineCheckError != 0) &&
          (PCR->MachineCheckError)(ExceptionRecord,
                                   ExceptionFrame,
                                   TrapFrame) ) {

        //
        // The HAL has handled the error.
        //

        return;

    } else {

        //
        // Either there is no HAL handler, or it did not handle the
        // error.
        //

        if( ExceptionRecord->ExceptionInformation[0] != 0 ){

            //
            // The error is either correctable or retryable, resume
            // execution.
            //

#if DBG

            DbgPrint( "MCHK: resuming correctable or retryable error\n" );

#endif //DBG

            return;

        }
    }


    //
    // The error was not handled and is not correctable or retryable.
    //

    KeBugCheck(DATA_BUS_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\xipi.c ===
/*++

Copyright (c) 1993-1995  Microsoft Corporation

Module Name:

    xipi.c

Abstract:

    This module implements portable interprocessor interrup routines.

Author:

    David N. Cutler (davec) 24-Apr-1993

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Define forward reference function prototypes.
//

VOID
KiIpiGenericCallTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID BroadcastFunction,
    IN PVOID Context,
    IN PVOID Parameter3
    );

ULONG_PTR
KiIpiGenericCall (
    IN PKIPI_BROADCAST_WORKER BroadcastFunction,
    IN ULONG_PTR Context
    )

/*++

Routine Description:

    This function executes the specified function on every processor in
    the host configuration in a synchronous manner, i.e., the function
    is executed on each target in series with the execution of the source
    processor.

Arguments:

    BroadcastFunction - Supplies the address of function that is executed
        on each of the target processors.

    Context - Supplies the value of the context parameter that is passed
        to each function.

Return Value:

    The value returned by the specified function on the source processor
    is returned as the function value.

--*/

{

    KIRQL OldIrql;
    ULONG_PTR Status;
    KAFFINITY TargetProcessors;

    //
    // Raise IRQL to the higher of the current level and synchronization
    // level to avoid a possible context switch.
    //

    KeRaiseIrql((KIRQL)(max(KiSynchIrql, KeGetCurrentIrql())), &OldIrql);

    //
    // Initialize the broadcast packet, compute the set of target processors,
    // and sent the packet to the target processors for execution.
    //

#if !defined(NT_UP)

    TargetProcessors = KeActiveProcessors & ~KeGetCurrentPrcb()->SetMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiIpiGenericCallTarget,
                        (PVOID)BroadcastFunction,
                        (PVOID)Context,
                        NULL);
    }

#endif

    //
    // Execute function of source processor and capture return status.
    //

    Status = BroadcastFunction(Context);

    //
    // Wait until all of the target processors have finished capturing the
    // function parameters.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    //
    // Lower IRQL to its previous level and return the function execution
    // status.
    //

    KeLowerIrql(OldIrql);
    return Status;
}

#if !defined(NT_UP)


VOID
KiIpiGenericCallTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID BroadcastFunction,
    IN PVOID Context,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This function is the target jacket function to execute a broadcast
    function on a set of target processors. The broadcast packet address
    is obtained, the specified parameters are captured, the broadcast
    packet address is cleared to signal the source processor to continue,
    and the specified function is executed.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    BroadcastFunction - Supplies the address of function that is executed
        on each of the target processors.

    Context - Supplies the value of the context parameter that is passed
        to each function.

    Parameter3 - Not used.

Return Value:

    None

--*/

{

    //
    // Execute the specified function.
    //

    ((PKIPI_BROADCAST_WORKER)(BroadcastFunction))((ULONG_PTR)Context);
    KiIpiSignalPacketDone(SignalDone);
    return;
}



VOID
KiIpiStallOnPacketTargets (
    KAFFINITY TargetSet
    )

/*++

Routine Description:

    This function waits until the specified set of processors have signaled
    their completion of a requested function.

    N.B. The exact protocol used between the source and the target of an
         interprocessor request is not specified. Minimally the source
         must construct an appropriate packet and send the packet to a set
         of specified targets. Each target receives the address of the packet
         address as an argument, and minimally must clear the packet address
         when the mutually agreed upon protocol allows. The target has three
         options:

         1. Capture necessary information, release the source by clearing
            the packet address, execute the request in parallel with the
            source, and return from the interrupt.

         2. Execute the request in series with the source, release the
            source by clearing the packet address, and return from the
            interrupt.

         3. Execute the request in series with the source, release the
            source, wait for a reply from the source based on a packet
            parameter, and return from the interrupt.

    This function is provided to enable the source to synchronize with the
    target for cases 2 and 3 above.

    N.B. There is no support for method 3 above.

Arguments:

    TargetSet - Supplies the the target set of IPI processors.

Return Value:

    None.

--*/

{

    volatile ULONG *Barrier;
    PKPRCB Prcb;

    //
    // Wait until the target set of processors is zero in the current
    // processor's packet.
    //

    Prcb = KeGetCurrentPrcb();

    //
    // If there is one and only one bit set in the target set, then wait
    // on the target set. Otherwise, wait on the packet barrier.
    //

    Barrier = (volatile ULONG *)&Prcb->TargetSet;
    if ((TargetSet & (TargetSet - 1)) != 0) {
       Barrier = &Prcb->PacketBarrier;
    }

    while (*Barrier != 0) {
        KeYieldProcessor();
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\apcuser.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    apcuser.c

Abstract:

    This module implements the machine dependent code necessary to initialize
    a user mode APC.

Author:

    David N. Cutler (davec) 23-Apr-1990

Environment:

    Kernel mode only, IRQL APC_LEVEL.

Revision History:

    Thomas Van Baak (tvb) 13-May-1992

        Adapted for Alpha AXP.

--*/

#include "ki.h"

VOID
KiInitializeUserApc (
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN PKNORMAL_ROUTINE NormalRoutine,
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called to initialize the context for a user mode APC.

Arguments:

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    NormalRoutine - Supplies a pointer to the user mode APC routine.

    NormalContext - Supplies a pointer to the user context for the APC
        routine.

    SystemArgument1 - Supplies the first system supplied value.

    SystemArgument2 - Supplies the second system supplied value.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord;
    EXCEPTION_RECORD ExceptionRecord;
    LONG_PTR Length;
    ULONG_PTR UserStack;

    //
    // Move the user mode state from the trap and exception frames to the
    // context frame.
    //

    ContextRecord.ContextFlags = CONTEXT_FULL;
    KeContextFromKframes(TrapFrame, ExceptionFrame, &ContextRecord);

    //
    // Transfer the context information to the user stack, initialize the
    // APC routine parameters, and modify the trap frame so execution will
    // continue in user mode at the user mode APC dispatch routine.
    //

    try {

        //
        // Compute length of context record and new aligned user stack pointer.
        //

        Length = (sizeof(CONTEXT) + 15) & (~15);
        UserStack = ((ULONG_PTR)ContextRecord.IntSp & (~15)) - Length;

        //
        // Probe user stack area for writeability and then transfer the
        // context record to the user stack.
        //

        ProbeForWrite((PVOID)UserStack, (ULONG)Length, sizeof(QUAD));
        RtlMoveMemory((PVOID)UserStack, &ContextRecord, sizeof(CONTEXT));

        //
        // Set the address of the user APC routine, the APC parameters, the
        // new frame pointer, and the new stack pointer in the current trap
        // frame. Set the continuation address so control will be transferred
        // to the user APC dispatcher.
        //
        // N.B. It is not possible to pass 64 bit arguments to the routine.
        // N.B. ULONG becomes canonical longword with (ULONGLONG)(LONG) cast.
        //
        //

        TrapFrame->IntSp = (ULONGLONG)(LONG_PTR)UserStack;
        TrapFrame->IntFp = (ULONGLONG)(LONG_PTR)UserStack;
        TrapFrame->IntA0 = (ULONGLONG)(LONG_PTR)NormalContext;
        TrapFrame->IntA1 = (ULONGLONG)(LONG_PTR)SystemArgument1;
        TrapFrame->IntA2 = (ULONGLONG)(LONG_PTR)SystemArgument2;
        TrapFrame->IntA3 = (ULONGLONG)(LONG_PTR)NormalRoutine;
        TrapFrame->Fir = (ULONGLONG)(LONG_PTR)KeUserApcDispatcher;

    //
    // If an exception occurs, then copy the exception information to an
    // exception record and handle the exception.
    //

    } except (KiCopyInformation(&ExceptionRecord,
                                (GetExceptionInformation())->ExceptionRecord)) {

        //
        // Set the address of the exception to the current program address
        // and raise the exception by calling the exception dispatcher.
        //

        ExceptionRecord.ExceptionAddress = (PVOID)(TrapFrame->Fir);
        KiDispatchException(&ExceptionRecord,
                            ExceptionFrame,
                            TrapFrame,
                            UserMode,
                            TRUE);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\byteme.s ===
//  TITLE("Byte and Short Emulation")
//++
//
//
// Copyright (c) 1995  Digital Equipment Corporation
//
// Module Name:
//
//    byteme.s
//
// Abstract:
//
//    This module implements the code to perform atomic store operations
//    on bytes and shorts (words).
//
//    Atomic byte and short opcodes have been added into the Alpha
//    architecture as of Alpha 21164A or EV56. In chips 21164 and prior,
//    an illegal instruction will occur and an exception will lead them here.
//
// Author:
//
//    Wim Colgate, May 18th, 1995
//    Tom Van Baak, May 18th, 1995
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

//++
//
// VOID
// KiInterlockedStoreByte(
//    IN PUCHAR Address,
//    IN UCHAR  Data
//    )
//
// Routine Description:
//
//    This routine stores the data byte specified by Data to the location
//    specified by Address. The architecture requires byte granularity,
//    so locking is necessary.
//
// Arguments:
//
//    Address(a0) - Supplies a pointer to byte data value.
//    Data(a1) - Supplied the byte data value to store.
//
// Return Value:
//
//    None
//
//--

        LEAF_ENTRY(KiInterlockedStoreByte)

        bic     a0, 3, t0               // clear low 2 bits
        and     a0, 3, t1               // mask of three low bits
10:     ldl_l   t2, 0(t0)               // load locked full longword
        insbl   a1, t1, t3              // insert byte low
        mskbl   t2, t1, t2              // mask byte low
        bis     t2, t3, t2              // merge data
        stl_c   t2, 0(t0)               // store conditional
        beq     t2, 20f                 // failed to store, retry, forward
        ret     zero, (ra), 1           // return

20:     br      zero, 10b               // try again

        .end    KiInterlockedStoreByte

//++
//
// VOID
// KiInterlockedStoreWord(
//    IN PUSHORT Address,
//    IN USHORT Data
//    )
//
// Routine Description:
//
//    This routine stores the short data specified by Data to the aligned
//    location specified by Address. The architecture requires word granularity,
//    so locking is necessary.
//
// Arguments:
//
//    Address(a0) - Supplies a pointer to an aligned short data value.
//    Data(a1) - Supplied the short data value to store.
//
// Return Value:
//
//    None
//
//--

        LEAF_ENTRY(KiInterlockedStoreWord)

        bic     a0, 2, t0               // clear low short address bit
        and     a0, 2, t1               // mask of low short address bit
10:     ldl_l   t2, 0(t0)               // load locked full longword
        inswl   a1, t1, t3              // insert word low
        mskwl   t2, t1, t2              // mask word low
        bis     t2, t3, t2              // merge data
        stl_c   t2, 0(t0)               // store conditional
        beq     t2, 20f                 // failed to store, retry, forward
        ret     zero, (ra), 1           // return

20:     br      zero, 10b               // try again

        .end    KiInterlockedStoreWord

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\byteem.c ===
/*++

Copyright (c) 1995  Digital Equipment Corporation

Module Name:

    byteem.c

Abstract:

    This module implements the code necessary to emulate the new set of Alpha
    byte and word instructions defined by ECO 81.

    N.B. This file must be compiled without the use of byte/word instructions
         to avoid fatal recursive exceptions.

Author:

    Wim Colgate (colgate) 18-May-1995
    Thomas Van Baak (tvb) 18-May-1995

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Define function prototypes for emulation routines written in assembler.
//

VOID
KiInterlockedStoreByte (
   IN PUCHAR Address,
   IN UCHAR Data
   );

VOID
KiInterlockedStoreWord (
   IN PUSHORT Address,
   IN USHORT Data
   );

BOOLEAN
KiEmulateByteWord (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PKEXCEPTION_FRAME  ExceptionFrame,
    IN OUT PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine emulates Alpha instructions defined by ECO 81. This includes
    the load byte unsigned, store byte, load word unsigned, store word, sign
    extend byte, and sign extend word instructions.

    If a misaligned word access is detected the illegal instruction exception
    record is converted into data misalignment exception record, no emulation
    is performed, and a value of FALSE is returned. It is expected that the
    call to this function is followed by a check for a data misalignment
    exception and a call to the data misalignment emulation function if
    appropriate.

Arguments:

    ExceptionRecord - Supplies a pointer to the exception record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    A value of TRUE is returned if the instruction is successfully emulated,
    otherwise a value of FALSE is returned.

--*/

{
    ULONGLONG Data;
    ULONGLONG EffectiveAddress;
    PVOID ExceptionAddress;
    ALPHA_INSTRUCTION Instruction;
    KIRQL OldIrql;
    KPROCESSOR_MODE PreviousMode;

    //
    // Save original exception address in case another exception occurs.
    //

    ExceptionAddress = ExceptionRecord->ExceptionAddress;

    //
    // Any exception that occurs during the attempted emulation will cause
    // the emulation to be aborted. The new exception code and information
    // will be copied to the original exception record and FALSE will be
    // returned. If the memory access was not from kernel mode then probe
    // the effective address before performing the emulation.
    //

    //
    // Capture previous mode from trap frame not current thread.
    //

    PreviousMode = (KPROCESSOR_MODE)(((PSR *)(&TrapFrame->Psr))->MODE);

    try {

        //
        // Get faulting instruction and case on instruction type.
        //

        if (PreviousMode != KernelMode) {
            ProbeForRead(ExceptionAddress,
                         sizeof(ALPHA_INSTRUCTION),
                         sizeof(ALPHA_INSTRUCTION));
        }
        Instruction = *((PALPHA_INSTRUCTION)ExceptionAddress);
        switch (Instruction.Memory.Opcode) {

        //
        // Load/store operations.
        //

        case LDBU_OP :
        case LDWU_OP :
        case STB_OP :
        case STW_OP :


            //
            // Compute effective address and if the address is non-canonical
            // then change the exception code to STATUS_ACCESS_VIOLATION and
            // return FALSE.
            //

            EffectiveAddress = (ULONGLONG)Instruction.Memory.MemDisp +
                               KiGetRegisterValue(Instruction.Memory.Rb,
                                                  ExceptionFrame,
                                                  TrapFrame);

            if (EffectiveAddress != (ULONGLONG)(PVOID)EffectiveAddress) {
                ExceptionRecord->ExceptionCode = STATUS_ACCESS_VIOLATION;
                ExceptionRecord->NumberParameters = 0;
                return FALSE;
            }

            //
            // Case on individual load/store instruction type.
            //

            switch (Instruction.Memory.Opcode) {

            //
            // Load byte unsigned.
            //

            case LDBU_OP :
                if (PreviousMode != KernelMode) {
                    ProbeForRead(EffectiveAddress,
                                 sizeof(UCHAR),
                                 sizeof(UCHAR));
                }
                Data = (ULONGLONG)*(PUCHAR)EffectiveAddress;
                KiSetRegisterValue(Instruction.Memory.Ra,
                                   Data,
                                   ExceptionFrame,
                                   TrapFrame);
                break;

            //
            // Load word unsigned.
            //

            case LDWU_OP :
                if (EffectiveAddress & 0x1) {
                    goto AlignmentFault;
                }
                if (PreviousMode != KernelMode) {
                    ProbeForRead((PUSHORT)EffectiveAddress,
                                 sizeof(USHORT),
                                 sizeof(UCHAR));
                }
                Data = (ULONGLONG)*(PUSHORT)EffectiveAddress;
                KiSetRegisterValue(Instruction.Memory.Ra,
                                   Data,
                                   ExceptionFrame,
                                   TrapFrame);
                break;

            //
            // Store byte.
            //

            case STB_OP :
                if (PreviousMode != KernelMode) {
                    ProbeForWrite((PUCHAR)EffectiveAddress,
                                  sizeof(UCHAR),
                                  sizeof(UCHAR));
                }
                Data = KiGetRegisterValue(Instruction.Memory.Ra,
                                          ExceptionFrame,
                                          TrapFrame);
                KiInterlockedStoreByte((PUCHAR)EffectiveAddress,
                                       (UCHAR)Data);
                break;

            //
            // Store word.
            //

            case STW_OP :
                if (EffectiveAddress & 0x1) {
                    goto AlignmentFault;
                }
                if (PreviousMode != KernelMode) {
                    ProbeForWrite((PUSHORT)EffectiveAddress,
                                  sizeof(USHORT),
                                  sizeof(UCHAR));
                }
                Data = KiGetRegisterValue(Instruction.Memory.Ra,
                                          ExceptionFrame,
                                          TrapFrame);
                KiInterlockedStoreWord((PUSHORT)EffectiveAddress,
                                       (USHORT)Data);
                break;
            }

            break;

        //
        // Sign extend operations.
        //

        case SEXT_OP :
            switch (Instruction.OpReg.Function) {

            //
            // Sign extend byte.
            //

            case SEXTB_FUNC :
                Data = KiGetRegisterValue(Instruction.OpReg.Rb,
                                          ExceptionFrame,
                                          TrapFrame);
                KiSetRegisterValue(Instruction.OpReg.Rc,
                                   (ULONGLONG)(CHAR)Data,
                                   ExceptionFrame,
                                   TrapFrame);
                break;

            //
            // Sign extend word.
            //

            case SEXTW_FUNC :
                Data = KiGetRegisterValue(Instruction.OpReg.Rb,
                                          ExceptionFrame,
                                          TrapFrame);
                KiSetRegisterValue(Instruction.OpReg.Rc,
                                   (ULONGLONG)(SHORT)Data,
                                   ExceptionFrame,
                                   TrapFrame);
                break;

            //
            // All other functions are not emulated.
            //

            default :
                return FALSE;
            }

            break;

        //
        // All other instructions are not emulated.
        //

        default :
            return FALSE;
        }

#if 0
        //
        // Call out to profile interrupt if byte/word emulation profiling is
        // active.
        //

        if (KiProfileByteWordEmulation != FALSE) {
            if (++KiProfileByteWordEmulationCount >=
                KiProfileByteWordEmulationInterval) {

                KeRaiseIrql(PROFILE_LEVEL, &OldIrql);
                KiProfileByteWordEmulationCount = 0;
                KeProfileInterruptWithSource(TrapFrame,
                                             ProfileByteWordEmulation);
                KeLowerIrql(OldIrql);
            }
        }
#endif

        TrapFrame->Fir += 4;

        return TRUE;

    } except (KiCopyInformation(ExceptionRecord,
                                (GetExceptionInformation())->ExceptionRecord)) {

        //
        // Preserve the original exception address.
        //

        ExceptionRecord->ExceptionAddress = ExceptionAddress;

        return FALSE;
    }

AlignmentFault :

    //
    // A misaligned word access has been encountered. Change the illegal
    // instruction exception record into data misalignment exception record
    // (the format is defined by PALcode) and return FALSE.
    //

    ExceptionRecord->ExceptionCode = STATUS_DATATYPE_MISALIGNMENT;
    ExceptionRecord->NumberParameters = 3;
    ExceptionRecord->ExceptionInformation[0] = Instruction.Memory.Opcode;
    ExceptionRecord->ExceptionInformation[1] = Instruction.Memory.Ra;
    ExceptionRecord->ExceptionInformation[2] = (ULONG)EffectiveAddress;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\apcint.s ===
//      TITLE("Asynchronous Procedure Call (APC) Interrupt")
//++
//
// Copyright (c) 1990  Microsoft Corporation
//
// Module Name:
//
//    apcint.s
//
// Abstract:
//
//    This module implements the code necessary to field and process the
//    Asynchronous Procedure Call (APC) interrupt.
//
// Author:
//
//    David N. Cutler (davec) 3-Apr-1990
//    Joe Notarangelo 15-Jul-1992  alpha version
//
// Environment:
//
//    Kernel mode only, IRQL APC_LEVEL.
//
// Revision History:
//
//--

#include "ksalpha.h"

        SBTTL("Asynchronous Procedure Call Interrupt")
//++
//
// Routine Description:
//
//    This routine is entered as the result of a software interrupt generated
//    at APC_LEVEL. Its function is to allocate an exception frame and call
//    the kernel APC delivery routine to deliver kernel mode APCs and to check
//    if a user mode APC should be delivered. If a user mode APC should be
//    delivered, then the kernel APC delivery routine constructs a context
//    frame on the user stack and alters the exception and trap frames so that
//    control will be transfered to the user APC dispatcher on return from the
//    interrupt.
//
//    N.B. On entry to this routine only the volatile integer registers have
//       been saved. The remainder of the machine state is saved if and only
//       if the previous mode was user mode. It is assumed that none of the
//       APC delivery code, nor any of the kernel mode APC routines themselves
//       use any floating point instructions.
//
// Arguments:
//
//    s6/fp - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(KiApcInterrupt, ExceptionFrameLength, zero)

	lda	sp, -ExceptionFrameLength(sp) // allocate exception frame
	stq	ra, ExIntRa(sp)		// save return address

        PROLOGUE_END

//
// Save the volatile floating state and determine the previous mode.
//

	bsr	ra, KiSaveVolatileFloatState // save volatile floats
	ldl	t0, TrPsr(fp)		// get saved processor status
	and	t0, PSR_MODE_MASK, a0	// isolate previous mode
        beq     a0, 10f			// if eq, kernel mode

//
// The previous mode was user.
//
// Save the nonvolatile machine state so a context record can be
// properly constructed to deliver an APC to user mode if required.
// It is also necessary to save the volatile floating state for
// suspend/resume operations.
//

	stq	s0, ExIntS0(sp)		// save nonvolatile integer state
	stq	s1, ExIntS1(sp)		//
	stq	s2, ExIntS2(sp)		//
	stq	s3, ExIntS3(sp)		//
	stq	s4, ExIntS4(sp)		//
	stq	s5, ExIntS5(sp)		//
	bsr	ra, KiSaveNonVolatileFloatState // save floating state

//
// Attempt to deliver an APC.
//

10:     bis	sp, zero, a1		// set address of exception frame
	bis	fp, zero, a2		// set address of trap frame
	bsr	ra, KiDeliverApc	// call APC delivery routine

//
// Restore the volatile floating state and return from the interrupt.
//

	bsr	ra, KiRestoreVolatileFloatState // restore floating state
	ldq	ra, ExIntRa(sp)		// restore return address
	lda	sp, ExceptionFrameLength(sp) // deallocate exception frame
	ret	zero, (ra)		// return

        .end    KiApcInterrupt

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\callback.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    callback.c

Abstract:

    This module implements stubs for the user mode call back services.

Author:

    David N. Cutler (davec) 29-Oct-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

NTSTATUS
KeUserModeCallback (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    IN PULONG OutputLength
    )

/*++

Routine Description:

    This function call out from kernel mode to a user mode function.

Arguments:

    ApiNumber - Supplies the API number.

    InputBuffer - Supplies a pointer to a structure that is copied
        to the user stack.

    InputLength - Supplies the length of the input structure.

    Outputbuffer - Supplies a pointer to a variable that receives
        the address of the output buffer.

    Outputlength - Supplies a pointer to a variable that receives
        the length of the output buffer.

Return Value:

    If the callout cannot be executed, then an error status is
    returned. Otherwise, the status returned by the callback function
    is returned.

--*/

{

    PUCALLOUT_FRAME CalloutFrame;
    ULONG Length;
    ULONGLONG OldStack;
    NTSTATUS Status;
    PKTRAP_FRAME TrapFrame;
    PVOID ValueBuffer;
    ULONG ValueLength;

    ASSERT(KeGetPreviousMode() == UserMode);

    //
    // Get the user mode stack pointer and attempt to copy input buffer
    // to the user stack.
    //

    TrapFrame = KeGetCurrentThread()->TrapFrame;
    OldStack = TrapFrame->IntSp;
    try {

        //
        // Compute new user mode stack address, probe for writability,
        // and copy the input buffer to the user stack.
        //
        // N.B. Alpha requires stacks to be 16-byte aligned, therefore
        //      the input length must be rounded up to a 16-byte boundary.
        //

        Length =  (InputLength +
                16 - 1 + sizeof(UCALLOUT_FRAME)) & ~(16 - 1);

        CalloutFrame = (PUCALLOUT_FRAME)(OldStack - Length);
        ProbeForWrite(CalloutFrame, Length, sizeof(QUAD));
        RtlCopyMemory(CalloutFrame + 1, InputBuffer, InputLength);

        //
        // Allocate stack frame and fill in callout arguments.
        //

        CalloutFrame->Buffer = (PVOID)(CalloutFrame + 1);
        CalloutFrame->Length = InputLength;
        CalloutFrame->ApiNumber = ApiNumber;
        CalloutFrame->Sp = OldStack;
        CalloutFrame->Ra = TrapFrame->IntRa;

    //
    // If an exception occurs during the probe of the user stack, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Call user mode.
    //

    TrapFrame->IntSp = (ULONGLONG)(LONG_PTR)CalloutFrame;
    Status = KiCallUserMode(OutputBuffer, OutputLength);

    //
    // When returning from user mode, any drawing done to the GDI TEB
    // batch must be flushed.
    //

    if (((PTEB)KeGetCurrentThread()->Teb)->GdiBatchCount > 0) {
        TrapFrame->IntSp -= 256;
        KeGdiFlushUserBatch();
    }

    TrapFrame->IntSp = OldStack;
    return Status;
}

NTSTATUS
NtW32Call (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    OUT PULONG OutputLength
    )

/*++

Routine Description:

    This function calls a W32 function.

Arguments:

    ApiNumber - Supplies the API number.

    InputBuffer - Supplies a pointer to a structure that is copied to
        the user stack.

    InputLength - Supplies the length of the input structure.

    Outputbuffer - Supplies a pointer to a variable that recevies the
        output buffer address.

    Outputlength - Supplies a pointer to a variable that recevies the
        output buffer length.

Return Value:

    TBS.

--*/

{

    PVOID ValueBuffer;
    ULONG ValueLength;
    NTSTATUS Status;

    ASSERT(KeGetPreviousMode() == UserMode);

    //
    // If the current thread is not a GUI thread, then fail the service
    // since the thread does not have a large stack.
    //

    if (KeGetCurrentThread()->Win32Thread == (PVOID)&KeServiceDescriptorTable[0]) {
        return STATUS_NOT_IMPLEMENTED;
    }

    //
    // Probe the output buffer address and length for writeability.
    //

    try {
        ProbeForWriteUlong((PULONG)OutputBuffer);
        ProbeForWriteUlong(OutputLength);

    //
    // If an exception occurs during the probe of the output buffer or
    // length, then always handle the exception and return the exception
    // code as the status value.
    //

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Call out to user mode specifying the input buffer and API number.
    //

    Status = KeUserModeCallback(ApiNumber,
                                InputBuffer,
                                InputLength,
                                &ValueBuffer,
                                &ValueLength);

    //
    // If the callout is successful, then the output buffer address and
    // length.
    //

    if (NT_SUCCESS(Status)) {
        try {
            *OutputBuffer = ValueBuffer;
            *OutputLength = ValueLength;

        } except(EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\callout.s ===
//      TITLE("Call Out to User Mode")
//++
//
// Copyright (c) 1994  Microsoft Corporation
//
// Module Name:
//
//     callout.s
//
// Abstract:
//
//    This module implements the code necessary to call out from kernel
//    mode to user mode.
//
// Author:
//
//     John Vert (jvert) 2-Nov-1994
//
// Environment:
//
//     Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

//
// Define external variables that can be addressed using GP.
//

        .extern KeUserCallbackDispatcher

        SBTTL("Call User Mode Function")
//++
//
// NTSTATUS
// KiCallUserMode (
//    IN PVOID *OutputBuffer,
//    IN PULONG OutputLength
//    )
//
// Routine Description:
//
//    This function calls a user mode function.
//
//    N.B. This function calls out to user mode and the NtCallbackReturn
//        function returns back to the caller of this function. Therefore,
//        the stack layout must be consistent between the two routines.
//
// Arguments:
//
//    OutputBuffer (a0) - Supplies a pointer to the variable that receivies
//        the address of the output buffer.
//
//    OutputLength (a1) - Supplies a pointer to a variable that receives
//        the length of the output buffer.
//
// Return Value:
//
//    The final status of the call out function is returned as the status
//    of the function.
//
//    N.B. This function does not return to its caller. A return to the
//        caller is executed when a NtCallbackReturn system service is
//        executed.
//
//    N.B. This function does return to its caller if a kernel stack
//         expansion is required and the attempted expansion fails.
//
//--

        NESTED_ENTRY(KiCallUserMode, CuFrameLength, zero)

        lda     sp, -CuFrameLength(sp)  // allocate stack frame
        stq     ra, CuRa(sp)            // save return address

//
// Save nonvolatile integer registers.
//

        stq     s0, CuS0(sp)            // save integer registers s0 - s5
        stq     s1, CuS1(sp)            //
        stq     s2, CuS2(sp)            //
        stq     s3, CuS3(sp)            //
        stq     s4, CuS4(sp)            //
        stq     s5, CuS5(sp)            //
        stq     fp, CuFP(sp)            // save FP

//
// Save nonvolatile floating registers.
//

        stt     f2, CuF2(sp)            // save floating registers f2 - f9
        stt     f3, CuF3(sp)            //
        stt     f4, CuF4(sp)            //
        stt     f5, CuF5(sp)            //
        stt     f6, CuF6(sp)            //
        stt     f7, CuF7(sp)            //
        stt     f8, CuF8(sp)            //
        stt     f9, CuF9(sp)            //

        PROLOGUE_END

//
// Save argument registers.
//

        stq     a0, CuA0(sp)            // save output buffer address
        stq     a1, CuA1(sp)            // save output length address

//
// Check if sufficient room is available on the kernel stack for another
// system call.
//

        GET_CURRENT_THREAD              // get current thread address

        bis     v0, zero, t0            // save current thread address
        LDP     t1, ThInitialStack(t0)  // get initial stack address
        LDP     t2, ThStackLimit(t0)    // get current stack limit
        SUBP    sp, KERNEL_LARGE_STACK_COMMIT, t3 // compute bottom address
        cmpult  t2, t3, t4              // check if limit exceeded
        bne     t4, 10f                 // if ne, limit not exceeded
        bis     sp, zero, a0            // set current kernel stack address
        bsr     ra, MmGrowKernelStack   // attempt to grow the kernel stack
        bne     v0, 20f                 // if ne, attempt to grow failed

        GET_CURRENT_THREAD              // get current thread address

        bis     v0, zero, t0            // save current thread address
        LDP     t1, ThInitialStack(t0)  // get initial stack address
10:     LDP     fp, ThTrapFrame(t0)     // get trap frame address
        LDP     t2, ThCallbackStack(t0) // get callback stack address
        STP     t1, CuInStk(sp)         // save initial stack address
        STP     fp, CuTrFr(sp)          // save trap frame address
        STP     t2, CuCbStk(sp)         // save callback stack address
        STP     sp, ThCallbackStack(t0) // set callback stack address

//
// Restore state and callback to user mode.
//
// N.B. Interrupts are disabled to prevent get/set context APCs from
//      occurring.
//

        DISABLE_INTERRUPTS              // disable interrupts

        STP     sp, ThInitialStack(t0)  // reset initial stack address
        ldq     t3, TrFir(fp)           // get old PC
        STP     t3, CuTrFir(sp)         // save old PC
        LDP     t4, KeUserCallbackDispatcher // get continuation address
        stq     t4, TrFir(fp)           // set continuation address

//
// If a user mode APC is pending, then request an APC interrupt.
//

        bis     zero, zero, a1          // assume no user APC pending
        ldq_u   t1, ThApcState+AsUserApcPending(t0) // get user APC pending
        extbl   t1, (ThApcState+AsUserApcPending) % 8, t1 //
        ZeroByte(ThAlerted(t0))         // clear kernel mode alerted
        cmovne  t1, APC_INTERRUPT, a1   // if pending set APC interrupt

//
// Set initial kernel stack for this thread.
//

        bis     sp, zero, a0            // set kernel stack address

        SET_INITIAL_KERNEL_STACK        // set kernel stack pointer

        ldl     a0, TrPsr(fp)           // get previous processor status

//
// a0 = previous psr
// a1 = sfw interrupt requests
//

        RETURN_FROM_SYSTEM_CALL         // return to user mode

        ret     zero, (ra)              //

//
// An attempt to grow the kernel stack failed.
//

20:     ldq     ra, CuRa(sp)            // restore return address
        lda     sp, CuFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)

        .end KiCallUserMode

        SBTTL("Switch Kernel Stack")
//++
//
// PVOID
// KeSwitchKernelStack (
//    IN PVOID StackBase,
//    IN PVOID StackLimit
//    )
//
// Routine Description:
//
//    This function switches to the specified large kernel stack.
//
//    N.B. This function can ONLY be called when there are no variables
//        in the stack that refer to other variables in the stack, i.e.,
//        there are no pointers into the stack.
//
// Arguments:
//
//    StackBase (a0) - Supplies a pointer to the base of the new kernel
//        stack.
//
//    StackLimit (a1) - supplies a pointer to the limit of the new kernel
//        stack.
//
// Return Value:
//
//    The old kernel stack is returned as the function value.
//
//--

        .struct 0
SsRa:   .space  8                       // saved return address
SsSp:   .space  8                       // saved new stack pointer
SsA0:   .space  8                       // saved argument registers a0-a1
SsA1:   .space  8                       //
SsFrameLength:                          // length of stack frame

        NESTED_ENTRY(KeSwitchKernelStack, SsFrameLength, zero)

        lda     sp, -SsFrameLength(sp)  // allocate stack frame
        stq     ra, SsRa(sp)            // save return address

        PROLOGUE_END

//
// Save the address of the new stack and copy the old stack to the new
// stack.
//

        GET_CURRENT_THREAD                  // get current thread address

        stq     a0, SsA0(sp)                // save new stack base address
        stq     a1, SsA1(sp)                // save new stack limit address
        LDP     a2, ThStackBase(v0)         // get current stack base address
        LDP     a3, ThTrapFrame(v0)         // get current trap frame address
        ADDP    a3, a0, a3                  // relocate trap frame address
        SUBP    a3, a2, a3                  //
        STP     a3, ThTrapFrame(v0)         // set current trap frame address
        bis     sp, zero, a1                // set source address of copy
        SUBP    a2, sp, a2                  // compute length of copy
        SUBP    a0, a2, a0                  // set destination address of copy
        stq     a0, SsSp(sp)                // save new stack pointer address
        bsr     ra, RtlMoveMemory           // copy old stack to new stack

//
// Switch to new kernel stack and return the address of the old kernel stack.
//

        GET_CURRENT_THREAD                  // get current thread address

        DISABLE_INTERRUPTS                  // disable interrupts

        LDP     t0, ThStackBase(v0)         // get old stack base address
        ldq     a0, SsA0(sp)                // get new stack base address
        ldq     a1, SsA1(sp)                // get new stack limit address
        STP     a0, ThInitialStack(v0)      // set new initial stack address
        STP     a0, ThStackBase(v0)         // set new stack base address
        STP     a1, ThStackLimit(v0)        // set new stack limit address
        ldil    t1, TRUE                    // set large kernel stack TRUE
        StoreByte(t1, ThLargeStack(v0))     //
        ldq     sp, SsSp(sp)                // set initial stack address

        SET_INITIAL_KERNEL_STACK            // set initial kernel stack address

        ENABLE_INTERRUPTS                   // enable interrupts

        ldq     ra, SsRa(sp)                // restore return address
        lda     sp, SsFrameLength(sp)       // deallocate stack frame
        ret     zero, (ra)                  // return

        .end    KeSwitchKernelStack

        SBTTL("Return from User Mode Callback")
//++
//
// NTSTATUS
// NtCallbackReturn (
//    IN PVOID OutputBuffer OPTIONAL,
//    IN ULONG OutputLength,
//    IN NTSTATUS Status
//    )
//
// Routine Description:
//
//    This function returns from a user mode callout to the kernel
//    mode caller of the user mode callback function.
//
//    N.B. This function returns to the function that called out to user
//        mode and the KiCallUserMode function calls out to user mode.
//        Therefore, the stack layout must be consistent between the
//        two routines.
//
// Arguments:
//
//    OutputBuffer - Supplies an optional pointer to an output buffer.
//
//    OutputLength - Supplies the length of the output buffer.
//
//    Status - Supplies the status value returned to the caller of the
//        callback function.
//
// Return Value:
//
//    If the callback return cannot be executed, then an error status is
//    returned. Otherwise, the specified callback status is returned to
//    the caller of the callback function.
//
//    N.B. This function returns to the function that called out to user
//         mode is a callout is currently active.
//
//--

        LEAF_ENTRY(NtCallbackReturn)

        GET_CURRENT_THREAD              // get current thread address

        LDP     t1, ThCallbackStack(v0) // get callback stack address
        beq     t1, 10f                 // if eq, no callback stack present

//
// Restore nonvolatile integer registers.
//

        ldq     s0, CuS0(t1)            // restore integer registers s0 - s5
        ldq     s1, CuS1(t1)            //
        ldq     s2, CuS2(t1)            //
        ldq     s3, CuS3(t1)            //
        ldq     s4, CuS4(t1)            //
        ldq     s5, CuS5(t1)            //
        ldq     fp, CuFP(t1)            // restore FP

//
// Restore nonvolatile floating registers.
//

        ldt     f2, CuF2(t1)            // restore floating registers f2 - f9
        ldt     f3, CuF3(t1)            //
        ldt     f4, CuF4(t1)            //
        ldt     f5, CuF5(t1)            //
        ldt     f6, CuF6(t1)            //
        ldt     f7, CuF7(t1)            //
        ldt     f8, CuF8(t1)            //
        ldt     f9, CuF9(t1)            //

//
// Restore the trap frame and callback stack addresses, and store the output
// buffer address and length.
//

        LDP     t2, CuTrFr(t1)          // get previous trap frame address
        LDP     t3, CuCbStk(t1)         // get previous callback stack address
        LDP     t4, CuA0(t1)            // get address to store output address
        LDP     t5, CuA1(t1)            // get address to store output length
        LDP     t6, CuTrFir(t1)         // get old trap frame PC
        STP     t2, ThTrapFrame(v0)     // restore trap frame address
        STP     t3, ThCallbackStack(v0) // restore callback stack address
        STP     a0, 0(t4)               // store output buffer address
        STP     a1, 0(t5)               // store output buffer length
        stq     t6, TrFir(t2)           // restore old trap frame PC

//
// **** this is the place where the current stack could be trimmed back.
//
// Restore initial stack pointer, trim stackback to callback frame,
// deallocate callback stack frame, and return to callback caller.
//

        LDP     a0, CuInStk(t1)         // get previous initial stack
        STP     a0, ThInitialStack(v0)  //

        SET_INITIAL_KERNEL_STACK        // set initial kernel stack address

        bis     t1, zero, sp            // trim stack callback frame
        bis     a2, zero, v0            // set callback service status
        ldq     ra, CuRa(sp)            // restore return address
        lda     sp, CuFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// No callback is currently active.
//

10:     ldil    v0, STATUS_NO_CALLBACK_ACTIVE // set service status
        ret     zero, (ra)              // return

        .end NtCallbackReturn

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\ctxsw.s ===
//      TITLE("Context Swap")
//++
//
// Copyright (c) 1991  Microsoft Corporation
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    ctxsw.s
//
// Abstract:
//
//    This module implements the ALPHA machine dependent code necessary to
//    field the dispatch interrupt and to perform kernel initiated context
//    switching.
//
// Author:
//
//    David N. Cutler (davec) 1-Apr-1991
//    Joe Notarangelo 05-Jun-1992
//
// Environment:
//
//    Kernel mode only, IRQL DISPATCH_LEVEL.
//
// Revision History:
//
//--

#include "ksalpha.h"

// #define _COLLECT_SWITCH_DATA_ 1

        SBTTL("Unlock Dispatcher Database")
//++
//
// VOID
// KiUnlockDispatcherDatabase (
//    IN KIRQL OldIrql
//    )
//
// Routine Description:
//
//    This routine is entered at IRQL DISPATCH_LEVEL with the dispatcher
//    database locked. Ifs function is to either unlock the dispatcher
//    database and return or initiate a context switch if another thread
//    has been selected for execution.
//
//    N.B. A context switch CANNOT be initiated if the previous IRQL
//         is DISPATCH_LEVEL.
//
//    N.B. This routine is carefully written to be a leaf function. If,
//        however, a context swap should be performed, the routine is
//        switched to a nested function.
//
// Arguments:
//
//    OldIrql (a0) - Supplies the IRQL when the dispatcher database
//        lock was acquired.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiUnlockDispatcherDatabase)

//
// Check if a thread has been scheduled to execute on the current processor
//

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get prcb address

        cmpult  a0, DISPATCH_LEVEL, t1  // check if IRQL below dispatch level
        LDP     t2, PbNextThread(v0)    // get next thread address
        bne     t2, 30f                 // if ne, next thread selected

//
// Release dispatcher database lock, restore IRQL to its previous level
// and return
//

10:                                     //

#if !defined(NT_UP)

        bis     a0, zero, a1            // set old IRQL value
        ldil    a0, LockQueueDispatcherLock // set lock queue number
        br      zero, KeReleaseQueuedSpinLock // release dispatcher lock

#else

        SWAP_IRQL                       // lower IRQL

        ret     zero, (ra)              // return

#endif

//
// A new thread has been selected to run on the current processor, but
// the new IRQL is not below dispatch level. If the current processor is
// not executing a DPC, then request a dispatch interrupt on the current
// processor before releasing the dispatcher lock and restoring IRQL.
//

20:     ldl     t2, PbDpcRoutineActive(v0) // check if DPC routine active
        bne     t2,10b                  // if ne, DPC routine active

#if !defined(NT_UP)

        bis     a0, zero, t0            // save old IRQL value
        ldil    a0, DISPATCH_LEVEL      // set interrupt request level

        REQUEST_SOFTWARE_INTERRUPT      // request DPC interrupt

        ldil    a0, LockQueueDispatcherLock // set lock queue number
        bis     t0, zero, a1            // set old IRQL value
        br      zero, KeReleaseQueuedSpinLock // release dispatcher lock

#else

        SWAP_IRQL                       // lower IRQL

        ldil    a0, DISPATCH_LEVEL      // set interrupt request level

        REQUEST_SOFTWARE_INTERRUPT      // request DPC interrupt

        ret     zero, (ra)              // return

#endif

//
// A new thread has been selected to run on the current processor.
//
// If the new IRQL is less than dispatch level, then switch to the new
// thread.
//

30:     beq     t1, 20b                         // if eq, not below dispatch level

        .end    KiUnlockDispatcherDatabase

//
// N.B. This routine is carefully written as a nested function.
//    Control only reaches this routine from above.
//
//    v0 contains the address of PRCB
//    t2 contains the next thread
//

        NESTED_ENTRY(KxUnlockDispatcherDatabase, ExceptionFrameLength, zero)

        lda     sp, -ExceptionFrameLength(sp) // allocate context frame
        stq     ra, ExIntRa(sp)         // save return address
        stq     s0, ExIntS0(sp)         // save integer registers
        stq     s1, ExIntS1(sp)         //
        stq     s2, ExIntS2(sp)         //
        stq     s3, ExIntS3(sp)         //
        stq     s4, ExIntS4(sp)         //
        stq     s5, ExIntS5(sp)         //
        stq     fp, ExIntFp(sp)         //

        PROLOGUE_END

        bis     v0, zero, s0            // set address of PRCB

        GET_CURRENT_THREAD              // get current thread address

        bis     v0, zero, s1            // set current thread address
        bis     t2, zero, s2            // set next thread address
        StoreByte(a0, ThWaitIrql(s1))   // save previous IRQL
        STP     zero, PbNextThread(s0)  // clear next thread address

//
// Reready current thread for execution and swap context to the selected thread.
//
// N.B. The return from the call to swap context is directly to the swap
//      thread exit.
//

        bis     s1, zero, a0            // set previous thread address
        STP     s2, PbCurrentThread(s0) // set address of current thread object
        bsr     ra, KiReadyThread       // reready thread for execution
        lda     ra, KiSwapThreadExit    // set return address
        jmp     SwapContext             // swap context

        .end    KxUnlockDispatcherDatabase

        SBTTL("Swap Thread")
//++
//
// INT_PTR
// KiSwapThread (
//    VOID
//    )
//
// Routine Description:
//
//    This routine is called to select the next thread to run on the
//    current processor and to perform a context switch to the thread.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    Wait completion status (v0).
//
//--

        NESTED_ENTRY(KiSwapThread, ExceptionFrameLength, zero)

        lda     sp, -ExceptionFrameLength(sp) // allocate context frame
        stq     ra, ExIntRa(sp)         // save return address
        stq     s0, ExIntS0(sp)         // save integer registers s0 - s5
        stq     s1, ExIntS1(sp)         //
        stq     s2, ExIntS2(sp)         //
        stq     s3, ExIntS3(sp)         //
        stq     s4, ExIntS4(sp)         //
        stq     s5, ExIntS5(sp)         //
        stq     fp, ExIntFp(sp)         // save fp

        PROLOGUE_END

        GET_PROCESSOR_CONTROL_REGION_BASE // get pcr address

        bis     v0, zero, s3            // save PCR address
        LDP     s0, PcPrcb(s3)          // get address of PRCB
        ldl     s5, KiReadySummary      // get ready summary
        zapnot  s5, 0x0f, t0            // clear high 32 bits

        GET_CURRENT_THREAD              // get current thread address

        bis     v0, zero, s1            // set current thread address
        LDP     s2, PbNextThread(s0)    // get next thread address

#if !defined(NT_UP)

        ldl     fp, PcSetMember(s3)     // get processor affinity mask

#endif

        STP     zero, PbNextThread(s0)  // zero next thread address
        bne     s2, 120f                // if ne, next thread selected

//
// Find the highest nibble in the ready summary that contains a set bit
// and left justify so the nibble is in bits <63:60>.
//

        cmpbge  zero, t0, s4            // generate mask of clear bytes
        ldil    t2, 7                   // set initial bit number
        srl     s4, 1, t5               // check bits <15:8>
        cmovlbc t5, 15, t2              // if bit clear, bit number = 15
        srl     s4, 2, t6               // check bits <23:16>
        cmovlbc t6, 23, t2              // if bit clear, bit number = 23
        srl     s4, 3, t7               // check bits <31:24>
        cmovlbc t7, 31, t2              // if bit clear, bit number = 31
        bic     t2, 7, t3               // get byte shift from priority
        srl     t0, t3, s4              // isolate highest nonzero byte
        and     s4, 0xf0, t4            // check if high nibble nonzero
        subq    t2, 4, t1               // compute bit number if high nibble zero
        cmoveq  t4, t1, t2              // if eq, high nibble zero
10:     ornot   zero, t2, t4            // compute left justify shift count
        sll     t0, t4, t0              // left justify ready summary to nibble

//
// If the next bit is set in the ready summary, then scan the corresponding
// dispatcher ready queue.
//

30:     blt     t0, 50f                 // if ltz, queue contains an entry
31:     sll     t0, 1, t0               // position next ready summary bit
        subq    t2, 1, t2               // decrement ready queue priority
        bne     t0, 30b                 // if ne, more queues to scan

//
// All ready queues were scanned without finding a runnable thread so
// default to the idle thread and set the appropirate bit in idle summary.
//

#if defined(_COLLECT_SWITCH_DATA_)

        lda     t0, KeThreadSwitchCounters // get switch counters address
        ldl     v0, TwSwitchToIdle(t0)  // increment switch to idle count
        addl    v0, 1, v0               //
        stl     v0, TwSwitchToIdle(t0)  //

#endif

#if defined(NT_UP)

        ldil    t0, 1                   // get current idle summary

#else

        ldl     t0, KiIdleSummary       // get current idle summary
        bis     t0, fp, t0              // set member bit in idle summary

#endif

        stl     t0, KiIdleSummary       // set new idle summary
        LDP     s2, PbIdleThread(s0)    // set address of idle thread

        br      zero, 120f              // swap context

//
// Compute address of ready list head and scan reday queue for a runnable
// thread.
//

50:     lda     t1, KiDispatcherReadyListHead // get ready ready base address

#if defined(_AXP64_)

        sll     t2, 4, s4               // compute ready queue address
        addq    s4, t1, s4              //

#else

        s8addl  t2, t1, s4              // compute ready queue address

#endif

        LDP     t4, LsFlink(s4)         // get address of next queue entry
55:     SUBP    t4, ThWaitListEntry, s2 // compute address of thread object

//
// If the thread can execute on the current processor, then remove it from
// the dispatcher ready queue.
//

#if !defined(NT_UP)

        ldl     t5, ThAffinity(s2)      // get thread affinity
        and     t5, fp, t6              // the current processor
        bne     t6, 60f                 // if ne, thread affinity compatible
        LDP     t4, LsFlink(t4)         // get address of next entry
        cmpeq   t4, s4, t1              // check for end of list
        beq     t1, 55b                 // if eq, not end of list
        br      zero, 31b               //

//
// If the thread last ran on the current processor, the processor is the
// ideal processor for the thread, the thread has been waiting for longer
// than a quantum, ot its priority is greater than low realtime plus 9,
// then select the thread. Otherwise, an attempt is made to find a more
// appropriate candidate.
//

60:     ldq_u   t1, PcNumber(s3)        // get current processor number
        extbl   t1, PcNumber % 8, t12   //
        ldq_u   t11, ThNextProcessor(s2) // get last processor number
        extbl   t11, ThNextProcessor % 8, t9 //
        cmpeq   t9, t12, t5             // check thread's last processor
        bne     t5, 110f                // if eq, last processor match
        ldq_u   t6, ThIdealProcessor(s2) // get thread's ideal processor number
        extbl   t6, ThIdealProcessor % 8, a3 //
        cmpeq   a3, t12, t8             // check thread's ideal processor
        bne     t8, 100f                // if eq, ideal processor match
        ldl     t6, KeTickCount         // get low part of tick count
        ldl     t7, ThWaitTime(s2)      // get time of thread ready
        subq    t6, t7, t8              // compute length of wait
        cmpult  t8, READY_SKIP_QUANTUM + 1, t1 // check if wait time exceeded
        cmpult  t2, LOW_REALTIME_PRIORITY + 9, t3 // check if priority in range
        and     t1, t3, v0              // check if priority and time match
        beq     v0, 100f                // if eq, select this thread

//
// Search forward in the ready queue until the end of the list is reached
// or a more appropriate thread is found.
//

        LDP     t7, LsFlink(t4)         // get address of next entry
80:     cmpeq   t7, s4, t1              // if eq, end of list
        bne     t1, 100f                // select original thread
        SUBP    t7, ThWaitListEntry, a0 // compute address of thread object
        ldl     a2, ThAffinity(a0)      // get thread affinity
        and     a2, fp, t1              // check for compatibile thread affinity
        beq     t1, 85f                 // if eq, thread affinity not compatible
        ldq_u   t5, ThNextProcessor(a0) // get last processor number
        extbl   t5, ThNextProcessor % 8, t9 //
        cmpeq   t9, t12, t10            // check if last processor number match
        bne     t10, 90f                // if ne, last processor match
        ldq_u   a1, ThIdealProcessor(a0) // get ideal processor number
        extbl   a1, ThIdealProcessor % 8, a3 //
        cmpeq   a3, t12, t10            // check if ideal processor match
        bne     t10, 90f                // if ne, ideal processor match
85:     ldl     t8, ThWaitTime(a0)      // get time of thread ready
        LDP     t7, LsFlink(t7)         // get address of next entry
        subq    t6, t8, t8              // compute length of wait
        cmpult  t8, READY_SKIP_QUANTUM + 1, t5 //  check if wait time exceeded
        bne     t5, 80b                 // if ne, wait time not exceeded
        br      zero, 100f              // select original thread

//
// Last processor or ideal processor match.
//

90:     bis     a0, zero, s2            // set thread address
        bis     t7, zero, t4            // set list entry address
        bis     t5, zero, t11           // copy last processor data
100:    insbl   t12, ThNextProcessor % 8, t8 // move next processor into position
        mskbl   t11, ThNextProcessor % 8, t5 // mask next processor position
        bis     t8, t5, t6              // merge
        stq_u   t6, ThNextProcessor(s2) // update next processor

110:                                    //

#if defined(_COLLECT_SWITCH_DATA_)

        ldq_u   t5, ThNextProcessor(s2) // get last processor number
        extbl   t5, ThNextProcessor % 8, t9 //
        ldq_u   a1, ThIdealProcessor(s2) // get ideal processor number
        extbl   a1, ThIdealProcessor % 8, a3 //
        lda     t0, KeThreadSwitchCounters + TwFindAny // compute address of Any counter
        ADDP    t0, TwFindIdeal-TwFindAny, t1 // compute address of Ideal counter
        cmpeq   t9, t12, t7             // if eq, last processor match
        ADDP    t0, TwFindLast-TwFindAny, t6 // compute address of Last counter
        cmpeq   a3, t12, t5             // check if ideal processor match
        cmovne  t7, t6, t0              // if last match, use last counter
        cmovne  t5, t1, t0              // if ideal match, use ideal counter
        ldl     v0, 0(t0)               // increment counter
        addl    v0, 1, v0               //
        stl     v0, 0(t0)               //

#endif

#endif

        LDP     t5, LsFlink(t4)         // get list entry forward link
        LDP     t6, LsBlink(t4)         // get list entry backward link
        STP     t5, LsFlink(t6)         // set forward link in previous entry
        STP     t6, LsBlink(t5)         // set backward link in next entry
        cmpeq   t6, t5, t7              // if eq, list is empty
        beq     t7, 120f                //
        ldil    t1, 1                   // compute ready summary set member
        sll     t1, t2, t1              //
        xor     t1, s5, t1              // clear member bit in ready summary
        stl     t1, KiReadySummary      //

//
// Swap context to the next thread
//

120:    STP     s2, PbCurrentThread(s0) // set address of current thread object
        bsr     ra, SwapContext         // swap context

//
// Lower IRQL, deallocate context frame, and return wait completion status.
//
// N.B. SwapContext releases the dispatcher database lock.
//
// N.B. The register v0 contains the complement of the kernel APC pending state.
//
// N.B. The register s2 contains the address of the new thread.
//

        ALTERNATE_ENTRY(KiSwapThreadExit)

        LDP     s1, ThWaitStatus(s2)    // get wait completion status
        ldq_u   t1, ThWaitIrql(s2)      // get original IRQL
        extbl   t1, ThWaitIrql % 8, a0  //
        bis     v0, a0, t3              // check if APC pending and IRQL is zero
        bne     t3, 10f                 // if ne, APC not pending or IRQL not zero

//
// Lower IRQL to APC level and dispatch APC interrupt.
//

        ldil    a0, APC_LEVEL           // lower IRQL to APC level

        SWAP_IRQL                       //

        ldil    a0, APC_LEVEL           // clear software interrupt

        DEASSERT_SOFTWARE_INTERRUPT     //

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        ldl     t1, PbApcBypassCount(v0) // increment the APC bypass count
        addl    t1, 1, t2               //
        stl     t2, PbApcBypassCount(v0) //
        bis     zero, zero, a0          // set previous mode to kernel
        bis     zero, zero, a1          // set exception frame address
        bis     zero, zero, a2          // set trap frame address
        bsr     ra, KiDeliverApc        // deliver kernel mode APC
        bis     zero, zero, a0          // set original wait IRQL

//
// Lower IRQL to wait level, set return status, restore registers, and
// return.
//

10:     SWAP_IRQL                       // lower IRQL to wait level

        bis     s1, zero, v0            // set return status value
        ldq     ra, ExIntRa(sp)         // restore return address
        ldq     s0, ExIntS0(sp)         // restore int regs S0-S5
        ldq     s1, ExIntS1(sp)         //
        ldq     s2, ExIntS2(sp)         //
        ldq     s3, ExIntS3(sp)         //
        ldq     s4, ExIntS4(sp)         //
        ldq     s5, ExIntS5(sp)         //
        ldq     fp, ExIntFp(sp)         // restore fp

        lda     sp, ExceptionFrameLength(sp) // deallocate context frame
        ret     zero, (ra)              // return

        .end    KiSwapThread

        SBTTL("Dispatch Interrupt")
//++
//
// Routine Description:
//
//    This routine is entered as the result of a software interrupt generated
//    at DISPATCH_LEVEL. Its function is to process the Deferred Procedure Call
//    (DPC) list, and then perform a context switch if a new thread has been
//    selected for execution on the processor.
//
//    This routine is entered at IRQL DISPATCH_LEVEL with the dispatcher
//    database unlocked. When a return to the caller finally occurs, the
//    IRQL remains at DISPATCH_LEVEL, and the dispatcher database is still
//    unlocked.
//
//    N.B. On entry to this routine only the volatile integer registers have
//       been saved. The volatile floating point registers have not been saved.
//
// Arguments:
//
//    fp - Supplies a pointer to the base of a trap frame.
//
// Return Value:
//
//    None.
//
//--
        .struct 0
DpSp:   .space  8                       // saved stack pointer
DpBs:   .space  8                       // base of previous stack
DpLim:  .space  8                       // limit of previous stack
        .space  8                       // pad to octaword
DpcFrameLength:                         // DPC frame length

        NESTED_ENTRY(KiDispatchInterrupt, ExceptionFrameLength, zero)

        lda     sp, -ExceptionFrameLength(sp) // allocate exception frame
        stq     ra, ExIntRa(sp)         // save return address

//
// Save the saved registers in case we context switch to a new thread.
//
// N.B. - If we don't context switch then we need only restore those
//        registers that we use in this routine, currently those registers
//        are s0, s1
//

        stq     s0, ExIntS0(sp)          // save integer registers s0-s6
        stq     s1, ExIntS1(sp)          //
        stq     s2, ExIntS2(sp)          //
        stq     s3, ExIntS3(sp)          //
        stq     s4, ExIntS4(sp)          //
        stq     s5, ExIntS5(sp)          //
        stq     fp, ExIntFp(sp)          //

        PROLOGUE_END

//
// Increment the dispatch interrupt count
//

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        bis     v0, zero, s0             // save current prcb address
        ldl     t2, PbDispatchInterruptCount(s0) // increment dispatch interrupt count
        addl    t2, 1, t3                //
        stl     t3, PbDispatchInterruptCount(s0) //

//
// Process the DPC List with interrupts off.
//

        ldl     t0, PbDpcQueueDepth(s0) // get current queue depth
        beq     t0, 20f                 // if eq, no DPCs pending

//
// Save current initial kernel stack address and set new initial kernel stack
// address.
//

PollDpcList:                            //

        DISABLE_INTERRUPTS              // disable interrupts

        GET_PROCESSOR_CONTROL_REGION_BASE // get current PCR address

        LDP     a0, PcDpcStack(v0)      // get address of DPC stack
        lda     t0, -DpcFrameLength(a0) // allocate DPC frame
        LDP     t4, PbCurrentThread(s0) // get current thread
        LDP     t5, ThStackLimit(t4)    // get current stack limit
        stq     sp, DpSp(t0)            // save old stack pointer
        stq     t5, DpLim(t0)           // save old stack limit
        SUBP    a0, KERNEL_STACK_SIZE, t5 // compute new stack limit
        STP     t5, ThStackLimit(t4)    // store new stack limit
        bis     t0, t0, sp              // set new stack pointer

        SET_INITIAL_KERNEL_STACK        // set new initial kernel stack

        stq     v0, DpBs(sp)            // save previous initial stack
        bsr     ra, KiRetireDpcList     // process the DPC list

//
// Switch back to previous stack and restore the initial stack limit.
//

        ldq     a0, DpBs(sp)            // get previous initial stack address
        ldq     t5, DpLim(sp)           // get old stack limit

        SET_INITIAL_KERNEL_STACK        // reset current initial stack

        ldq     sp, DpSp(sp)            // restore stack pointer
        LDP     t4, PbCurrentThread(s0) // get current thread
        STP     t5, ThStackLimit(t4)    // restore stack limit

        ENABLE_INTERRUPTS               // enable interrupts

//
// Check to determine if quantum end has occured.
//

20:     ldl     t0, PbQuantumEnd(s0)    // get quantum end indicator
        beq     t0, 25f                 // if eq, no quantum end request
        stl     zero, PbQuantumEnd(s0)  // clear quantum end indicator
        bsr     ra, KiQuantumEnd        // process quantum end request
        beq     v0, 50f                 // if eq, no next thread, return
        bis     v0, zero, s2            // set next thread
        br      zero, 40f               // else restore interrupts and return

//
// Determine if a new thread has been selected for execution on
// this processor.
//

25:     LDP     v0, PbNextThread(s0)    // get address of next thread object
        beq     v0, 50f                 // if eq, no new thread selected

//
// Lock dispatcher database and reread address of next thread object
//      since it is possible for it to change in mp sysytem.
//
// N.B. This is a very special acquire of the dispatcher lock in that it
//      will not be acquired unless it is free. Therefore, it is known
//      that there cannot be any queued lock requests.
//

#if !defined(NT_UP)

        lda     s1, KiDispatcherLock    // get dispatcher base lock address
        ldil    s2, LockQueueDispatcherLock * 2 // compute per processor
        SPADDP  s2, s0, s2              // lock queue entry address
        lda     s2, PbLockQueue(s2)     //

#endif

30:     ldl     a0, KiSynchIrql         // raise IRQL to synch level

        SWAP_IRQL                       //

#if !defined(NT_UP)

        LDP_L   t0, 0(s1)               // get current lock value
        bis     s2, zero, t1            // t1 = lock ownership value
        bne     t0, 45f                 // ne => spin lock owned
        STP_C   t1, 0(s1)               // set lock to owned
        beq     t1, 45f                 // if eq, conditional store failed
        mb                              // synchronize memory access
        bis     s1, LOCK_QUEUE_OWNER, t0 // set lock owner bit in lock entry
        STP     t0, LqLock(s2)          //

#endif

//
// Reready current thread for execution and swap context to the selected thread.
//

        LDP     s2, PbNextThread(s0)    // get addr of next thread

40:     GET_CURRENT_THREAD              // get current thread address

        bis     v0, zero, s1            // save current thread address

        STP     zero, PbNextThread(s0)  // clear address of next thread
        STP     s2, PbCurrentThread(s0) // set address of current thread
        bis     s1, zero, a0            // set address of previous thread
        bsr     ra, KiReadyThread       // reready thread for execution
        bsr     ra, KiSaveVolatileFloatState // save floating state
        bsr     ra, SwapContext         // swap context

//
// Restore the saved integer registers that were changed for a context
// switch only.
//
// N.B. - The frame pointer must be restored before the volatile floating
//        state because it is the pointer to the trap frame.
//

        ldq     s2, ExIntS2(sp)         // restore s2 - s5
        ldq     s3, ExIntS3(sp)         //
        ldq     s4, ExIntS4(sp)         //
        ldq     s5, ExIntS5(sp)         //
        ldq     fp, ExIntFp(sp)         // restore the frame pointer
        bsr     ra, KiRestoreVolatileFloatState // restore floating state

//
// Restore the remaining saved integer registers and return.
//

50:     ldq     s0, ExIntS0(sp)         // restore s0 - s1
        ldq     s1, ExIntS1(sp)         //
        ldq     ra, ExIntRa(sp)         // get return address
        lda     sp, ExceptionFrameLength(sp) // deallocate context frame
        ret     zero, (ra)              // return

//
// Dispatcher lock is owned, spin on both the the dispatcher lock and
// the DPC queue going not empty.
//

#if !defined(NT_UP)

45:     bis     v0, zero, a0            // lower IRQL to wait for locks

        SWAP_IRQL                       //

48:     LDP     t0, 0(s1)               // read current dispatcher lock value
        beq     t0, 30b                 // lock available.  retry spinlock
        ldl     t1, PbDpcQueueDepth(s0) // get current DPC queue depth
        bne     t1, PollDpcList         // if ne, list not empty
        br      zero, 48b               // loop in cache until lock available

#endif

        .end   KiDispatchInterrupt

        SBTTL("Swap Context to Next Thread")
//++
//
// Routine Description:
//
//    This routine is called to swap context from one thread to the next.
//
// Arguments:
//
//    s0 - Address of Processor Control Block (PRCB).
//    s1 - Address of previous thread object.
//    s2 - Address of next thread object.
//    sp - Pointer to a exception frame.
//
// Return value:
//
//    v0 - complement of Kernel APC pending.
//    s2 - Address of current thread object.
//
//--

        NESTED_ENTRY(SwapContext, 0, zero)

        stq     ra, ExSwapReturn(sp)    // save return address

        PROLOGUE_END

//
// Set new thread's state to running. Note this must be done
// under the dispatcher lock so that KiSetPriorityThread sees
// the correct state.
//

        ldil    t0, Running             // set state of new thread to running
        StoreByte( t0, ThState(s2) )    //

//
// Acquire the context swap lock so the address space of the old thread
// cannot be deleted and then release the dispatcher database lock.
//
// N.B. This lock is used to protect the address space until the context
//    switch has sufficiently progressed to the point where the address
//    space is no longer needed. This lock is also acquired by the reaper
//    thread before it finishes thread termination.
//

#if !defined(NT_UP)

        ldil    a0, LockQueueContextSwapLock * 2 // compute per processor
        SPADDP  a0, s0, a0              // lock queue entry address
        lda     a0, PbLockQueue(a0)     //
        bsr     ra, KeAcquireQueuedSpinLockAtDpcLevel // acquire context swap lock
        ldil    a0, LockQueueDispatcherLock * 2 // compute per processor
        SPADDP  a0, s0, a0              // lock queue entry address
        lda     a0, PbLockQueue(a0)     //
        bsr     ra, KeReleaseQueuedSpinLockFromDpcLevel // release dispatcher lock

#endif

//
// Accumulate the total time spent in a thread.
//

#if defined(PERF_DATA)

        bis     zero,zero,a0            // optional frequency not required
        bsr     ra, KeQueryPerformanceCounter // 64-bit cycle count in v0
        ldq     t0, PbStartCount(s0)    // get starting cycle count
        stq     v0, PbStartCount(s0)    // set starting cycle count
        ldl     t1, EtPerformanceCountHigh(s1) // get accumulated cycle count high
        sll     t1, 32, t2              //
        ldl     t3, EtPerformanceCountLow(s1) // get accumulated cycle count low
        zap     t3, 0xf0, t4            // zero out high dword sign extension
        bis     t2, t4, t3              //
        subq    v0, t0, t5              // compute elapsed cycle count
        addq    t5, t3, t4              // compute new cycle count
        stl     t4, EtPerformanceCountLow(s1) // set new cycle count in thread
        srl     t4, 32, t2              //
        stl     t2, EtPerformanceCountHigh(s1) //

#endif

        bsr     ra, KiSaveNonVolatileFloatState // save floating state

//
// The following entry point is used to switch from the idle thread to
// another thread.
//

        ALTERNATE_ENTRY(SwapFromIdle)

//
// Check if an attempt is being made to swap context while executing a DPC.
//

        ldl     v0, PbDpcRoutineActive(s0) // get DPC routine active flag
        beq     v0, 10f                 //
        ldil    a0, ATTEMPTED_SWITCH_FROM_DPC // set bug check code
        bsr     ra, KeBugCheck          // call bug check routine

//
// Get address of old and new process objects.
//

10:     LDP     s5, ThApcState + AsProcess(s1) // get address of old process
        LDP     s4, ThApcState + AsProcess(s2) // get address of new process

//
// Save the current PSR in the context frame, store the kernel stack pointer
// in the previous thread object, load the new kernel stack pointer from the
// new thread object, load the ptes for the new kernel stack in the DTB
// stack, select and new process id and swap to the new process, and restore
// the previous PSR from the context frame.
//

        DISABLE_INTERRUPTS              // disable interrupts

        LDP     a0, ThInitialStack(s2)  // get initial kernel stack pointer
        STP     sp, ThKernelStack(s1)   // save old kernel stack pointer
        bis     s2, zero, a1            // new thread address
        LDP     a2, ThTeb(s2)           // get address of user TEB

//
// On uni-processor systems keep the global current thread address
// up to date.
//

#ifdef  NT_UP

        STP     a1, KiCurrentThread     // save new current thread

#endif  //NT_UP

//
// If the old process is the same as the new process, then there is no need
// to change the address space.  The a3 parameter indicates that the address
// space is not to be swapped if it is less than zero.  Otherwise, a3 will
// contain the pfn of the PDR for the new address space.
//

        ldil    a3, -1                  // assume no address space change
        cmpeq   s5, s4, t0              // old process = new process?
        bne     t0, 50f                 // if ne, no address space swap

//
// Update the processor set masks. Clear the processor set member number in
// the old process and set the processor member number in the new process.
//

#if !defined(NT_UP)

        ldl     t0, PbSetMember(s0)     // get processor set member mask
        ldq     t1, PrActiveProcessors(s5) // get old processor sets
        ldq     t2, PrActiveProcessors(s4) // get new processor sets
        bic     t1, t0, t3              // clear member in old active set
        bis     t2, t0, t4              // set member in new active set
        sll     t0, 32, t5              // set member in new run on set
        bis     t4, t5, t4              //
        stq     t3, PrActiveProcessors(s5)  // set old processor sets
        stq     t4, PrActiveProcessors(s4)  // set new processor sets

#endif

        LDP     a3, PrDirectoryTableBase(s4) // get page directory PDE
        srl     a3, PTE_PFN, a3         // isolate page frame number

//
// If the maximum address space number is zero, then force a TB invalidate.
//

        ldl     a4, KiMaximumAsn        // get maximum ASN number
        bis     zero, 1, a5             // set ASN wrap indicator
        beq     a4, 50f                 // if eq, only one ASN
        bis     a4, zero, t3            // save maximum ASN number

//
// Check if a pending TB invalidate is pending on the current processor.
//

#if !defined(NT_UP)

        lda     t8, KiTbiaFlushRequest  // get TBIA flush request mask address
        ldl     t1, 0(t8)               // get TBIA flush request mask
        and     t1, t0, t2              // check if current processor request
        beq     t2, 20f                 // if eq, no pending flush request
        bic     t1, t0, t1              // clear processor member in mask
        stl     t1, 0(t8)               // set TBIA flush request mask

#endif

//
// If the process sequence number matches the master sequence number then
// use the process ASN. Otherwise, allocate a new ASN and check for wrap.
// If ASN wrap occurs, then also increment the master sequence number.
//

20:     lda     t9, KiMasterSequence    // get master sequence number address
        ldq     t4, 0(t9)               // get master sequence number
        ldq     t5, PrProcessSequence(s4) // get process sequence number
        ldl     a4, PrProcessAsn(s4)    // get process ASN
        xor     t4, t5, a5              // check if sequence number matches
        beq     a5, 40f                 // if eq, sequence number match
        lda     t10, KiMasterAsn        // get master ASN number address
        ldl     a4, 0(t10)              // get master ASN number
        addl    a4, 1, a4               // increment master ASN number
        cmpult  t3, a4, a5              // check for ASN wrap
        beq     a5, 30f                 // if eq, ASN did not wrap
        addq    t4, 1, t4               // increment master sequence number
        stq     t4, 0(t9)               // set master sequence number

#if !defined(NT_UP)

        ldl     t5, KeActiveProcessors  // get active processor mask
        bic     t5, t0, t5              // clear current processor member
        stl     t5, 0(t8)               // request flush on other processors

#endif

        bis     zero, zero, a4          // reset master ASN
30:     stl     a4, 0(t10)              // set master ASN number
        stl     a4, PrProcessAsn(s4)    // set process ASN number
        stq     t4, PrProcessSequence(s4) // set process sequence number

#if !defined(NT_UP)

        ldq     t5, PrActiveProcessors(s4) // get new processor sets
        zapnot  t5, 0xf, t5             // clear run on processor set
        sll     t5, 32, t3              // set run on set equal to active set
        bis     t5, t3, t5              //
        stq     t5, PrActiveProcessors(s4) // set new processor sets

#endif

//
// Merge TBIA flush request with ASN wrap indicator.
//

40:                                     //

#if !defined(NT_UP)

        bis     t2, a5, a5              // merge TBIA indicators

#endif

//
// a0 = initial ksp of new thread
// a1 = new thread address
// a2 = new TEB
// a3 = PDR of new address space or -1
// a4 = new ASN
// a5 = ASN wrap indicator
//

50:     SWAP_THREAD_CONTEXT             // swap thread

        LDP     sp, ThKernelStack(s2)   // get new kernel stack pointer

        ENABLE_INTERRUPTS               // enable interrupts

//
// Release the context swap lock.
//

#if !defined(NT_UP)

        ldil    a0, LockQueueContextSwapLock * 2 // compute per processor
        SPADDP  a0, s0, a0              // lock queue entry address
        lda     a0, PbLockQueue(a0)     //
        bsr     ra, KeReleaseQueuedSpinLockFromDpcLevel // release context swap lock

#endif

//
// If the new thread has a kernel mode APC pending, then request an APC
// interrupt.
//

        ldil    v0, 1                   // set no apc pending
        LoadByte(t0, ThApcState + AsKernelApcPending(s2)) // get kernel APC pendng
        ldl     t2, ExPsr(sp)           // get previous processor status
        beq     t0, 50f                 // if eq no apc pending
        ldil    a0, APC_INTERRUPT       // set APC level value

        REQUEST_SOFTWARE_INTERRUPT      // request an apc interrupt

        bis     zero, zero, v0          // set APC pending

//
// Count number of context switches.
//

50:     ldl     t1, PbContextSwitches(s0) // increment number of switches
        addl    t1, 1, t1               //
        stl     t1, PbContextSwitches(s0) //
        ldl     t0, ThContextSwitches(s2) // increment thread switches
        addl    t0, 1, t0               //
        stl     t0, ThContextSwitches(s2) //

//
// Restore the nonvolatile floating state.
//

        bsr     ra, KiRestoreNonVolatileFloatState //

//
// load RA and return with address of current thread in s2
//

        ldq     ra, ExSwapReturn(sp)    // get return address
        ret     zero, (ra)              // return

        .end    SwapContext

        SBTTL("Swap Process")
//++
//
// BOOLEAN
// KiSwapProcess (
//    IN PKPROCESS NewProcess
//    IN PKPROCESS OldProcess
//    )
//
// Routine Description:
//
//    This function swaps the address space from one process to another by
//    assigning a new ASN if necessary and calling the palcode to swap
//    the privileged portion of the process context (the page directory
//    base pointer and the ASN).  This function also maintains the processor
//    set for both processes in the switch.
//
// Arguments:
//
//    NewProcess (a0) - Supplies a pointer to a control object of type process
//        which represents the new process to switch to.
//
//    OldProcess (a1) - Supplies a pointer to a control object of type process
//        which represents the old process to switch from..
//
// Return Value:
//
//    None.
//
//--

        .struct 0
SwA0:   .space  8                       // saved new process address
SwA1:   .space  8                       // saved old process address
SwRa:   .space  8                       // saved return address
        .space  8                       // unused
SwapFrameLength:                        // swap frame length

        NESTED_ENTRY(KiSwapProcess, SwapFrameLength, zero)

        lda     sp, -SwapFrameLength(sp) // allocate stack frame
        stq     ra, SwRa(sp)            // save return address

        PROLOGUE_END

//
// Acquire the context swap lock, clear the processor set member in he old
// process, set the processor member in the new process, and release the
// context swap lock.
//

#if !defined(NT_UP)

        stq     a0, SwA0(sp)            // save new process address
        stq     a1, SwA1(sp)            // save old process address
        ldil    a0, LockQueueContextSwapLock // set lock queue number
        bsr     ra, KeAcquireQueuedSpinLock // acquire context swap lock
        bis     v0, zero, t6            // save old IRQL

        GET_PROCESSOR_CONTROL_REGION_BASE // get PCR address

        ldq     a3, SwA0(sp)            // restore new process address
        ldq     a1, SwA1(sp)            // restore old process address
        ldl     t0, PcSetMember(v0)     // get processor set member mask
        ldq     t1, PrActiveProcessors(a1) // get old processor sets
        ldq     t2, PrActiveProcessors(a3) // get new processor sets
        bic     t1, t0, t3              // clear member in old active set
        bis     t2, t0, t4              // set member in new active set
        sll     t0, 32, t5              // set member in new run on set
        bis     t4, t5, t4              //
        stq     t3, PrActiveProcessors(a1) // set old processor sets
        stq     t4, PrActiveProcessors(a3) // set new processor sets

#else

        bis     a0, zero, a3            // copy new process address

#endif

        LDP     a0, PrDirectoryTableBase(a3) // get page directory PDE
        srl     a0, PTE_PFN, a0         // isloate page frame number

//
// If the maximum address space number is zero, then assign ASN zero to
// the new process.
//

        ldl     a1, KiMaximumAsn        // get maximum ASN number
        ldil    a2, TRUE                // set ASN wrap indicator
        beq     a1, 40f                 // if eq, only one ASN
        bis     a1, zero, t3            // save maximum ASN number

//
// Check if a pending TB invalidate all is pending on the current processor.
//

#if !defined(NT_UP)

        lda     t8, KiTbiaFlushRequest  // get TBIA flush request mask address
        ldl     t1, 0(t8)               // get TBIA flush request mask
        and     t1, t0, t2              // check if current processor request
        beq     t2, 10f                 // if eq, no pending flush request
        bic     t1, t0, t1              // clear processor member in mask
        stl     t1, 0(t8)               // set TBIA flush request mask

#endif

//
// If the process sequence number matches the master sequence number then
// use the process ASN. Otherwise, allocate a new ASN and check for wrap.
// If ASN wrap occurs, then also increment the master sequence number.
//

10:     lda     t9, KiMasterSequence    // get master sequence number address
        ldq     t4, 0(t9)               // get master sequence number
        ldq     t5, PrProcessSequence(a3) // get process sequence number
        ldl     a1, PrProcessAsn(a3)    // get process ASN
        xor     t4, t5, a2              // check if sequence number matches
        beq     a2, 30f                 // if eq, sequence number match
        lda     t10, KiMasterAsn        // get master ASN number address
        ldl     a1, 0(t10)              // get master ASN number
        addl    a1, 1, a1               // increment master ASN number
        cmpult  t3, a1, a2              // check for ASN wrap
        beq     a2, 20f                 // if eq, ASN did not wrap
        addq    t4, 1, t4               // increment master sequence number
        stq     t4, 0(t9)               // set master sequence number

#if !defined(NT_UP)

        ldl     t5, KeActiveProcessors  // get active processor mask
        bic     t5, t0, t5              // clear current processor member
        stl     t5, 0(t8)               // request flush on other processors

#endif

        bis     zero, zero, a1          // reset master ASN
20:     stl     a1, 0(t10)              // set master ASN number
        stl     a1, PrProcessAsn(a3)    // set process ASN number
        stq     t4, PrProcessSequence(a3) // set process sequence number

#if !defined(NT_UP)

        ldq     t5, PrActiveProcessors(a3) // get new processor sets
        zapnot  t5, 0xf, t5             // clear run on processor set
        sll     t5, 32, t3              // set run on set equal to active set
        bis     t5, t3, t5              //
        stq     t5, PrActiveProcessors(a3) // set new processor sets

#endif

//
// Merge TBIA flush request with ASN wrap indicator.
//

30:                                     //

#if !defined(NT_UP)

        bis     t2, a2, a2              // merge TBIA indicators

#endif

//
// a0 = pfn of new page directory base
// a1 = new address space number
// a2 = tbiap indicator
//

40:     SWAP_PROCESS_CONTEXT            // swap address space

//
// Release context swap lock.
//

#if !defined(NT_UP)

        ldil    a0, LockQueueContextSwapLock // set lock queue number
        bis     t6, zero, a1            // set old IRQL value
        bsr     ra, KeReleaseQueuedSpinLock // release dispatcher lock

#endif

        ldq     ra, SwRa(sp)            // restore return address
        lda     sp, SwapFrameLength(sp) // deallocate stack frame
        ret     zero, (ra)              // return

        .end    KiSwapProcess
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\floatem.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1993  Digital Equipment Corporation

Module Name:

    floatem.c

Abstract:

    This module implements a software emulation of the IEEE single and
    double floating operations. It is required on Alpha processors since
    the hardware does not fully support all of the operations required
    by the IEEE standard. In particular, infinities and NaNs are not
    handled by the hardware, but rather cause an exception. On receipt
    of the exception, a software emulation of the floating operation
    is performed to determine the real result of the operation and if
    an exception will actually be raised.

    This code is also used to perform all floating operations on EV4
    processors when plus or minus infinity rounding is used.

    Since floating exceptions are rather rare events, this routine is
    written in C. Should a higher performance implementation be required,
    then the algorithms contained herein, can be used to guide a higher
    performance assembly language implementation.

    N.B. This routine does not emulate floating loads, floating stores,
         control to/from floating, or move to/from floating instructions.
         These instructions never require emulation.

    Floating point operations are carried out by unpacking the operands,
    normalizing denormalized numbers, checking for NaNs, interpreting
    infinities, and computing results.

    Floating operands are converted to a format that has a value with the
    appropriate number of leading zeros, an overflow bit, the mantissa, a
    guard bit, a round bit, and a set of sticky bits. The unpacked mantissa
    includes the hidden bit.

    The overflow bit is needed for addition and is also used for multiply.
    The mantissa is 24-bits for single operations and 53-bits for double
    operations. The guard bit and round bit are used to hold precise values
    for normalization and rounding.

    If the result of an operation is normalized, then the guard bit becomes
    the round bit and the round bit is accumulated with the sticky bits. If
    the result of an operation needs to be shifted left one bit for purposes
    of normalization, then the guard bit becomes part of the mantissa and the
    round bit is used for rounding.

    The round bit plus the sticky bits are used to determine how rounding is
    performed.

Author:

    David N. Cutler (davec) 16-Jun-1991

Environment:

    Kernel mode only.

Revision History:

    Thomas Van Baak (tvb) 12-Sep-1992

        Adapted for Alpha AXP.

    Nigel Haslock (haslock) 20-Apr-1995

        Adjustments for additional EV4.5 and EV5 functionality

    Kim Peterson (peterson) 4-Feb-1998

        Corrections for denormal and double precision denormal processing.
        Rounds denormal after shifting it into denormal format.
        Preserves first operand NAN if second operand is not a NAN
        (single precision was already correct).

--*/

#include "ki.h"
#pragma hdrstop
#include "alphaops.h"

#if DBG

extern ULONG RtlDebugFlags;
#define DBGPRINT  ((RtlDebugFlags & 0x4) != 0) && DbgPrint
#define DBGPRINT2 ((RtlDebugFlags & 0x8) != 0) && DbgPrint

#else

#define DBGPRINT  0 && DbgPrint
#define DBGPRINT2 0 && DbgPrint

#endif

#define LOW_PART(Quad) ((ULONG)(Quad))
#define HIGH_PART(Quad) ((ULONG)(Quad >> 32))
#define MAKE_QUAD(Low, High) (((ULONGLONG)(High)) << 32 | ((ULONGLONG)(Low)))

//
// The hardware recognizes the new CVTST instruction by the kludged
// opcode function 16.2ac instead of the proper 16.00e (per ECO #46).
//

#define CVTST_FUNC_PROPER 0x00E

//
// Define unpacked format NaN mask values and boolean macros.
//
// N.B. The NaN bit is set for a quiet NaN and reset for a signaling NaN.
//      This is the same as Intel, Sun, IBM and opposite of Mips, HP.
//

#define DOUBLE_NAN_BIT_HIGH (1 << (53 - 32))
#define SINGLE_NAN_BIT (1 << 24)

#define DoubleSignalNan(DoubleOperand) \
    (((DoubleOperand)->Nan != FALSE) && \
     (((DoubleOperand)->MantissaHigh & DOUBLE_NAN_BIT_HIGH) == 0))

#define DoubleQuietNan(DoubleOperand) \
    (((DoubleOperand)->Nan != FALSE) && \
     (((DoubleOperand)->MantissaHigh & DOUBLE_NAN_BIT_HIGH) != 0))

#define SingleSignalNan(SingleOperand) \
    (((SingleOperand)->Nan != FALSE) && \
     (((SingleOperand)->Mantissa & SINGLE_NAN_BIT) == 0))

#define SingleQuietNan(SingleOperand) \
    (((SingleOperand)->Nan != FALSE) && \
     (((SingleOperand)->Mantissa & SINGLE_NAN_BIT) != 0))

//
// Define context block structure.
//

typedef struct _FP_CONTEXT_BLOCK {
    ULONG Fc;
    PEXCEPTION_RECORD ExceptionRecord;
    PKEXCEPTION_FRAME ExceptionFrame;
    PKTRAP_FRAME TrapFrame;
    PSW_FPCR SoftwareFpcr;
    ULONG Round;
    BOOLEAN IeeeMode;
    BOOLEAN UnderflowEnable;
} FP_CONTEXT_BLOCK, *PFP_CONTEXT_BLOCK;

//
// Define single and double operand value structures.
//

typedef struct _FP_DOUBLE_OPERAND {
    LONG MantissaHigh;
    ULONG MantissaLow;
    LONGLONG Mantissa;                  // ## Not fully used yet
    LONG Exponent;
    LONG Sign;
    BOOLEAN Infinity;
    BOOLEAN Nan;
    BOOLEAN Normal;
} FP_DOUBLE_OPERAND, *PFP_DOUBLE_OPERAND;

typedef struct _FP_SINGLE_OPERAND {
    LONG Mantissa;
    LONG Exponent;
    LONG Sign;
    BOOLEAN Infinity;
    BOOLEAN Nan;
    BOOLEAN Normal;
} FP_SINGLE_OPERAND, *PFP_SINGLE_OPERAND;

//
// Define single and double IEEE floating point memory formats.
//

typedef struct _DOUBLE_FORMAT {
    ULONGLONG Mantissa : 52;
    ULONGLONG Exponent : 11;
    ULONGLONG Sign : 1;
} DOUBLE_FORMAT, *PDOUBLE_FORMAT;

typedef struct _SINGLE_FORMAT {
    ULONG Mantissa : 23;
    ULONG Exponent : 8;
    ULONG Sign : 1;
} SINGLE_FORMAT, *PSINGLE_FORMAT;

//
// Define forward referenced function prototypes.
//

ULONGLONG
KiConvertSingleOperandToRegister (
    IN ULONG SingleValue
    );

ULONG
KiConvertRegisterToSingleOperand (
    IN ULONGLONG DoubleValue
    );

BOOLEAN
KiConvertQuadwordToLongword (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN LONGLONG Quadword
    );

BOOLEAN
KiDivideByZeroDouble (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN PFP_DOUBLE_OPERAND DoubleOperand1,
    IN PFP_DOUBLE_OPERAND DoubleOperand2
    );

BOOLEAN
KiDivideByZeroSingle (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN PFP_SINGLE_OPERAND SingleOperand1,
    IN PFP_SINGLE_OPERAND SingleOperand2
    );

PFP_IEEE_VALUE
KiInitializeIeeeValue (
    IN PEXCEPTION_RECORD ExceptionRecord
    );

BOOLEAN
KiInvalidCompareDouble (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN BOOLEAN CheckForSignalNan,
    IN PFP_DOUBLE_OPERAND DoubleOperand1,
    IN PFP_DOUBLE_OPERAND DoubleOperand2
    );

BOOLEAN
KiInvalidOperationDouble (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN BOOLEAN CheckForSignalNan,
    IN PFP_DOUBLE_OPERAND DoubleOperand1,
    IN PFP_DOUBLE_OPERAND DoubleOperand2
    );

BOOLEAN
KiInvalidOperationQuadword (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN ULONGLONG ResultValue
    );

BOOLEAN
KiInvalidOperationSingle (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN BOOLEAN CheckForSignalNan,
    IN PFP_SINGLE_OPERAND SingleOperand1,
    IN PFP_SINGLE_OPERAND SingleOperand2
    );

BOOLEAN
KiNormalizeDouble (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN PFP_DOUBLE_OPERAND ResultOperand,
    IN ULONGLONG StickyBits
    );

BOOLEAN
KiNormalizeQuadword (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN PFP_DOUBLE_OPERAND ResultOperand
    );

BOOLEAN
KiNormalizeSingle (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN PFP_SINGLE_OPERAND ResultOperand,
    IN ULONG StickyBits
    );

VOID
KiUnpackDouble (
    IN ULONG Source,
    IN PFP_CONTEXT_BLOCK ContextBlock,
    OUT PFP_DOUBLE_OPERAND DoubleOperand
    );

VOID
KiUnpackSingle (
    IN ULONG Source,
    IN PFP_CONTEXT_BLOCK ContextBlock,
    OUT PFP_SINGLE_OPERAND SingleOperand
    );

BOOLEAN
KiEmulateFloating (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PSW_FPCR SoftwareFpcr
    )

/*++

Routine Description:

    This function is called to emulate a floating operation and convert the
    exception status to the proper value. If the exception is an unimplemented
    operation, then the operation is emulated. Otherwise, the status code is
    just converted to its proper value.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    SoftwareFpcr - Supplies a pointer to a variable that contains a copy of
        the software FPCR.

Return Value:

    A value of TRUE is returned if the floating exception is successfully
    emulated. Otherwise, a value of FALSE is returned.

--*/

{

    ULARGE_INTEGER AhighBhigh;
    ULARGE_INTEGER AhighBlow;
    ULARGE_INTEGER AlowBhigh;
    ULARGE_INTEGER AlowBlow;
    ULONG Carry1;
    ULONG Carry2;
    BOOLEAN CompareEqual;
    BOOLEAN CompareLess;
    BOOLEAN CompareResult;
    FP_CONTEXT_BLOCK ContextBlock;
    LARGE_INTEGER DoubleDividend;
    LARGE_INTEGER DoubleDivisor;
    ULONG DoubleMantissaLow;
    LONG DoubleMantissaHigh;
    FP_DOUBLE_OPERAND DoubleOperand1;
    FP_DOUBLE_OPERAND DoubleOperand2;
    FP_DOUBLE_OPERAND DoubleOperand3;
    LARGE_INTEGER DoubleQuotient;
    PVOID ExceptionAddress;
    ULONG ExponentDifference;
    ULONG Fa;
    ULONG Fb;
    ULONG Function;
    ULONG Index;
    ALPHA_INSTRUCTION Instruction;
    ULARGE_INTEGER LargeResult;
    LONG Negation;
    LONGLONG Quadword;
    LONG SingleMantissa;
    FP_SINGLE_OPERAND SingleOperand1;
    FP_SINGLE_OPERAND SingleOperand2;
    FP_SINGLE_OPERAND SingleOperand3;
    ULONG StickyBits;
    BOOLEAN ValidOperation;

    //
    // Save the original exception address in case another exception
    // occurs.
    //

    ExceptionAddress = ExceptionRecord->ExceptionAddress;

    //
    // Any exception that occurs during the attempted emulation of the
    // floating operation causes the emulation to be aborted. The new
    // exception code and information is copied to the original exception
    // record and a value of FALSE is returned.
    //

    try {

        //
        // Fetch the faulting or trapping instruction. Check the opcode and
        // function code (including the trap enable bits) for IEEE floating
        // point operations that are expected to be emulated.
        //
        // N.B. Only a subset of the 2048 possible combinations of 11 bits
        //      in the function field are valid. A total of 88 functions
        //      are affected by missing plus and minus infinity rounding
        //      mode support in the EV4 chip.
        //

        Instruction = *((PALPHA_INSTRUCTION)ExceptionRecord->ExceptionAddress);
        DBGPRINT("KiEmulateFloating: Instruction = %.8lx, Fpcr = %.16Lx\n",
                 Instruction.Long, TrapFrame->Fpcr);
        Function = Instruction.FpOp.Function;

        ValidOperation = FALSE;
        if (Instruction.FpOp.Opcode == IEEEFP_OP) {

            //
            // Adjust the function code if the instruction is CVTST.
            //

            if (Function == CVTST_FUNC) {
                Function = CVTST_FUNC_PROPER;

            } else if (Function == CVTST_S_FUNC) {
                Function = CVTST_FUNC_PROPER | FP_TRAP_ENABLE_S;
            }

            switch (Function & FP_FUNCTION_MASK) {
            case ADDS_FUNC :
            case SUBS_FUNC :
            case MULS_FUNC :
            case DIVS_FUNC :
            case ADDT_FUNC :
            case SUBT_FUNC :
            case MULT_FUNC :
            case DIVT_FUNC :
            case CVTTQ_FUNC :
            case CVTTS_FUNC :

                switch (Function & FP_TRAP_ENABLE_MASK) {
                case FP_TRAP_ENABLE_NONE :
                case FP_TRAP_ENABLE_U :
                case FP_TRAP_ENABLE_SU :
                case FP_TRAP_ENABLE_SUI :

                    ValidOperation = TRUE;
                    break;
                }
                break;

            case CVTQS_FUNC :
            case CVTQT_FUNC :

                switch (Function & FP_TRAP_ENABLE_MASK) {
                case FP_TRAP_ENABLE_NONE :
                case FP_TRAP_ENABLE_SUI :

                    ValidOperation = TRUE;
                    break;
                }
                break;

            case CVTST_FUNC_PROPER :

                switch (Function & FP_TRAP_ENABLE_MASK) {
                case FP_TRAP_ENABLE_NONE :
                case FP_TRAP_ENABLE_S :

                    ValidOperation = TRUE;
                    break;
                }
                break;

            case CMPTEQ_FUNC :
            case CMPTLE_FUNC :
            case CMPTLT_FUNC :
            case CMPTUN_FUNC :

                ValidOperation = TRUE;
                break;
            }

        } else if (Instruction.FpOp.Opcode == FPOP_OP) {
            switch (Function) {
            case CVTLQ_FUNC :
            case CVTQL_FUNC :
            case CVTQLV_FUNC :
            case CVTQLSV_FUNC :

                ValidOperation = TRUE;
                break;
            }
        }

        if (ValidOperation == FALSE) {

            //
            // An illegal instruction, function code, format value, or trap
            // enable value was encountered. Generate an illegal instruction
            // exception.
            //

            ExceptionRecord->ExceptionCode = STATUS_ILLEGAL_INSTRUCTION;
            DBGPRINT("KiEmulateFloating: Invalid Function or Format\n");
            return FALSE;
        }

        //
        // Increment the floating emulation count.
        //

        KeGetCurrentPrcb()->KeFloatingEmulationCount += 1;

        //
        // Initialize the address of the exception record, exception frame,
        // and trap frame in the context block used during the emulation of
        // the floating point operation.
        //
        // N.B. The SoftwareFpcr and IEEE exception records are only used
        //      with IEEE mode instructions.
        //

        ContextBlock.ExceptionRecord = ExceptionRecord;
        ContextBlock.ExceptionFrame = ExceptionFrame;
        ContextBlock.TrapFrame = TrapFrame;
        ContextBlock.SoftwareFpcr = SoftwareFpcr;

        //
        // Check if the /S bit is set in the instruction. This bit is always
        // set in the case of a trigger instruction of an asynchronous trap
        // (assuming valid trap shadow) but not necessarily always set in the
        // case of an unimplemented floating instruction fault.
        //

        if ((Function & FP_TRAP_ENABLE_S) != 0) {
            ContextBlock.IeeeMode = TRUE;

        } else {
            ContextBlock.IeeeMode = FALSE;
        }

        if ((Function & FP_TRAP_ENABLE_U) != 0) {
            ContextBlock.UnderflowEnable = TRUE;

        } else {
            ContextBlock.UnderflowEnable = FALSE;
        }

        //
        // Set the current rounding mode from the rounding mode specified in
        // the instruction, or if dynamic rounding is specified, from the
        // rounding mode specified in the FPCR.
        // Set the emulation flag and emulate the floating point operation.
        // The return value is dependent on the results of the emulation.
        //

        ContextBlock.Fc = Instruction.FpOp.Fc;
        Fa = Instruction.FpOp.Fa;
        Fb = Instruction.FpOp.Fb;

        if ((Function & FP_ROUND_MASK) == FP_ROUND_D) {
            ContextBlock.Round = ((PFPCR)&TrapFrame->Fpcr)->DynamicRoundingMode;

        } else {
            ContextBlock.Round = (Function & FP_ROUND_MASK) >> FP_ROUND_SHIFT;
        }

        SoftwareFpcr->EmulationOccurred = 1;

        //
        // Unpack operands and dispense with NaNs.
        //

        switch (Function & FP_FUNCTION_MASK) {
        case ADDS_FUNC :
        case SUBS_FUNC :
        case MULS_FUNC :
        case DIVS_FUNC :

            //
            // The function has two single operand values.
            //

            KiUnpackSingle(Fa, &ContextBlock, &SingleOperand1);
            KiUnpackSingle(Fb, &ContextBlock, &SingleOperand2);

            //
            // Non-IEEE mode operate instructions trap on NaN, infinity, or
            // denormal operands.
            //

            if ((ContextBlock.IeeeMode == FALSE) &&
                ((SingleOperand1.Normal == FALSE) ||
                 (SingleOperand2.Normal == FALSE))) {
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
                return FALSE;
            }

            if ((SingleOperand1.Nan != FALSE) || (SingleOperand2.Nan != FALSE)) {

                //
                // Store a quiet NaN if the invalid operation trap
                // is disabled, or raise an exception if the invalid
                // operation trap is enabled and either of the NaNs
                // is a signaling NaN.
                //

                return KiInvalidOperationSingle(&ContextBlock,
                                                TRUE,
                                                &SingleOperand1,
                                                &SingleOperand2);
            }
            break;

        case ADDT_FUNC :
        case SUBT_FUNC :
        case MULT_FUNC :
        case DIVT_FUNC :

            //
            // The function has two double operand values.
            //

            KiUnpackDouble(Fa, &ContextBlock, &DoubleOperand1);
            KiUnpackDouble(Fb, &ContextBlock, &DoubleOperand2);

            //
            // Non-IEEE mode operate instructions trap on NaN, infinity, or
            // denormal operands.
            //

            if ((ContextBlock.IeeeMode == FALSE) &&
                ((DoubleOperand1.Normal == FALSE) ||
                 (DoubleOperand2.Normal == FALSE))) {
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
                return FALSE;
            }
            if ((DoubleOperand1.Nan != FALSE) || (DoubleOperand2.Nan != FALSE)) {

                //
                // Store a quiet NaN if the invalid operation trap
                // is disabled, or raise an exception if the invalid
                // operation trap is enabled and either of the NaNs
                // is a signaling NaN.
                //

                return KiInvalidOperationDouble(&ContextBlock,
                                                TRUE,
                                                &DoubleOperand1,
                                                &DoubleOperand2);
            }
            break;

        case CMPTEQ_FUNC :
        case CMPTLE_FUNC :
        case CMPTLT_FUNC :
        case CMPTUN_FUNC :

            //
            // The function has two double operand values.
            //

            KiUnpackDouble(Fa, &ContextBlock, &DoubleOperand1);
            KiUnpackDouble(Fb, &ContextBlock, &DoubleOperand2);

            //
            // Non-IEEE mode compare instructions trap on NaN or denormal
            // operands.
            //

            if ((ContextBlock.IeeeMode == FALSE) &&
                (((DoubleOperand1.Normal == FALSE) &&
                  (DoubleOperand1.Infinity == FALSE)) ||
                 ((DoubleOperand2.Normal == FALSE) &&
                  (DoubleOperand2.Infinity == FALSE)))) {
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
                return FALSE;
            }

            //
            // Compare operation.
            //
            // If either operand is a NaN, then check the type of compare
            // operation to determine the result value and if an exception
            // should be raised. Otherwise, if the operation is a compare
            // unordered operation, store a false result.
            //

            if ((DoubleOperand1.Nan != FALSE) || (DoubleOperand2.Nan != FALSE)) {

                //
                // If the compare is an unordered compare, then store a true
                // result (a NaN compares unordered with everything, including
                // itself). Raise an exception if the invalid operation trap
                // is enabled and either of the NaNs is a signaling NaN.
                //
                // Otherwise, if the operation is compare equal, then store a
                // false result. Raise an exception if the invalid operation
                // trap is enabled and either of the NaNs is a signaling NaN.
                //
                // Otherwise store a false result and raise an exception if
                // the invalid operation trap is enabled.
                //

                if ((Function & FP_FUNCTION_MASK) == CMPTUN_FUNC) {
                    KiSetRegisterValue(ContextBlock.Fc + 32,
                                       FP_COMPARE_TRUE,
                                       ExceptionFrame,
                                       TrapFrame);

                    return KiInvalidCompareDouble(&ContextBlock,
                                                  TRUE,
                                                  &DoubleOperand1,
                                                  &DoubleOperand2);

                } else if ((Function & FP_FUNCTION_MASK) == CMPTEQ_FUNC) {
                    KiSetRegisterValue(ContextBlock.Fc + 32,
                                       FP_COMPARE_FALSE,
                                       ExceptionFrame,
                                       TrapFrame);

                    return KiInvalidCompareDouble(&ContextBlock,
                                                  TRUE,
                                                  &DoubleOperand1,
                                                  &DoubleOperand2);

                } else {
                    KiSetRegisterValue(ContextBlock.Fc + 32,
                                       FP_COMPARE_FALSE,
                                       ExceptionFrame,
                                       TrapFrame);

                    return KiInvalidCompareDouble(&ContextBlock,
                                                  FALSE,
                                                  &DoubleOperand1,
                                                  &DoubleOperand2);
                }

            } else {
                if ((Function & FP_FUNCTION_MASK) == CMPTUN_FUNC) {
                    KiSetRegisterValue(ContextBlock.Fc + 32,
                                       FP_COMPARE_FALSE,
                                       ExceptionFrame,
                                       TrapFrame);

                    return TRUE;
                }
            }
            break;

        case CVTST_FUNC_PROPER :

            //
            // The function has one single operand value which is found in
            // the second operand.
            //

            KiUnpackSingle(Fb, &ContextBlock, &SingleOperand1);

            //
            // Non-IEEE mode convert instructions trap on NaN, infinity, or
            // denormal operands.
            //

            if ((ContextBlock.IeeeMode == FALSE) &&
                (SingleOperand1.Normal == FALSE)) {
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
                return FALSE;
            }
            break;

        case CVTTQ_FUNC :
        case CVTTS_FUNC :

            //
            // The function has one double operand value which is found in
            // the second operand.
            //

            KiUnpackDouble(Fb, &ContextBlock, &DoubleOperand1);

            //
            // Non-IEEE mode convert instructions trap on NaN, infinity, or
            // denormal operands.
            //

            if ((ContextBlock.IeeeMode == FALSE) &&
                (DoubleOperand1.Normal == FALSE)) {
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
                return FALSE;
            }
            break;

        case CVTLQ_FUNC :
        case CVTQL_FUNC :
        case CVTQS_FUNC :
        case CVTQT_FUNC :

            //
            // The function has one quadword operand value which is found in
            // the second operand.
            //

            Quadword = KiGetRegisterValue(Fb + 32,
                                          ContextBlock.ExceptionFrame,
                                          ContextBlock.TrapFrame);
            break;
        }

        //
        // Case to the proper function routine to emulate the operation.
        //

        Negation = 0;
        switch (Function & FP_FUNCTION_MASK) {

        //
        // Floating subtract operation.
        //
        // Floating subtract is accomplished by complementing the sign
        // of the second operand and then performing an add operation.
        //

        case SUBS_FUNC :
            DBGPRINT2("subs\n");
            Negation = 0x1;

        //
        // Floating add operation.
        //
        // Floating add is accomplished using signed magnitude addition.
        //
        // The exponent difference is calculated and the smaller number
        // is right shifted by the specified amount, but no more than
        // the width of the operand values (i.e., 26 for single and 55
        // for double). The shifted out value is saved for rounding.
        //
        // If the signs of the two operands are the same, then they
        // are added together after having performed the alignment
        // shift.
        //
        // If the signs of the two operands are different, then the
        // sign of the result is the sign of the larger operand and
        // the smaller operand is subtracted from the larger operand.
        // In order to avoid making a double level test (i.e., one on
        // the exponents, and one on the mantissas if the exponents
        // are equal), it is possible that the result of the subtract
        // could be negative (if the exponents are equal). If this
        // occurs, then the result sign and mantissa are complemented
        // to obtain the correct result.
        //

        case ADDS_FUNC :
            DBGPRINT2("adds\n");

            //
            // Complement the sign of the second operand if the operation
            // is subtraction.
            //

            SingleOperand2.Sign ^= Negation;

            //
            // Reorder the operands according to their exponent value
            // so that Operand1 exponent will be >= Operand2 exponent.
            //

            if (SingleOperand2.Exponent > SingleOperand1.Exponent) {
                SingleOperand3 = SingleOperand2;
                SingleOperand2 = SingleOperand1;
                SingleOperand1 = SingleOperand3;
            }

            //
            // Compute the exponent difference and shift the smaller
            // mantissa right by the difference value or 26 which ever
            // is smaller. The bits shifted out are termed the sticky
            // bits and are used later in the rounding operation.
            //

            ExponentDifference =
                SingleOperand1.Exponent - SingleOperand2.Exponent;

            if (ExponentDifference > 26) {
                ExponentDifference = 26;
            }

            StickyBits =
                    SingleOperand2.Mantissa & ((1 << ExponentDifference) - 1);
            SingleMantissa = SingleOperand2.Mantissa >> ExponentDifference;

            //
            // If the operands both have the same sign, then perform the
            // operation by adding the values together. Otherwise, if the
            // operands are not infinity, perform the operation by
            // subtracting the second operand from the first operand.
            //

            if ((SingleOperand1.Sign ^ SingleOperand2.Sign) == 0) {
                SingleOperand1.Mantissa += SingleMantissa;

            } else {
                if ((SingleOperand1.Infinity != FALSE) &&
                    (SingleOperand2.Infinity != FALSE)) {
                    return KiInvalidOperationSingle(&ContextBlock,
                                                    FALSE,
                                                    &SingleOperand1,
                                                    &SingleOperand2);

                } else if (SingleOperand1.Infinity == FALSE) {
                    if (StickyBits != 0) {
                        SingleOperand1.Mantissa -= 1;
                    }

                    SingleOperand1.Mantissa -= SingleMantissa;
                    if (SingleOperand1.Mantissa < 0) {
                        SingleOperand1.Mantissa = -SingleOperand1.Mantissa;
                        SingleOperand1.Sign ^= 0x1;
                    }

                    //
                    // If the result is exactly zero and the signs of the
                    // operands differ, then the result is plus zero except
                    // when the rounding mode is minus infinity.
                    //

                    if ((SingleOperand1.Mantissa == 0) && (StickyBits == 0)) {
                        if (ContextBlock.Round == ROUND_TO_MINUS_INFINITY) {
                            SingleOperand1.Sign = 0x1;

                        } else {
                            SingleOperand1.Sign = 0x0;
                        }
                    }
                }
            }

            //
            // Normalize and store the result value.
            //

            return KiNormalizeSingle(&ContextBlock,
                                     &SingleOperand1,
                                     StickyBits);

        case SUBT_FUNC :
            DBGPRINT2("subt\n");
            Negation = 0x1;

        case ADDT_FUNC :
            DBGPRINT2("addt\n");

            //
            // Complement the sign of the second operand if the operation
            // is subtraction.
            //

            DoubleOperand2.Sign ^= Negation;

            //
            // Reorder the operands according to their exponent value
            // so that Operand1 exponent will be >= Operand2 exponent.
            //

            if (DoubleOperand2.Exponent > DoubleOperand1.Exponent) {
                DoubleOperand3 = DoubleOperand2;
                DoubleOperand2 = DoubleOperand1;
                DoubleOperand1 = DoubleOperand3;
            }

            //
            // Compute the exponent difference and shift the smaller
            // mantissa right by the difference value or 55 which ever
            // is smaller. The bits shifted out are termed the sticky
            // bits and are used later in the rounding operation.
            //

            ExponentDifference =
                DoubleOperand1.Exponent - DoubleOperand2.Exponent;

            if (ExponentDifference > 55) {
                ExponentDifference = 55;
            }

            if (ExponentDifference >= 32) {
                ExponentDifference -= 32;
                StickyBits = (DoubleOperand2.MantissaLow) |
                    (DoubleOperand2.MantissaHigh & ((1 << ExponentDifference) - 1));

                DoubleMantissaLow =
                    DoubleOperand2.MantissaHigh >> ExponentDifference;

                DoubleMantissaHigh = 0;

            } else if (ExponentDifference > 0) {
                StickyBits =
                    DoubleOperand2.MantissaLow & ((1 << ExponentDifference) - 1);

                DoubleMantissaLow =
                    (DoubleOperand2.MantissaLow >> ExponentDifference) |
                    (DoubleOperand2.MantissaHigh << (32 - ExponentDifference));

                DoubleMantissaHigh =
                    DoubleOperand2.MantissaHigh >> ExponentDifference;

            } else {
                StickyBits = 0;
                DoubleMantissaLow = DoubleOperand2.MantissaLow;
                DoubleMantissaHigh = DoubleOperand2.MantissaHigh;
            }

            //
            // If the operands both have the same sign, then perform the
            // operation by adding the values together. Otherwise, if the
            // operands are not infinity, perform the operation by
            // subtracting the second operand from the first operand.
            //

            if ((DoubleOperand1.Sign ^ DoubleOperand2.Sign) == 0) {
                DoubleOperand1.MantissaLow += DoubleMantissaLow;
                DoubleOperand1.MantissaHigh += DoubleMantissaHigh;
                if (DoubleOperand1.MantissaLow < DoubleMantissaLow) {
                    DoubleOperand1.MantissaHigh += 1;
                }

            } else {
                if ((DoubleOperand1.Infinity != FALSE) &&
                    (DoubleOperand2.Infinity != FALSE)) {
                    return KiInvalidOperationDouble(&ContextBlock,
                                                    FALSE,
                                                    &DoubleOperand1,
                                                    &DoubleOperand2);

                } else if (DoubleOperand1.Infinity == FALSE) {
                    if (StickyBits != 0) {
                        if (DoubleOperand1.MantissaLow < 1) {
                            DoubleOperand1.MantissaHigh -= 1;
                        }

                        DoubleOperand1.MantissaLow -= 1;
                    }

                    if (DoubleOperand1.MantissaLow < DoubleMantissaLow) {
                        DoubleOperand1.MantissaHigh -= 1;
                    }

                    DoubleOperand1.MantissaLow -= DoubleMantissaLow;
                    DoubleOperand1.MantissaHigh -= DoubleMantissaHigh;
                    if (DoubleOperand1.MantissaHigh < 0) {
                        DoubleOperand1.MantissaLow = -(LONG)DoubleOperand1.MantissaLow;
                        DoubleOperand1.MantissaHigh = -DoubleOperand1.MantissaHigh;
                        if (DoubleOperand1.MantissaLow != 0) {
                            DoubleOperand1.MantissaHigh -= 1;
                        }
                        DoubleOperand1.Sign ^= 0x1;
                    }

                    //
                    // If the result is exactly zero and the signs of the
                    // operands differ, then the result is plus zero except
                    // when the rounding mode is minus infinity.
                    //

                    if ((DoubleOperand1.MantissaHigh == 0) &&
                        (DoubleOperand1.MantissaLow == 0) &&
                        (StickyBits == 0)) {
                        if (ContextBlock.Round == ROUND_TO_MINUS_INFINITY) {
                            DoubleOperand1.Sign = 0x1;

                        } else {
                            DoubleOperand1.Sign = 0x0;
                        }
                    }
                }
            }

            //
            // Normalize and store the result value.
            //

            return KiNormalizeDouble(&ContextBlock,
                                     &DoubleOperand1,
                                     StickyBits);

        //
        // Floating multiply operation.
        //
        // Floating multiply is accomplished using unsigned multiplies
        // of the mantissa values, and adding the partial results together
        // to form the total product.
        //
        // The two mantissa values are preshifted such that the final
        // result is properly aligned.
        //

        case MULS_FUNC :
            DBGPRINT2("muls\n");

            //
            // Reorder the operands according to their exponent value
            // so that Operand1 exponent will be >= Operand2 exponent.
            //

            if (SingleOperand2.Exponent > SingleOperand1.Exponent) {
                SingleOperand3 = SingleOperand2;
                SingleOperand2 = SingleOperand1;
                SingleOperand1 = SingleOperand3;
            }

            //
            // If the first operand is infinite and the second operand is
            // zero, then an invalid operation is specified.
            //

            if ((SingleOperand1.Infinity != FALSE) &&
                (SingleOperand2.Infinity == FALSE) &&
                (SingleOperand2.Mantissa == 0)) {
                return KiInvalidOperationSingle(&ContextBlock,
                                                FALSE,
                                                &SingleOperand1,
                                                &SingleOperand2);
            }

            //
            // Preshift the operand mantissas so the result will be a
            // properly aligned 64-bit value and then unsigned multiply
            // the two mantissa values. The single result is the high part
            // of the 64-bit product and the sticky bits are the low part
            // of the 64-bit product.
            //
            // The size of the product will be (1+23+2)+(1+23+2) = 52 bits
            // of which the high (1+1+23+2) = 27 bits are result and the
            // remaining 25 bits are sticky. By preshifting the operands
            // left 7 bits, the number of sticky bits is 32. This alignment
            // is convenient.
            //
            // The 7 bit preshift amount must be applied in part to both
            // operands because 26 of 32 bits of the mantissa are used and
            // so neither operand can be safely shifted left by more than 6
            // bits. Thus one operand is shifted the maximum of 6 bits and
            // the other the remaining 1 bit.
            //

            LargeResult.QuadPart = ((ULONGLONG)((ULONG)(SingleOperand1.Mantissa << (32 - 26)))) *
                                   ((ULONGLONG)((ULONG)(SingleOperand2.Mantissa << 1)));

            SingleOperand1.Mantissa = LargeResult.HighPart;
            StickyBits = LargeResult.LowPart;

            //
            // Compute the sign and exponent of the result.
            //

            SingleOperand1.Sign ^= SingleOperand2.Sign;
            SingleOperand1.Exponent +=
                        SingleOperand2.Exponent - SINGLE_EXPONENT_BIAS;

            //
            // Normalize and store the result value.
            //

            return KiNormalizeSingle(&ContextBlock,
                                     &SingleOperand1,
                                     StickyBits);

        case MULT_FUNC :
            DBGPRINT2("mult\n");

            //
            // Reorder the operands according to their exponent value
            // so that Operand1 exponent will be >= Operand2 exponent.
            //

            if (DoubleOperand2.Exponent > DoubleOperand1.Exponent) {
                DoubleOperand3 = DoubleOperand2;
                DoubleOperand2 = DoubleOperand1;
                DoubleOperand1 = DoubleOperand3;
            }

            //
            // If the first operand is infinite and the second operand is
            // zero, then an invalid operation is specified.
            //

            if ((DoubleOperand1.Infinity != FALSE) &&
                (DoubleOperand2.Infinity == FALSE) &&
                (DoubleOperand2.MantissaHigh == 0)) {
                return KiInvalidOperationDouble(&ContextBlock,
                                                FALSE,
                                                &DoubleOperand1,
                                                &DoubleOperand2);
            }

            //
            // Preshift the operand mantissas so the result will be a
            // properly aligned 128-bit value and then unsigned multiply
            // the two mantissa values. The double result is the high part
            // of the 128-bit product and the sticky bits are the low part
            // of the 128-bit product.
            //
            // The size of the product will be (1+52+2)+(1+52+2) = 110 bits
            // of which the high (1+1+52+2) = 56 bits are result and the
            // remaining 54 bits are sticky. By preshifting the operands
            // left 10 bits, the number of sticky bits is 64. This alignment
            // is convenient.
            //
            // The 10 bit preshift amount must be applied in part to both
            // operands because 55 of 64 bits of the mantissa are used and
            // so neither operand can be safely shifted left by more than 9
            // bits. Thus one operand is shifted the maximum of 9 bits and
            // the other the remaining 1 bit.
            //

            DoubleOperand1.MantissaHigh =
                    (DoubleOperand1.MantissaHigh << 1) |
                            (DoubleOperand1.MantissaLow >> 31);

            DoubleOperand1.MantissaLow <<= 1;
            DoubleOperand2.MantissaHigh =
                    (DoubleOperand2.MantissaHigh << (64 - 55)) |
                            (DoubleOperand2.MantissaLow >> (32 - (64 - 55)));

            DoubleOperand2.MantissaLow <<= (64 - 55);

            //
            // The 128-bit product is formed by multiplying and adding
            // all the cross product values.
            //
            // Consider the operands (A and B) as being composed of two
            // parts Ahigh, Alow, Bhigh, and Blow. The cross product sum
            // is then:
            //
            //       Ahigh * Bhigh * 2^64 +
            //              Ahigh * Blow * 2^32 +
            //              Alow * Bhigh * 2^32 +
            //                              Alow * Blow
            //

            AhighBhigh.QuadPart = (ULONGLONG)(ULONG)DoubleOperand1.MantissaHigh *
                                  (ULONGLONG)(ULONG)DoubleOperand2.MantissaHigh;

            AhighBlow.QuadPart = (ULONGLONG)(ULONG)DoubleOperand1.MantissaHigh *
                                 (ULONGLONG)DoubleOperand2.MantissaLow;

            AlowBhigh.QuadPart = (ULONGLONG)DoubleOperand1.MantissaLow *
                                 (ULONGLONG)(ULONG)DoubleOperand2.MantissaHigh;

            AlowBlow.QuadPart = (ULONGLONG)DoubleOperand1.MantissaLow *
                                (ULONGLONG)DoubleOperand2.MantissaLow;

            AlowBlow.HighPart += AhighBlow.LowPart;
            if (AlowBlow.HighPart < AhighBlow.LowPart) {
                Carry1 = 1;

            } else {
                Carry1 = 0;
            }

            AlowBlow.HighPart += AlowBhigh.LowPart;
            if (AlowBlow.HighPart < AlowBhigh.LowPart) {
                Carry1 += 1;
            }

            DoubleOperand1.MantissaLow = AhighBlow.HighPart + Carry1;
            if (DoubleOperand1.MantissaLow < Carry1) {
                Carry2 = 1;

            } else {
                Carry2 = 0;
            }

            DoubleOperand1.MantissaLow += AlowBhigh.HighPart;
            if (DoubleOperand1.MantissaLow < AlowBhigh.HighPart) {
                Carry2 += 1;
            }

            DoubleOperand1.MantissaLow += AhighBhigh.LowPart;
            if (DoubleOperand1.MantissaLow < AhighBhigh.LowPart) {
                Carry2 += 1;
            }

            DoubleOperand1.MantissaHigh = AhighBhigh.HighPart + Carry2;
            StickyBits = AlowBlow.HighPart | AlowBlow.LowPart;

            //
            // Compute the sign and exponent of the result.
            //

            DoubleOperand1.Sign ^= DoubleOperand2.Sign;
            DoubleOperand1.Exponent +=
                        DoubleOperand2.Exponent - DOUBLE_EXPONENT_BIAS;

            //
            // Normalize and store the result value.
            //

            return KiNormalizeDouble(&ContextBlock,
                                     &DoubleOperand1,
                                     StickyBits);

        //
        // Floating divide operation.
        //
        // Floating division is accomplished by repeated subtract using
        // a single one-bit-at-a-time algorithm. The number of division
        // steps performed is equal to the mantissa size plus one guard
        // bit.
        //
        // The sticky bits are the remainder after the specified number
        // of division steps.
        //

        case DIVS_FUNC :
            DBGPRINT2("divs\n");

            //
            // If the first operand is infinite and the second operand
            // is infinite, or both operands are zero, then an invalid
            // operation is specified.
            //

            if (((SingleOperand1.Infinity != FALSE) &&
                 (SingleOperand2.Infinity != FALSE)) ||
                ((SingleOperand1.Infinity == FALSE) &&
                 (SingleOperand1.Mantissa == 0) &&
                 (SingleOperand2.Infinity == FALSE) &&
                 (SingleOperand2.Mantissa == 0))) {
                return KiInvalidOperationSingle(&ContextBlock,
                                                FALSE,
                                                &SingleOperand1,
                                                &SingleOperand2);
            }

            //
            // If the second operand is zero, then a divide by zero
            // operation is specified.
            //

            if ((SingleOperand2.Infinity == FALSE) &&
                (SingleOperand2.Mantissa == 0)) {
                return KiDivideByZeroSingle(&ContextBlock,
                                            &SingleOperand1,
                                            &SingleOperand2);
            }

            //
            // If the first operand is infinite, then the result is
            // infinite. Otherwise, if the second operand is infinite,
            // then the result is zero (note that both operands cannot
            // be infinite).
            //

            if (SingleOperand1.Infinity != FALSE) {
                SingleOperand1.Sign ^= SingleOperand2.Sign;
                return KiNormalizeSingle(&ContextBlock,
                                         &SingleOperand1,
                                         0);

            } else if (SingleOperand2.Infinity != FALSE) {
                SingleOperand1.Sign ^= SingleOperand2.Sign;
                SingleOperand1.Exponent = 0;
                SingleOperand1.Mantissa = 0;
                return KiNormalizeSingle(&ContextBlock,
                                         &SingleOperand1,
                                         0);
            }

            //
            // Perform divide operation by repeating a single bit
            // divide step 26 iterations.
            //

            SingleOperand3.Mantissa = 0;
            for (Index = 0; Index < 26; Index += 1) {
                SingleOperand3.Mantissa <<= 1;
                if (SingleOperand1.Mantissa >= SingleOperand2.Mantissa) {
                    SingleOperand1.Mantissa -= SingleOperand2.Mantissa;
                    SingleOperand3.Mantissa |= 1;
                }

                SingleOperand1.Mantissa <<= 1;
            }

            //
            // Compute the sign and exponent of the result.
            //

            SingleOperand3.Sign = SingleOperand1.Sign ^ SingleOperand2.Sign;
            SingleOperand3.Exponent = SingleOperand1.Exponent -
                            SingleOperand2.Exponent + SINGLE_EXPONENT_BIAS;

            //
            // Normalize and store the result value.
            //

            SingleOperand3.Infinity = FALSE;
            SingleOperand3.Nan = FALSE;
            return KiNormalizeSingle(&ContextBlock,
                                     &SingleOperand3,
                                     SingleOperand1.Mantissa);

        case DIVT_FUNC :
            DBGPRINT2("divt\n");

            //
            // If the first operand is infinite and the second operand
            // is infinite, or both operands are zero, then an invalid
            // operation is specified.
            //

            if (((DoubleOperand1.Infinity != FALSE) &&
                 (DoubleOperand2.Infinity != FALSE)) ||
                ((DoubleOperand1.Infinity == FALSE) &&
                 (DoubleOperand1.MantissaHigh == 0) &&
                 (DoubleOperand2.Infinity == FALSE) &&
                 (DoubleOperand2.MantissaHigh == 0))) {
                return KiInvalidOperationDouble(&ContextBlock,
                                                FALSE,
                                                &DoubleOperand1,
                                                &DoubleOperand2);
            }

            //
            // If the second operand is zero, then a divide by zero
            // operation is specified.
            //

            if ((DoubleOperand2.Infinity == FALSE) &&
                (DoubleOperand2.MantissaHigh == 0)) {
                return KiDivideByZeroDouble(&ContextBlock,
                                            &DoubleOperand1,
                                            &DoubleOperand2);
            }

            //
            // If the first operand is infinite, then the result is
            // infinite. Otherwise, if the second operand is infinite,
            // then the result is zero (note that both operands cannot
            // be infinite).
            //

            if (DoubleOperand1.Infinity != FALSE) {
                DoubleOperand1.Sign ^= DoubleOperand2.Sign;
                return KiNormalizeDouble(&ContextBlock,
                                         &DoubleOperand1,
                                         0);

            } else if (DoubleOperand2.Infinity != FALSE) {
                DoubleOperand1.Sign ^= DoubleOperand2.Sign;
                DoubleOperand1.Exponent = 0;
                DoubleOperand1.MantissaHigh = 0;
                DoubleOperand1.MantissaLow = 0;
                return KiNormalizeDouble(&ContextBlock,
                                         &DoubleOperand1,
                                         0);
            }

            //
            // Perform divide operation by repeating a single bit
            // divide step 55 iterations.
            //

            DoubleDividend.LowPart = DoubleOperand1.MantissaLow;
            DoubleDividend.HighPart = DoubleOperand1.MantissaHigh;
            DoubleDivisor.LowPart = DoubleOperand2.MantissaLow;
            DoubleDivisor.HighPart = DoubleOperand2.MantissaHigh;
            DoubleQuotient.LowPart = 0;
            DoubleQuotient.HighPart = 0;
            for (Index = 0; Index < 55; Index += 1) {
                DoubleQuotient.HighPart =
                            (DoubleQuotient.HighPart << 1) |
                                            DoubleQuotient.LowPart >> 31;

                DoubleQuotient.LowPart <<= 1;
                if (DoubleDividend.QuadPart >= DoubleDivisor.QuadPart) {
                    DoubleDividend.QuadPart = DoubleDividend.QuadPart - DoubleDivisor.QuadPart;
                    DoubleQuotient.LowPart |= 1;
                }

                DoubleDividend.HighPart =
                            (DoubleDividend.HighPart << 1) |
                                            DoubleDividend.LowPart >> 31;

                DoubleDividend.LowPart <<= 1;
            }

            DoubleOperand3.MantissaLow = DoubleQuotient.LowPart;
            DoubleOperand3.MantissaHigh = DoubleQuotient.HighPart;

            //
            // Compute the sign and exponent of the result.
            //

            DoubleOperand3.Sign = DoubleOperand1.Sign ^ DoubleOperand2.Sign;
            DoubleOperand3.Exponent = DoubleOperand1.Exponent -
                            DoubleOperand2.Exponent + DOUBLE_EXPONENT_BIAS;

            //
            // Normalize and store the result value.
            //

            DoubleOperand3.Infinity = FALSE;
            DoubleOperand3.Nan = FALSE;
            return KiNormalizeDouble(&ContextBlock,
                                     &DoubleOperand3,
                                     DoubleDividend.LowPart | DoubleDividend.HighPart);

            //
            // Floating compare double.
            //
            // This operation is performed after having separated out NaNs,
            // and therefore the only comparison predicates left are equal
            // and less.
            //
            // Floating compare double is accomplished by comparing signs,
            // then exponents, and finally the mantissa if necessary.
            //
            // N.B. The sign of zero is ignored.
            //

        case CMPTEQ_FUNC :
        case CMPTLE_FUNC :
        case CMPTLT_FUNC :

            //
            // If either operand is zero, then set the sign of the operand
            // positive and the exponent to a value less than the minimum
            // denormal number.
            //

            if ((DoubleOperand1.Infinity == FALSE) &&
                (DoubleOperand1.MantissaHigh == 0)) {
                DoubleOperand1.Sign = 0;
                DoubleOperand1.Exponent = -52;
            }

            if ((DoubleOperand2.Infinity == FALSE) &&
                (DoubleOperand2.MantissaHigh == 0)) {
                DoubleOperand2.Sign = 0;
                DoubleOperand2.Exponent = -52;
            }

            //
            // Compare signs first.
            //

            if (DoubleOperand1.Sign < DoubleOperand2.Sign) {

                //
                // The first operand is greater than the second operand.
                //

                CompareEqual = FALSE;
                CompareLess = FALSE;

            } else if (DoubleOperand1.Sign > DoubleOperand2.Sign) {

                //
                // The first operand is less than the second operand.
                //

                CompareEqual = FALSE;
                CompareLess = TRUE;

            } else {

                //
                // The operand signs are equal.
                //
                // If the sign of the operand is negative, then the sense of
                // the comparison is reversed.
                //

                if (DoubleOperand1.Sign == 0) {

                    //
                    // Compare positive operand with positive operand.
                    //

                    if (DoubleOperand1.Exponent > DoubleOperand2.Exponent) {
                        CompareEqual = FALSE;
                        CompareLess = FALSE;

                    } else if (DoubleOperand1.Exponent < DoubleOperand2.Exponent) {
                        CompareEqual = FALSE;
                        CompareLess = TRUE;

                    } else {
                        if (DoubleOperand1.MantissaHigh >
                            DoubleOperand2.MantissaHigh) {
                            CompareEqual = FALSE;
                            CompareLess = FALSE;

                        } else if (DoubleOperand1.MantissaHigh <
                                   DoubleOperand2.MantissaHigh) {
                            CompareEqual = FALSE;
                            CompareLess = TRUE;

                        } else {
                            if (DoubleOperand1.MantissaLow >
                                DoubleOperand2.MantissaLow) {
                                CompareEqual = FALSE;
                                CompareLess = FALSE;

                            } else if (DoubleOperand1.MantissaLow <
                                       DoubleOperand2.MantissaLow) {
                                CompareEqual = FALSE;
                                CompareLess = TRUE;

                            } else {
                                CompareEqual = TRUE;
                                CompareLess = FALSE;
                            }
                        }
                    }

                } else {

                    //
                    // Compare negative operand with negative operand.
                    //

                    if (DoubleOperand2.Exponent > DoubleOperand1.Exponent) {
                        CompareEqual = FALSE;
                        CompareLess = FALSE;

                    } else if (DoubleOperand2.Exponent < DoubleOperand1.Exponent) {
                        CompareEqual = FALSE;
                        CompareLess = TRUE;

                    } else {
                        if (DoubleOperand2.MantissaHigh >
                            DoubleOperand1.MantissaHigh) {
                            CompareEqual = FALSE;
                            CompareLess = FALSE;

                        } else if (DoubleOperand2.MantissaHigh <
                                   DoubleOperand1.MantissaHigh) {
                            CompareEqual = FALSE;
                            CompareLess = TRUE;

                        } else {
                            if (DoubleOperand2.MantissaLow >
                                DoubleOperand1.MantissaLow) {
                                CompareEqual = FALSE;
                                CompareLess = FALSE;

                            } else if (DoubleOperand2.MantissaLow <
                                       DoubleOperand1.MantissaLow) {
                                CompareEqual = FALSE;
                                CompareLess = TRUE;

                            } else {
                                CompareEqual = TRUE;
                                CompareLess = FALSE;
                            }
                        }
                    }
                }
            }

            //
            // Form the condition code result value using the comparison
            // information and the compare function codes.
            //

            switch (Function & FP_FUNCTION_MASK) {
            case CMPTEQ_FUNC :
                CompareResult = CompareEqual;
                DBGPRINT2("cmpteq\n");
                break;

            case CMPTLE_FUNC :
                CompareResult = (CompareLess | CompareEqual);
                DBGPRINT2("cmptle\n");
                break;

            case CMPTLT_FUNC :
                CompareResult = CompareLess;
                DBGPRINT2("cmptlt\n");
                break;
            }

            //
            // Set the result operand to 2.0 if the comparison is true,
            // otherwise store 0.0.
            //

            if (CompareResult != FALSE) {
                KiSetRegisterValue(ContextBlock.Fc + 32,
                                   FP_COMPARE_TRUE,
                                   ExceptionFrame,
                                   TrapFrame);

            } else {
                KiSetRegisterValue(ContextBlock.Fc + 32,
                                   FP_COMPARE_FALSE,
                                   ExceptionFrame,
                                   TrapFrame);
            }
            return TRUE;

        //
        // Floating convert single to double.
        //
        // Floating conversion to double is accomplished by forming a
        // double floating operand and then normalizing and storing
        // the result value.
        //

        case CVTST_FUNC_PROPER :
            DBGPRINT2("cvtst\n");

            //
            // If the operand is a NaN, then store a quiet NaN if the
            // invalid operation trap is disabled, or raise an exception
            // if the invalid operation trap is enabled and the operand
            // is a signaling NaN.
            //

            if (SingleOperand1.Nan != FALSE) {
                DoubleOperand1.MantissaHigh =
                        SingleOperand1.Mantissa >> (26 - (55 - 32));
                DoubleOperand1.MantissaLow =
                        SingleOperand1.Mantissa << (32 - (26 - (55 - 32)));
                DoubleOperand1.Exponent = DOUBLE_MAXIMUM_EXPONENT;
                DoubleOperand1.Sign = SingleOperand1.Sign;
                DoubleOperand1.Infinity = FALSE;
                DoubleOperand1.Nan = TRUE;
                return KiInvalidOperationDouble(&ContextBlock,
                                                TRUE,
                                                &DoubleOperand1,
                                                &DoubleOperand1);
            }

            //
            // Transform the single operand to double format.
            //

            DoubleOperand1.MantissaHigh =
                        SingleOperand1.Mantissa >> (26 - (55 - 32));
            DoubleOperand1.MantissaLow =
                        SingleOperand1.Mantissa << (32 - (26 - (55 - 32)));
            DoubleOperand1.Exponent = SingleOperand1.Exponent +
                                DOUBLE_EXPONENT_BIAS - SINGLE_EXPONENT_BIAS;
            DoubleOperand1.Sign = SingleOperand1.Sign;
            DoubleOperand1.Infinity = SingleOperand1.Infinity;
            DoubleOperand1.Nan = FALSE;

            //
            // Normalize and store the result value.
            //

            return KiNormalizeDouble(&ContextBlock,
                                     &DoubleOperand1,
                                     0);

        //
        // Floating convert double to single.
        //
        // Floating conversion to single is accomplished by forming a
        // single floating operand and then normalizing and storing the
        // result value.
        //

        case CVTTS_FUNC :
            DBGPRINT2("cvtts\n");

            //
            // If the operand is a NaN, then store a quiet NaN if the
            // invalid operation trap is disabled, or raise an exception
            // if the invalid operation trap is enabled and the operand
            // is a signaling NaN.
            //

            if (DoubleOperand1.Nan != FALSE) {
                SingleOperand1.Mantissa =
                    (DoubleOperand1.MantissaHigh << (26 - (55 - 32))) |
                    (DoubleOperand1.MantissaLow >> (32 - (26 - (55 - 32))));
                SingleOperand1.Exponent = SINGLE_MAXIMUM_EXPONENT;
                SingleOperand1.Sign = DoubleOperand1.Sign;
                SingleOperand1.Infinity = FALSE;
                SingleOperand1.Nan = TRUE;
                return KiInvalidOperationSingle(&ContextBlock,
                                                TRUE,
                                                &SingleOperand1,
                                                &SingleOperand1);
            }

            //
            // Transform the double operand to single format.
            //

            SingleOperand1.Mantissa =
                (DoubleOperand1.MantissaHigh << (26 - (55 - 32))) |
                (DoubleOperand1.MantissaLow >> (32 - (26 - (55 - 32))));
            StickyBits = DoubleOperand1.MantissaLow << (26 - (55 - 32));
            SingleOperand1.Exponent = DoubleOperand1.Exponent +
                                SINGLE_EXPONENT_BIAS - DOUBLE_EXPONENT_BIAS;
            SingleOperand1.Sign = DoubleOperand1.Sign;
            SingleOperand1.Infinity = DoubleOperand1.Infinity;
            SingleOperand1.Nan = FALSE;

            //
            // Normalize and store the result value.
            //

            return KiNormalizeSingle(&ContextBlock,
                                     &SingleOperand1,
                                     StickyBits);

        //
        // Floating convert longword to quadword.
        //
        // Floating conversion from longword to quadword is accomplished by
        // a repositioning of 32 bits of the operand, with sign extension.
        //

        case CVTLQ_FUNC :
            DBGPRINT2("cvtlq\n");

            //
            // Pack floating register longword format into upper 32-bits
            // by keeping bits 63..62 and 58..29, eliminating unused bits
            // 61..59. Then right justify and sign extend the 32 bits into
            // 64 bits.
            //

            Quadword = ((Quadword >> 62) << 62) | ((ULONGLONG)(Quadword << 5) >> 2);
            KiSetRegisterValue(ContextBlock.Fc + 32,
                               Quadword >> 32,
                               ExceptionFrame,
                               TrapFrame);

            return TRUE;

        //
        // Floating convert quadword to longword.
        //
        // Floating conversion from quadword to longword is accomplished by
        // truncating the high order 32 bits of the quadword after checking
        // for overflow.
        //

        case CVTQL_FUNC :
            DBGPRINT2("cvtql\n");

            return KiConvertQuadwordToLongword(&ContextBlock, Quadword);

        //
        // Floating convert quadword to single.
        //
        // Floating conversion to single is accomplished by forming a
        // single floating operand and then normalizing and storing the
        // result value.
        //

        case CVTQS_FUNC :
            DBGPRINT2("cvtqs\n");

            //
            // Compute the sign of the result.
            //

            if (Quadword < 0) {
                SingleOperand1.Sign = 0x1;
                Quadword = -Quadword;

            } else {
                SingleOperand1.Sign = 0;
            }

            //
            // Initialize the infinity and NaN values.
            //

            SingleOperand1.Infinity = FALSE;
            SingleOperand1.Nan = FALSE;

            //
            // Compute the exponent value and normalize the quadword
            // value.
            //

            if (Quadword != 0) {
                SingleOperand1.Exponent = SINGLE_EXPONENT_BIAS + 63;
                while (Quadword > 0) {
                    Quadword <<= 1;
                    SingleOperand1.Exponent -= 1;
                }

                SingleOperand1.Mantissa = (LONG)((ULONGLONG)Quadword >> (64 - 26));
                if (Quadword & (((ULONGLONG)1 << (64 - 26)) - 1)) {
                    StickyBits = 1;

                } else {
                    StickyBits = 0;
                }

            } else {
                SingleOperand1.Exponent = 0;
                SingleOperand1.Mantissa = 0;
                StickyBits = 0;
            }

            //
            // Normalize and store the result value.
            //

            return KiNormalizeSingle(&ContextBlock,
                                     &SingleOperand1,
                                     StickyBits);

        //
        // Floating convert quadword to double.
        //
        // Floating conversion to double is accomplished by forming a
        // double floating operand and then normalizing and storing the
        // result value.
        //

        case CVTQT_FUNC :
            DBGPRINT2("cvtqt\n");

            //
            // Compute the sign of the result.
            //

            if (Quadword < 0) {
                DoubleOperand1.Sign = 0x1;
                Quadword = -Quadword;

            } else {
                DoubleOperand1.Sign = 0;
            }

            //
            // Initialize the infinity and NaN values.
            //

            DoubleOperand1.Infinity = FALSE;
            DoubleOperand1.Nan = FALSE;

            //
            // Compute the exponent value and normalize the quadword
            // value.
            //

            if (Quadword != 0) {
                DoubleOperand1.Exponent = DOUBLE_EXPONENT_BIAS + 63;
                while (Quadword > 0) {
                    Quadword <<= 1;
                    DoubleOperand1.Exponent -= 1;
                }

                DoubleOperand1.MantissaHigh = (LONG)((ULONGLONG)Quadword >> ((64 - 55) + 32));
                DoubleOperand1.MantissaLow = (LONG)((ULONGLONG)Quadword >> (64 - 55));
                if (Quadword & (((ULONGLONG)1 << (64 - 55)) - 1)) {
                    StickyBits = 1;

                } else {
                    StickyBits = 0;
                }

            } else {
                DoubleOperand1.MantissaHigh = 0;
                DoubleOperand1.MantissaLow = 0;
                DoubleOperand1.Exponent = 0;
                StickyBits = 0;
            }

            //
            // Normalize and store the result value.
            //

            return KiNormalizeDouble(&ContextBlock,
                                     &DoubleOperand1,
                                     StickyBits);

        //
        // Floating convert double to quadword.
        //
        // Floating conversion to quadword is accomplished by forming
        // a quadword value from a double floating value.
        //

        case CVTTQ_FUNC :
            DBGPRINT2("cvttq\n");

            //
            // If the operand is infinite or is a NaN, then store a
            // quiet NaN or an appropriate infinity if the invalid
            // operation trap is disabled, or raise an exception if
            // the invalid trap is enabled.
            //

            if ((DoubleOperand1.Infinity != FALSE) ||
                (DoubleOperand1.Nan != FALSE)) {
                return KiInvalidOperationQuadword(&ContextBlock, 0);
            }

            //
            // Convert double to quadword and store the result value.
            //

            return KiNormalizeQuadword(&ContextBlock, &DoubleOperand1);
        }

    //
    // If an exception occurs, then copy the new exception information to the
    // original exception record and handle the exception.
    //

    } except (KiCopyInformation(ExceptionRecord,
                                (GetExceptionInformation())->ExceptionRecord)) {

        //
        // Preserve the original exception address.
        //

        ExceptionRecord->ExceptionAddress = ExceptionAddress;
        DBGPRINT("KiEmulateFloating: Exception\n");
        return FALSE;
    }

    DBGPRINT("KiEmulateFloating: Invalid Instruction\n");
    return FALSE;
}

ULONGLONG
KiConvertSingleOperandToRegister (
    IN ULONG SingleValue
    )

/*++

Routine Description:

    This function converts a 32-bit single format floating point value to
    the 64-bit, double format used within floating point registers. Alpha
    floating point registers are 64-bits wide and single format values are
    transformed to 64-bits when stored or loaded from memory.

Arguments:

    SingleValue - Supplies the 32-bit single operand value as an integer.

Return Value:

    The 64-bit register format operand value is returned as the function
    value.

--*/

{
    PDOUBLE_FORMAT DoubleFormat;
    ULONGLONG Result;
    PSINGLE_FORMAT SingleFormat;

    SingleFormat = (PSINGLE_FORMAT)&SingleValue;
    DoubleFormat = (PDOUBLE_FORMAT)&Result;

    DoubleFormat->Sign = SingleFormat->Sign;
    DoubleFormat->Mantissa = ((ULONGLONG)SingleFormat->Mantissa) << (52 - 23);
    if (SingleFormat->Exponent == SINGLE_MAXIMUM_EXPONENT) {
        DoubleFormat->Exponent = DOUBLE_MAXIMUM_EXPONENT;

    } else if (SingleFormat->Exponent == SINGLE_MINIMUM_EXPONENT) {
        DoubleFormat->Exponent = DOUBLE_MINIMUM_EXPONENT;

    } else {
        DoubleFormat->Exponent = SingleFormat->Exponent - SINGLE_EXPONENT_BIAS +
                                 DOUBLE_EXPONENT_BIAS;
    }
    return Result;
}

ULONG
KiConvertRegisterToSingleOperand (
    IN ULONGLONG DoubleValue
    )

/*++

Routine Description:

    This function converts the 64-bit, double format floating point value
    used within the floating point registers to a 32-bit, single format
    floating point value.

Arguments:

    DoubleValue - Supplies the 64-bit double operand value as an integer.

Return Value:

    The 32-bit register format operand value is returned as the function
    value.

--*/

{
    PDOUBLE_FORMAT DoubleFormat;
    ULONG Result;
    PSINGLE_FORMAT SingleFormat;

    SingleFormat = (PSINGLE_FORMAT)&Result;
    DoubleFormat = (PDOUBLE_FORMAT)&DoubleValue;

    SingleFormat->Sign = (ULONG)DoubleFormat->Sign;
    SingleFormat->Mantissa = (ULONG)(DoubleFormat->Mantissa >> (52 - 23));
    if (DoubleFormat->Exponent == DOUBLE_MAXIMUM_EXPONENT) {
        SingleFormat->Exponent = SINGLE_MAXIMUM_EXPONENT;

    } else if (DoubleFormat->Exponent == DOUBLE_MINIMUM_EXPONENT) {
        SingleFormat->Exponent = SINGLE_MINIMUM_EXPONENT;

    } else {
        SingleFormat->Exponent = (ULONG)(DoubleFormat->Exponent - DOUBLE_EXPONENT_BIAS +
                                         SINGLE_EXPONENT_BIAS);
    }
    return Result;
}

BOOLEAN
KiConvertQuadwordToLongword (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN LONGLONG Quadword
    )

/*++

Routine Description:

    This function is called to convert a quadword operand to a longword
    result.

Arguments:

    ContextBlock - Supplies a pointer to the emulation context block.

    Operand - Supplies the quadword operand value.

Return Value:

    If the quadword value would overflow the longword result and the invalid
    trap is enabled then a value of FALSE is returned. Otherwise, the quadword
    is truncated to a longword and a value of TRUE is returned.

--*/

{
    PEXCEPTION_RECORD ExceptionRecord;
    PFPCR Fpcr;
    PFP_IEEE_VALUE IeeeValue;
    ULONGLONG ResultValue;
    PSW_FPCR SoftwareFpcr;

    //
    // Truncate the quadword to a longword and convert the longword integer
    // to floating register longword integer format.
    //

    ResultValue = ((Quadword & (ULONGLONG)0xc0000000) << 32) |
                  ((Quadword & (ULONGLONG)0x3fffffff) << 29);

    //
    // Check to determine if an exception should be delivered or the result
    // should be written to the destination register.
    //

    if ((Quadword < (LONG)0x80000000) || (Quadword > (LONG)0x7fffffff)) {
        Fpcr = (PFPCR)&ContextBlock->TrapFrame->Fpcr;
        Fpcr->InvalidOperation = 1;
        Fpcr->SummaryBit = 1;
        if (ContextBlock->IeeeMode == FALSE) {
            ExceptionRecord = ContextBlock->ExceptionRecord;
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
            return FALSE;
        }
        SoftwareFpcr = ContextBlock->SoftwareFpcr;
        SoftwareFpcr->StatusInvalid = 1;
        if (SoftwareFpcr->EnableInvalid != 0) {
            ExceptionRecord = ContextBlock->ExceptionRecord;
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
            IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
            IeeeValue->Value.U64Value.LowPart = LOW_PART(ResultValue);
            IeeeValue->Value.U64Value.HighPart = HIGH_PART(ResultValue);
            return FALSE;
        }

        Fpcr->DisableInvalid = 1;
    }

    //
    // Set the destination register value and return a value of TRUE.
    //

    KiSetRegisterValue(ContextBlock->Fc + 32,
                       ResultValue,
                       ContextBlock->ExceptionFrame,
                       ContextBlock->TrapFrame);
    return TRUE;
}

BOOLEAN
KiDivideByZeroDouble (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN PFP_DOUBLE_OPERAND DoubleOperand1,
    IN PFP_DOUBLE_OPERAND DoubleOperand2
    )

/*++

Routine Description:

    This function is called to either raise an exception or store a
    quiet NaN or properly signed infinity for a divide by zero double
    floating operation.

Arguments:

    ContextBlock - Supplies a pointer to the emulation context block.

    DoubleOperand1 - Supplies a pointer to the first operand value.

    DoubleOperand2 - Supplies a pointer ot the second operand value.

Return Value:

    If the divide by zero trap is enabled and the dividend is not infinite,
    then a value of FALSE is returned. Otherwise, a quiet NaN or a properly
    signed infinity is stored as the destination result and a value of TRUE
    is returned.

--*/

{

    PEXCEPTION_RECORD ExceptionRecord;
    PFPCR Fpcr;
    PFP_IEEE_VALUE IeeeValue;
    ULONG ResultSign;
    ULONG ResultValueHigh;
    ULONG ResultValueLow;
    PSW_FPCR SoftwareFpcr;

    //
    // The result value is a properly signed infinity.
    //

    ResultSign = DoubleOperand1->Sign ^ DoubleOperand2->Sign;
    ResultValueHigh = DOUBLE_INFINITY_VALUE_HIGH | (ResultSign << 31);
    ResultValueLow = DOUBLE_INFINITY_VALUE_LOW;

    //
    // If the first operand is not infinite and the divide by zero trap is
    // enabled, then store the proper exception code and exception flags
    // and return a value of FALSE. Otherwise, store the appropriately signed
    // infinity and return a value of TRUE.
    //

    if (DoubleOperand1->Infinity == FALSE) {

        Fpcr = (PFPCR)&ContextBlock->TrapFrame->Fpcr;
        Fpcr->DivisionByZero = 1;
        Fpcr->SummaryBit = 1;
        if (ContextBlock->IeeeMode == FALSE) {
            ExceptionRecord = ContextBlock->ExceptionRecord;
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
            return FALSE;
        }
        SoftwareFpcr = ContextBlock->SoftwareFpcr;
        SoftwareFpcr->StatusDivisionByZero = 1;
        if (SoftwareFpcr->EnableDivisionByZero != 0) {
            ExceptionRecord = ContextBlock->ExceptionRecord;
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
            IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
            IeeeValue->Value.Fp64Value.W[0] = ResultValueLow;
            IeeeValue->Value.Fp64Value.W[1] = ResultValueHigh;
            return FALSE;
        }

        Fpcr->DisableDivisionByZero = 1;
    }

    KiSetRegisterValue(ContextBlock->Fc + 32,
                       MAKE_QUAD(ResultValueLow, ResultValueHigh),
                       ContextBlock->ExceptionFrame,
                       ContextBlock->TrapFrame);

    return TRUE;
}

BOOLEAN
KiDivideByZeroSingle (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN PFP_SINGLE_OPERAND SingleOperand1,
    IN PFP_SINGLE_OPERAND SingleOperand2
    )

/*++

Routine Description:

    This function is called to either raise an exception or store a
    quiet NaN or properly signed infinity for a divide by zero single
    floating operation.

Arguments:

    ContextBlock - Supplies a pointer to the emulation context block.

    SingleOperand1 - Supplies a pointer to the first operand value.

    SingleOperand2 - Supplies a pointer ot the second operand value.

Return Value:

    If the divide by zero trap is enabled and the dividend is not infinite,
    then a value of FALSE is returned. Otherwise, a quiet NaN or a properly
    signed infinity is stored as the destination result and a value of TRUE
    is returned.

--*/

{

    PEXCEPTION_RECORD ExceptionRecord;
    PFPCR Fpcr;
    PFP_IEEE_VALUE IeeeValue;
    ULONG ResultSign;
    ULONG ResultValue;
    PSW_FPCR SoftwareFpcr;

    //
    // The result value is a properly signed infinity.
    //

    ResultSign = SingleOperand1->Sign ^ SingleOperand2->Sign;
    ResultValue = SINGLE_INFINITY_VALUE | (ResultSign << 31);

    //
    // If the first operand is not infinite and the divide by zero trap is
    // enabled, then store the proper exception code and exception flags
    // and return a value of FALSE. Otherwise, store the appropriately signed
    // infinity and return a value of TRUE.
    //

    if (SingleOperand1->Infinity == FALSE) {

        Fpcr = (PFPCR)&ContextBlock->TrapFrame->Fpcr;
        Fpcr->DivisionByZero = 1;
        Fpcr->SummaryBit = 1;
        if (ContextBlock->IeeeMode == FALSE) {
            ExceptionRecord = ContextBlock->ExceptionRecord;
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
            return FALSE;
        }
        SoftwareFpcr = ContextBlock->SoftwareFpcr;
        SoftwareFpcr->StatusDivisionByZero = 1;
        if (SoftwareFpcr->EnableDivisionByZero != 0) {
            ExceptionRecord = ContextBlock->ExceptionRecord;
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
            IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
            IeeeValue->Value.Fp32Value.W[0] = ResultValue;
            return FALSE;
        }

        Fpcr->DisableDivisionByZero = 1;
    }

    KiSetRegisterValue(ContextBlock->Fc + 32,
                       KiConvertSingleOperandToRegister(ResultValue),
                       ContextBlock->ExceptionFrame,
                       ContextBlock->TrapFrame);

    return TRUE;
}

PFP_IEEE_VALUE
KiInitializeIeeeValue (
    IN PEXCEPTION_RECORD ExceptionRecord
    )

/*++

Routine Description:

    This function is called to initialize an IEEE exception record.

    N.B. The original hardware exception record should be overwritten with an
         IEEE exception record only when it is known for certain that an IEEE
         exception must be generated.

Arguments:

    ExceptionRecord - Supplies a pointer to the exception record.

Return Value:

    The address of the IEEE value portion of the exception record is returned
    as the function value.

--*/

{

    //
    // Initialize the number of exception information parameters, zero
    // the first parameter to indicate a hardware initiated exception,
    // set the continuation address, and clear the IEEE exception value.
    //

    ExceptionRecord->NumberParameters = 6;
    ExceptionRecord->ExceptionInformation[0] = 0;
    ExceptionRecord->ExceptionInformation[1] =
        ((ULONG_PTR)(ExceptionRecord)->ExceptionAddress) + 4;
    ExceptionRecord->ExceptionInformation[2] = 0;
    ExceptionRecord->ExceptionInformation[3] = 0;
    ExceptionRecord->ExceptionInformation[4] = 0;
    ExceptionRecord->ExceptionInformation[5] = 0;

    //
    // Return address of IEEE exception value.
    //

    return (PFP_IEEE_VALUE)&ExceptionRecord->ExceptionInformation[2];
}

BOOLEAN
KiInvalidCompareDouble (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN BOOLEAN CheckForSignalNan,
    IN PFP_DOUBLE_OPERAND DoubleOperand1,
    IN PFP_DOUBLE_OPERAND DoubleOperand2
    )

/*++

Routine Description:

    This function is called to determine whether an invalid operation
    exception should be raised for a double compare operation.

Arguments:

    ContextBlock - Supplies a pointer to the emulation context block.

    CheckForSignalNan - Supplies a boolean value that determines whether the
        operand values should be checked for a signaling NaN.

    DoubleOperand1 - Supplies a pointer to the first operand value.

    DoubleOperand2 - Supplies a pointer ot the second operand value.

Return Value:

    If the invalid operation trap is enabled and either the operation is
    invalid or one of the operands in a signaling NaN, then a value of
    FALSE is returned. Otherwise, no operation is performed and a value
    of TRUE is returned.

--*/

{

    PEXCEPTION_RECORD ExceptionRecord;
    PFPCR Fpcr;
    PFP_IEEE_VALUE IeeeValue;
    PSW_FPCR SoftwareFpcr;

    //
    // If an invalid operation is specified or one of the operands is a
    // signaling NaN and the invalid operation trap is enabled, then
    // store the proper exception code and exception flags and return
    // a value of FALSE. Otherwise, perform no operation and return a
    // value of TRUE.
    //

    if ((CheckForSignalNan == FALSE) ||
        (DoubleSignalNan(DoubleOperand1) != FALSE) ||
        (DoubleSignalNan(DoubleOperand2) != FALSE)) {

        Fpcr = (PFPCR)&ContextBlock->TrapFrame->Fpcr;
        Fpcr->InvalidOperation = 1;
        Fpcr->SummaryBit = 1;
        if (ContextBlock->IeeeMode == FALSE) {
            ExceptionRecord = ContextBlock->ExceptionRecord;
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
            return FALSE;
        }
        SoftwareFpcr = ContextBlock->SoftwareFpcr;
        SoftwareFpcr->StatusInvalid = 1;
        if (SoftwareFpcr->EnableInvalid != 0) {
            ExceptionRecord = ContextBlock->ExceptionRecord;
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
            IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
            IeeeValue->Value.CompareValue = FpCompareUnordered;
            return FALSE;
        }

        Fpcr->DisableInvalid = 1;
    }

    return TRUE;
}

BOOLEAN
KiInvalidOperationDouble (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN BOOLEAN CheckForSignalNan,
    IN PFP_DOUBLE_OPERAND DoubleOperand1,
    IN PFP_DOUBLE_OPERAND DoubleOperand2
    )

/*++

Routine Description:

    This function is called to either raise an exception or store a
    quiet NaN for an invalid double floating operation.

Arguments:

    ContextBlock - Supplies a pointer to the emulation context block.

    CheckForSignalNan - Supplies a boolean value that determines whether the
        operand values should be checked for a signaling NaN.

    DoubleOperand1 - Supplies a pointer to the first operand value.

    DoubleOperand2 - Supplies a pointer ot the second operand value.

Return Value:

    If the invalid operation trap is enabled and either the operation is
    invalid or one of the operands in a signaling NaN, then a value of
    FALSE is returned. Otherwise, a quiet NaN is stored as the destination
    result and a value of TRUE is returned.

--*/

{

    PEXCEPTION_RECORD ExceptionRecord;
    PFPCR Fpcr;
    PFP_IEEE_VALUE IeeeValue;
    ULONG ResultValueHigh;
    ULONG ResultValueLow;
    PSW_FPCR SoftwareFpcr;

    //
    // If the second operand is a NaN, then compute a quiet NaN from its
    // value. Otherwise, if the first operand is a NaN, then compute a
    // quiet NaN from its value. Otherwise, the result value is a quiet
    // (real indefinite) NaN.
    //

    DBGPRINT("Operand1: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x%.8x\n",
             DoubleOperand1->Infinity, DoubleOperand1->Nan,
             DoubleOperand1->Sign,
             DoubleOperand1->Exponent,
             DoubleOperand1->MantissaHigh, DoubleOperand1->MantissaLow);
    DBGPRINT("Operand2: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x%.8x\n",
             DoubleOperand2->Infinity, DoubleOperand2->Nan,
             DoubleOperand2->Sign,
             DoubleOperand2->Exponent,
             DoubleOperand2->MantissaHigh, DoubleOperand2->MantissaLow);

    if (DoubleOperand2->Nan != FALSE) {
        ResultValueLow = DoubleOperand2->MantissaLow >> 2;
        ResultValueLow |= DoubleOperand2->MantissaHigh << 30;
        ResultValueHigh = DoubleOperand2->MantissaHigh >> 2;
        ResultValueHigh |= DOUBLE_QUIET_NAN_PREFIX_HIGH;
        ResultValueHigh |= DoubleOperand2->Sign << 31;

    } else if (DoubleOperand1->Nan != FALSE) {
        ResultValueLow = DoubleOperand1->MantissaLow >> 2;
        ResultValueLow |= DoubleOperand1->MantissaHigh << 30;
        ResultValueHigh = DoubleOperand1->MantissaHigh >> 2;
        ResultValueHigh |= DOUBLE_QUIET_NAN_PREFIX_HIGH;
        ResultValueHigh |= DoubleOperand1->Sign << 31;

    } else {
        ResultValueLow = DOUBLE_QUIET_NAN_VALUE_LOW;
        ResultValueHigh = DOUBLE_QUIET_NAN_VALUE_HIGH;
    }

    //
    // If an invalid operation is specified or one of the operands is a
    // signaling NaN and the invalid operation trap is enabled, then
    // store the proper exception code and exception flags and return
    // a value of FALSE. Otherwise, store a quiet NaN as the destination
    // result and return a value of TRUE.
    //

    if ((CheckForSignalNan == FALSE) ||
        (DoubleSignalNan(DoubleOperand1) != FALSE) ||
        (DoubleSignalNan(DoubleOperand2) != FALSE)) {

        Fpcr = (PFPCR)&ContextBlock->TrapFrame->Fpcr;
        Fpcr->InvalidOperation = 1;
        Fpcr->SummaryBit = 1;
        if (ContextBlock->IeeeMode == FALSE) {
            ExceptionRecord = ContextBlock->ExceptionRecord;
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
            return FALSE;
        }
        SoftwareFpcr = ContextBlock->SoftwareFpcr;
        SoftwareFpcr->StatusInvalid = 1;
        if (SoftwareFpcr->EnableInvalid != 0) {
            ExceptionRecord = ContextBlock->ExceptionRecord;
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
            IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
            IeeeValue->Value.Fp64Value.W[0] = ResultValueLow;
            IeeeValue->Value.Fp64Value.W[1] = ResultValueHigh;
            return FALSE;
        }

        Fpcr->DisableInvalid = 1;
    }

    KiSetRegisterValue(ContextBlock->Fc + 32,
                       MAKE_QUAD(ResultValueLow, ResultValueHigh),
                       ContextBlock->ExceptionFrame,
                       ContextBlock->TrapFrame);

    return TRUE;
}

BOOLEAN
KiInvalidOperationQuadword (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN ULONGLONG ResultValue
    )

/*++

Routine Description:

    This function is called to either raise an exception or store a
    quiet NaN for an invalid conversion to quadword.

Arguments:

    ContextBlock - Supplies a pointer to the emulation context block.

    ResultValue - Suplies a quadword result value to be stored.

Return Value:

    If the invalid operation trap is enabled, then a value of FALSE is
    returned. Otherwise, an appropriate quadword value is stored as the
    destination result and a value of TRUE is returned.

--*/

{

    PEXCEPTION_RECORD ExceptionRecord;
    PFPCR Fpcr;
    PFP_IEEE_VALUE IeeeValue;
    PSW_FPCR SoftwareFpcr;

    //
    // If the invalid operation trap is enabled then store the proper
    // exception code and exception flags and return a value of FALSE.
    // Otherwise, store a quiet NaN as the destination result and return
    // a value of TRUE.
    //

    Fpcr = (PFPCR)&ContextBlock->TrapFrame->Fpcr;
    Fpcr->InvalidOperation = 1;
    Fpcr->SummaryBit = 1;
    if (ContextBlock->IeeeMode == FALSE) {
        ExceptionRecord = ContextBlock->ExceptionRecord;
        ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
        return FALSE;
    }
    SoftwareFpcr = ContextBlock->SoftwareFpcr;
    SoftwareFpcr->StatusInvalid = 1;
    if (SoftwareFpcr->EnableInvalid != 0) {
        ExceptionRecord = ContextBlock->ExceptionRecord;
        ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
        IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
        IeeeValue->Value.U64Value.LowPart = LOW_PART(ResultValue);
        IeeeValue->Value.U64Value.HighPart = HIGH_PART(ResultValue);
        return FALSE;
    }

    Fpcr->DisableInvalid = 1;

    KiSetRegisterValue(ContextBlock->Fc + 32,
                       ResultValue,
                       ContextBlock->ExceptionFrame,
                       ContextBlock->TrapFrame);

    return TRUE;
}

BOOLEAN
KiInvalidOperationSingle (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN BOOLEAN CheckForSignalNan,
    IN PFP_SINGLE_OPERAND SingleOperand1,
    IN PFP_SINGLE_OPERAND SingleOperand2
    )

/*++

Routine Description:

    This function is called to either raise an exception or store a
    quiet NaN for an invalid single floating operation.

Arguments:

    ContextBlock - Supplies a pointer to the emulation context block.

    CheckForSignalNan - Supplies a boolean value that determines whether the
        operand values should be checked for a signaling NaN.

    SingleOperand1 - Supplies a pointer to the first operand value.

    SingleOperand2 - Supplies a pointer ot the second operand value.

Return Value:

    If the invalid operation trap is enabled and either the operation is
    invalid or one of the operands in a signaling NaN, then a value of
    FALSE is returned. Otherwise, a quiet NaN is stored as the destination
    result and a value of TRUE is returned.

--*/

{

    PEXCEPTION_RECORD ExceptionRecord;
    PFPCR Fpcr;
    PFP_IEEE_VALUE IeeeValue;
    ULONG ResultValue;
    PSW_FPCR SoftwareFpcr;

    //
    // If the second operand is a NaN, then compute a quiet NaN from its
    // value. Otherwise, if the first operand is a NaN, then compute a
    // quiet NaN from its value. Otherwise, the result value is a quiet
    // (real indefinite) NaN.
    //

    if (SingleOperand2->Nan != FALSE) {
        ResultValue = SingleOperand2->Mantissa >> 2;
        ResultValue |= SINGLE_QUIET_NAN_PREFIX;
        ResultValue |= SingleOperand2->Sign << 31;

    } else if (SingleOperand1->Nan != FALSE) {
        ResultValue = SingleOperand1->Mantissa >> 2;
        ResultValue |= SINGLE_QUIET_NAN_PREFIX;
        ResultValue |= SingleOperand1->Sign << 31;

    } else {
        ResultValue = SINGLE_QUIET_NAN_VALUE;
    }

    //
    // If an invalid operation is specified or one of the operands is a
    // signaling NaN and the invalid operation trap is enabled, then
    // store the proper exception code and exception flags and return
    // a value of FALSE. Otherwise, store a quiet NaN as the destination
    // result and return a value of TRUE.
    //

    if ((CheckForSignalNan == FALSE) ||
        (SingleSignalNan(SingleOperand1) != FALSE) ||
        (SingleSignalNan(SingleOperand2) != FALSE)) {

        Fpcr = (PFPCR)&ContextBlock->TrapFrame->Fpcr;
        Fpcr->InvalidOperation = 1;
        Fpcr->SummaryBit = 1;
        if (ContextBlock->IeeeMode == FALSE) {
            ExceptionRecord = ContextBlock->ExceptionRecord;
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
            return FALSE;
        }
        SoftwareFpcr = ContextBlock->SoftwareFpcr;
        SoftwareFpcr->StatusInvalid = 1;
        if (SoftwareFpcr->EnableInvalid != 0) {
            ExceptionRecord = ContextBlock->ExceptionRecord;
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
            IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
            IeeeValue->Value.Fp32Value.W[0] = ResultValue;
            return FALSE;
        }

        Fpcr->DisableInvalid = 1;
    }

    KiSetRegisterValue(ContextBlock->Fc + 32,
                       KiConvertSingleOperandToRegister(ResultValue),
                       ContextBlock->ExceptionFrame,
                       ContextBlock->TrapFrame);

    return TRUE;
}

BOOLEAN
KiNormalizeDouble (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN PFP_DOUBLE_OPERAND ResultOperand,
    IN ULONGLONG StickyBits
    )

/*++

Routine Description:

    This function is called to normalize a double floating result.

    N.B. The result value is specified with a guard bit on the right,
        the hidden bit (if appropriate), and a possible overflow bit.
        The result format is:

        <63:56> - zero
        <55> - overflow bit
        <54> - hidden bit
        <53:2> - mantissa
        <1> - guard bit
        <0> - round bit

        The sticky bits specify bits that were lost during the computation.

Arguments:

    ContextBlock - Supplies a pointer to the emulation context block.

    ResultOperand - Supplies a pointer to the result operand value.

    StickyBits - Supplies the value of the sticky bits.

Return Value:

    If there is not an exception, or the exception is handled, then a proper
    result is stored in the destination result, the continuation address is
    set, and a value of TRUE is returned. Otherwise, a proper value is stored and
    a value of FALSE is returned.

--*/

{

    ULONGLONG DenormalizeShift;
    PEXCEPTION_RECORD ExceptionRecord;
    ULONGLONG ExceptionResult;
    PFPCR Fpcr;
    PFP_IEEE_VALUE IeeeValue;
    BOOLEAN Inexact;
    ULONGLONG Mantissa;
    BOOLEAN Overflow;
    ULONGLONG ResultValue;
    ULONG RoundBit;
    PSW_FPCR SoftwareFpcr;
    BOOLEAN Underflow;
    ULONGLONG ResultStickyBits;
    ULONGLONG ResultMantissa;
    ULONG ResultRoundBit;
    LONG ResultExponent;
    BOOLEAN ReturnValue = TRUE;

    //
    // If the result is infinite, then store a properly signed infinity
    // in the destination register and return a value of TRUE. Otherwise,
    // round and normalize the result and check for overflow and underflow.
    //

    DBGPRINT("KiNormalizeDouble: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x%.8x\n",
             ResultOperand->Infinity, ResultOperand->Nan, ResultOperand->Sign,
             ResultOperand->Exponent,
             ResultOperand->MantissaHigh, ResultOperand->MantissaLow);
    DBGPRINT("KiNormalizeDouble: StickyBits=%.16Lx\n", StickyBits);

    if (ResultOperand->Infinity != FALSE) {
        KiSetRegisterValue(ContextBlock->Fc + 32,
                           MAKE_QUAD(DOUBLE_INFINITY_VALUE_LOW,
                                     DOUBLE_INFINITY_VALUE_HIGH |
                                         (ResultOperand->Sign << 31)),
                           ContextBlock->ExceptionFrame,
                           ContextBlock->TrapFrame);

        return TRUE;
    }

    Mantissa = MAKE_QUAD(ResultOperand->MantissaLow,
                         ResultOperand->MantissaHigh);
    Fpcr = (PFPCR)&ContextBlock->TrapFrame->Fpcr;
    SoftwareFpcr = ContextBlock->SoftwareFpcr;

    //
    // If the overflow bit is set, then right shift the mantissa one bit,
    // accumulate the lost bit with the sticky bits, and adjust the exponent
    // value.
    //

    if ((Mantissa & ((ULONGLONG)1 << 55)) != 0) {
        StickyBits |= (Mantissa & 0x1);
        Mantissa >>= 1;
        ResultOperand->Exponent += 1;
    }

    //
    // If the mantissa is nonzero, then normalize the mantissa by left
    // shifting one bit at a time until there is a one bit in bit 54.
    //

    if (Mantissa != 0) {
        while ((Mantissa & ((ULONGLONG)1 << 54)) == 0) {
            Mantissa <<= 1;
            ResultOperand->Exponent -= 1;
        }
    }

    //
    // Right shift the mantissa two bits, set the round bit, and accumulate
    // the other lost bit with the sticky bits.
    //

    StickyBits |= (Mantissa & 0x1);
    RoundBit = (ULONG)(Mantissa & 0x2);
    Mantissa >>= 2;

    //
    // Convert to denormal format before rounding to allow underflow to
    // be detected on rounded result.  Save context to calculate IEEE
    // exception record, if needed.
    //

    if (ResultOperand->Exponent <= DOUBLE_MINIMUM_EXPONENT && Mantissa != 0) {

        //
        // Save everything needed for calculating IEEE exception record value
        //

        ResultMantissa = Mantissa;
        ResultExponent = ResultOperand->Exponent;
        ResultStickyBits = StickyBits;
        ResultRoundBit = RoundBit;

        //
        // Right shift the mantissa to set the minimum exponent plus an extra
        // bit for the denormal format
        //

        DenormalizeShift = 1 - ResultOperand->Exponent;

        //
        // The maximum denormal shift is 52 bits for the mantissa plus 1 bit for the round
        // A denormal shift of 54 guarantees 0 mantissa and 0 round bit and preserves all sticky bits
        //

        if (DenormalizeShift > 54) {
            DenormalizeShift = 54;
        }

        //
        // The denormalized result will be rounded after it is
        // shifted.  Preserve existing Round and Sticky Bits.
        //

        StickyBits |= RoundBit; 
        StickyBits |= (Mantissa << 1) << (64 - DenormalizeShift); 
        RoundBit = (ULONG)(Mantissa >> (DenormalizeShift - 1)) & 1;
        Mantissa = Mantissa >> DenormalizeShift;
        ResultOperand->Exponent = DOUBLE_MINIMUM_EXPONENT;
    }

    //
    // Round the result value using the mantissa, the round bit, and the sticky bits.
    //

    switch (ContextBlock->Round) {

        //
        // Round to nearest representable number.
        //

    case ROUND_TO_NEAREST:
        if (RoundBit != 0) {
            if ((StickyBits != 0) || ((Mantissa & 0x1) != 0)) {
                Mantissa += 1;
            }
        }
        break;

        //
        // Round toward zero.
        //

    case ROUND_TO_ZERO:
        break;

        //
        // Round toward plus infinity.
        //

    case ROUND_TO_PLUS_INFINITY:
        if ((ResultOperand->Sign == 0) &&
            ((StickyBits != 0) || (RoundBit != 0))) {
            Mantissa += 1;
        }
        break;

        //
        // Round toward minus infinity.
        //

    case ROUND_TO_MINUS_INFINITY:
        if ((ResultOperand->Sign != 0) &&
            ((StickyBits != 0) || (RoundBit != 0))) {
            Mantissa += 1;
        }
        break;
    }

    //
    // If rounding resulted in a carry into bit 53, then right shift the
    // mantissa one bit and adjust the exponent.
    //

    if ((Mantissa & ((ULONGLONG)1 << 53)) != 0) {
        Mantissa >>= 1;
        ResultOperand->Exponent += 1;
    }

    //
    // If rounding resulted in a carry into bit 52 in denormal format, then
    // adjust the exponent.
    //

    if ((ResultOperand->Exponent == DOUBLE_MINIMUM_EXPONENT) && 
        (Mantissa & ((ULONGLONG)1 << 52)) != 0) {
        ResultOperand->Exponent += 1;
    }

    //
    // If the exponent value is greater than or equal to the maximum
    // exponent value, then overflow has occurred. This results in both
    // the inexact and overflow sticky bits being set in the FPCR.
    //
    // If the exponent value is less than or equal to the minimum exponent
    // value, the mantissa is nonzero, and the denormalized result is inexact,
    // then underflow has occurred.  This results in both the inexact and
    // underflow sticky bits being set in the FPCR. 
    //
    // Or if underflow exceptions are enabled, underflow occurs for all denormal
    // numbers.  This results in the underflow sticky bit always being set in the
    // FPCR and the inexact sticky bit is set when the denormalized result is
    // also inexact.
    //
    // Otherwise, a normal result can be delivered, but it may be inexact.
    // If the result is inexact, then the inexact sticky bit is set in the
    // FPCR.
    //

    if (ResultOperand->Exponent >= DOUBLE_MAXIMUM_EXPONENT) {
        Inexact = TRUE;
        Overflow = TRUE;
        Underflow = FALSE;

        //
        // The overflow value is dependent on the rounding mode.
        //

        switch (ContextBlock->Round) {

            //
            // Round to nearest representable number.
            //
            // The result value is infinity with the sign of the result.
            //

        case ROUND_TO_NEAREST:
            ResultValue = MAKE_QUAD(DOUBLE_INFINITY_VALUE_LOW,
                                    DOUBLE_INFINITY_VALUE_HIGH |
                                        (ResultOperand->Sign << 31));
            break;

            //
            // Round toward zero.
            //
            // The result is the maximum number with the sign of the result.
            //

        case ROUND_TO_ZERO:
            ResultValue = MAKE_QUAD(DOUBLE_MAXIMUM_VALUE_LOW,
                                    DOUBLE_MAXIMUM_VALUE_HIGH |
                                        (ResultOperand->Sign << 31));
            break;

            //
            // Round toward plus infinity.
            //
            // If the sign of the result is positive, then the result is
            // plus infinity. Otherwise, the result is the maximum negative
            // number.
            //

        case ROUND_TO_PLUS_INFINITY:
            if (ResultOperand->Sign == 0) {
                ResultValue = MAKE_QUAD(DOUBLE_INFINITY_VALUE_LOW,
                                        DOUBLE_INFINITY_VALUE_HIGH);

            } else {
                ResultValue = MAKE_QUAD(DOUBLE_MAXIMUM_VALUE_LOW,
                                        DOUBLE_MAXIMUM_VALUE_HIGH |
                                            (1 << 31));
            }
            break;

            //
            // Round toward minus infinity.
            //
            // If the sign of the result is negative, then the result is
            // negative infinity. Otherwise, the result is the maximum
            // positive number.
            //


        case ROUND_TO_MINUS_INFINITY:
            if (ResultOperand->Sign != 0) {
                ResultValue = MAKE_QUAD(DOUBLE_INFINITY_VALUE_LOW,
                                        DOUBLE_INFINITY_VALUE_HIGH |
                                            (1 << 31));

            } else {
                ResultValue = MAKE_QUAD(DOUBLE_MAXIMUM_VALUE_LOW,
                                        DOUBLE_MAXIMUM_VALUE_HIGH);
            }
            break;
        }

        //
        // Compute the overflow exception result value by subtracting 1536
        // from the exponent.
        //

        ExceptionResult = Mantissa & (((ULONGLONG)1 << 52) - 1);
        ExceptionResult |= (((ULONGLONG)ResultOperand->Exponent - 1536) << 52);
        ExceptionResult |= ((ULONGLONG)ResultOperand->Sign << 63);

    } else {

        //
        // After rounding if the exponent value is equal to
        // the minimum exponent value and the result was nonzero, then
        // underflow has occurred.
        //

        if ((ResultOperand->Exponent == DOUBLE_MINIMUM_EXPONENT) &&
            (Mantissa != 0 || RoundBit != 00 || StickyBits != 0)) {

            //
            // If the FPCR underflow to zero (denormal enable) control bit
            // is set, then flush the denormalized result to zero and do
            // not set an underflow status or generate an exception.
            //

            if ((ContextBlock->IeeeMode == FALSE) ||
                (SoftwareFpcr->DenormalResultEnable == 0)) {
                DBGPRINT("SoftwareFpcr->DenormalResultEnable == 0\n");
                ResultValue = 0;
                Inexact = FALSE;
                Overflow = FALSE;
                Underflow = FALSE;

            } else {

                ResultValue = Mantissa;
                ResultValue |= (ULONGLONG)ResultOperand->Sign << 63;

                //
                //
                // Compute the underflow exception result value by recalculating the
                // full precision answer and adding 1536 to the exponent.
                //

                //
                // Round the result value using the mantissa, the round bit, and the sticky bits.
                //

                switch (ContextBlock->Round) {

                    //
                    // Round to nearest representable number.
                    //

                case ROUND_TO_NEAREST:
                    if (ResultRoundBit != 0) {
                        if ((ResultStickyBits != 0) || ((ResultMantissa & 0x1) != 0)) {
                            ResultMantissa += 1;
                        }
                    }
                    break;

                    //
                    // Round toward zero.
                    //

                case ROUND_TO_ZERO:
                    break;

                    //
                    // Round toward plus infinity.
                    //

                case ROUND_TO_PLUS_INFINITY:
                    if ((ResultOperand->Sign == 0) &&
                        ((ResultStickyBits != 0) || (ResultRoundBit != 0))) {
                        ResultMantissa += 1;
                    }
                    break;

                    //
                    // Round toward minus infinity.
                    //

                case ROUND_TO_MINUS_INFINITY:
                    if ((ResultOperand->Sign != 0) &&
                        ((ResultStickyBits != 0) || (ResultRoundBit != 0))) {
                        ResultMantissa += 1;
                    }
                    break;
                }

                //
                // If rounding resulted in a carry into bit 53, then right shift the
                // mantissa one bit and adjust the exponent.
                //

                if ((ResultMantissa & ((ULONGLONG)1 << 53)) != 0) {
                    ResultMantissa >>= 1;
                    ResultExponent += 1;
                }

                // Compute the underflow exception result value by adding
                // 1536 to the exponent.
                //

                ExceptionResult = ResultMantissa & (((ULONGLONG)1 << 52) - 1);
                ExceptionResult |= (((ULONGLONG)ResultExponent + 1536) << 52);
                ExceptionResult |= ((ULONGLONG)ResultOperand->Sign << 63);

                //
                // If the denormalized result is inexact, then set underflow.
                // Otherwise, for exact denormals do not set the underflow
                // sticky bit unless underflow exception is enabled.
                //

                Overflow = FALSE;
                Underflow = TRUE;
                if ((StickyBits != 0) || (RoundBit != 0)) {
                    Inexact = TRUE;

                } else {
                    Inexact = FALSE;
                }
            }

        } else {

            //
            // If the result is zero, then set the proper sign for zero.
            //

            if (Mantissa == 0) {
                ResultOperand->Exponent = 0;
            }

            ResultValue = Mantissa & (((ULONGLONG)1 << 52) - 1);
            ResultValue |= (ULONGLONG)ResultOperand->Exponent << 52;
            ResultValue |= (ULONGLONG)ResultOperand->Sign << 63;
            if ((StickyBits != 0) || (RoundBit != 0)) {
                Inexact = TRUE;

            } else {
                Inexact = FALSE;
            }
            Overflow = FALSE;
            Underflow = FALSE;
        }
    }

    //
    // Check to determine if an exception should be delivered.
    //

    ExceptionRecord = ContextBlock->ExceptionRecord;

    if (Overflow != FALSE) {
        Fpcr->Overflow = 1;
        Fpcr->InexactResult = 1;
        Fpcr->SummaryBit = 1;
        if (ContextBlock->IeeeMode == FALSE) {
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_OVERFLOW;
            return FALSE;
        }
        IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
        SoftwareFpcr->StatusOverflow = 1;
        SoftwareFpcr->StatusInexact = 1;
        if (SoftwareFpcr->EnableOverflow != 0) {
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_OVERFLOW;
            IeeeValue->Value.Fp64Value.W[0] = LOW_PART(ExceptionResult);
            IeeeValue->Value.Fp64Value.W[1] = HIGH_PART(ExceptionResult);
            ReturnValue = FALSE;
        } else if (SoftwareFpcr->EnableInexact != 0) {
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
            IeeeValue->Value.Fp64Value.W[0] = LOW_PART(ExceptionResult);
            IeeeValue->Value.Fp64Value.W[1] = HIGH_PART(ExceptionResult);
            ReturnValue = FALSE;
        } else {
            Fpcr->DisableOverflow = 1;
            Fpcr->DisableInexact = 1;
        }

    } else if (Underflow != FALSE) {

        //
        // Non-IEEE instruction always forces underflow to zero
        //

        if (ContextBlock->IeeeMode == FALSE) {
            Fpcr->Underflow = 1;
            Fpcr->SummaryBit = 1;
            Fpcr->InexactResult = 1;
            if (ContextBlock->UnderflowEnable != FALSE) {
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_UNDERFLOW;
                return FALSE;
            }

        //
        // IEEE instructions don't report underflow unless the results are
        // inexact or underflow exceptions are enabled
        //

        } else {
            IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
            if (Inexact != FALSE) {
                Fpcr->Underflow = 1;
                Fpcr->SummaryBit = 1;
                Fpcr->InexactResult = 1;
                SoftwareFpcr->StatusUnderflow = 1;
                SoftwareFpcr->StatusInexact = 1;
            } 
            if (SoftwareFpcr->EnableUnderflow != 0) {
                Fpcr->Underflow = 1;
                Fpcr->SummaryBit = 1;
                SoftwareFpcr->StatusUnderflow = 1;
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_UNDERFLOW;
                IeeeValue->Value.Fp64Value.W[0] = LOW_PART(ExceptionResult);
                IeeeValue->Value.Fp64Value.W[1] = HIGH_PART(ExceptionResult);
                ReturnValue = FALSE;
            } else if (Inexact != FALSE && SoftwareFpcr->EnableInexact != 0) {
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
                IeeeValue->Value.Fp64Value.W[0] = LOW_PART(ExceptionResult);
                IeeeValue->Value.Fp64Value.W[1] = HIGH_PART(ExceptionResult);
                ReturnValue = FALSE;
            } else if (Inexact != FALSE) {
                Fpcr->DisableUnderflow = 1;
                Fpcr->DisableInexact = 1;
            }
        }

    } else if (Inexact != FALSE) {
        Fpcr->InexactResult = 1;
        Fpcr->SummaryBit = 1;
        if (ContextBlock->IeeeMode != FALSE) {
            IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
            SoftwareFpcr->StatusInexact = 1;
            if (SoftwareFpcr->EnableInexact != 0) {
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
                IeeeValue->Value.Fp64Value.W[0] = LOW_PART(ResultValue);
                IeeeValue->Value.Fp64Value.W[1] = HIGH_PART(ResultValue);
                ReturnValue = FALSE;
            } else {
                Fpcr->DisableInexact = 1;
            }
        }
    }

    //
    // Always write the destination register.  If an exception is delivered, and
    // then dismissed, the correct value must be in the register.
    //

    KiSetRegisterValue(ContextBlock->Fc + 32,
                       ResultValue,
                       ContextBlock->ExceptionFrame,
                       ContextBlock->TrapFrame);

    //
    // Return a value of TRUE.unless an exception should be generated
    //

    return ReturnValue;
}

BOOLEAN
KiNormalizeQuadword (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN PFP_DOUBLE_OPERAND ResultOperand
    )

/*++

Routine Description:

    This function is called to convert a result value to a quadword result.

    N.B. The result value is specified with a guard bit on the right,
        the hidden bit (if appropriate), and an overflow bit of zero.
        As called above, the guard bit and the round bit are also zero.
        The result format is:

        <63:55> - zero
        <54 - hidden bit
        <53:2> - mantissa
        <1> - guard bit
        <0> - round bit

        There are no sticky bits.

Arguments:

    ContextBlock - Supplies a pointer to the emulation context block.

    ResultOperand - Supplies a pointer to the result operand value.

Return Value:

    If there is not an exception, or the exception is handled, then a proper
    result is stored in the destination result, the continuation address is
    set, and a value of TRUE is returned. Otherwise, no value is stored and
    a value of FALSE is returned.

--*/

{

    PEXCEPTION_RECORD ExceptionRecord;
    LONGLONG ExponentShift;
    PFPCR Fpcr;
    PFP_IEEE_VALUE IeeeValue;
    ULONGLONG Mantissa;
    BOOLEAN Overflow;
    ULONGLONG ResultValue;
    ULONG RoundBit;
    ULONGLONG StickyBits;
    PSW_FPCR SoftwareFpcr;

    //
    // Subtract out the exponent bias and divide the cases into right
    // and left shifts.
    //

    ExponentShift = ResultOperand->Exponent - DOUBLE_EXPONENT_BIAS;
    DBGPRINT("KiNormalizeQuadword: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x%.8x\n",
             ResultOperand->Infinity, ResultOperand->Nan, ResultOperand->Sign,
             ResultOperand->Exponent,
             ResultOperand->MantissaHigh, ResultOperand->MantissaLow);
    DBGPRINT(".. ExponentShift = %d\n", ExponentShift);
    Mantissa = MAKE_QUAD(ResultOperand->MantissaLow,
                         ResultOperand->MantissaHigh);

    if (ExponentShift < 54) {

        //
        // The integer result value is less than 2**54 and so a right shift
        // must be performed.
        //

        ExponentShift = 54 - ExponentShift;
        if (ExponentShift < 64) {
            StickyBits = Mantissa << (64 - ExponentShift);
            ResultValue = Mantissa >> ExponentShift;

        } else {
            StickyBits = Mantissa;
            ResultValue = 0;
        }
        Overflow = FALSE;

    } else if (ExponentShift > 54) {
        ExponentShift -= 54;

        //
        // The integer result value is 2**54 or greater and so a left shift
        // must be performed. If the unsigned integer result value is 2**64
        // or greater, then overflow has occurred and store the low order 64
        // bits of the true result.
        //

        if (ExponentShift < (64 - 54)) {
            StickyBits = Mantissa >> (64 - ExponentShift);
            ResultValue = Mantissa << ExponentShift;
            Overflow = FALSE;

        } else {
            StickyBits = 0;
            if (ExponentShift < 64) {
                ResultValue = Mantissa << ExponentShift;

            } else {
                ResultValue = 0;
            }
            Overflow = TRUE;
        }

    } else {
        StickyBits = 0;
        ResultValue = Mantissa;
        Overflow = FALSE;
    }
    DBGPRINT(".. ResultValue = %.16Lx, StickyBits = %.16Lx\n",
             ResultValue, StickyBits);

    //
    // Round the result value using the mantissa, the round bit, and the
    // sticky bits.
    //

    RoundBit = (ULONG)(StickyBits >> 63);
    StickyBits <<= 1;
    DBGPRINT(".. ResultValue = %.16Lx, StickyBits = %.16Lx, RoundBit = %lx\n",
             ResultValue, StickyBits, RoundBit);
    switch (ContextBlock->Round) {

        //
        // Round to nearest representable number.
        //

    case ROUND_TO_NEAREST:
        if (RoundBit != 0) {
            if ((StickyBits != 0) || ((ResultValue & 0x1) != 0)) {
                ResultValue += 1;
                if (ResultValue == 0) {
                    Overflow = TRUE;
                }
            }
        }
        break;

        //
        // Round toward zero.
        //

    case ROUND_TO_ZERO:
        break;

        //
        // Round toward plus infinity.
        //

    case ROUND_TO_PLUS_INFINITY:
        if ((ResultOperand->Sign == 0) &&
            ((StickyBits != 0) || (RoundBit != 0))) {
            ResultValue += 1;
            if (ResultValue == 0) {
                Overflow = TRUE;
            }
        }
        break;

        //
        // Round toward minus infinity.
        //

    case ROUND_TO_MINUS_INFINITY:
        if ((ResultOperand->Sign != 0) &&
            ((StickyBits != 0) || (RoundBit != 0))) {
            ResultValue += 1;
            if (ResultValue == 0) {
                Overflow = TRUE;
            }
        }
        break;
    }

    //
    // If the result value is positive and the result is negative, then
    // overflow has occurred. Otherwise, negate the result value and
    // check if the result is negative. If the result is positive, then
    // overflow has occurred.
    //

    if (ResultOperand->Sign == 0) {
        if ((LONGLONG)ResultValue < 0) {
            Overflow = TRUE;
        }

    } else {
        ResultValue = -(LONGLONG)ResultValue;
        if ((LONGLONG)ResultValue > 0) {
            Overflow = TRUE;
        }
    }
    DBGPRINT(".. ResultValue = %.16Lx, StickyBits = %.16Lx\n",
             ResultValue, StickyBits);

    //
    // Check to determine if an exception should be delivered or the result
    // should be written to the destination register.
    //

    if (Overflow != FALSE) {
        return KiInvalidOperationQuadword(ContextBlock, ResultValue);

    } else if ((StickyBits | RoundBit) != 0) {
        Fpcr = (PFPCR)&ContextBlock->TrapFrame->Fpcr;
        Fpcr->InexactResult = 1;
        Fpcr->SummaryBit = 1;
        if (ContextBlock->IeeeMode != FALSE) {
            SoftwareFpcr = ContextBlock->SoftwareFpcr;
            SoftwareFpcr->StatusInexact = 1;
            if (SoftwareFpcr->EnableInexact != 0) {
                ExceptionRecord = ContextBlock->ExceptionRecord;
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
                IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
                IeeeValue->Value.U64Value.LowPart = LOW_PART(ResultValue);
                IeeeValue->Value.U64Value.HighPart = HIGH_PART(ResultValue);
                return FALSE;
            }

            Fpcr->DisableInexact = 1;
        }
    }

    //
    // Set the destination register value and return a value of TRUE.
    //

    KiSetRegisterValue(ContextBlock->Fc + 32,
                       ResultValue,
                       ContextBlock->ExceptionFrame,
                       ContextBlock->TrapFrame);

    return TRUE;
}

BOOLEAN
KiNormalizeSingle (
    IN PFP_CONTEXT_BLOCK ContextBlock,
    IN PFP_SINGLE_OPERAND ResultOperand,
    IN ULONG StickyBits
    )

/*++

Routine Description:

    This function is called to normalize a single floating result.

    N.B. The result value is specified with a guard bit on the right,
        the hidden bit (if appropriate), and a possible overflow bit.
        The result format is:

        <31:27> - zero
        <26> - overflow bit
        <25> - hidden bit
        <24:2> - mantissa
        <1> - guard bit
        <0> - round bit

        The sticky bits specify bits that were lost during the computation.

Arguments:

    ContextBlock - Supplies a pointer to the emulation context block.

    ResultOperand - Supplies a pointer to the result operand value.

    StickyBits - Supplies the value of the sticky bits.

Return Value:

    If there is not an exception, or the exception is handled, then a proper
    result is stored in the destination result, the continuation address is
    set, and a value of TRUE is returned. Otherwise, a proper value is stored and
    a value of FALSE is returned.

--*/

{

    ULONG DenormalizeShift;
    PEXCEPTION_RECORD ExceptionRecord;
    ULONG ExceptionResult;
    PFPCR Fpcr;
    PFP_IEEE_VALUE IeeeValue;
    BOOLEAN Inexact;
    ULONG Mantissa;
    BOOLEAN Overflow;
    ULONG ResultValue;
    ULONG RoundBit;
    PSW_FPCR SoftwareFpcr;
    BOOLEAN Underflow;
    ULONG ResultStickyBits;
    ULONG ResultMantissa;
    ULONG ResultRoundBit;
    LONG ResultExponent;
    BOOLEAN ReturnValue = TRUE;

    //
    // If the result is infinite, then store a properly signed infinity
    // in the destination register and return a value of TRUE. Otherwise,
    // round and normalize the result and check for overflow and underflow.
    //

    DBGPRINT("KiNormalizeSingle: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x\n",
             ResultOperand->Infinity, ResultOperand->Nan, ResultOperand->Sign,
             ResultOperand->Exponent, ResultOperand->Mantissa);
    DBGPRINT("KiNormalizeSingle: StickyBits=%.8lx\n", StickyBits);

    if (ResultOperand->Infinity != FALSE) {
        ResultValue = SINGLE_INFINITY_VALUE | (ResultOperand->Sign << 31);
        KiSetRegisterValue(ContextBlock->Fc + 32,
                           KiConvertSingleOperandToRegister(ResultValue),
                           ContextBlock->ExceptionFrame,
                           ContextBlock->TrapFrame);

        return TRUE;
    }

    Mantissa = ResultOperand->Mantissa;
    Fpcr = (PFPCR)&ContextBlock->TrapFrame->Fpcr;
    SoftwareFpcr = ContextBlock->SoftwareFpcr;

    //
    // If the overflow bit is set, then right shift the mantissa one bit,
    // accumulate the lost bit with the sticky bits, and adjust the exponent
    // value.
    //

    if ((Mantissa & (1 << 26)) != 0) {
        StickyBits |= (Mantissa & 0x1);
        Mantissa >>= 1;
        ResultOperand->Exponent += 1;
    }

    //
    // If the mantissa is nonzero, then normalize the mantissa by left
    // shifting one bit at a time until there is a one bit in bit 25.
    //

    if (Mantissa != 0) {
        while ((Mantissa & (1 << 25)) == 0) {
            Mantissa <<= 1;
            ResultOperand->Exponent -= 1;
        }
    }

    //
    // Right shift the mantissa two bits, set the round bit, and accumulate
    // the other lost bit with the sticky bits.
    //

    StickyBits |= (Mantissa & 0x1);
    RoundBit = (Mantissa & 0x2);
    Mantissa >>= 2;

    //
    // Convert to denormal format before rounding to allow underflow to
    // be detected on rounded result.  Save context to calculate IEEE
    // exception record, if needed.
    //

    if (ResultOperand->Exponent <= SINGLE_MINIMUM_EXPONENT && Mantissa != 0) {

        //
        // Save everything needed for calculating IEEE exception record value
        //

        ResultMantissa = Mantissa;
        ResultExponent = ResultOperand->Exponent;
        ResultStickyBits = StickyBits;
        ResultRoundBit = RoundBit;

        //
        // Right shift the mantissa to set the minimum exponent plus an extra
        // bit for the denormal format
        //

        DenormalizeShift = 1 - ResultOperand->Exponent;

        //
        // The maximum denormal shift is 23 bits for the mantissa plus 1 bit for the round
        // A denormal shift of 25 guarantees 0 mantissa and 0 round bit and preserves all sticky bits
        //

        if (DenormalizeShift > 25) {
            DenormalizeShift = 25;
        }

        //
        // The denormalized result will be rounded after it is
        // shifted.  Preserve existing Round and Sticky Bits.
        //

        StickyBits |= RoundBit; 
        StickyBits |= (Mantissa << 1) << (32 - DenormalizeShift); 
        RoundBit = (Mantissa >> (DenormalizeShift - 1)) & 1;
        Mantissa = Mantissa >> DenormalizeShift;
        ResultOperand->Exponent = SINGLE_MINIMUM_EXPONENT;
    }

    //
    // Round the result value using the mantissa, the round bit, and the sticky bits.
    //

    switch (ContextBlock->Round) {

        //
        // Round to nearest representable number.
        //

    case ROUND_TO_NEAREST:
        if (RoundBit != 0) {
            if ((StickyBits != 0) || ((Mantissa & 0x1) != 0)) {
                Mantissa += 1;
            }
        }
        break;

        //
        // Round toward zero.
        //

    case ROUND_TO_ZERO:
        break;

        //
        // Round toward plus infinity.
        //

    case ROUND_TO_PLUS_INFINITY:
        if ((ResultOperand->Sign == 0) &&
            ((StickyBits != 0) || (RoundBit != 0))) {
            Mantissa += 1;
        }
        break;

        //
        // Round toward minus infinity.
        //

    case ROUND_TO_MINUS_INFINITY:
        if ((ResultOperand->Sign != 0) &&
            ((StickyBits != 0) || (RoundBit != 0))) {
            Mantissa += 1;
        }
        break;
    }

    //
    // If rounding resulted in a carry into bit 24, then right shift the
    // mantissa one bit and adjust the exponent.
    //

    if ((Mantissa & (1 << 24)) != 0) {
        Mantissa >>= 1;
        ResultOperand->Exponent += 1;
    }

    //
    // If rounding resulted in a carry into bit 23 in denormal format, then
    // adjust the exponent.
    //

    if ((ResultOperand->Exponent == SINGLE_MINIMUM_EXPONENT) && 
        (Mantissa & (1 << 23)) != 0) {
        ResultOperand->Exponent += 1;
    }

    //
    // If the exponent value is greater than or equal to the maximum
    // exponent value, then overflow has occurred. This results in both
    // the inexact and overflow sticky bits being set in the FPCR.
    //
    // If the exponent value is less than or equal to the minimum exponent
    // value, the mantissa is nonzero, and the denormalized result is inexact,
    // then underflow has occurred.  This results in both the inexact and
    // underflow sticky bits being set in the FPCR. 
    //
    // Or if underflow exceptions are enabled, underflow occurs for all denormal
    // numbers.  This results in the underflow sticky bit always being set in the
    // FPCR and the inexact sticky bit is set when the denormalized result is
    // also inexact.
    //
    // Otherwise, a normal result can be delivered, but it may be inexact.
    // If the result is inexact, then the inexact sticky bit is set in the
    // FPCR.
    //

    if (ResultOperand->Exponent >= SINGLE_MAXIMUM_EXPONENT) {
        Inexact = TRUE;
        Overflow = TRUE;
        Underflow = FALSE;

        //
        // The overflow value is dependent on the rounding mode.
        //

        switch (ContextBlock->Round) {

            //
            // Round to nearest representable number.
            //
            // The result value is infinity with the sign of the result.
            //

        case ROUND_TO_NEAREST:
            ResultValue = SINGLE_INFINITY_VALUE | (ResultOperand->Sign << 31);
            break;

            //
            // Round toward zero.
            //
            // The result is the maximum number with the sign of the result.
            //

        case ROUND_TO_ZERO:
            ResultValue = SINGLE_MAXIMUM_VALUE | (ResultOperand->Sign << 31);
            break;

            //
            // Round toward plus infinity.
            //
            // If the sign of the result is positive, then the result is
            // plus infinity. Otherwise, the result is the maximum negative
            // number.
            //

        case ROUND_TO_PLUS_INFINITY:
            if (ResultOperand->Sign == 0) {
                ResultValue = SINGLE_INFINITY_VALUE;

            } else {
                ResultValue = (ULONG)(SINGLE_MAXIMUM_VALUE | (1 << 31));
            }
            break;

            //
            // Round toward minus infinity.
            //
            // If the sign of the result is negative, then the result is
            // negative infinity. Otherwise, the result is the maximum
            // positive number.
            //

        case ROUND_TO_MINUS_INFINITY:
            if (ResultOperand->Sign != 0) {
                ResultValue = (ULONG)(SINGLE_INFINITY_VALUE | (1 << 31));

            } else {
                ResultValue = SINGLE_MAXIMUM_VALUE;
            }
            break;
        }

        //
        // Compute the overflow exception result value by subtracting 192
        // from the exponent.
        //

        ExceptionResult = Mantissa & ((1 << 23) - 1);
        ExceptionResult |= ((ResultOperand->Exponent - 192) << 23);
        ExceptionResult |= (ResultOperand->Sign << 31);

    } else {

        //
        // After rounding if the exponent value is equal to
        // the minimum exponent value and the result was nonzero, then
        // underflow has occurred.
        //

        if ((ResultOperand->Exponent == SINGLE_MINIMUM_EXPONENT) &&
            (Mantissa != 0 || RoundBit != 00 || StickyBits != 0)) {

            //
            // If the FPCR underflow to zero (denormal enable) control bit
            // is set, then flush the denormalized result to zero and do
            // not set an underflow status or generate an exception.
            //

            if ((ContextBlock->IeeeMode == FALSE) ||
                (SoftwareFpcr->DenormalResultEnable == 0)) {
                DBGPRINT("SoftwareFpcr->DenormalResultEnable == 0\n");
                ResultValue = 0;
                Inexact = FALSE;
                Overflow = FALSE;
                Underflow = FALSE;

            } else {

                ResultValue = Mantissa;
                ResultValue |= ResultOperand->Sign << 31;

                //
                //
                // Compute the underflow exception result value by first recalculating the
                // full precision answer.
                //

                //
                // Round the result value using the mantissa, the round bit, and the sticky bits.
                //

                switch (ContextBlock->Round) {

                    //
                    // Round to nearest representable number.
                    //

                case ROUND_TO_NEAREST:
                    if (ResultRoundBit != 0) {
                        if ((ResultStickyBits != 0) || ((ResultMantissa & 0x1) != 0)) {
                            ResultMantissa += 1;
                        }
                    }
                    break;

                    //
                    // Round toward zero.
                    //

                case ROUND_TO_ZERO:
                    break;

                    //
                    // Round toward plus infinity.
                    //

                case ROUND_TO_PLUS_INFINITY:
                    if ((ResultOperand->Sign == 0) &&
                        ((ResultStickyBits != 0) || (ResultRoundBit != 0))) {
                        ResultMantissa += 1;
                    }
                    break;

                    //
                    // Round toward minus infinity.
                    //

                case ROUND_TO_MINUS_INFINITY:
                    if ((ResultOperand->Sign != 0) &&
                        ((ResultStickyBits != 0) || (ResultRoundBit != 0))) {
                        ResultMantissa += 1;
                    }
                    break;
                }

                //
                // If rounding resulted in a carry into bit 24, then right shift the
                // mantissa one bit and adjust the exponent.
                //

                if ((ResultMantissa & (1 << 24)) != 0) {
                    ResultMantissa >>= 1;
                    ResultExponent += 1;
                }

                //
                // Compute the underflow exception result value by adding
                // 192 to the exponent.
                //

                ExceptionResult = ResultMantissa & ((1 << 23) - 1);
                ExceptionResult |= ((ResultExponent + 192) << 23);
                ExceptionResult |= (ResultOperand->Sign << 31);

                //
                // If the denormalized result is inexact, then set underflow.
                // Otherwise, for exact denormals do not set the underflow
                // sticky bit unless underflow exception is enabled.
                //

                Overflow = FALSE;
                Underflow = TRUE;
                if ((StickyBits != 0) || (RoundBit != 0)) {
                    Inexact = TRUE;

                } else {
                    Inexact = FALSE;
                }
            }

        } else {

            //
            // If the result is zero, then set the proper sign for zero.
            //

            if (Mantissa == 0) {
                ResultOperand->Exponent = 0;
            }

            ResultValue = Mantissa & ((1 << 23) - 1);
            ResultValue |= (ResultOperand->Exponent << 23);
            ResultValue |= (ResultOperand->Sign << 31);
            if ((StickyBits != 0) || (RoundBit != 0)) {
                Inexact = TRUE;

            } else {
                Inexact = FALSE;
            }
            Overflow = FALSE;
            Underflow = FALSE;
        }
    }

    //
    // Check to determine if an exception should be delivered.
    //

    ExceptionRecord = ContextBlock->ExceptionRecord;

    if (Overflow != FALSE) {
        Fpcr->Overflow = 1;
        Fpcr->InexactResult = 1;
        Fpcr->SummaryBit = 1;
        if (ContextBlock->IeeeMode == FALSE) {
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_OVERFLOW;
            return FALSE;
        }
        IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
        SoftwareFpcr->StatusOverflow = 1;
        SoftwareFpcr->StatusInexact = 1;
        if (SoftwareFpcr->EnableOverflow != 0) {
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_OVERFLOW;
            IeeeValue->Value.Fp32Value.W[0] = ExceptionResult;
            ReturnValue = FALSE;
        } else if (SoftwareFpcr->EnableInexact != 0) {
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
            IeeeValue->Value.Fp32Value.W[0] = ExceptionResult;
            ReturnValue = FALSE;
        } else {
            Fpcr->DisableOverflow = 1;
            Fpcr->DisableInexact = 1;
        }

    } else if (Underflow != FALSE) {

        //
        // Non-IEEE instruction always forces underflow to zero
        //

        if (ContextBlock->IeeeMode == FALSE) {
            Fpcr->Underflow = 1;
            Fpcr->SummaryBit = 1;
            Fpcr->InexactResult = 1;
            if (ContextBlock->UnderflowEnable != FALSE) {
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_UNDERFLOW;
                return FALSE;
            }

        //
        // IEEE instructions don't report underflow unless the results are
        // inexact or underflow exceptions are enabled
        //

        } else {
            IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
            if (Inexact != FALSE) {
                Fpcr->Underflow = 1;
                Fpcr->InexactResult = 1;
                Fpcr->SummaryBit = 1;
                SoftwareFpcr->StatusUnderflow = 1;
                SoftwareFpcr->StatusInexact = 1;
            }
            if (SoftwareFpcr->EnableUnderflow != 0) {
                Fpcr->Underflow = 1;
                Fpcr->SummaryBit = 1;
                SoftwareFpcr->StatusUnderflow = 1;
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_UNDERFLOW;
                IeeeValue->Value.Fp32Value.W[0] = ExceptionResult;
                ReturnValue = FALSE;
            } else if (Inexact != FALSE && SoftwareFpcr->EnableInexact != 0) {
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
                IeeeValue->Value.Fp32Value.W[0] = ExceptionResult;
                ReturnValue = FALSE;
            } else if (Inexact != FALSE) {
                Fpcr->DisableUnderflow = 1;
                Fpcr->DisableInexact = 1;
            }
        }

    } else if (Inexact != FALSE) {
        Fpcr->InexactResult = 1;
        Fpcr->SummaryBit = 1;
        if (ContextBlock->IeeeMode != FALSE) {
            IeeeValue = KiInitializeIeeeValue(ExceptionRecord);
            SoftwareFpcr->StatusInexact = 1;
            if (SoftwareFpcr->EnableInexact != 0) {
                ExceptionRecord->ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
                IeeeValue->Value.Fp32Value.W[0] = ResultValue;
                ReturnValue = FALSE;
            } else {
                Fpcr->DisableInexact = 1;
            }
        }
    }

    //
    // Always write the destination register.  If an exception is delivered, and
    // then dismissed, the correct value must be in the register.
    //

    KiSetRegisterValue(ContextBlock->Fc + 32,
                       KiConvertSingleOperandToRegister(ResultValue),
                       ContextBlock->ExceptionFrame,
                       ContextBlock->TrapFrame);

    //
    // Return a value of TRUE.unless an exception should be generated
    //

    return ReturnValue;
}

VOID
KiUnpackDouble (
    IN ULONG Source,
    IN PFP_CONTEXT_BLOCK ContextBlock,
    OUT PFP_DOUBLE_OPERAND DoubleOperand
    )

/*++

Routine Description:

    This function is called to unpack a double floating value from the
    specified source register.

    N.B. The unpacked mantissa value is returned with a guard bit and a
        round bit on the right and the hidden bit inserted if appropriate.
        The format of the returned value is:

        <63:55> - zero
        <54> - hidden bit
        <53:2> - mantissa
        <1> - guard bit
        <0> - round bit

Arguments:

    Source - Supplies the number of the register that contains the operand.

    ContextBlock - Supplies a pointer to the emulation context block.

    DoubleOperand - Supplies a pointer to a structure that is to receive the
        operand value.

Return Value:

    None.

--*/

{

    ULONGLONG Value;
    ULONG Value1;
    ULONG Value2;

    //
    // Get the source register value and unpack the sign, exponent, and
    // mantissa value.
    //

    Value = KiGetRegisterValue(Source + 32,
                               ContextBlock->ExceptionFrame,
                               ContextBlock->TrapFrame);
    Value1 = (ULONG)Value;
    Value2 = (ULONG)(Value >> 32);

    DoubleOperand->Sign = Value2 >> 31;
    DoubleOperand->Exponent = (Value2 >> (52 - 32)) & 0x7ff;
    DoubleOperand->MantissaHigh = Value2 & 0xfffff;
    DoubleOperand->MantissaLow = Value1;

    //
    // If the exponent is the largest possible value, then the number is
    // either a NaN or an infinity. Otherwise if the exponent is the smallest
    // possible value and the mantissa is nonzero, then the number is
    // denormalized. Otherwise the number is finite and normal.
    //

    if (DoubleOperand->Exponent == DOUBLE_MAXIMUM_EXPONENT) {
        DoubleOperand->Normal = FALSE;
        if ((DoubleOperand->MantissaLow | DoubleOperand->MantissaHigh) != 0) {
            DoubleOperand->Infinity = FALSE;
            DoubleOperand->Nan = TRUE;

        } else {
            DoubleOperand->Infinity = TRUE;
            DoubleOperand->Nan = FALSE;
        }

    } else {
        DoubleOperand->Infinity = FALSE;
        DoubleOperand->Nan = FALSE;
        DoubleOperand->Normal = TRUE;
        if (DoubleOperand->Exponent == DOUBLE_MINIMUM_EXPONENT) {
            if ((DoubleOperand->MantissaHigh | DoubleOperand->MantissaLow) != 0) {
                if (ContextBlock->SoftwareFpcr->DenormalOperandsEnable == 0) {
                    DBGPRINT("SoftwareFpcr->DenormalOperandsEnable == 0\n");
                    DoubleOperand->MantissaHigh = 0;
                    DoubleOperand->MantissaLow = 0;
                    DoubleOperand->Exponent = 0;
                } else {
                    DoubleOperand->Normal = FALSE;
                    DoubleOperand->Exponent += 1;
                    while ((DoubleOperand->MantissaHigh & (1 << 20)) == 0) {
                        DoubleOperand->MantissaHigh =
                                (DoubleOperand->MantissaHigh << 1) |
                                                (DoubleOperand->MantissaLow >> 31);
                        DoubleOperand->MantissaLow <<= 1;
                        DoubleOperand->Exponent -= 1;
                    }
                }
            }

        } else {
            DoubleOperand->MantissaHigh |= (1 << 20);
        }
    }

    //
    // Left shift the mantissa 2-bits to provide for a guard bit and a round
    // bit.
    //

    DoubleOperand->MantissaHigh =
        (DoubleOperand->MantissaHigh << 2) | (DoubleOperand->MantissaLow >> 30);
    DoubleOperand->MantissaLow <<= 2;
    DBGPRINT("KiUnpackDouble: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x%.8x\n",
             DoubleOperand->Infinity, DoubleOperand->Nan, DoubleOperand->Sign,
             DoubleOperand->Exponent,
             DoubleOperand->MantissaHigh, DoubleOperand->MantissaLow);

    return;
}

VOID
KiUnpackSingle (
    IN ULONG Source,
    IN PFP_CONTEXT_BLOCK ContextBlock,
    OUT PFP_SINGLE_OPERAND SingleOperand
    )

/*++

Routine Description:

    This function is called to unpack a single floating value from the
    specified source register.

    N.B. The unpacked mantissa value is returned with a guard bit and a
        round bit on the right and the hidden bit inserted if appropriate.
        The format of the returned value is:

        <31:26> - zero
        <25> - hidden bit
        <24:2> - mantissa
        <1> - guard bit
        <0> - round bit

Arguments:

    Source - Supplies the number of the register that contains the operand.

    ContextBlock - Supplies a pointer to the emulation context block.

    SingleOperand - Supplies a pointer to a structure that is to receive the
        operand value.

Return Value:

    None.

--*/

{

    ULONG Value;

    //
    // Get the source register value and unpack the sign, exponent, and
    // mantissa value.
    //

    Value = KiConvertRegisterToSingleOperand(
                KiGetRegisterValue(Source + 32,
                                  ContextBlock->ExceptionFrame,
                                  ContextBlock->TrapFrame));

    SingleOperand->Sign = Value >> 31;
    SingleOperand->Exponent = (Value >> 23) & 0xff;
    SingleOperand->Mantissa = Value & 0x7fffff;

    //
    // If the exponent is the largest possible value, then the number is
    // either a NaN or an infinity. Otherwise if the exponent is the smallest
    // possible value and the mantissa is nonzero, then the number is
    // denormalized. Otherwise the number is finite and normal.
    //

    if (SingleOperand->Exponent == SINGLE_MAXIMUM_EXPONENT) {
        SingleOperand->Normal = FALSE;
        if (SingleOperand->Mantissa != 0) {
            SingleOperand->Infinity = FALSE;
            SingleOperand->Nan = TRUE;

        } else {
            SingleOperand->Infinity = TRUE;
            SingleOperand->Nan = FALSE;
        }

    } else {
        SingleOperand->Infinity = FALSE;
        SingleOperand->Nan = FALSE;
        SingleOperand->Normal = TRUE;
        if (SingleOperand->Exponent == SINGLE_MINIMUM_EXPONENT) {
            if (SingleOperand->Mantissa != 0) {
                if (ContextBlock->SoftwareFpcr->DenormalOperandsEnable == 0) {
                    DBGPRINT("SoftwareFpcr->DenormalOperandsEnable == 0\n");
                    SingleOperand->Mantissa = 0;
                    SingleOperand->Exponent = 0;
                } else {
                    SingleOperand->Normal = FALSE;
                    SingleOperand->Exponent += 1;
                    while ((SingleOperand->Mantissa & (1 << 23)) == 0) {
                        SingleOperand->Mantissa <<= 1;
                        SingleOperand->Exponent -= 1;
                    }
                }
            }

        } else {
            SingleOperand->Mantissa |= (1 << 23);
        }
    }

    //
    // Left shift the mantissa 2-bits to provide for a guard bit and a round
    // bit.
    //

    SingleOperand->Mantissa <<= 2;
    DBGPRINT("KiUnpackSingle: Inf=%d NaN=%d Sign=%d Exponent=%d Mantissa=%.8x\n",
             SingleOperand->Infinity, SingleOperand->Nan, SingleOperand->Sign,
             SingleOperand->Exponent, SingleOperand->Mantissa);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\clock.s ===
//      TITLE("Interval and Profile Clock Interrupts")
//++
//
// Copyright (c) 1990  Microsoft Corporation
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    clock.s
//
// Abstract:
//
//    This module implements the code necessary to field and process the
//    interval and profile clock interrupts.
//
// Author:
//
//    David N. Cutler (davec) 27-Mar-1990
//    Joe Notarangelo 06-Apr-1992
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

#if DBG
//
// KiDpcTimeout - This is the number of clock ticks that a single DPC can
//      consume. When a DPC crosses this threshold, a BreakPoint is issued
//
        .globl  KiDpcTimeout
KiDpcTimeout:
        .long   110

//
// KiDpcTimeoutMsg - This is the message that gets displayed if the DPC
//      has exceeded KiDpcTimeout
//
        .globl KiDpcTimeoutMsg
KiDpcTimeoutMsg:
        .ascii "\n*** DPC routine > 1 sec --- This is not a break in KeUpdateRunTime\n"

//
// KiDpcTimeoutMsgLength - This is the length of the timeout message,
//      including the trailing NULL
//
        .globl KiDpcTimeoutMsgLength
KiDpcTimeoutMsgLength:
        .long   69

#endif

//++
//
// VOID
// KeUpdateSystemTime (
//    IN ULONG TimeIncrement
//    )
//
// Routine Description:
//
//    This routine is entered as the result of an interrupt generated by the
//    interval timer. Its function is to update the system time and check to
//    determine if a timer has expired.
//
//    N.B. This routine is executed on a single processor in a multiprocess
//       system. The remainder of the processors only execute the quantum end
//       and runtime update code.
//
// Arguments:
//
//    Time Increment (a0) - Supplies the time increment in 100ns units.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeUpdateSystemTime)

//
// Update the interrupt time.
//

        lda     a2, KiTickOffset        // get tick offset value
        ldl     a3, 0(a2)               //
        LDIP    t8, SharedUserData      // get shared user data address
        ldl     t9, UsInterruptTime + 0(t8) // get low interrupt time
        ldl     t10, UsInterruptTime + 4(t8) // get high interrupt time
        addl    a0, t9, t9              // add time increment value
        cmpult  t9, a0, t11             // compute carry
        addl    t11, t10, t10           // add carry to high part
        stl     t10, UsInterruptTime + 8(t8) // store high interrupt time
        stl     t9, UsInterruptTime + 0(t8) // store low interrupt time

#if !defined(NT_UP)

        mb                              //

#endif

        stl     t10, UsInterruptTime + 4(t8) // store high interrupt time

        zapnot  t9, 15, t9              // set t9 = full 64 bits of
        sll     t10, 32, t10            //   interrupt time 
        bis     t9, t10, t9             //

        subq    a3, a0, a3              // subtract time increment
        lda     v0, KeTickCount         // get tick count value
        ldq     t6, 0(v0)               //
        lda     t0, KiTimerTableListHead // get base address of timer table
        stl     a3, 0(a2)               // store tick offset value
        bgt     a3, 10f                 // if gt, tick not completed
        ldl     a4, KeMaximumIncrement  // get maximum increment value

//
// Update system time.
//

        lda     t1, KeTimeAdjustment    // get time adjustment value
        ldl     t1, 0(t1)               //
        ldl     t3, UsSystemTime + 0(t8) // get low system time
        ldl     t4, UsSystemTime + 4(t8) // get high system time
        addl    t1, t3, t3              // add time increment value
        cmpult  t3, t1, t5              // compute carry
        addl    t5, t4, t4              // add carry to high part
        stl     t4, UsSystemTime + 8(t8) // store high system time
        stl     t3, UsSystemTime + 0(t8) // store low system time

#if !defined(NT_UP)

        mb                              //

#endif

        stl     t4, UsSystemTime + 4(t8)    // store high system time

//
// Update the tick count.
//

        addq    t6, 1, t1               // increment tick count value
        stq     t1, 0(v0)               // store tick count value
        stl     t1, UsTickCountLow(t8)  // store low tick count value

//
// Compute next tick offset value.
//

        addq    a3, a4, a4              // add maximum increment to residue
        stl     a4, 0(a2)               // store tick offset value

//
// Check to determine if a timer has expired at the current hand value.
//

        and     t6, TIMER_TABLE_SIZE - 1, v0  // reduce to table table index

#if defined(_AXP64_)

        sll     v0, 4, t2               // compute timer table listhead address
        addq    t2, t0, t2              //

#else

        s8addl  v0, t0, t2              // compute timer table listhead address

#endif

        LDP     t3, LsFlink(t2)         // get address of first timer in list
        cmpeq   t2, t3, t4              // compare fist with listhead address
        bne     t4, 5f                  // if ne, no timer active

//
// Get the expiration time from the timer object.
//
// N.B. The offset to the timer list entry must be subtracted out of the
//      displacement calculation.
//

        ldq     t4,TiDueTime - TiTimerListEntry(t3) // get due time
        cmpule  t4, t9, t5              // is expiration time <= system time
        bne     t5, 20f                 // if ne, timer has expired

//
// Check to determine if a timer has expired at the next hand value.
//

5:      addq    t6, 1, t6               // advance hand value to next entry
10:     and     t6, TIMER_TABLE_SIZE - 1, v0 // reduce to table table index

#if defined(_AXP64_)

        sll     v0, 4, t2               // compute timer table listhead address
        addq    t2, t0, t2              //

#else

        s8addl  v0, t0, t2              // compute timer table listhead address

#endif

        LDP     t3, LsFlink(t2)         // get address of first timer in list
        cmpeq   t2, t3, t4              // compare fist with listhead address
        bne     t4, 40f                 // if ne, no timer active

//
// Get the expiration time from the timer object.
//

        ldq     t4, TiDueTime - TiTimerListEntry(t3) // get due time
        cmpule  t4, t9, t5              // is expiration time <= system time
        beq     t5, 40f                 // if eq, timer has not expired

//
// Put timer expiration DPC in the system DPC list and initiate a dispatch
// interrupt on the current processor.
//

20:     lda     t2, KiTimerExpireDpc    // get expiration DPC address

        DISABLE_INTERRUPTS              // disable interrupts

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        lda     t3, PbDpcListHead(v0)   // get DPC listhead address
        lda     t1, PbDpcLock(v0)       // get address of spin lock

#if !defined(NT_UP)

30:     LDP_L   t4, 0(t1)               // get current lock value
        bis     t1, zero, t5            // set ownership value
        bne     t4, 50f                 // if ne, spin lock owned
        STP_C   t5, 0(t1)               // set spin lock owned
        beq     t5, 50f                 // if eq, store conditional failed
        mb                              // synchronize memory access

#endif

        LDP     t4, DpLock(t2)          // get DPC inserted state
        bne     t4, 35f                 // if ne, DPC entry already inserted
        LDP     t4, LsBlink(t3)         // get address of last entry in list
        STP     t1, DpLock(t2)          // set DPC inserted state
        STP     t6, DpSystemArgument1(t2) // set timer table hand value
        ADDP    t2, DpDpcListEntry, t2  // compute address of DPC list entry
        STP     t2, LsBlink(t3)         // set address of new last entry
        STP     t2, LsFlink(t4)         // set next link in old last entry
        STP     t3, LsFlink(t2)         // set address of next entry
        STP     t4, LsBlink(t2)         // set address of previous entry
        ldl     t5, PbDpcQueueDepth(v0) // get current DPC queue depth
        addl    t5, 1, t7               // increment DPC queue depth
        stl     t7, PbDpcQueueDepth(v0) // set updated DPC queue depth

//
// N.B. Since an interrupt must be active, simply set the software interrupt
//      request bit in the PRCB to request a dispatch interrupt directly from
//      the interrupt exception handler.
//

        ldil    t11, DISPATCH_INTERRUPT  // get interrupt request level
        stl     t11, PbSoftwareInterrupts(v0) // set interrupt request level
35:                                     //

#if !defined(NT_UP)

        mb                              // synchronize memory access
        STP     zero, 0(t1)             // set spin lock not owned

#endif

        ENABLE_INTERRUPTS               // enable interrupts

//
// Check to determine is a full tick has expired.
//

40:     ble      a3, KeUpdateRunTime    // if le, full tick expiration
        ret     zero, (ra)              // return

//
// Attempt to acquire the dpc lock failed.
//

#if !defined(NT_UP)

50:     LDP     t4, 0(t1)               // get lock value
        beq     t4, 30b                 // if eq, lock available
        br      zero, 50b               // retry

#endif

        .end    KeUpdateSystemTime

//++
//
// VOID
// KeUpdateRunTime (
//    VOID
//    )
//
// Routine Description:
//
//    This routine is entered as the result of an interrupt generated by the
//    interval timer. Its function is to update the runtime of the current
//    thread, update the runtime of the current thread's process, and decrement
//    the current thread's quantum.
//
//    N.B. This routine is executed on all processors in a multiprocess system.
//
// Arguments:
//
//    None
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeUpdateRunTime)

        GET_CURRENT_THREAD              // get current thread address

        bis     v0, zero, t0            // save current thread address

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        bis     v0, zero, t5            // save current prcb address
        LDP     a0, PbInterruptTrapFrame(v0) // get trap frame address

//
// Update the current DPC rate.
//
// A running average of the DPC rate is used. The number of DPCs requested
// in the previous tick is added to the current DPC rate and divided by two.
// This becomes the new DPC rate.
//

        ldl     t1, PbDpcCount(t5)      // get current DPC count
        ldl     t6, PbLastDpcCount(t5)  // get last DPC count
        subl    t1, t6, t7              // compute difference
        ldl     t2, PbDpcRequestRate(t5) // get old DPC request rate
        addl    t7, t2, t3              // compute average
        srl     t3, 1, t4               //
        stl     t4, PbDpcRequestRate(t5) // store new DPC request rate
        stl     t1, PbLastDpcCount(t5)  // update last DPC count
        LDP     t2, ThApcState + AsProcess(t0) // get current process address
        ldl     t3, TrPsr(a0)           // get saved processor status
        and     t3, PSR_MODE_MASK, t6   // isolate previous mode
        bne     t6, 30f                 // if ne, previous mode was user

//
// If a DPC is active, then increment the time spent executing DPC routines.
// Otherwise, if the old IRQL is greater than DPC level, then increment the
// time spent executing interrupt service routines.  Otherwise, increment
// the time spent in kernel mode for the current thread.
//

        srl     t3, PSR_IRQL, t6        // isolate previous IRQL
        ldl     v0, PbDpcRoutineActive(t5) // get DPC active flag
        subl    t6, DISPATCH_LEVEL, t6  // previous Irql - DPC level
        blt     t6, 20f                 // if lt, charge against thread
        lda     t8, PbInterruptTime(t5) // compute interrupt time address
        bgt     t6, 10f                 // if gt, increment interrupt time
        lda     t8, PbDpcTime(t5)       // compute DPC time address
        beq     v0, 20f                 // if eq, not executing DPC

#if DBG
//
// On a checked build, increment the DebugDpcTime count and see if this
// has exceeded the value of KiDpcTimeout. If it has, then we need to
// print a message and issue a breakpoint (if possible)
//
        ldl     t9, PbDebugDpcTime(t5)  // load current time in DPC
        addl    t9, 1, t9               // another tick occured
        ldl     t10, KiDpcTimeout       // What is the timeout value?
        cmpule  t9, t10, t11            // T11=1 if tick <= timeout
        bne     t11, 5f                 // if ne, then time is okay
        lda     a0, KiDpcTimeoutMsg     // load the timeout message address
        ldl     a1, KiDpcTimeoutMsgLength // load the timeout message length
        BREAK_DEBUG_PRINT               // Print the message
        BREAK_DEBUG_STOP                // Enter the debugger
        bis     zero, zero, t9          // Clear the time in DPC

5:      stl     t9, PbDebugDpcTime(t5)  // store current time in DPC
#endif

//
// Update the time spent executing DPC or interrupt level
//
// t8 = address of time to increment
//

10:     ldl     t11, 0(t8)              // get processor time
        addl    t11, 1, t11             // increment processor time
        stl     t11, 0(t8)              // update processor time
        lda     t6, PbKernelTime(t5)    // compute address of kernel time
        br      zero, 45f               // update kernel time

//
// Update the time spent in kernel mode for the current thread and the current
// thread's process.
//

20:     ldl     t11, ThKernelTime(t0)   // get kernel time
        addl    t11, 1, t11             // increment kernel time
        stl     t11, ThKernelTime(t0)   // store updated kernel time
        lda     t2, PrKernelTime(t2)    // compute process kernel time address
        lda     t6, PbKernelTime(t5)    // compute processor kernel time addr
        br      zero, 40f               // join comon code

//
// Update the time spend in user mode for the current thread and the current
// thread's process.
//

30:     ldl     t11, ThUserTime(t0)     // get user time
        addl    t11, 1, t11             // increment user time
        stl     t11, ThUserTime(t0)     // store updated user time
        lda     t2, PrUserTime(t2)      // compute process user time address
        lda     t6, PbUserTime(t5)      // compute processor user time address

//
// Update the time spent in kernel/user mode for the current thread's process.
//

40:                                     //

#if !defined(NT_UP)

        ldl_l   t11, 0(t2)              // get process time
        addl    t11, 1, t11             // increment process time
        stl_c   t11, 0(t2)              // store updated process time
        beq     t11, 41f                // if eq, store conditional failed
        mb                              // synchronize subsequent reads

#else

        ldl     t11,0(t2)               // get process time
        addl    t11, 1, t11             // increment process time
        stl     t11,0(t2)               // store updated process time

#endif

//
// A DPC is not active.  If there are DPCs in the DPC queue and a  DPC
// interrupt has not  been requested, request  a dispatch interrupt  in
// order to initiate the batch  processing of the  pending DPCs in  the
// DPC queue.
//
// N.B. Since an interrupt must be active, the software interrupt request
//      bit in the PRCB can be set to request a dispatch interrupt directly from
//      the interrupt exception handler.
//
// Pushing DPCs from the clock interrupt indicates that the current maximum
// DPC queue depth is too high. If the DPC rate does not exceed the ideal
// rate, decrement the maximum DPC queue depth and
// reset the threshold to its original value.
//

        ldl     t1, PbDpcQueueDepth(t5) // get current queue depth
        beq     t1, 45f                 // skip if queue is empty
        ldl     t2, PbDpcInterruptRequested(t5) // get dpc interrupt request flag
        bne     t2, 45f                 // skip if flag is set
        ldil    a0, DISPATCH_INTERRUPT  // set software interrupt request
        stl     a0, PbSoftwareInterrupts(t5) //
        ldl     t3, PbMaximumDpcQueueDepth(t5) // get current DPC queue depth
        subl    t3, 1, t4                // decrement
        ldl     t2, PbDpcRequestRate(t5) // get old DPC request rate
        ldl     t1, KiIdealDpcRate       // get ideal DPC rate
        cmpult  t2, t1, t2               // compare current with ideal
        ldl     t1, KiAdjustDpcThreshold // get system threshold default
        stl     t1, PbAdjustDpcThreshold(t5) // reset processor threshold default
        beq     t4, 50f                  // if queue depth==0, skip decrement
        beq     t2, 50f                  // if rate not lt ideal rate, skip decrement
        stl     t4, PbMaximumDpcQueueDepth(t5) // set current DPC queue depth
        br      zero, 50f                // rejoin common code

//
// There is no need to push a DPC from the clock interrupt. This indicates that
// the current maximum DPC queue depth may be too low. Decrement the threshold
// indicator, and if the new threshold is zero, and the current maximum queue
// depth is less than the maximum, increment the maximum DPC queue
// depth.
//

45:     ldl     t1, PbAdjustDpcThreshold(t5) // get current threshold
        subl    t1, 1, t2               // decrement threshold
        stl     t2, PbAdjustDpcThreshold(t5) // update current threshold
        bne     t2, 50f                 // if threshold nez, skip
        ldl     t1, KiAdjustDpcThreshold // get system threshold default
        stl     t1, PbAdjustDpcThreshold(t5) // reset processor threshold default
        ldl     t3, PbMaximumDpcQueueDepth(t5) // get current DPC queue depth
        ldl     t1, KiMaximumDpcQueueDepth // get maximum DPC queue depth
        cmpult  t3, t1, t2              // compare
        beq     t2, 50f                 // if current not lt maximum, skip
        addl    t3, 1, t4               // increment queue depth
        stl     t4, PbMaximumDpcQueueDepth(t5) // update current DPC queue depth

//
// Update the time spent in kernel/user mode for the current processor.
//
// t5 = pointer to processor time to increment
//

50:     ldl     t11, 0(t6)              // get processor time
        addl    t11, 1, t11             // increment processor time
        stl     t11, 0(t6)              // store updated processor time

//
// If the current thread is not the idle thread, decrement its
// quantum and check to determine if a quantum end has occurred.
//

        LDP     t6, PbIdleThread(t5)    // get address of idle thread
        cmpeq   t6, t0, t7              // check if idle thread running
        bne     t7, 60f                 // if ne, idle thread running
        LoadByte(t7, ThQuantum(t0))     // get current thread quantum
        sll     t7, 56, t9              //
        sra     t9, 56, t7              //
        subl    t7, CLOCK_QUANTUM_DECREMENT, t7 // decrement quantum
        StoreByte(t7, ThQuantum(t0))    // store thread quantum
        bgt     t7, 60f                 // if gtz, quantum remaining

//
// Put processor specific quantum end DPC in the system DPC list and initiate
// a dispatch interrupt on the current processor.
//
// N.B. Since an interrupt must be active, simply set the software interrupt
//      request bit in the PRCB to request a dispatch interrupt directly from
//      the interrupt exception handler.
//

        ldil    a0, DISPATCH_INTERRUPT  // set interrupt request mask
        stl     a0, PbSoftwareInterrupts(t5) // request software interrupt
        stl     a0, PbQuantumEnd(t5)    // set quantum end indicator
60:     ret     zero, (ra)              // return

//
// Atomic increment of user/kernel time failed.
//

#if !defined(NT_UP)

41:     br      zero, 40b               // retry atomic increment

#endif

        .end    KeUpdateRunTime

//++
//
// VOID
// KeProfileInterrupt (
//    VOID
//    )
//
// VOID
// KeProfileInterruptWithSource (
//    IN KPROFILE_SOURCE ProfileSource
//    )
//
// VOID
// KiProfileInterrupt(
//    IN KPROFILE_SOURCE ProfileSource,
//    IN PKTRAP_FRAME TrapFrame
//    )
//
// Routine Description:
//
//    This routine is entered as the result of an interrupt generated by the
//    profile timer. Its function is to update the profile information for
//    the currently active profile objects.
//
//    N.B. This routine is executed on all processors in a multiprocess system.
//
// Arguments:
//
//    ProfileSource (a0) - Supplies the source of the profile interrupt
//              KeProfileInterrupt is an alternate entry for backwards
//              compatibility that sets the source to zero (ProfileTime)
//
// Return Value:
//
//    None.
//
//--

        .struct 0
PfS0:   .space  8                       // saved integer register s0
PfRa:   .space  8                       // return address
        .space  2 * 8                   // profile frame length
ProfileFrameLength:

        NESTED_ENTRY(KeProfileInterrupt, ProfileFrameLength, zero)

        bis     zero, zero, a0          // set profile source to ProfileTime

        ALTERNATE_ENTRY(KeProfileInterruptWithSource)

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        LDP     a1, PbInterruptTrapFrame(v0) // get trap frame address

        ALTERNATE_ENTRY(KiProfileInterrupt)

        lda     sp, -ProfileFrameLength(sp) // allocate stack frame
        stq     ra, PfRa(sp)            // save return address

#if !defined(NT_UP)

        stq     s0, PfS0(sp)            // save integer register s0

#endif

        PROLOGUE_END

//
// Acquire profile lock.
//

#if !defined(NT_UP)

        lda     s0, KiProfileLock       // get address of profile lock
10:     LDP_L   t0, 0(s0)               // get current lock value
        bis     s0, zero, t1            // set ownership value
        bne     t0, 15f                 // if ne, spin lock owned
        STP_C   t1, 0(s0)               // set spin lock owned
        beq     t1, 15f                 // if eq, store conditional failed
        mb                              // synchronize memory access

#endif

        GET_CURRENT_THREAD              // get current thread address

        LDP     a2, ThApcState + AsProcess(v0) // get current process address
        ADDP    a2, PrProfileListHead, a2 // compute profile listhead address
        bsr     ra, KiProcessProfileList // process profile list
        lda     a2, KiProfileListHead   // get system profile listhead address
        bsr     ra, KiProcessProfileList // process profile list

#if !defined(NT_UP)

        mb                              // synchronize memory access
        STP     zero, 0(s0)             // set spin lock not owned
        ldq     s0, PfS0(sp)            // restore s0

#endif

        ldq     ra, PfRa(sp)            // restore return address
        lda     sp, ProfileFrameLength(sp)  // deallocate stack frame
        ret     zero, (ra)              // return

//
// Acquire profile lock failed.
//

#if !defined(NT_UP)

15:     LDP     t0, 0(s0)               // get current lock value
        beq     t0, 10b                 // if eq, lock available
        br      zero, 15b               // spin in cache until lock ready

#endif

        .end    KeProfileInterrupt

//++
//
// VOID
// KiProcessProfileList (
//    IN KPROFILE_SOURCE Source,
//    IN PKTRAP_FRAME TrapFrame,
//    IN PLIST_ENTRY ListHead
//    )
//
// Routine Description:
//
//    This routine is called to process a profile list.
//
// Arguments:
//
//    Source (a1) - Supplies profile source to match
//
//    TrapFrame (a0) - Supplies a pointer to a trap frame.
//
//    ListHead (a2) - Supplies a pointer to a profile list.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiProcessProfileList)

        LDP     a3, LsFlink(a2)         // get address of next entry
        cmpeq   a2, a3, t0              // end of list ?
        bne     t0, 30f                 // if ne, end of list
        LDP     t0, TrFir(a1)           // get interrupt PC address

        GET_PROCESSOR_CONTROL_REGION_BASE // get current pcr address

        ldl     t6, PcSetMember(v0)     // get processor member

//
// Scan profile list and increment profile buckets as appropriate.
//

10:     LDP     t1, PfRangeBase - PfProfileListEntry(a3) // get base of range
        LDP     t2, PfRangeLimit - PfProfileListEntry(a3) // get limit of range
        ldl     t4, PfSource - PfProfileListEntry(a3) // get source
        ldl     t7, PfAffinity - PfProfileListEntry(a3) // get affinity
        zapnot  t4, 3, t4               // source is a SHORT
        cmpeq   t4, a0, t5              // check against profile source
        and     t7, t6, v0              // check against processor
        beq     t5, 20f                 // if ne, profile source doesn't match
        beq     v0, 20f                 // if ne, processor doesn't match
        cmpult  t0, t1, v0              // check against range base
        cmpult  t0, t2, t3              // check against range limit
        bne     v0, 20f                 // if ne, less than range base
        beq     t3, 20f                 // if eq, not less than range limit
        SUBP    t0, t1, t1              // compute offset in range
        ldl     t2, PfBucketShift - PfProfileListEntry(a3) // get shift count
        LDP     v0, PfBuffer - PfProfileListEntry(a3) // profile buffer address
        zap     t1, 0xf0, t1            // force bucket offset to 32bit unit
        srl     t1, t2, t3              // compute bucket offset
        bic     t3, 0x3, t3             // clear low order offset bits
        ADDP    v0, t3, t3              // compute bucket address
        ldl     v0, 0(t3)               // increment profile bucket
        addl    v0, 1, v0               //
        stl     v0, 0(t3)               //
20:     LDP     a3, LsFlink(a3)         // get address of next entry
        cmpeq   a2, a3, t1              // end of list?
        beq     t1, 10b                 // if eq[false], more entries
30:     ret     zero, (ra)              // return

        .end    KiProcessProfileList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\flushtb.c ===
/*++

Copyright (c) 1992-1998  Microsoft Corporation
Copyright (c) 1993  Digital Equipment Corporation

Module Name:

    flushtb.c

Abstract:

    This module implements machine dependent functions to flush the
    translation buffers and synchronize PIDs in an Alpha AXP MP system.

    N.B. This module contains only MP versions of the TB flush routines.
         The UP versions are macros in ke.h
         KeFlushEntireTb remains a routine for the UP system since it is
         exported from the kernel for backwards compatibility.

Author:

    David N. Cutler (davec) 13-May-1989
    Joe Notarangelo  29-Nov-1993

Environment:

    Kernel mode only.

Revision History:


--*/

#include "ki.h"

//
// Define forward referenced prototypes.
//

VOID
KiFlushEntireTbTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiFlushMultipleTbTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Number,
    IN PVOID Virtual,
    IN PVOID Pid
    );

VOID
KiFlushSingleTbTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Virtual,
    IN PVOID Pid,
    IN PVOID Parameter3
    );

VOID
KiFlushMultipleTbTarget64 (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Number,
    IN PVOID Virtual,
    IN PVOID Pid
    );

VOID
KiFlushSingleTbTarget64 (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Virtual,
    IN PVOID Pid,
    IN PVOID Parameter3
    );

#if !defined(NT_UP)


VOID
KeFlushEntireTb (
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes the entire translation buffer (TB) on all
    processors that are currently running threads which are children
    of the current process or flushes the entire translation buffer
    on all processors in the host configuration.

Arguments:

    Invalid - Supplies a boolean value that specifies the reason for
        flushing the translation buffer.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

Return Value:

    None.

--*/

{

    KAFFINITY EntireSet;
    KIRQL OldIrql;
    PKPROCESS Process;
    PKTHREAD Thread;
    KAFFINITY TargetProcessors;

    //
    // Compute the target set of processors, disable context switching,
    // and send the flush entire parameters to the target processors,
    // if any, for execution.
    //

    if (AllProcessors != FALSE) {
        OldIrql = KeRaiseIrqlToSynchLevel();
        TargetProcessors = KeActiveProcessors;

    } else {
        KiLockContextSwap(&OldIrql);
        Thread = KeGetCurrentThread();
        Process = Thread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
        if (TargetProcessors != Process->RunOnProcessors) {
            Process->ProcessSequence = KiMasterSequence - 1;
        }
    }

    EntireSet = KeActiveProcessors & PCR->NotMember;
    TargetProcessors &= PCR->NotMember;

    //
    // If the target set fo processors is equal to the full set of processors,
    // then set the TB flush time stamp busy.
    //

    if (TargetProcessors == EntireSet) {
        KiSetTbFlushTimeStampBusy();
    }

    //
    // Send packet to target processors.
    //

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushEntireTbTarget,
                        NULL,
                        NULL,
                        NULL);
    }

    IPI_INSTRUMENT_COUNT(KeGetCurrentPrcb()->Number, FlushEntireTb);

    //
    // Flush TB on current processor.
    //

    // KeFlushCurrentTb();
    __tbia();

    //
    // Wait until all target processors have finished.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // If the target set of processors is equal to the full set of processors,
    // then clear the TB flush time stamp busy.
    //

    if (TargetProcessors == EntireSet) {
        KiClearTbFlushTimeStampBusy();
    }

    //
    // Lower IRQL and unlock as appropriate.
    //

    if (AllProcessors != FALSE) {
        KeLowerIrql(OldIrql);

    } else {
        KiUnlockContextSwap(OldIrql);
    }

    return;
}


VOID
KiFlushEntireTbTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for flushing the entire TB.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Parameter1 - Parameter3 - not used

Return Value:

    None.

--*/

{

    //
    // Flush the entire TB on the current processor
    //

    KiIpiSignalPacketDone(SignalDone);

    // KeFlushCurrentTb();
    __tbia();

    IPI_INSTRUMENT_COUNT(KeGetCurrentPrcb()->Number, FlushEntireTb);

    return;
}

VOID
KeFlushMultipleTb (
    IN ULONG Number,
    IN PVOID *Virtual,
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors,
    IN PHARDWARE_PTE *PtePointer OPTIONAL,
    IN HARDWARE_PTE PteValue
    )

/*++

Routine Description:

    This function flushes multiple entries from the translation buffer
    on all processors that are currently running threads which are
    children of the current process or flushes a multiple entries from
    the translation buffer on all processors in the host configuration.

Arguments:

    Number - Supplies the number of TB entries to flush.

    Virtual - Supplies a pointer to an array of virtual addresses that
        are within the pages whose translation buffer entries are to be
        flushed.

    Invalid - Supplies a boolean value that specifies the reason for
        flushing the translation buffer.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

    PtePointer - Supplies an optional pointer to an array of pointers to
       page table entries that receive the specified page table entry
       value.

    PteValue - Supplies the the new page table entry value.

Return Value:

    The previous contents of the specified page table entry is returned
    as the function value.

--*/

{

    ULONG Index;
    KIRQL OldIrql;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;
    PKTHREAD Thread;

    //
    // Compute the target set of processors and send the flush multiple
    // parameters to the target processors, if any, for execution.
    //

    if (AllProcessors != FALSE) {
        OldIrql = KeRaiseIrqlToSynchLevel();
        TargetProcessors = KeActiveProcessors;

    } else {
        KiLockContextSwap(&OldIrql);
        Thread = KeGetCurrentThread();
        Process = Thread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
        if (TargetProcessors != Process->RunOnProcessors) {
            Process->ProcessSequence = KiMasterSequence - 1;
        }
    }

    //
    // If a page table entry address address is specified, then set the
    // specified page table entries to the specific value.
    //

    if (ARGUMENT_PRESENT(PtePointer)) {
        for (Index = 0; Index < Number; Index += 1) {
            *PtePointer[Index] = PteValue;
        }
    }

    TargetProcessors &= PCR->NotMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushMultipleTbTarget,
                        ULongToPtr(Number),
                        (PVOID)Virtual,
                        NULL);
    }

    IPI_INSTRUMENT_COUNT(KeGetCurrentPrcb()->Number, FlushMultipleTb);

    //
    // Flush the specified entries from the TB on the current processor.
    //

    KiFlushMultipleTb(Invalid, &Virtual[0], Number);

    //
    // Wait until all target processors have finished.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // If the context swap lock was acquired, release it.
    //
    if (AllProcessors != FALSE) {
        KeLowerIrql(OldIrql);

    } else {
        KiUnlockContextSwap(OldIrql);
    }

    return;
}

VOID
KiFlushMultipleTbTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Number,
    IN PVOID Virtual,
    IN PVOID Pid
    )

/*++

Routine Description:

    This is the target function for flushing multiple TB entries.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Number - Supplies the number of TB entries to flush.

    Virtual - Supplies a pointer to an array of virtual addresses that
        are within the pages whose translation buffer entries are to be
        flushed.

    Pid - Supplies the PID of the TB entries to flush.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Limit;
    PVOID Array[FLUSH_MULTIPLE_MAXIMUM];

    //
    // Flush multiple entries from the TB on the current processor
    //

    //
    // Capture the virtual addresses that are to be flushed from the TB
    // on the current processor and clear the packet address.
    //

    Limit = (ULONG)((ULONG_PTR)Number);
    for (Index = 0; Index < Limit; Index += 1) {
        Array[Index] = ((PVOID *)(Virtual))[Index];
    }

    KiIpiSignalPacketDone(SignalDone);

    //
    // Flush the specified virtual addresses from the TB on the current
    // processor.
    //

    KiFlushMultipleTb(TRUE, &Array[0], Limit);

    IPI_INSTRUMENT_COUNT(KeGetCurrentPrcb()->Number, FlushMultipleTb);

    return;
}

HARDWARE_PTE
KeFlushSingleTb (
    IN PVOID Virtual,
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors,
    IN PHARDWARE_PTE PtePointer,
    IN HARDWARE_PTE PteValue
    )

/*++

Routine Description:

    This function flushes a single entry from the translation buffer
    on all processors that are currently running threads which are
    children of the current process or flushes a single entry from
    the translation buffer on all processors in the host configuration.

Arguments:

    Virtual - Supplies a virtual address that is within the page whose
        translation buffer entry is to be flushed.

    Invalid - Supplies a boolean value that specifies the reason for
        flushing the translation buffer.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

    PtePointer - Supplies a pointer to the page table entry which
        receives the specified value.

    PteValue - Supplies the the new page table entry value.

Return Value:

    The previous contents of the specified page table entry is returned
    as the function value.

--*/

{

    KIRQL OldIrql;
    HARDWARE_PTE OldPte;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;
    PKTHREAD Thread;

    //
    // Compute the target set of processors and send the flush single
    // paramters to the target processors, if any, for execution.
    //

    if (AllProcessors != FALSE) {
        OldIrql = KeRaiseIrqlToSynchLevel();
        TargetProcessors = KeActiveProcessors;

    } else {
        KiLockContextSwap(&OldIrql);
        Thread = KeGetCurrentThread();
        Process = Thread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
        if (TargetProcessors != Process->RunOnProcessors) {
            Process->ProcessSequence = KiMasterSequence - 1;
        }
    }

    //
    // Capture the previous contents of the page table entry and set the
    // page table entry to the new value.
    //

    OldPte = *PtePointer;
    *PtePointer = PteValue;
    TargetProcessors &= PCR->NotMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushSingleTbTarget,
                        (PVOID)Virtual,
                        NULL,
                        NULL);
    }

    IPI_INSTRUMENT_COUNT(KeGetCurrentPrcb()->Number, FlushSingleTb);

    //
    // Flush the specified entry from the TB on the current processor.
    //

//    KiFlushSingleTb(Invalid, Virtual);
    __tbis(Virtual);

    //
    // Wait until all target processors have finished.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    if (AllProcessors != FALSE) {
        KeLowerIrql(OldIrql);

    } else {
        KiUnlockContextSwap(OldIrql);
    }

    //
    // return the previous page table entry value.
    //

    return OldPte;
}

VOID
KiFlushSingleTbTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Virtual,
    IN PVOID Pid,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for flushing a single TB entry.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Virtual - Supplies a virtual address that is within the page whose
        translation buffer entry is to be flushed.

    RequestPacket - Supplies a pointer to a flush single TB packet address.

    Pid - Supplies the PID of the TB entries to flush.

    Parameter3 - Not used.

Return Value:

    None.

--*/

{

    //
    // Flush a single entry form the TB on the current processor.
    //

    KiIpiSignalPacketDone(SignalDone);
//    KiFlushSingleTb(TRUE, Virtual);
    __tbis(Virtual);

    IPI_INSTRUMENT_COUNT(KeGetCurrentPrcb()->Number, FlushSingleTb);

    return;
}

#endif // !defined(NT_UP)


VOID
KeFlushMultipleTb64 (
    IN ULONG Number,
    IN PULONG_PTR Virtual,
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors,
    IN PHARDWARE_PTE *PtePointer OPTIONAL,
    IN HARDWARE_PTE PteValue
    )

/*++

Routine Description:

    This function flushes multiple entries from the translation buffer
    on all processors that are currently running threads which are
    children of the current process or flushes a multiple entries from
    the translation buffer on all processors in the host configuration.

Arguments:

    Number - Supplies the number of TB entries to flush.

    Virtual - Supplies a pointer to an array of virtual page numbers that
        are flushed from the TB.

    Invalid - Supplies a boolean value that specifies the reason for
        flushing the translation buffer.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

    PtePointer - Supplies an optional pointer to an array of pointers to
       page table entries that receive the specified page table entry
       value.

    PteValue - Supplies the the new page table entry value.

Return Value:

    The previous contents of the specified page table entry is returned
    as the function value.

--*/

{

    ULONG Index;
    KIRQL OldIrql;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;
    PKTHREAD Thread;

    ASSERT(Number <= FLUSH_MULTIPLE_MAXIMUM);

    //
    // Compute the target set of processors.
    //

#if defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

#else

    if (AllProcessors != FALSE) {
        OldIrql = KeRaiseIrqlToSynchLevel();
        TargetProcessors = KeActiveProcessors;

    } else {
        KiLockContextSwap(&OldIrql);
        Thread = KeGetCurrentThread();
        Process = Thread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
        if (TargetProcessors != Process->RunOnProcessors) {
            Process->ProcessSequence = KiMasterSequence - 1;
        }
    }

    TargetProcessors &= PCR->NotMember;

#endif

    //
    // If a page table entry address array is specified, then set the
    // specified page table entries to the specific value.
    //

    if (ARGUMENT_PRESENT(PtePointer)) {
        for (Index = 0; Index < Number; Index += 1) {
            *PtePointer[Index] = PteValue;
        }
    }

    //
    // If any target processors are specified, then send a flush multiple
    // packet to the target set of processor.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushMultipleTbTarget64,
                        ULongToPtr(Number),
                        (PVOID)Virtual,
                        NULL);
    }

#endif

    //
    // Flush the specified entries from the TB on the current processor.
    //

    KiFlushMultipleTb64(Invalid, &Virtual[0], Number);

    //
    // Wait until all target processors have finished.
    //

#if defined(NT_UP)

    KeLowerIrql(OldIrql);

#else

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    if (AllProcessors != FALSE) {
        KeLowerIrql(OldIrql);

    } else {
        KiUnlockContextSwap(OldIrql);
    }

#endif

    return;
}

#if !defined(NT_UP)


VOID
KiFlushMultipleTbTarget64 (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Number,
    IN PVOID Virtual,
    IN PVOID Pid
    )

/*++

Routine Description:

    This is the target function for flushing multiple TB entries.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Number - Supplies the number of TB entries to flush.

    Virtual - Supplies a pointer to an array of virtual page numbers that
        are flushed from the TB.

    Pid - Supplies the PID of the TB entries to flush.

Return Value:

    None.

--*/

{

    ULONG Index;
    ULONG Limit;
    ULONG_PTR Array[FLUSH_MULTIPLE_MAXIMUM];

    ASSERT((ULONG_PTR)Number <= FLUSH_MULTIPLE_MAXIMUM);

    //
    // Capture the virtual addresses that are to be flushed from the TB
    // on the current processor and clear the packet address.
    //

    Limit = (ULONG)((ULONG_PTR)Number);
    for (Index = 0; Index < Limit; Index += 1) {
        Array[Index] = ((PULONG_PTR)(Virtual))[Index];
    }

    KiIpiSignalPacketDone(SignalDone);

    //
    // Flush the specified virtual addresses from the TB on the current
    // processor.
    //

    KiFlushMultipleTb64(TRUE, &Array[0], Limit);
    return;
}

#endif


HARDWARE_PTE
KeFlushSingleTb64 (
    IN ULONG_PTR Virtual,
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors,
    IN PHARDWARE_PTE PtePointer,
    IN HARDWARE_PTE PteValue
    )

/*++

Routine Description:

    This function flushes a single entry from the translation buffer
    on all processors that are currently running threads which are
    children of the current process or flushes a single entry from
    the translation buffer on all processors in the host configuration.

Arguments:

    Virtual - Supplies a virtual page number that is flushed from the TB.

    Invalid - Supplies a boolean value that specifies the reason for
        flushing the translation buffer.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

    PtePointer - Supplies a pointer to the page table entry which
        receives the specified value.

    PteValue - Supplies the the new page table entry value.

Return Value:

    The previous contents of the specified page table entry is returned
    as the function value.

--*/

{

    KIRQL OldIrql;
    HARDWARE_PTE OldPte;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;
    PKTHREAD Thread;

    //
    // Compute the target set of processors.
    //

#if defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

#else

    if (AllProcessors != FALSE) {
        OldIrql = KeRaiseIrqlToSynchLevel();
        TargetProcessors = KeActiveProcessors;

    } else {
        KiLockContextSwap(&OldIrql);
        Thread = KeGetCurrentThread();
        Process = Thread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
        if (TargetProcessors != Process->RunOnProcessors) {
            Process->ProcessSequence = KiMasterSequence - 1;
        }
    }

    TargetProcessors &= PCR->NotMember;

#endif

    //
    // Capture the previous contents of the page table entry and set the
    // page table entry to the new value.
    //

    OldPte = *PtePointer;
    *PtePointer = PteValue;

    //
    // If any target processors are specified, then send a flush single
    // packet to the target set of processors.

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushSingleTbTarget64,
                        (PVOID)Virtual,
                        NULL,
                        NULL);
    }

#endif

    //
    // Flush the specified entry from the TB on the current processor.
    //

    KiFlushSingleTb64(Invalid, Virtual);

    //
    // Wait until all target processors have finished.
    //

#if defined(NT_UP)

    KeLowerIrql(OldIrql);

#else

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    if (AllProcessors != FALSE) {
        KeLowerIrql(OldIrql);

    } else {
        KiUnlockContextSwap(OldIrql);
    }

#endif

    return OldPte;
}

#if !defined(NT_UP)


VOID
KiFlushSingleTbTarget64 (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Virtual,
    IN PVOID Pid,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for flushing a single TB entry.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Virtual - Supplies a virtual page number that is flushed from the TB.

    RequestPacket - Supplies a pointer to a flush single TB packet address.

    Pid - Not used.

    Parameter3 - Not used.

Return Value:

    None.

--*/

{

    //
    // Flush a single entry form the TB on the current processor.
    //

    KiIpiSignalPacketDone(SignalDone);
    KiFlushSingleTb64(TRUE, (ULONG_PTR)Virtual);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\exceptn.c ===
/*++

Copyright (c) 1990  Microsoft Corporation
Copyright (c) 1993, 1994  Digital Equipment Corporation

Module Name:

    exceptn.c

Abstract:

    This module implements the code necessary to dispatch exceptions to the
    proper mode and invoke the exception dispatcher.

Author:

    David N. Cutler (davec) 3-Apr-1990

Environment:

    Kernel mode only.

Revision History:

    Thomas Van Baak (tvb) 12-May-1992

        Adapted for Alpha AXP.

--*/

#include "ki.h"

BOOLEAN
KiHandleAlignmentFault(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance,
    OUT BOOLEAN *ExceptionForwarded
    );


VOID
KiMachineCheck (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    );


VOID
KeContextFromKframes (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN OUT PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified trap and exception
    frames into the specified context frame according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    ExceptionFrame - Supplies a pointer to an exception frame from which context
        should be copied into the context record.

    ContextFrame - Supplies a pointer to the context frame that receives the
        context copied from the trap and exception frames.

Return Value:

    None.

--*/

{

    //
    // Set control information if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set integer register gp, ra, sp, FIR, and PSR from trap frame.
        //

        ContextFrame->IntGp = TrapFrame->IntGp;
        ContextFrame->IntSp = TrapFrame->IntSp;
        ContextFrame->IntRa = TrapFrame->IntRa;
        ContextFrame->Fir = TrapFrame->Fir;
        ContextFrame->Psr = TrapFrame->Psr;
    }

    //
    // Set integer register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set volatile integer registers v0 and t0 - t7 from trap frame.
        //

        ContextFrame->IntV0 = TrapFrame->IntV0;
        ContextFrame->IntT0 = TrapFrame->IntT0;
        ContextFrame->IntT1 = TrapFrame->IntT1;
        ContextFrame->IntT2 = TrapFrame->IntT2;
        ContextFrame->IntT3 = TrapFrame->IntT3;
        ContextFrame->IntT4 = TrapFrame->IntT4;
        ContextFrame->IntT5 = TrapFrame->IntT5;
        ContextFrame->IntT6 = TrapFrame->IntT6;
        ContextFrame->IntT7 = TrapFrame->IntT7;

        //
        // Set nonvolatile integer registers s0 - s5 from exception frame.
        //

        ContextFrame->IntS0 = ExceptionFrame->IntS0;
        ContextFrame->IntS1 = ExceptionFrame->IntS1;
        ContextFrame->IntS2 = ExceptionFrame->IntS2;
        ContextFrame->IntS3 = ExceptionFrame->IntS3;
        ContextFrame->IntS4 = ExceptionFrame->IntS4;
        ContextFrame->IntS5 = ExceptionFrame->IntS5;

        //
        // Set volatile integer registers a0 - a5, and t8 - t11 from trap
        // frame.
        //

        ContextFrame->IntA0 = TrapFrame->IntA0;
        ContextFrame->IntA1 = TrapFrame->IntA1;
        ContextFrame->IntA2 = TrapFrame->IntA2;
        ContextFrame->IntA3 = TrapFrame->IntA3;
        ContextFrame->IntA4 = TrapFrame->IntA4;
        ContextFrame->IntA5 = TrapFrame->IntA5;

        ContextFrame->IntT8 = TrapFrame->IntT8;
        ContextFrame->IntT9 = TrapFrame->IntT9;
        ContextFrame->IntT10 = TrapFrame->IntT10;
        ContextFrame->IntT11 = TrapFrame->IntT11;

        //
        // Set volatile integer registers fp, t12 and at from trap frame.
        // Set integer register zero.
        //

        ContextFrame->IntFp = TrapFrame->IntFp;
        ContextFrame->IntT12 = TrapFrame->IntT12;
        ContextFrame->IntAt = TrapFrame->IntAt;
        ContextFrame->IntZero = 0;
    }

    //
    // Set floating register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {

        //
        // Set volatile floating registers f0 - f1 from trap frame.
        // Set volatile floating registers f10 - f30 from trap frame.
        // Set floating zero register f31 to 0.
        //

        ContextFrame->FltF0 = TrapFrame->FltF0;
        ContextFrame->FltF1 = TrapFrame->FltF1;
        RtlMoveMemory(&ContextFrame->FltF10, &TrapFrame->FltF10,
                      sizeof(ULONGLONG) * 21);
        ContextFrame->FltF31 = 0;

        //
        // Set nonvolatile floating registers f2 - f9 from exception frame.
        //

        ContextFrame->FltF2 = ExceptionFrame->FltF2;
        ContextFrame->FltF3 = ExceptionFrame->FltF3;
        ContextFrame->FltF4 = ExceptionFrame->FltF4;
        ContextFrame->FltF5 = ExceptionFrame->FltF5;
        ContextFrame->FltF6 = ExceptionFrame->FltF6;
        ContextFrame->FltF7 = ExceptionFrame->FltF7;
        ContextFrame->FltF8 = ExceptionFrame->FltF8;
        ContextFrame->FltF9 = ExceptionFrame->FltF9;

        //
        // Set floating point control register from trap frame.
        // Clear software floating point control register in context frame
        // (if necessary, it can be set to the proper value by the caller).
        //

        ContextFrame->Fpcr = TrapFrame->Fpcr;
        ContextFrame->SoftFpcr = 0;
    }

    return;
}

VOID
KeContextToKframes (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextFrame,
    IN ULONG ContextFlags,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified context frame into
    the specified trap and exception frames according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that receives the volatile
        context from the context record.

    ExceptionFrame - Supplies a pointer to an exception frame that receives
        the nonvolatile context from the context record.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied into the trap and exception frames.

    ContextFlags - Supplies the set of flags that specify which parts of the
        context frame are to be copied into the trap and exception frames.

    PreviousMode - Supplies the processor mode for which the trap and exception
        frames are being built.

Return Value:

    None.

--*/

{

    //
    // Set control information if specified.
    //

    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set integer register gp, sp, ra, FIR, and PSR in trap frame.
        //

        TrapFrame->IntGp = ContextFrame->IntGp;
        TrapFrame->IntSp = ContextFrame->IntSp;
        TrapFrame->IntRa = ContextFrame->IntRa;
        TrapFrame->Fir = ContextFrame->Fir;
        TrapFrame->Psr = SANITIZE_PSR(ContextFrame->Psr, PreviousMode);
    }

    //
    // Set integer register contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set volatile integer registers v0 and t0 - t7 in trap frame.
        //

        TrapFrame->IntV0 = ContextFrame->IntV0;
        TrapFrame->IntT0 = ContextFrame->IntT0;
        TrapFrame->IntT1 = ContextFrame->IntT1;
        TrapFrame->IntT2 = ContextFrame->IntT2;
        TrapFrame->IntT3 = ContextFrame->IntT3;
        TrapFrame->IntT4 = ContextFrame->IntT4;
        TrapFrame->IntT5 = ContextFrame->IntT5;
        TrapFrame->IntT6 = ContextFrame->IntT6;
        TrapFrame->IntT7 = ContextFrame->IntT7;

        //
        // Set nonvolatile integer registers s0 - s5 in exception frame.
        //

        ExceptionFrame->IntS0 = ContextFrame->IntS0;
        ExceptionFrame->IntS1 = ContextFrame->IntS1;
        ExceptionFrame->IntS2 = ContextFrame->IntS2;
        ExceptionFrame->IntS3 = ContextFrame->IntS3;
        ExceptionFrame->IntS4 = ContextFrame->IntS4;
        ExceptionFrame->IntS5 = ContextFrame->IntS5;

        //
        // Set volatile integer registers a0 - a5, and t8 - t11 in trap frame.
        //

        TrapFrame->IntA0 = ContextFrame->IntA0;
        TrapFrame->IntA1 = ContextFrame->IntA1;
        TrapFrame->IntA2 = ContextFrame->IntA2;
        TrapFrame->IntA3 = ContextFrame->IntA3;
        TrapFrame->IntA4 = ContextFrame->IntA4;
        TrapFrame->IntA5 = ContextFrame->IntA5;

        TrapFrame->IntT8 = ContextFrame->IntT8;
        TrapFrame->IntT9 = ContextFrame->IntT9;
        TrapFrame->IntT10 = ContextFrame->IntT10;
        TrapFrame->IntT11 = ContextFrame->IntT11;

        //
        // Set volatile integer registers fp, t12 and at in trap frame.
        //

        TrapFrame->IntFp = ContextFrame->IntFp;
        TrapFrame->IntT12 = ContextFrame->IntT12;
        TrapFrame->IntAt = ContextFrame->IntAt;
    }

    //
    // Set floating register contents if specified.
    //

    if ((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {

        //
        // Set volatile floating registers f0 - f1 in trap frame.
        // Set volatile floating registers f10 - f30 in trap frame.
        //

        TrapFrame->FltF0 = ContextFrame->FltF0;
        TrapFrame->FltF1 = ContextFrame->FltF1;
        RtlMoveMemory(&TrapFrame->FltF10, &ContextFrame->FltF10,
                      sizeof(ULONGLONG) * 21);

        //
        // Set nonvolatile floating registers f2 - f9 in exception frame.
        //

        ExceptionFrame->FltF2 = ContextFrame->FltF2;
        ExceptionFrame->FltF3 = ContextFrame->FltF3;
        ExceptionFrame->FltF4 = ContextFrame->FltF4;
        ExceptionFrame->FltF5 = ContextFrame->FltF5;
        ExceptionFrame->FltF6 = ContextFrame->FltF6;
        ExceptionFrame->FltF7 = ContextFrame->FltF7;
        ExceptionFrame->FltF8 = ContextFrame->FltF8;
        ExceptionFrame->FltF9 = ContextFrame->FltF9;

        //
        // Set floating point control register in trap frame.
        //

        TrapFrame->Fpcr = ContextFrame->Fpcr;
    }

    return;
}

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to dispatch an exception to the proper mode and
    to cause the exception dispatcher to be called.

    If the exception is a data misalignment, the previous mode is user, this
    is the first chance for handling the exception, and the current thread
    has enabled automatic alignment fixup, then an attempt is made to emulate
    the unaligned reference. Data misalignment exceptions are never emulated
    for kernel mode.

    If the exception is a floating not implemented exception, then an attempt
    is made to emulate the floating operation. If the exception is an
    arithmetic exception, then an attempt is made to convert the imprecise
    exception into a precise exception, and then emulate the floating
    operation in order to obtain the proper IEEE results and exceptions.
    Floating exceptions are never emulated for kernel mode.

    If the exception is neither a data misalignment nor a floating point
    exception and the previous mode is kernel, then the exception
    dispatcher is called directly to process the exception. Otherwise the
    exception record, exception frame, and trap frame contents are copied
    to the user mode stack. The contents of the exception frame and trap
    are then modified such that when control is returned, execution will
    commence in user mode in a routine which will call the exception
    dispatcher.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    PreviousMode - Supplies the previous processor mode.

    FirstChance - Supplies a boolean variable that specifies whether this
        is the first (TRUE) or second (FALSE) time that this exception has
        been processed.

Return Value:

    None.

--*/

{

    CONTEXT ContextFrame;
    EXCEPTION_RECORD ExceptionRecord1;
    PEXC_SUM ExceptionSummary;
    LONG Length;
    ULONG SoftFpcr;
    ULONGLONG UserStack1;
    ULONGLONG UserStack2;
    BOOLEAN AlignmentFaultHandled;
    BOOLEAN ExceptionForwarded;

    //
    // If the exception is an illegal instruction exception, then check for
    // a byte/word instruction that should be emulated.
    //
    // N.B. The exception code STATUS_ILLEGAL_INSTRUCTION may be converted
    //      into STATUS_DATATYPE_MISALIGNMENT in the case of unaligned word
    //      access.
    //

    if (ExceptionRecord->ExceptionCode == STATUS_ILLEGAL_INSTRUCTION) {
        if (KiEmulateByteWord(ExceptionRecord,
                              ExceptionFrame,
                              TrapFrame) != FALSE) {
            KeGetCurrentPrcb()->KeByteWordEmulationCount += 1;
            goto Handled2;
        }
    }

    ExceptionForwarded = FALSE;
    if (ExceptionRecord->ExceptionCode == STATUS_DATATYPE_MISALIGNMENT) {

        AlignmentFaultHandled = KiHandleAlignmentFault( ExceptionRecord,
                                                        ExceptionFrame,
                                                        TrapFrame,
                                                        PreviousMode,
                                                        FirstChance,
                                                        &ExceptionForwarded );
        if (AlignmentFaultHandled != FALSE) {
            goto Handled2;
        }
    }

    //
    // If the exception is a data bus error then a machine check has
    // been trapped by the PALcode. The error will be forwarded to the
    // HAL eventually for logging or handling. If the handler returns
    // it is assumed that the HAL successfully handled the error and
    // execution may resume.
    //
    // N.B. A special exception code is used to signal a data bus error.
    //      This code is equivalent to the bug check code merged with a
    //      reserved facility code and the reserved bit set.
    //

    if (ExceptionRecord->ExceptionCode == (DATA_BUS_ERROR | 0xdfff0000)) {
        KiMachineCheck(ExceptionRecord, ExceptionFrame, TrapFrame);
        goto Handled2;
    }

    //
    // Initialize the copy of the software FPCR. The proper value is set
    // if a floating emulation operation is performed. Case on arithmetic
    // exception codes that require special handling by the kernel.
    //

    SoftFpcr = 0;
    switch (ExceptionRecord->ExceptionCode) {

        //
        // If the exception is a gentrap, then attempt to translate the
        // Alpha specific gentrap value to a status code value. This
        // exception is a precise trap.
        //
        // N.B. STATUS_ALPHA_GENTRAP is a pseudo status code generated by
        //      PALcode when a callpal gentrap is executed. The status is
        //      visible in user mode only when the gentrap code value is
        //      unrecognized.
        //

    case STATUS_ALPHA_GENTRAP :
        switch (ExceptionRecord->ExceptionInformation[0]) {
        case GENTRAP_INTEGER_OVERFLOW :
            ExceptionRecord->ExceptionCode = STATUS_INTEGER_OVERFLOW;
            break;

        case GENTRAP_INTEGER_DIVIDE_BY_ZERO :
            ExceptionRecord->ExceptionCode = STATUS_INTEGER_DIVIDE_BY_ZERO;
            break;

        case GENTRAP_FLOATING_OVERFLOW :
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_OVERFLOW;
            break;

        case GENTRAP_FLOATING_DIVIDE_BY_ZERO :
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;
            break;

        case GENTRAP_FLOATING_UNDERFLOW :
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_UNDERFLOW;
            break;

        case GENTRAP_FLOATING_INVALID_OPERAND :
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;
            break;

        case GENTRAP_FLOATING_INEXACT_RESULT :
            ExceptionRecord->ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;
            break;
        }
        break;

        //
        // If the exception is an unimplemented floating operation, then
        // PALcode has detected a subsetted floating point operation. These
        // include attempts to use round to plus or minus infinity rounding
        // modes on EV4. This exception is a fault.
        //
        // If the previous mode was user, an attempt is made to emulate the
        // operation. If the emulation is successful, the continuation
        // address is incremented to the next instruction.
        //
        // N.B. STATUS_ALPHA_FLOATING_NOT_IMPLEMENTED is a pseudo status code
        //      generated by PALcode. The status is never visible outside of
        //      this handler because the floating emulation routine converts
        //      the status code to the proper floating status value.
        //

    case STATUS_ALPHA_FLOATING_NOT_IMPLEMENTED :
        if (PreviousMode != KernelMode) {
            if (KiFloatingException(ExceptionRecord,
                                    ExceptionFrame,
                                    TrapFrame,
                                    FALSE,
                                    &SoftFpcr) != FALSE) {
                TrapFrame->Fir += 4;
                goto Handled2;
            }

        } else {
            ExceptionRecord->ExceptionCode = STATUS_ILLEGAL_INSTRUCTION;
        }

        break;

        //
        // If the exception is an arithmetic exception, then one or more
        // integer overflow or floating point traps has occurred. This
        // exception is an imprecise (asynchronous) trap. Attempt to locate 
        // the original trapping instruction and emulate the instruction.
        //
        // N.B. STATUS_ALPHA_ARITHMETIC_EXCEPTION is a pseudo status code
        //      generated by PALcode. The status is never visible outside of
        //      this handler because the floating emulation routine converts
        //      the status code to the proper floating status value.
        //

    case STATUS_ALPHA_ARITHMETIC_EXCEPTION :
        if (KiFloatingException(ExceptionRecord,
                                ExceptionFrame,
                                TrapFrame,
                                TRUE,
                                &SoftFpcr) != FALSE) {
            goto Handled2;
        }
        break;
    }

    //
    // Move machine state from trap and exception frames to a context frame,
    // and increment the number of exceptions dispatched.
    //
    // Explicitly set the value of the software FPCR in the context frame
    // (because it is not a hardware register and thus not present in the
    // trap or exception frames).
    //

    ContextFrame.ContextFlags = CONTEXT_FULL;
    KeContextFromKframes(TrapFrame, ExceptionFrame, &ContextFrame);
    KeGetCurrentPrcb()->KeExceptionDispatchCount += 1;
    ContextFrame.SoftFpcr = (ULONGLONG)SoftFpcr;

    //
    // Select the method of handling the exception based on the previous mode.
    //

    if (PreviousMode == KernelMode) {

        //
        // If the kernel debugger is active, the exception is a breakpoint,
        // the breakpoint is handled by the kernel debugger, and this is the
        // first chance, then give the kernel debugger a chance to handle
        // the exception.
        //

        if ((FirstChance != FALSE) && (KiDebugRoutine != NULL) &&
           (ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
           (KdIsThisAKdTrap(ExceptionRecord,
                            &ContextFrame,
                            KernelMode) != FALSE) &&

           (((KiDebugRoutine) (TrapFrame,
                               ExceptionFrame,
                               ExceptionRecord,
                               &ContextFrame,
                               KernelMode,
                               FALSE)) != FALSE)) {

            goto Handled1;
        }


        //
        // Previous mode was kernel.
        //
        // If this is the first chance, then attempt to dispatch the exception
        // to a frame based handler. If the exception is handled, then continue
        // execution.
        //
        // If this is the second chance or the exception is not handled,
        // then if the kernel debugger is active, then give the kernel
        // debugger a second chance to handle the exception. If the kernel
        // debugger handles the exception, then continue execution. Otherwise
        // bug check.
        //

        if (FirstChance != FALSE) {

            //
            // This is the first chance to handle the exception.
            //

            if (RtlDispatchException(ExceptionRecord, &ContextFrame) != FALSE) {
                goto Handled1;
            }
        }

        //
        // This is the second chance to handle the exception.
        //

        if ((KiDebugRoutine != NULL) &&
           (((KiDebugRoutine) (TrapFrame,
                               ExceptionFrame,
                               ExceptionRecord,
                               &ContextFrame,
                               PreviousMode,
                                   TRUE)) != FALSE)) {

            goto Handled1;
        }

        KeBugCheckEx(KMODE_EXCEPTION_NOT_HANDLED,
                     ExceptionRecord->ExceptionCode,
                     (ULONG_PTR)ExceptionRecord->ExceptionAddress,
                     ExceptionRecord->ExceptionInformation[0],
                     ExceptionRecord->ExceptionInformation[1]);

    } else {

        //
        // If the kernel debugger is active, the exception is a breakpoint,
        // the breakpoint is handled by the kernel debugger, and this is the
        // first chance, then give the kernel debugger a chance to handle
        // the exception.
        //

        if ((FirstChance != FALSE) &&
            (KiDebugRoutine != NULL) &&
            (ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
            (KdIsThisAKdTrap(ExceptionRecord,
                             &ContextFrame,
                             UserMode) != FALSE) &&

            ((PsGetCurrentProcess()->DebugPort == NULL) ||
             ((PsGetCurrentProcess()->DebugPort != NULL) &&
              (ExceptionRecord->ExceptionInformation[0] !=
                                            DEBUG_STOP_BREAKPOINT)))) {

              if (((KiDebugRoutine) (TrapFrame,
                                     ExceptionFrame,
                                     ExceptionRecord,
                                     &ContextFrame,
                                     UserMode,
                                     FALSE)) != FALSE) {

                     goto Handled1;
              }
        }

        //
        // Previous mode was user.
        //
        // If this is the first chance and the current process has a debugger
        // port, then send a message to the debugger port and wait for a reply.
        // If the debugger handles the exception, then continue execution. Otherwise
        // transfer the exception information to the user stack, transition to
        // user mode, and attempt to dispatch the exception to a frame based
        // handler. If a frame based handler handles the exception, then continue
        // execution. Otherwise, execute the raise exception system service
        // which will call this routine a second time to process the exception.
        //
        // If this is the second chance and the current process has a debugger
        // port, then send a message to the debugger port and wait for a reply.
        // If the debugger handles the exception, then continue execution. Otherwise
        // if the current process has a subsystem port, then send a message to
        // the subsystem port and wait for a reply. If the subsystem handles the
        // exception, then continue execution. Otherwise terminate the thread.
        //

        if (FirstChance != FALSE) {

            //
            // This is the first chance to handle the exception.
            //

            if (ExceptionForwarded == FALSE &&
                DbgkForwardException(ExceptionRecord, TRUE, FALSE)) {
                goto Handled2;
            }

            //
            // Transfer exception information to the user stack, transition
            // to user mode, and attempt to dispatch the exception to a frame
            // based handler.
            //

        repeat:
            try {

                //
                // Compute length of exception record and new aligned stack
                // address.
                //

                Length = (sizeof(EXCEPTION_RECORD) + 15) & (~15);
                UserStack1 = (ContextFrame.IntSp & ~((ULONG_PTR)15)) - Length;

                //
                // Probe user stack area for writability and then transfer the
                // exception record to the user stack area.
                //

                ProbeForWrite((PCHAR)UserStack1, Length, sizeof(QUAD));
                RtlMoveMemory((PVOID)UserStack1, ExceptionRecord, Length);

                //
                // Compute length of context record and new aligned user stack
                // pointer.
                //

                Length = (sizeof(CONTEXT) + 15) & (~15);
                UserStack2 = UserStack1 - Length;

                //
                // Probe user stack area for writability and then transfer the
                // context record to the user stack.
                //

                ProbeForWrite((PCHAR)UserStack2, Length, sizeof(QUAD));
                RtlMoveMemory((PVOID)UserStack2, &ContextFrame, sizeof(CONTEXT));

                //
                // Set address of exception record, context record, and the
                // and the new stack pointer in the current trap frame.
                //

                TrapFrame->IntSp = UserStack2;
                TrapFrame->IntFp = UserStack2;
                ExceptionFrame->IntS0 = UserStack1;
                ExceptionFrame->IntS1 = UserStack2;

                //
                // Set the address of the exception routine that will call the
                // exception dispatcher and then return to the trap handler.
                // The trap handler will restore the exception and trap frame
                // context and continue execution in the routine that will
                // call the exception dispatcher.
                //

                TrapFrame->Fir = (ULONGLONG)(LONG_PTR)KeUserExceptionDispatcher;
                return;

            //
            // If an exception occurs, then copy the new exception information
            // to an exception record and handle the exception.
            //

            } except (KiCopyInformation(&ExceptionRecord1,
                               (GetExceptionInformation())->ExceptionRecord)) {

                //
                // If the exception is a stack overflow, then attempt
                // to raise the stack overflow exception. Otherwise,
                // the user's stack is not accessible, or is misaligned,
                // and second chance processing is performed.
                //

                if (ExceptionRecord1.ExceptionCode == STATUS_STACK_OVERFLOW) {
                    ExceptionRecord1.ExceptionAddress = ExceptionRecord->ExceptionAddress;
                    RtlMoveMemory((PVOID)ExceptionRecord,
                                  &ExceptionRecord1, sizeof(EXCEPTION_RECORD));
                    goto repeat;
                }
            }
        }

        //
        // This is the second chance to handle the exception.
        //

        if (DbgkForwardException(ExceptionRecord, TRUE, TRUE)) {
            goto Handled2;

        } else if (DbgkForwardException(ExceptionRecord, FALSE, TRUE)) {
            goto Handled2;

        } else {
            ZwTerminateProcess(NtCurrentProcess(), ExceptionRecord->ExceptionCode);
            KeBugCheckEx(KMODE_EXCEPTION_NOT_HANDLED,
                         ExceptionRecord->ExceptionCode,
                         (ULONG_PTR)ExceptionRecord->ExceptionAddress,
                         ExceptionRecord->ExceptionInformation[0],
                         ExceptionRecord->ExceptionInformation[1]);

        }
    }

    //
    // Move machine state from context frame to trap and exception frames and
    // then return to continue execution with the restored state.
    //

Handled1:
    KeContextToKframes(TrapFrame, ExceptionFrame, &ContextFrame,
                       ContextFrame.ContextFlags, PreviousMode);

    //
    // Exception was handled by the debugger or the associated subsystem
    // and state was modified, if necessary, using the get state and set
    // state capabilities. Therefore the context frame does not need to
    // be transferred to the trap and exception frames.
    //

Handled2:
    return;
}

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    )

/*++

Routine Description:

    This function is called from an exception filter to copy the exception
    information from one exception record to another when an exception occurs.

Arguments:

    ExceptionRecord1 - Supplies a pointer to the destination exception record.

    ExceptionRecord2 - Supplies a pointer to the source exception record.

Return Value:

    A value of EXCEPTION_EXECUTE_HANDLER is returned as the function value.

--*/

{

    //
    // Copy one exception record to another and return value that causes
    // an exception handler to be executed.
    //

    RtlMoveMemory((PVOID)ExceptionRecord1,
                  (PVOID)ExceptionRecord2,
                  sizeof(EXCEPTION_RECORD));

    return EXCEPTION_EXECUTE_HANDLER;
}


NTSTATUS
KeRaiseUserException(
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This function causes an exception to be raised in the calling thread's user-mode
    context. It does this by editing the trap frame the kernel was entered with to
    point to trampoline code that raises the requested exception.

Arguments:

    ExceptionCode - Supplies the status value to be used as the exception
        code for the exception that is to be raised.

Return Value:

    The status value that should be returned by the caller.

--*/

{

    PKTRAP_FRAME TrapFrame;

    ASSERT(KeGetPreviousMode() == UserMode);

    TrapFrame = KeGetCurrentThread()->TrapFrame;

    TrapFrame->Fir = (ULONGLONG)(LONG_PTR)KeRaiseUserExceptionDispatcher;
    return(ExceptionCode);
}


#if 0

LOGICAL
BdReportExceptionStateChange (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT ContextRecord
    );

LOGICAL
BdReportLoadSymbolsStateChange (
    IN PSTRING PathName,
    IN PKD_SYMBOLS_INFO SymbolInfo,
    IN LOGICAL UnloadSymbols,
    IN OUT PCONTEXT ContextRecord
    );

LOGICAL
BdPrintString (
    IN PSTRING Output
    );

LOGICAL
BdPromptString (
    IN PSTRING Output,
    IN OUT PSTRING Input
    );

LOGICAL
BdTrap (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This routine is called whenever a exception is dispatched and the kernel
    debugger is active.

Arguments:

    FirmwareFrame - Supplies a pointer to a firmware frame that describes the
        trap.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    CONTEXT ContextFrame;
    LOGICAL Completion;
    PCONTEXT ContextRecord;
    STRING Input;
    ULONGLONG OldFir;
    STRING Output;
    PKD_SYMBOLS_INFO SymbolInfo;
    LOGICAL UnloadSymbols;

    //
    // Set address of context record and set context flags.
    //

    ContextRecord = &ContextFrame;
    ContextRecord->ContextFlags = CONTEXT_FULL;

    //
    // Print, prompt, load symbols, and unload symbols are all special cases
    // of breakpoint.
    //

//    BlPrint("bd: debug code entered with type %lx, p1 %lx\r\n",
//            (ULONG)FirmwareFrame->Type,
//            (ULONG)FirmwareFrame->Param1);

    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
        (ExceptionRecord->ExceptionInformation[0] >= DEBUG_PRINT_BREAKPOINT)) {

        //
        // Switch on the breakpoint code.
        //

        UnloadSymbols = FALSE;
        switch (ExceptionRecord->ExceptionInformation[0]) {

            //
            // Print:
            //
            // Arguments:
            //
            //   a0 - Supplies a pointer to an output string buffer.
            //   a1 - Supplies the length of the output string buffer.
            //

        case DEBUG_PRINT_BREAKPOINT:
//            BlPrint("bd/debug: print\r\n");
            Output.Buffer = (PCHAR)TrapFrame->IntA0;
            Output.Length = (USHORT)TrapFrame->IntA1;
            if (BdPrintString(&Output)) {
                TrapFrame->IntV0 = STATUS_BREAKPOINT;

            } else {
                TrapFrame->IntV0 = STATUS_SUCCESS;
            }

            TrapFrame->Fir += 4;
//            BlPrint("bd/debug: exit - print\r\n");
            KeSweepCurrentIcache();
            return TRUE;

            //
            // Stop in debugger:
            //
            // As this is not a normal breakpoint we must increment the
            // context past the breakpoint instruction.
            //

        case BREAKIN_BREAKPOINT:
            TrapFrame->Fir += 4;
            break;

            //
            // Prompt:
            //
            //   a0 - Supplies a pointer to an output string buffer.
            //   a1 - Supplies the length of the output string buffer..
            //   a2 - supplies a pointer to an input string buffer.
            //   a3 - Supplies the length of the input string bufffer.
            //

        case DEBUG_PROMPT_BREAKPOINT:
//            BlPrint("bd/debug: prompt\r\n");
            Output.Buffer = (PCHAR)TrapFrame->IntA0;
            Output.Length = (USHORT)TrapFrame->IntA1;
            Input.Buffer = (PCHAR)TrapFrame->IntA2;
            Input.MaximumLength = (USHORT)TrapFrame->IntA3;

            //
            // Prompt and keep prompting until no breakin seen.
            //

            do {
            } while(BdPromptString(&Output, &Input) != FALSE);

            TrapFrame->IntV0 = Input.Length;
            TrapFrame->Fir += 4;
//            BlPrint("bd/debug: exit - prompt\r\n");
            KeSweepCurrentIcache();
            return TRUE;

            //
            // Unload Symbols:
            //
            // Arguments:
            //
            //    a0 - Supplies a pointer to the image path string descriptor.
            //    a1 - Supplies a pointer to he symbol information.
            //

        case DEBUG_UNLOAD_SYMBOLS_BREAKPOINT:
//            BlPrint("bd/debug: unload\r\n");
            UnloadSymbols = TRUE;

            //
            // Fall through to load symbol case.
            //

        case DEBUG_LOAD_SYMBOLS_BREAKPOINT:
//            BlPrint("bd/debug: load\r\n");
            KeContextFromKframes(TrapFrame, ExceptionFrame, ContextRecord);
            OldFir = ContextRecord->Fir;
            SymbolInfo = (PKD_SYMBOLS_INFO)ContextRecord->IntA1;
            BdReportLoadSymbolsStateChange((PSTRING)ContextRecord->IntA0,
                                           SymbolInfo,
                                           UnloadSymbols,
                                           ContextRecord);


            //
            // If the kernel debugger did not update the FIR, then increment
            // past the breakpoint instruction.
            //

            if (ContextRecord->Fir == OldFir) {
                ContextRecord->Fir += 4;
            }

            KeContextToKframes(TrapFrame,
                               ExceptionFrame,
                               ContextRecord,
                               ContextRecord->ContextFlags,
                               PreviousMode);

//            BlPrint("bd/debug: exit - load/unload\r\n");
            KeSweepCurrentIcache();
            return TRUE;

            //
            // Unknown internal command.
            //

        default:
            break;
        }
    }

    //
    // Report state change to kernel debugger on host machine.
    //

//    BlPrint("bd/debug: report\r\n");
    KeContextFromKframes(TrapFrame, ExceptionFrame, ContextRecord);
    Completion = BdReportExceptionStateChange(ExceptionRecord,
                                              ContextRecord);

    KeContextToKframes(TrapFrame,
                       ExceptionFrame,
                       ContextRecord,
                       ContextRecord->ContextFlags,
                       PreviousMode);

//    BlPrint("bd/debug: exit - report\r\n");
    KeSweepCurrentIcache();
    return TRUE;
}

LOGICAL
BdStub (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This routine provides a kernel debugger stub routine that catchs debug
    prints in checked systems when the kernel debugger is not active.

Arguments:

    FirmwareFrame - Supplies a pointer to a firmware frame that describes
        the trap.

Return Value:

    A value of TRUE is returned if the exception is handled. Otherwise a
    value of FALSE is returned.

--*/

{

    return FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\flush.c ===
/*++

Copyright (c) 1990  Microsoft Corporation
Copyright (c) 1993  Digital Equipment Corporation

Module Name:

    flush.c

Abstract:

    This module implements Alpha AXP machine dependent kernel functions to flush
    the data and instruction caches and to flush I/O buffers.

Author:

    David N. Cutler (davec) 26-Apr-1990
    Joe Notarangelo  29-Nov-1993

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"


//
// Define forward referenced prototypes.
//

VOID
KiSweepDcacheTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Count,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiSweepIcacheTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Count,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiFlushIoBuffersTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Mdl,
    IN PVOID ReadOperation,
    IN PVOID DmaOperation
    );

VOID
KiSynchronizeMemoryAccessTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

ULONG KiSynchronizeMemoryCallCount = 0;


VOID
KeSweepDcache (
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes the data cache on all processors that are currently
    running threads which are children of the current process or flushes the
    data cache on all processors in the host configuration.

Arguments:

    AllProcessors - Supplies a boolean value that determines which data
        caches are flushed.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    KAFFINITY TargetProcessors;

    ASSERT(KeGetCurrentIrql() <= KiSynchIrql);

    //
    // Raise IRQL to synchronization level to prevent a context switch.
    //

#if !defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

    //
    // Compute the set of target processors and send the sweep parameters
    // to the target processors, if any, for execution.
    //

    TargetProcessors = KeActiveProcessors & PCR->NotMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiSweepDcacheTarget,
                        NULL,
                        NULL,
                        NULL);
    }

    IPI_INSTRUMENT_COUNT(KeGetCurrentPrcb()->Number, SweepDcache);

#endif

    //
    // Sweep the data cache on the current processor.
    //

    HalSweepDcache();

    //
    // Wait until all target processors have finished sweeping the their
    // data cache.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Lower IRQL to its previous level and return.
    //

    KeLowerIrql(OldIrql);

#endif

    return;
}

VOID
KiSweepDcacheTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for sweeping the data cache on target
    processors.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed

    Parameter1 - Parameter3 - not used

Return Value:

    None.

--*/

{

    //
    // Sweep the data cache on the current processor and clear the sweep
    // data cache packet address to signal the source to continue.
    //

#if !defined(NT_UP)

    HalSweepDcache();
    KiIpiSignalPacketDone(SignalDone);
    IPI_INSTRUMENT_COUNT(KeGetCurrentPrcb()->Number, SweepDcache);

#endif

    return;
}

VOID
KeSweepIcache (
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes the instruction cache on all processors that are
    currently running threads which are children of the current process or
    flushes the instruction cache on all processors in the host configuration.

Arguments:

    AllProcessors - Supplies a boolean value that determines which instruction
        caches are flushed.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    KAFFINITY TargetProcessors;

    ASSERT(KeGetCurrentIrql() <= KiSynchIrql);

    //
    // Raise IRQL to synchronization level to prevent a context switch.
    //

#if !defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

    //
    // Compute the set of target processors and send the sweep parameters
    // to the target processors, if any, for execution.
    //

    TargetProcessors = KeActiveProcessors & PCR->NotMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiSweepIcacheTarget,
                        NULL,
                        NULL,
                        NULL);
    }

    IPI_INSTRUMENT_COUNT(KeGetCurrentPrcb()->Number, SweepIcache);

#endif

    //
    // Sweep the instruction cache on the current processor.
    //

    KiImb();

    //
    // Wait until all target processors have finished sweeping the their
    // instruction cache.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Lower IRQL to its previous level and return.
    //

    KeLowerIrql(OldIrql);

#endif

    return;
}

VOID
KiSweepIcacheTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for sweeping the instruction cache on
    target processors.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed

    Parameter1 - Parameter3 - not used


Return Value:

    None.

--*/

{

    //
    // Sweep the instruction cache on the current processor and clear
    // the sweep instruction cache packet address to signal the source
    // to continue.
    //

#if !defined(NT_UP)

    KiImb();
    KiIpiSignalPacketDone(SignalDone);
    IPI_INSTRUMENT_COUNT(KeGetCurrentPrcb()->Number, SweepIcache);

#endif

    return;
}

VOID
KeSweepIcacheRange (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG_PTR Length
    )

/*++

Routine Description:

    This function flushes the an range of virtual addresses from the primary
    instruction cache on all processors that are currently running threads
    which are children of the current process or flushes the range of virtual
    addresses from the primary instruction cache on all processors in the host
    configuration.

Arguments:

    AllProcessors - Supplies a boolean value that determines which instruction
        caches are flushed.

    BaseAddress - Supplies a pointer to the base of the range that is flushed.

    Length - Supplies the length of the range that is flushed if the base
        address is specified.

Return Value:

    None.

--*/

{

    KeSweepIcache(AllProcessors);
    return;
}

VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    )

/*++

Routine Description:

    This function flushes the I/O buffer specified by the memory descriptor
    list from the data cache on all processors.

    Alpha requires that caches be coherent with respect to I/O. All that
    this routine needs to do is execute a memory barrier on the current
    processor. However, in order to maintain i-stream coherency, all
    processors must execute the IMB PAL call in the case of page reads.
    Thus, all processors are IPI'd to perform the IMB for any flush
    that is a DmaOperation, a ReadOperation, and an MDL_IO_PAGE_READ.


Arguments:

    Mdl - Supplies a pointer to a memory descriptor list that describes the
        I/O buffer location.

    ReadOperation - Supplies a boolean value that determines whether the I/O
        operation is a read into memory.

    DmaOperation - Supplies a boolean value that determines whether the I/O
        operation is a DMA operation.

Return Value:

    None.

--*/

{
    KIRQL OldIrql;
    KAFFINITY TargetProcessors;

    ASSERT(KeGetCurrentIrql() <= KiSynchIrql);

    KiMb();

    //
    // If the operation is a DMA operation, then check if the flush
    // can be avoided because the host system supports the right set
    // of cache coherency attributes. Otherwise, the flush can also
    // be avoided if the operation is a programmed I/O and not a page
    // read.
    //

    if (DmaOperation != FALSE) {
        if (ReadOperation != FALSE) {
            if ((KiDmaIoCoherency & DMA_READ_ICACHE_INVALIDATE) != 0) {

                ASSERT((KiDmaIoCoherency & DMA_READ_DCACHE_INVALIDATE) != 0);

                return;

            } else if (((Mdl->MdlFlags & MDL_IO_PAGE_READ) == 0) &&
                ((KiDmaIoCoherency & DMA_READ_DCACHE_INVALIDATE) != 0)) {
                return;
            }

        } else if ((KiDmaIoCoherency & DMA_WRITE_DCACHE_SNOOP) != 0) {
            return;
        }

    } else if ((Mdl->MdlFlags & MDL_IO_PAGE_READ) == 0) {
        return;
    }

    //
    // Either the operation is a DMA operation and the right coherency
    // attributes are not supported by the host system, or the operation
    // is programmed I/O and a page read.
    //
    // Raise IRQL to synchronization level to prevent a context switch.
    //

    OldIrql = KeRaiseIrqlToSynchLevel();

    //
    // Compute the set of target processors, and send the flush I/O
    // parameters to the target processors, if any, for execution.
    //

#if !defined(NT_UP)

    TargetProcessors = KeActiveProcessors & PCR->NotMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushIoBuffersTarget,
                        (PVOID)Mdl,
                        ULongToPtr((ULONG)ReadOperation),
                        ULongToPtr((ULONG)DmaOperation));
    }

#endif

    //
    // Flush I/O buffer on current processor.
    //

    HalFlushIoBuffers(Mdl, ReadOperation, DmaOperation);

    //
    // Wait until all target processors have finished flushing the
    // specified I/O buffer.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    //
    // Lower IRQL to its previous level and return.
    //

    KeLowerIrql(OldIrql);

    return;
}

#if !defined(NT_UP)

VOID
KiFlushIoBuffersTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Mdl,
    IN PVOID ReadOperation,
    IN PVOID DmaOperation
    )

/*++

Routine Description:

    This is the target function for flushing an I/O buffer on target
    processors.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Mdl - Supplies a pointer to a memory descriptor list that describes the
        I/O buffer location.

    ReadOperation - Supplies a boolean value that determines whether the I/O
        operation is a read into memory.

    DmaOperation - Supplies a boolean value that determines whether the I/O
        operation is a DMA operation.

Return Value:

    None.

--*/

{

    //
    // Flush the specified I/O buffer on the current processor.
    //

    HalFlushIoBuffers((PMDL)Mdl,
                      (BOOLEAN)((ULONG_PTR)ReadOperation),
                      (BOOLEAN)((ULONG_PTR)DmaOperation));

    KiIpiSignalPacketDone(SignalDone);
    IPI_INSTRUMENT_COUNT(KeGetCurrentPrcb()->Number, FlushIoBuffers);

    return;
}

#endif

VOID
KeSynchronizeMemoryAccess (
    VOID
    )

/*++

Routine Description:

    This function synchronizes memory access across all processors in the
    host configurarion.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    KAFFINITY TargetProcessors;

    ASSERT(KeGetCurrentIrql() <= KiSynchIrql);

    KiSynchronizeMemoryCallCount += 1;

    //
    // Raise IRQL to synchronization level to prevent a context switch.
    //

#if !defined(NT_UP)

    OldIrql = KeRaiseIrqlToSynchLevel();

    //
    // Compute the set of target processors and send the synchronize message
    // to the target processors, if any, for execution.
    //

    TargetProcessors = KeActiveProcessors & PCR->NotMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiSynchronizeMemoryAccessTarget,
                        NULL,
                        NULL,
                        NULL);
    }

    //
    // On an MP system an implicit memory barrier is executed during the
    // end of the IPI message. On a UP system, a memory barrier must be
    // executed.
    //

#else

    __MB();

#endif

    //
    // Wait until all target processors have finished sweeping the their
    // data cache.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Lower IRQL to its previous level and return.
    //

    KeLowerIrql(OldIrql);

#endif

    return;
}

#if !defined(NT_UP)


VOID
KiSynchronizeMemoryAccessTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This function performs no operation, but an implicit memory barrier
    is executed when the IPI message is received.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed

    Parameter1 - Parameter3 - not used

Return Value:

    None.

--*/

{

    KiIpiSignalPacketDone(SignalDone);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\initkr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    initkr.c

Abstract:

    This module contains the code to initialize the kernel data structures
    and to initialize the idle thread, its process, and the processor control
    block.

Author:

    David N. Cutler (davec) 11-Apr-1990

Environment:

    Kernel mode only.

Revision History:

    Joe Notarangelo  21-April-1992
        very minor changes for ALPHA
             - system time to 64bit integer
             - some data moved out of pcr
--*/

#include "ki.h"

//
// Define forward referenced prototypes.
//

ULONG
KiGetFeatureBits (
    VOID
    );

__inline
ULONG
amask(
    IN ULONG Feature
    )

{
    return(__asm("amask %0, v0",Feature));
}
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, KiInitializeKernel)
#endif

VOID
KiInitializeKernel (
    IN PKPROCESS Process,
    IN PKTHREAD Thread,
    IN PVOID IdleStack,
    IN PKPRCB Prcb,
    IN CCHAR Number,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function gains control after the system has been bootstrapped and
    before the system has been initialized. Its function is to initialize
    the kernel data structures, initialize the idle thread and process objects,
    initialize the processor control block, call the executive initialization
    routine, and then return to the system startup routine. This routine is
    also called to initialize the processor specific structures when a new
    processor is brought on line.

Arguments:

    Process - Supplies a pointer to a control object of type process for
        the specified processor.

    Thread - Supplies a pointer to a dispatcher object of type thread for
        the specified processor.

    IdleStack - Supplies a pointer the base of the real kernel stack for
        idle thread on the specified processor.

    Prcb - Supplies a pointer to a processor control block for the specified
        processor.

    Number - Supplies the number of the processor that is being
        initialized.

    LoaderBlock - Supplies a pointer to the loader parameter block.

Return Value:

    None.

--*/

{

    UCHAR DataByte;
    ULONG DataLong;
    LONG Index;
    KIRQL OldIrql;
    PKPCR Pcr = PCR;
    struct _RESTART_BLOCK *RestartBlock;

    //
    // Save the address of the loader parameter block.
    //

    KeLoaderBlock = LoaderBlock;

    //
    // Set the appropriate member in the active processors set.
    //

    SetMember(Number, KeActiveProcessors);

    //
    // Set the number of processors based on the maximum of the current
    // number of processors and the current processor number.
    //

    if ((Number + 1) > KeNumberProcessors) {
        KeNumberProcessors = Number + 1;
    }

    //
    // Set the maximum address space number to the minimum of all maximum
    // address space numbers passed via the loader block.
    //

    if (Number == 0) {
        KiMaximumAsn = LoaderBlock->u.Alpha.MaximumAddressSpaceNumber;

    } else if (KiMaximumAsn > LoaderBlock->u.Alpha.MaximumAddressSpaceNumber) {
        KiMaximumAsn = LoaderBlock->u.Alpha.MaximumAddressSpaceNumber;
    }

    //
    // Initialize the passive release, APC, and DPC interrupt vectors.
    //

    Pcr->InterruptRoutine[0] = KiPassiveRelease;
    Pcr->InterruptRoutine[APC_LEVEL] = KiApcInterrupt;
    Pcr->InterruptRoutine[DISPATCH_LEVEL] = KiDispatchInterrupt;
    Pcr->ReservedVectors =
        (1 << PASSIVE_LEVEL) | (1 << APC_LEVEL) | (1 << DISPATCH_LEVEL);

    //
    // Initialize the processor id fields in the PCR.
    //

    Pcr->Number = Number;
    Pcr->SetMember = 1 << Number;
    Pcr->NotMember = ~Pcr->SetMember;

    //
    // Initialize the processor block.
    //

    Prcb->MinorVersion = PRCB_MINOR_VERSION;
    Prcb->MajorVersion = PRCB_MAJOR_VERSION;
    Prcb->BuildType = 0;

#if DBG

    Prcb->BuildType |= PRCB_BUILD_DEBUG;

#endif

#ifdef NT_UP

    Prcb->BuildType |= PRCB_BUILD_UNIPROCESSOR;

#endif

    Prcb->CurrentThread = Thread;
    Prcb->NextThread = (PKTHREAD)NULL;
    Prcb->IdleThread = Thread;
    Prcb->Number = Number;
    Prcb->SetMember = 1 << Number;

    KeInitializeDpc(&Prcb->QuantumEndDpc,
                    (PKDEFERRED_ROUTINE)KiQuantumEnd,
                    NIL);

    //
    // initialize the per processor lock queue entry for implemented locks.
    //

    KiInitQueuedSpinLocks(Prcb, Number);

    //
    // Set address of PCR in PRCB.
    //

    Prcb->Pcr = Pcr;

    //
    // Initialize the interprocessor communication packet.
    //

#if !defined(NT_UP)

    Prcb->TargetSet = 0;
    Prcb->WorkerRoutine = NULL;
    Prcb->RequestSummary = 0;
    Prcb->IpiFrozen = 0;

#if NT_INST

    Prcb->IpiCounts = &KiIpiCounts[Number];

#endif //NT_INST

#endif //NT_UP

    Prcb->MaximumDpcQueueDepth = KiMaximumDpcQueueDepth;
    Prcb->MinimumDpcRate = KiMinimumDpcRate;
    Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;

    //
    // Initialize DPC listhead and lock.
    //

    InitializeListHead(&Prcb->DpcListHead);
    KeInitializeSpinLock(&Prcb->DpcLock);

    //
    // Set address of processor block.
    //

    KiProcessorBlock[Number] = Prcb;

    //
    // Set address of process object in thread object.
    //

    Thread->ApcState.Process = Process;

    //
    // Set the appropriate member in the active processors set.
    //

    SetMember( Number, KeActiveProcessors );

    //
    // Set the number of processors based on the maximum of the current
    // number of processors and the current processor number.
    //

    if( (Number+1) > KeNumberProcessors ){
        KeNumberProcessors = Number + 1;
    }

    //
    // Initialize processors PowerState
    //

    PoInitializePrcb (Prcb);

    //
    // Set global processor architecture, level and revision.  The
    // latter two are the least common denominator on an MP system.
    //

#ifdef _AXP64_
    KeProcessorArchitecture = PROCESSOR_ARCHITECTURE_ALPHA64;
#else
    KeProcessorArchitecture = PROCESSOR_ARCHITECTURE_ALPHA;
#endif

    if ((KeProcessorLevel == 0) ||
        (KeProcessorLevel > (USHORT)Pcr->ProcessorType)) {
        KeProcessorLevel = (USHORT)Pcr->ProcessorType;
    }

    if ((KeProcessorRevision == 0) ||
        (KeProcessorRevision > (USHORT)Pcr->ProcessorRevision)) {
        KeProcessorRevision = (USHORT)Pcr->ProcessorRevision;
    }

    //
    // Initialize all interrupt vectors to transfer control to the unexpected
    // interrupt routine.
    //
    // N.B. This interrupt object is never actually "connected" to an interrupt
    //      vector via KeConnectInterrupt. It is initialized and then connected
    //      by simply storing the address of the dispatch code in the interrupt
    //      vector.
    //

    if (Number == 0) {

        //
        // Set default node.  Used in non-multinode systems and in
        // multinode systems until the node topology is available.
        //

        extern KNODE KiNode0;

        KeNodeBlock[0] = &KiNode0;

#if defined(KE_MULTINODE)

        for (Index = 1; Index < MAXIMUM_CCNUMA_NODES; Index++) {

            extern KNODE KiNodeInit[];

            //
            // Set temporary node.
            //

            KeNodeBlock[Index] = &KiNodeInit[Index];
        }

#endif

        Prcb->ParentNode = KeNodeBlock[0];
        KeNodeBlock[0]->ProcessorMask = Prcb->SetMember;

        KeFeatureBits = KiGetFeatureBits();

        //
        // Initial the address of the interrupt dispatch routine.
        //

        KxUnexpectedInterrupt.DispatchAddress = KiUnexpectedInterrupt;

        //
        // Copy the interrupt dispatch code template into the interrupt object
        // and flush the dcache on all processors that the current thread can
        // run on to ensure that the code is actually in memory.
        //

        for (Index = 0; Index < DISPATCH_LENGTH; Index += 1) {
            KxUnexpectedInterrupt.DispatchCode[Index] = KiInterruptTemplate[Index];
        }

        //
        // Sweep the instruction cache on the current processor.
        //

        KiImb();

    } else {

        //
        // Mask off feature bits that are not supported on all processors.
        //

        KeFeatureBits &= KiGetFeatureBits();
    }

    //
    // Update processor features
    //

    SharedUserData->ProcessorFeatures[PF_ALPHA_BYTE_INSTRUCTIONS] =
        (KeFeatureBits & KF_BYTE) ? TRUE : FALSE;

    for (Index = DISPATCH_LEVEL+1; Index < MAXIMUM_VECTOR; Index += 1) {
        Pcr->InterruptRoutine[Index] =  (PKINTERRUPT_ROUTINE)(&KxUnexpectedInterrupt.DispatchCode);
    }

    //
    // Raise IRQL to APC level.
    //

    KeRaiseIrql(APC_LEVEL, &OldIrql);

    //
    // If the initial processor is being initialized, then initialize the
    // per system data structures.
    //

    if (Number == 0) {

        //
        // Initialize the address of the restart block for the boot master.
        //

        Prcb->RestartBlock = SYSTEM_BLOCK->RestartBlock;

        //
        // Initialize the kernel debugger if enabled by the load options.
        //

        if (KdInitSystem(0, LoaderBlock, FALSE) == FALSE) {
            KeBugCheck(PHASE0_INITIALIZATION_FAILED);
        }

        //
        // Initialize processor block array.
        //

        for (Index = 1; Index < MAXIMUM_PROCESSORS; Index += 1) {
            KiProcessorBlock[Index] = (PKPRCB)NULL;
        }

        //
        // Initialize default DMA coherency value for Alpha.
        //

        KiDmaIoCoherency = DMA_READ_DCACHE_INVALIDATE | DMA_WRITE_DCACHE_SNOOP;

        //
        // Perform architecture independent initialization.
        //

        KiInitSystem();

        //
        // Initialize idle thread process object and then set:
        //
        //      1. all the quantum values to the maximum possible.
        //      2. the process in the balance set.
        //      3. the active processor mask to the specified processor.
        //

        KeInitializeProcess(Process,
                            (KPRIORITY)0,
                            (KAFFINITY)(0xffffffff),
                            (PULONG_PTR)PDE_SELFMAP,
                            FALSE);

        Process->ThreadQuantum = MAXCHAR;
    }

    //
    // Initialize idle thread object and then set:
    //
    //      1. the initial kernel stack to the specified idle stack.
    //      2. the next processor number to the specified processor.
    //      3. the thread priority to the highest possible value.
    //      4. the state of the thread to running.
    //      5. the thread affinity to the specified processor.
    //      6. the specified processor member in the process active processors
    //          set.
    //

    KeInitializeThread(Thread,
                       (PVOID)((ULONG_PTR)IdleStack - PAGE_SIZE),
                       (PKSYSTEM_ROUTINE)NULL,
                       (PKSTART_ROUTINE)NULL,
                       (PVOID)NULL,
                       (PCONTEXT)NULL,
                       (PVOID)NULL,
                       Process);

    Thread->InitialStack = IdleStack;
    Thread->StackBase = IdleStack;
    Thread->StackLimit = (PVOID)((ULONG_PTR)IdleStack - KERNEL_STACK_SIZE);
    Thread->NextProcessor = Number;
    Thread->Priority = HIGH_PRIORITY;
    Thread->State = Running;
    Thread->Affinity = (KAFFINITY)(1 << Number);
    Thread->WaitIrql = DISPATCH_LEVEL;

    //
    // If the current processor is the boot master then set the appropriate
    // bit in the active summary of the idle process.
    //

    if (Number == 0) {
        SetMember(Number, Process->ActiveProcessors);
    }

    //
    // call the executive initialization routine.
    //

    try {
        ExpInitializeExecutive(Number, LoaderBlock);

    } except(KeBugCheckEx(PHASE0_EXCEPTION,
                          (ULONG)GetExceptionCode(),
                          (ULONG_PTR)GetExceptionInformation(),
                          0,0), EXCEPTION_EXECUTE_HANDLER) {
        ; // should never get here
    }

    //
    // If the initial processor is being initialized, then compute the
    // timer table reciprocal value and reset the PRCB values for
    // the controllable DPC behavior in order to reflect any registry
    // overrides.
    //

    if (Number == 0) {
        KiTimeIncrementReciprocal = KiComputeReciprocal((LONG)KeMaximumIncrement,
                                                        &KiTimeIncrementShiftCount);

        Prcb->MaximumDpcQueueDepth = KiMaximumDpcQueueDepth;
        Prcb->MinimumDpcRate = KiMinimumDpcRate;
        Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;
    }

    //
    // Try to enable automatic PAL code fixups on this processor.
    // This must be done after the configuration values are read
    // out of the registry in ExpInitializeExecutive.
    //

#if !defined(_AXP64_)

    //
    // Don't let the PAL fix up alignment exceptions for axp64, so that we can catch
    // and fix them as they occur.
    //

    KiDisableAlignmentExceptions();

#endif

    //
    //
    // Raise IRQL to dispatch level and set the priority of the idle thread
    // to zero. This will have the effect of immediately causing the phase
    // one initialization thread to get scheduled for execution. The idle
    // thread priority is then set to the lowest realtime priority.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    KeSetPriorityThread(Thread, (KPRIORITY)0);
    Thread->Priority = LOW_REALTIME_PRIORITY;

    //
    // Raise IRQL to the highest level.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // If a restart block exists for the current processor then set boot
    // completed.
    //

#if !defined(NT_UP)

    RestartBlock = Prcb->RestartBlock;
    if (RestartBlock != NULL) {
        RestartBlock->BootStatus.BootFinished = 1;
    }

    //
    // If the current processor is a secondary processor and a thread has
    // not been selected for execution, then set the appropriate bit in the
    // idle summary.
    //

    if ((Number != 0) && (Prcb->NextThread == NULL)) {
        SetMember(Number, KiIdleSummary);
    }

#endif //NT_UP

    return;
}

ULONG
KiGetFeatureBits(
    VOID
    )

/*++

    Return the NT feature bits supported by this processors

--*/

{

    ULONG Features = 0;

    //
    // Check for byte instructions.
    //

    if (amask(1) == 0) {
        Features |= KF_BYTE;
    }

    return Features;
}

#if defined(_AXP64_)


VOID
KiStartHalThread (
    IN PKTHREAD Thread,
    IN PVOID Stack,
    IN PKSTART_ROUTINE StartRoutine,
    IN ULONG_PTR Process
    )

/*++

Routine Description:

    This function is called to initialize and start a thread from the
    HAL to emulate BIOS calls.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    Stack - Supplies a pointer the base of the real kernel stack for
        thread.

    StartRoutine - Supplies the address of the start routine.

Return Value:

    None.

--*/

{

    //
    // Initialize the specified thread object.
    //

    KeInitializeThread(Thread,
                       Stack,
                       (PKSYSTEM_ROUTINE)StartRoutine,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       (PKPROCESS)Process);

    //
    // Set thread priority.
    //

    Thread->Priority = (KPRIORITY) NORMAL_BASE_PRIORITY - 1;
    KeReadyThread(Thread);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\intobj.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    intobj.c

Abstract:

    This module implements the kernel interrupt object. Functions are provided
    to initialize, connect, and disconnect interrupt objects.

Author:

    David N. Cutler (davec) 3-Apr-1990


Environment:

    Kernel mode only.

Revision History:


--*/

#include "ki.h"


VOID
KeInitializeInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN PKSPIN_LOCK SpinLock OPTIONAL,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KIRQL SynchronizeIrql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector,
    IN CCHAR ProcessorNumber,
    IN BOOLEAN FloatingSave
    )

/*++

Routine Description:

    This function initializes a kernel interrupt object. The service routine,
    service context, spin lock, vector, IRQL, Synchronized IRQL, and floating
    context save flag are initialized.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

    ServiceRoutine - Supplies a pointer to a function that is to be
        executed when an interrupt occurs via the specified interrupt
        vector.

    ServiceContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the ServiceRoutine parameter.

    SpinLock - Supplies an optional pointer to an executive spin lock.

    Vector - Supplies the index of the entry in the Interrupt Dispatch Table
        that is to be associated with the ServiceRoutine function.

    Irql - Supplies the request priority of the interrupting source.

    SynchronizeIrql - The request priority that the interrupt should be
        synchronized with.

    InterruptMode - Supplies the mode of the interrupt; LevelSensitive or
        Latched.

    ShareVector - Supplies a boolean value that specifies whether the
        vector can be shared with other interrupt objects or not.  If FALSE
        then the vector may not be shared, if TRUE it may be.
        Latched.

    ProcessorNumber - Supplies the number of the processor to which the
        interrupt will be connected.

    FloatingSave - Supplies a boolean value that determines whether the
        floating point registers and pipe line are to be saved before calling
        the ServiceRoutine function.

Return Value:

    None.

--*/

{

    LONG Index;

    //
    // Initialize standard control object header.
    //

    Interrupt->Type = InterruptObject;
    Interrupt->Size = sizeof(KINTERRUPT);

    //
    // Initialize the address of the service routine, the service context,
    // the address of the spin lock, the address of the actual spin lock
    // that will be used, the vector number, the IRQL of the interrupting
    // source, the Synchronized IRQL of the interrupt object, the interrupt
    // mode, the processor number, and the floating context save flag.
    //

    Interrupt->ServiceRoutine = ServiceRoutine;
    Interrupt->ServiceContext = ServiceContext;

    if (ARGUMENT_PRESENT(SpinLock)) {
        Interrupt->ActualLock = SpinLock;
    } else {
        Interrupt->SpinLock = 0;
        Interrupt->ActualLock = &Interrupt->SpinLock;
    }

    Interrupt->Vector = Vector;
    Interrupt->Irql = Irql;
    Interrupt->SynchronizeIrql = SynchronizeIrql;
    Interrupt->Mode = InterruptMode;
    Interrupt->ShareVector = ShareVector;
    Interrupt->Number = ProcessorNumber;
    Interrupt->FloatingSave = FloatingSave;

    //
    // Copy the interrupt dispatch code template into the interrupt object
    // and flush the dcache on all processors that the current thread can
    // run on to ensure that the code is actually in memory.
    //

    for (Index = 0; Index < DISPATCH_LENGTH; Index += 1) {
        Interrupt->DispatchCode[Index] = KiInterruptTemplate[Index];
    }

    KeSweepIcache(FALSE);

    //
    // Set the connected state of the interrupt object to FALSE.
    //

    Interrupt->Connected = FALSE;
    return;
}

BOOLEAN
KeConnectInterrupt (
    IN PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function connects an interrupt object to the interrupt vector
    specified by the interrupt object. If the interrupt object is already
    connected, or an attempt is made to connect to an interrupt that cannot
    be connected, then a value of FALSE is returned. Else the specified
    interrupt object is connected to the interrupt vector, the connected
    state is set to TRUE, and TRUE is returned as the function value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is already connected or an attempt is made to
    connect to an interrupt vector that cannot be connected, then a value
    of FALSE is returned. Else a value of TRUE is returned.

--*/

{

    BOOLEAN Connected;
    PKINTERRUPT Interruptx;
    KIRQL Irql;
    CHAR Number;
    KIRQL OldIrql;
    ULONG Vector;

    //
    // If the interrupt object is already connected, the interrupt vector
    // number is invalid, an attempt is being made to connect to a vector
    // that cannot be connected, the interrupt request level is invalid,
    // the processor number is invalid, of the interrupt vector is less
    // than or equal to the highest level and it not equal to the specified
    // IRQL, then do not connect the interrupt object. Else connect interrupt
    // object to the specified vector and establish the proper interrupt
    // dispatcher.
    //

    Connected = FALSE;
    Irql = Interrupt->Irql;
    Number = Interrupt->Number;
    Vector = Interrupt->Vector;
    if (((Vector >= MAXIMUM_VECTOR) || (Irql > HIGH_LEVEL) ||
       ((Vector <= HIGH_LEVEL) &&
       (((1 << Vector & PCR->ReservedVectors) != 0))) ||
       (Number >= KeNumberProcessors)) == FALSE) {

        //
        // Set system affinity to the specified processor.
        //

        KeSetSystemAffinityThread((KAFFINITY)(1 << Number));

        //
        // Raise IRQL to dispatcher level and lock dispatcher database.
        //

        KiLockDispatcherDatabase(&OldIrql);

        //
        // If the specified interrupt vector is not connected, then
        // connect the interrupt vector to the interrupt object dispatch
        // code, establish the dispatcher address, and set the new
        // interrupt mode and enable masks. Else if the interrupt is
        // already chained, then add the new interrupt object at the end
        // of the chain. If the interrupt vector is not chained, then
        // start a chain with the previous interrupt object at the front
        // of the chain. The interrupt mode of all interrupt objects in
        // a chain must be the same.
        //

        if (Interrupt->Connected == FALSE) {
            if ( PCR->InterruptRoutine[Vector] ==
                 (PKINTERRUPT_ROUTINE)(&KxUnexpectedInterrupt.DispatchCode) ) {
                Connected = TRUE;
                Interrupt->Connected = TRUE;
                if (Interrupt->FloatingSave) {
                    Interrupt->DispatchAddress = KiFloatingDispatch;

                } else {
                    if (Interrupt->Irql == Interrupt->SynchronizeIrql) {
                        Interrupt->DispatchAddress =
                                    (PKINTERRUPT_ROUTINE)KiInterruptDispatchSame;
                    } else {
                        Interrupt->DispatchAddress =
                                    (PKINTERRUPT_ROUTINE)KiInterruptDispatchRaise;
                    }
                }

                PCR->InterruptRoutine[Vector] =
                            (PKINTERRUPT_ROUTINE)(&Interrupt->DispatchCode);

                HalEnableSystemInterrupt(Vector, Irql, Interrupt->Mode);

            } else {
                Interruptx = CONTAINING_RECORD(PCR->InterruptRoutine[Vector],
                                               KINTERRUPT,
                                               DispatchCode[0]);

                if (Interrupt->Mode == Interruptx->Mode) {
                    Connected = TRUE;
                    Interrupt->Connected = TRUE;
                    ASSERT (Irql <= KiSynchIrql);
                    if (Interruptx->DispatchAddress != KiChainedDispatch) {
                        InitializeListHead(&Interruptx->InterruptListEntry);
                        Interruptx->DispatchAddress = KiChainedDispatch;
                    }

                    InsertTailList(&Interruptx->InterruptListEntry,
                                   &Interrupt->InterruptListEntry);
                }
            }
        }

        //
        // Unlock dispatcher database and lower IRQL to its previous value.
        //

        KiUnlockDispatcherDatabase(OldIrql);

        //
        // Set system affinity back to the original value.
        //

        KeRevertToUserAffinityThread();
    }

    //
    // Return whether interrupt was connected to the specified vector.
    //

    return Connected;
}

BOOLEAN
KeDisconnectInterrupt (
    IN PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function disconnects an interrupt object from the interrupt vector
    specified by the interrupt object. If the interrupt object is not
    connected, then a value of FALSE is returned. Else the specified interrupt
    object is disconnected from the interrupt vector, the connected state is
    set to FALSE, and TRUE is returned as the function value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is not connected, then a value of FALSE is
    returned. Else a value of TRUE is returned.

--*/

{

    BOOLEAN Connected;
    PKINTERRUPT Interruptx;
    PKINTERRUPT Interrupty;
    KIRQL Irql;
    KIRQL OldIrql;
    ULONG Vector;

    //
    // Set system affinity to the specified processor.
    //

    KeSetSystemAffinityThread((KAFFINITY)(1 << Interrupt->Number));

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the interrupt object is connected, then disconnect it from the
    // specified vector.
    //

    Connected = Interrupt->Connected;
    if (Connected != FALSE) {
        Irql = Interrupt->Irql;
        Vector = Interrupt->Vector;

        //
        // If the specified interrupt vector is not connected to the chained
        // interrupt dispatcher, then disconnect it by setting its dispatch
        // address to the unexpected interrupt routine. Else remove the
        // interrupt object from the interrupt chain. If there is only
        // one entry remaining in the list, then reestablish the dispatch
        // address.
        //

        Interruptx = CONTAINING_RECORD(PCR->InterruptRoutine[Vector],
                                       KINTERRUPT,
                                       DispatchCode[0]);

        if (Interruptx->DispatchAddress == KiChainedDispatch) {
            ASSERT (Irql <= KiSynchIrql);
            if (Interrupt == Interruptx) {
                Interruptx = CONTAINING_RECORD(Interruptx->InterruptListEntry.Flink,
                                               KINTERRUPT, InterruptListEntry);
                Interruptx->DispatchAddress = KiChainedDispatch;
                PCR->InterruptRoutine[Vector] =
                                (PKINTERRUPT_ROUTINE)(&Interruptx->DispatchCode);

            }

            RemoveEntryList(&Interrupt->InterruptListEntry);
            Interrupty = CONTAINING_RECORD(Interruptx->InterruptListEntry.Flink,
                                           KINTERRUPT,
                                           InterruptListEntry);

            if (Interruptx == Interrupty) {
                if (Interrupty->FloatingSave) {
                    Interrupty->DispatchAddress = KiFloatingDispatch;

                } else {
                    if (Interrupty->Irql == Interrupty->SynchronizeIrql) {
                        Interrupty->DispatchAddress =
                                    (PKINTERRUPT_ROUTINE)KiInterruptDispatchSame;

                    } else {
                        Interrupty->DispatchAddress =
                                    (PKINTERRUPT_ROUTINE)KiInterruptDispatchRaise;
                    }
                }

                PCR->InterruptRoutine[Vector] =
                               (PKINTERRUPT_ROUTINE)(&Interrupty->DispatchCode);

                }

        } else {
            HalDisableSystemInterrupt(Vector, Irql);
            PCR->InterruptRoutine[Vector] =
                (PKINTERRUPT_ROUTINE)(&KxUnexpectedInterrupt.DispatchCode);
        }

        KeSweepIcache(TRUE);
        Interrupt->Connected = FALSE;
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Set system affinity back to the original value.
    //

    KeRevertToUserAffinityThread();

    //
    // Return whether interrupt was disconnected from the specified vector.
    //

    return Connected;
}


PKTRAP_FRAME
KeGetInterruptTrapFrame(
    VOID
    )
/*++

Routine Description:

    Returns a pointer to the last interrupt trap frame on the
    current stack. This allows the machine check handlers in 
    the HAL to inspect the trap frame without having to pass
    the PKTRAP_FRAME to every interrupt handler.

Arguments:

    None.

Return Value:

    Pointer to the last interrupt trap frame on the stack.

--*/

{
    ASSERT(KeGetCurrentIrql() >= DEVICE_LEVEL);
    ASSERT(KeGetCurrentPrcb()->InterruptTrapFrame != NULL);

    return(KeGetCurrentPrcb()->InterruptTrapFrame);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\getsetrg.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Digital Equipment Corporation

Module Name:

    getsetrg.c

Abstract:

    This module implement the code necessary to get and set register values.
    These routines are used during the emulation of unaligned data references
    and floating point exceptions.

Author:

    David N. Cutler (davec) 17-Jun-1991

Environment:

    Kernel mode only.

Revision History:

    Thomas Van Baak (tvb) 14-Jul-1992

        Adapted for NT/Alpha

--*/

#include "ki.h"

ULONGLONG
KiGetRegisterValue (
    IN ULONG Register,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to get the value of a register from the specified
    exception or trap frame.

Arguments:

    Register - Supplies the number of the register whose value is to be
        returned. Integer registers are specified as 0 - 31 and floating
        registers are specified as 32 - 63.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    The value of the specified register is returned as the function value.

--*/

{

    //
    // Dispatch on the register number.
    //

    switch (Register) {

        //
        // Integer register V0.
        //

    case 0:
        return TrapFrame->IntV0;

        //
        // Integer register T0.
        //

    case 1:
        return TrapFrame->IntT0;

        //
        // Integer register T1.
        //

    case 2:
        return TrapFrame->IntT1;

        //
        // Integer register T2.
        //

    case 3:
        return TrapFrame->IntT2;

        //
        // Integer register T3.
        //

    case 4:
        return TrapFrame->IntT3;

        //
        // Integer register T4.
        //

    case 5:
        return TrapFrame->IntT4;

        //
        // Integer register T5.
        //

    case 6:
        return TrapFrame->IntT5;

        //
        // Integer register T6.
        //

    case 7:
        return TrapFrame->IntT6;

        //
        // Integer register T7.
        //

    case 8:
        return TrapFrame->IntT7;

        //
        // Integer register S0.
        //

    case 9:
        return ExceptionFrame->IntS0;

        //
        // Integer register S1.
        //

    case 10:
        return ExceptionFrame->IntS1;

        //
        // Integer register S2.
        //

    case 11:
        return ExceptionFrame->IntS2;

        //
        // Integer register S3.
        //

    case 12:
        return ExceptionFrame->IntS3;

        //
        // Integer register S4.
        //

    case 13:
        return ExceptionFrame->IntS4;

        //
        // Integer register S5.
        //

    case 14:
        return ExceptionFrame->IntS5;

        //
        // Integer register S6/Fp.
        //
        // N.B. Unlike the other S registers, S6 is obtained from the trap
        // frame instead of the exception frame since it is used by the kernel
        // as a trap frame pointer.
        //

    case 15:
        return TrapFrame->IntFp;

        //
        // Integer register A0.
        //

    case 16:
        return TrapFrame->IntA0;

        //
        // Integer register A1.
        //

    case 17:
        return TrapFrame->IntA1;

        //
        // Integer register A2
        //

    case 18:
        return TrapFrame->IntA2;

        //
        // Integer register A3.
        //

    case 19:
        return TrapFrame->IntA3;

        //
        // Integer register A4.
        //

    case 20:
        return TrapFrame->IntA4;

        //
        // Integer register A5.
        //

    case 21:
        return TrapFrame->IntA5;

        //
        // Integer register T8.
        //

    case 22:
        return TrapFrame->IntT8;

        //
        // Integer register T9.
        //

    case 23:
        return TrapFrame->IntT9;

        //
        // Integer register T10.
        //

    case 24:
        return TrapFrame->IntT10;

        //
        // Integer register T11.
        //

    case 25:
        return TrapFrame->IntT11;

        //
        // Integer register Ra.
        //

    case 26:
        return TrapFrame->IntRa;

        //
        // Integer register T12.
        //

    case 27:
        return TrapFrame->IntT12;

        //
        // Integer register At.
        //

    case 28:
        return TrapFrame->IntAt;

        //
        // Integer register Gp.
        //

    case 29:
        return TrapFrame->IntGp;

        //
        // Integer register Sp.
        //

    case 30:
        return TrapFrame->IntSp;

        //
        // Integer register Zero.
        //

    case 31:
        return 0;

        //
        // Floating register F0.
        //

    case 32:
        return TrapFrame->FltF0;

        //
        // Floating register F1.
        //

    case 33:
        return TrapFrame->FltF1;

        //
        // Floating register F2.
        //

    case 34:
        return ExceptionFrame->FltF2;

        //
        // Floating register F3.
        //

    case 35:
        return ExceptionFrame->FltF3;

        //
        // Floating register F4.
        //

    case 36:
        return ExceptionFrame->FltF4;

        //
        // Floating register F5.
        //

    case 37:
        return ExceptionFrame->FltF5;

        //
        // Floating register F6.
        //

    case 38:
        return ExceptionFrame->FltF6;

        //
        // Floating register F7.
        //

    case 39:
        return ExceptionFrame->FltF7;

        //
        // Floating register F8.
        //

    case 40:
        return ExceptionFrame->FltF8;

        //
        // Floating register F9.
        //

    case 41:
        return ExceptionFrame->FltF9;

        //
        // Floating register F10.
        //

    case 42:
        return TrapFrame->FltF10;

        //
        // Floating register F11.
        //

    case 43:
        return TrapFrame->FltF11;

        //
        // Floating register F12.
        //

    case 44:
        return TrapFrame->FltF12;

        //
        // Floating register F13.
        //

    case 45:
        return TrapFrame->FltF13;

        //
        // Floating register F14.
        //

    case 46:
        return TrapFrame->FltF14;

        //
        // Floating register F15.
        //

    case 47:
        return TrapFrame->FltF15;

        //
        // Floating register F16.
        //

    case 48:
        return TrapFrame->FltF16;

        //
        // Floating register F17.
        //

    case 49:
        return TrapFrame->FltF17;

        //
        // Floating register F18.
        //

    case 50:
        return TrapFrame->FltF18;

        //
        // Floating register F19.
        //

    case 51:
        return TrapFrame->FltF19;

        //
        // Floating register F20.
        //

    case 52:
        return TrapFrame->FltF20;

        //
        // Floating register F21.
        //

    case 53:
        return TrapFrame->FltF21;

        //
        // Floating register F22.
        //

    case 54:
        return TrapFrame->FltF22;

        //
        // Floating register F23.
        //

    case 55:
        return TrapFrame->FltF23;

        //
        // Floating register F24.
        //

    case 56:
        return TrapFrame->FltF24;

        //
        // Floating register F25.
        //

    case 57:
        return TrapFrame->FltF25;

        //
        // Floating register F26.
        //

    case 58:
        return TrapFrame->FltF26;

        //
        // Floating register F27.
        //

    case 59:
        return TrapFrame->FltF27;

        //
        // Floating register F28.
        //

    case 60:
        return TrapFrame->FltF28;

        //
        // Floating register F29.
        //

    case 61:
        return TrapFrame->FltF29;

        //
        // Floating register F30.
        //

    case 62:
        return TrapFrame->FltF30;

        //
        // Floating register F31 (Zero).
        //

    case 63:
        return 0;
    }
}

VOID
KiSetRegisterValue (
    IN ULONG Register,
    IN ULONGLONG Value,
    OUT PKEXCEPTION_FRAME ExceptionFrame,
    OUT PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to set the value of a register in the specified
    exception or trap frame.

Arguments:

    Register - Supplies the number of the register whose value is to be
        stored. Integer registers are specified as 0 - 31 and floating
        registers are specified as 32 - 63.

    Value - Supplies the value to be stored in the specified register.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    None.

--*/

{

    //
    // Dispatch on the register number.
    //

    switch (Register) {

        //
        // Integer register V0.
        //

    case 0:
        TrapFrame->IntV0 = Value;
        return;

        //
        // Integer register T0.
        //

    case 1:
        TrapFrame->IntT0 = Value;
        return;

        //
        // Integer register T1.
        //

    case 2:
        TrapFrame->IntT1 = Value;
        return;

        //
        // Integer register T2.
        //

    case 3:
        TrapFrame->IntT2 = Value;
        return;

        //
        // Integer register T3.
        //

    case 4:
        TrapFrame->IntT3 = Value;
        return;

        //
        // Integer register T4.
        //

    case 5:
        TrapFrame->IntT4 = Value;
        return;

        //
        // Integer register T5.
        //

    case 6:
        TrapFrame->IntT5 = Value;
        return;

        //
        // Integer register T6.
        //

    case 7:
        TrapFrame->IntT6 = Value;
        return;

        //
        // Integer register T7.
        //

    case 8:
        TrapFrame->IntT7 = Value;
        return;

        //
        // Integer register S0.
        //

    case 9:
        ExceptionFrame->IntS0 = Value;
        return;

        //
        // Integer register S1.
        //

    case 10:
        ExceptionFrame->IntS1 = Value;
        return;

        //
        // Integer register S2.
        //

    case 11:
        ExceptionFrame->IntS2 = Value;
        return;

        //
        // Integer register S3.
        //

    case 12:
        ExceptionFrame->IntS3 = Value;
        return;

        //
        // Integer register S4.
        //

    case 13:
        ExceptionFrame->IntS4 = Value;
        return;

        //
        // Integer register S5.
        //

    case 14:
        ExceptionFrame->IntS5 = Value;
        return;

        //
        // Integer register S6/Fp.
        //
        // N.B. Unlike the other S registers, S6 is stored back in the trap
        // frame instead of the exception frame since it is used by the kernel
        // as a trap frame pointer.
        //

    case 15:
        TrapFrame->IntFp = Value;
        return;

        //
        // Integer register A0.
        //

    case 16:
        TrapFrame->IntA0 = Value;
        return;

        //
        // Integer register A1.
        //

    case 17:
        TrapFrame->IntA1 = Value;
        return;

        //
        // Integer register A2.
        //

    case 18:
        TrapFrame->IntA2 = Value;
        return;

        //
        // Integer register A3.
        //

    case 19:
        TrapFrame->IntA3 = Value;
        return;

        //
        // Integer register A4.
        //

    case 20:
        TrapFrame->IntA4 = Value;
        return;

        //
        // Integer register A5.
        //

    case 21:
        TrapFrame->IntA5 = Value;
        return;

        //
        // Integer register T8.
        //

    case 22:
        TrapFrame->IntT8 = Value;
        return;

        //
        // Integer register T9.
        //

    case 23:
        TrapFrame->IntT9 = Value;
        return;

        //
        // Integer register T10.
        //

    case 24:
        TrapFrame->IntT10 = Value;
        return;

        //
        // Integer register T11.
        //

    case 25:
        TrapFrame->IntT11 = Value;
        return;

        //
        // Integer register Ra.
        //

    case 26:
        TrapFrame->IntRa = Value;
        return;

        //
        // Integer register T12.
        //

    case 27:
        TrapFrame->IntT12 = Value;
        return;

        //
        // Integer register At.
        //

    case 28:
        TrapFrame->IntAt = Value;
        return;

        //
        // Integer register Gp.
        //

    case 29:
        TrapFrame->IntGp = Value;
        return;

        //
        // Integer register Sp.
        //

    case 30:
        TrapFrame->IntSp = Value;
        return;

        //
        // Integer register Zero.
        //

    case 31:
        return;

        //
        // Floating register F0.
        //

    case 32:
        TrapFrame->FltF0 = Value;
        return;

        //
        // Floating register F1.
        //

    case 33:
        TrapFrame->FltF1 = Value;
        return;

        //
        // Floating register F2.
        //

    case 34:
        ExceptionFrame->FltF2 = Value;
        return;

        //
        // Floating register F3.
        //

    case 35:
        ExceptionFrame->FltF3 = Value;
        return;

        //
        // Floating register F4.
        //

    case 36:
        ExceptionFrame->FltF4 = Value;
        return;

        //
        // Floating register F5.
        //

    case 37:
        ExceptionFrame->FltF5 = Value;
        return;

        //
        // Floating register F6.
        //

    case 38:
        ExceptionFrame->FltF6 = Value;
        return;

        //
        // Floating register F7.
        //

    case 39:
        ExceptionFrame->FltF7 = Value;
        return;

        //
        // Floating register F8.
        //

    case 40:
        ExceptionFrame->FltF8 = Value;
        return;

        //
        // Floating register F9.
        //

    case 41:
        ExceptionFrame->FltF9 = Value;
        return;

        //
        // Floating register F10.
        //

    case 42:
        TrapFrame->FltF10 = Value;
        return;

        //
        // Floating register F11.
        //

    case 43:
        TrapFrame->FltF11 = Value;
        return;

        //
        // Floating register F12.
        //

    case 44:
        TrapFrame->FltF12 = Value;
        return;

        //
        // Floating register F13.
        //

    case 45:
        TrapFrame->FltF13 = Value;
        return;

        //
        // Floating register F14.
        //

    case 46:
        TrapFrame->FltF14 = Value;
        return;

        //
        // Floating register F15.
        //

    case 47:
        TrapFrame->FltF15 = Value;
        return;

        //
        // Floating register F16.
        //

    case 48:
        TrapFrame->FltF16 = Value;
        return;

        //
        // Floating register F17.
        //

    case 49:
        TrapFrame->FltF17 = Value;
        return;

        //
        // Floating register F18.
        //

    case 50:
        TrapFrame->FltF18 = Value;
        return;

        //
        // Floating register F19.
        //

    case 51:
        TrapFrame->FltF19 = Value;
        return;

        //
        // Floating register F20.
        //

    case 52:
        TrapFrame->FltF20 = Value;
        return;

        //
        // Floating register F21.
        //

    case 53:
        TrapFrame->FltF21 = Value;
        return;

        //
        // Floating register F22.
        //

    case 54:
        TrapFrame->FltF22 = Value;
        return;

        //
        // Floating register F23.
        //

    case 55:
        TrapFrame->FltF23 = Value;
        return;

        //
        // Floating register F24.
        //

    case 56:
        TrapFrame->FltF24 = Value;
        return;

        //
        // Floating register F25.
        //

    case 57:
        TrapFrame->FltF25 = Value;
        return;

        //
        // Floating register F26.
        //

    case 58:
        TrapFrame->FltF26 = Value;
        return;

        //
        // Floating register F27.
        //

    case 59:
        TrapFrame->FltF27 = Value;
        return;

        //
        // Floating register F28.
        //

    case 60:
        TrapFrame->FltF28 = Value;
        return;

        //
        // Floating register F29.
        //

    case 61:
        TrapFrame->FltF29 = Value;
        return;

        //
        // Floating register F30.
        //

    case 62:
        TrapFrame->FltF30 = Value;
        return;

        //
        // Floating register F31 (Zero).
        //

    case 63:
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\intsup.s ===
//      TITLE("Interrupt Object Support Routines")
//++
//
// Copyright (c) 1990  Microsoft Corporation
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    intsup.s
//
// Abstract:
//
//    This module implements the code necessary to support interrupt objects.
//    It contains the interrupt dispatch code and the code template that gets
//    copied into an interrupt object.
//
// Author:
//
//    David N. Cutler (davec) 2-Apr-1990
//    Joe Notarangelo 07-Apr-1992  (based on xxintsup.s by Dave Cutler)
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

        SBTTL("Synchronize Execution")
//++
//
// BOOLEAN
// KeSynchronizeExecution (
//    IN PKINTERRUPT Interrupt,
//    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
//    IN PVOID SynchronizeContext
//    )
//
// Routine Description:
//
//    This function synchronizes the execution of the specified routine with the
//    execution of the service routine associated with the specified interrupt
//    object.
//
// Arguments:
//
//    Interrupt (a0) - Supplies a pointer to a control object of type interrupt.
//
//    SynchronizeRoutine (a1) - Supplies a pointer to a function whose execution
//       is to be synchronized with the execution of the service routine associated
//       with the specified interrupt object.
//
//    SynchronizeContext (a2) - Supplies a pointer to an arbitrary data structure
//       which is to be passed to the function specified by the SynchronizeRoutine
//       parameter.
//
// Return Value:
//
//    The value returned by the SynchronizeRoutine function is returned as the
//    function value.
//
//--


        .struct 0
SyS0:   .space  8                       // saved integer register s0
SyIrql: .space  4                       // saved IRQL value
        .space  4                       // fill for alignment
SyRa:   .space  8                       // saved return address
SyA0:   .space  8                       // saved argument registers a0 - a2
SyA1:   .space  8                       //
SyA2:   .space  8                       //
SyFrameLength:                          // length of stack frame

        NESTED_ENTRY(KeSynchronizeExecution, SyFrameLength, zero)

        lda     sp, -SyFrameLength(sp)  // allocate stack frame
        stq     ra, SyRa(sp)            // save return address
        stq     s0, SyS0(sp)            // save integer register s0

        PROLOGUE_END

        stq     a1, SyA1(sp)            // save synchronization routine address
        stq     a2, SyA2(sp)            // save synchronization routine context

//
// Raise IRQL to the synchronization level and acquire the associated
// spin lock.
//

#if !defined(NT_UP)

        LDP     s0, InActualLock(a0)    // get address of spin lock

#endif

        ldq_u   t1, InSynchronizeIrql(a0) // get synchronization IRQL
	lda	t2, InSynchronizeIrql(a0) //
        extbl   t1, t2, a0              //

        SWAP_IRQL                       // raise IRQL to synchronization level

        stl     v0, SyIrql(sp)          // save old irql

#if !defined(NT_UP)

10:     LDP_L   t0, 0(s0)               // get current lock value
        bis     s0, zero, t1            // set lock ownership value
        bne     t0, 15f                 // if ne, spin lock owned
        STP_C   t1, 0(s0)               // set spin lock owned
        beq     t1, 15f                 // if eq, store conditional failed
        mb                              // synchronize memory access

#endif

//
// Call specified routine passing the specified context parameter.
//

        LDP     t5, SyA1(sp)            // get synchronize routine address
        LDP     a0, SyA2(sp)            // get synchronzie routine context
        jsr     ra, (t5)                // call routine

//
// Release spin lock, lower IRQL to its previous level, and return the value
// returned by the specified routine.
//

#if !defined(NT_UP)

        mb                              // synchronize memory access
        STP     zero, 0(s0)             // set spin lock not owned

#endif

        ldl     a0, SyIrql(sp)          // get saved IRQL
        extbl   a0, 0, a0               // this is a uchar
        bis     v0, zero, s0            // save return value

        SWAP_IRQL                       // lower IRQL to previous level

        bis     s0, zero, v0            // restore return value
        ldq     s0, SyS0(sp)            // restore s0
        ldq     ra, SyRa(sp)            // restore ra
        lda     sp, SyFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// Attempt to acquire lock failed.
//

#if !defined(NT_UP)

15:     LDP     t0, 0(s0)               // read current lock value
        beq     t0, 10b                 // if lock available, retry spinlock
        br      zero, 15b               // spin in cache until lock available

#endif

        .end    KeSynchronizeExecution

        SBTTL("Dispatch Chained Interrupt")
//++
//
// Routine Description:
//
//    This routine is entered as the result of an interrupt being generated
//    via a vector that is connected to more than one interrupt object. Its
//    function is to walk the list of connected interrupt objects and call
//    each interrupt service routine. If the mode of the interrupt is latched,
//    then a complete traversal of the chain must be performed. If any of the
//    routines require saving the volatile floating point machine state, then
//    it is only saved once.
//
//    N.B. On entry to this routine only the volatile integer registers have
//       been saved.
//
// Arguments:
//
//    a0 - Supplies a pointer to the interrupt object.
//
//    s6/fp - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
//--

        .struct 0
ChS0:   .space  8                       // saved integer registers s0 - s5
ChS1:   .space  8                       //
ChS2:   .space  8                       //
ChS3:   .space  8                       //
ChS4:   .space  8                       //
ChS5:   .space  8                       //
ChRa:   .space  8                       // saved return address
ChIrql: .space  4                       // saved IRQL value
ChSpinL: .space 4                       // address of spin lock
ChFrameLength:                          // length of stack frame

        NESTED_ENTRY(KiChainedDispatch, ChFrameLength, zero)

        lda     sp, -ChFrameLength(sp)  // allocate stack frame
        stq     ra, ChRa(sp)            // save return address
        stq     s0, ChS0(sp)            // save integer registers s0 - s6
        stq     s1, ChS1(sp)            //
        stq     s2, ChS2(sp)            //
        stq     s3, ChS3(sp)            //
        stq     s4, ChS4(sp)            //
        stq     s5, ChS5(sp)            //

        PROLOGUE_END

//
// Register usage:
//
//      s0 = address of listhead
//      s1 = address of current item in list
//      s2 = floating status saved flag
//      s3 = mode of interrupt
//      s4 = irql of interrupt source
//      s5 = synchronization level requested for current list item
//
// Initialize loop variables.
//

        ADDP    a0, InInterruptListEntry, s0 // set address of listhead
        bis     s0, zero, s1            // set address of first entry
        bis     zero, zero, s2          // clear floating state saved flag
        ldq_u   t0, InMode(a0)          // get mode of interrupt
	lda	t2, InMode(a0)          //
        extbl   t0, t2, s3              //
        ldq_u   t1, InIrql(a0)          // get interrupt source IRQL
	lda	t3, InIrql(a0)          //
        extbl   t1, t3, s4              //

//
// Walk the list of connected interrupt objects and call the respective
// interrupt service routines.
//

10:     SUBP    s1, InInterruptListEntry, a0 // compute interrupt object address
        ldq_u   t2, InFloatingSave(a0)  // get floating save flag
	lda	t1, InFloatingSave(a0)  //
        extbl   t2, t1, t0              //
        bne     s2, 20f                 // if ne, floating state already saved
        beq     t0, 20f                 // if eq, don't save floating state

//
// Save volatile floating registers in trap frame.
//

        bsr     ra, KiSaveVolatileFloatState // save floating state
        ldil    s2, 1                   // set floating state saved flag

//
// Raise IRQL to synchronization level if synchronization level is not
// equal to the interrupt source level.
//

20:     ldq_u   t1, InSynchronizeIrql(a0) // get synchronization IRQL
	lda	t2, InSynchronizeIrql(a0) //
        extbl   t1, t2, s5              //
        cmpeq   s4, s5, t0              // Check if synchronization equals source level?
        bne     t0, 25f                 // if ne[true], IRQL levels are same
        bis     s5, zero, a0            // set synchronization IRQL

        SWAP_IRQL                       // raise IRQL to synchronization level

        stl     v0, ChIrql(sp)          // save old IRQL
        SUBP    s1, InInterruptListEntry, a0 // recompute interrupt object address

//
//
// Acquire the service routine spin lock and call the service routine.
//

25:                                     //

#if !defined(NT_UP)

        LDP     t5, InActualLock(a0)    // get address of spin lock
30:     LDP_L   t1, 0(t5)               // get current lock value
        bis     t5, zero, t2            // set ownership value
        bne     t1, 35f                 // if ne, spin lock owned
        STP_C   t2, 0(t5)               // set spin lock owned
        beq     t2, 35f                 // if eq, store conditional failed
        mb                              // synchronize memory access
        STP     t5, ChSpinL(sp)         // save spin lock address

#endif

        LDP     t5, InServiceRoutine(a0) // get address of service routine
        LDP     a1, InServiceContext(a0) // get service context
        jsr     ra, (t5)                // call interrupt service routine

//
// Release the service routine spin lock.
//

#if !defined(NT_UP)

        LDP     t5, ChSpinL(sp)         // get address of spin lock
        mb                              // synchronize memory access
        STP     zero, 0(t5)             // set spin lock not owned

#endif

//
// Lower IRQL to the interrupt source level if synchronization level is not
// the same as the interrupt source level.
//

        cmpeq   s4, s5, t0              // check if synchronization equals source level
        bne     t0, 37f                 // if ne[true], IRQL levels are same
        bis     s4, zero, a0            // set interrupt source IRQL

        SWAP_IRQL                       // lower to interrupt source IRQL

//
// Get next list entry and check for end of loop.
//

37:     LDP     s1, LsFlink(s1)         // get next interrupt object address
        beq     v0, 40f                 // if eq, interrupt not handled
        beq     s3, 50f                 // if eq, level sensitive interrupt
40:     cmpeq   s0, s1, t0              // check if end of list
        beq     t0, 10b                 // if eq[false], not end of list

//
// Either the interrupt is level sensitive and has been handled or the end of
// the interrupt object chain has been reached. Check to determine if floating
// machine state needs to be restored.
//

50:     beq     s2, 60f                 // if eq, floating state not saved

//
// Restore volatile floating registers from trap frame.
//

        bsr     ra, KiRestoreVolatileFloatState // restore floating state

//
// Restore integer registers s0 - s5, retrieve return address, deallocate
// stack frame, and return.
//

60:     ldq     s0, ChS0(sp)            // restore integer registers s0 - s6
        ldq     s1, ChS1(sp)            //
        ldq     s2, ChS2(sp)            //
        ldq     s3, ChS3(sp)            //
        ldq     s4, ChS4(sp)            //
        ldq     s5, ChS5(sp)            //
        ldq     ra, ChRa(sp)            // restore return address
        lda     sp, ChFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// Attempt to acquire spinlock failed.
//

#if !defined(NT_UP)

35:     LDP     t1, 0(t5)               // read current lock value
        beq     t1, 30b                 // if eq, lock available
        br      zero, 35b               // spin in cache until lock available

#endif

        .end    KiChainedDispatch

        SBTTL("Floating Dispatch")
//++
//
// Routine Description:
//
//    This routine is entered as the result of an interrupt being generated
//    via a vector that is connected to an interrupt object. Its function is
//    to save the volatile floating machine state and then call the specified
//    interrupt service routine.
//
//    N.B. On entry to this routine only the volatile integer registers have
//       been saved.
//
// Arguments:
//
//    a0 - Supplies a pointer to the interrupt object.
//
//    s6/fp - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
//--

        .struct 0
FlS0:   .space  8                       // saved integer registers s0 - s1
FlS1:   .space  8                       //
FlIrql: .space  4                       // saved IRQL value
        .space  4                       // for alignment
FlRa:   .space  8                       // saved return address
FlFrameLength:                          // length of stack frame

        NESTED_ENTRY(KiFloatingDispatch, FlFrameLength, zero)

        lda     sp, -FlFrameLength(sp)  // allocate stack frame
        stq     ra, FlRa(sp)            // save return address
        stq     s0, FlS0(sp)            // save integer registers s0 - s1

#if !defined(NT_UP)

        stq     s1, FlS1(sp)            //

#endif

        PROLOGUE_END

//
// Save volatile floating registers f0 - f19 in trap frame.
//

        bsr     ra, KiSaveVolatileFloatState // save floating state

//
// Raise IRQL to synchronization level if synchronization level is not
// equal to the interrupt source level.
//

        bis     a0, zero, s0            // save address of interrupt object
        ldq_u   t2, InSynchronizeIrql(s0) // get synchronization IRQL
	lda	t1, InSynchronizeIrql(s0) //
        extbl   t2, t1, a0              //
        ldq_u   t3, InIrql(s0)          // get interrupt source IRQL
	lda	t4, InIrql(s0)          //
        extbl   t3, t4, t0              //
        cmpeq   a0, t0, t1              // check if synchronize equals source IRQL ?
        bne     t1, 10f                 // if ne[true], IRQL levels same

        SWAP_IRQL                       // raise IRQL to synchronization level

        stl     v0, FlIrql(sp)          // save old irql
10:     bis     s0, zero, a0            // restore address of interrupt object

//
//
// Acquire the service routine spin lock and call the service routine.
//

#if !defined(NT_UP)

        LDP     s1, InActualLock(a0)    // get address of spin lock
20:     LDP_L   t1, 0(s1)               // get current lock value
        bis     s1, s1, t2              // set ownership value
        bne     t1, 25f                 // if ne, spin lock owned
        STP_C   t2, 0(s1)               // set spin lock owned
        beq     t2, 25f                 // if eq, store conditional failed
        mb                              // synchronize memory access

#endif

        LDP     t5, InServiceRoutine(a0) // get address of service routine
        LDP     a1, InServiceContext(a0) // get service context
        jsr     ra, (t5)                // call service routine

//
// Release the service routine spin lock.
//

#if !defined(NT_UP)

        mb                              // synchronize memory access
        STP     zero, 0(s1)             // set spin lock not owned

#endif

//
// Lower IRQL to the interrupt source level if synchronization level is not
// the same as the interrupt source level.
//

        ldq_u   t3, InIrql(s0)         // get interrupt source IRQL
	lda	t1, InIrql(s0)         //
        extbl   t3, t1, a0             //
        ldq_u   t4, InSynchronizeIrql(s0) // get synchronization IRQL
	lda	t2, InSynchronizeIrql(s0) //
        extbl   t4, t2, t0              //
        cmpeq   a0, t0, t1              // check if synchronize equal source IRQL?
        bne     t1, 30f                 // if eq, IRQL levels are the same

        SWAP_IRQL                       // lower IRQL to interrupt source

//
// Restore volatile floating registers f0 - f19 from trap frame.
//

30:     bsr     ra, KiRestoreVolatileFloatState // restore floating state

//
// Restore integer registers s0 - s1, retrieve return address, deallocate
// stack frame, and return.
//

        ldq     s0, FlS0(sp)            // restore integer registers s0 - s1

#if !defined(NT_UP)

        ldq     s1, FlS1(sp)            //

#endif

        ldq     ra, FlRa(sp)            // restore return address
        lda     sp, FlFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// Attempt to acquire spinlock failed.
//

#if !defined(NT_UP)

25:     LDP     t1, 0(s1)               // read current lock value
        beq     t1, 20b                 // if lock available, retry spinlock
        br      zero, 25b               // spin in cache until lock available

#endif

        .end    KiFloatingDispatch

        SBTTL("Interrupt Dispatch - Raise IRQL")
//++
//
// Routine Description:
//
//    This routine is entered as the result of an interrupt being generated
//    via a vector that is connected to an interrupt object. Its function is
//    to directly call the specified interrupt service routine.
//
//    N.B. On entry to this routine only the volatile integer registers have
//       been saved.
//
//    N.B. This routine raises the interrupt level to the synchronization
//       level specified in the interrupt object.
//
// Arguments:
//
//    a0 - Supplies a pointer to the interrupt object.
//
//    s6/fp - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
//--

        .struct 0
        .space  8                       // insure octaword alignment
RdS0:   .space  8                       // saved integer registers s0
RdIrql: .space  4                       // saved IRQL value
        .space  4                       // for alignment
RdRa:   .space  8                       // saved return address
RdFrameLength:                          // length of stack frame

        NESTED_ENTRY(KiInterruptDispatchRaise, RdFrameLength, zero)

        lda     sp, -RdFrameLength(sp)  // allocate stack frame
        stq     ra, RdRa(sp)            // save return address
        stq     s0, RdS0(sp)            // save integer registers s0

        PROLOGUE_END

//
// Raise IRQL to synchronization level
//

        bis     a0, zero, s0            // save address of interrupt object
        ldq_u   t3, InSynchronizeIrql(s0) // get synchronization IRQL
	lda	t1, InSynchronizeIrql(s0) //
        extbl   t3, t1, a0              //

        SWAP_IRQL                       // raise IRQL to synchronization level

        stl     v0, RdIrql(sp)          // save old irql
        bis     s0, zero, a0            // restore address of interrupt object

//
//
// Acquire the service routine spin lock and call the service routine.
//

#if !defined(NT_UP)

        LDP     t3, InActualLock(a0)    // get address of actual lock
20:     LDP_L   t1, 0(t3)               // get current lock value
        bis     t3, t3, t2              // set lock ownership value
        bne     t1, 25f                 // if ne, spin lock owned
        STP_C   t2, 0(t3)               // set spin lock owned
        beq     t2, 25f                 // if eq, store conditional failed
        mb                              // synchronize memory access

#endif

        LDP     t5, InServiceRoutine(a0) // get address of service routine
        LDP     a1, InServiceContext(a0) // get service context
        jsr     ra, (t5)                // call service routine

//
// Release the service routine spin lock.
//

#if !defined(NT_UP)

        LDP     t2, InActualLock(s0)    // get address of actual lock
        mb                              // synchronize memory access
        STP     zero, 0(t2)             // set spin lock not owned

#endif

//
// Lower IRQL to the previous level.
//

        ldl     a0, RdIrql(sp)          // get previous IRQL

        SWAP_IRQL                       // lower to interrupt source IRQL

//
// Restore integer register s0, retrieve return address, deallocate
// stack frame, and return.
//

30:     ldq     s0, RdS0(sp)            // restore integer register s0
        ldq     ra, RdRa(sp)            // restore return address
        lda     sp, RdFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// Attempt to acquire spinlock failed.

#if !defined(NT_UP)

25:     LDP     t1, 0(t3)               // read current lock value
        beq     t1, 20b                 // if lock available, retry spinlock
        br      zero, 25b               // spin in cache until lock available

#endif

        .end    KiInterruptDispatchRaise

        SBTTL("Interrupt Dispatch - Same IRQL")
//++
//
// Routine Description:
//
//    This routine is entered as the result of an interrupt being generated
//    via a vector that is connected to an interrupt object. Its function is
//    to directly call the specified interrupt service routine.
//
//    N.B. On entry to this routine only the volatile integer registers have
//       been saved.
//
// Arguments:
//
//    a0 - Supplies a pointer to the interrupt object.
//
//    s6/fp - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
//--

#if defined(NT_UP)

        LEAF_ENTRY(KiInterruptDispatchSame)

        LDP     t5, InServiceRoutine(a0) // get address of service routine
        LDP     a1, InServiceContext(a0) // get service context
        jsr     zero, (t5)              // jump to service routine

#else

        .struct 0
        .space  8                       // insure octaword alignment
SdS0:   .space  8                       // saved integer registers s0
SdIrql: .space  4                       // saved IRQL value
        .space  4                       // for alignment
SdRa:   .space  8                       // saved return address
SdFrameLength:                          // length of stack frame

        NESTED_ENTRY(KiInterruptDispatchSame, SdFrameLength, zero)

        lda     sp, -SdFrameLength(sp)  // allocate stack frame
        stq     ra, SdRa(sp)            // save return address
        stq     s0, SdS0(sp)            // save integer registers s0

        PROLOGUE_END

//
//
// Acquire the service routine spin lock and call the service routine.
//

        LDP     t3, InActualLock(a0)    // get actual lock address
        bis     a0, zero, s0            // save interrupt object address
20:     LDP_L   t1, 0(t3)               // get current lock value
        bis     t3, t3, t2              // set lock ownership value
        bne     t1, 25f                 // if ne, spin lock owned
        STP_C   t2, 0(t3)               // set spin lock owned
        beq     t2, 25f                 // if eq, store conditional failed
        mb                              // synchronize memory access
        LDP     t5, InServiceRoutine(a0) // get address of service routine
        LDP     a1, InServiceContext(a0) // get service context
        jsr     ra, (t5)                // call service routine

//
// Release the service routine spin lock.
//

        LDP     t2, InActualLock(s0)    // get actual lock address
        mb                              // synchronize memory access
        STP     zero, 0(t2)             // set spin lock not owned

//
// Restore integer registers s0, retrieve return address, deallocate
// stack frame, and return.
//

30:     ldq     s0, SdS0(sp)            // restore integer register s0
        ldq     ra, SdRa(sp)            // restore return address
        lda     sp, SdFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// Attempt to acquire spinlock failed.
//

25:     LDP     t1, 0(t3)               // read current lock value
        beq     t1, 20b                 // if lock available, retry spinlock
        br      zero, 25b               // spin in cache until lock available

#endif

        .end    KiInterruptDispatchSame

        SBTTL("Interrupt Template")
//++
//
// Routine Description:
//
//    This routine is a template that is copied into each interrupt object. Its
//    function is to determine the address of the respective interrupt object
//    and then transfer control to the appropriate interrupt dispatcher.
//
//    N.B. On entry to this routine only the volatile integer registers have
//       been saved.
//
// Arguments:
//
//    a0 - Supplies a pointer to the interrupt template within an interrupt
//       object.
//
//    s6/fp - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiInterruptTemplate)

        .set    noreorder
        .set    noat
        LDP     t5, InDispatchAddress - InDispatchCode(a0) // get dispatcher address
        SUBP    a0, InDispatchCode, a0  // compute address of interrupt object
        jmp     zero, (t5)              // transfer to dispatch routine
        bis     zero, zero, zero        // nop for alignment
        .set    at
        .set    reorder

        .end    KiInterruptTemplate

        SBTTL("Disable Interrupts")
//++
//
// Routine Description:
//
//     This routine disables interrupts on the current processor and
//     returns the previous state of the interrrupt enable bit.
//
// Arguments:
//
//     None.
//
// Return Value:
//
//     A boolean value, if true interrupts were previously turned on,
//     false indicates interrupts were previously off.
//
//--

        LEAF_ENTRY(KiDisableInterrupts)

        GET_CURRENT_PROCESSOR_STATUS_REGISTER // get current prcb address

        DISABLE_INTERRUPTS              // disable interrupts

        and     v0, PSR_IE_MASK, v0     // isolate interrupt enable
        srl     v0, PSR_IE, v0          // shift to bit 0
        ret     zero, (ra)              // return

        .end    KiDisableInterrupts

        SBTTL("Restore Interrupts")
//++
//
// Routine Description:
//
//     This routine enables interrupts according to the the previous
//     interrupt enable passed as input.
//
// Arguments:
//
//    a0 - Supplies previous interrupt enable state (returned by
//         KiDisableInterrupts)
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiRestoreInterrupts)

        beq     a0, 10f                 // if eq, then interrupts disabled

        ENABLE_INTERRUPTS               // enable interrupts

        ret     zero, (ra)              // return

10:     DISABLE_INTERRUPTS              // disable interrupts

        ret     zero, (ra)              // return

        .end    KiRestoreInterrupts

        SBTTL("Unexpected Interrupts")
//++
//
// Routine Description:
//
//    This routine is entered as the result of an interrupt being generated
//    via a vector that is not connected to an interrupt object. Its function
//    is to report the error and dismiss the interrupt.
//
//    N.B. On entry to this routine only the volatile integer registers have
//       been saved.
//
//    N.B. - This routine relies upon a private convention with the
//           interrupt exception dispatcher that register t12 contains the
//           interrupt vector of the unexpected interrupt.  This convention
//           will only work if the first level dispatch causes the
//           unexpected interrupt.
//
// Arguments:
//
//    a0 - Supplies a pointer to the interrupt object.
//    t12 - Supplies the interrupt vector.
//
//    s6/fp - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
//--

        .struct 0
        .space  8                       // filler for 16 byte alignment
UiRa:   .space  8                       // return address
UiFrameLength:                          // frame length

        NESTED_ENTRY(KiUnexpectedInterrupt, UiFrameLength, zero)

        lda     sp, -UiFrameLength(sp)  // allocate stack frame
        stq     ra, UiRa(sp)            // save return address

        PROLOGUE_END                    //

        ldil    a0, 0xfacefeed          // ****** temp ******
        bis     t12, zero, a1           // pass interrupt vector
        bis     zero, zero, a2          // zero remaining parameters
        bis     zero, zero, a3          //
        bis     zero, zero, a4          //
        bis     zero, zero, a5          //
        bsr     ra, KeBugCheckEx        // perform system crash

        .end    KiUnexpectedInterrupt

        SBTTL(KiPassiveRelease)
//++
//
// RoutineDescription:
//
//      KiPassiveRelease passively releases an interrupt that cannot/will not
//      be serviced at this time.  Or there is no reason to service it and
//      maybe this routine will never be called in a million years.
//
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      None.
//
//--

        LEAF_ENTRY( KiPassiveRelease )

        ret     zero, (ra)              // return

        .end    KiPassiveRelease

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\mpipi.s ===
//        TITLE("Interprocessor Interrupt support routines")
//++
//
// Copyright (c) 1993  Microsoft Corporation
// Copyright (c) 1993  Digital Equipment Corporation
//
// Module Name:
//
//    mpipi.s
//
// Abstract:
//
//    This module implements the Alpha AXP specific functions required to
//    support multiprocessor systems.
//
// Author:
//
//    David N. Cutler (davec) 22-Apr-1993
//    Joe Notarangelo  29-Nov-1993
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

        SBTTL("Interprocess Interrupt Processing")
//++
//
// VOID
// KeIpiInterrupt (
//    IN PKTRAP_FRAME TrapFrame
//    );
//
// Routine Description:
//
//    This routine is entered as the result of an interprocessor interrupt.
//    It's function is to process all interprocess immediate and packet
//    requests.
//
// Arguments:
//
//    TrapFrame (fp/s6) - Supplies a pointer to a trap frame.
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(KeIpiInterrupt, ExceptionFrameLength, zero)

        lda     sp, -ExceptionFrameLength(sp) // allocate exception frame
        stq     ra, ExIntRa(sp)         // save return address

        PROLOGUE_END

//
// Process all interprocessor requests.
//

        bsr     ra, KiIpiProcessRequests // process requests
        and     v0, IPI_FREEZE, t0      // check if freeze is requested
        beq     t0, 10f                 // if eq, no freeze requested

//
// Save the volatile floating state, the nonvolatile floating state,
// and the nonvolatile integer state.
//

        bsr     ra, KiSaveVolatileFloatState // save volatile float in trap
        bsr     ra, KiSaveNonVolatileFloatState // save nv float in exception
        stq     s0, ExIntS0(sp)         // save nonvolatile integer state
        stq     s1, ExIntS1(sp)         //
        stq     s2, ExIntS2(sp)         //
        stq     s3, ExIntS3(sp)         //
        stq     s4, ExIntS4(sp)         //
        stq     s5, ExIntS5(sp)         //
        stq     fp, ExIntFp(sp)         //

//
// Freeze the execution of the current processor.
//

        bis     fp, zero, a0            // set address of trap frame
        bis     sp, zero, a1            // set address of exception frame
        bsr     ra, KiFreezeTargetExecution // freeze current processor

//
// Restore the volatile floating state, the nonvolatile floating state,
// and the nonvolatile integer state.
//

        ldq     s0, ExIntS0(sp)         // restore nonvolatile integer state
        ldq     s1, ExIntS1(sp)         //
        ldq     s2, ExIntS2(sp)         //
        ldq     s3, ExIntS3(sp)         //
        ldq     s4, ExIntS4(sp)         //
        ldq     s5, ExIntS5(sp)         //
        ldq     fp, ExIntFp(sp)         //
        bsr     ra, KiRestoreVolatileFloatState // restore volatile float
        bsr     ra, KiRestoreNonVolatileFloatState // restore nv float state

//
// Cleanup and return to the caller.
//

10:     ldq     ra, ExIntRa(sp)         // restore return address
        lda     sp, ExceptionFrameLength(sp) // deallocate exception frame
        ret     zero, (ra)              // return

        .end    KeIpiInterrupt

        SBTTL("Processor Request")
//++
//
// ULONG
// KiIpiProcessRequests (
//    VOID
//    );
//
// Routine Description:
//
//    This routine processes interprocessor requests and returns a summary
//    of the requests that were processed.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    The request summary is returned as the function value.
//
//--

        .struct 0
PrS0:   .space  8                       // saved integer register s0
PrS1:   .space  8                       // saved integer register s1
        .space  8                       // fill
PrRa:   .space  8                       // saved return address
PrFrameLength:

        NESTED_ENTRY(KiIpiProcessRequests, PrFrameLength, zero)

        lda     sp, -PrFrameLength(sp)  // allocate stack frame
        stq     s0, PrS0(sp)            // save integer register s0

#if NT_INST

        stq     s1, PrS1(sp)            // save integer register s1

#endif

        stq     ra, PrRa(sp)            // save return address

        PROLOGUE_END

//
// Read request summary and write a zero result interlocked.
//

        mb                              // get consistent view of memory

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

#if NT_INST

        LDP     s1, PbIpiCounts(v0)     // get interrupt count structure address

#endif

10:     ldq_l   s0, PbRequestSummary(v0) // get request summary and entry address
        bis     zero, zero, t1          // set zero value for store
        stq_c   t1, PbRequestSummary(v0) // zero request summary, conditionally
        beq     t1, 15f                 // if eq, store conditional failed
        sra     s0, 16, a0              // shift out entry address

//
// Check for Packet ready.
//
// If a packet is ready, then get the address of the requested function
// and call the function passing the address of the packet address as a
// parameter.
//

        and     s0, IPI_PACKET_READY, t2 // check for packet ready
        beq     t2, 20f                 // if eq, no packet ready
        bic     a0, 1, v0               // clear low order packet address bit
        LDP     t2, PbWorkerRoutine(v0) // get address of worker function
        LDP     a1, PbCurrentPacket(v0) // get request parameters

#if defined(_AXP64_)

        ldq     a2, PbCurrentPacket + 8(v0) //
        ldq     a3, PbCurrentPacket + 16(v0) //

#else

        ldl     a2, PbCurrentPacket + 4(v0) //
        ldl     a3, PbCurrentPacket + 8(v0) //

#endif

        jsr     ra, (t2)                // call worker routine
        mb                              // synchronize memory access

#if NT_INST

        ldl     t1, IcPacket(s1)        // increment number of packet requests
        addl    t1, 1, t1               //
        stl     t1, IcPacket(s1)        //

#endif

//
// Check for APC interrupt request.
//
// If an APC interrupt is requested, then request a software interrupt at
// APC level on the current processor.
//

20:     and     s0, IPI_APC, t1         // check for APC interrupt request
        beq     t1, 30f                 // if eq, no APC interrupt requested
        ldil    a0, APC_LEVEL           // set interrupt request level

        REQUEST_SOFTWARE_INTERRUPT      // request APC interrupt

#if NT_INST

        ldl     t1, IcAPC(s1)           // increment number of APC requests
        addl    t1, 1, t1               //
        stl     t1, IcAPC(s1)           //

#endif

//
// Check for DPC interrupt request.
//
// If a DPC interrupt is requested, then request a software interrupt at
// DPC level on the current processor.
//

30:     and     s0, IPI_DPC, t1         // check for DPC interrupt request
        beq     t1, 40f                 // if eq, no DPC interrupt requested
        ldil    a0, DISPATCH_LEVEL      // set interrupt request level

        REQUEST_SOFTWARE_INTERRUPT      // request DPC interrupt

#if NT_INST

        ldl     t1, IcDPC(s1)           // increment number of DPC requests
        addl    t1, 1, t1               //
        stl     t1, IcDPC(s1)           //

#endif

//
// Set function return value, restore registers, and return.
//

40:     bis     s0, zero, v0            // set function return value
        ldq     s0, PrS0(sp)            // restore integer register s0

#if NT_INST

        and     v0, IPI_FREEZE, t1      // check if freeze requested
        beq     t1, 50f                 // if eq, no freeze requested
        ldl     t1, IcFreeze(s1)        // increment number of freeze requests
        addl    t1, 1, t1               //
        stl     t1, IcFreeze(s1)        //
50:     ldq     s1, PrS1(sp)            // restore integer register s1

#endif

        ldq     ra, PrRa(sp)            // restore return address
        lda     sp, PrFrameLength(sp)   // deallocate stack frame
        ret     zero, (ra)              // return

//
// Conditional store failed.
//

15:     br      zero, 10b               // store conditonal failed, retry

        .end    KiIpiProcessRequests

        SBTTL("Send Interprocess Request")
//++
//
// VOID
// KiIpiSend (
//    IN KAFINITY TargetProcessors,
//    IN KIPI_REQUEST IpiRequest
//    );
//
// Routine Description:
//
//    This routine requests the specified operation on the target set of
//    processors.
//
// Arguments:
//
//    TargetProcessors (a0) - Supplies the set of processors on which the
//        specified operation is to be executed.
//
//    IpiRequest (a1) - Supplies the request operation mask.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiIpiSend)

#if !defined(NT_UP)

        bis     a0, zero, t0            // copy target processor set
        lda     t1, KiProcessorBlock    // get processor block array address
10:     blbc    t0, 30f                 // if lbc, target processor not set
        LDP     t2, 0(t1)               // get target processor block address

//
// Merge the new request into the target processor request summary.
// The store is conditional to ensure that no updates are lost.
//

20:     ldq_l   t3, PbRequestSummary(t2) // get target request summary
        bis     t3, a1, t4              // merge new request with summary
        stq_c   t4, PbRequestSummary(t2) // set new request summary
        beq     t4, 25f                 // if eq, store conditional failed
30:     srl     t0, 1, t0               // shift to next target

#if defined(_AXP64_)

        lda     t1, 8(t1)               // get next processor block element

#else

        lda     t1, 4(t1)               // get next processor block element

#endif

        bne     t0, 10b                 // if ne, more targets requested
        mb                              // synchronize memory access
        LDP     t0, __imp_HalRequestIpi // request IPI interrupt on targets
        jmp     zero, (t0)              //

#else

        ret     zero, (ra)              // simply return for uni-processor

#endif

//
// Conditional store failed.
//

25:     br      zero, 20b               // store conditional failed, retry

        .end    KiIpiSend

        SBTTL("Send Interprocess Request Packet")
//++
//
// VOID
// KiIpiSendPacket (
//    IN KAFFINITY TargetProcessors,
//    IN PKIPI_WORKER WorkerFunction,
//    IN PVOID Parameter1,
//    IN PVOID Parameter2,
//    IN PVOID Parameter3
//    );
//
// Routine Description:
//
//    This routine executes the specified worker function on the specified
//    set of processors.
//
// Arguments:
//
//    TargetProcessors (a0) - Supplies the set of processors on which the
//        specified operation is to be executed.
//
//    WorkerFunction (a1) - Supplies the address of the worker function.
//
//    Parameter1 - Parameter3 - Supplies arguments for worker.
//
// Return Value:
//
//    None.
//
//--


        LEAF_ENTRY(KiIpiSendPacket)

#if !defined(NT_UP)

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        bis     a0, zero, t1            // copy target processor set
        lda     t2, KiProcessorBlock    // get processor block array address

//
// Store function address and parameters in the packet area of the PRCB on
// the current processor.
//

        stl     a0, PbTargetSet(v0)     // set target processor set
        STP     a1, PbWorkerRoutine(v0) // set worker function address
        STP     a2, PbCurrentPacket(v0) // store worker function parameters

#if defined(_AXP64_)

        stq     a3, PbCurrentPacket + 8(v0) //
        stq     a4, PbCurrentPacket + 16(v0) //

#else

        stl     a3, PbCurrentPacket + 4(v0) //
        stl     a4, PbCurrentPacket + 8(v0) //

#endif

        subl    a0, 1, a1               // compute target set - 1
        and     a1, a0, a1              // and target set with target set - 1
        zapnot  a1, 0xf, a1             // clear upper 32 bits
        cmpeq   a1, zero, a1            // compare if result is zero
        bne     a1, 5f                  // if ne, one and only one bit set
        stl     a0, PbPacketBarrier(v0) // set packet barrier
5:      mb                              // synchronize memory access
        ADDP    v0, a1, v0              // set low bit if appropriate

//
// Loop through the target processors and send the packet to the specified
// recipients.
//

10:     blbc    t1, 30f                 // if eq, target not specified
        LDP     t0, 0(t2)               // get target processor block address
        sll     v0, 16, t3              // shift packet address into position
        bis     t3, IPI_PACKET_READY, t3 // set packet ready in low 32 bits
20:     ldq_l   t4, PbRequestSummary(t0) // get request summary of target
        and     t4, IPI_PACKET_READY, t6 // check if target packet busy
        bne     t6, 25f                 // if ne, target packet busy
        bis     t4, t3, t4              // set entry address in request summary
        stq_c   t4, PbRequestSummary(t0) // store request summary and address
        beq     t4, 20b                 // if eq, store conditional failed

#if defined(_AXP64_)

30:     lda     t2, 8(t2)               // advance to next array element

#else

30:     lda     t2, 4(t2)               // advance to next array element

#endif

        srl     t1, 1, t1               // shift to next target
        bne     t1, 10b                 // if ne, more targets to process
        mb                              // synchronize memory access
        LDP     t0, __imp_HalRequestIpi // request IPI interrupt on targets
        jmp     zero, (t0)              //

//
// Packet not ready, spin in cache until it looks available.
//

25:     ldq     t4, PbRequestSummary(t0)    // get request summary of target
        and     t4, IPI_PACKET_READY, t6    // check if target packet busy
        beq     t6, 20b                     // looks available, try again
        br      zero, 25b                   // spin again

#else

        ret     zero, (ra)

#endif //!NT_UP

        .end    KiIpiSendPacket

        SBTTL("Restore Processor Control State")
//++
//
// VOID
// KiRestoreProcessorControlState (
//    IN PKPROCESSOR_STATE ProcessorState
//    );
//
// Routine Description:
//
//    This routine restores the processor control state for the debugger.
//
// Arguments:
//
//    ProcessorState (a0) - Pointer to PROCSSOR_STATE
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiRestoreProcessorControlState)

        ret     zero, (ra)              // return

        .end    KiRestoreProcessorControlState

        SBTTL("Save Processor Control State")
//++
//
// VOID
// KiSaveProcessorControlState (
//    IN PKPROCESSOR_STATE ProcessorState
//    );
//
// Routine Description:
//
//    This routine saves the processor control state for the debugger.
//
// Arguments:
//
//    ProcessorState (a0) - Pointer to PROCSSOR_STATE
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiSaveProcessorControlState)

        ret     zero, (ra)              // return

        .end    KiSaveProcessorControlState

        SBTTL("Signal Packet Done")
//++
//
// VOID
// KiIpiSignalPacketDone (
//    IN PKIPI_CONTEXT SignalDone
//    );
//
// Routine Description:
//
//    This routine signals that a processor has completed a packet by
//    clearing the calling processor's set member of the requesting
//    processor's packet.
//
// Arguments:
//
//    SignalDone (a0) - Supplies a pointer to the processor block of the
//        sending processor.
//
// Return Value:
//
//    None.
//
//--

#if !defined(NT_UP)

        LEAF_ENTRY(KiIpiSignalPacketDone)

        GET_PROCESSOR_CONTROL_REGION_BASE // get current pcr address

        blbs    a0, 30f                 // if lbs, one and only one bit set
        ldl     a1, PcSetMember(v0)     // get processor set member
        mb                              // synchronize memory access
10:     ldl_l   a2, PbTargetSet(a0)     // get request target set
        bic     a2, a1, a2              // clear processor set member
        mov     a2, v0                  // save result target set
        stl_c   a2, PbTargetSet(a0)     // store target set
        beq     a2, 10b                 // if eq, store conditional failed
        bne     v0, 20f                 // if ne, more targets to go
        stl     zero, PbPacketBarrier(a0) // clear packet barrier
        mb                              // synchronize memory access
20:     ret     zero, (ra)              // return

30:     stl     zero, PbTargetSet - 1(a0) // clear target set
        mb                              // synchronize memory access
        ret     zero, (ra)              //

        .end    KiIpiSignalPacketDone

#endif

        SBTTL("Read Memory Barrier Time Stamp")
//++
//
// ULONG
// KeReadMbTimeStamp (
//    VOID
//    );
//
// Routine Description:
//
//    This routine reads the current memory bazrrier time stamp value.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    The current value of the memory barrier time stamp is returned as the
//    function value.
//
//--

#if !defined(NT_UP)

        LEAF_ENTRY(KeReadMbTimeStamp)

        ldl_l   v0,KiMbTimeStamp        // read current memory barrier time stamp
        ret     zero, (ra)              // return

        .end    KeReadMbTimeStamp

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\ipi.c ===
/*++

Copyright (c) 1993  Microsoft Corporation
Copyright (c) 1993  Digital Equipment Corporation

Module Name:

    ipi.c

Abstract:

    This module implement Alpha AXP - specific interprocessor interrupt
    routines.

Author:

    David N. Cutler 24-Apr-1993
    Joe Notarangelo  29-Nov-1993

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
KiRestoreProcessorState (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function moves processor register state from the current
    processor context structure in the processor block to the
    specified trap and exception frames.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame.

Return Value:

    None.

--*/

{

    PKPRCB Prcb;

    //
    // Get the address of the current processor block and move the
    // specified register state from the processor context structure
    // to the specified trap and exception frames
    //

#if !defined(NT_UP)

    Prcb = KeGetCurrentPrcb();
    KeContextToKframes(TrapFrame,
                       ExceptionFrame,
                       &Prcb->ProcessorState.ContextFrame,
                       CONTEXT_FULL,
                       KernelMode);

#endif

    return;
}

VOID
KiSaveProcessorState (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function moves processor register state from the specified trap
    and exception frames to the processor context structure in the current
    processor block.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame.

Return Value:

    None.

--*/

{

    PKPRCB Prcb;

    //
    // Get the address of the current processor block and move the
    // specified register state from specified trap and exception
    // frames to the current processor context structure.
    //

#if !defined(NT_UP)

    Prcb = KeGetCurrentPrcb();
    Prcb->ProcessorState.ContextFrame.ContextFlags = CONTEXT_FULL;
    KeContextFromKframes(TrapFrame,
                         ExceptionFrame,
                         &Prcb->ProcessorState.ContextFrame);

#endif

    return;
}

BOOLEAN
KiIpiServiceRoutine (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:


    This function is called at IPI_LEVEL to process any outstanding
    interprocess request for the current processor.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame

Return Value:

    A value of TRUE is returned, if one of more requests were service.
    Otherwise, FALSE is returned.

--*/

{

    ULONG RequestSummary;

    //
    // Process any outstanding interprocessor requests.
    //

    RequestSummary = KiIpiProcessRequests();

    //
    // If freeze is requested, then freeze target execution.
    //

    if ((RequestSummary & IPI_FREEZE) != 0) {
        KiFreezeTargetExecution(TrapFrame, ExceptionFrame);
    }

    //
    // Return whether any requests were processed.
    //

    return (RequestSummary & ~IPI_FREEZE) != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\irql.s ===
//      TITLE("Manipulate Interrupt Request Level")
//++
//
// Copyright (c) 1990  Microsoft Corporation
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//    irql.s
//
// Abstract:
//
//    This module implements the code necessary to lower and raise the current
//    Interrupt Request Level (IRQL).
//
//
// Author:
//
//    David N. Cutler (davec) 12-Aug-1990
//    Joe Notarangelo 06-Apr-1992
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

//++
//
// VOID
// KeLowerIrql (
//    KIRQL NewIrql
//    )
//
// Routine Description:
//
//    This function lowers the current IRQL to the specified value.
//
// Arguments:
//
//    NewIrql (a0) - Supplies the new IRQL value.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeLowerIrql)

	SWAP_IRQL			// a0 = new, on return v0 = old irql

	ret	zero, (ra)		// return

        .end    KeLowerIrql

//++
//
// VOID
// KeRaiseIrql (
//    KIRQL NewIrql,
//    PKIRQL OldIrql
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to the specified value and returns
//    the old IRQL value.
//
// Arguments:
//
//    NewIrql (a0) - Supplies the new IRQL value.
//
//    OldIrql (a1) - Supplies a pointer to a variable that recieves the old
//       IRQL value.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeRaiseIrql)

	bis	a1, zero, t0		// save pointer to old irql

	SWAP_IRQL			// a0 = new, on return v0 = old irql

	ldq_u	t1, 0(t0)		// get quadword around old irql
	bic	t0, 0x3, t3		// get containing longword address
	insbl	v0, t0, t2		// put destination byte into position
	mskbl	t1, t0, t1		// clear destination byte
	bis	t1, t2, t1		// merge destination byte
	extll	t1, t3, t1		// get appropriate longword
	stl	t1, 0(t3)		// store byte
	ret	zero, (ra)		// return

        .end    KeRaiseIrql

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\pcr.s ===
//      TITLE("Processor Control Registers")
//++
//
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    pcr.s
//
// Abstract:
//
//    This module implements the code necessary to access the
//    processor control registers (pcr) on an alpha processor.
//    On mips processors the pcr (which contains processor-specific data)
//    was mapped in the virtual address space using a fixed tb entry.
//    For alpha, we don't have fixed tb entries so we will get pcr data
//    via routine interfaces that will vary depending upon whether we are
//    on a multi- or uni-processor system..
//
// Author:
//
//    Joe Notarangelo 15-Apr-1992
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

//++
//
// KIRQL
// KeGetCurrentIrql(
//      VOID
//      )
//
// Routine Description:
//
//    This function returns the current irql of the processor.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    Current processor irql.
//
//--

        LEAF_ENTRY(KeGetCurrentIrql)


        GET_CURRENT_IRQL                // v0 = current irql

        ret     zero, (ra)              // return

        .end KeGetCurrentIrql

//++
//
// PPRCB
// KeGetCurrentPrcb
//      VOID
//      )
//
// Routine Description:
//
//    This function returns the current processor control block for this
//      processor.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    Pointer to current processor's prcb.
//
//--

        LEAF_ENTRY(KeGetCurrentPrcb)

        GET_PROCESSOR_CONTROL_BLOCK_BASE // v0 = prcb base

        ret     zero, (ra)              // return

        .end KeGetCurrentPrcb

//++
//
// PKTHREAD
// KeGetCurrentThread
//      VOID
//      )
//
// Routine Description:
//
//    This function return the current thread running on this processor.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    Pointer to current thread.
//
//--

        LEAF_ENTRY(KeGetCurrentThread)

        GET_CURRENT_THREAD              // v0 = current thread address

        ret     zero, (ra)              // return

        .end KeGetCurrentThread

//++
//
// PKPCR
// KeGetPcr(
//      VOID
//      )
//
// Routine Description:
//
//    This function returns the base address of the processor control
//    region for the current processor.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    Pointer to current thread executing on this processor.
//
//--

        LEAF_ENTRY(KeGetPcr)

        GET_PROCESSOR_CONTROL_REGION_BASE // v0 = pcr base address

        ret     zero, (ra)              // return

        .end KeGetPcr

//++
//
// BOOLEAN
// KeIsExecutingDpc(
//     VOID
//     )
//
// Routine Description:
//
//    This function returns the DPC Active flag on the current processor.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    Current DPC Active flag.  This flag indicates if a DPC routine is
//    currently running on this processor.
//
//--

        LEAF_ENTRY(KeIsExecutingDpc)

#if !defined(NT_UP)

        DISABLE_INTERRUPTS              // disable interrupts

#endif

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        ldl     v0, PbDpcRoutineActive(v0) // get DPC routine active flag

#if !defined(NT_UP)

        ENABLE_INTERRUPTS               // enable interrupts

#endif

        ret     zero, (ra)              // return

        .end    KeIsExecutingDpc

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\miscs.s ===
//      TITLE("Miscellaneous Kernel Functions")
//++
//
// Copyright (c) 1990  Microsoft Corporation
//
// Module Name:
//
//    miscs.s
//
// Abstract:
//
//    This module implements machine dependent miscellaneous kernel functions.
//    Functions are provided to request a software interrupt, continue thread
//    execution, and perform last chance exception processing.
//
// Author:
//
//    David N. Cutler (davec) 31-Mar-1990
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//    Thomas Van Baak (tvb) 29-Jul-1992
//
//        Adapted for Alpha AXP.
//
//--

#include "ksalpha.h"

        SBTTL("Request Software Interrupt")
//++
//
// VOID
// KiRequestSoftwareInterrupt (
//    KIRQL RequestIrql
//    )
//
// Routine Description:
//
//    This function requests a software interrupt at the specified IRQL
//    level.
//
// Arguments:
//
//    RequestIrql (a0) - Supplies the requested IRQL value.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiRequestSoftwareInterrupt)

//
// If an interrupt routine is active, do not request an interrupt from the
// PAL. Indicate the interrupt has been requested in the PRCB. The interrupt
// exit code will dispatch the software interrupt directly.
//

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        LDP     t0, PbInterruptTrapFrame(v0) // get interrupt trap frame
        beq     t0, 10f                 // if eq, no interrupt active
        blbs    a0, 10f                 // if lbs, APC interrupt requested
        stl     a0, PbSoftwareInterrupts(v0) // set interrupt request bit in PRCB
        ret     zero, (ra)              //

//
// Request software interrupt.
//

10:     REQUEST_SOFTWARE_INTERRUPT      // request software interrupt

        ret     zero, (ra)              // return

        .end    KiRequestSoftwareInterrupt

        SBTTL("Continue Execution System Service")
//++
//
// NTSTATUS
// NtContinue (
//    IN PCONTEXT ContextRecord,
//    IN BOOLEAN TestAlert
//    )
//
// Routine Description:
//
//    This routine is called as a system service to continue execution after
//    an exception has occurred. Its function is to transfer information from
//    the specified context record into the trap frame that was built when the
//    system service was executed, and then exit the system as if an exception
//    had occurred.
//
// Arguments:
//
//    ContextRecord (a0) - Supplies a pointer to a context record.
//
//    TestAlert (a1) - Supplies a boolean value that specifies whether alert
//       should be tested for the previous processor mode.
//
//    N.B. Register fp is assumed to contain the address of a trap frame.
//
// Return Value:
//
//    Normally there is no return from this routine. However, if the specified
//    context record is misaligned or is not accessible, then the appropriate
//    status code is returned.
//
//--

        NESTED_ENTRY(NtContinue, ExceptionFrameLength, zero)

        lda     sp, -ExceptionFrameLength(sp) // allocate exception frame
        stq     ra, ExIntRa(sp)         // save return address

        PROLOGUE_END

//
// Save the nonvolatile machine state so that it can be restored by exception
// exit if it is not overwritten by the specified context record.
//

        stq     s0, ExIntS0(sp)         // save nonvolatile integer state
        stq     s1, ExIntS1(sp)         //
        stq     s2, ExIntS2(sp)         //
        stq     s3, ExIntS3(sp)         //
        stq     s4, ExIntS4(sp)         //
        stq     s5, ExIntS5(sp)         //

        stt     f2, ExFltF2(sp)         // save nonvolatile floating state
        stt     f3, ExFltF3(sp)         //
        stt     f4, ExFltF4(sp)         //
        stt     f5, ExFltF5(sp)         //
        stt     f6, ExFltF6(sp)         //
        stt     f7, ExFltF7(sp)         //
        stt     f8, ExFltF8(sp)         //
        stt     f9, ExFltF9(sp)         //

//
// Transfer information from the context frame to the exception and trap
// frames.
//

        mov     a1, s0                  // preserve test alert argument in s0
        mov     sp, a1                  // set address of exception frame
        mov     fp, a2                  // set address of trap frame
        bsr     ra, KiContinue          // transfer context to kernel frames

//
// If the kernel continuation routine returns success, then exit via the
// exception exit code. Otherwise return to the system service dispatcher.
//

        bne     v0, 20f                 // if ne, transfer failed

//
// Check to determine if alert should be tested for the previous processor
// mode and restore the previous mode in the thread object.
//

        GET_CURRENT_THREAD              // get current thread address

        LDP     t3, TrTrapFrame(fp)     // get old trap frame address
        ldl     t2, TrPreviousMode(fp)  // get old previous mode
        LoadByte(a0, ThPreviousMode(v0)) // get current previous mode
        STP     t3, ThTrapFrame(v0)     // restore old trap frame address
        StoreByte(t2, ThPreviousMode(v0)) // restore old previous mode
        beq     s0, 10f                 // if eq, don't test for alert
        bsr     ra, KeTestAlertThread   // test alert for current thread

//
// Exit the system via exception exit which will restore the nonvolatile
// machine state.
//

10:     br      zero, KiExceptionExit   // finish in exception exit

//
// Context record is misaligned or not accessible.
//

20:     ldq     ra, ExIntRa(sp)         // restore return address
        lda     sp, ExceptionFrameLength(sp) // deallocate stack frame
        ret     zero, (ra)              // return

        .end    NtContinue

        SBTTL("Raise Exception System Service")
//++
//
// NTSTATUS
// NtRaiseException (
//    IN PEXCEPTION_RECORD ExceptionRecord,
//    IN PCONTEXT ContextRecord,
//    IN BOOLEAN FirstChance
//    )
//
// Routine Description:
//
//    This routine is called as a system service to raise an exception.
//    The exception can be raised as a first or second chance exception.
//
// Arguments:
//
//    ExceptionRecord (a0) - Supplies a pointer to an exception record.
//
//    ContextRecord (a1) - Supplies a pointer to a context record.
//
//    FirstChance (a2) - Supplies a boolean value that determines whether
//       this is the first (TRUE) or second (FALSE) chance for dispatching
//       the exception.
//
//    N.B. Register fp is assumed to contain the address of a trap frame.
//
// Return Value:
//
//    Normally there is no return from this routine. However, if the specified
//    context record or exception record is misaligned or is not accessible,
//    then the appropriate status code is returned.
//
//--

        NESTED_ENTRY(NtRaiseException, ExceptionFrameLength, zero)

        lda     sp, -ExceptionFrameLength(sp) // allocate exception frame
        stq     ra, ExIntRa(sp)         // save return address
        stq     s0, ExIntS0(sp)         // save S0 and S1 in the prologue
        stq     s1, ExIntS1(sp)         // so that Get/SetContext can find
                                        // the right ones.
        PROLOGUE_END

//
// Save the nonvolatile machine state so that it can be restored by exception
// exit if it is not overwritten by the specified context record.
//

        stq     s2, ExIntS2(sp)         //
        stq     s3, ExIntS3(sp)         //
        stq     s4, ExIntS4(sp)         //
        stq     s5, ExIntS5(sp)         //

        stt     f2, ExFltF2(sp)         // save nonvolatile floating state
        stt     f3, ExFltF3(sp)         //
        stt     f4, ExFltF4(sp)         //
        stt     f5, ExFltF5(sp)         //
        stt     f6, ExFltF6(sp)         //
        stt     f7, ExFltF7(sp)         //
        stt     f8, ExFltF8(sp)         //
        stt     f9, ExFltF9(sp)         //

//
// Call the raise exception kernel routine which will marshall the arguments
// and then call the exception dispatcher.
//
// KiRaiseException requires five arguments: the first two are the same as
// the first two of this function and the other three are set here.
//

        mov     a2, a4                  // set first chance argument
        mov     sp, a2                  // set address of exception frame
        mov     fp, a3                  // set address of trap frame
        bsr     ra, KiRaiseException    // call raise exception routine

//
// If the raise exception routine returns success, then exit via the exception
// exit code. Otherwise return to the system service dispatcher.
//

        bis     v0, zero, t0            // save return status
        LDP     t1, TrTrapFrame(fp)     // get old trap frame address

        GET_CURRENT_THREAD              // get current thread address

        bne     t0, 10f                 // if ne, dispatch not successful
        STP     t1, ThTrapFrame(v0)     // restore old trap frame address

//
// Exit the system via exception exit which will restore the nonvolatile
// machine state.
//

        br      zero, KiExceptionExit   // finish in exception exit

//
// The context or exception record is misaligned or not accessible, or the
// exception was not handled.
//

10:     ldq     ra, ExIntRa(sp)         // restore return address
        lda     sp, ExceptionFrameLength(sp) // deallocate stack frame
        ret     zero, (ra)              // return

        .end    NtRaiseException

        SBTTL("Instruction Memory Barrier")
//++
//
// VOID
// KiImb (
//     VOID
//     )
//
// Routine Description:
//
//    This routine is called to flush the instruction cache on the
//    current processor.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiImb)

        IMB                     // flush the icache via PALcode

        ret     zero, (ra)      // return

        .end    KiImb

        SBTTL("Memory Barrier")
//++
//
// VOID
// KiImb (
//     VOID
//     )
//
// Routine Description:
//
//    This routine is called to issue a memory barrier on the current
//    processor.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiMb)

        mb                      // memory barrier

        ret     zero, (ra)      // return

        .end    KiMb

//++
//
// VOID
// KiEnablePALAlignmentFixups(
//     VOID	
//     )
//
// Routine Description:
//
//     Enable PAL fixups and PAL counting of alignment faults.
//
// Arguments:
//
//     None
//
// Return Value:
//
//     None.
//
//--

	LEAF_ENTRY(KiEnablePALAlignmentFixups)


	ENABLE_ALIGNMENT_FIXUPS         // enable alignment fixups

	ret	zero, (ra)		// return

	.end	KiEnablePALAlignmentFixups

//++
//
// VOID
// KiDisablePALAlignmentFixups(
//     VOID	
//     )
//
// Routine Description:
//
//     Disable PAL fixups and force all alignment faults to
//     the kernel.
//
// Arguments:
//
//     None
//
// Return Value:
//
//     None.
//
//--

	LEAF_ENTRY(KiDisablePALAlignmentFixups)

	DISABLE_ALIGNMENT_FIXUPS        // disable alignment fixups

	ret	zero, (ra)		// return

	.end	KiDisablePALAlignmentFixups

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\spinlock.s ===
//      TITLE("Spin Locks")
//++
//
// Copyright (c) 1990  Microsoft Corporation
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    spinlock.s
//
// Abstract:
//
//    This module implements the routines for acquiring and releasing
//    spin locks.
//
// Author:
//
//    David N. Cutler (davec) 23-Mar-1990
//    Joe Notarangelo 06-Apr-1992
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

//++
//
// VOID
// KeInitializeSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function initializes an executive spin lock.
//
// Argument:
//
//    SpinLock (a0) - Supplies a pointer to the executive spin lock.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY( KeInitializeSpinLock )

        STP     zero, 0(a0)             // set spin lock not owned
        ret     zero, (ra)              // return

        .end KeInitializeSpinLock

//++
//
// VOID
// KeAcquireSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    OUT PKIRQL OldIrql
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to DISPATCH_LEVEL and acquires
//    the specified executive spinlock.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a executive spinlock.
//
//    OldIrql  (a1) - Supplies a pointer to a variable that receives the
//        the previous IRQL value.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeAcquireSpinLock)

//
// Raise IRQL to DISPATCH_LEVEL and acquire the specified spinlock.
//
// N.B. The raise IRQL code is duplicated here is avoid any extra overhead
//      since this is such a common operation.
//
// N.B. The previous IRQL must not be stored until the lock is owned.
//
// N.B. The longword surrounding the previous IRQL must not be read
//      until the lock is owned.
//

        bis     a0, zero, t5            // t5 = address of spin lock
        ldil    a0, DISPATCH_LEVEL      // set new IRQL
        bis     a1, zero, t0            // t0 = a1, a1 may be destroyed

        SWAP_IRQL                       // swap irql, on return v0 = old irql

//
// Acquire the specified spinlock.
//
// N.B. code below branches forward if spinlock fails intentionally
//      because branch forwards are predicted to miss
//

#if !defined(NT_UP)

10:     LDP_L   t3, 0(t5)               // get current lock value
        bis     t5, zero, t4            // set ownership value
        bne     t3, 15f                 // if ne => lock owned
        STP_C   t4, 0(t5)               // set lock owned
        beq     t4, 15f                 // if eq => stx_c failed
        mb                              // synchronize memory access

#endif

//
// Save the old Irql at the address saved by the caller.
// Insure that the old Irql is updated with longword granularity.
//

        ldq_u   t1, 0(t0)               // read quadword surrounding KIRQL
        bic     t0, 3, t2               // get address of containing longword
        mskbl   t1, t0, t1              // clear KIRQL byte in quadword
        insbl   v0, t0, v0              // get new KIRQL to correct byte
        bis     t1, v0, t1              // merge KIRQL into quadword
        extll   t1, t2, t1              // get longword containg KIRQL
        stl     t1, 0(t2)               // store containing longword
        ret     zero, (ra)              // return

//
// Attempt to acquire spinlock failed.
//

#if !defined(NT_UP)

15:     LDP     t3, 0(t5)               // get current lock value
        beq     t3, 10b                 // retry acquire lock if unowned
        br      zero, 15b               // loop in cache until lock free

#endif

        .end    KeAcquireSpinLock

        SBTTL("Acquire SpinLock and Raise to Synch")
//++
//
// KIRQL
// KeAcquireSpinLockRaiseToSynch (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to synchronization level and
//    acquires the specified spinlock.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to the spinlock that is to be
//        acquired.
//
// Return Value:
//
//    The previous IRQL is returned as the function value.
//
//--

        LEAF_ENTRY(KeAcquireSpinLockRaiseToSynch)

#if !defined(NT_UP)

        bis         a0, zero, t5        // save spinlock address
        ldl         a0, KiSynchIrql     // get synch level IRQL

//
// Raise IRQL and attempt to acquire the specified spinlock.
//

10:     SWAP_IRQL                       // raise IRQL to synch level

        LDP_L       t3, 0(t5)           // get current lock value
        bis         t5, zero, t4        // set ownership value
        bne         t3, 25f             // if ne, lock owned
        STP_C       t4, 0(t5)           // set lock owned
        beq         t4, 25f             // if eq, conditional store failed
        mb                              // synchronize subsequent reads
        ret         zero, (ra)

//
// Spinlock is owned, lower IRQL and spin in cache until it looks free.
//

25:     bis         v0, zero, a0        // get previous IRQL value

        SWAP_IRQL                       // lower IRQL

        bis         v0, zero, a0        // save synch level IRQL
26:     LDP         t3, 0(t5)           // get current lock value
        beq         t3, 10b             // retry acquire if unowned
        br          zero, 26b           // loop in cache until free

#else

        ldl         a0, KiSynchIrql     // get synch level IRQL

        SWAP_IRQL                       // rasie IRQL to synch levcel

        ret         zero, (ra)          // return

        .end    KeAcquireSpinLockRaiseToSynch

#endif

//++
//
// KIRQL
// KeAcquireSpinLockRaiseToDpc (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to dispatcher level and acquires
//    the specified spinlock.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to the spinlock that is to be
//        acquired.
//
// Return Value:
//
//    The previous IRQL is returned as the function value.
//
//--

#if !defined(NT_UP)

        ALTERNATE_ENTRY(KeAcquireSpinLockRaiseToDpc)

        bis     a0, zero, t5            // save spinlock address
        ldil    a0, DISPATCH_LEVEL      // set IRQL level
        br      10b                     // finish in common code

        .end    KeAcquireSpinLockRaiseToSynch

#else

        LEAF_ENTRY(KeAcquireSpinLockRaiseToDpc)

        ldil    a0, DISPATCH_LEVEL      // set new IRQL

        SWAP_IRQL                       // old irql in v0

        ret     zero, (ra)

        .end    KeAcquireSpinLockRaiseToDpc

#endif

//++
//
// VOID
// KeReleaseSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    IN KIRQL OldIrql
//    )
//
// Routine Description:
//
//    This function releases an executive spin lock and lowers the IRQL
//    to its previous value.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to an executive spin lock.
//
//    OldIrql (a1) - Supplies the previous IRQL value.
//
// Return Value:
//
//    None.
//
//--
        LEAF_ENTRY(KeReleaseSpinLock)

//
// Release the specified spinlock.
//

#if !defined(NT_UP)

        mb                              // synchronize memory access
        STP     zero, 0(a0)             // set spin lock not owned

#endif

//
// Lower the IRQL to the specified level.
//
// N.B. The lower IRQL code is duplicated here is avoid any extra overhead
//      since this is such a common operation.
//

10:     bis     a1, zero, a0            // a0 = new irql

        SWAP_IRQL                       // change to new irql

        ret     zero, (ra)              // return

        .end    KeReleaseSpinLock

//++
//
// BOOLEAN
// KeTryToAcquireSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    OUT PKIRQL OldIrql
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to DISPATCH_LEVEL and attempts
//    to acquires the specified executive spinlock. If the spinlock can be
//    acquired, then TRUE is returned. Otherwise, the IRQL is restored to
//    its previous value and FALSE is returned.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a executive spinlock.
//
//    OldIrql  (a1) - Supplies a pointer to a variable that receives the
//        the previous IRQL value.
//
// Return Value:
//
//    If the spin lock is acquired, then a value of TRUE is returned.
//    Otherwise, a value of FALSE is returned.
//
//--

        LEAF_ENTRY(KeTryToAcquireSpinLock)

//
// Raise IRQL to DISPATCH_LEVEL and try to acquire the specified spinlock.
//
// N.B. The raise IRQL code is duplicated here is avoid any extra overhead
//      since this is such a common operation.
//

        bis     a0, zero, t5            // t5 = address of spin lock
        ldil    a0, DISPATCH_LEVEL      // new irql
        bis     a1, zero, t11           // t11 = a1, a1 may be clobbered

        SWAP_IRQL                       // a0 = new, on return v0 = old irql

//
// Try to acquire the specified spinlock.
//
// N.B. A noninterlocked test is done before the interlocked attempt. This
//      allows spinning without interlocked cycles.
//

#if !defined(NT_UP)

        LDP     t0, 0(t5)               // get current lock value
        bne     t0, 20f                 // if ne, lock owned
10:     LDP_L   t0, 0(t5)               // get current lock value
        bis     t5, zero, t3            // t3 = ownership value
        bne     t0, 20f                 // if ne, spin lock owned
        STP_C   t3, 0(t5)               // set lock owned
        beq     t3, 15f                 // if eq, store conditional failure
        mb                              // synchronize memory access

#endif

//
// The attempt to acquire the specified spin lock succeeded.
//
// Save the old Irql at the address saved by the caller.
// Insure that the old Irql is updated with longword granularity.
//

        ldq_u   t1, 0(t11)              // read quadword containing KIRQL
        bic     t11, 3, t2              // get address of containing longword
        mskbl   t1, t11, t1             // clear byte position of KIRQL
        bis     v0, zero, a0            // save old irql
        insbl   v0, t11, v0             // get KIRQL to correct byte
        bis     t1, v0, t1              // merge KIRQL into quadword
        extll   t1, t2, t1              // extract containing longword
        stl     t1, 0(t2)               // store containing longword
        ldil    v0, TRUE                // set return value
        ret     zero, (ra)              // return

//
// The attempt to acquire the specified spin lock failed. Lower IRQL to its
// previous value and return FALSE.
//
// N.B. The lower IRQL code is duplicated here is avoid any extra overhead
//      since this is such a common operation.
//

#if !defined(NT_UP)

20:     bis     v0, zero, a0            // set old IRQL value

        SWAP_IRQL                       // change back to old irql(a0)

        ldil    v0, FALSE               // set return to failed
        ret     zero, (ra)              // return

//
// Attempt to acquire spinlock failed.
//

15:     br      zero, 10b               // retry spinlock

#endif

        .end    KeTryToAcquireSpinLock

//++
//
// KIRQL
// KiAcquireSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function acquires a kernel spin lock.
//
//    N.B. This function assumes that the current IRQL is set properly.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a kernel spin lock.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiAcquireSpinLock)

        ALTERNATE_ENTRY(KeAcquireSpinLockAtDpcLevel)

#if !defined(NT_UP)

        GET_CURRENT_THREAD              // v0 = current thread address

10:     LDP_L   t2, 0(a0)               // get current lock value
        bis     v0, zero, t3            // set ownership value
        bne     t2, 15f                 // if ne, spin lock owned
        STP_C   t3, 0(a0)               // set spin lock owned
        beq     t3, 15f                 // if eq, store conditional failure
        mb                              // synchronize memory access
        ret     zero, (ra)              // return

//
// attempt to acquire spinlock failed.
//

15:     LDP     t2, 0(a0)               // get current lock value
        beq     t2, 10b                 // retry acquire lock if unowned
        br      zero, 15b               // loop in cache until lock free

#else

        ret     zero, (ra)              // return

#endif

        .end    KiAcquireSpinLock

//++
//
// VOID
// KiReleaseSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function releases a kernel spin lock.
//
//    N.B. This function assumes that the current IRQL is set properly.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to an executive spin lock.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiReleaseSpinLock)

        ALTERNATE_ENTRY(KeReleaseSpinLockFromDpcLevel)

#if !defined(NT_UP)

        mb                              // synchronize memory accesss
        STP    zero, 0(a0)             // set spin lock not owned

#endif

        ret     zero, (ra)              // return

        .end    KiReleaseSpinLock

//++
//
// KIRQL
// KiTryToAcquireSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function attempts to acquires the specified kernel spinlock. If
//    the spinlock can be acquired, then TRUE is returned. Otherwise, FALSE
//    is returned.
//
//    N.B. This function assumes that the current IRQL is set properly.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a kernel spin lock.
//
// Return Value:
//
//    If the spin lock is acquired, then a value of TRUE is returned.
//    Otherwise, a value of FALSE is returned.
//
//--

        LEAF_ENTRY(KiTryToAcquireSpinLock)

#if !defined(NT_UP)

        GET_CURRENT_THREAD              // v0 = current thread address

10:     LDP_L   t2, 0(a0)               // get current lock value
        bis     v0, zero, t3            // set ownership value
        bne     t2, 20f                 // if ne, spin lock owned
        STP_C   t3, 0(a0)               // set spin lock owned
        beq     t3, 15f                 // if eq, conditional store failed
        mb                              // synchronize memory access
        ldil    v0, TRUE                // set success return value
        ret     zero, (ra)              // return

20:     ldil    v0, FALSE               // set failure return value
        ret     zero, (ra)              // return

//
// Attempt to acquire spinlock failed.
//

15:     br      zero, 10b               // retry

#else

        ldil    v0, TRUE                // set success return value
        ret     zero, (ra)              // return

#endif

        .end    KiTryToAcquireSpinLock

//++
//
// BOOLEAN
// KeTestSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function tests a kernel spin lock.  If the spinlock is
//    busy, FALSE is returned.  If not, TRUE is returned.  The spinlock
//    is never acquired.  This is provided to allow code to spin at low
//    IRQL, only raising the IRQL when there is a reasonable hope of
//    acquiring the lock.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a kernel spin lock.
//
// Return Value:
//
//    TRUE  - Spinlock appears available
//    FALSE - SpinLock is busy
//--

#if !defined(NT_UP)

        LEAF_ENTRY(KeTestSpinLock)

        LDP     t0, (a0)                // get current spinlock value
        ldil    v0, 1                   // default TRUE
        cmovne  t0, zero, v0            // if t0 != 0, return FALSE
        ret     zero, (ra)              // return

        .end    KeTestSpinLock

#endif

        SBTTL("Acquire Queued SpinLock and Raise IRQL")
//++
//
// VOID
// KeAcquireInStackQueuedSpinLock (
//    IN PKSPIN_LOCK SpinLock,
//    IN PKLOCK_QUEUE_HANDLE LockHandle
//    )
//
// VOID
// KeAcquireInStackQueuedSpinLockRaiseToSynch (
//    IN PKSPIN_LOCK SpinLock,
//    IN PKLOCK_QUEUE_HANDLE LockHandle
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to either  synchronization or
//    dispatch level and acquires the specified queued spinlock.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a spin lock.
//
//    LockHandle (a1) - Supplies a pointer to a lock handle.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeAcquireInStackQueuedSpinLock)

        ldil    v0, DISPATCH_LEVEL      // get dispatch level IRQL
        br      zero, 5f                //

        ALTERNATE_ENTRY(KeAcquireInStackQueuedSpinLockRaiseToSynch)

        ldl     v0, KiSynchIrql         // get synch level IRQL

5:      mov     a1, t5                  // save address of lock handle

#if !defined(NT_UP)

        STP     zero, LqhNext(t5)       // set next link to NULL
        STP     a0, LqhLock(t5)         // set spin lock address
        mb                              // synchronize memory access

#endif

        mov     v0, a0                  // set new Irql value

        SWAP_IRQL                       // raise Irql to specified level

        stl     v0, LqhOldIrql(t5)      // save old IRQL

#if !defined(NT_UP)

        ADDP    t5, LqhNext, t5         // set address of lock queue
        br      zero, KxqAcquireQueuedSpinLock // finish in common code

#else

        ret     zero, (ra)              // return

#endif

        .end    KeAcquireInStackQueuedSpinLock

        SBTTL("Acquire Queued SpinLock and Raise IRQL")
//++
//
// KIRQL
// KeAcquireQueuedSpinLock (
//    IN KSPIN_LOCK_QUEUE_NUMBER Number
//    )
//
// KIRQL
// KeAcquireQueuedSpinLockRaiseToSynch (
//    IN KSPIN_LOCK_QUEUE_NUMBER Number
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to synchronization level and
//    acquires the specified queued spinlock.
//
// Arguments:
//
//    Number (a0) - Supplies the queued spinlock number.
//
// Return Value:
//
//    The previous IRQL is returned as the function value.
//
//--


        LEAF_ENTRY(KeAcquireQueuedSpinLock)

        addq    a0, a0, t5              // account for two addresses
        ldil    a0, DISPATCH_LEVEL      // get dispatch level IRQL
        br      zero, 5f                //

        ALTERNATE_ENTRY(KeAcquireQueuedSpinLockRaiseToSynch)

        addq    a0, a0, t5              // account for two addresses
        ldl     a0, KiSynchIrql         // get synch level IRQL

5:      SWAP_IRQL                       // raise Irql to specified level

#if !defined(NT_UP)

        bis     v0, zero, t0            // save previous Irql

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        SPADDP  t5, v0, t5              // entry address
        lda     t5, PbLockQueue(t5)     //

        ALTERNATE_ENTRY(KxqAcquireQueuedSpinLock)

        LDP     t4, LqLock(t5)          // get associated spinlock address
10:     LDP_L   t3, 0(t4)               // get current lock value
        bis     t5, zero, t2            // set lock ownership value
        STP_C   t2, 0(t4)               //
        beq     t2, 50f                 // if eq, conditional store failed
        bne     t3, 30f                 // if ne, lock already owned
        bis     t4, LOCK_QUEUE_OWNER, t4 // set lock owner bit in lock entry
        STP     t4, LqLock(t5)          //
        mb                              // synchronize subsequent reads
20:     bis     t0, zero, v0            // set old IRQL value

#endif

        ret     zero, (ra)              // return

//
// The lock is owned by another processor. Set the lock bit in the current
// processor lock queue entry, set the next link in the previous lock queue
// entry, and spin on the current processor's lock bit.
//

#if !defined(NT_UP)

30:     bis     t4, LOCK_QUEUE_WAIT, t4 // set lock wait bit in lock entry
        STP     t4, LqLock(t5)          //
        mb                              // synchronize memory access
        STP     t5, LqNext(t3)          // set address of lock queue entry
40:     LDP     t4, LqLock(t5)          // get lock address and lock wait bit
        blbc    t4, 20b                 // if lbc (lock wait), ownership granted
        br      zero, 40b               // try again

//
// Conditional store failed.
//

50:     br      zero, 10b               // try again

#endif

        .end    KeAcquireQueuedSpinLock


        SBTTL("Release Queued SpinLock and Lower IRQL")
//++
//
// VOID
// KeReleaseInStackQueuedSpinLock (
//    IN PKLOCK_QUEUE_HANDLE LockHandle
//    )
//
// Routine Description:
//
//    This function releases a queued spinlock and lowers the IRQL to its
//    previous value.
//
// Arguments:
//
//    LockHandle (a0) - Supplies a pointer to a lock handle.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeReleaseInStackQueuedSpinLock)

        ldl     t0, LqhOldIrql(a0)      // save old IRQL
        ADDP    a0, LqhNext, t5         // set address of lock queue
        br      zero, KxqReleaseQueuedSpinLock // finish in common code

        .end    KeReleaseInStackQueuedSpinLock

        SBTTL("Release Queued SpinLock and Lower IRQL")
//++
//
// VOID
// KeReleaseQueuedSpinLock (
//    IN KSPIN_LOCK_QUEUE_NUMBER Number,
//    IN KIRQL OldIrql
//    )
//
// Routine Description:
//
//    This function releases a queued spinlock and lowers the IRQL to its
//    previous value.
//
// Arguments:
//
//    Number (a0) - Supplies the queued spinlock number.
//
//    OldIrql (a1) - Supplies the previous IRQL value.
//
// Return Value:
//
//    None.
//
//--


        LEAF_ENTRY(KeReleaseQueuedSpinLock)

        bis     a1, zero, t0            // save old IRQL

#if !defined(NT_UP)

        addq    a0, a0, t5              // account for two addresses

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        SPADDP  t5, v0, t5              // compute per processor lock queue
        lda     t5, PbLockQueue(t5)     // entry address

#endif

        ALTERNATE_ENTRY(KxqReleaseQueuedSpinLock)

#if !defined(NT_UP)

        mb                              // synchronize memory access
        LDP     t4, LqLock(t5)          // get associated spin lock address
        bic     t4, LOCK_QUEUE_OWNER, t4 // clear lock owner bit in lock entry
10:     LDP_L   t3, 0(t4)               // get current lock ownership value
        xor     t3, t5, t2              // set lock ownership value
        bne     t2, 20f                 // if ne, another processor waiting
        STP_C   t2, 0(t4)               // set new ownership value
        beq     t2, 10b                 // if eq, conditional store failed
        STP     t4, LqLock(t5)          // store associated spin lock address
        mb                              // synchronize memory access

#endif

        bis     t0, zero, a0            // set old IRQL value

        SWAP_IRQL                       // lower IRQL to previous level

        ret     zero, (ra)              // return

//
// Another processor has inserted its lock queue entry in the lock queue,
// but has not yet written its lock queue entry address in the current
// processor's next link. Spin until the lock queue address is written.
//

#if !defined(NT_UP)

20:     LDP     t3, LqNext(t5)          // get next lock queue entry address
        beq     t3, 20b                 // if eq, address not written yet

//
// Grant the next process in the lock queue ownership of the spinlock.
//

        LDP     t2, LqLock(t3)          // get spinlock address and wait bit
        STP     zero, LqNext(t5)        // clear next lock queue entry address
        STP     t4, LqLock(t5)          // store associated spin lock address
        bic     t2, LOCK_QUEUE_WAIT, t2 // clear lock wait bit in lock entry
        bis     t2, LOCK_QUEUE_OWNER, t2 // set lock owner bit in lock entry
        STP     t2, LqLock(t3)          //
        mb                              // synchronize memory access
        bis     t0, zero, a0            // set old IRQL value

        SWAP_IRQL                       // lower IRQL to previous level

        ret     zero, (ra)              // return

#endif

        .end    KeReleaseQueuedSpinLock


        SBTTL("Try to Acquire Queued SpinLock and Raise IRQL")
//++
//
// LOGICAL
// KeTryToAcquireQueuedSpinLock (
//    IN KSPIN_LOCK_QUEUE_NUMBER Number
//    OUT PKIRQL OldIrql
//    )
//
// LOGICAL
// KeTryToAcquireQueuedSpinLockRaiseToSynch (
//    IN KSPIN_LOCK_QUEUE_NUMBER Number
//    OUT PKIRQL OldIrql
//    )
//
// Routine Description:
//
//    This function raises the current IRQL to synchronization level and
//    attempts to acquire the specified queued spinlock. If the spinlock
//    cannot be acquired, then IRQL is restored and FALSE is returned as
//    the function value. Otherwise, TRUE is returned as the function
//    value.
//
// Arguments:
//
//    Number (a0) - Supplies the queued spinlock number.
//
//    OldIrql  (a1) - Supplies a pointer to a variable that receives the
//        the previous IRQL value.
//
// Return Value:
//
//    If the spin lock is acquired, then a value of TRUE is returned.
//    Otherwise, a value of FALSE is returned.
//
//--

        LEAF_ENTRY(KeTryToAcquireQueuedSpinLock)

        addq    a0, a0, t5              // account for two addresses
        ldil    a0, DISPATCH_LEVEL      // get dispatch level irql
        br      zero, 5f                //

        ALTERNATE_ENTRY(KeTryToAcquireQueuedSpinLockRaiseToSynch)

        addq    a0, a0, t5              // account for two addresses
        ldl     a0, KiSynchIrql         // get synch level irql
5:      bis     a1, zero, t0            // save previous irql address

        SWAP_IRQL                       // raise irql to specified level

        bis     v0, zero, t1            // save previous irql

#if !defined(NT_UP)

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        SPADDP  t5, v0, t5              // compute per processor lock queue
        lda     t5, PbLockQueue(t5)     // entry address
        LDP     t4, LqLock(t5)          // get associated spinlock address

//
// Try to acquire the specified spinlock.
//
// N.B. A noninterlocked test is done before the interlocked attempt. This
//      allows spinning without interlocked cycles.
//

        LDP     t3, 0(t4)               // get current lock value
        bne     t3, 20f                 // if ne, lock owned
10:     LDP_L   t3, 0(t4)               // get current lock value
        bis     t5, zero, t2            // set lock ownership value
        bne     t3, 20f                 // if ne, spin lock owned
        STP_C   t2, 0(t4)               // set lock owned
        beq     t2, 30f                 // if eq, store conditional failure

//
// The attempt to acquire the specified spin lock succeeded. Set the spin
// lock owner bit and save the old irql at the address specified by the
// caller. Insure that the old Irql is updated with longword granularity.
//

        bis     t4, LOCK_QUEUE_OWNER, t4 // set lock owner bit in lock entry
        STP     t4, LqLock(t5)          //
        mb                              // synchronize memory access

#endif

        ldq_u   t2, 0(t0)               // get quadword containing irql
        bic     t0, 3, t3               // get containing longword address
        mskbl   t2, t0, t2              // clear byte position of Irql
        insbl   t1, t0, t1              // shift irql to correct byte
        bis     t2, t1, t2              // merge irql into quadword
        extll   t2, t3, t2              // extract containing longword
        stl     t2, 0(t3)               // store containing longword
        ldil    v0, TRUE                // set return value
        ret     zero, (ra)              // return

//
// The attempt to acquire the specified spin lock failed. Lower IRQL to its
// previous value and return FALSE.
//

#if !defined(NT_UP)

20:     bis     t1, zero, a0            // set old irql value

        SWAP_IRQL                       // lower irql to previous level

        ldil    v0, FALSE               // set return value
        ret     zero, (ra)              // return

//
// Attempt to acquire spinlock failed.
//

30:     br      zero, 10b               // retry spinlock

#endif

        .end    KeTryToAcquireQueuedSpinLock


        SBTTL("Acquire Queued SpinLock at Current IRQL")
//++
// VOID
// KeAcquireInStackQueuedSpinLockAtDpcLevel (
//    IN PKSPIN_LOCK SpinLock,
//    IN PKLOCK_QUEUE_HANDLE LockHandle
//    )
//
// Routine Description:
//
//    This function acquires the specified queued spinlock at the current
//    IRQL.
//
// Arguments:
//
//    SpinLock (a0) - Supplies the address of a spin lock.
//
//    LockHandle (a1) - Supplies the address of an in stack lock handle.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeAcquireInStackQueuedSpinLockAtDpcLevel)

#if !defined(NT_UP)

        STP     zero, LqhNext(a1)       // set next link to NULL
        STP     a0, LqhLock(a1)         // set spin lock address

#endif

        ADDP    a1, LqhNext, a0         // compute address of lock queue

//++
//
// VOID
// KeAcquireQueuedSpinLockAtDpcLevel (
//    IN PKSPIN_LOCK_QUEUE LockQueue
//    )
//
// Routine Description:
//
//    This function acquires the specified queued spinlock at the current
//    IRQL.
//
// Arguments:
//
//    LockQueue (a0) - Supplies the address of the lock queue entry.
//
// Return Value:
//
//    None.
//
//--

        ALTERNATE_ENTRY(KeAcquireQueuedSpinLockAtDpcLevel)

#if !defined(NT_UP)

        mb                              // synchronize memory access
        LDP     t4, LqLock(a0)          // get associated spinlock address
10:     LDP_L   t3, 0(t4)               // get current lock value
        bis     a0, zero, t2            // set lock ownership value
        STP_C   t2, 0(t4)               //
        beq     t2, 50f                 // if eq, conditional store failed
        bne     t3, 30f                 // if ne, lock already owned
        bis     t4, LOCK_QUEUE_OWNER, t4 // set lock owner bit in lock entry
        STP     t4, LqLock(a0)          //
        mb                              // synchronize subsequent reads

#endif

20:     ret     zero, (ra)              // return

//
// The lock is owned by another processor. Set the lock bit in the current
// processor lock queue entry, set the next link in the previous lock queue
// entry, and spin on the current processor's lock bit.
//

#if !defined(NT_UP)

30:     bis     t4, LOCK_QUEUE_WAIT, t4 // set lock wait bit in lock entry
        STP     t4, LqLock(a0)          //
        mb                              // synchronize memory access
        STP     a0, LqNext(t3)          // set address of lock queue entry
40:     LDP     t4, LqLock(a0)          // get lock address and lock wait bit
        blbc    t4, 20b                 // if lbc (lock wait), ownership granted
        br      zero, 40b               // try again

//
// Conditional store failed.
//

50:     br      zero, 10b               // try again

#endif

        .end    KeAcquireInStackQueuedSpinLockAtDpcLevel


        SBTTL("Release Queued SpinLock at Current IRQL")
//++
//
// VOID
// KeReleaseInStackQueuedSpinLockFromDpcLevel (
//    IN PKLOCK_QUEUE_HANDLE LockHandle
//    )
//
// Routine Description:
//
//    This function releases a queued spinlock and preserves the current
//    IRQL.
//
// Arguments:
//
//    LockHandle (a0) - Supplies the address of a lock handle.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeReleaseInStackQueuedSpinLockFromDpcLevel)

        ADDP    a0, LqhNext, a0         // compute address of lock queue

//++
//
// VOID
// KeReleaseQueuedSpinLockFromDpcLevel (
//    IN PKSPIN_LOCK_QUEUE LockQueue
//    )
//
// Routine Description:
//
//    This function releases a queued spinlock and preserves the current
//    IRQL.
//
// Arguments:
//
//    LockQueue (a0) - Supplies the address of the lock queue entry.
//
// Return Value:
//
//    None.
//
//--

        ALTERNATE_ENTRY(KeReleaseQueuedSpinLockFromDpcLevel)

#if !defined(NT_UP)

        mb                              // synchronize memory access
        LDP     t4, LqLock(a0)          // get associate spin lock address
        bic     t4, LOCK_QUEUE_OWNER, t4 // clear lock owner bit in lock entry
10:     LDP_L   t3, 0(t4)               // get current lock ownership value
        xor     t3, a0, t2              // set lock ownership value
        bne     t2, 20f                 // if ne, another processor waiting
        STP_C   t2, 0(t4)               // set new ownership value
        beq     t2, 10b                 // if eq, conditional store failed
        STP     t4, LqLock(a0)          //
        mb                              // synchronize memory access
        ret     zero, (ra)              // return

//
// Another processor has inserted its lock queue entry in the lock queue,
// but has not yet written its lock queue entry address in the current
// processor's next link. Spin until the lock queue address is written.
//

20:     LDP     t3, LqNext(a0)          // get next lock queue entry address
        beq     t3, 20b                 // if eq, address not written yet

//
// Grant the next process in the lock queue ownership of the spinlock.
//

        LDP     t2, LqLock(t3)          // get spinlock address and lock bit
        STP     zero, LqNext(a0)        // clear next lock queue entry address
        STP     t4, LqLock(a0)          //
        bic     t2, LOCK_QUEUE_WAIT, t2 // clear lock wait bit in lock entry
        bis     t2, LOCK_QUEUE_OWNER, t2 // set lock owner bit in lock entry
        STP     t2, LqLock(t3)          //
        mb                              // synchronize memory access

#endif

        ret     zero, (ra)              // return

        .end    KeReleaseInStackQueuedSpinLockFromDpcLevel
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\regsav.s ===
//      TITLE("Register Save and Restore")
//++
//
// Copyright (c) 1992 Digital Equipment Corporation
//
// Module Name:
//
//      regsav.s
//
// Abstract:
//
//      Implements save/restore general purpose processor
//      registers during exception handling
//
// Author:
//
//      Joe Notarangelo 06-May-1992
//
// Environment:
//
//      Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

        SBTTL("Generate Trap Frame")
//++
//
// Routine Description:
//
//     Save volatile register state (integer/float) in
//     a trap frame.
//
//     Note: control registers, ra, sp, fp, gp have already
//     been saved, argument registers a0-a3 have also been saved.
//
// Arguments:
//
//     fp - Supplies a pointer to the trap frame.
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(KiGenerateTrapFrame)

        stq     v0, TrIntV0(fp)         // save integer register v0
        stq     t0, TrIntT0(fp)         // save integer registers t0 - t7
        stq     t1, TrIntT1(fp)         //
        stq     t2, TrIntT2(fp)         //
        stq     t3, TrIntT3(fp)         //
        stq     t4, TrIntT4(fp)         //
        stq     t5, TrIntT5(fp)         //
        stq     t6, TrIntT6(fp)         //
        stq     t7, TrIntT7(fp)         //
        stq     a4, TrIntA4(fp)         // save integer registers a4 - a5
        stq     a5, TrIntA5(fp)         //
        stq     t8, TrIntT8(fp)         // save integer registers t8 - t12
        stq     t9, TrIntT9(fp)         //
        stq     t10, TrIntT10(fp)       //
        stq     t11, TrIntT11(fp)       //
        stq     t12, TrIntT12(fp)       //

        .set    noat
        stq     AT, TrIntAt(fp)         // save integer register AT
        .set    at

        br      zero, KiSaveVolatileFloatState // save volatile float state

        .end    KiGenerateTrapFrame

        SBTTL("Restore Trap Frame")
//++
//
// Routine Description:
//
//     Restore volatile register state (integer/float) from
//     a trap frame
//
//     Note: control registers, ra, sp, fp, gp will be
//     restored by the PALcode, as will argument registers a0-a3.
//
// Arguments:
//
//     fp - Supplies a pointer to trap frame.
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(KiRestoreTrapFrame)

        ldq     v0, TrIntV0(fp)         // restore integer register v0
        ldq     t0, TrIntT0(fp)         // restore integer registers t0 - t7
        ldq     t1, TrIntT1(fp)         //
        ldq     t2, TrIntT2(fp)         //
        ldq     t3, TrIntT3(fp)         //
        ldq     t4, TrIntT4(fp)         //
        ldq     t5, TrIntT5(fp)         //
        ldq     t6, TrIntT6(fp)         //
        ldq     t7, TrIntT7(fp)         //
        ldq     a4, TrIntA4(fp)         // restore integer registers a4 - a5
        ldq     a5, TrIntA5(fp)         //
        ldq     t8, TrIntT8(fp)         // restore integer registers t8 - t12
        ldq     t9, TrIntT9(fp)         //
        ldq     t10, TrIntT10(fp)       //
        ldq     t11, TrIntT11(fp)       //
        ldq     t12, TrIntT12(fp)       //

        .set    noat
        ldq     AT, TrIntAt(fp)         // restore integer register AT
        .set    at

//
// Restore the volatile floating register state
//

        br      zero, KiRestoreVolatileFloatState //

        .end    KiRestoreTrapFrame

        SBTTL("Save Volatile Floating Registers")
//++
//
// Routine Description:
//
//     Save volatile floating registers in a trap frame.
//
// Arguments:
//
//     fp - Supplies a pointer to the trap frame.
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(KiSaveVolatileFloatState)

        //
        // asaxp is broken, it does not know that mf_fpcr f0
        // destroys f0.
        //

        .set noreorder
        stt     f0, TrFltF0(fp)         // save floating register f0
        mf_fpcr f0                      // save fp control register
        .set reorder

        stt     f0, TrFpcr(fp)          //
        stt     f1, TrFltF1(fp)         // save floating register f1
        stt     f10, TrFltF10(fp)       // save floating registers f10 - f30
        stt     f11, TrFltF11(fp)       //
        stt     f12, TrFltF12(fp)       //
        stt     f13, TrFltF13(fp)       //
        stt     f14, TrFltF14(fp)       //
        stt     f15, TrFltF15(fp)       //
        stt     f16, TrFltF16(fp)       //
        stt     f17, TrFltF17(fp)       //
        stt     f18, TrFltF18(fp)       //
        stt     f19, TrFltF19(fp)       //
        stt     f20, TrFltF20(fp)       //
        stt     f21, TrFltF21(fp)       //
        stt     f22, TrFltF22(fp)       //
        stt     f23, TrFltF23(fp)       //
        stt     f24, TrFltF24(fp)       //
        stt     f25, TrFltF25(fp)       //
        stt     f26, TrFltF26(fp)       //
        stt     f27, TrFltF27(fp)       //
        stt     f28, TrFltF28(fp)       //
        stt     f29, TrFltF29(fp)       //
        stt     f30, TrFltF30(fp)       //

        ret     zero, (ra)              // return

        .end    KiSaveVolatileFloatState

        SBTTL("Restore Volatile Floating State")
//++
//
// Routine Description:
//
//     Restore volatile floating registers from a trap frame.
//
//
// Arguments:
//
//     fp - pointer to trap frame
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(KiRestoreVolatileFloatState)

        ldt     f0, TrFpcr(fp)          // restore fp control register
        mt_fpcr f0                      //
        ldt     f0, TrFltF0(fp)         // restore floating registers f0 - f1
        ldt     f1, TrFltF1(fp)         //
        ldt     f10, TrFltF10(fp)       // restore floating registers f10 - f30
        ldt     f11, TrFltF11(fp)       //
        ldt     f12, TrFltF12(fp)       //
        ldt     f13, TrFltF13(fp)       //
        ldt     f14, TrFltF14(fp)       //
        ldt     f15, TrFltF15(fp)       //
        ldt     f16, TrFltF16(fp)       //
        ldt     f17, TrFltF17(fp)       //
        ldt     f18, TrFltF18(fp)       //
        ldt     f19, TrFltF19(fp)       //
        ldt     f20, TrFltF20(fp)       //
        ldt     f21, TrFltF21(fp)       //
        ldt     f22, TrFltF22(fp)       //
        ldt     f23, TrFltF23(fp)       //
        ldt     f24, TrFltF24(fp)       //
        ldt     f25, TrFltF25(fp)       //
        ldt     f26, TrFltF26(fp)       //
        ldt     f27, TrFltF27(fp)       //
        ldt     f28, TrFltF28(fp)       //
        ldt     f29, TrFltF29(fp)       //
        ldt     f30, TrFltF30(fp)       //

        ret     zero, (ra)              // return

        .end    KiRestoreVolatileFloatState

        SBTTL("Save Non-Volatile Floating State")
//++
//
// Routine Description:
//
//      Save nonvolatile floating registers in
//      an exception frame
//
//
// Arguments:
//
//      sp - pointer to exception frame
//
// Return Value:
//
//      None.
//
//--

        LEAF_ENTRY(KiSaveNonVolatileFloatState)

        stt     f2, ExFltF2(sp)         // save floating registers f2 - f9
        stt     f3, ExFltF3(sp)         //
        stt     f4, ExFltF4(sp)         //
        stt     f5, ExFltF5(sp)         //
        stt     f6, ExFltF6(sp)         //
        stt     f7, ExFltF7(sp)         //
        stt     f8, ExFltF8(sp)         //
        stt     f9, ExFltF9(sp)         //

        ret     zero, (ra)              // return

        .end    KiSaveNonVolatileFloatState

        SBTTL("Restore Non-Volatile Floating State")
//++
//
// Routine Description:
//
//     Restore nonvolatile floating registers from an exception frame.
//
//
// Arguments:
//
//     sp - Supplies a pointer to an exception frame.
//
// Return Value:
//
//      None.
//
//--


        LEAF_ENTRY(KiRestoreNonVolatileFloatState)

        ldt     f2, ExFltF2(sp)         // restore floating registers f2 - f9
        ldt     f3, ExFltF3(sp)         //
        ldt     f4, ExFltF4(sp)         //
        ldt     f5, ExFltF5(sp)         //
        ldt     f6, ExFltF6(sp)         //
        ldt     f7, ExFltF7(sp)         //
        ldt     f8, ExFltF8(sp)         //
        ldt     f9, ExFltF9(sp)         //

        ret     zero, (ra)              // return

        .end    KiRestoreNonVolatileFloatState

        SBTTL("Save Volatile Integer State")
//++
//
// Routine Description:
//
//     Save volatile integer register state in a trap frame.
//
//     Note: control registers, ra, sp, fp, gp have already been saved
//     as have argument registers a0-a3.
//
// Arguments:
//
//      fp - Supplies a pointer to the trap frame.
//
// Return Value:
//
//      None.
//
//--

        LEAF_ENTRY( KiSaveVolatileIntegerState)

        stq     v0, TrIntV0(fp)         // save integer register v0
        stq     t0, TrIntT0(fp)         // save integer registers t0 - t7
        stq     t1, TrIntT1(fp)         //
        stq     t2, TrIntT2(fp)         //
        stq     t3, TrIntT3(fp)         //
        stq     t4, TrIntT4(fp)         //
        stq     t5, TrIntT5(fp)         //
        stq     t6, TrIntT6(fp)         //
        stq     t7, TrIntT7(fp)         //
        stq     a4, TrIntA4(fp)         // save integer registers a4 - a5
        stq     a5, TrIntA5(fp)         //
        stq     t8, TrIntT8(fp)         // save integer registers t8 - t12
        stq     t9, TrIntT9(fp)         //
        stq     t10, TrIntT10(fp)       //
        stq     t11, TrIntT11(fp)       //
        stq     t12, TrIntT12(fp)       //

        .set    noat
        stq     AT, TrIntAt(fp)         // save integer register AT
        .set    at

        ret     zero, (ra)              // return

        .end    KiSaveVolatileIntegerState

        SBTTL("Restore Volatile Integer State")
//++
//
// Routine Description:
//
//     Restore volatile integer register state from a trap frame.
//
//     Note: control registers, ra, sp, fp, gp and argument registers
//     a0 - a3 will be restored by the PALcode.
//
// Arguments:
//
//     fp - Supplies a pointer to the trap frame.
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(KiRestoreVolatileIntegerState)

        ldq     v0, TrIntV0(fp)         // restore integer register v0
        ldq     t0, TrIntT0(fp)         // restore integer registers t0 - t7
        ldq     t1, TrIntT1(fp)         //
        ldq     t2, TrIntT2(fp)         //
        ldq     t3, TrIntT3(fp)         //
        ldq     t4, TrIntT4(fp)         //
        ldq     t5, TrIntT5(fp)         //
        ldq     t6, TrIntT6(fp)         //
        ldq     t7, TrIntT7(fp)         //
        ldq     a4, TrIntA4(fp)         // restore integer registers a4 - a5
        ldq     a5, TrIntA5(fp)         //
        ldq     t8, TrIntT8(fp)         // restore integer registers t8 - t12
        ldq     t9, TrIntT9(fp)         //
        ldq     t10, TrIntT10(fp)       //
        ldq     t11, TrIntT11(fp)       //
        ldq     t12, TrIntT12(fp)       //

        .set    noat
        ldq     AT, TrIntAt(fp)         // restore integer register AT
        .set    at

        ret     zero, (ra)              // return

        .end    KiRestoreVolatileIntegerState

        SBTTL("Save Floating Point State")
//++
//
// Routine Description:
//
//     This routine saves the thread's current non-volatile NPX state,
//     and sets a new initial floating point state for the caller.
//
//     This is intended for use by kernel-mode code that needs to use
//     the floating point registers. Must be paired with
//     KeRestoreFloatingPointState
//
//     N.B. Currently this saves only the hardware FPCR. Software
//          emulation is not supported. Floating point from within
//          a DPC is not supported.
//
// Arguments:
//
//     a0 - Supplies pointer to KFLOATING_SAVE structure
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(KeSaveFloatingPointState)

        //
        // Generate default FPCR value
        //

        ldiq    t0, 0x0800000000000000
        stq     t0, KfsReserved1(a0)
        ldt     f1, KfsReserved1(a0)

        //
        // asaxp is broken, it does not know that mf_fpcr f0
        // destroys f0.
        //

        .set noreorder
        mf_fpcr f0                      // save fp control register
        .set reorder

        stt     f0, KfsFpcr(a0)         //

        //
        // Set default mode - ROUND_TO_NEAREST
        //

        mt_fpcr f1                      //
        bis     zero, zero, v0          // always return success
        ret     zero, (ra)              // return

        .end    KeSaveFloatingPointState

        SBTTL("Restore Floating Point State")
//++
//
// Routine Description:
//
//     This routine restores the thread's current non-volatile NPX state,
//     to the passed in state.
//
//     This is intended for use by kernel-mode code that needs to use
//     the floating point registers. Must be paired with
//     KeSaveFloatingPointState
//
//     N.B. Currently this restores only the hardware FPCR. Software
//          emulation is not supported. Floating point from within
//          a DPC is not supported.
//
// Arguments:
//
//     a0 - Supplies pointer to KFLOATING_SAVE structure
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(KeRestoreFloatingPointState)

        ldt     f0, KfsFpcr(a0)         // restore fp control register
        mt_fpcr f0                      //
        bis     zero, zero, v0          // always return success
        ret     zero, (ra)              // return

        .end    KeRestoreFloatingPointState


        SBTTL("Save State For Hibernate")
//++
//
//  VOID
//  KeSaveStateForHibernate(
//      IN PKPROCESSOR_STATE ProcessorState
//      )
//  /*++
//
//  Routine Description:
//
//      Saves all processor-specific state that must be preserved
//      across an S4 state (hibernation).
//
//  Arguments:
//
//      ProcessorState - Supplies the KPROCESSOR_STATE where the
//          current CPU's state is to be saved.
//
//  Return Value:
//
//      None.
//
//--
        .struct 0
KsRa:   .space  8
KsA0:   .space  8
SaveStateLength:
        NESTED_ENTRY(KeSaveStateForHibernate, SaveStateLength,zero)
        lda     sp, -SaveStateLength(sp)    // allocate stack frame
        stq     ra, KsRa(sp)                // save return address
        PROLOGUE_END

        stq     a0, KsA0(sp)
        bsr     ra, RtlCaptureContext
        ldq     t1, KsA0(sp)                // get copy of context pointer
        lda     a1, CxIntA1(t1)             // SleepData pointer will be restored to a1

//    
// The processor context when calling cp_sleep is the one that will be
// restored by the PAL code when doing the restore. A0 contains the 
// address at which execution will resume. We resume in this function so
// that SP gets readjusted to the callers value. However, we must be
// careful not to reference anything in our stack frame after a resume
// as that data was not saved to disk.
//

        lda     a0, do_return               // address at which restore continues execution
        ldq     ra, KsRa(sp)                // address to return to after continuing
        ldil    v0, 0                       // return value on wakeup
        call_pal    cp_sleep                // save PAL state

//
// v0 is now the PALmode (physical) address of the PALcode restore routine, i.e. where
// to jump to in PALmode.  
//
        stq     v0, CxIntA2(t1)             // it will be in a2        

// Set the address to start up at when first entered (the swppal to enter PALmode).

        lda     t2, reentry             // address of startup code below
        stq     t2, CxFir(t1)           // store startup address in CONTEXT        

//
// Set the address for swppal to transfer control to in PALmode.  This must be in a0
// when swppal is executed.
//
        lda     t3, gorestore           // address of transfer to restore below
        sll     t3, 33, t3              // clear high-order 33 bits to convert
        srl     t3, 33, t3              //  to PALmode physical address
        stq     t3, CxIntA0(t1)

//
// Return.
//
        ldq     ra, KsRa(sp)                // restore return address
do_return:
        lda     sp, SaveStateLength(sp)     // deallocate stack frame
        ret     zero, (ra)                  // return

//
// This is where the OS Loader transfers control back to NT.  The CONTEXT was
// set up to direct execution here with registers set as follows:
//
//     a0 - PALmode address of code to be executed in PALmode (gorestore)
//     a1 - pointer to the SleepData structure (returned by sleep)
//     a2 - PALmode address of the restore routine (returned by sleep)
//
// All other registers are presently "don't care", but the code in OS Loader
// that transfers control should restore the entire CONTEXT so that it remains
// compatible even if this convention changes.

reentry:

#if defined(DBG_LEDS)

// LED display: F1

        ldiq    t0, 0xfffffc0000000000+0x87A0000180
        ldil    t1, 0xF1
        stq     t1, (t0)
        mb

        ldil    t0, 166666666
1:
        subl    t0, 1, t0
        bne     t0, 1b

#endif

        call_pal swppal                 // simply enter PALmode, transfer to
                                        // following code

//
// Control is transferred here in PALmode by swppal. a1 contains the pointer
// to the SleepData structure, and a2 contains the PALmode address of the
// restore routine.
//

gorestore:

#if defined(DBG_LEDS)

// LED display: F2

        ldiq    t0, 0xfffffc0000000000+0x87A0000180
        ldil    t1, 0xF2
        stq     t1, (t0)
        mb

        ldil    t0, 166666666
1:
        subl    t0, 1, t0
        bne     t0, 1b

#endif

        bis     a1, 0, a0               // restore needs SleepData pointer in a0
        jmp     (a2)                     // jump to restore routine

        .end KeSaveStateForHibernate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\tb.s ===
//      TITLE("Flush Translation Buffers")
//++
//
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    tb.s
//
// Abstract:
//
//    This module implements the code to flush the tbs on the current
//      processor.
//
// Author:
//
//    Joe Notarangelo 21-apr-1992
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

        SBTTL("Flush All Translation Buffers")
//++
//
// VOID
// KiFlushEntireTb(
//    )
//
// Routine Description:
//
//     This function flushes the data and instruction tbs on the current
//     processor.  All entries are flushed with the exception of any entries
//     that are fixed in the tb (either in hdw or via sfw).
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiFlushEntireTb)

        TB_INVALIDATE_ALL               // invalidate all tb entries

        ret     zero, (ra)              // return

        .end    KiFlushEntireTb

        SBTTL("Flush All Translation Buffers")
//++
//
// VOID
// KeFlushCurrentTb(
//    )
//
// Routine Description:
//
//     This function flushes the data and instruction tbs on the current
//     processor.  All entries are flushed with the exception of any entries
//     that are fixed in the tb (either in hdw or via sfw).
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KeFlushCurrentTb)

        TB_INVALIDATE_ALL               // invalidate all tb entries

        ret     zero, (ra)              // return

        .end    KeFlushCurrentTb

        SBTTL("Flush Single 32-bit Translation Buffer")
//++
//
// VOID
// KiFlushSingleTb
//    IN BOOLEAN Invalid,
//    IN PVOID Virtual
//
// Routine Description:
//
//     This function flushes a single entry from both the instruction
//     and data translation buffers.  Note: it may flush more that just
//     the single entry.
//
// Arguments:
//
//    Invalid (a0) - Supplies a boolean variable that determines the reason that
//      that the TB entry is being flushed.
//
//    Virtual (a1) - Supplies the virtual address of the entry that is to be
//      flushed from the buffers.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiFlushSingleTb)

        bis     a1, zero, a0            // set virtual address to flush

        TB_INVALIDATE_SINGLE            // flush va(a0) from tbs

        ret     zero, (ra)              // return

        .end    KiFlushSingleTb

        SBTTL("Flush Single 64-bit Translation Buffer")
//++
//
// VOID
// KiFlushSingleTb64
//    IN BOOLEAN Invalid,
//    IN PVOID Virtual
//
// Routine Description:
//
//     This function flushes a single entry from both the instruction
//     and data translation buffers.  Note: it may flush more that just
//     the single entry.
//
// Arguments:
//
//    Invalid (a0) - Supplies a boolean variable that determines the reason that
//      that the TB entry is being flushed.
//
//    Virtual (a1) - Supplies the virtual page number of the entry that is to be
//      flushed from the buffers.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiFlushSingleTb64)

        bis     a1, zero, a0            // a0 = va to flush

        TB_INVALIDATE_SINGLE64          // flush va(a0) from tbs

        ret     zero, (ra)              // return

        .end    KiFlushSingleTb64

        SBTTL("Flush Multiple 32-bit Translation Buffer")
//++
//
// VOID
// KiFlushMultipleTb (
//    IN BOOLEAN Invalid,
//    IN PVOID *Virtual,
//    IN ULONG Count
//    )
//
// Routine Description:
//
//    This function flushes multiple entries from the translation buffer.
//
// Arguments:
//
//    Invalid (a0) - Supplies a boolean variable that determines the reason
//       that the TB entry is being flushed.
//
//    Virtual (a1) - Supplies a pointer to an array of virtual addresses of
//       the entries that are flushed from the translation buffer.
//
//    Count (a2) - Supplies the number of TB entries to flush.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiFlushMultipleTb)

        bis     a1, zero, a0            // a0 = pointer to array
        bis     a2, zero, a1            // a1 = count

        TB_INVALIDATE_MULTIPLE          // invalidate the entries

        ret     zero, (ra)              // return

        .end    KiFlushMultipleTb

        SBTTL("Flush Multiple 64-bit Translation Buffer")
//++
//
// VOID
// KiFlushMultipleTb64 (
//    IN BOOLEAN Invalid,
//    IN PVOID *Virtual,
//    IN ULONG Count
//    )
//
// Routine Description:
//
//    This function flushes multiple entries from the translation buffer.
//
// Arguments:
//
//    Invalid (a0) - Supplies a boolean variable that determines the reason
//       that the TB entry is being flushed.
//
//    Virtual (a1) - Supplies a pointer to an array of virtual page numbers
//       for the entries that are flushed from the translation buffer.
//
//    Count (a2) - Supplies the number of TB entries to flush.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiFlushMultipleTb64)

        bis     a1, zero, a0            // a0 = pointer to array
        bis     a2, zero, a1            // a1 = count

        TB_INVALIDATE_MULTIPLE64        // invalidate the entries

        ret     zero, (ra)              // return

        .end    KiFlushMultipleTb64

        SBTTL("Flush Single Data Translation Buffer")
//++
//
// VOID
// KiFlushSingleDataTb(
//    )
//
// Routine Description:
//
//    This function flushes a single entry for the data tb only.
//
// Arguments:
//
//    VirtualAddress(a0) - Supplies the virtual address of the entry
//      that is to be flushed from the data translations.
//
// Return Value:
//
//    None.
//
//--

        LEAF_ENTRY(KiFlushSingleDataTb)

        DATA_TB_INVALIDATE_SINGLE       // flush va(a0) from data tbs

        ret     zero, (ra)              // return

        .end    KiFlushSingleDataTb

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\start.s ===
//      TITLE( "Start System" )
//++
//
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module:
//
//    start.s
//
// Abstract:
//
//     This module implements the code necessary to iniitially start NT
//     on an alpha - it includes the routine that first receives control
//     when the loader executes the kernel.
//
// Author:
//
//     Joe Notarangelo  02-Apr-1992
//
// Environment:
//
//     Kernel Mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

//
// Define the total frame size.
//

#define TotalFrameLength (KERNEL_STACK_SIZE - (TrapFrameLength + \
                            ExceptionFrameLength) )

//
// Define variables to hold the address of the PCR and current thread
// on uniprocessor systems.
//

        .data

#ifdef NT_UP

        .globl  KiPcrBaseAddress
KiPcrBaseAddress:
        .quad   0 : 1

        .globl  KiCurrentThread
KiCurrentThread:
        .quad   0 : 1

#endif //NT_UP

        SBTTL( "System Startup" )
//++
//
// Routine Description:
//
//     This routine represents the final stage of the loader and is also
//     executed as each additional processor is brought online is a multi-
//     processor system. It is responsible for installing the loaded PALcode
//     image and transfering control kernel startup code.
//
//     N.B. This code assumes that the I-cache is coherent.
//
//     N.B. This routine does not execute in the context of the operating
//          system but instead executes in the context of the firmware
//          PAL environment.  This routine can only use those services
//          guaranteed to exist in the firmware.  The only PAL services
//          that can be counted on are: swppal, imb, and halt.
//
// Arguments:
//
//     a0 - Supplies pointer to loader parameter block.
//
// Return Value:
//
//     None.
//
//--

        .struct 0
SsRa:   .space  8                       // Save ra
        .space  8                       // for stack alignment
SsFrameLength:                          //

        NESTED_ENTRY(KiSystemStartup, SsFrameLength, ra)

        ALTERNATE_ENTRY(KiStartProcessor)

        lda     sp, -SsFrameLength(sp)  // allocate stack frame
        stq     ra, SsRa(sp)            // save return address

        PROLOGUE_END

//
// Save the loader block address in a register that is preserved during
// the pal swap.
//

        ldl     s0, LpbPcrPage(a0)      // get PCR page frame number
        LDIP    s1, KSEG0_BASE          // get kseg0 base address
        bis     a0, zero, s2            //
        ldl     s3, LpbPdrPage(s2)      // get pdr page number
        sll     s3, PAGE_SHIFT, s3      // compute virtual address of PDR
        bis     s3, s1, s3              //

//
// Swap PAL code and enter the kernel initialization routine.
//
//      a0 - Physical base address of PAL.
//      a1 - Page frame number of PCR.
//      a2 - The virtual address of the PDR (AXP64 systems only).
//      ra - Return address from PAL call.
//

        LDP     a0, LpbPalBaseAddress(s2) // get PAL base address
        sll     a0, 32 + 3, a0          // clear upper address bits
        srl     a0, 32 + 3, a0          //
        bis     s0, zero, a1            // set PCR page frame number
        bis     s3, zero, a2            // set level 1 page directory address
        lda     ra, KiStartupContinue   // set return address

        SWPPAL                          // swap PAL images

//
// Control should never get here!
//

        ldq     ra, SsRa(sp)            // Restore ra
        lda     sp, SsFrameLength(sp)   // Restore stack pointer
        ret     zero, (ra)              // shouldn't get here

        .end    KiSystemStartup

        SBTTL( "Startup Continue" )
//++
//
// Routine Description:
//
//     This routine is called when NT begins execution after loading the
//     Kernel environment from the PAL. It registers exception routines
//     and system values with the pal code, calls kernel initialization
//     and falls into the idle thread code.
//
// Arguments:
//
//     s0 - Supplies the PCR page frame number.
//
//     s1 - Supplies the base address of KSEG0.
//
//     s2 - Supplies a pointer to the loader parameter block.
//
//     s3 - Supplies the virtual address of the PDR.
//
// Return Value:
//
//     None.
//
//--

        LEAF_ENTRY(KiStartupContinue)

//
// Set kernel stack pointer and kernel global pointer from loader
// parameter block.
//

        LDP     sp, LpbKernelStack(s2)  // set kernel stack pointer
        LDP     gp, LpbGpBase(s2)       // set kernel global pointer

//
//  Initialize PAL values, sp, gp, pcr, pdr, initial thread.
//
// sp - Kernel stack pointer.
// gp - System global pointer.
// a0 - Page directory (PDR) address.
// a1 - Idle thread address.
// a2 - Idle thread Teb address.
// a3 - Panic stack address.
// a4 - Maximum kernel stack allocation size.
//

        bis     s3, zero, a0            // set level 1 page directory address
        LDP     a1, LpbThread(s2)       // get idle thread address
        bis     zero, zero, a2          // zero Teb for initial thread
        LDP     a3, LpbPanicStack(s2)   // get panic stack base
        ldil    a4, TotalFrameLength    // set maximum kernel stack size

        INITIALIZE_PAL

//
// Save copies of the per processor values in global variables for
// uniprocessor systems.
//

        sll     s0, PAGE_SHIFT, s0      // compute physical address of pcr
        bis     s0, s1, s0              // compute address of pcr

#ifdef NT_UP

        lda     t0, KiPcrBaseAddress    // save PCR address
        STP     s0, 0(t0)               //
        LDP     t1, LpbThread(s2)       // get idle thread address
        lda     t0, KiCurrentThread     // save idle thread address
        STP     t1, 0(t0)               //

#endif //NT_UP

#if 0

        lda     a0, BdSystemName        // set system name address
        bis     zero, zero, a1          // set system base address
        lda     a2, BdDebugOptions      // set debug options address
        bsr     ra, BdInitDebugger      // initialize special debugger
        bsr     ra, DbgBreakPoint       // break into debugger

#endif

//
// Register kernel exception entry points with the PALcode.
//

        lda     a0, KiPanicException    // bugcheck entry point
        ldil    a1, entryBugCheck       //

        WRITE_KERNEL_ENTRY_POINT        //

        lda     a0, KiGeneralException  // general exception entry point
        ldil    a1, entryGeneral        //

        WRITE_KERNEL_ENTRY_POINT        //

        lda     a0, KiMemoryManagementException // memory mgmt exception entry
        ldil    a1, entryMM             //

        WRITE_KERNEL_ENTRY_POINT        //

        lda     a0, KiInterruptException // interrupt exception entry point
        ldil    a1, entryInterrupt      //

        WRITE_KERNEL_ENTRY_POINT        //

        lda     a0, KiSystemServiceException // syscall entry point
        ldil    a1, entrySyscall        //

        WRITE_KERNEL_ENTRY_POINT        //

//
// Initialize fields in the pcr.
//

        ldil    t1, PCR_MINOR_VERSION   // get minor version
        ldil    t2, PCR_MAJOR_VERSION   // get major version
        stl     t1, PcMinorVersion(s0)  // store minor version number
        stl     t2, PcMajorVersion(s0)  // store major version number

        LDP     t0, LpbThread(s2)       // save idle thread in pcr
        STP     t0, PcIdleThread(s0)    //

        LDP     t0, LpbPanicStack(s2)   // save panic stack in pcr
        STP     t0, PcPanicStack(s0)    //

        ldl     t0, LpbProcessorType(s2) // save processor type in pcr
        stl     t0, PcProcessorType(s0) //

        ldl     t0, LpbProcessorRevision(s2) // save processor revision
        stl     t0, PcProcessorRevision(s0)  //

        ldl     t0, LpbPhysicalAddressBits(s2) // save physical address bits
        stl     t0, PcPhysicalAddressBits(s0)  //

        ldl     t0, LpbMaximumAddressSpaceNumber(s2) // save max asn
        stl     t0, PcMaximumAddressSpaceNumber(s0)  //

        ldl     t0, LpbFirstLevelDcacheSize(s2) // save first level dcache size
        stl     t0, PcFirstLevelDcacheSize(s0)  //

        ldl     t0, LpbFirstLevelDcacheFillSize(s2) // save dcache fill size
        stl     t0, PcFirstLevelDcacheFillSize(s0)  //

        ldl     t0, LpbFirstLevelIcacheSize(s2) // save first level icache size
        stl     t0, PcFirstLevelIcacheSize(s0)  //

        ldl     t0, LpbFirstLevelIcacheFillSize(s2) // save icache fill size
        stl     t0, PcFirstLevelIcacheFillSize(s0)  //

        ldl     t0, LpbSystemType(s2)   // save system type
        stl     t0, PcSystemType(s0)    //
        ldl     t0, LpbSystemType+4(s2) //
        stl     t0, PcSystemType+4(s0)  //

        ldl     t0, LpbSystemVariant(s2) // save system variant
        stl     t0, PcSystemVariant(s0) //

        ldl     t0, LpbSystemRevision(s2) // save system revision
        stl     t0, PcSystemRevision(s0) //

        ldl     t0, LpbSystemSerialNumber(s2) // save system serial number
        stl     t0, PcSystemSerialNumber(s0) //
        ldl     t0, LpbSystemSerialNumber+4(s2) //
        stl     t0, PcSystemSerialNumber+4(s0) //
        ldl     t0, LpbSystemSerialNumber+8(s2) //
        stl     t0, PcSystemSerialNumber+8(s0) //
        ldl     t0, LpbSystemSerialNumber+12(s2) //
        stl     t0, PcSystemSerialNumber+12(s0) //

        ldl     t0, LpbCycleClockPeriod(s2) // save cycle counter period
        stl     t0, PcCycleClockPeriod(s0)  //

        LDP     t0, LpbRestartBlock(s2) // save Restart Block address
        STP     t0, PcRestartBlock(s0)  //

        ldq     t0, LpbFirmwareRestartAddress(s2) // save firmware restart
        stq     t0, PcFirmwareRestartAddress(s0) //

        ldl     t0, LpbFirmwareRevisionId(s2) // save firmware revision
        stl     t0, PcFirmwareRevisionId(s0) //

        LDP     t0, LpbDpcStack(s2)     // save Dpc Stack address
        STP     t0, PcDpcStack(s0)      //

        LDP     t0, LpbPrcb(s2)         // save Prcb address
        STP     t0, PcPrcb(s0)          //

        stl     zero, PbDpcRoutineActive(t0) // clear DPC Active flag
        stl     zero, PcMachineCheckError(s0) // indicate no HAL mchk handler

//
// Set system service dispatch address limits used by get and set context.
//

        lda     t0, KiSystemServiceDispatchStart // set start address of range
        STP     t0, PcSystemServiceDispatchStart(s0) //
        lda     t0, KiSystemServiceDispatchEnd // set end address of range
        STP     t0, PcSystemServiceDispatchEnd(s0) //

//
// Initialize the system.
//

        LDP     a0, LpbProcess(s2)      // get idle process address
        LDP     a1, LpbThread(s2)       // get idle thread address
        bis     a1, zero, s1            // save idle thread address
        LDP     a2, LpbKernelStack(s2)  // get idle thread stack
        LDP     a3, LpbPrcb(s2)         // get processor block address
        bis     a3, zero, s0            // save processor block address
        LoadByte(a4, PbNumber(a3))      // get processor number
        bis     s2, zero, a5            // get loader parameter block
        bsr     ra, KiInitializeKernel  // initialize system data

//
// Set the wait IRQL of the idle thread, and lower IRQL to DISPATCH_LEVEL.
//

        ldil    a0, DISPATCH_LEVEL      // get dispatch level IRQL
        StoreByte(a0, ThWaitIrql(s1))   // set wait IRQL of idle thread
        bsr     ra, KeLowerIrql         // lower IRQL

        ENABLE_INTERRUPTS               // enable interrupts

        bis     zero, zero, ra          // set bogus RA to stop debugger
        br      zero, KiIdleLoop        // continue in idle loop

        .end    KiStartupContinue

//
// The following code represents the idle loop for all processors. The idle
// loop executes at DISPATCH_LEVEL and continually polls for work.
//

        NESTED_ENTRY(KiIdleLoop, ExceptionFrameLength, zero)

        lda     sp, -ExceptionFrameLength(sp) // allocate context frame
        stq     ra, ExIntRa(sp)         // set bogus RA to stop debugger

        PROLOGUE_END

        lda     t0, KiIdleReturn        // set swap context return address
        stq     t0, ExSwapReturn(sp)    //

//
// Lower IRQL back to DISPATCH_LEVEL and restore global register values.
//
// N.B. The address of the current processor block (s0) is preserved across
//      the switch from idle call.
//

KiIdleReturn:                           //
        ldil    a0, DISPATCH_LEVEL      // set IRQL to dispatch level

        SWAP_IRQL                       //

#if DBG

        bis     zero, zero, s2          // reset breakin loop counter

#endif

        lda     s3, PbDpcListHead(s0)   // get DPC listhead address

#if !defined(NT_UP)

        ldil    s4, LockQueueDispatcherLock * 2 // compute per processor
        SPADDP  s4, s0, s4              // lock queue entry address
        lda     s4, PbLockQueue(s4)     //
        lda     s5, KiDispatcherLock    // get address of dispatcher lock

#endif

//
// Continually scan for debugger break in, a nonempty DPC list, or a new
// thread ready for execution.
//

IdleLoop:                               //

#if DBG

        subl    s2, 1, s2               // decrement breakin loop counter
        bge     s2, 5f                  // if ge, not time for breakin check
        ldil    s2, 200 * 1000          // set breakin loop counter
        bsr     ra, KdPollBreakIn       // check if breakin is requested
        beq     v0, 5f                  // if eq, then no breakin requested
        lda     a0, DBG_STATUS_CONTROL_C //
        bsr     ra, DbgBreakPointWithStatus //
5:                                      //

#endif //DBG

//
// Disable interrupts and check if there is any work in the DPC list
// of the current processor or a target processor.
//

CheckDpcList:                           //

        ENABLE_INTERRUPTS               // give interrupts a chance

        DISABLE_INTERRUPTS              // to interrupt spinning

//
// Process the deferred procedure call list for the current processor.
//

        ldl     t0, PbDpcQueueDepth(s0) // get current queue depth
        beq     t0, CheckNextThread     // if eq, DPC list is empty

//
// Clear dispatch interrupt.
//

        ldil    a0, DISPATCH_LEVEL      //clear any pending software interrupts
        ldl     t0, PbSoftwareInterrupts(s0) //
        bic     t0, a0, t1
        stl     t1, PbSoftwareInterrupts(s0) //

        DEASSERT_SOFTWARE_INTERRUPT     // clear any PAL-requested interrupts.

        bsr     ra, KiRetireDpcList     // process the DPC list

#if DBG

        bis     zero, zero, s2          // clear breakin loop counter

#endif

//
// Check if a thread has been selected to run on this processor.
//

CheckNextThread:                        //
        LDP     a0, PbNextThread(s0)    // get address of next thread object
        beq     a0, IdleProcessor       // if eq, no thread selected

//
// A thread has been selected for execution on this processor. Acquire
// dispatcher database lock, get the thread address again (it may have
// changed), clear the address of the next thread in the processor block,
// and call swap context to start execution of the selected thread.
//
// N.B. If the dispatcher database lock cannot be obtained immediately,
//      then attempt to process another DPC rather than spinning on the
//      dispatcher database lock.
//
// N.B. This is a very special acquire of the dispatcher lock in that it
//      will not be acquired unless it is free. Therefore, it is known
//      that there cannot be any queued lock requests.
//

#if !defined(NT_UP)

130:    LDP_L   t0, 0(s5)               // get current lock value
        bis     s4, zero, t1            // set lock ownership value
        bne     t0, CheckDpcList        // if ne, spin lock owned
        STP_C   t1, 0(s5)               // set spin lock owned
        beq     t1, 135f                // if eq, store conditional failed
        mb                              // synchronize reads after acquire
        bis     s5, LOCK_QUEUE_OWNER, t0 // set lock owner bit in lock entry
        STP     t0, LqLock(s4)          //

#endif

//
// Raise IRQL to sync level and re-enable interrupts
//

        ldl     a0, KiSynchIrql         //

        SWAP_IRQL                       //

        ENABLE_INTERRUPTS               //

        LDP     s2, PbNextThread(s0)    // get address of next thread
        LDP     s1, PbIdleThread(s0)    // get address of current thread
        STP     zero, PbNextThread(s0)  // clear next thread address
        STP     s2, PbCurrentThread(s0) // set address of current thread

//
// Set new thread's state to running. Note this must be done under the
// dispatcher lock so that KiSetPriorityThread sees the correct state.
//

        ldil    t0, Running             // set thread state to running
        StoreByte(t0, ThState(s2))      //

//
// Acquire the context swap lock so the address space of the old thread
// cannot be deleted and then release the dispatcher database lock. In
// this case the old thread is the idle thread, but the context swap code
// releases the context swap lock so it must be acquired.
//
// N.B. This lock is used to protect the address space until the context
//    switch has sufficiently progressed to the point where the address
//    space is no longer needed. This lock is also acquired by the reaper
//    thread before it finishes thread termination.
//

#if !defined(NT_UP)

        ldil    a0, LockQueueContextSwapLock * 2 // compute per processor
        SPADDP  a0, s0, a0              // lock queue entry address
        lda     a0, PbLockQueue(a0)     //
        bsr     ra, KeAcquireQueuedSpinLockAtDpcLevel // acquire context swap lock
        bis     s4, zero, a0                // set lock queue endtry address
        bsr     ra, KeReleaseQueuedSpinLockFromDpcLevel // release dispatcher lock

#endif

//
// Swap context to the new thread from the idle thread.
//
//  N.B. Control returns directly from this call to the top of the idle
//       loop.
//

        bsr     ra, SwapFromIdle        // swap context to new thread
        br      zero, KiIdleReturn      // control should not reach here

//
// There are no entries in the DPC list and a thread has not been selected
// for execution on this processor. Call the HAL so power management can
// be performed.
//
//  N.B. The HAL is called with interrupts disabled. The HAL will return
//       with interrupts enabled.
//

IdleProcessor:                          //
        lda     ra, IdleLoop            // set return address

        lda     a0, PbPowerState(s0)    // Get the Pointer to the current
                                        // C State Handler and Jump to it.
                                        // The Handler that gets called expects
                                        // A0 to contain the PState pointer.

        LDP     t0, PpIdleFunction(a0)
        jmp     zero, (t0)              //

//
// Conditional store of dispatcher lock failed. Retry. Do not spin in cache
// here. If the lock is owned, we want to check the DPC list again.
//

#if !defined(NT_UP)

135:    ENABLE_INTERRUPTS               // enable interrupts

        DISABLE_INTERRUPTS              // disable interrupts

        br      zero, 130b              // try again

#endif

        .end    KiIdleLoop

        SBTTL("Retire Deferred Procedure Call List")
//++
//
// Routine Description:
//
//    This routine is called to retire the specified deferred procedure
//    call list.
//
//    N.B. Interrupts must be disabled entry to this routine. Control is
//         returned to the caller with the same conditions true.
//
// Arguments:
//
//    s0 - Address of the processor control block.
//
// Return value:
//
//    None.
//
//--

        .struct 0
DpRa:   .space  8                       // return address
        .space  8                       // fill
DpcFrameLength:                         // frame length

        NESTED_ENTRY(KiRetireDpcList, DpcFrameLength, zero)

        lda     sp, -DpcFrameLength(sp) // allocate stack frame
        stq     ra, DpRa(sp)            // save return address

        PROLOGUE_END

//
// Process the DPC list.
//

10:     ldl     t0, PbDpcQueueDepth(s0) // get current DPC queue depth
        beq     t0, 60f                 // if eq, list is empty
15:     stl     t0, PbDpcRoutineActive(s0) // set DPC routine active
        lda     t2, PbDpcListHead(s0)   // compute DPC list head address

#if !defined(NT_UP)

20:     LDP_L   t1, PbDpcLock(s0)       // get current lock value
        bis     s0, zero, t3            // set lock ownership value
        bne     t1, 25f                 // if ne, spin lock owned
        STP_C   t3, PbDpcLock(s0)       // set spin lock owned
        beq     t3, 25f                 // if eq, store conditional failed
        mb                              // synchronize memory access
        ldl     t0, PbDpcQueueDepth(s0) // get current DPC queue depth
        beq     t0, 50f                 // if eq, DPC list is empty

#endif

        LDP     a0, LsFlink(t2)         // get address of next entry
        LDP     t1, LsFlink(a0)         // get address of next entry
        lda     a0, -DpDpcListEntry(a0) // compute address of DPC object
        STP     t1, LsFlink(t2)         // set address of next in header
        STP     t2, LsBlink(t1)         // set address of previous in next
        LDP     a1, DpDeferredContext(a0) // get deferred context argument
        LDP     a2, DpSystemArgument1(a0) // get first system argument
        LDP     a3, DpSystemArgument2(a0) // get second system argument
        LDP     t1, DpDeferredRoutine(a0) // get deferred routine address
        STP     zero, DpLock(a0)        // clear DPC inserted state
        subl    t0, 1, t0               // decrement DPC queue depth
        stl     t0, PbDpcQueueDepth(s0) // update DPC queue depth

#if DBG

        stl     zero, PbDebugDpcTime(s0) // clear the time spent in dpc

#endif

#if !defined(NT_UP)

        mb                              // synchronize previous writes
        STP     zero, PbDpcLock(s0)     // set spinlock not owned

#endif
        ENABLE_INTERRUPTS               // enable interrupts

        jsr     ra, (t1)                // call DPC routine

        DISABLE_INTERRUPTS              // disable interrupts

        br      zero, 10b               //

//
// Unlock DPC list and clear DPC active.
//

50:                                     //

#if !defined(NT_UP)

        mb                              // synchronize previous writes
        STP     zero, PbDpcLock(s0)     // set spin lock not owned

#endif

60:     stl     zero, PbDpcRoutineActive(s0) // clear DPC routine active
        stl     zero, PbDpcInterruptRequested(s0) // clear DPC interrupt requested

//
// Check one last time that the DPC list is empty. This is required to
// close a race condition with the DPC queuing code where it appears that
// a DPC routine is active (and thus an interrupt is not requested), but
// this code has decided the DPC list is empty and is clearing the DPC
// active flag.
//

#if !defined(NT_UP)

        mb                              //

#endif

        ldl     t0, PbDpcQueueDepth(s0) // get current DPC queue depth
        bne     t0, 65f                 // if ne, DPC list not empty
        ldq     ra, DpRa(sp)            // restore return address
        lda     sp, DpcFrameLength(sp)  // deallocate stack frame
        ret     zero, (ra)              // return

65:     br      zero, 15b               //

#if !defined(NT_UP)

25:     LDP     t1, PbDpcLock(s0)       // spin in cache until lock free
        beq     t1, 20b                 // retry spinlock
        br      zero, 25b               //

#endif

        .end    KiRetireDpcList

#if 0


        SBTTL("Initialize Traps")
//++
//
// Routine Description:
//
//    This function connects the PAL code to the boot debugger trap
//    routines.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

        NESTED_ENTRY(BdInitializeTraps, 8, ra)

        lda     sp, -8(sp)              // allocate stack frame
        stq     ra, 0(sp)               // save return address

        lda     a0, BdGeneralException  // general exception entry point
        ldil    a1, entryGeneral        //

        WRITE_KERNEL_ENTRY_POINT        //

        lda     a0, BdMemoryManagementException // memory mgmt exception entry
        ldil    a1, entryMM             //

        WRITE_KERNEL_ENTRY_POINT        //

        ldq     ra, 0(sp)               // restore return address
        lda     sp, 8(sp)               // deallocate stack frame
        ret     zero, (ra)              // return

        .end    BdInitializeTraps

        SBTTL("General Exception Dispatch")
//++
//
// Routine Description:
//
//     The following code is never executed.  Its purpose is to allow the
//     kernel debugger to walk call frames backwards through an exception
//     to support unwinding through exceptions for system services, and to
//     support get/set user context.
//
//    N.B. The volatile registers must be saved in this prologue because
//         the compiler will occasionally generate code that uses volatile
//         registers to save the contents of nonvolatile registers when
//         a function only calls another function with a known register
//         signature (such as _OtsDivide).
//
//--

        NESTED_ENTRY(BdGeneralExceptionDispatch, TrapFrameLength, zero)

        .set    noreorder
        stq     sp, TrIntSp(sp)         // save stack pointer
        stq     ra, TrIntRa(sp)         // save return address
        stq     ra, TrFir(sp)           // save return address
        stq     fp, TrIntFp(sp)         // save frame pointer
        stq     gp, TrIntGp(sp)         // save global pointer
        bis     sp, sp, fp              // set frame pointer
        .set    reorder

        stq     v0, TrIntV0(sp)         // save integer register v0
        stq     t0, TrIntT0(sp)         // save integer registers t0 - t7
        stq     t1, TrIntT1(sp)         //
        stq     t2, TrIntT2(sp)         //
        stq     t3, TrIntT3(sp)         //
        stq     t4, TrIntT4(sp)         //
        stq     t5, TrIntT5(sp)         //
        stq     t6, TrIntT6(sp)         //
        stq     t7, TrIntT7(sp)         //
        stq     a4, TrIntA4(sp)         // save integer registers a4 - a5
        stq     a5, TrIntA5(sp)         //
        stq     t8, TrIntT8(sp)         // save integer registers t8 - t12
        stq     t9, TrIntT9(sp)         //
        stq     t10, TrIntT10(sp)       //
        stq     t11, TrIntT11(sp)       //
        stq     t12, TrIntT12(sp)       //

        .set    noat
        stq     AT, TrIntAt(sp)         // save integer register AT
        .set    at

        PROLOGUE_END

//++
//
// Routine Description:
//
//     PALcode dispatches to this kernel entry point when a "general"
//     exception occurs.  These general exceptions are any exception
//     other than an interrupt, system service call or memory management
//     fault.  The types of exceptions that will dispatch through this
//     routine will be: breakpoints, unaligned accesses, machine check
//     errors, illegal instruction exceptions, and arithmetic exceptions.
//     The purpose of this routine is to save the volatile state and
//     enter the common exception dispatch code.
//
// Arguments:
//
//     fp - Supplies a pointer to the trap frame.
//     gp - Supplies a pointer to the system short data area.
//     sp - Supplies a pointer to the trap frame.
//     a0 = Supplies a pointer to the exception record.
//     a3 = Supplies the previous psr.
//
//     Note: Control registers, ra, sp, fp, gp have already been saved
//           argument registers a0-a3 have been saved as well
//
//--

        ALTERNATE_ENTRY(BdGeneralException)

        bsr     ra, KiGenerateTrapFrame // store volatile state
        br      ra, BdExceptionDispatch // handle the exception

        .end    BdGeneralExceptionDispatch

        SBTTL("Exception Dispatch")
//++
//
// Routine Description:
//
//     This routine begins the common code for raising an exception.
//     The routine saves the non-volatile state and dispatches to the
//     next level exception dispatcher.
//
// Arguments:
//
//     fp - Supplies a pointer to the trap frame.
//     sp - Supplies a pointer to the trap frame.
//     a0 = Supplies a pointer to the exception record.
//     a3 = Supplies the previous psr.
//
//     gp, ra - saved in trap frame
//     a0-a3 - saved in trap frame
//
// Return Value:
//
//      None.
//
//--

        NESTED_ENTRY(BdExceptionDispatch, ExceptionFrameLength, zero )

//
// Build exception frame
//

        lda     sp, -ExceptionFrameLength(sp) // allocate exception frame
        stq     ra, ExIntRa(sp)         // save ra
        stq     s0, ExIntS0(sp)         // save integer registers s0 - s5
        stq     s1, ExIntS1(sp)         //
        stq     s2, ExIntS2(sp)         //
        stq     s3, ExIntS3(sp)         //
        stq     s4, ExIntS4(sp)         //
        stq     s5, ExIntS5(sp)         //
        stt     f2, ExFltF2(sp)         // save floating registers f2 - f9
        stt     f3, ExFltF3(sp)         //
        stt     f4, ExFltF4(sp)         //
        stt     f5, ExFltF5(sp)         //
        stt     f6, ExFltF6(sp)         //
        stt     f7, ExFltF7(sp)         //
        stt     f8, ExFltF8(sp)         //
        stt     f9, ExFltF9(sp)         //

        PROLOGUE_END

        ldil    a4, TRUE                // first chance to true
        bis     zero, zero, a3          // set previous mode
        bis     fp, zero, a2            // set pointer to trap frame
        bis     sp, zero, a1            // set pointer to exception frame
        lda     a0, TrExceptionRecord(fp) // set address of exception record
        LDP     t0, BdDebugRoutine      // get address of debug routine
        jsr     ra, (t0)                // call kernel debugger
        ldq     s0, ExIntS0(sp)         // restore integer registers s0 - s5
        ldq     s1, ExIntS1(sp)         //
        ldq     s2, ExIntS2(sp)         //
        ldq     s3, ExIntS3(sp)         //
        ldq     s4, ExIntS4(sp)         //
        ldq     s5, ExIntS5(sp)         //
        ldl     a0, TrPsr(fp)           // get previous psr
        bsr     ra, KiRestoreNonVolatileFloatState // restore nv float state
        bsr     ra, KiRestoreTrapFrame  // restore volatile state
        bis     zero, zero, a1          // assume softwareinterrupt requested

//
// a0 = previous psr
// a1 = sfw interrupt requests
//

        RETURN_FROM_TRAP_OR_INTERRUPT   // return from exception

        .end    BdExceptionDispatch

        SBTTL("Memory Management Exception Dispatch")
//++
//
// Routine Description:
//
//     The following code is never executed.  Its purpose is to allow the
//     kernel debugger to walk call frames backwards through an exception
//     to support unwinding through exceptions for system services, and to
//     support get/set user context.
//
//    N.B. The volatile registers must be saved in this prologue because
//         the compiler will occasionally generate code that uses volatile
//         registers to save the contents of nonvolatile registers when
//         a function only calls another function with a known register
//         signature (such as _OtsMove).
//
//--

        NESTED_ENTRY(BdMemoryManagementDispatch, TrapFrameLength, zero)

        .set    noreorder
        stq     sp, TrIntSp(sp)         // save stack pointer
        stq     ra, TrIntRa(sp)         // save return address
        stq     ra, TrFir(sp)           // save return address
        stq     fp, TrIntFp(sp)         // save frame pointer
        stq     gp, TrIntGp(sp)         // save global pointer
        bis     sp, sp, fp              // set frame pointer
        .set    reorder

        stq     v0, TrIntV0(sp)         // save integer register v0
        stq     t0, TrIntT0(sp)         // save integer registers t0 - t7
        stq     t1, TrIntT1(sp)         //
        stq     t2, TrIntT2(sp)         //
        stq     t3, TrIntT3(sp)         //
        stq     t4, TrIntT4(sp)         //
        stq     t5, TrIntT5(sp)         //
        stq     t6, TrIntT6(sp)         //
        stq     t7, TrIntT7(sp)         //
        stq     a4, TrIntA4(sp)         // save integer registers a4 - a5
        stq     a5, TrIntA5(sp)         //
        stq     t8, TrIntT8(sp)         // save integer registers t8 - t12
        stq     t9, TrIntT9(sp)         //
        stq     t10, TrIntT10(sp)       //
        stq     t11, TrIntT11(sp)       //
        stq     t12, TrIntT12(sp)       //

        .set    noat
        stq     AT, TrIntAt(sp)         // save integer register AT
        .set    at

        PROLOGUE_END

//++
//
// Routine Description:
//
//     This routine is called from the PALcode when a translation not valid
//     fault or an access violation is encountered.  This routine will
//     call MmAccessFault to attempt to resolve the fault.  If the fault
//     cannot be resolved then the routine will dispatch to the exception
//     dispatcher so the exception can be raised.
//
// Arguments:
//
//      fp - Supplies a pointer to the trap frame.
//      gp - Supplies a pointer to the system short data area.
//      sp - Supplies a pointer to the trap frame.
//      a0 = Supplies the load/store indicator, 1 = store, 0 = load.
//      a1 = Supplies the bad virtual address.
//      a2 = Supplies the previous mode.
//      a3 = Supplies the previous psr.
//
//      gp, ra - saved in trap frame
//      a0-a3 - saved in trap frame
//
// Return Value:
//
//      None.
//
//--

        ALTERNATE_ENTRY(BdMemoryManagementException)

        bsr     ra, KiGenerateTrapFrame // store volatile state
        STP     a0, TrExceptionRecord + ErExceptionInformation(fp) // set load/store

#if defined(_AXP64_)

        stq     a1, TrExceptionRecord + ErExceptionInformation + 8(fp) // set bad va

#else

        stl     a1, TrExceptionRecord + ErExceptionInformation + 4(fp) // set bad va

#endif

        lda     a0, TrExceptionRecord(fp) // get exception record address
        ldil    v0, STATUS_ACCESS_VIOLATION // get access violation code
        stl     v0, ErExceptionCode(a0) // save exception code
        stl     zero, ErExceptionFlags(a0) // set exception flags
        STP     zero, ErExceptionRecord(a0) // set associated record
        bis     zero, 2, t0             // set number of parameters
        stl     t0, ErNumberParameters(a0) // set number of parameters
        br      ra, BdExceptionDispatch // dispatch exception

        .end     BdMemoryManagementDispatch

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\trap.s ===
//      TITLE("Kernel Trap Handler")
//++
// Copyright (c) 1990 Microsoft Corporation
// Copyright (c) 1992 Digital Equipment Corporation
//
// Module Name:
//
//     trap.s
//
//
// Abstract:
//
//     Implements trap routines for ALPHA, these are the
//     entry points that the palcode calls for exception
//     processing.
//
//
// Author:
//
//      David N. Cutler (davec) 4-Apr-1990
//      Joe Notarangelo 06-Feb-1992
//
//
// Environment:
//
//      Kernel mode only.
//
//
// Revision History:
//
//      Nigel Haslock 05-May-1995       preserve fpcr across system calls
//
//--

#include "ksalpha.h"

//
// Define exception handler frame
//

        .struct 0
HdRa:   .space  8                       // return address
        .space  3*8                     // round to cache block
HandlerFrameLength:                     // frame length

        SBTTL("General Exception Dispatch")
//++
//
// Routine Description:
//
//     The following code is never executed.  Its purpose is to allow the
//     kernel debugger to walk call frames backwards through an exception
//     to support unwinding through exceptions for system services, and to
//     support get/set user context.
//
//    N.B. The volatile registers must be saved in this prologue because
//         the compiler will occasionally generate code that uses volatile
//         registers to save the contents of nonvolatile registers when
//         a function only calls another function with a known register
//         signature (such as _OtsDivide).
//
//--

        NESTED_ENTRY(KiGeneralExceptionDispatch, TrapFrameLength, zero)

        .set    noreorder
        stq     sp, TrIntSp(sp)         // save stack pointer
        stq     ra, TrIntRa(sp)         // save return address
        stq     ra, TrFir(sp)           // save return address
        stq     fp, TrIntFp(sp)         // save frame pointer
        stq     gp, TrIntGp(sp)         // save global pointer
        bis     sp, sp, fp              // set frame pointer
        .set    reorder

        stq     v0, TrIntV0(sp)         // save integer register v0
        stq     t0, TrIntT0(sp)         // save integer registers t0 - t7
        stq     t1, TrIntT1(sp)         //
        stq     t2, TrIntT2(sp)         //
        stq     t3, TrIntT3(sp)         //
        stq     t4, TrIntT4(sp)         //
        stq     t5, TrIntT5(sp)         //
        stq     t6, TrIntT6(sp)         //
        stq     t7, TrIntT7(sp)         //
        stq     a4, TrIntA4(sp)         // save integer registers a4 - a5
        stq     a5, TrIntA5(sp)         //
        stq     t8, TrIntT8(sp)         // save integer registers t8 - t12
        stq     t9, TrIntT9(sp)         //
        stq     t10, TrIntT10(sp)       //
        stq     t11, TrIntT11(sp)       //
        stq     t12, TrIntT12(sp)       //

        .set    noat
        stq     AT, TrIntAt(sp)         // save integer register AT
        .set    at

        PROLOGUE_END

//++
//
// Routine Description:
//
//     PALcode dispatches to this kernel entry point when a "general"
//     exception occurs.  These general exceptions are any exception
//     other than an interrupt, system service call or memory management
//     fault.  The types of exceptions that will dispatch through this
//     routine will be: breakpoints, unaligned accesses, machine check
//     errors, illegal instruction exceptions, and arithmetic exceptions.
//     The purpose of this routine is to save the volatile state and
//     enter the common exception dispatch code.
//
// Arguments:
//
//     fp - Supplies a pointer to the trap frame.
//     gp - Supplies a pointer to the system short data area.
//     sp - Supplies a pointer to the trap frame.
//     a0 = Supplies a pointer to the exception record.
//     a3 = Supplies the previous psr.
//
//     Note: Control registers, ra, sp, fp, gp have already been saved
//           argument registers a0-a3 have been saved as well
//
//--

        ALTERNATE_ENTRY(KiGeneralException)

        bsr     ra, KiGenerateTrapFrame // store volatile state
        br      ra, KiExceptionDispatch // handle the exception

        .end    KiGeneralExceptionDispatch

        SBTTL("Exception Dispatch")
//++
//
// Routine Description:
//
//     This routine begins the common code for raising an exception.
//     The routine saves the non-volatile state and dispatches to the
//     next level exception dispatcher.
//
// Arguments:
//
//     fp - Supplies a pointer to the trap frame.
//     sp - Supplies a pointer to the trap frame.
//     a0 = Supplies a pointer to the exception record.
//     a3 = Supplies the previous psr.
//
//     gp, ra - saved in trap frame
//     a0-a3 - saved in trap frame
//
// Return Value:
//
//      None.
//
//--

        NESTED_ENTRY(KiExceptionDispatch, ExceptionFrameLength, zero )

//
// Build exception frame
//

        lda     sp, -ExceptionFrameLength(sp) // allocate exception frame
        stq     ra, ExIntRa(sp)         // save ra
        stq     s0, ExIntS0(sp)         // save integer registers s0 - s5
        stq     s1, ExIntS1(sp)         //
        stq     s2, ExIntS2(sp)         //
        stq     s3, ExIntS3(sp)         //
        stq     s4, ExIntS4(sp)         //
        stq     s5, ExIntS5(sp)         //
        stt     f2, ExFltF2(sp)         // save floating registers f2 - f9
        stt     f3, ExFltF3(sp)         //
        stt     f4, ExFltF4(sp)         //
        stt     f5, ExFltF5(sp)         //
        stt     f6, ExFltF6(sp)         //
        stt     f7, ExFltF7(sp)         //
        stt     f8, ExFltF8(sp)         //
        stt     f9, ExFltF9(sp)         //

        PROLOGUE_END

        ldil    a4, TRUE                // first chance to true
        and     a3, PSR_MODE_MASK, a3   // set previous mode
        bis     fp, zero, a2            // set pointer to trap frame
        bis     sp, zero, a1            // set pointer to exception frame
        bsr     ra, KiDispatchException // dispatch exception

        SBTTL("Exception Exit")
//++
//
// Routine Description:
//
//     This routine is called to exit from an exception.
//
//     N.B. This transfer of control occurs from:
//
//         1. fall-through from above
//         2. exit from continue system service
//         3. exit from raise exception system service
//         4. exit into user mode from thread startup
//
// Arguments:
//
//     fp - Supplies a pointer to the trap frame.
//     sp - Supplies a pointer to the exception frame.
//
// Return Value:
//
//     Does not return.
//
//--

        ALTERNATE_ENTRY(KiExceptionExit)

        ldq     s0, ExIntS0(sp)         // restore integer registers s0 - s5
        ldq     s1, ExIntS1(sp)         //
        ldq     s2, ExIntS2(sp)         //
        ldq     s3, ExIntS3(sp)         //
        ldq     s4, ExIntS4(sp)         //
        ldq     s5, ExIntS5(sp)         //
        ldl     a0, TrPsr(fp)           // get previous psr
        bsr     ra, KiRestoreNonVolatileFloatState // restore nv float state

        ALTERNATE_ENTRY(KiAlternateExit)

//
// on entry:
//
//      a0 = Supplies the previous psr.
//
// rfe will do the following for us:
//
//      set sfw interrupt requests as per a1
//      restore previous irql and mode from previous psr
//      restore registers, a0-a3, fp, sp, ra, gp
//      return to saved exception address in the trap frame
//
//      here, we need to restore the trap frame and determine
//      if we must request an APC interrupt
//

        bis     zero, zero, a1          // assume softwareinterrupt requested
        blbc    a0, 30f                 // if lbc, previous mode kernel

//
// Check to determine if an apc interrupt should be generated.
//

        GET_CURRENT_THREAD              // get current thread address

        ldq_u   t1, ThApcState+AsUserApcPending(v0) // get user APC pending
        extbl   t1, (ThApcState+AsUserApcPending) % 8, t0 //
        ZeroByte(ThAlerted(v0))         // clear kernel mode alerted
        cmovne  t0, APC_INTERRUPT, a1   // if pending set APC interrupt
30:     bsr     ra, KiRestoreTrapFrame  // restore volatile state

//
// a0 = previous psr
// a1 = sfw interrupt requests
//

        RETURN_FROM_TRAP_OR_INTERRUPT   // return from exception

        .end    KiExceptionDispatch

        SBTTL("Memory Management Exception Dispatch")
//++
//
// Routine Description:
//
//     The following code is never executed.  Its purpose is to allow the
//     kernel debugger to walk call frames backwards through an exception
//     to support unwinding through exceptions for system services, and to
//     support get/set user context.
//
//    N.B. The volatile registers must be saved in this prologue because
//         the compiler will occasionally generate code that uses volatile
//         registers to save the contents of nonvolatile registers when
//         a function only calls another function with a known register
//         signature (such as _OtsMove).
//
//--

        NESTED_ENTRY(KiMemoryManagementDispatch, TrapFrameLength, zero)

        .set    noreorder
        stq     sp, TrIntSp(sp)         // save stack pointer
        stq     ra, TrIntRa(sp)         // save return address
        stq     ra, TrFir(sp)           // save return address
        stq     fp, TrIntFp(sp)         // save frame pointer
        stq     gp, TrIntGp(sp)         // save global pointer
        bis     sp, sp, fp              // set frame pointer
        .set    reorder

        stq     v0, TrIntV0(sp)         // save integer register v0
        stq     t0, TrIntT0(sp)         // save integer registers t0 - t7
        stq     t1, TrIntT1(sp)         //
        stq     t2, TrIntT2(sp)         //
        stq     t3, TrIntT3(sp)         //
        stq     t4, TrIntT4(sp)         //
        stq     t5, TrIntT5(sp)         //
        stq     t6, TrIntT6(sp)         //
        stq     t7, TrIntT7(sp)         //
        stq     a4, TrIntA4(sp)         // save integer registers a4 - a5
        stq     a5, TrIntA5(sp)         //
        stq     t8, TrIntT8(sp)         // save integer registers t8 - t12
        stq     t9, TrIntT9(sp)         //
        stq     t10, TrIntT10(sp)       //
        stq     t11, TrIntT11(sp)       //
        stq     t12, TrIntT12(sp)       //

        .set    noat
        stq     AT, TrIntAt(sp)         // save integer register AT
        .set    at

        PROLOGUE_END

//++
//
// Routine Description:
//
//     This routine is called from the PALcode when a translation not valid
//     fault or an access violation is encountered.  This routine will
//     call MmAccessFault to attempt to resolve the fault.  If the fault
//     cannot be resolved then the routine will dispatch to the exception
//     dispatcher so the exception can be raised.
//
// Arguments:
//
//      fp - Supplies a pointer to the trap frame.
//      gp - Supplies a pointer to the system short data area.
//      sp - Supplies a pointer to the trap frame.
//      a0 = Supplies the load/store indicator, 1 = store, 0 = load.
//      a1 = Supplies the bad virtual address.
//      a2 = Supplies the previous mode.
//      a3 = Supplies the previous psr.
//
//      gp, ra - saved in trap frame
//      a0-a3 - saved in trap frame
//
// Return Value:
//
//      None.
//
//--

        ALTERNATE_ENTRY(KiMemoryManagementException)

        bsr     ra, KiGenerateTrapFrame // store volatile state

//
// Save parameters in exception record and save previous psr.
//

        STP     a0, TrExceptionRecord + ErExceptionInformation(fp) // set load/store

#if defined(_AXP64_)

        stq     a1, TrExceptionRecord + ErExceptionInformation + 8(fp) // set bad va

#else

        stl     a1, TrExceptionRecord + ErExceptionInformation + 4(fp) // set bad va

#endif

        stl     a3, TrExceptionRecord + ErExceptionCode(fp) // save previous psr

//
// Call memory management to handle the access fault.
//

        bis     fp, zero, a3            // set address of trap frame
        bsr     ra, MmAccessFault       // resolve memory management fault
        ldl     a3, TrExceptionRecord + ErExceptionCode(fp) // get previous psr

//
// Check if working set watch is enabled.
//

        ldl     t0, PsWatchEnabled      // get working set watch enable flag
        bis     v0, zero, a0            // save status of fault resolution
        blt     v0, 40f                 // if ltz, resolution not successful
        beq     t0, 35f                 // if eq. zero, watch not enabled
        LDP     a1, TrExceptionRecord + ErExceptionAddress(fp) // set exception address

#if defined(_AXP64_)

        ldq     a2, TrExceptionRecord + ErExceptionInformation + 8(fp) // set bad address

#else

        ldl     a2, TrExceptionRecord + ErExceptionInformation + 4(fp) // set bad address

#endif

        bsr     ra, PsWatchWorkingSet   // record working set information

//
// Check if debugger has any breakpoints that should be inserted.
//

35:     ldl     t0, KdpOweBreakpoint    // get owned breakpoint flag
        zap     t0, 0xfe, t1            // mask off high bytes
        beq     t1, 37f                 // if eq, no break points owed
        bsr     ra, KdSetOwedBreakpoints // set owed break points

//
// Exit exception.
//

37:     ldl     a0, TrPsr(fp)           // get previous psr
        br      zero, KiAlternateExit   // exception handled

//
// Check to determine if the fault occured in the interlocked pop
// entry slist code. There is a case where a fault may occur in this
// code when the right set of circumstances occurs. The fault can be
// ignored by simply skipping the faulting instruction.
//

40:     ldq     t0, TrFir(fp)           // get faulting instruction address
        lda     t1, ExpInterlockedPopEntrySListFault // get address of pop code
        cmpeq   t0, t1, t2              // check if address matches
        bne     t2, 70f                 // if ne, fault address match

//
// Memory management failed to resolve fault.
//
// STATUS_IN_PAGE_ERROR | 0x10000000 is a special status that indicates a
//      page fault at Irql greater than APC_LEVEL.
//
// The following statuses can be raised:
//
//      STATUS_ACCESS_VIOLATION
//      STATUS_GUARD_PAGE_VIOLATION
//      STATUS_STACK_OVERFLOW
//
// All other status will be set to:
//
//      STATUS_IN_PAGE_ERROR
//
// dispatch exception via common code in KiDispatchException
// Following must be done:
//      allocate exception frame via sp
//      complete data in ExceptionRecord
//      a0 points to ExceptionRecord
//      a1 points to ExceptionFrame
//      a2 points to TrapFrame
//      a3 = previous psr
//
// Exception record information has the following values
//      offset  value
//      0       read vs write indicator (set on entry)
//      4       bad virtual address (set on entry)
//      8       real status (only if status was not "recognized")
//
//
// Check for special status that indicates a page fault at
// Irql above APC_LEVEL.
//

        ldil    t1, STATUS_IN_PAGE_ERROR | 0x10000000 // get special status
        cmpeq   v0, t1, t2              // check if status is special case
        bne     t2, 60f                 // if ne, status is special case

//
// Check for expected status values.
//

        lda     a0, TrExceptionRecord(fp) // get exception record address
        bis     zero, 2, t0             // set number of parameters
        ldil    t1, STATUS_ACCESS_VIOLATION // get access violation code
        cmpeq   v0, t1, t2              // check if access violation
        bne     t2, 50f                 // if ne, access violation
        ldil    t1, STATUS_GUARD_PAGE_VIOLATION // get guard page violation code
        cmpeq   v0, t1, t2              // check if guard page violation
        bne     t2, 50f                 // if ne, guard page violation
        ldil    t1, STATUS_STACK_OVERFLOW // get stack overflow code
        cmpeq   v0, t1, t2              // check if stack overflow
        bne     t2, 50f                 // if ne, stack overflow

//
// Status is not recognized, save real status, bump the number
// of exception parameters, and set status to STATUS_IN_PAGE_ERROR
//

#if defined(_AXP64_)

        stq     v0, ErExceptionInformation + 16(a0) // save real status code

#else

        stl     v0, ErExceptionInformation + 8(a0) // save real status code

#endif

        bis     zero, 3, t0             // set number of params
        ldil    v0, STATUS_IN_PAGE_ERROR // set status to in page error

//
// Fill in the remaining exception record parameters and attempt to
// resolve the exception.
//

50:     ldl     a3, ErExceptionCode(a0) // get previous psr
        stl     v0, ErExceptionCode(a0) // save exception code
        stl     zero, ErExceptionFlags(a0) // set exception flags
        STP     zero, ErExceptionRecord(a0) // set associated record
        stl     t0, ErNumberParameters(a0) // set number of parameters
        br      ra, KiExceptionDispatch // dispatch exception

//
// Generate a bugcheck - A page fault has occured at an IRQL that is greater
// than APC_LEVEL.
//

60:     ldil    a0, IRQL_NOT_LESS_OR_EQUAL // set bugcheck code

#if defined(_AXP64_)

        ldq     a1, TrExceptionRecord + ErExceptionInformation + 8(fp) // set bad va

#else

        ldl     a1, TrExceptionRecord + ErExceptionInformation + 4(fp) // set bad va

#endif

        ldl     a2, TrExceptionRecord + ErExceptionCode(fp) // set previous IRQL
        srl     a2, PSR_IRQL, a2        //
        LDP     a3, TrExceptionRecord + ErExceptionInformation(fp) // set load/store indicator
        ldq     a4, TrFir(fp)           // set exception pc
        br      ra, KeBugCheckEx        // handle bugcheck

//
// The fault occured in the interlocked pop slist function and the faulting
// instruction should be skipped.
//

70:     lda     t0, ExpInterlockedPopEntrySListResume // get resumption address
        stq     t0, TrFir(fp)           // set continuation address
        ldl     a0, TrPsr(fp)           // get previous psr
        br      zero, KiAlternateExit   //

        .end     KiMemoryManagementDispatch

        SBTTL("Invalid Access Allowed")
//++
//
// BOOLEAN
// KeInvalidAccessAllowed (
//    IN PVOID TrapFrame
//    )
//
// Routine Description:
//
//    Mm will pass a pointer to a trap frame prior to issuing a bug check on
//    a pagefault. This routine lets Mm know if it is ok to bugcheck.  The
//    specific case we must protect are the interlocked pop sequences which can
//    blindly access memory that may have been freed and/or reused prior to the
//    access.  We don't want to bugcheck the system in these cases, so we check
//    the instruction pointer here.
//
// Arguments:
//
//    TrapFrame (a0) - Supplies a  trap frame pointer.  NULL means return False.
//
// Return Value:
//
//    True if the invalid access should be ignored.
//    False which will usually trigger a bugcheck.
//
//--

        LEAF_ENTRY(KeInvalidAccessAllowed)

        bis     zero, 0, v0             // assume access not allowed
        beq     a0, 10f                 // if eq, no trap frame specified
        ldq     t0, TrFir(a0)           // get faulting instruction address
        lda     t1, ExpInterlockedPopEntrySListFault // get address of pop code
        cmpeq   t0, t1, v0              // check if fault at pop code address
10:     ret     zero, (ra)              // return

        .end    KeInvalidAccessAllowed

        SBTTL("Primary Interrupt Dispatch")
//++
//
// Routine Description:
//
//    The following code is never executed. Its purpose is to allow the
//    kernel debugger to walk call frames backwards through an exception,
//    to support unwinding through exceptions for system services, and to
//    support get/set user context.
//
//    N.B. The volatile registers must be saved in this prologue because
//         the compiler will occasionally generate code that uses volatile
//         registers to save the contents of nonvolatile registers when
//         a function only calls another function with a known register
//         signature (such as _OtsMove)
//
//--

        EXCEPTION_HANDLER(KiInterruptHandler)

        NESTED_ENTRY(KiInterruptDistribution, TrapFrameLength, zero);

        .set    noreorder
        stq     sp,TrIntSp(sp)          // save stack pointer
        stq     ra,TrIntRa(sp)          // save return address
        stq     ra,TrFir(sp)            // save return address
        stq     fp,TrIntFp(sp)          // save frame pointer
        stq     gp,TrIntGp(sp)          // save general pointer
        bis     sp, sp, fp              // set frame pointer
        .set    reorder

        stq     v0, TrIntV0(sp)         // save integer register v0
        stq     t0, TrIntT0(sp)         // save integer registers t0 - t7
        stq     t1, TrIntT1(sp)         //
        stq     t2, TrIntT2(sp)         //
        stq     t3, TrIntT3(sp)         //
        stq     t4, TrIntT4(sp)         //
        stq     t5, TrIntT5(sp)         //
        stq     t6, TrIntT6(sp)         //
        stq     t7, TrIntT7(sp)         //
        stq     a4, TrIntA4(sp)         // save integer registers a4 - a5
        stq     a5, TrIntA5(sp)         //
        stq     t8, TrIntT8(sp)         // save integer registers t8 - t12
        stq     t9, TrIntT9(sp)         //
        stq     t10, TrIntT10(sp)       //
        stq     t11, TrIntT11(sp)       //
        stq     t12, TrIntT12(sp)       //

        .set    noat
        stq     AT, TrIntAt(sp)         // save integer register AT
        .set    at

        PROLOGUE_END

//++
//
// Routine Description:
//
//     The PALcode dispatches to this routine when an enabled interrupt
//     is asserted.
//
//     When this routine is entered, interrupts are disabled.
//
//     The function of this routine is to determine the highest priority
//     pending interrupt, raise the IRQL to the level of the highest interrupt,
//     and then dispatch the interrupt to the proper service routine.
//
//
// Arguments:
//
//     a0 - Supplies the interrupt vector number.
//     a1 - Supplies the address of the pcr.
//     a3 - Supplies the previous psr.
//     fp - Supplies a pointer to the trap frame.
//     gp - Supplies a pointer to the system short data area.
//
// Return Value:
//
//     None.
//
//--

        ALTERNATE_ENTRY(KiInterruptException)

        bsr     ra, KiSaveVolatileIntegerState // save integer registers

//
// Count the number of interrupts.
//

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        ldl     t0, PbInterruptCount(v0) // get current count of interrupts
        addl    t0, 1, t1               // increment count
        stl     t1, PbInterruptCount(v0) // save new interrupt count

//
// If interrupt vector > DISPATCH_LEVEL, indicate interrupt active in PRCB
//

        cmpule  a0, DISPATCH_LEVEL, t4  // compare vector to DISPATCH_LEVEL
        LDP     t2, PbInterruptTrapFrame(v0)// get old interrupt trap frame
        cmovne  t4, zero, t2            // zero trap frame if <= DISPATCH_LEVEL
        STP     t2, TrTrapFrame(fp)     // save old interrupt trap in new
        bne     t4, 10f                 // vector <= DISPATCH_LEVEL, no interrupt trap
        STP     fp, PbInterruptTrapFrame(v0)// set new interrupt trap frame
10:     SPADDP  a0, a1, a0              // convert index to offset + PCR base
        LDP     a0, PcInterruptRoutine(a0) // get service routine address
        jsr     ra, (a0)                // call interrupt service routine

//
// Restore state and exit interrupt.
//

        ldl     a0, TrPsr(fp)           // get previous psr

#ifndef NT_UP

        DISABLE_INTERRUPTS              // disable interrupts

#endif

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get current prcb address

        LDP     t0, TrTrapFrame(fp)     // get old interrupt trap frame
        STP     t0, PbInterruptTrapFrame(v0)// restore old interrupt trap frame

#ifndef NT_UP

        ENABLE_INTERRUPTS               // enable interrupts

#endif

        bne     t0, 50f                 // if ne, interrupt still active,

//
// If a dispatch interrupt is pending, lower IRQL to DISPATCH_LEVEL, and
// directly call the dispatch interrupt handler.
//

        ldl     t2, PbSoftwareInterrupts(v0) // get pending SW interrupts
        beq     t2, 50f                 // if eq, no pending SW interrupts
        stl     zero, PbSoftwareInterrupts(v0) // clear pending SW interrupts
        and     a0, PSR_IRQL_MASK, a1   // extract IRQL from PSR
        cmpult  a1, DISPATCH_LEVEL << PSR_IRQL, t3 // check return IRQL
        beq     t3, 70f                 // if not lt DISPATCH_LEVEL, can't bypass

//
// Update count of bypassed dispatch interrupts.
//

        ldl     t4, PbDpcBypassCount(v0) // get old bypass count
        addl    t4, 1, t5                // increment
        stl     t5, PbDpcBypassCount(v0) // store new bypass count
        ldil    a0, DISPATCH_LEVEL      // set new IRQL level

        SWAP_IRQL                       // lower IRQL to DISPATCH_LEVEL

        bsr     ra, KiDispatchInterrupt // process dispatch interrupt
45:     ldl     a0, TrPsr(fp)           // restore previous psr

//
// Check if an APC interrupt should be generated.
//

50:     bis     zero, zero, a1          // clear sfw interrupt request
        blbc    a0, 60f                 // if kernel no apc

        GET_CURRENT_THREAD              // get current thread address

        ldq_u   t1, ThApcState+AsUserApcPending(v0) // get user APC pending
        extbl   t1, (ThApcState+AsUserApcPending) % 8, t0 //
        ZeroByte(ThAlerted(v0))         // clear kernel mode alerted
        cmovne  t0, APC_INTERRUPT, a1   // if pending set APC interrupt
60:     bsr     ra, KiRestoreVolatileIntegerState // restore volatile state

//
// a0 = previous mode
// a1 = sfw interrupt requests
//

        RETURN_FROM_TRAP_OR_INTERRUPT   // return from trap/interrupt

//
// Previous IRQL is >= DISPATCH_LEVEL, so a pending software interrupt cannot
// be short-circuited. Request a software interrupt from the PAL.
//

70:     ldil    a0, DISPATCH_LEVEL      // set interrupt request level

        REQUEST_SOFTWARE_INTERRUPT      // request interrupt from PAL

        br      zero, 45b               // rejoin common code

        .end    KiInterruptDistribution

//++
//
// EXCEPTION_DISPOSITION
// KiInterruptHandler (
//    IN PEXCEPTION_RECORD ExceptionRecord,
//    IN ULONG EstablisherFrame,
//    IN OUT PCONTEXT ContextRecord,
//    IN OUT PDISPATCHER_CONTEXT DispatcherContext
//
// Routine Description:
//
//    Control reaches here when an exception is not handled by an interrupt
//    service routine or an unwind is initiated in an interrupt service
//    routine that would result in an unwind through the interrupt dispatcher.
//    This is considered to be a fatal system error and bug check is called.
//
// Arguments:
//
//    ExceptionRecord (a0) - Supplies a pointer to an exception record.
//
//    EstablisherFrame (a1) - Supplies the frame pointer of the establisher
//       of this exception handler.
//
//       N.B. This is not actually the frame pointer of the establisher of
//            this handler. It is actually the stack pointer of the caller
//            of the system service. Therefore, the establisher frame pointer
//            is not used and the address of the trap frame is determined by
//            examining the saved fp register in the context record.
//
//    ContextRecord (a2) - Supplies a pointer to a context record.
//
//    DispatcherContext (a3) - Supplies a pointer to  the dispatcher context
//       record.
//
// Return Value:
//
//    There is no return from this routine.
//
//--

        NESTED_ENTRY(KiInterruptHandler, HandlerFrameLength, zero)

        lda     sp, -HandlerFrameLength(sp) // allocate stack frame
        stq     ra, HdRa(sp)            // save return address

        PROLOGUE_END

        ldl     t0, ErExceptionFlags(a0) // get exception flags
        ldil    a0, INTERRUPT_UNWIND_ATTEMPTED // assume unwind in progress
        and     t0, EXCEPTION_UNWIND, t1 // check if unwind in progress
        bne     t1, 10f                  // if ne, unwind in progress
        ldil    a0, INTERRUPT_EXCEPTION_NOT_HANDLED // set bug check code
10:     bsr     ra, KeBugCheck           // call bug check routine

        .end    KiInterruptHandler

        SBTTL("System Service Dispatch")
//++
//
// Routine Description:
//
//    The following code is never executed. Its purpose is to allow the
//    kernel debugger to walk call frames backwards through an exception,
//    to support unwinding through exceptions for system services, and to
//    support get/set user context.
//
//--
        .struct 0
ScCurrentThread:                        // current thread address
        .space  8                       //
ScServiceRoutine:                       // service routine address
        .space  8                       //
ScServiceDescriptor:                    // service descriptor address
        .space  8                       //
ScServiceNumber:                        // service number
        .space  4                       //
        .space  4                       // fill
SyscallFrameLength:                     // frame length

        EXCEPTION_HANDLER(KiSystemServiceHandler)

        NESTED_ENTRY(KiSystemServiceDispatch, TrapFrameLength, zero);

        .set    noreorder
        stq     sp, TrIntSp - TrapFrameLength(sp) // save stack pointer
        lda     sp, -TrapFrameLength(sp) // allocate stack frame
        stq     ra,TrIntRa(sp)          // save return address
        stq     ra,TrFir(sp)            // save return address
        stq     fp,TrIntFp(sp)          // save frame pointer
        stq     gp,TrIntGp(sp)          // save general pointer
        bis     sp, sp, fp              // set frame pointer
        .set    reorder

        PROLOGUE_END

//++
//
// Routine Description:
//
//    Control reaches here when we have a system call call pal executed.
//    When this routine is entered, interrupts are disabled.
//
//    The function of this routine is to call the specified system service.
//
//
// Arguments:
//
//    v0 - Supplies the system service code.
//    t0 - Previous processor mode
//    t1 - Current thread address
//    gp - Supplies a pointer to the system short data area.
//    fp - Supplies a pointer to the trap frame.
//
// Return Value:
//
//    None.
//
//--

        ALTERNATE_ENTRY(KiSystemServiceException)

        START_REGION(KiSystemServiceDispatchStart)

        mf_fpcr f0                      // save floating control register
        stt     f0, TrFpcr(fp)          //
        lda     sp, -SyscallFrameLength(sp) // allocate stack frame
        STP     t1, ScCurrentThread(sp) // save current thread address
        ldq_u   t4, ThPreviousMode(t1)  // get old previous thread mode
        LDP     t5, ThTrapFrame(t1)     // get current trap frame address
        extbl   t4, ThPreviousMode % 8, t3 // extract previous mode
        stl     t3, TrPreviousMode(fp)  // save old previous mode of thread
        StoreByte(t0, ThPreviousMode(t1)) // set new previous mode in thread
        STP     t5, TrTrapFrame(fp)     // save current trap frame address

//
// If the specified system service number is not within range, then
// attempt to convert the thread to a GUI thread and retry the service
// dispatch.
//
// N.B. The argument registers a0-a3, the system service number in v0,
//      and the thread address in t1 must be preserved while attempting
//      to convert the thread to a GUI thread.
//

        ALTERNATE_ENTRY(KiSystemServiceRepeat)

        STP     fp, ThTrapFrame(t1)     // save address of trap frame
        LDP     t10, ThServiceTable(t1) // get service descriptor table address
        srl     v0, SERVICE_TABLE_SHIFT, t2 // isolate service descriptor offset
        and     t2, SERVICE_TABLE_MASK, t2 //
        ADDP    t2, t10, t10            // compute service descriptor address
        ldl     t3, SdLimit(t10)        // get service number limit
        and     v0, SERVICE_NUMBER_MASK, t7 // isolate service table offset
        cmpult  t7, t3, t4              // check if valid service number
        beq     t4, 80f                 // if eq, not valid service number
        LDP     t4, SdBase(t10)         // get service table address
        SPADDP  t7, t4, t3              // compute address in service table
        LDP     t5, 0(t3)               // get address of service routine

#if DBG

        LDP     t6, SdCount(t10)        // get service count table address
        beq     t6, 5f                  // if eq, table not defined
        S4ADDP  t7, t6, t6              // compute system service offset value
        ldl     t11, 0(t6)              // increment system service count
        addl    t11, 1, t11             //
        stl     t11, 0(t6)              // store result

#endif

//
// If the system service is a GUI service and the GDI user batch queue is
// not empty, then call the appropriate service to flush the user batch.
//

5:      cmpeq   t2, SERVICE_TABLE_TEST, t2 // check if GUI system service
        beq     t2, 15f                 // if eq, not GUI system service
        LDP     t3, ThTeb(t1)           // get current thread TEB address
        ldl     t4, TeGdiBatchCount(t3) // get number of batched GDI calls
        beq     t4, 15f                 // if eq, no batched calls
        STP     t5, ScServiceRoutine(sp) // save service routine address
        STP     t10, ScServiceDescriptor(sp)// save service descriptor address
        stl     t7, ScServiceNumber(sp)  // save service table offset
        LDP     t5, KeGdiFlushUserBatch // get address of flush routine
        stq     a0, TrIntA0(fp)         // save possible arguments
        stq     a1, TrIntA1(fp)         //
        stq     a2, TrIntA2(fp)         //
        stq     a3, TrIntA3(fp)         //
        stq     a4, TrIntA4(fp)         //
        stq     a5, TrIntA5(fp)         //
        jsr     ra, (t5)                // flush GDI user batch
        ldq     a0, TrIntA0(fp)         // restore possible arguments
        ldq     a1, TrIntA1(fp)         //
        ldq     a2, TrIntA2(fp)         //
        ldq     a3, TrIntA3(fp)         //
        ldq     a4, TrIntA4(fp)         //
        ldq     a5, TrIntA5(fp)         //
        LDP     t5, ScServiceRoutine(sp) // restore service routine address
        LDP     t10, ScServiceDescriptor(sp) // restore service descriptor address
        ldl     t7, ScServiceNumber(sp) // restore service table offset

//
// Check if system service has any in memory arguments.
//

15:     blbc    t5, 30f                 // if clear, no in memory arguments
        LDP     t10, SdNumber(t10)      // get argument table address
        ADDP    t7, t10, t11            // compute address in argument table

//
// The following code captures arguments that were passed in memory on the
// callers stack. This is necessary to ensure that the caller does not modify
// the arguments after they have been probed and is also necessary in kernel
// mode because a trap frame has been allocated on the stack.
//
// If the previous mode is user, then the user stack is probed for readability.
//

        LDP     t10, TrIntSp(fp)        // get previous stack pointer
        beq     t0, 10f                 // if eq, previous mode was kernel
        LDIP    t2, MM_USER_PROBE_ADDRESS // get user probe address
        cmpult  t10, t2, t4             // check if stack in user region
        cmoveq  t4, t2, t10             // if eq, set invalid user stack address
10:     ldq_u   t4, 0(t11)              // get number of memory arguments * 8
        extbl   t4, t11, t9             //
        addl    t9, 0x1f, t3            // round up to hexaword (32 bytes)
        bic     t3, 0x1f, t3            // ensure hexaword alignment
        SUBP    sp, t3, sp              // allocate space on kernel stack
        bis     sp, zero, t2            // set destination copy address
        ADDP    t2, t3, t4              // compute destination end address

        START_REGION(KiSystemServiceStartAddress)

//
// This code is set up to load the cache block in the first
// instruction and then perform computations that do not require
// the cache while waiting for the data.  In addition, the stores
// are setup so they will be in order.
//

20:     ldq     t6, 24(t10)             // get argument from previous stack
        ADDP    t10, 32, t10            // next hexaword on previous stack
        ADDP    t2, 32, t2              // next hexaword on kernel stack
        cmpeq   t2, t4, t11             // at end address?
        stq     t6, -8(t2)              // store argument on kernel stack
        ldq     t7, -16(t10)            // argument from previous stack
        ldq     t8, -24(t10)            // argument from previous stack
        ldq     t9, -32(t10)            // argument from previous stack
        stq     t7, -16(t2)             // save argument on kernel stack
        stq     t8, -24(t2)             // save argument on kernel stack
        stq     t9, -32(t2)             // save argument on kernel stack
        beq     t11, 20b                // if eq, get next block

        END_REGION(KiSystemServiceEndAddress)

        bic     t5, 3, t5               // clear lower bits of service addr

//
// Call system service.
//

30:     jsr     ra, (t5)

//
// Restore old trap frame address from the current trap frame and update
// the number of system calls.
//

        ALTERNATE_ENTRY(KiSystemServiceExit)

        bis     v0, zero, t1            // save return status

        GET_PROCESSOR_CONTROL_BLOCK_BASE // get processor block address

        LDP     t2, -SyscallFrameLength + ScCurrentThread(fp) // get current thread address
        LDP     t3, TrTrapFrame(fp)     // get old trap frame address
        ldl     t10, PbSystemCalls(v0)  // increment number of calls
        addl    t10, 1, t10             //
        stl     t10, PbSystemCalls(v0)  // store result
        STP     t3, ThTrapFrame(t2)     // restore old trap frame address
        bis     t1, zero, v0            // restore return status
        ldt     f0, TrFpcr(fp)          // restore floating control register
        mt_fpcr f0                      //
        ldl     a0, TrPsr(fp)           // get previous processor status
        ldl     t5, TrPreviousMode(fp)  // get old previous mode
        StoreByte(t5, ThPreviousMode(t2)) // store previous mode in thread

//
// Check if an APC interrupt should be generated.
//

        bis     zero, zero, a1          // clear siftware interrupt request
        blbc    a0, 70f                 // if kernel mode skip apc check
        ldq_u   t1, ThApcState+AsUserApcPending(t2) // get user APC pending
        extbl   t1, (ThApcState+AsUserApcPending) % 8, t0 //
        ZeroByte(ThAlerted(t2))         // clear kernel mode alerted
        cmovne  t0, APC_INTERRUPT, a1   // if pending set APC interrupt

//
// a0 = previous psr
// a1 = sfw interrupt requests
//

70:     RETURN_FROM_SYSTEM_CALL         // return to caller

//
// The specified system service number is not within range. Attempt to
// convert the thread to a GUI thread if specified system service is a
// GUI service.
//
// N.B. The argument register a0-a5 and the system service number in v0
//      must be preserved if an attempt is made to convert the thread to
//      a GUI thread.
//

80:     cmpeq   t2, SERVICE_TABLE_TEST, t2 // check if GUI system service
        beq     t2, 55f                 // if eq, not GUI system service
        stl     v0, ScServiceNumber(sp) // save system service number
        stq     a0, TrIntA0(fp)         // save argument registers a0-a5
        stq     a1, TrIntA1(fp)         //
        stq     a2, TrIntA2(fp)         //
        stq     a3, TrIntA3(fp)         //
        stq     a4, TrIntA4(fp)         //
        stq     a5, TrIntA5(fp)         //
        bsr     ra, PsConvertToGuiThread // attempt to convert to GUI thread
        bis     v0, zero, t0            // save completion status
        lda     fp, SyscallFrameLength(sp) // restore trap frame address

        GET_CURRENT_THREAD              // restore current thread address

        bis     v0, zero, t1            // set current thread address
        ldl     v0, ScServiceNumber(sp) // restore system service number
        ldq     a0, TrIntA0(fp)         // restore argument registers a0-a5
        ldq     a1, TrIntA1(fp)         //
        ldq     a2, TrIntA2(fp)         //
        ldq     a3, TrIntA3(fp)         //
        ldq     a4, TrIntA4(fp)         //
        ldq     a5, TrIntA5(fp)         //
        beq     t0, KiSystemServiceRepeat // if eq, successful conversion

//
// The conversion to a Gui thread failed. The correct return value is encoded
// in a byte table indexed by the service number that is at the end of the
// service address table. The encoding is as follows:
//
//     0 - return 0.
//    -1 - return -1.
//     1 - return status code.
//

        lda     t2, KeServiceDescriptorTableShadow // get descriptor base address
        ldl     t3, SERVICE_TABLE_TEST + SdLimit(t2) // get service number limit
        LDP     t4, SERVICE_TABLE_TEST + SdBase(t2) // get service table address
        SPADDP  t3, t4, t2              // compute ending service table address
        and     v0, SERVICE_NUMBER_MASK, t3 // isolate service number
        ADDP    t2, t3, t3              // compute return value address
        ldq_u   t2, 0(t3)               // get packed status bytes
        extbl   t2, t3, t2              // extract encoded status byte
        sll     t2, 7 * 8, t2           // sign extend status byte value
        sra     t2, 7 * 8, v0           //
        ble     v0, KiSystemServiceExit // if le, return value set

//
// Return invalid system service status for invalid service code.
//

55:     ldil    v0, STATUS_INVALID_SYSTEM_SERVICE // set completion status
        br      zero, KiSystemServiceExit //

        END_REGION(KiSystemServiceDispatchEnd)

        .end    KiSystemServiceDispatch

//++
//
// EXCEPTION_DISPOSITION
// KiSystemServiceHandler (
//    IN PEXCEPTION_RECORD ExceptionRecord,
//    IN ULONG EstablisherFrame,
//    IN OUT PCONTEXT ContextRecord,
//    IN OUT PDISPATCHER_CONTEXT DispatcherContext
//    )
//
// Routine Description:
//
//    Control reaches here when a exception is raised in a system service
//    or the system service dispatcher, and for an unwind during a kernel
//    exception.
//
//    If an unwind is being performed and the system service dispatcher is
//    the target of the unwind, then an exception occured while attempting
//    to copy the user's in-memory argument list. Control is transfered to
//    the system service exit by return a continue execution disposition
//    value.
//
//    If an unwind is being performed and the previous mode is user, then
//    bug check is called to crash the system. It is not valid to unwind
//    out of a system service into user mode.
//
//    If an unwind is being performed, the previous mode is kernel, the
//    system service dispatcher is not the target of the unwind, and the
//    thread does not own any mutexes, then the previous mode field from
//    the trap frame is restored to the thread object. Otherwise, bug
//    check is called to crash the system. It is invalid to unwind out of
//    a system service while owning a mutex.
//
//    If an exception is being raised and the exception PC is within the
//    range of the system service dispatcher in-memory argument copy code,
//    then an unwind to the system service exit code is initiated.
//
//    If an exception is being raised and the exception PC is not within
//    the range of the system service dispatcher, and the previous mode is
//    not user, then a continue searh disposition value is returned. Otherwise,
//    a system service has failed to handle an exception and bug check is
//    called. It is invalid for a system service not to handle all exceptions
//    that can be raised in the service.
//
// Arguments:
//
//    ExceptionRecord (a0) - Supplies a pointer to an exception record.
//
//    EstablisherFrame (a1) - Supplies the frame pointer of the establisher
//       of this exception handler.
//
//       N.B. This is not actually the frame pointer of the establisher of
//            this handler. It is actually the stack pointer of the caller
//            of the system service. Therefore, the establisher frame pointer
//            is not used and the address of the trap frame is determined by
//            examining the saved fp register in the context record.
//
//    ContextRecord (a2) - Supplies a pointer to a context record.
//
//    DispatcherContext (a3) - Supplies a pointer to  the dispatcher context
//       record.
//
// Return Value:
//
//    If bug check is called, there is no return from this routine and the
//    system is crashed. If an exception occured while attempting to copy
//    the user in-memory argument list, then there is no return from this
//    routine, and unwind is called. Otherwise, ExceptionContinueSearch is
//    returned as the function value.
//
//--

        LEAF_ENTRY(KiSystemServiceHandler)

        lda     sp, -HandlerFrameLength(sp) // allocate stack frame
        stq     ra, HdRa(sp)            // save return address

        PROLOGUE_END

        ldl     t0, ErExceptionFlags(a0) // get exception flags
        and     t0, EXCEPTION_UNWIND, t1 // check if unwind in progress
        bne     t1, 40f                  // if ne, unwind in progress

//
// An exception is in progress.
//
// If the exception PC is within the in-memory argument copy code of the
// system service dispatcher, then call unwind to transfer control to the
// system service exit code. Otherwise, check if the previous mode is user
// or kernel mode.
//
//

        LDP     t0, ErExceptionAddress(a0) // get address of exception
        lda     t1, KiSystemServiceStartAddress // address of system service
        cmpult  t0, t1, t3                 // check if before start range
        lda     t2, KiSystemServiceEndAddress // end address
        bne     t3, 10f                 // if ne, before start of range
        cmpult  t0, t2, t3              // check if before end of range
        bne     t3, 30f                 // if ne, before end of range

//
// If the previous mode was kernel mode, then a continue search disposition
// value is returned. Otherwise, the exception was raised in a system service
// and was not handled by that service. Call bug check to crash the system.
//

10:     GET_CURRENT_THREAD              // get current thread address

        ldq_u   t4, ThPreviousMode(v0)  // get previous mode from thread
        extbl   t4, ThPreviousMode % 8, t1 //
        bne     t1, 20f                 // if ne, previous mode was user

//
// Previous mode is kernel mode.
//

        ldil    v0, ExceptionContinueSearch // set disposition code
        lda     sp, HandlerFrameLength(sp) // deallocate stack frame
        jmp     zero, (ra)              // return

//
// Previous mode is user mode. Call bug check to crash the system.
//

20:     bis     a3, zero, a4            // set dispatcher context address
        bis     a2, zero, a3            // set context record address
        bis     a1, zero, a2            // set system service frame address
        bis     a0, zero, a1            // set exception record address
        ldil    a0, SYSTEM_SERVICE_EXCEPTION // set bug check code
        bsr     ra, KeBugCheckEx        // call bug check routine

//
// The exception was raised in the system service dispatcher. Unwind to the
// the system service exit code.
//

30:     ldl     a3, ErExceptionCode(a0) // set return value
        bis     zero, zero, a2          // set exception record address
        bis     a1, zero, a0            // set target frame address
        lda     a1, KiSystemServiceExit // set target PC address
        bsr     ra, RtlUnwind           // unwind to system service exit

//
// An unwind is in progress.
//
// If a target unwind is being performed, then continue execution is returned
// to transfer control to the system service exit code. Otherwise, restore the
// previous mode if the previous mode is not user and there are no mutexes owned
// by the current thread.
//

40:     and     t0, EXCEPTION_TARGET_UNWIND, t1 // check if target unwnd in progres
        bne     t1, 60f                 // if ne, target unwind in progress

//
// An unwind is being performed through the system service dispatcher. If the
// previous mode is not kernel or the current thread owns one or more mutexes,
// then call bug check and crash the system. Otherwise, restore the previous
// mode in the current thread object.
//

        GET_CURRENT_THREAD              // get current thread address

        ldl     t1, CxIntFp(a2)         // get address of trap frame
        ldq_u   t4, ThPreviousMode(v0)  // get previous mode from thread
        extbl   t4, ThPreviousMode % 8, t3 //
        ldl     t4,TrPreviousMode(t1)   // get previous mode from trap frame
        bne     t3, 50f                 // if ne, previous mode was user

//
// Restore previous from trap frame to thread object and continue the unwind
// operation.
//

        StoreByte(t4, ThPreviousMode(v0)) // restore previous mode from trap frame
        ldil    v0, ExceptionContinueSearch // set disposition value
        lda     sp, HandlerFrameLength(sp) // deallocate stack frame
        jmp     zero, (ra)              // return

//
// An attempt is being made to unwind into user mode. Call bug check to crash
// the system.
//

50:     ldil    a0, SYSTEM_UNWIND_PREVIOUS_USER // set bug check code
        bsr     ra, KeBugCheck          // call bug check

//
// A target unwind is being performed. Return a continue search disposition
// value.
//

60:     ldil    v0, ExceptionContinueSearch // set disposition value
        lda     sp, HandlerFrameLength(sp) // deallocate stack frame
        jmp      zero, (ra)             // return

        .end    KiSystemServiceHandler

//++
//
// Routine Description:
//
//     The following code is never executed.  Its purpose is to allow the
//     kernel debugger to walk call frames backwards through an exception
//     to support unwinding through exceptions for system services, and to
//     support get/set user context.
//--

        NESTED_ENTRY(KiPanicDispatch, TrapFrameLength, zero)

        .set    noreorder
        stq     sp, TrIntSp(sp)         // save stack pointer
        stq     ra, TrIntRa(sp)         // save return address
        stq     ra, TrFir(sp)           // save return address
        stq     fp, TrIntFp(sp)         // save frame pointer
        stq     gp, TrIntGp(sp)         // save global pointer
        bis     sp, sp, fp              // set frame pointer
        .set    reorder

        PROLOGUE_END

//++
//
// Routine Description:
//
//     PALcode dispatches to this entry point when a panic situation
//     is detected while in PAL mode.  The panic situation may be that
//     the kernel stack is about to overflow/underflow or there may be
//     a condition that was not expected to occur while in PAL mode
//     (eg. arithmetic exception while in PAL).  This entry point is
//     here to help us debug the condition.
//
// Arguments:
//
//      fp - points to trap frame
//      sp - points to exception frame
//      a0 = Bug check code
//      a1 = Exception address
//      a2 = Bugcheck parameter
//      a3 = Bugcheck parameter
//
//      gp, ra - saved in trap frame
//      a0-a3 - saved in trap frame
//
// Return Value:
//
//      None.
//
//--

        ALTERNATE_ENTRY(KiPanicException)

        stq     ra, TrIntRa(fp)         // PAL is supposed to do this, but it doesn't!

//
// Save state, volatile float and integer state via KiGenerateTrapFrame
//

        bsr     ra, KiGenerateTrapFrame // save volatile state

//
// Dispatch to KeBugCheckEx, does not return
//

        br      ra, KeBugCheckEx        // do the bugcheck

        .end    KiPanicDispatch

//++
//
// VOID
// KiBreakinBreakpoint(
//     VOID
//     );
//
// Routine Description:
//
//     This routine issues a breakin breakpoint.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      None.
//
//--

        LEAF_ENTRY( KiBreakinBreakpoint )

        BREAK_BREAKIN                   // execute breakin breakpoint

        ret     zero, (ra)              // return to caller

        .end    KiBreakinBreakpoint
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\timindex.s ===
//      TITLE("Compute Timer Table Index")
//++
//
// Copyright (c) 1993  Microsoft Corporation
//
// Module Name:
//
//    timindex.s
//
// Abstract:
//
//    This module implements the code necessary to compute the timer table
//    index for a timer.
//
// Author:
//
//    David N. Cutler (davec) 17-May-1993
//    Joe Notarangelo 20-Jul-1993  (Alpha AXP version)
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

        SBTTL("Compute Timer Table Index")
//++
//
// ULONG
// KiComputeTimerTableIndex (
//    IN LARGE_INTEGER Interval,
//    IN LARGE_INTEGER CurrentTime,
//    IN PKTIMER Timer
//    )
//
// Routine Description:
//
//    This function computes the timer table index for the specified timer
//    object and stores the due time in the timer object.
//
//    N.B. The interval parameter is guaranteed to be negative since it is
//         expressed as relative time.
//
//    The formula for due time calculation is:
//
//    Due Time = Current Time - Interval
//
//    The formula for the index calculation is:
//
//    Index = (Due Time / Maximum Time) & (Table Size - 1)
//
//    The index division is performed using reciprocal multiplication.
//
// Arguments:
//
//    Interval (a0) - Supplies the relative time at which the timer is
//        to expire.
//
//    CurrentTime (a1) - Supplies the current interrupt time.
//
//    Timer (a2) - Supplies a pointer to a dispatch object of type timer.
//
// Return Value:
//
//    The time table index is returned as the function value and the due
//    time is stored in the timer object.
//
//--

        LEAF_ENTRY(KiComputeTimerTableIndex)

//
// Compute the due time and store in the timer object.
//

        subq    a1, a0, t0              // compute due time
        stq     t0, TiDueTime(a2)       // set due time of timer object

//
// Capture global values for magic divide, the reciprocal multiply value
// and the shift count.
//

	lda	t2, KiTimeIncrementReciprocal // get address of reciprocal
	ldq	t1, 0(t2)		// get timer reciprocal for magic divide
	lda	t2, KiTimeIncrementShiftCount // get address of shift count
	ldq_u	t10, 0(t2)		// read surrounding quadword
	extbl	t10, t2, t10		// extract shift count for magic divide

//
// Do the reciprocal multiply and capture the upper 64 bits of the
// 128 bit product with umulh instruction.
//

	umulh	t0, t1, t11		// t11 = upper 64 bits of product

//
// Right shift the result by the specified shift count and mask off extra
// bits.
//

	srl	t11, t10, t0		// t0 = division result
	ldil	t3, TIMER_TABLE_SIZE - 1 // get mask value
	and	t0, t3, v0		// v0 = mask result
	ret	zero, (ra)		// return
	
        .end    KiComputeTimerTableIndex
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\threadbg.s ===
//      TITLE("Thread Startup")
//++
//
// Copyright (c) 1990  Microsoft Corporation
// Copyright (c) 1992, 1993  Digital Equipment Corporation
//
// Module Name:
//
//    threadbg.s
//
// Abstract:
//
//    This module implements the MIPS machine dependent code necessary to
//    startup a thread in kernel mode.
//
// Author:
//
//    David N. Cutler (davec) 28-Mar-1990
//    Joe Notarangelo  21-Apr-1992
//
// Environment:
//
//    Kernel mode only, IRQL APC_LEVEL.
//
// Revision History:
//
//--

#include "ksalpha.h"

//++
//
// RoutineDescription:
//
//    The following code is never executed. Its purpose is to allow the
//    kernel debugger to walk call frames backwards through thread startup
//    and to support get/set user context.
//
//--

        NESTED_ENTRY(KiThreadDispatch, ExceptionFrameLength, zero)

        lda     sp, -ExceptionFrameLength(sp) // allocate exception frame
        stq     ra, ExIntRa(sp)         // save return address
        stq     s0, ExIntS0(sp)         // save integer regs s0-s5
        stq     s1, ExIntS1(sp)         //
        stq     s2, ExIntS2(sp)         //
        stq     s3, ExIntS3(sp)         //
        stq     s4, ExIntS4(sp)         //
        stq     s5, ExIntS5(sp)         //

        stt     f2, ExFltF2(sp)         // save floating regs f2 - f9
        stt     f3, ExFltF3(sp)         //
        stt     f4, ExFltF4(sp)         //
        stt     f5, ExFltF5(sp)         //
        stt     f6, ExFltF6(sp)         //
        stt     f7, ExFltF7(sp)         //
        stt     f8, ExFltF8(sp)         //
        stt     f9, ExFltF9(sp)         //

        PROLOGUE_END

//++
//
// Routine Description:
//
//    This routine is called at thread startup. Its function is to call the
//    initial thread procedure. If control returns from the initial thread
//    procedure and a user mode context was established when the thread
//    was initialized, then the user mode context is restored and control
//    is transfered to user mode. Otherwise a bug check will occur.
//
//
// Arguments:
//
//    sp - Supplies a pointer to the exception frame which contains the
//         startup parameters.
//
//    Within Exception frame:
//
//    s0 - Supplies a boolean value that specified whether a user mode
//       thread context was established when the thread was initialized.
//
//    s1 - Supplies the starting context parameter for the initial thread
//       procedure.
//
//    s2 - Supplies the starting address of the initial thread routine.
//
//    s3 - Supplies the starting address of the initial system routine.
//
// Return Value:
//
//    None.
//
//--

        ALTERNATE_ENTRY(KiThreadStartup)

//
// Capture the arguments for startup from the exception frame.
// After the arguments are captured, deallocate the exception frame.
//

        ldq     s0, ExIntS0(sp)         // capture user context boolean
        ldq     s1, ExIntS1(sp)         // set startup context parameter
        ldq     s2, ExIntS2(sp)         // set address of thread routine
        ldq     s3, ExIntS3(sp)         // capture startup routine address
        ldq     s4, ExIntS4(sp)         // restore s4
        ldq     s5, ExIntS5(sp)         // restore s5
        ldq     fp, ExIntFp(sp)         // restore trap frame pointer
        lda     sp, ExceptionFrameLength(sp) // deallocate exception frame

//
// Lower Irql to APC level.
//

        ldil    a0, APC_LEVEL           // set IRQL to APC level

        SWAP_IRQL                       // lower IRQL

//
// Jump to the startup routine with the address of the thread routine and
// the startup context parameter.
//

        bis     s2, zero, a0            // set address of thread routine
        bis     s1, zero, a1            // set startup context parameter
        jsr     ra, (s3)                // call system startup routine

//
// If we return and no user context was supplied then we have trouble.
//

        beq     s0, 20f                 // if eq, no user context

//
// Finish in common exception exit code which will restore the nonvolatile
// registers and exit to user mode.
//

        br      zero, KiExceptionExit   // finish in exception exit code

//
// An attempt was made to enter user mode for a thread that has no user mode
// context. Generate a bug check.
//

20:     ldil    a0, NO_USER_MODE_CONTEXT // set bug check code
        bsr     ra, KeBugCheck          // call bug check routine

        .end    KiThreadDispatch

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\vdm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    VDM.C

Abstract:

    This routine has a stub for the x86 only api NtStartVdmExecution.

Author:

    Dave Hastings (daveh) 2 Apr 1991


Revision History:

--*/

#include "ki.h"



NTSTATUS
NtInitializeVDM(
    VOID
    )
{
    return STATUS_SUCCESS;
}

NTSTATUS
NtVdmStartExecution (
    )

/*++

Routine Description:

    This routine returns STATUS_NOT_IMPLEMENTED

Arguments:

Return Value:

    STATUS_NOT_IMPLEMENTED
--*/
{

    return STATUS_NOT_IMPLEMENTED;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\thredini.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    thredini.c

Abstract:

    This module implements the machine dependent functions to set the initial
    context and data alignment handling mode for a process or thread object.

Author:

    David N. Cutler (davec) 1-Apr-1990

Environment:

    Kernel mode only.

Revision History:

    Joe Notarangelo  21-Apr-1992
        very minor changes for ALPHA
	     1. psr definition
	     2. pte and mask (from 3ffffc to 1ffffc), mips page size is 4k
	            our first alpha page size is 8k
		    mips code shifts right 10 (12-2) and then turns off the
		    upper 10 bits, alpha shifts right 11 (13-2) and so must
		    turn off upper 11 bits
	     3. Insert register values into context structure as quadwords
		    to insure that the written values are in canonical form

    Thomas Van Baak (tvb) 9-Oct-1992

        Adapted for Alpha AXP.

--*/

#include "ki.h"

//
// The following assert macros are used to check that an input object is
// really the proper type.
//

#define ASSERT_PROCESS(E) {                    \
    ASSERT((E)->Header.Type == ProcessObject); \
}

#define ASSERT_THREAD(E) {                    \
    ASSERT((E)->Header.Type == ThreadObject); \
}

VOID
KiInitializeContextThread (
    IN PKTHREAD Thread,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PCONTEXT ContextRecord OPTIONAL
    )

/*++

Routine Description:

    This function initializes the machine dependent context of a thread object.

    N.B. This function does not check the accessibility of the context record.
         It is assumed the the caller of this routine is either prepared to
         handle access violations or has probed and copied the context record
         as appropriate.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to an arbitrary data structure
        which will be passed to the StartRoutine as a parameter. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    ContextRecord - Supplies an optional pointer a context frame which contains
        the initial user mode state of the thread. This parameter is specified
        if the thread is a user thread and will execute in user mode. If this
        parameter is not specified, then the Teb parameter is ignored.

Return Value:

    None.

--*/

{

    PKEXCEPTION_FRAME CxFrame;
    PKEXCEPTION_FRAME ExFrame;
    ULONG_PTR InitialStack;
    PKTRAP_FRAME TrFrame;

    //
    // If a context frame is specified, then initialize a trap frame and
    // and an exception frame with the specified user mode context.
    //

    InitialStack = (ULONG_PTR)Thread->InitialStack;
    if (ARGUMENT_PRESENT(ContextRecord)) {
        TrFrame = (PKTRAP_FRAME)(((InitialStack) -
                  sizeof(KTRAP_FRAME)) & ~((ULONG_PTR)15));
        ExFrame = (PKEXCEPTION_FRAME)(((ULONG_PTR)TrFrame -
                  sizeof(KEXCEPTION_FRAME)) & ~((ULONG_PTR)15));
        CxFrame = (PKEXCEPTION_FRAME)(((ULONG_PTR)ExFrame -
                  sizeof(KEXCEPTION_FRAME)) & ~((ULONG_PTR)15));

        //
        // Zero the exception and trap frames and copy information from the
        // specified context frame to the trap and exception frames.
        //

        RtlZeroMemory((PVOID)ExFrame, sizeof(KEXCEPTION_FRAME));
        RtlZeroMemory((PVOID)TrFrame, sizeof(KTRAP_FRAME));
        KeContextToKframes(TrFrame, ExFrame,
                           ContextRecord,
                           ContextRecord->ContextFlags | CONTEXT_CONTROL,
                           UserMode);

        //
        // If the FPCR quadword in the specified context record is zero,
        // then assume it is a default value and force floating point round
        // to nearest mode (the hardware default mode is chopped rounding
        // which is not desirable for NT). It would be nice to initialize
        // the SoftFpcr here also but not all threads have a Teb.
        //

        if (TrFrame->Fpcr == 0) {
            ((PFPCR)(&TrFrame->Fpcr))->DynamicRoundingMode = ROUND_TO_NEAREST;
        }

        //
        // Set the saved previous processor mode in the trap frame and the
        // previous processor mode in the thread object to user mode.
        //

        TrFrame->PreviousMode = UserMode;
        Thread->PreviousMode = UserMode;

        //
        // Initialize the return address in the exception frame.
        //

        ExFrame->IntRa = 0;

    } else {
        ExFrame = NULL;
        CxFrame = (PKEXCEPTION_FRAME)(((InitialStack) -
                  sizeof(KEXCEPTION_FRAME)) & ~((ULONG_PTR)15));

        //
        // Set the previous mode in thread object to kernel.
        //

        Thread->PreviousMode = KernelMode;
    }

    //
    // Initialize context switch frame and set thread start up parameters.
    //
    // N.B. ULONG becomes canonical longword with (ULONGLONG)(LONG) cast.
    //

    CxFrame->SwapReturn = (ULONGLONG)(LONG_PTR)KiThreadStartup;
    if (ExFrame == NULL) {
        CxFrame->IntFp = (ULONGLONG)(LONG_PTR)ExFrame;

    } else {
        CxFrame->IntFp = (ULONGLONG)(LONG_PTR)TrFrame;
    }

    CxFrame->IntS0 = (ULONGLONG)(LONG_PTR)ContextRecord;
    CxFrame->IntS1 = (ULONGLONG)(LONG_PTR)StartContext;
    CxFrame->IntS2 = (ULONGLONG)(LONG_PTR)StartRoutine;
    CxFrame->IntS3 = (ULONGLONG)(LONG_PTR)SystemRoutine;

    CxFrame->Psr = 0;			// clear everything
    ((PSR *)(&CxFrame->Psr))->INTERRUPT_ENABLE = 1;
    ((PSR *)(&CxFrame->Psr))->IRQL = DISPATCH_LEVEL;
    ((PSR *)(&CxFrame->Psr))->MODE = 0;

    //
    // Set the initial kernel stack pointer.
    //

    Thread->KernelStack = (PVOID)(ULONGLONG)(LONG_PTR)CxFrame;
    return;
}

BOOLEAN
KeSetAutoAlignmentProcess (
    IN PKPROCESS Process,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function sets the data alignment handling mode for the specified
    process and returns the previous data alignment handling mode.

Arguments:

    Process  - Supplies a pointer to a dispatcher object of type process.

    Enable - Supplies a boolean value that determines the handling of data
        alignment exceptions for the process. A value of TRUE causes all
        data alignment exceptions to be automatically handled by the kernel.
        A value of FALSE causes all data alignment exceptions to be actually
        raised as exceptions.

Return Value:

    A value of TRUE is returned if data alignment exceptions were
    previously automatically handled by the kernel. Otherwise, a value
    of FALSE is returned.

--*/

{

    KIRQL OldIrql;
    BOOLEAN Previous;

    ASSERT_PROCESS(Process);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the previous data alignment handling mode and set the
    // specified data alignment mode.
    //

    Previous = Process->AutoAlignment;
    Process->AutoAlignment = Enable;

    //
    // Unlock dispatcher database, lower IRQL to its previous value, and
    // return the previous data alignment mode.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Previous;
}

BOOLEAN
KeSetAutoAlignmentThread (
    IN PKTHREAD Thread,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function sets the data alignment handling mode for the specified
    thread and returns the previous data alignment handling mode.

Arguments:

    Thread  - Supplies a pointer to a dispatcher object of type thread.

    Enable - Supplies a boolean value that determines the handling of data
        alignment exceptions for the thread. A value of TRUE causes all
        data alignment exceptions to be automatically handled by the kernel.
        A value of FALSE causes all data alignment exceptions to be actually
        raised as exceptions.

Return Value:

    A value of TRUE is returned if data alignment exceptions were
    previously automatically handled by the kernel. Otherwise, a value
    of FALSE is returned.

--*/

{

    KIRQL OldIrql;
    BOOLEAN Previous;

    ASSERT_THREAD(Thread);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the previous data alignment handling mode and set the
    // specified data alignment mode.
    //

    Previous = Thread->AutoAlignment;
    Thread->AutoAlignment = Enable;

    //
    // Unlock dispatcher database, lower IRQL to its previous value, and
    // return the previous data alignment mode.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Previous;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\xxalign.s ===
//	TITLE("Alignment emulation")
//++
//
//
// Copyright (c) 1992  Digital Equipment Corporation
//
// Module Name:
//
//    align.s
//
// Abstract:
//
//    This module implements the code to complete unaligned access
//    emulation.
//
// Author:
//
//    Joe Notarangelo 14-May-1992
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//--

#include "ksalpha.h"

//++
//
// UQUAD
// KiEmulateLoadLong(
//    IN PULONG UnalignedAddress
//    )
//
// Routine Description:
//
//    This routine returns the longword value stored at the unaligned
//    address passed in UnalignedAddress.
//
// Arguments:
//
//    UnalignedAddress(a0) - Supplies a pointer to long data value.
//
// Return Value:
//
//    The longword value at the address pointed to by UnalignedAddress.
//
//--

        LEAF_ENTRY(KiEmulateLoadLong)

	ldq_u	t0, 0(a0)		// get 1st quadword
	ldq_u	v0, 3(a0)		// get 2nd quadword

	extll	t0, a0, t0		// extract bytes from low quadword
	extlh	v0, a0, v0		// extract bytes from high quadword
	bis	v0, t0, v0		// v0 = longword

	addl	v0, zero, v0		// insure canonical longword form

	ret	zero, (ra)		// return

	.end	KiEmulateLoadLong



//++
//
// UQUAD
// KiEmulateLoadQuad(
//    IN PUQUAD UnalignedAddress
//    )
//
// Routine Description:
//
//    This routine returns the quadword value stored at the unaligned
//    address passed in UnalignedAddress.
//
// Arguments:
//
//    UnalignedAddress(a0) - Supplies a pointer to quad data value.
//
// Return Value:
//
//    The quadword value at the address pointed to by UnalignedAddress.
//
//--

        LEAF_ENTRY(KiEmulateLoadQuad)

	ldq_u	t0, 0(a0)		// get 1st quadword
	ldq_u	v0, 7(a0)		// get 2nd quadword

	extql	t0, a0, t0		// extract bytes from low quadword
	extqh	v0, a0, v0		// extract bytes from high quadword
	bis	v0, t0, v0		// v0 = longword

	ret	zero, (ra)		// return

	.end	KiEmulateLoadQuad

//++
//
// VOID
// KiEmulateStoreLong(
//    IN PULONG UnalignedAddress
//    IN UQUAD  Data
//    )
//
// Routine Description:
//
//    This routine stores the longword in Data to the UnalignedAddress.
//
// Arguments:
//
//    UnalignedAddress(a0) - Supplies a pointer to longword destination.
//    Data(a1)             - Supplies data value to store.
//
// Return Value:
//
//    None.
//
//--

	LEAF_ENTRY(KiEmulateStoreLong)

	ldq_u	t0, 0(a0)		// get 1st quadword
	ldq_u	t1, 3(a0)		// get 2nd quadword

	inslh	a1, a0, t2		// get bytes for high quadword
	insll	a1, a0, t3		// get bytes for low quadword

	msklh	t1, a0, t1		// clear corresponding bytes
	mskll	t0, a0, t0		// clear corresponding bytes

	bis	t1, t2, t1		// merge in bytes for high qw
	bis	t0, t3, t0		// merge in bytes for low qw

	stq_u	t1, 3(a0)		// must store high first in case
	stq_u	t0, 0(a0)		// address was actually aligned

	ret	zero, (ra)		// return

	.end	KiEmulateStoreLong


//++
//
// VOID
// KiEmulateStoreQuad(
//    IN PUQUAD UnalignedAddress
//    IN UQUAD  Data
//    )
//
// Routine Description:
//
//    This routine stores the quadword in Data to the UnalignedAddress.
//
// Arguments:
//
//    UnalignedAddress(a0) - Supplies a pointer to quadword destination.
//    Data(a1)             - Supplies the data value to store.
//
// Return Value:
//
//    None.
//
//--

	LEAF_ENTRY(KiEmulateStoreQuad)

	ldq_u	t0, 0(a0)		// get 1st quadword
	ldq_u	t1, 7(a0)		// get 2nd quadword

	insqh	a1, a0, t2		// get bytes for high quadword
	insql	a1, a0, t3		// get bytes for low quadword

	mskqh	t1, a0, t1		// clear corresponding bytes
	mskql	t0, a0, t0		// clear corresponding bytes

	bis	t1, t2, t1		// merge in bytes for high qw
	bis	t0, t3, t0		// merge in bytes for low qw

	stq_u	t1, 7(a0)		// must store high first in case
	stq_u	t0, 0(a0)		// address was actually aligned 

	ret	zero, (ra)		// return

	.end	KiEmulateStoreQuad


//++
//
// UQUAD
// KiEmulateLoadFloatIEEESingle(
//    IN PULONG UnalignedAddress
//    )
//
// Routine Description:
//
//    This routine returns the IEEE Single value stored at the unaligned
//    address passed in UnalignedAddress.
//
//    N.B. The value is returned as the memory format T-formatted
//	interpretation of the read S-format value.
//
// Arguments:
//
//    UnalignedAddress(a0) - Supplies a pointer to float single data.
//
// Return Value:
//
//    The single float value at the address pointed to by UnalignedAddress.
//
//--

	.struct 0
FlTemp:	.space	8			// temporary memory
	.space	8			// filler for alignment
FlFrameLength:				// length of stack frame

    NESTED_ENTRY(KiEmulateLoadFloatIEEESingle, FlFrameLength, zero)
	lda	sp, -FlFrameLength(sp)	// allocate temp space
    PROLOGUE_END

	//
	// get the value into an integer register
	//

	ldq_u	t0, 0(a0)		// get 1st quadword
	ldq_u	v0, 3(a0)		// get 2nd quadword

	extll	t0, a0, t0		// extract bytes from low quadword
	extlh	v0, a0, v0		// extract bytes from high quadword
	bis	v0, t0, v0		// v0 = longword


	//
	// v0 now is S memory format, however return from exception
	//	sequence will restore floating registers as T memory format
	//   convert v0 to T memory format

	stl	v0, FlTemp(sp)		// store bytes, S-mem-format
	lds	f0, FlTemp(sp)		// now S-reg-format
	stt	f0, FlTemp(sp)		// write as T-mem-format
	ldq	v0, FlTemp(sp)		// return as T-mem_format

	lda	sp, FlFrameLength(sp)	// deallocate stack frame

	ret	zero, (ra)		// return

	.end	KiEmulateLoadFloatIEEESingle



//++
//
// UQUAD
// KiEmulateLoadFloatIEEEDouble(
//    IN PUQUAD UnalignedAddress
//    )
//
// Routine Description:
//
//    This routine returns the quadword value stored at the unaligned
//    address passed in UnalignedAddress.
//
// Arguments:
//
//    UnalignedAddress(a0) - Supplies a pointer to double float data value.
//
// Return Value:
//
//    The double float value at the address pointed to by UnalignedAddress.
//
//--

    LEAF_ENTRY(KiEmulateLoadFloatIEEEDouble)

	ldq_u	t0, 0(a0)		// get 1st quadword
	ldq_u	v0, 7(a0)		// get 2nd quadword

	extql	t0, a0, t0		// extract bytes from low quadword
	extqh	v0, a0, v0		// extract bytes from high quadword
	bis	v0, t0, v0		// v0 = longword

	ret	zero, (ra)		// return

	.end	KiEmulateLoadFloatIEEEDouble

//++
//
// VOID
// KiEmulateStoreFloatIEEESingle(
//    IN PULONG UnalignedAddress
//    IN UQUAD  Data
//    )
//
// Routine Description:
//
//    This routine stores the float value in Data to the UnalignedAddress.
//
// Arguments:
//
//    UnalignedAddress(a0) - Supplies a pointer to float destination.
//    Data(a1)             - Supplies the data value to store.
//
// Return Value:
//
//    None.
//
//--

	.struct 0
FsTemp:	.space	8			// temporary memory
	.space	8			// filler for alignment
FsFrameLength:				// length of stack frame

    NESTED_ENTRY(KiEmulateStoreFloatIEEESingle, FsFrameLength, zero)
	lda	sp, -FsFrameLength(sp)	// allocate stack space
    PROLOGUE_END

	//
	// a1 is an integer version of the T-memory format
	//   convert it to integer version of S-memory format
	//

	stq	a1, FsTemp(sp)		// store bytes, T-mem-format
	ldt	f10, FsTemp(sp)		// load back in now in S-reg-format
	sts	f10, FsTemp(sp)		// now in S-mem-format
	ldl	a1, FsTemp(sp)		// now integer version of S-mem


	//
	// now problem is just to store an unaligned longword
	//

	ldq_u	t0, 0(a0)		// get 1st quadword
	ldq_u	t1, 3(a0)		// get 2nd quadword

	inslh	a1, a0, t2		// get bytes for high quadword
	insll	a1, a0, t3		// get bytes for low quadword

	msklh	t1, a0, t1		// clear corresponding bytes
	mskll	t0, a0, t0		// clear corresponding bytes

	bis	t1, t2, t1		// merge in bytes for high qw
	bis	t0, t3, t0		// merge in bytes for low qw

	stq_u	t1, 3(a0)		// must store high first in case
	stq_u	t0, 0(a0)		//   was actually aligned

	lda	sp, FsFrameLength(sp)	// restore stack frame

	ret	zero, (ra)		// return

	.end	KiEmulateStoreFloatIEEESingle


//++
//
// VOID
// KiEmulateStoreFloatIEEEDouble(
//    IN PUQUAD UnalignedAddress
//    IN UQUAD  Data
//    )
//
// Routine Description:
//
//    This routine stores the quadword in Data to the UnalignedAddress.
//
// Arguments:
//
//    UnalignedAddress(a0) - Supplies a pointer to double float destination.
//    Data(a1)             - Supplies the data value to store.
//
// Return Value:
//
//    None.
//
//--

	LEAF_ENTRY(KiEmulateStoreFloatIEEEDouble)

	ldq_u	t0, 0(a0)		// get 1st quadword
	ldq_u	t1, 7(a0)		// get 2nd quadword

	insqh	a1, a0, t2		// get bytes for high quadword
	insql	a1, a0, t3		// get bytes for low quadword

	mskqh	t1, a0, t1		// clear corresponding bytes
	mskql	t0, a0, t0		// clear corresponding bytes

	bis	t1, t2, t1		// merge in bytes for high qw
	bis	t0, t3, t0		// merge in bytes for low qw

	stq_u	t1, 7(a0)		// must store high first in case
	stq_u	t0, 0(a0)		//   was actually aligned

	ret	zero, (ra)		// return

	.end	KiEmulateStoreFloatIEEEDouble
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\alpha\trigger.c ===
/*++

Copyright (c) 1993  Digital Equipment Corporation

Module Name:

    trigger.c

Abstract:

    This module implements functions that handle synchronous and asynchronous
    arithmetic exceptions. The Alpha SRM specifies certain code generation
    rules which if followed allow this code (in conjunction with internal
    processor register state) to effect a precise, synchronous exception
    given an imprecise, asynchronous exception. This capability is required
    for software emulation of the IEEE single and double floating operations.

Author:

    Thomas Van Baak (tvb) 5-Mar-1993

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#pragma hdrstop
#include "alphaops.h"

//
// Define forward referenced function prototypes.
//

BOOLEAN
KiLocateTriggerPc (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PKTRAP_FRAME TrapFrame
    );

//
// Define debugging macros.
//

#if DBG

extern ULONG RtlDebugFlags;
#define DBGPRINT ((RtlDebugFlags & 0x4) != 0) && DbgPrint

#else

#define DBGPRINT 0 && DbgPrint

#endif

//
// Define non-IEEE (a/k/a `high performance') arithmetic exception types.
// The PALcode exception record is extended by one word and the 4th word
// contains the reason the arithmetic exception is not an IEEE exception.
//

#define NON_IEEE(ExceptionRecord, Reason) \
    (ExceptionRecord)->NumberParameters = 4; \
    (ExceptionRecord)->ExceptionInformation[3] = (Reason);

#define TRIGGER_FLOATING_REGISTER_MASK_CLEAR 1
#define TRIGGER_INTEGER_REGISTER_MASK_SET 2
#define TRIGGER_NO_SOFTWARE_COMPLETION 3
#define TRIGGER_INVALID_INSTRUCTION_FOUND 4
#define TRIGGER_INSTRUCTION_FETCH_ERROR 5
#define TRIGGER_INSTRUCTION_NOT_FOUND 6
#define TRIGGER_SOURCE_IS_DESTINATION 7
#define TRIGGER_WRONG_INSTRUCTION 8

BOOLEAN
KiFloatingException (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN OUT PKTRAP_FRAME TrapFrame,
    IN BOOLEAN ImpreciseTrap,
    IN OUT PULONG SoftFpcrCopy
    )

/*++

Routine Description:

    This function is called to emulate a floating operation and convert the
    exception status to the proper value. If the exception is a fault, the
    faulting floating point instruction is emulated. If the exception is an
    imprecise trap, an attempt is made to locate and to emulate the original
    trapping floating point instruction.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    ImpreciseTrap - Supplies a boolean value that specifies whether the
        exception is an imprecise trap.

    SoftFpcrCopy - Supplies a pointer to a longword variable that receives
        a copy of the software FPCR.

Return Value:

    A value of TRUE is returned if the floating exception is successfully
    emulated. Otherwise, a value of FALSE is returned.

--*/

{

    BOOLEAN Status;
    PSW_FPCR SoftwareFpcr;
    PTEB Teb;

    try {

        //
        // Obtain a copy of the software FPCR longword from the TEB.
        //

        Teb = NtCurrentTeb();
        *SoftFpcrCopy = Teb->FpSoftwareStatusRegister;
        SoftwareFpcr = (PSW_FPCR)SoftFpcrCopy;
        DBGPRINT("KiFloatingException: SoftFpcr = %.8lx\n", *SoftFpcrCopy);

#if DBG
        //
        // If the floating emulation inhibit flag is set, then bypass all
        // software emulation by the kernel and return FALSE to raise the
        // original PALcode exception.
        //
        // N.B. This is for user-mode development and testing and is not
        //      part of the API.
        //

        if (SoftwareFpcr->NoSoftwareEmulation != 0) {
            DBGPRINT("KiFloatingException: NoSoftwareEmulation\n");
            return FALSE;
        }
#endif

        //
        // If the arithmetic exception is an imprecise trap, the address of
        // the trapping instruction is somewhere before the exception address.
        //
        // Otherwise the exception is a fault and the address of the faulting
        // instruction is the exception address.
        //

        if (ImpreciseTrap != FALSE) {

            //
            // If the arithmetic trap ignore mode is enabled, then do not
            // spend time to locate or to emulate the trapping instruction,
            // leave unpredictable results in the destination register, do
            // not set correct IEEE sticky bits in the software FPCR, leave
            // the hardware FPCR sticky status bits as they are, and return
            // TRUE to continue execution. It is assumed that user code will
            // check the hardware FPCR exception status bits to determine if
            // the instruction succeeded or not (Insignia SoftPc feature).
            //

            if (SoftwareFpcr->ArithmeticTrapIgnore != 0) {
                return TRUE;
            }

            //
            // Attempt to locate the trapping instruction. If the instruction
            // stream is such that this is not possible or was not intended,
            // then set an exception code that best reflects the exception
            // summary register bits and return FALSE to raise the exception.
            //
            // Otherwise emulate the trigger instruction in order to compute
            // the correct destination result value, the correct IEEE status
            // bits, and raise any enabled IEEE exceptions.
            //

            if (KiLocateTriggerPc(ExceptionRecord, TrapFrame) == FALSE) {
                KiSetFloatingStatus(ExceptionRecord);
                return FALSE;
            }
            Status = KiEmulateFloating(ExceptionRecord,
                                       ExceptionFrame,
                                       TrapFrame,
                                       SoftwareFpcr);

        } else {

            //
            // Attempt to emulate the faulting instruction in order to perform
            // floating operations not supported by EV4, to compute the correct
            // destination result value, the correct IEEE status bits, and
            // raise any enabled IEEE exceptions.
            //

            Status = KiEmulateFloating(ExceptionRecord,
                                       ExceptionFrame,
                                       TrapFrame,
                                       SoftwareFpcr);

            //
            // If the emulation resulted in a floating point exception and
            // the arithmetic trap ignore mode is enabled, then set the return
            // value to TRUE to suppress the exception and continue execution.
            //

            if ((Status == FALSE) &&
                (SoftwareFpcr->ArithmeticTrapIgnore != 0) &&
                (ExceptionRecord->ExceptionCode != STATUS_ILLEGAL_INSTRUCTION)) {
                Status = TRUE;
            }
        }

        //
        // Store the updated software FPCR longword in the TEB.
        //

        Teb->FpSoftwareStatusRegister = *SoftFpcrCopy;
        DBGPRINT("KiFloatingException: SoftFpcr = %.8lx\n", *SoftFpcrCopy);

    } except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception occurred accessing the TEB.
        //

        ExceptionRecord->ExceptionCode = GetExceptionCode();
        return FALSE;
    }

    return Status;
}

BOOLEAN
KiLocateTriggerPc (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to try to determine the precise location of the
    instruction that caused an arithmetic exception. The instruction that
    caused the trap to occur is known as the trigger instruction. On entry,
    the actual address of the trigger instruction is unknown and the exception
    address is the continuation address. The continuation address is the
    address of the instruction that would have executed had the trap not
    occurred. The instructions following the trigger instruction up to the
    continuation address are known as the trap shadow of the trigger
    instruction.

    Alpha AXP produces imprecise, asynchronous arithmetic exceptions. The
    exceptions are imprecise because the exception address when a trap is
    taken may be more than one instruction beyond the address of the
    instruction that actually caused the trap to occur.

    The arithmetic exceptions are traps (rather than faults) because the
    exception address is not the address of the trapping instruction
    itself, but the address of the next instruction to execute, which is
    always (at least) one instruction beyond the address of the trapping
    instruction.

    It is possible for multiple exceptions to occur and result in a single
    trap. This function only determines the address of the first trapping
    instruction.

    Unpredictable values may have been stored in the destination register
    of trapping instructions. Thus to insure that the trigger instruction
    can be located, and that the trigger instruction and any instructions
    in the trap shadow can be re-executed, certain restrictions are placed
    on the type of instructions or the mix of operands in the trap shadow.

    The code generation rules serve only to guarantee that the instruction
    backup algorithm and subsequent re-execution can always be successful.
    Hence the restrictions on such constructs as branches, jumps, and the
    re-use of source or destination operands within the trap shadow.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    If the trigger PC was precisely determined, the exception address in
    the exception record is set to the trigger PC, the continuation address
    in the trap frame is updated, and a value of TRUE is returned. Otherwise
    no values are stored and a value of FALSE is returned.

--*/

{

    PEXC_SUM ExceptionSummary;
    ULONG Fa;
    ULONG Fb;
    ULONG Fc;
    ULONG FloatRegisterTrashMask;
    ULONG FloatRegisterWriteMask;
    ALPHA_INSTRUCTION Instruction;
    ULONG IntegerRegisterWriteMask;
    ULONG Opcode;
    ULONG_PTR TrapShadowLowLimit;
    ULONG_PTR TriggerPc;
    KPROCESSOR_MODE PreviousMode;

    //
    // Obtain a copy of the float and integer register write mask registers
    // and the exception summary register from the exception record built by
    // PALcode.
    //

    FloatRegisterWriteMask = (ULONG)ExceptionRecord->ExceptionInformation[0];
    IntegerRegisterWriteMask = (ULONG)ExceptionRecord->ExceptionInformation[1];
    ExceptionSummary = (PEXC_SUM)&(ExceptionRecord->ExceptionInformation[2]);
    DBGPRINT("KiLocateTriggerPc: WriteMask %.8lx.%.8lx, ExceptionSummary %.8lx\n",
             FloatRegisterWriteMask, IntegerRegisterWriteMask,
             *(PULONG)ExceptionSummary);

    //
    // Capture previous mode from trap frame not current thread.
    //

    PreviousMode = (KPROCESSOR_MODE)(((PSR *)(&TrapFrame->Psr))->MODE);

    if (FloatRegisterWriteMask == 0) {

        //
        // It should not be possible to have a floating point exception without
        // at least one of the destination float register bits set. The trap
        // shadow is invalid.
        //

        DBGPRINT("KiLocateTriggerPc: FloatRegisterWriteMask clear\n");
        NON_IEEE(ExceptionRecord, TRIGGER_FLOATING_REGISTER_MASK_CLEAR);
        return FALSE;
    }
    if (IntegerRegisterWriteMask != 0) {

        //
        // It is not possible to precisely locate the trigger instruction
        // when the integer overflow bit is set. The trap shadow is invalid.
        //

        DBGPRINT("KiLocateTriggerPc: IntegerRegisterMask set.\n");
        NON_IEEE(ExceptionRecord, TRIGGER_INTEGER_REGISTER_MASK_SET);
        return FALSE;
    }
    if (ExceptionSummary->SoftwareCompletion == 0) {

        //
        // The exception summary software completion bit is the AND of the
        // /S bits of all trapping instructions in the trap shadow. Since
        // the software completion bit is not set, it can be assumed the
        // code that was executing does not want precise exceptions, or if
        // it does, the code does not comply with the Alpha AXP guidelines
        // for locating the trigger PC. The trap shadow is invalid.
        //

        DBGPRINT("KiLocateTriggerPc: SoftwareCompletion clear\n");
        NON_IEEE(ExceptionRecord, TRIGGER_NO_SOFTWARE_COMPLETION);
        return FALSE;
    }

    //
    // Search for the trigger instruction starting with the instruction before
    // the continuation PC (the instruction pointed to by Fir either did not
    // complete or did not even start). Limit the search to the arbitrary
    // limit of N instructions back from the current PC to prevent unbounded
    // searches. The search is complete when all trapping destination register
    // bits in the float write mask register have been accounted for.
    //

    FloatRegisterTrashMask = 0;
    TriggerPc = (ULONG_PTR)TrapFrame->Fir;
    TrapShadowLowLimit = TriggerPc - (500 * sizeof(ULONG));

    try {
        do {
            TriggerPc -= 4;
            if (TriggerPc < TrapShadowLowLimit) {

                //
                // The trigger PC is too far away from the exception PC to
                // be reasonable. The trap shadow is invalid.
                //

                DBGPRINT("KiLocateTriggerPc: Trap shadow too long\n");
                NON_IEEE(ExceptionRecord, TRIGGER_INSTRUCTION_NOT_FOUND);
                return FALSE;
            }

            if (PreviousMode != KernelMode) {
                Instruction.Long = ProbeAndReadUlong((PULONG)TriggerPc);
            } else {
                Instruction.Long = *((PULONG)TriggerPc);
            }

            //
            // Examine the opcode of this instruction to determine if the
            // trap shadow is invalid.
            //

            Opcode = Instruction.Memory.Opcode;
            if (Opcode == JMP_OP) {

                //
                // This is one of the jump instructions: jump, return, or
                // either form of jsr. The trap shadow is invalid.
                //

                DBGPRINT("KiLocateTriggerPc: Jump within Trap Shadow\n");
                NON_IEEE(ExceptionRecord, TRIGGER_INVALID_INSTRUCTION_FOUND);
                return FALSE;

            } else if ((Opcode >= BR_OP) && (Opcode <= BGT_OP)) {

                //
                // The instruction is one of 16 branch opcodes that consists
                // of BR, the 6 floating point branch, BSR, and the 8 integer
                // branch instructions. The trap shadow is invalid.
                //

                DBGPRINT("KiLocateTriggerPc: Branch within Trap Shadow\n");
                NON_IEEE(ExceptionRecord, TRIGGER_INVALID_INSTRUCTION_FOUND);
                return FALSE;

            } else if ((Instruction.Memory.Opcode == MEMSPC_OP) &&
                ((Instruction.Memory.MemDisp == TRAPB_FUNC) ||
                 (Instruction.Memory.MemDisp == EXCB_FUNC))) {

                //
                // The instruction is a type of TRAPB instruction. The trap
                // shadow is invalid.
                //

                DBGPRINT("KiLocateTriggerPc: Trapb within Trap Shadow\n");
                NON_IEEE(ExceptionRecord, TRIGGER_INVALID_INSTRUCTION_FOUND);
                return FALSE;

            } else if (Opcode == CALLPAL_OP) {

                //
                // The instruction is a Call PAL. The trap shadow is invalid.
                //

                DBGPRINT("KiLocateTriggerPc: Call PAL within Trap Shadow\n");
                NON_IEEE(ExceptionRecord, TRIGGER_INVALID_INSTRUCTION_FOUND);
                return FALSE;

            } else if ((Opcode == IEEEFP_OP) || (Opcode == FPOP_OP)) {

                //
                // The instruction is an IEEE floating point instruction.
                // Decode the destination register of the floating point
                // instruction in order to check against the register mask.
                //

                Fc = Instruction.FpOp.Fc;
                if (Fc != FZERO_REG) {
                    FloatRegisterTrashMask |= (1 << Fc);
                }
                FloatRegisterWriteMask &= ~(1 << Fc);
            }

        } while (FloatRegisterWriteMask != 0);

        //
        // If the instruction thought to be the trigger instruction does not
        // have the /S bit set, then the trap shadow is invalid (some other
        // instruction must have caused software completion bit to be set).
        //

        if ((Instruction.FpOp.Function & FP_TRAP_ENABLE_S) == 0) {
            DBGPRINT("KiLocateTriggerPc: Trigger instruction missing /S\n");
            NON_IEEE(ExceptionRecord, TRIGGER_WRONG_INSTRUCTION);
            return FALSE;
        }

        //
        // If either of the operand registers of the trigger instruction is
        // also the destination register of the trigger instruction or any
        // instruction in the trap shadow, then the trap shadow in invalid.
        // This is because the original value of the operand register(s) may
        // have been destroyed making it impossible to re-execute the trigger
        // instruction.
        //

        Fa = Instruction.FpOp.Fa;
        Fb = Instruction.FpOp.Fb;
        if ((FloatRegisterTrashMask & ((1 << Fa) | (1 << Fb))) != 0) {
            DBGPRINT("KiLocateTriggerPc: Source is destination\n");
            NON_IEEE(ExceptionRecord, TRIGGER_SOURCE_IS_DESTINATION);
            return FALSE;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception occurred while fetching the value of the
        // next previous instruction. The trap shadow is invalid.
        //

        DBGPRINT("KiLocateTriggerPc: Instruction fetch error\n");
        NON_IEEE(ExceptionRecord, TRIGGER_INSTRUCTION_FETCH_ERROR);
        return FALSE;
    }

    //
    // The trigger instruction was successfully located. Set the precise
    // exception address in the exception record, set the new continuation
    // address in the trap frame, and return a value of TRUE.
    //

    DBGPRINT("KiLocateTriggerPc: Exception PC = %p, Trigger PC = %p\n",
             ExceptionRecord->ExceptionAddress, TriggerPc);
    ExceptionRecord->ExceptionAddress = (PVOID)TriggerPc;
    TrapFrame->Fir = (ULONGLONG)(LONG_PTR)(TriggerPc + 4);
    return TRUE;
}

VOID
KiSetFloatingStatus (
    IN OUT PEXCEPTION_RECORD ExceptionRecord
    )

/*++

Routine Description:

    This function is called to convert the exception summary register bits
    into a status code value.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

Return Value:

    None.

--*/

{

    PEXC_SUM ExceptionSummary;

    //
    // Perform the following triage on the exception summary register to
    // report the type of exception, even if though the PC reported is
    // imprecise.
    //

    DBGPRINT("KiSetFloatingStatus: ExceptionSummary = %.8lx\n",
             ExceptionRecord->ExceptionInformation[2]);

    ExceptionSummary = (PEXC_SUM)(&ExceptionRecord->ExceptionInformation[2]);
    if (ExceptionSummary->InvalidOperation != 0) {
        ExceptionRecord->ExceptionCode = STATUS_FLOAT_INVALID_OPERATION;

    } else if (ExceptionSummary->DivisionByZero != 0) {
        ExceptionRecord->ExceptionCode = STATUS_FLOAT_DIVIDE_BY_ZERO;

    } else if (ExceptionSummary->Overflow != 0) {
        ExceptionRecord->ExceptionCode = STATUS_FLOAT_OVERFLOW;

    } else if (ExceptionSummary->Underflow != 0) {
        ExceptionRecord->ExceptionCode = STATUS_FLOAT_UNDERFLOW;

    } else if (ExceptionSummary->InexactResult != 0) {
        ExceptionRecord->ExceptionCode = STATUS_FLOAT_INEXACT_RESULT;

    } else if (ExceptionSummary->IntegerOverflow != 0) {
        ExceptionRecord->ExceptionCode = STATUS_INTEGER_OVERFLOW;

    } else {
        ExceptionRecord->ExceptionCode = STATUS_FLOAT_STACK_CHECK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\apcuser.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    apcuser.c

Abstract:

    This module implements the machine dependent code necessary to initialize
    a user mode APC.

Author:

    David N. Cutler (davec) 5-May-2000

Environment:

    Kernel mode only, IRQL APC_LEVEL.

Revision History:

--*/

#include "ki.h"

VOID
KiInitializeUserApc (
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN PKNORMAL_ROUTINE NormalRoutine,
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called to initialize the context for a user mode APC.

Arguments:

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    NormalRoutine - Supplies a pointer to the user mode APC routine.

    NormalContext - Supplies a pointer to the user context for the APC
        routine.

    SystemArgument1 - Supplies the first system supplied value.

    SystemArgument2 - Supplies the second system supplied value.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord;
    EXCEPTION_RECORD ExceptionRecord;
    PMACHINE_FRAME MachineFrame;
    ULONG64 UserStack;

    //
    // Move machine state from trap and exception frames to the context frame.
    //

    ContextRecord.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
    KeContextFromKframes(TrapFrame, ExceptionFrame, &ContextRecord);

    //
    // Transfer the context information to the user stack, initialize the
    // APC routine parameters, and modify the trap frame so execution will
    // continue in user mode at the user mode APC dispatch routine.
    //

    try {

        //
        // Compute address of aligned machine frame, compute address of
        // context record, and probe user stack for writeability.
        //

        MachineFrame =
            (PMACHINE_FRAME)((ContextRecord.Rsp - sizeof(MACHINE_FRAME)) & ~STACK_ROUND);

        UserStack = (ULONG64)MachineFrame - CONTEXT_LENGTH;
        ProbeForWriteSmallStructure((PVOID)UserStack,
                                     sizeof(MACHINE_FRAME) + CONTEXT_LENGTH,
                                     STACK_ALIGN);

        //
        // Fill in machine frame information.
        //

        MachineFrame->Rsp = ContextRecord.Rsp;
        MachineFrame->Rip = ContextRecord.Rip;

        //
        // Initialize the user APC parameters.
        //

        ContextRecord.P1Home = (ULONG64)NormalContext;
        ContextRecord.P2Home = (ULONG64)SystemArgument1;
        ContextRecord.P3Home = (ULONG64)SystemArgument2;
        ContextRecord.P4Home = (ULONG64)NormalRoutine;

        //
        // Copy context record to the user stack.
        //

        RtlCopyMemory((PVOID)UserStack, &ContextRecord, sizeof(CONTEXT));

        //
        // Set the address new stack pointer in the current trap frame and
        // the continuation address so control will be transfered to the user
        // APC dispatcher.
        //

        TrapFrame->Rsp = UserStack;
        TrapFrame->Rip = (ULONG64)KeUserApcDispatcher;

    } except (DbgBreakPoint(), KiCopyInformation(&ExceptionRecord,
                                (GetExceptionInformation())->ExceptionRecord)) {

        //
        // Set the address of the exception to the current program address
        // and raise the exception by calling the exception dispatcher.
        //

        ExceptionRecord.ExceptionAddress = (PVOID)(TrapFrame->Rip);
        KiDispatchException(&ExceptionRecord,
                            ExceptionFrame,
                            TrapFrame,
                            UserMode,
                            TRUE);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\alignem.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    alignem.c

Abstract:

    This module contains the code that is executed when a misaligned
    data reference must be "emulated".

Author:

    Forrest C. Foltz (forrestf) 05-Feb-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Flags used in KTHREAD.AlignmentEmulationFlags
//

#define AFE_EMULATING_ALIGNMENT_FAULT   0x01
#define AFE_TF_FLAG_WAS_SET             0x02


BOOLEAN
KiEmulateReference (
    IN OUT PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN OUT PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This function is called to emulate an unaligned data reference to an
    address in the user part of the address space.

    On AMD64, this function doesn't actually perform an emulation.  Instead,
    it:

        - Turns off the alignment check (AC) bit in EFLAGS
        - Turns on the single step (TF) bit in EFLAGS

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    A value of TRUE is returned if the data reference is successfully
    emulated. Otherwise, a value of FALSE is returned.

--*/

{
    PKTHREAD thread;

    //
    // Indicate that we are in the middle of alignment fault emulation.
    //
    // After the instruction is executed and the trap 1 handler is invoked,
    // KiEmulateReferenceComplete() (following) will restore the normal
    // state.
    //

    thread = KeGetCurrentThread();
    ASSERT(thread->AlignmentEmulationFlags == 0);
    thread->AlignmentEmulationFlags = AFE_EMULATING_ALIGNMENT_FAULT;

    //
    // Record whether the single-step flag was set when we took
    // the fault.
    //

    if ((TrapFrame->EFlags & EFLAGS_TF_MASK) != 0) {
        thread->AlignmentEmulationFlags |= AFE_TF_FLAG_WAS_SET;
    }

    //
    // Turn off the AC flag and turn on the TF flag
    //

    TrapFrame->EFlags =
        (TrapFrame->EFlags & ~EFLAGS_AC_MASK) | EFLAGS_TF_MASK;

    return TRUE;
}



BOOLEAN
KiEmulateReferenceComplete (
    IN OUT PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine is called from the single-step (trap01) handler.  It's
    purpose is to determine whether an alignment fault emulation has just
    completed and if so, restore the cpu state to the non-emulating state.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

Return Value:

    A value of TRUE is returned when the trap should be forwarded to the
    exception dispatcher.  FALSE indicates that execution may be resumed
    immediately upon returning from this routine.
                
--*/

{
    PKTHREAD thread;
    UCHAR emulationFlags;

    thread = KeGetCurrentThread();

    //
    // Check if we are currently emulating an alignment fault at this address.
    //

    emulationFlags = thread->AlignmentEmulationFlags;
    if ((emulationFlags & AFE_EMULATING_ALIGNMENT_FAULT) == 0) {

        //
        // This single-step wasn't the result of any alignment emulation that
        // we're doing, so indicate that the debug exception dispatcher
        // should be called.
        //

        return TRUE;
    }

    //
    // Clear the emulation flags in the thread, we've got a local copy.
    // 

    thread->AlignmentEmulationFlags = 0;

    //
    // This single-step is the indication that an alignment emulation has
    // just completed.  Restore the AC and TF flags.
    //

    if ((emulationFlags & AFE_TF_FLAG_WAS_SET) == 0) {

        //
        // The TF flag was not set when the alignment fault was first
        // encountered, so clear it now.  Also set the AC flag.  Indicate
        // that this trap 01 need not be forwarded any further.
        //

        TrapFrame->EFlags =
            (TrapFrame->EFlags | EFLAGS_AC_MASK) & ~EFLAGS_TF_MASK;

        return FALSE;

    } else {

        //
        // The TF flag was set when the alignment fault was first
        // encountered.  Leave it set, restore the AC flag, and indicate
        // that this trap 01 should be forwarded to the exception dispatcher.
        // 

        TrapFrame->EFlags |= EFLAGS_AC_MASK;
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\callback.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    callback.c

Abstract:

    This module implements user mode call back services.

Author:

    David N. Cutler (davec) 5-Jul-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#pragma alloc_text(PAGE, KeUserModeCallback)

NTSTATUS
KeUserModeCallback (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    IN PULONG OutputLength
    )

/*++

Routine Description:

    This function call out from kernel mode to a user mode function.

Arguments:

    ApiNumber - Supplies the API number.

    InputBuffer - Supplies a pointer to a structure that is copied
        to the user stack.

    InputLength - Supplies the length of the input structure.

    Outputbuffer - Supplies a pointer to a variable that receives
        the address of the output buffer.

    Outputlength - Supplies a pointer to a variable that receives
        the length of the output buffer.

Return Value:

    If the callout cannot be executed, then an error status is returned.
    Otherwise, the status returned by the callback function is returned.

--*/

{

    PUCALLOUT_FRAME CalloutFrame;
    ULONG Length;
    ULONG64 OldStack;
    NTSTATUS Status;
    PKTRAP_FRAME TrapFrame;
    PVOID ValueBuffer;
    ULONG ValueLength;

    ASSERT(KeGetPreviousMode() == UserMode);

    //
    // Get the user mode stack pointer and attempt to copy input buffer
    // to the user stack.
    //

    TrapFrame = KeGetCurrentThread()->TrapFrame;
    OldStack = TrapFrame->Rsp;
    try {

        //
        // Compute new user mode stack address, probe for writability, and
        // copy the input buffer to the user stack.
        //

        Length = ((InputLength + STACK_ROUND) & ~STACK_ROUND) + UCALLOUT_FRAME_LENGTH;
        CalloutFrame = (PUCALLOUT_FRAME)((OldStack - Length) & ~STACK_ROUND);
        ProbeForWrite(CalloutFrame, Length, STACK_ALIGN);
        RtlCopyMemory(CalloutFrame + 1, InputBuffer, InputLength);

        //
        // Fill in callout arguments.
        //

        CalloutFrame->Buffer = (PVOID)(CalloutFrame + 1);
        CalloutFrame->Length = InputLength;
        CalloutFrame->ApiNumber = ApiNumber;
        CalloutFrame->MachineFrame.Rsp = OldStack;
        CalloutFrame->MachineFrame.Rip = TrapFrame->Rip;

    //
    // If an exception occurs during the probe of the user stack, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // Call user mode.
    //

    TrapFrame->Rsp = (ULONG64)CalloutFrame;
    Status = KiCallUserMode(OutputBuffer, OutputLength);

    //
    // When returning from user mode, any drawing done to the GDI TEB
    // batch must be flushed.
    //

    if (((PTEB)KeGetCurrentThread()->Teb)->GdiBatchCount > 0) {
        TrapFrame->Rsp -= 256;
        KeGdiFlushUserBatch();
    }

    TrapFrame->Rsp = OldStack;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\allproc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    allproc.c

Abstract:

    This module allocates and initializes kernel resources required to
    start a new processor, and passes a complete process state structure
    to the hal to obtain a new processor.

Author:

    David N. Cutler (davec) 5-May-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Define local macros.
//

#define ROUNDUP16(x) (((x) + 15) & ~15)

//
// Define prototypes for forward referenced functions.
//

VOID
KiCopyDescriptorMemory (
   IN PKDESCRIPTOR Source,
   IN PKDESCRIPTOR Destination,
   IN PVOID Base
   );

VOID
KiSetDescriptorBase (
   IN USHORT Selector,
   IN PKGDTENTRY64 GdtBase,
   IN PVOID Base
   );

#if defined(KE_MULTINODE)

NTSTATUS
KiNotNumaQueryProcessorNode (
    IN ULONG ProcessorNumber,
    OUT PUSHORT Identifier,
    OUT PUCHAR Node
    );

#pragma alloc_text(INIT, KiNotNumaQueryProcessorNode)

#endif

#pragma alloc_text(INIT, KeStartAllProcessors)
#pragma alloc_text(INIT, KiCopyDescriptorMemory)
#pragma alloc_text(INIT, KiSetDescriptorBase)
#pragma alloc_text(INIT, KiAllProcessorsStarted)

ULONG KiBarrierWait = 0;

//
// Statically allocate enough KNODE structures to allow memory management
// to allocate pages by node during system initialization. As processors
// are brought online, real KNODE structures are allocated in the correct
// memory for the node.
//

#if defined(KE_MULTINODE)

PHALNUMAQUERYPROCESSORNODE KiQueryProcessorNode = KiNotNumaQueryProcessorNode;

#pragma data_seg("INITDATA")

KNODE KiNodeInit[MAXIMUM_CCNUMA_NODES];

#endif

VOID
KeStartAllProcessors (
    VOID
    )

/*++

Routine Description:

    This function is called during phase 1 initialization on the master boot
    processor to start all of the other registered processors.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    KAFFINITY Affinity;
    ULONG AllocationSize;
    PUCHAR Base;
    PKPCR CurrentPcr = KeGetPcr();
    PVOID DataBlock;
    PKTSS64 DfTssBase;
    PVOID DpcStack;
    PKGDTENTRY64 GdtBase;
    ULONG GdtOffset;
    ULONG IdtOffset;
    PVOID KernelStack;
    PKTSS64 NmiTssBase;
    PKNODE Node;
    UCHAR NodeNumber;
    UCHAR Number;
    PKPCR PcrBase;
    USHORT ProcessorId;
    KPROCESSOR_STATE ProcessorState;
    NTSTATUS Status;
    PKTSS64 SysTssBase;
    PETHREAD Thread;

    //
    // If processor zero is not on node zero, then move it to the appropriate
    // node.
    //

#if defined(KE_MULTINODE)

    if (KeNumberNodes > 1) {
        Status = KiQueryProcessorNode(0, &ProcessorId, &NodeNumber);
        if (NT_SUCCESS(Status)) {
            if (NodeNumber != 0) {
                KeNodeBlock[0]->ProcessorMask &= ~1;
                KeNodeBlock[NodeNumber]->ProcessorMask |= 1;
                KeGetCurrentPrcb()->ParentNode = KeNodeBlock[NodeNumber];
            }
        }
    }

#else

    NodeNumber = 0;

#endif

    //
    // Calculate the size of the per processor data structures.
    //
    // This includes:
    //
    //   PCR (including the PRCB)
    //   System TSS
    //   Idle Thread Object
    //   Double Fault/NMI Panic Stack
    //   Machine Check Stack
    //   GDT
    //   IDT
    //
    // If this is a multinode system, the KNODE structure is also allocated.
    //
    // A DPC and Idle stack are also allocated, but they are done separately.
    //

    AllocationSize = ROUNDUP16(sizeof(KPCR)) +
                     ROUNDUP16(sizeof(KTSS64)) +
                     ROUNDUP16(sizeof(ETHREAD)) +
                     ROUNDUP16(DOUBLE_FAULT_STACK_SIZE) +
                     ROUNDUP16(KERNEL_MCA_EXCEPTION_STACK_SIZE);

#if defined(KE_MULTINODE)

    AllocationSize += ROUNDUP16(sizeof(KNODE));

#endif

    //
    // Save the offset of the GDT in the allocation structure and add in
    // the size of the GDT.
    //

    GdtOffset = AllocationSize;
    AllocationSize +=
            CurrentPcr->Prcb.ProcessorState.SpecialRegisters.Gdtr.Limit + 1;

    //
    // Save the offset of the IDT in the allocation structure and add in
    // the size of the IDT.
    //

    IdtOffset = AllocationSize;
    AllocationSize +=
            CurrentPcr->Prcb.ProcessorState.SpecialRegisters.Idtr.Limit + 1;

    //
    // If the registered number of processors is greater than the maximum
    // number of processors supported, then only allow the maximum number
    // of supported processors.
    //

    if (KeRegisteredProcessors > MAXIMUM_PROCESSORS) {
        KeRegisteredProcessors = MAXIMUM_PROCESSORS;
    }

    //
    // Set barrier that will prevent any other processor from entering the
    // idle loop until all processors have been started.
    //

    KiBarrierWait = 1;

    //
    // Initialize the fixed part of the processor state that will be used to
    // start processors. Each processor starts in the system initialization
    // code with address of the loader parameter block as an argument.
    //

    RtlZeroMemory(&ProcessorState, sizeof(KPROCESSOR_STATE));
    ProcessorState.ContextFrame.Rcx = (ULONG64)KeLoaderBlock;
    ProcessorState.ContextFrame.Rip = (ULONG64)KiSystemStartup;
    ProcessorState.ContextFrame.SegCs = KGDT64_R0_CODE;
    ProcessorState.ContextFrame.SegDs = KGDT64_R3_DATA | RPL_MASK;
    ProcessorState.ContextFrame.SegEs = KGDT64_R3_DATA | RPL_MASK;
    ProcessorState.ContextFrame.SegFs = KGDT64_R3_CMTEB | RPL_MASK;
    ProcessorState.ContextFrame.SegGs = KGDT64_R3_DATA | RPL_MASK;
    ProcessorState.ContextFrame.SegSs = KGDT64_R3_DATA | RPL_MASK;

    //
    // Loop trying to start a new processors until a new processor can't be
    // started or an allocation failure occurs.
    //

    Number = 0;
    while ((ULONG)KeNumberProcessors < KeRegisteredProcessors) {
        Number++;

#if defined(KE_MULTINODE)

        Status = KiQueryProcessorNode(Number, &ProcessorId, &NodeNumber);
        if (!NT_SUCCESS(Status)) {

            //
            // No such processor, advance to next.
            //

            continue;
        }

        Node = KeNodeBlock[NodeNumber];

#endif

        //
        // Allocate memory for the new processor specific data. If the
        // allocation fails, then stop starting processors.
        //

        DataBlock = MmAllocateIndependentPages(AllocationSize, NodeNumber);
        if (DataBlock == NULL) {
            break;
        }

        //
        // Zero the allocated memory.
        //

        Base = (PUCHAR)DataBlock;
        RtlZeroMemory(DataBlock, AllocationSize);

        //
        // Copy and initialize the GDT for the next processor.
        //

        KiCopyDescriptorMemory(&CurrentPcr->Prcb.ProcessorState.SpecialRegisters.Gdtr,
                               &ProcessorState.SpecialRegisters.Gdtr,
                               Base + GdtOffset);

        GdtBase = (PKGDTENTRY64)ProcessorState.SpecialRegisters.Gdtr.Base;

        //
        // Copy and initialize the IDT for the next processor.
        //

        KiCopyDescriptorMemory(&CurrentPcr->Prcb.ProcessorState.SpecialRegisters.Gdtr,
                               &ProcessorState.SpecialRegisters.Idtr,
                               Base + IdtOffset);

        //
        // Set the PCR base address for the next processor and set the
        // processor number.
        //
        // N.B. The PCR address is passed to the next processor by computing
        //      the containing address with respect to the PRCB.
        //

        PcrBase = (PKPCR)Base;
        PcrBase->Number = Number;
        Base += ROUNDUP16(sizeof(KPCR));

        //
        // Set the system TSS descriptor base for the next processor.
        //

        SysTssBase = (PKTSS64)Base;
        KiSetDescriptorBase(KGDT64_SYS_TSS / 16, GdtBase, SysTssBase);
        Base += ROUNDUP16(sizeof(KTSS64));

        //
        // Initialize the panic stack address for double fault and NMI.
        //

        Base += DOUBLE_FAULT_STACK_SIZE;
        SysTssBase->Ist[TSS_IST_PANIC] = (ULONG64)Base;

        //
        // Initialize the machine check stack address.
        //

        Base += KERNEL_MCA_EXCEPTION_STACK_SIZE;
        SysTssBase->Ist[TSS_IST_MCA] = (ULONG64)Base;

        //
        // Idle Thread thread object.
        //

        Thread = (PETHREAD)Base;
        Base += ROUNDUP16(sizeof(ETHREAD));

        //
        // Set other special registers in the processor state.
        //

        ProcessorState.SpecialRegisters.Cr0 = ReadCR0();
        ProcessorState.SpecialRegisters.Cr3 = ReadCR3();
        ProcessorState.ContextFrame.EFlags = 0; // ******fixfix what should this be??
        ProcessorState.SpecialRegisters.Tr  = KGDT64_SYS_TSS;
        GdtBase[KGDT64_SYS_TSS / 16].Bytes.Flags1 = 0x89;
        ProcessorState.SpecialRegisters.Cr4 = CR4_PAE;

        //
        // Allocate a kernel stack and a DPC stack for the next processor.
        //

        KernelStack = MmCreateKernelStack(FALSE, NodeNumber);
        DpcStack = MmCreateKernelStack(FALSE, NodeNumber);
        if ((DpcStack == NULL) || (KernelStack == NULL)) {
            MmFreeIndependentPages(DataBlock, AllocationSize);
            break;
        }

        //
        // Initialize the kernel stack for the system TSS.
        //

        SysTssBase->Rsp0 = (ULONG64)KernelStack;
        ProcessorState.ContextFrame.Rsp = (ULONG64)KernelStack;

        //
        // If this is the first processor on this node, then use the space
        // allocated for KNODE as the KNODE.
        //

#if defined(KE_MULTINODE)

        if (KeNodeBlock[NodeNumber] == &KiNodeInit[NodeNumber]) {
            Node = (PKNODE)Base;
            *Node = KiNodeInit[NodeNumber];
            KeNodeBlock[NodeNumber] = Node;
        }

        Base += ROUNDUP16(sizeof(KNODE));
        PcrBase->Prcb.ParentNode = Node;

#else

        PcrBase->Prcb.ParentNode = KeNodeBlock[0];

#endif

        //
        // Adjust the loader block so it has the next processor state.
        //

        KeLoaderBlock->KernelStack = (ULONG64)DpcStack;
        KeLoaderBlock->Thread = (ULONG64)Thread;
        KeLoaderBlock->Prcb = (ULONG64)(&PcrBase->Prcb);

        //
        // Attempt to start the next processor. If a processor cannot be
        // started, then deallocate memory and stop starting processors.
        //

        if (HalStartNextProcessor(KeLoaderBlock, &ProcessorState) == 0) {
            MmFreeIndependentPages(DataBlock, AllocationSize);
            MmDeleteKernelStack(KernelStack, FALSE);
            MmDeleteKernelStack(DpcStack, FALSE);
            break;
        }

#if defined(KE_MULTINODE)

        Node->ProcessorMask |= AFFINITY_MASK(Number);

#endif

        //
        // Wait for processor to initialize.
        //

        while (*((volatile ULONG64 *)&KeLoaderBlock->Prcb) != 0) {
            KeYieldProcessor();
        }

        Number += 1;
    }

    //
    // All processors have been stated.
    //

    KiAllProcessorsStarted();

    //
    // Reset and synchronize the performance counters of all processors, by
    // applying a null adjustment to the interrupt time
    //

    KiAdjustInterruptTime(0);

    //
    // Allow all processors that were started to enter the idle loop and
    // begin execution.
    //

    KiBarrierWait = 0;

#endif // !defined(NT_UP)

    return;
}

VOID
KiSetDescriptorBase (
   IN USHORT Selector,
   IN PKGDTENTRY64 GdtBase,
   IN PVOID Base
   )

/*++

Routine Description:

    This function sets the base address of a descriptor to the specified
    base address.

Arguments:

    Selector - Supplies the selector for the descriptor.

    GdtBase - Supplies a pointer to the GDT.

    Base - Supplies a pointer to the base address.

Return Value:

    None.

--*/

{

    GdtBase = &GdtBase[Selector];
    GdtBase->BaseLow = (USHORT)((ULONG64)Base);
    GdtBase->Bytes.BaseMiddle = (UCHAR)((ULONG64)Base >> 16);
    GdtBase->Bytes.BaseHigh = (UCHAR)((ULONG64)Base >> 24);
    GdtBase->BaseUpper = (ULONG)((ULONG64)Base >> 32);
    return;
}

VOID
KiCopyDescriptorMemory (
   IN PKDESCRIPTOR Source,
   IN PKDESCRIPTOR Destination,
   IN PVOID Base
   )

/*++

Routine Description:

    This function copies the specified descriptor memory to the new memory
    and initializes a descriptor for the new memory.

Arguments:

    Source - Supplies a pointer to the source descriptor that describes
        the memory to copy.

    Destination - Supplies a pointer to the destination descriptor to be
        initialized.

    Base - Supplies a pointer to the new memory.

Return Value:

    None.

--*/

{

    Destination->Limit = Source->Limit;
    Destination->Base = Base;
    RtlCopyMemory(Base, Source->Base, Source->Limit + 1);
    return;
}

VOID
KiAllProcessorsStarted(
    VOID
    )

/*++

Routine Description:

    This routine is called once all processors in the system have been started.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG i;

    //
    // Make sure there are no references to the temporary nodes used during
    // initialization.
    //

#if defined(KE_MULTINODE)

    for (i = 0; i < KeNumberNodes; i += 1) {
        if (KeNodeBlock[i] == &KiNodeInit[i]) {

            //
            // No processor started on this node so no new node structure has
            // been allocated. This is possible if the node contains memory
            // only or IO busses. At this time we need to allocate a permanent
            // node structure for the node.
            //

            KeNodeBlock[i] = ExAllocatePoolWithTag(NonPagedPool,
                                                   sizeof(KNODE),
                                                   '  eK');

            if (KeNodeBlock[i]) {
                *KeNodeBlock[i] = KiNodeInit[i];
            }
        }
    }

    for (i = KeNumberNodes; i < MAXIMUM_CCNUMA_NODES; i += 1) {
        KeNodeBlock[i] = NULL;
    }

#endif

    if (KeNumberNodes == 1) {

        //
        // For Non NUMA machines, Node 0 gets all processors.
        //

        KeNodeBlock[0]->ProcessorMask = KeActiveProcessors;
    }

    return;
}

NTSTATUS
KiNotNumaQueryProcessorNode(
    IN ULONG ProcessorNumber,
    OUT PUSHORT Identifier,
    OUT PUCHAR Node
    )

/*++

Routine Description:

    This routine is a stub used on non NUMA systems to provide a
    consistent method of determining the NUMA configuration rather
    than checking for the presense of multiple nodes inline.

Arguments:

    ProcessorNumber supplies the system logical processor number.
    Identifier      supplies the address of a variable to receive
                    the unique identifier for this processor.
    NodeNumber      supplies the address of a variable to receive
                    the number of the node this processor resides on.

Return Value:

    Returns success.

--*/

{
    *Identifier = (USHORT)ProcessorNumber;
    *Node = 0;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\apcint.asm ===
title  "Asynchronous Procedure Call Interrupt"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   apcint.asm
;
; Abstract:
;
;   This module implements the code necessary to process the  Asynchronous
;   Procedure Call interrupt request.
;
; Author:
;
;   David N. Cutler (davec) 10-Nov-2000
;
; Environment:
;
;    Kernel mode only.
;
;--

        extern  KiDeliverApc:proc
        extern  __imp_HalEndSystemInterrupt:qword

include ksamd64.inc

        subttl  "Asynchronous Procedure Call Interrupt"
;++
;
; VOID
; KiApcInterrupt (
;     VOID
;     )
;
; Routine Description:
;
;   This routine is entered as the result of a software interrupt generated
;   at APC_LEVEL. Its function is to save the machine state and call the APC
;   delivery routine.
;
;   N.B. This is a directly connected interrupt that does not use an interrupt
;        object.
;
;   N.B. APC interrupts are never requested for user mode APCs.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiApcInterrupt, _TEXT$00

        .pushframe                      ; mark machine frame

        push_reg rbp                    ; push dummy vector
        push_reg rbp                    ; save nonvolatile register

        GENERATE_INTERRUPT_FRAME        ; generate interrupt frame

        mov     ecx, APC_LEVEL          ; set new IRQL level

	ENTER_INTERRUPT			; raise IRQL, do EOI, enable interrupts

        mov     cl, KernelMode          ; set APC processor mode
        xor     edx, edx                ; set exception frame address
        lea     r8, (-128)[rbp]         ; set trap frame address
        call    KiDeliverApc            ; initiate APC execution

        EXIT_INTERRUPT <NoEOI>          ; lower IRQL and restore state

        NESTED_END KiApcInterrupt, _TEXT$00

        subttl  "Initiate User APC Execution"
;++
;
; Routine Description:
;
;   This routine generates an exception frame and attempts to deliver a user
;   APC.
;
; Arguments:
;
;   rbp - Supplies the address of the trap frame.
;
;   rsp - Supplies the address of the trap frame.
;
; Return value:
;
;   None.
;
;--

        NESTED_ENTRY KiInitiateUserApc, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        lea     rbx, (KTRAP_FRAME_LENGTH - 128)[rbp] ; get save area address
        fnsaved [rbx]                   ; save legacy floating state
        mov     cl, UserMode            ; set APC processor mode
        mov     rdx, rsp                ; set exception frame address
        lea     r8, (-128)[rbp]         ; set trap frame address
        call    KiDeliverApc            ; deliver APC
        mov     ax, LfControlWord[rbx]  ; save current control word
        mov     word ptr LfControlWord[rbx], 03fh ; set to mask all exceptions
        frstord [rbx]                   ; restore legacy floating state
        mov     LfControlWord[rbx], ax  ; restore control word
        fldcw   word ptr LfControlWord[rbx] ; load legacy control word

        RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        NESTED_END KiInitiateUserApc, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\callout.asm ===
title  "Call Out to User Mode"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   callout.asm
;
; Abstract:
;
;   This module implements the code necessary to call out from kernel
;   mode to user mode.
;
; Author:
;
;   David N. Cutler (davec) 30-Aug-2000
;
; Environment:
;
;    Kernel mode only.
;
;--

include ksamd64.inc

        extern  KeUserCallbackDispatcher:qword
        extern  KiSystemServiceExit:proc
        extern  MmGrowKernelStack:proc
        extern  PsConvertToGuiThread:proc

        subttl  "Call User Mode Function"
;++
;
; NTSTATUS
; KiCallUserMode (
;     IN PVOID *Outputbuffer,
;     IN PULONG OutputLength
;     )
;
; Routine Description:
;
;   This function calls a user mode function from kernel mode.
;
;   N.B. This function calls out to user mode and the NtCallbackReturn
;        function returns back to the caller of this function. Therefore,
;        the stack layout must be consistent between the two routines.
;
; Arguments:
;
;   OutputBuffer (rcx) - Supplies a pointer to the variable that receivies
;       the address of the output buffer.
;
;   OutputLength (rdx) - Supplies a pointer to a variable that receives
;       the length of the output buffer.
;
; Return Value:
;
;   The final status of the call out function is returned as the status
;   of the function.
;
;   N.B. This function does not return to its caller. A return to the
;        caller is executed when a NtCallbackReturn system service is
;        executed.
;
;   N.B. This function does return to its caller if a kernel stack
;        expansion is required and the attempted expansion fails.
;
;--

        NESTED_ENTRY KiCallUserMode, _TEXT$00

        GENERATE_EXCEPTION_FRAME <Rbp>  ; generate exception frame

;
; Save argument registers in frame and allocate a legacy floating point
; save area.
;

        mov     CuOutputBuffer[rbp], rcx ; save output buffer address
        mov     CuOutputLength[rbp], rdx ; save output length address
        sub     rsp, LEGACY_SAVE_AREA_LENGTH ; allocate legacy save area

;
; Check if sufficient room is available on the kernel stack for another
; system call.
;

        mov     rbx, gs:[PcCurrentThread] ; get current thread address
        lea     rax, (- KERNEL_LARGE_STACK_COMMIT)[rsp] ; compute bottom address
        cmp     rax, ThStackLimit[rbx]  ; check if limit exceeded
        jae     short KiCU10            ; if ae, limit not exceeded
        mov     rcx, rsp                ; set current stack address
        call    MmGrowKernelStack       ; attempt to grow kernel stack
        or      eax, eax                ; check for successful completion
        jne     short KiCU20            ; if ne, attempt to grow failed

;
; Save the previous trap frame and callback stack addresses in the current
; frame. Also save the new callback stack address in the thread object.
;

KiCU10: mov     rax, ThCallbackStack[rbx] ; save current callback stack address
        mov     CuCallbackStack[rbp], rax ;
        mov     rsi, ThTrapFrame[rbx]   ; save current trap frame address
        mov     CuTrapFrame[rbp], rsi   ;
        mov     rax, ThInitialStack[rbx] ; save initial stack address
        mov     CuInitialStack[rbp], rax ;
        mov     ThCallbackstack[rbx], rbp ; set new callback stack address

;
; Establish a new initial kernel stack address
;

        cli                             ; disable interrupts
        mov     ThInitialStack[rbx], rsp ; set new initial stack address
        mov     rdi, gs:[PcTss]         ; get processor TSS address
        mov     TssRsp0[rdi], rsp       ; set initial stack address in TSS

;
; Construct a trap frame to facilitate the transfer into user mode via
; the standard system call exit.
;
; N.B. Interrupts are not enabled throughout the remainder of the system
;      service exit.
;

        sub     rsp, KTRAP_FRAME_LENGTH ; allocate a trap frame
        mov     rdi, rsp                ; set destination address
        mov     rcx, (KTRAP_FRAME_LENGTH / 8) ; set length of copy
        rep     movsq                   ; copy trap frame
        lea     rbp, 128[rsp]           ; set frame pointer address
        mov     rax, KeUserCallbackDispatcher ; set user return address
        mov     TrRip[rbp], rax         ;
        jmp     KiSystemServiceExit     ; exit through service dispatch

;
; An attempt to grow the kernel stack failed.
;

KiCU20: mov     rsp, rbp                ; deallocate legacy save area

        RESTORE_EXCEPTION_STATE <Rbp>   ; restore exception state/deallocate

        ret                             ;

        NESTED_END KiCallUserMode, _TEXT$00

        subttl  "Convert To Gui Thread"
;++
;
; NTSTATUS
; KiConvertToGuiThread (
;     VOID
;     );
;
; Routine Description:
;
;   This routine is a stub routine which is called by the system service
;   dispatcher to convert the current thread to a GUI thread. The process
;   of converting to a GUI mode thread involves allocating a large stack,
;   switching to the large stack, and then calling the win32k subsystem
;   to record state. In order to switch the kernel stack the frame pointer
;   used in the system service dispatch must be relocated. 
;
;   N.B. The address of the pushed rbp in this routine is located from the
;        trap frame address in switch kernel stack.
;
; Arguments:
;
;   None.
;
; Implicit arguments:
;
;   rbp - Supplies a pointer to the trap frame.
;
; Return Value:
;
;   The status returned by the real convert to GUI thread is returned as the
;   function status.
;
;--

        NESTED_ENTRY KiConvertToGuiThread, _TEXT$00

        push_reg rbp                    ; save frame pointer

        END_PROLOGUE

        call    PsConvertToGuiThread    ; convert to GUI thread
        pop     rbp                     ; restore frame pointer
        ret                             ;

        NESTED_END KiConvertToGuiThread, _TEXT$00

        subttl  "Switch Kernel Stack"
;++
;
; PVOID
; KeSwitchKernelStack (
;     IN PVOID StackBase,
;     IN PVOID StackLimit
;     )
;
; Routine Description:
;
;   This function switches to the specified large kernel stack.
;
;   N.B. This function can ONLY be called when there are no variables
;        in the stack that refer to other variables in the stack, i.e.,
;        there are no pointers into the stack.
;
;   N.B. The address of the frame pointer used in the system service
;        dispatcher is located using the trap frame.
;
; Arguments:
;
;   StackBase (rcx) - Supplies a pointer to the base of the new kernel
;       stack.
;
;   StackLimit (rdx) - Suplies a pointer to the limit of the new kernel
;       stack.
;
; Return Value:
;
;   The previous stack base is returned as the function value.
;
;--

SkFrame struct
        Fill    dq ?                    ; fill to 8 mod 16
        SavedRdi dq ?                   ; saved register RDI
        SavedRsi dq ?                   ; saved register RSI
SkFrame ends

        NESTED_ENTRY KeSwitchKernelStack, _TEXT$00

        push_reg rsi                    ; save nonvolatile registers
        push_reg rdi                    ;
        alloc_stack (sizeof SkFrame - (2 * 8)) ; allocate stack frame

        END_PROLOGUE

;
; Save the address of the new stack and copy the current stack to the new
; stack.
;

        mov     r8, rcx                 ; save new stack base address
        mov     r10, gs:[PcCurrentThread] ; get current thread address
        mov     rcx, ThStackBase[r10]   ; get current stack base address
        mov     r9, ThTrapFrame[r10]    ; get current trap frame address
        sub     r9, rcx                 ; relocate trap frame address
        add     r9, r8                  ;
        mov     ThTrapFrame[r10], r9    ; set new trap frame address
        sub     rcx, rsp                ; compute length of copy in bytes
        mov     rdi, r8                 ; compute destination address of copy
        sub     rdi, rcx                ;
        mov     r9, rdi                 ; save new stack pointer address
        mov     rsi, rsp                ; set source address of copy
        shr     rcx, 3                  ; compute length of copy on quadwords
        rep     movsq                   ; copy old stack to new stack
        mov     rcx, ThTrapFrame[r10]   ; get new trap frame address
        lea     rax, 128[rcx]           ; compute new frame address
        mov     (-2 * 8)[rcx], rax      ; set relocated frame pointer 

;
; Switch to the new kernel stack and return the address of the old kernel
; stack.
;

        mov     rax, ThStackBase[r10]   ; get current stack base address
        cli                             ; disable interrupts
        mov     byte ptr ThLargeStack[r10], 1 ; set large stack TRUE
        mov     ThStackBase[r10], r8    ; set new stack base address
        sub     r8, LEGACY_SAVE_AREA_LENGTH ; compute initial stack address
        mov     ThInitialStack[r10], r8 ; set new initial stack address
        mov     ThStackLimit[r10], rdx  ; set new stack limit address
        mov     r10, gs:[PcTss]         ; get processor TSS address
        mov     TssRsp0[r10], r8        ; set initial stack address in TSS
        mov     rsp, r9                 ; set new stack pointer address
        sti                             ;
        add     rsp, sizeof SkFrame - (2 * 8) ; deallocate stack frame
        pop     rdi                     ; restore nonvolatile registers
        pop     rsi                     ;
        ret                             ; return

        NESTED_END KeSwitchKernelStack, _TEXT$00

        subttl  "Return from User Mode Callback"
;++
;
; NTSTATUS
; NtCallbackReturn (
;     IN PVOID OutputBuffer OPTIONAL,
;     IN ULONG OutputLength,
;     IN NTSTATUS Status
;     )
;
; Routine Description:
;
;   This function returns from a user mode callout to the kernel
;   mode caller of the user mode callback function.
;
;   N.B. This function returns to the function that called out to user
;        mode and the KiCallUserMode function calls out to user mode.
;        Therefore, the stack layout must be consistent between the
;        two routines.
;
; Arguments:
;
;   OutputBuffer (rcx) - Supplies an optional pointer to an output buffer.
;
;   OutputLength (rdx) - Supplies the length of the output buffer.
;
;   Status (r8) - Supplies the status value returned to the caller of the
;       callback function.
;
; Return Value:
;
;   If the callback return cannot be executed, then an error status is
;   returned. Otherwise, the specified callback status is returned to
;   the caller of the callback function.
;
;   N.B. This function returns to the function that called out to user
;        mode is a callout is currently active.
;
;--

        LEAF_ENTRY NtCallbackReturn, _TEXT$00

        mov     r11, gs:[PcCurrentThread] ; get current thread address
        mov     r10, ThCallbackStack[r11] ; get callback stack address
        cmp     r10, 0                  ; check if callback active
        je      KiCb10                  ; if zero, callback not active
        mov     rax, r8                 ; save completion status

;
; Store the output buffer address and length.
;

        mov     r9, CuOutputBuffer[r10] ; get address to store output buffer
        mov     [r9], rcx               ; store output buffer address
        mov     r9, CuOutputLength[r10] ; get address to store output length
        mov     [r9], edx               ; store output buffer length

;
; Restore the previous callback stack address and trap frame address.
;

        mov     r8, CuTrapFrame[r10]    ; get previous trap frame address
        mov     ThTrapFrame[r11], r8    ; restore previous trap frame address
        mov     r8, CuCallbackStack[r10] ; get previous callback stack address
        mov     ThCallbackStack[r11], r8 ; restore previous callback stack address

;
; Restore initial stack address.
;

        mov     r9, CuInitialStack[r10] ; get previous initial stack address
        cli                             ; disable interrupt
        mov     ThInitialStack[r11], r9 ; restore initial stack address
        mov     r8, gs:[PcTss]          ; get processor TSS address
        mov     TssRsp0[r8], r9         ; set initial stack address in TSS
        mov     rsp, r10                ; trim stack back to callback frame

        RESTORE_EXCEPTION_STATE <Rbp>   ; restore exception state/deallocate

        sti                             ; enable interrupts
        ret                             ; return

;
; No callback is currently active.
;

KiCB10: mov     eax, STATUS_NO_CALLBACK_ACTIVE ; set service status
        ret                             ; return

        LEAF_END NtCallbackReturn, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\clockint.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   clockint.asm
;
; Abstract:
;
;   This module implements the architecture dependent code necessary to
;   process the interval clock interrupt.
;
; Author:
;
;   David N. Cutler (davec) 12-Sep-2000
;
; Environment:
;
;   Kernel mode only.
;
;--

include ksamd64.inc

        extern  KdDebuggerEnabled:byte
        extern  KeMaximumIncrement:dword
        extern  KeTimeAdjustment:dword
        extern  KeTickCount:qword
        extern  KiAdjustDpcThreshold:dword
        extern  KiCheckBreakInRequest:proc
        extern  KiIdealDpcRate:dword
        extern  KiMaximumDpcQueueDepth:dword
        extern  KiTickOffset:dword
        extern  KiTimerTableListHead:qword
        extern  __imp_HalRequestSoftwareInterrupt:qword

        subttl  "Update System Time"
;++
;
; VOID
; KeUpdateSystemTime (
;     IN ULONG64 Increment
;     )
;
; Routine Description:
;
;   This routine is called as the result of an interrupt generated by the
;   interval timer. Its function is to update the interrupt time, update the
;   system time, and check to determine if a timer has expired.
;
;   N.B. This routine is executed on a single processor in a multiprocess
;        system. The remainder of the processors only execute the quantum end
;        and runtime update code.
;
; Arguments:
;
;   TrapFrame (rcx) - Supplies the address of a trap frame.
;
;   Increment (rcx) - Supplies the time increment value in 100 nanosecond
;       units.
;
; Return Value:
;
;   None.
;
;--

UsFrame struct
        P1Home  dq ?                    ; request IRQL parameter
        Fill    dq ?                    ; fill to 8 mod 16
        SavedRbp dq ?                   ; saved register RBP
UsFrame ends

        NESTED_ENTRY KeUpdateSystemTime, _TEXT$00

        push_reg rbp                    ; save nonvolatile register
        alloc_stack (sizeof UsFrame- (1 * 8)); allocate stack frame

        END_PROLOGUE

        lea     rbp, 128[rcx]           ; set frame pointer address

;
; Check if the current clock tick should be skipped.
;
; Skip tick is set when the kernel debugger is entered.
;

if DBG

        cmp     byte ptr gs:[PcSkipTick], 0 ; check if tick should be skipped
        jnz     KiUS60                  ; if nz, skip clock tick

endif

;
; Update interrupt time.
;

        mov     rcx, USER_SHARED_DATA   ; get user shared data address
        lea     r11, KiTimerTableListHead ; get timer table address
        mov     r8, UsInterruptTime[rcx] ; get interrupt time
        add     r8, rdx                 ; add time increment
        mov     rax, r8                 ; isolate high part of interrupt time
        shr     rax, 32                 ;
        mov     UsInterruptTime + 8[rcx], eax ; store high 2 interrupt time
        mov     UsInterruptTime[rcx], r8 ; store interrupt time
        mov     r10, KeTickCount        ; get tick count value
        sub     KiTickOffset, edx       ; subtract time increment
        jg      short KiUS20            ; if greater, not complete tick

;
; Update system time.
;

        mov     r9d, UsSystemTime + 0[rcx] ; get low interrupt time
        mov     eax, UsSystemTime + 4[rcx] ; get high interrupt time
        add     r9d, KeTimeAdjustment   ; add time increment
        adc     eax, 0                  ; propagate carry
        mov     UsSystemTime + 8[rcx], eax ; store high 2 interrupt time
        mov     UsSystemTime + 0[rcx], r9d ; store low interrupt time
        mov     UsSystemTime + 4[rcx], eax ; store high 1 interrupt time

;
; Update tick count.
;

        inc     KeTickCount             ; update tick count value
        inc     dword ptr UsTickCountLow[rcx] ; update low tick count value

;
; Check to determine if a timer has expired.
;

        mov     rcx, r10                ; copy tick count value
        and     ecx, TIMER_TABLE_SIZE - 1 ; isolate current hand value
        shl     ecx, 4                  ; compute listhead offset
        lea     rcx, [r11][rcx]         ; get listhead address
        mov     r9, LsFlink[rcx]        ; get first entry address
        cmp     r9, rcx                 ; check if list is empty
        je      short KiUS10            ; if e, list is empty
        cmp     r8, (TiDueTime - TiTimerListEntry)[r9] ; compare due time
        jae     short KiUS30            ; if ae, timer has expired
KiUS10: inc     r10                     ; advance tick count value

;
; Check to determine if a timer has expired.
;

KiUS20: mov     rcx, r10                ; copy tick count value
        and     ecx, TIMER_TABLE_SIZE - 1 ; isolate current hand value
        shl     ecx, 4                  ; compute listhead offset
        lea     rcx, [r11][rcx]         ; get listhead addrees
        mov     r9, LsFlink[rcx]        ; get first entry address
        cmp     r9, rcx                 ; check if list is empty
        je      short KiUS40            ; if equal, list is empty
        cmp     r8, (TiDueTime - TiTimerListEntry)[r9] ; compare due time
        jb      short KiUS40            ; if b, timer has not expired

;
; A timer has expired.
;
; Set the timer hand value in the current processor block if it is not already
; set.
;

KiUS30: mov     rdx, gs:[PcCurrentPrcb] ; get current processor block address
        cmp     dword ptr PbTimerHand[rdx], 0 ; check if expiration active
        jne     short KiUS40            ; if ne, expiration already active
	and	r10d, TIMER_TABLE_SIZE - 1 ; isolate current hand value
        inc     r10d                    ; increment timer hand value
        mov     PbTimerHand[rdx], r10d  ; set timer hand value
        mov     cl, DISPATCH_LEVEL      ; request dispatch interrupt
        call    __imp_HalRequestSoftwareInterrupt ;

;
; If the debugger is enabled, check if a break is requested.
;

KiUS40: cmp     KdDebuggerEnabled, 0    ; check if a debugger is enabled
        je      short KiUS50            ; if e, debugger is not enabled
        call    KiCheckBreakInRequest   ; check for break in request

;
; Check to determine if a full tick has expired.
;

KiUS50: cmp     KiTickOffset, 0         ; check if full tick has expired
        jg      short KiUS70            ; if g, not a full tick
        mov     eax, KeMaximumIncrement ; get maximum time incrmeent
        add     KiTickOffset, eax       ; add maximum time to residue
        mov     rcx, rbp                ; set trap frame address
        call    KeUpdateRunTime         ; update runtime

if DBG

KiUS60: mov     byte ptr gs:[PcSkipTick], 0 ; clear skip tick indicator

endif

KiUS70: add     rsp, sizeof UsFrame- (1 * 8) ; deallocate stack frame
        pop     rbp                     ; restore nonvolatile register
        ret                             ; return

        NESTED_END KeUpdateSystemTime, _TEXT$00

        subttl  "Update Thread and Process Runtime"
;++
;
; Routine Description:
;
;   This routine is called as the result of the interval timer interrupt on
;   all processors in the system. Its function is update the runtime of the
;   current thread, update the runtime of the current thread's process, and
;   decrement the current thread's quantum. This routine also implements DPC
;   interrupt moderation.
;
;   N.B. This routine is executed on all processors in a multiprocessor
;        system.
;
; Arguments:
;
;   rcx - Supplies the address of a trap frame.
;
; Return Value:
;
;   None.
;
;--

UrFrame struct
        P1Home  dq ?                    ; request IRQL parameter
        Fill    dq ?                    ; fill to 8 mod 16
        SavedRdi dq ?                   ; saved register RDI
        SavedRsi dq ?                   ; saved register RSI
        savedRbp dq ?                   ; saved register RBP
UrFrame ends

        NESTED_ENTRY KeUpdateRunTime, _TEXT$00

        push_reg rbp                    ; save nonvolatile registers
        push_reg rsi                    ;
        push_reg rdi                    ;
        alloc_stack (sizeof UrFrame - (3 * 8)) ; allocate stack frame

        END_PROLOGUE

        lea     rbp, 128[rcx]           ; set frame pointer address

;
; Check if the current clock tick should be skipped.
;
; Skip tick is set when the kernel debugger is entered.
;

if DBG

        cmp     byte ptr gs:[PcSkipTick], 0 ; check if tick should be skipped
        jnz     KiUR70                  ; if nz, skip clock tick

endif

;
; Update time counter based on previous mode, IRQL level, and whether there
; is currently a DPC active.
;

        mov     rsi, gs:[PcCurrentPrcb]  ; get current processor block address
        mov     rdi, PbCurrentThread[rsi] ; get current thread address
        mov     rdx, ThApcState + AsProcess[rdi] ; get current process address
        test    byte ptr TrSegCs[rbp], MODE_MASK ; check if previous mode user
        jnz     short KiUR30            ; if nz, previous mode user

;
; Update the total time spent in kernel mode.
;

        inc     dword ptr PbKernelTime[rsi] ; increment kernel time
        cmp     byte ptr TrPreviousIrql[rbp], DISPATCH_LEVEL ; check IRQL level
        jb      short KiUR20            ; if b, previous IRQL below DPC level
        ja      short KiUR10            ; if a, previous IRQL above DPC level
        cmp     dword ptr PbDpcRoutineActive[rsi], 0 ; check if DPC routine active
        je      short KiUR20            ; if e, no DPC routine active
        inc     dword ptr PbDpcTime[rsi] ; increment time at DPC level
        jmp     short KiUR40            ; finish in common code

;
; Update the time spent at interrupt time for this processor
;

KiUR10: inc     dword ptr PbInterruptTime[rsi] ; increment interrupt time
        jmp     short KiUR40            ; finish in common code

;
; Update the time spent in kernel mode for the current thread and the current
; process.
;

KiUR20: inc     dword ptr ThKernelTime[rdi] ; increment time in kernel mode

ifndef NT_UP

   lock inc     dword ptr PrKernelTime[rdx] ; increment time in kernel mode

else

        inc     dword ptr PrKernelTime[rdx] ; increment time in kernel mode

endif
        jmp     short KiUR40            ; finish in common code

;
; Update total time spent in user mode and update the time spent inuser mode
; for the current thread and the current process.
;

KiUR30: inc     dword ptr PbUserTime[rsi] ; increment time in user mode
        inc     dword ptr ThUserTime[rdi] ; increment time is user mode

ifndef NT_UP

   lock inc     dword ptr PrUserTime[rdx] ; increment time in user mode

else

        inc     dword ptr PrUserTime[rdx] ; increment time in user mode

endif

;
; Update the DPC request rate which is computed as the average between the
; previous rate and the current rate.
;

KiUR40: mov     ecx, PbDpcCount[rsi]    ; get current DPC count
        mov     edx, PbDpcLastCount[rsi] ; get last DPC count
        mov     PbDpcLastCount[rsi], ecx ; set last DPC count
        sub     ecx, edx                ; compute count during interval
        add     ecx, PbDpcRequestRate[rsi] ; compute sum
        shr     ecx, 1                  ; average current and last
        mov     PbDpcRequestRate[rsi], ecx ; set new DPC request rate

;
; If the current DPC queue depth is not zero, a DPC routine is not active,
; and a DPC interrupt has not been requested, then request a dispatch
; interrupt, decrement the maximum DPC queue depth, and reset the threshold
; counter if appropriate.
;

        cmp     dword ptr PbDpcQueueDepth[rsi], 0 ; check if queue depth zero
        je      short KiUR50            ; if e, DPC queue depth is zero
        cmp     dword ptr PbDpcRoutineActive[rsi], 0 ; check if DPC routine active
        jne     short KiUR50            ; if ne, DPC routine active
        cmp     dword ptr PbDpcInterruptRequested[rsi], 0 ; check if interrupt
        jne     short KiUR50            ; if ne, interrupt requested
        mov     cl, DISPATCH_LEVEL      ; request a dispatch interrupt
        call    __imp_HalRequestSoftwareInterrupt ;
        mov     ecx, PbDpcRequestRate[rsi] ; get DPC request rate
        mov     edx, KiAdjustDpcThreshold ; reset initial threshold counter
        mov     PbAdjustDpcThreshold[rsi], edx ;
        cmp     ecx, KiIdealDpcRate     ; check if current rate less than ideal
        jge     short KiUR60            ; if ge, rate greater or equal ideal
        cmp     dword ptr PbMaximumDpcQueueDepth[rsi], 1 ; check if maximum depth one
        je      short KiUR60            ; if e, maximum depth is one
        dec     dword ptr PbMaximumDpcQueueDepth[rsi] ; decrement depth
        jmp     short KiUR60            ;

;
; The DPC queue is empty or a DPC routine is active or a DPC interrupt has
; been requested. Count down the adjustment threshold and if the count reaches
; zero, then increment the maximum DPC queue depth, but not above the initial
; value and reset the adjustment threshold value.
;

KiUR50: dec     dword ptr PbAdjustDpcThreshold[rsi] ; decrement threshold
        jnz     short KiUR60            ; if nz, threshold not zero
        mov     ecx, KiAdjustDpcThreshold ; reset initial threshold counter
        mov     PbAdjustDpcThreshold[rsi], ecx ;
        mov     ecx, KiMaximumDpcQueueDepth ; get maximum DPC queue depth
        cmp     ecx, PbMaximumDpcQueueDepth[rsi] ; check if depth at maximum level
        je      short KiUR60            ; if e, aleady a maximum level
        inc     dword ptr PbMaximumDpcQueueDepth[rsi] ; increment maximum depth

;
; Decrement current thread quantum and check to determine if a quantum end
; has occurred.
;

KiUR60: sub     byte ptr ThQuantum[rdi], CLOCK_QUANTUM_DECREMENT ; decrement quantum
        jg      short KiUR80            ; if g, time remaining on quantum

;
; Set quantum end flag and initiate a dispather interrupt on the current
; processor.
;

        cmp     rdi, PbIdleThread[rsi]  ; check if idle thread
        je      short KiUR80            ; if e, idle thread
        inc     dword ptr PbQuantumEnd[rsi] ; set quantum end indicator
        mov     cl, DISPATCH_LEVEL      ; request dispatch interrupt
        call    __imp_HalRequestSoftwareInterrupt ;

if DBG

KiUR70: mov     byte ptr gs:[PcSkipTick], 0 ; clear skip tick indicator

endif

KiUR80: add     rsp, sizeof UrFrame - (3 * 8) ; deallocate stack frame
        pop     rdi                     ; restore nonvolatile registers
        pop     rsi                     ;
        pop     rbp                     ;
        ret                             ; return

        NESTED_END KeUpdateRunTime, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\ctxswap.asm ===
title  "Context Swap"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   ctxswap.asm
;
; Abstract:
;
;   This module implements the code necessary to field the dispatch interrupt
;   and perform context switching.
;
; Author:
;
;   David N. Cutler (davec) 26-Aug-2000
;
; Environment:
;
;    Kernel mode only.
;
;--

include ksamd64.inc

        extern  KeAcquireQueuedSpinLockAtDpcLevel:proc
        extern  KeAcquireQueuedSpinLockRaiseToSynch:proc
        extern  KeBugCheck:proc
        extern  KeReleaseQueuedSpinLock:proc
        extern  KeReleaseQueuedSpinLockFromDpcLevel:proc
        extern  KiDeliverApc:proc
        extern  KiDispatcherLock:qword
        extern  KiQuantumEnd:proc
        extern  KiReadyThread:proc
        extern  KiRetireDpcList:proc
        extern  __imp_HalRequestSoftwareInterrupt:qword

        subttl  "Unlock Dispatcher Database"
;++
;
; VOID
; KiUnlockDispatcherDatabase (
;     IN KIRQL OldIrql
;     )
;
; Routine Description:
;
;   This routine is entered at SYNCH_LEVEL with the dispatcher database
;   locked. Its function is to either unlock the dispatcher database and
;   return or initiate a context switch if another thread has been selected
;   for execution.
;
; Arguments:
;
;   OldIrql (cl) - Supplies the IRQL when the dispatcher database lock was
;       acquired.
;
; Return Value:
;
;   None.
;
;--

UdFrame struct
        P1Home  dq ?                    ; queued spin lock number parameter
        P2Home  dq ?                    ; previous IRQL paramater
        SavedIrql db ?                  ; saved previous IRQL
        Fill    db 7 dup (?)            ; fill to 8 mod 16
UdFrame ends

        NESTED_ENTRY KiUnlockDispatcherDatabase, _TEXT$00

        alloc_stack (sizeof UdFrame)    ; allocate stack frame

        END_PROLOGUE

;
; Check if a new thread is scheduled for execution.
;

        cmp     qword ptr gs:[PcNextThread], 0 ; check if thread scheduled
        jne     short KiUD30            ; if ne, new thread scheduled

;
; Release dispatcher database lock, lower IRQL to its previous level,
; and return.
;

ifndef NT_UP

KiUD10: mov     dl, cl                  ; set old IRQL value
        mov     ecx, LockQueueDispatcherLock ; set lock queue number
        call    KeReleaseQueuedSpinLock ; release dispatcher lock

else

KiUD10: movzx   ecx, cl                 ; set IRQL to previous level

        SetIrql                         ;

endif

        add     rsp, sizeof UdFrame     ; deallocate stack frame
        ret                             ; return

;
; A new thread has been selected to run on the current processor, but the new
; IRQL is not below dispatch level. If the current processor is not executing
; a DPC, then request a dispatch interrupt on the current processor.
;

KiUD20: cmp     qword ptr gs:[PcDpcRoutineActive], 0 ; check if DPC routine active
        jne     short KiUD10            ; if ne, DPC routine is active
        mov     UdFrame.SavedIrql[rsp], cl ; save previous IRQL
        mov     cl, DISPATCH_LEVEL      ; request dispatch interrupt
        call    __imp_HalRequestSoftwareInterrupt ;
        mov     cl, UdFrame.SavedIrql[rsp] ; restore previous IRQL
        jmp     short KiUD10

;
; Check if the previous IRQL is less than dispatch level.
;

KiUD30: cmp     cl, DISPATCH_LEVEL      ; check if IRQL below dispatch level
        jge     short KiUD20            ; if ge, not below dispatch level
        add     rsp, sizeof UdFrame     ; deallocate stack frame
        jmp     short KxUnlockDispatcherDatabase ; finish in common code

        NESTED_END KiUnlockDispatcherDatabase, _TEXT$00

;
; There is a new thread scheduled for execution and the previous IRQL is
; less than dispatch level. Context switch to the new thread immediately.
;
; N.B. The following routine is entered by falling through the from above
;      code.
;
; N.B. The following routine is carefully written as a nested function that
;      appears to have been called directly by the caller of the above
;      function which unlocks the dispatcher database.
;
; Arguments:
;
;   OldIrql (cl) - Supplies the IRQL when the dispatcher database lock was
;       acquired.
;

        NESTED_ENTRY KxUnlockDispatcherDatabase, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        mov     rbx, gs:[PcCurrentPrcb] ; get current PRCB address
        mov     rsi, PbNextThread[rbx]  ; get next thread address
        mov     rdi, PbCurrentThread[rbx] ; get current thread address
        and     qword ptr PbNextThread[rbx], 0 ; clear next thread address
        mov     PbCurrentThread[rbx], rsi ; set current thread address
        mov     ThWaitIrql[rdi], cl     ; save previous IRQL

ifndef NT_UP

        mov     byte ptr ThIdleSwapBlock[rdi], 1 ; block swap from idle

endif

        mov     rcx, rdi                ; set address of current thread
        call    KiReadyThread           ; reready thread for execution
        xor     eax, eax                ; set NPX save false
        mov     cl, ThWaitIrql[rdi]     ; set APC interrupt bypass disable

ifndef NT_UP

        xor     edx, edx                ; set swap from idle false

endif

        call    SwapContext             ; swap context
        movzx   ecx, byte ptr ThWaitIrql[rsi] ; get original wait IRQL
        or      al, al                  ; check if kernel APC pending
        jz      short KiXD10            ; if z, no kernel APC pending
        mov     ecx, APC_LEVEL          ; set IRQL to APC level

        SetIrql                         ;

        xor     ecx, ecx                ; set previous mode to kernel
        xor     edx, edx                ; clear exception frame address
        xor     r8, r8                  ; clear trap frame address
        call    KiDeliverApc            ; deliver kernel mode APC
        xor     ecx, ecx                ; set original wait IRQL
KiXD10:                                 ; reference label

        SetIrql                         ; set IRQL to previous level

        RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        NESTED_END KxUnlockDispatcherDatabase, _TEXT$00

        subttl  "Swap Context"
;++
;
; BOOLEAN
; KiSwapContext (
;    IN PKTHREAD Thread
;    )
;
; Routine Description:
;
;   This function is a small wrapper that marshalls arguments and calls the
;   actual swap context routine.
;
; Arguments:
;
;   Thread (rcx) - Supplies the address of the new thread.
;
; Return Value:
;
;   If a kernel APC is pending, then a value of TRUE is returned. Otherwise,
;   a value of FALSE is returned.
;
;--

        NESTED_ENTRY KiSwapContext, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        mov     rbx, gs:[PcCurrentPrcb] ; get current PRCB address
        mov     rsi, rcx                ; set next thread address
        mov     rdi, PbCurrentThread[rbx] ; get current thread address
        mov     PbCurrentThread[rbx], rsi ; set current thread address
        xor     eax, eax                ; set NPX save false
        mov     cl, ThWaitIrql[rdi]     ; set APC interrupt bypass disable

ifndef NT_UP

        xor     edx, edx                ; set swap from idle false

endif

        call    SwapContext             ; swap context

        RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        NESTED_END KiSwapContext, _TEXT$00

        subttl  "Dispatch Interrupt"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a software interrupt generated
;   at DISPATCH_LEVEL. Its function is to process the DPC list, and then
;   perform a context switch if a new thread has been selected for execution
;   on the current processor.
;
;   This routine is entered at DISPATCH_LEVEL with the dispatcher database
;   unlocked.
;
; Arguments:
;
;   None
;
; Return Value:
;
;   None.
;
;--

DiFrame struct
        P1Home  dq ?                    ; PRCB address parameter
        Fill    dq ?                    ; fill to 8 mod 16
        SavedRbx dq ?                   ; saved RBX
DiFrame ends

        NESTED_ENTRY KiDispatchInterrupt, _TEXT$00

        push_reg rbx                    ; save nonvolatile register
        alloc_stack (sizeof DiFrame - 8) ; allocate stack frame

        END_PROLOGUE

        mov     rbx, gs:[PcCurrentPrcb] ; get current PRCB address
        and     dword ptr PbDpcInterruptRequested[rbx], 0 ; clear request

;
; Check if the DPC queue has any entries to process.
;

KiDI10: cli                             ; disable interrupts
        mov     eax, PbDpcQueueDepth[rbx] ; get DPC queue depth
        or      eax, PbTimerHand[rbx]   ; merge timer hand value
        jz      short KiDI20            ; if z, no DPCs to process
        mov     PbSavedRsp[rbx], rsp    ; save current stack pointer
        mov     rsp, PbDpcStack[rbx]    ; set DPC stack pointer
        mov     rcx, rbx                ; set PRCB address parameter
        call    KiRetireDpcList         ; process the DPC list
        mov     rsp, PbSavedRsp[rbx]    ; restore current stack pointer

;
; Check to determine if quantum end is requested.
;

KiDI20: sti                             ; enable interrupts
        cmp     dword ptr PbQuantumEnd[rbx], 0 ; check if quantum end request
        je      short KiDI50            ; if e, quantum end not requested

;
; Process quantum end event.
;
; N.B. If a new thread is selected as a result of processing the quantum end
;      request, then the new thread is returned with the dispatcher database
;      locked. Otherwise, NULL is returned with the dispatcher database
;      unlocked.
;

        and     dword ptr PbQuantumEnd[rbx], 0 ; clear quantum end indicator
        call    KiQuantumEnd            ; process quantum end
        test    rax, rax                ; test if new thread selected
        jnz     short KiDI60            ; if ne, new thread selected

;
; A new thread has not been selected for execution. Restore nonvolatile
; registers, deallocate stack frame, and return.
;

KiDI30: mov     rbx, DiFrame.SavedRbx[rsp] ; restore nonvolatile register
        add     rsp, sizeof DiFrame     ; deallocate stack frame
        ret                             ; return

;
; The dispatch lock could not be acquired. Lower IRQL to dispatch level, and
; loop processing the DPC list and quantum end events.
;

KiDI40: mov     ecx, DISPATCH_LEVEL     ; set IRQL to DISPATCH_LEVEL

        SetIrql                         ;

        jmp short KiDI10                ; try again

;
; Check to determine if a new thread has been selected for execution on this
; processor.
;

KiDI50: cmp     qword ptr PbNextThread[rbx], 0 ; check if new thread selected
        je      short KiDI30            ; if eq, then no new thread

ifndef NT_UP

        mov     ecx, SYNCH_LEVEL        ; set IRQL to SYNCH_LEVEL

        SetIrql                         ;

        lea     rcx, KiDispatcherLock   ; get dispatcher database lock address
        lea     rdx, PbLockQueue + (16 * LockQueueDispatcherLock)[rbx] ; lock queue
        xor     eax, eax                ; set comperand value to NULL
   lock cmpxchg [rcx], rdx              ; try to acquire dispatcher lock
        jnz     short KiDI40            ; if nz, dispatcher lock not acquired

endif

        mov     rax, PbNextThread[rbx]  ; get next thread address

;
; Swap context to a new thread.
;

KiDI60: add     rsp, sizeof DiFrame - 8 ; deallocate stack frame
        pop     rbx                     ; restore nonvolatile register
        jmp     short KxDispatchInterrupt ; finish in common code

        NESTED_END KiDispatchInterrupt, _TEXT$00

;
; There is a new thread scheduled for execution and the dispatcher lock
; has been acquired. Context switch to the new thread immediately.
;
; N.B. The following routine is entered by falling through from the above
;      routine.
;
; N.B. The following routine is carefully written as a nested function that
;      appears to have been called directly by the caller of the above
;      function which processes the dispatch interrupt.
;
; Arguments:
;
;   Thread (rax) - Supplies the address of the next thread to run on the
;       current processor.
;

        NESTED_ENTRY KxDispatchInterrupt, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        mov     rbx, gs:[PcCurrentPrcb] ; get current PRCB address
        mov     rsi, rax                ; set address of next thread
        mov     rdi, PbCurrentThread[rbx] ; get current thread address
        and     qword ptr PbNextThread[rbx], 0 ; clear next thread address
        mov     PbCurrentThread[rbx], rsi ; set current thread address

ifndef NT_UP

        mov     byte ptr ThIdleSwapBlock[rdi], 1 ; block swap from idle

endif

        mov     rcx, rdi                ; set address of current thread
        call    KiReadyThread           ; reready thread for execution
        mov     eax, TRUE               ; set NPX save true
        mov     cl, APC_LEVEL           ; set APC interrupt bypass disable

ifndef NT_UP

        xor     edx, edx                ; set swap from idle false

endif

        call    SwapContext             ; call context swap routine

        RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        NESTED_END KxDispatchInterrupt, _TEXT$00

        subttl  "Swap Context"
;++
;
; Routine Description:
;
;   This routine is called to swap context from one thread to the next. It
;   swaps context, flushes the translation buffer, swaps the process address
;   space if necessary, and returns to its caller.
;
;   N.B. This routine is only called by code within this module and the idle
;        thread code and uses special register calling conventions.
;
; Arguments:
;
;   al - Supplies a boolean value that determines whether the full legacy
;       floating state needs to be saved.
;
;   cl - Supplies the APC interrupt bypass disable IRQL value.
;
;   edx - Supplies a logical value that specifies whether the context swap
;       is being called from the idle thread (MP systems only).
;
;   rbx - Supplies the address of the current PRCB.
;
;   rdi - Supplies the address of previous thread.
;
;   rsi - Supplies the address of next thread.
;
; Return value:
;
;   al - Supplies the kernel APC pending flag.
;
;   rbx - Supplies the address of the current PRCB.
;
;   rsi - Supplies the address of current thread.
;
;--

        NESTED_ENTRY SwapContext, _TEXT$00

        push_reg rbp                    ; save nonvolatile register
        alloc_stack (KSWITCH_FRAME_LENGTH - (2 * 8)) ; allocate stack frame

        END_PROLOGUE

        mov     SwNpxSave[rsp], al      ; save NPX save
        mov     SwApcBypass[rsp], cl    ; save APC bypass disable

;
; Set the new thread state to running.
;
; N.B. The state of the new thread MUST be set to running before releasing
;      the dispatcher lock.
;

        mov     byte ptr ThState[rsi], Running ; set thread state to running

;
; Acquire the context swap lock so the address space of the previous process
; cannot be deleted, then release the dispatcher database lock.
;
; N.B. The context swap lock is used to protect the address space until the
;      context switch has sufficiently progressed to the point where the
;      previous process address space is no longer needed. This lock is also
;      acquired by the reaper thread before it finishes thread termination.
;


ifndef NT_UP

        test    edx, edx                ; test if call from idle thread
        jnz     short KiSC05            ; if nz, call from idle thread
        lea     rcx, PbLockQueue + (16 * LockQueueContextSwapLock)[rbx] ; lock queue
        call    KeAcquireQueuedSpinLockAtDpcLevel ; acquire context swap lock
        lea     rcx, PbLockQueue + (16 * LockQueueDispatcherLock)[rbx] ; lock queue
        call    KeReleaseQueuedSpinLockFromDpcLevel ; release dispatcher lock

endif

;
; Check if an attempt is being made to context switch while in a DPC routine.
;

KiSC05: cmp     dword ptr PbDpcRoutineActive[rbx], 0 ; check if DPC active
        jne     KiSC60                  ; if ne, DPC is active

;
; Accumulate the total time spent in a thread.
;

ifdef PERF_DATA

        rdtsc                           ; read cycle counter
        sub     eax, PbThreadStartCount + 0[rbx] ; sub out thread start time
        sbb     edx, PbThreadStartCount + 4[rbx] ;
        add     EtPerformanceCountLow[rdi], eax ; accumlate thread run time
        adc     EtPerformanceCountHigh[rdi], edx ;
        add     PbThreadStartCount + 4[rbx], eax ; set new thread start time
        adc     PbThreadStartCount + 8[rbx], edx ;

endif

;
; Save the kernel mode XMM control/status register. If the current thread
; executes in user mode, then also save the legacy floating point state.
;

        stmxcsr SwMxCsr[rsp]            ; save kernel mode XMM control/status
        cmp     byte ptr ThNpxState[rdi], UserMode ; check if user mode thread
        jne     short KiSC10            ; if ne, not user mode thread
        mov     rbp, ThInitialStack[rdi] ; get previous thread initial stack
        cmp     byte ptr SwNpxSave[rsp], TRUE ; check if full save required
        jne     short KiSC07            ; if ne, full save not required
        fnsaved [rbp]                   ; save full legacy floating point state
        jmp     short KiSC10            ;

;
; Full floating save not required.
;

KiSC07: fnstenvd [rbp]                  ; save legacy floating environment

;
; Switch kernel stacks.
;

KiSC10: mov     ThKernelStack[rdi], rsp ; save old kernel stack pointer
        mov     rsp, ThKernelStack[rsi] ; get new kernel stack pointer

;
; Swap the process address space if the new process is not the same as the
; previous process.
;

        mov     rax, ThApcState + AsProcess[rdi] ; get previous process address
        cmp     rax, ThApcState + AsProcess[rsi] ; check if process address match
        je      short KiSC20            ; if e, process addresses match
        mov     r14, ThApcState + AsProcess[rsi] ; get new process address

;
; Update the processor set masks.
;

ifndef NT_UP

        mov     rcx, PbSetMember[rbx]   ; get processor set member
        xor     PrActiveProcessors[rax], rcx ; clear bit in previous set
        xor     PrActiveProcessors[r14], rcx ; set bit in new set

if DBG

        test    PrActiveProcessors[rax], rcx ; test if bit clear in previous set
        jnz     short @f                ; if nz, bit not clear in previous set
        test    PrActiveProcessors[r14], rcx ; test if bit set in new set
        jnz     short KiSC15            ; if nz, bit set in new set
@@:     int     3                       ; debug break - incorrect active mask

endif

endif

;
; Load new CR3 value which will flush the TB and set the IOPM map offset in
; the TSS.
;

KiSC15: mov     r15, gs:[PcTss]         ; get processor TSS address
        mov     cx, PrIopmOffset[r14]   ; get process IOPM offset
        mov     TssIoMapBase[r15], cx   ; set TSS IOPM offset
        mov     rax, PrDirectoryTableBase[r14] ; get new directory base
        mov     cr3, rax                ; flush TLB and set new directory base

;
; Release the context swap lock.
;

KiSC20: mov     byte ptr ThIdleSwapBlock[rdi], 0 ; unblock swap from idle

ifndef NT_UP

        lea     rcx, PbLockQueue + (16 * LockQueueContextSwapLock)[rbx] ; lock queue
        call    KeReleaseQueuedSpinLockFromDpcLevel ; release context swap lock

endif

;
; Set the new kernel stack base in the TSS.
;

        mov     r15, gs:[PcTss]         ; get processor TSS address
        mov     rbp, ThInitialStack[rsi] ; get new stack base address
        mov     TssRsp0[r15], rbp       ; set stack base address in TSS

;
; If the new thread executes in user mode, then restore the legacy floating
; state, load the compatibility mode TEB address, load the native user mode
; TEB address, and reload the segment registers if needed.
;
; N.B. The upper 32-bits of the compatibility mode TEB address are always
;      zero.
;

        cmp     byte ptr ThNpxState[rsi], UserMode ; check if user mode thread
        jne     KiSC30                  ; if ne, not user mode thread
        cmp     byte ptr SwNpxSave[rsp], TRUE ; check if full restore required
        jne     short KiSC22            ; if ne, full restore not required
        mov     cx, LfControlWord[rbp]  ; save current control word
        mov     word ptr LfControlWord[rbp], 03fh ; set to mask all exceptions
        frstord [rbp]                   ; restore legacy floating point state
        mov     LfControlWord[rbp], cx  ; restore control word
        fldcw   word ptr LfControlWord[rbp] ; load legacy control word
        jmp     short KiSC24            ;

;
; Full legacy floating restore not required.
;

KiSC22: fldenv  [rbp]                   ; restore legacy floating environment

;
; Set base of compatibility mode TEB.
;

KiSC24: mov     eax, ThTeb[rsi]         ; compute compatibility mode TEB address
        add     eax, CmThreadEnvironmentBlockOffset ;
        mov     rcx, gs:[PcGdt]         ; get GDT base address
        mov     KgdtBaseLow + KGDT64_R3_CMTEB[rcx], ax ; set CMTEB base address
        shr     eax, 16                 ;
        mov     KgdtBaseMiddle + KGDT64_R3_CMTEB[rcx], al ;
        mov     KgdtBaseHigh + KGDT64_R3_CMTEB[rcx], ah   ;

;
; If the user segment selectors have been changed, then reload them with
; their cannonical values.
;

        mov     ax, ds                  ; compute sum of segment selectors
        mov     cx, es                  ;
        add     ax, cx                  ;
        mov     cx, gs                  ;
        add     ax, cx                  ;
        cmp     ax, ((KGDT64_R3_DATA or RPL_MASK) * 3) ; check if sum matches
        je      short KiSC25            ; if e, sum matches expected value
        mov     cx, KGDT64_R3_DATA or RPL_MASK ; reload user segment selectors
        mov     ds, cx                  ;
        mov     es, cx                  ;

;
; N.B. The following reload of the GS selector destroys the system MSR_GS_BASE
;      register. Thus this sequence must be done with interrupt off.
;

        mov     eax, gs:[PcSelf]        ; get current PCR address
        mov     edx, gs:[PcSelf + 4]    ;
        cli                             ; disable interrupts
        mov     gs, cx                  ; reload GS segment selector
        mov     ecx, MSR_GS_BASE        ; get GS base MSR number
        wrmsr                           ; write system PCR base address
        sti                             ; enable interrupts
KiSC25: mov     ax, KGDT64_R3_CMTEB or RPL_MASK ; reload FS segment selector
        mov     fs, ax                  ;
        mov     eax, ThTeb[rsi]         ; get low part of user TEB address
        mov     edx, ThTeb + 4[rsi]     ; get high part of user TEB address
        mov     gs:[PcTeb], eax         ; set user TEB address in PCR
        mov     gs:[PcTeb + 4], edx     ;
        mov     ecx, MSR_GS_SWAP        ; get GS base swap MSR number
        wrmsr                           ; write user TEB base address

;
; Restore kernel mode XMM control/status and update context switch counters.
;

KiSC30: ldmxcsr SwMxCsr[rsp]            ; kernel mode XMM control/status
        inc     dword ptr ThContextSwitches[rsi] ; thread count
        inc     dword ptr PbContextSwitches[rbx] ; processor count

;
; If the new thread has a kernel mode APC pending, then request an APC
; interrupt if APC bypass is disabled.
;

        mov     al, ThApcState + AsKernelApcPending[rsi] ; get APC pending
        test    al, al                  ; test if kernel APC pending
        jz      short KiSC50            ; if z, kernel APC not pending
        cmp     byte ptr SwApcBypass[rsp], APC_LEVEL ; check if APC bypass enabled
        jb      short KiSC40            ; if b, APC bypass is enabled
        mov     cl, APC_LEVEL           ; request APC interrupt
        call    __imp_HalRequestSoftwareInterrupt ;
        clc                             ; clear carry flag
KiSC40: setb    al                      ; set return value
KiSC50: add     rsp, KSWITCH_FRAME_LENGTH - (2 * 8) ; deallocate stack frame
        pop     rbp                     ; restore nonvolatile register
        ret                             ; return

;
; An attempt is being made to context switch while in a DPC routine. This is
; most likely caused by a DPC routine calling one of the wait functions.
;

KiSC60: mov     ecx, ATTEMPTED_SWITCH_FROM_DPC ; set bug check code
        call    KeBugCheck              ; bug check system - no return
        ret                             ; return

        NESTED_END SwapContext, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\dpcint.asm ===
title  "Deferred Procedure Call Interrupt"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   dpcint.asm
;
; Abstract:
;
;   This module implements the code necessary to process the Deferred
;   Procedure Call interrupt.
;
; Author:
;
;   David N. Cutler (davec) 10-Nov-2000
;
; Environment:
;
;    Kernel mode only.
;
;--

        extern  KiDispatchInterrupt:proc
        extern  KiInitiateUserApc:proc
        extern  __imp_HalEndSystemInterrupt:qword

include ksamd64.inc

        subttl  "Deferred Procedure Call Interrupt"
;++
;
; VOID
; KiDpcInterrupt (
;     VOID
;     )
;
; Routine Description:
;
;   This routine is entered as the result of a software interrupt generated
;   at DISPATCH_LEVEL. Its function is to save the machine state and call
;   the dispatch interrupt routine.
;
;   N.B. This is a directly connected interrupt that does not use an interrupt
;        object.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiDpcInterrupt, _TEXT$00

        .pushframe                      ; mark machine frame

        push_reg rbp                    ; push dummy vector
        push_reg rbp                    ; save nonvolatile register

        GENERATE_INTERRUPT_FRAME        ; generate interrupt frame

        mov     ecx, DISPATCH_LEVEL     ; set new IRQL level

	ENTER_INTERRUPT			; raise IRQL, do EOI, enable interrupts

        call    KiDispatchInterrupt     ; process the dispatch interrupt

        EXIT_INTERRUPT <NoEOI>          ; lower IRQL and restore state

        NESTED_END KiDpcInterrupt, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\dpcplt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dpcplt.c

Abstract:

    This module implements platform specific code to support Deferred
    Procedure Calls (DPCs).

Author:

    David N. Cutler (davec) 30-Aug-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
KiRetireDpcList (
    PKPRCB Prcb
    )

/*++

Routine Description:

    This function processes the DPC list for the specified processor.

    N.B. This function is entered with interrupts disabled and exits with
         interrupts disabled.

Arguments:

    Prcb - Supplies the address of the processor block.

Return Value:

    None.

--*/

{

    PKDPC Dpc;
    PVOID DeferredContext;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PLIST_ENTRY Entry;
    PLIST_ENTRY ListHead;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    ULONG TimerHand;

    //
    // Loop processing DPC list entries until the specified DPC list is empty.
    //
    // N.B. This following code appears to have a redundant loop, but it does
    //      not. The point of this code is to avoid as many dispatch interrupts
    //      as possible.
    //

    ListHead = &Prcb->DpcListHead;
    do {
        Prcb->DpcRoutineActive = TRUE;

        //
        // If the timer hand value is nonzero, then process expired timers.
        //

        if ((TimerHand = Prcb->TimerHand) != 0) {
            Prcb->TimerHand = 0;
            _enable();
            KiTimerExpiration(NULL, NULL, UlongToHandle(TimerHand - 1), NULL);
            _disable();
        }

        //
        // If the DPC list is not empty, then process the DPC list.
        //

        if (Prcb->DpcQueueDepth != 0) {

            //
            // Acquire the DPC lock for the current processor and check if
            // the DPC list is empty. If the DPC list is not empty, then
            // remove the first entry from the DPC list, capture the DPC
            // parameters, set the DPC inserted state false, decrement the
            // DPC queue depth, release the DPC lock, enable interrupts, and
            // call the specified DPC routine. Otherwise, release the DPC
            // lock and enable interrupts.
            //

            do {
                KeAcquireSpinLockAtDpcLevel(&Prcb->DpcLock);
                Entry = Prcb->DpcListHead.Flink;
                if (Entry != ListHead) {
                    RemoveEntryList(Entry);
                    Dpc = CONTAINING_RECORD(Entry, KDPC, DpcListEntry);
                    DeferredRoutine = Dpc->DeferredRoutine;
                    DeferredContext = Dpc->DeferredContext;
                    SystemArgument1 = Dpc->SystemArgument1;
                    SystemArgument2 = Dpc->SystemArgument2;
                    Dpc->Lock = NULL;
                    Prcb->DpcQueueDepth -= 1;
                    KeReleaseSpinLockFromDpcLevel(&Prcb->DpcLock);
                    _enable();
                    (DeferredRoutine)(Dpc,
                                      DeferredContext,
                                      SystemArgument1,
                                      SystemArgument2);

                    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

                    _disable();

                } else {

                    ASSERT(Prcb->DpcQueueDepth == 0);

                    KeReleaseSpinLockFromDpcLevel(&Prcb->DpcLock);
                }

            } while (ListHead != *((PLIST_ENTRY volatile *)&ListHead->Flink));
        }

        Prcb->DpcRoutineActive = FALSE;
        Prcb->DpcInterruptRequested = FALSE;
    } while (ListHead != *((PLIST_ENTRY volatile *)&ListHead->Flink));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\cpuid.asm ===
title  "Processor Type and Stepping Detection"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the code necessary to determine cpu information.
;
; Author:
;
;    David N. Cutler (davec) 10-Jun-2000
;
; Environment:
;
;    Kernel mode only.
;
;--

include ksamd64.inc

;++
;
; VOID
; KiCpuId (
;     ULONG Function,
;     PCPU_INFO CpuInfo
;     );
;
; Routine Description:
;
;   Executes the cpuid instruction and returns the resultant register
;   values.
;
; Arguments:
;
;   ecx - Supplies the cpuid function value.
;
;   rdx - Supplies the address a cpu information structure.
;
; Return Value:
;
;   The return values from the cpuid instruction are stored in the specified
;   cpu infomation structure.
;
;--

CiFrame struct
        SavedRbx dq ?                   ; saved register RBX
CiFrame ends

        NESTED_ENTRY KiCpuId, _TEXT$00

        push_reg rbx                    ; save nonvolatile register

        END_PROLOGUE

        mov     eax, ecx                ; set cpuid function
        mov     r9, rdx                 ; save information structure address
        cpuid                           ; get cpu information
        mov     CpuEax[r9], eax         ; save cpu information in structure
        mov     CpuEbx[r9], ebx         ;
        mov     CpuEcx[r9], ecx         ;
        mov     CpuEdx[r9], edx         ;
        pop     rbx                     ; restore nonvolatile registeer
        ret                             ; return

        NESTED_END KiCpuId, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\idle.asm ===
title  "Idle Loop"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   idle.asm
;
; Abstract:
;
;   This module implements the platform specifid idle loop.
;
; Author:
;
;   David N. Cutler (davec) 21-Sep-2000
;
; Environment:
;
;    Kernel mode only.
;
;--

include ksamd64.inc

        extern  KdDebuggerEnabled:byte
        extern  KeAcquireQueuedSpinLockAtDpcLevel:proc
        extern  KeAcquireQueuedSpinLockRaiseToSynch:proc
        extern  KeReleaseQueuedSpinLock:proc
        extern  KeReleaseQueuedSpinLockFromDpcLevel:proc
        extern  KiCheckBreakInRequest:proc
        extern  KiIdleSummary:qword
        extern  KiRetireDpcList:proc
        extern  SwapContext:proc
        extern  __imp_HalClearSoftwareInterrupt:qword

        subttl  "Idle Loop"
;++
; VOID
; KiIdleLoop (
;     VOID
;     )
;
; Routine Description:
;
;    This routine continuously executes the idle loop and never returns.
;
; Arguments:
;
;    None.
;
; Return value:
;
;    This routine never returns.
;
;--

IlFrame struct
        Fill    dq ?                    ; fill to 8 mod 16
IlFrame ends

        NESTED_ENTRY KiIdleLoop, _TEXT$00

        alloc_stack (sizeof IlFrame)    ; allocate stack frame

        END_PROLOGUE

        mov     rbx, gs:[PcCurrentPrcb] ; get current processor block address
        xor     edi, edi                ; reset check breakin counter
        jmp     short KiIL20            ; skip idle processor on first iteration

;
; There are no entries in the DPC list and a thread has not been selected
; for execution on this processor. Call the HAL so power managment can be
; performed.
;
; N.B. The HAL is called with interrupts disabled. The HAL will return
;      with interrupts enabled.
;

KiIL10: lea     rcx, PbPowerState[rbx]  ; set address of power state
        call    qword ptr PpIdleFunction[rcx] ; call idle function

;
; Give the debugger an opportunity to gain control if the kernel debuggger
; is enabled.
;
; N.B. On an MP system the lowest numbered idle processor is the only
;      processor that checks for a breakin request.
;

KiIL20: cmp     KdDebuggerEnabled, 0    ; check if a debugger is enabled
        je      short CheckDpcList      ; if e, debugger not enabled

ifndef NT_UP

        mov     rax, KiIdleSummary      ; get idle summary
        mov     rcx, PbSetMember[rbx]   ; get set member
        dec     rcx                     ; compute right bit mask
        and     rax, rcx                ; check if any lower bits set
        jnz     short CheckDpcList      ; if nz, not lowest numbered

endif

        dec     edi                     ; decrement check breakin counter
        jg      short CheckDpcList      ; if g, not time to check for breakin
        call    KiCheckBreakInRequest   ; check if break in requested
        mov     edi, 1000               ; set check breakin interval

;
; Disable interrupts and check if there is any work in the DPC list of the
; current processor or a target processor.
;
; N.B. The following code enables interrupts for a few cycles, then disables
;      them again for the subsequent DPC and next thread checks.
;

CheckDpcList:                           ; reference label
        sti                             ; enable interrupts
        nop                             ;
        nop                             ;
        cli                             ; disable interrupts

;
; Process the deferred procedure call list for the current processor.
;

        mov     eax, PbDpcQueueDepth[rbx] ; get DPC queue depth
        or      eax, PbTimerHand[rbx]   ; merge timer hand value
        jz      short CheckNextThread   ; if z, no DPCs to process
        mov     cl, DISPATCH_LEVEL      ; set interrupt level
        call    __imp_HalClearSoftwareInterrupt ; clear software interrupt
        mov     rcx, rbx                ; set processor block address
        call    KiRetireDpcList         ; process the current DPC list
        xor     edi, edi                ; clear check breakin interval

;
; Check if a thread has been selected to run on the current processor.
;

CheckNextThread:                        ;
        cmp     qword ptr PbNextThread[rbx], 0 ; check if thread slected
        je      short KiIL10            ; if e, no thread selected

;
; A thread has been selected for execution on this processor. Acquire the
; context swap lock, get the thread address again (it may have changed),
; and test whether a swap from idle is blocked for the specified thread.
; If swap from idle is blocked, then release the context swap lock and loop.
; Otherwise, clear the address of the next thread in the processor block
; and call swap context to start execution of the selected thread.
;

        sti                             ; enable interrupts

ifndef NT_UP

        mov     ecx, LockQueueContextSwapLock ; set queued spin lock number
        call    KeAcquireQueuedSpinLockRaiseToSynch ; acquire queued spin lock

endif

        mov     rsi, PbNextThread[rbx]  ; set next thread address
        mov     rdi, PbCurrentThread[rbx] ; get current thread address

ifndef NT_UP

        cmp     byte ptr ThIdleSwapBlock[rsi], 0 ; check if swap from idle blocked
        jne     short KiIL40            ; if ne, swap from idle blocked
        cmp     rsi, rdi                ; check if swap from idle to idle
        je      short KiIL60            ; if eq, idle to idle

endif

        mov     qword ptr PbNextThread[rbx], 0 ; clear next thread address
        mov     PbCurrentThread[rbx], rsi ; set current thread address
        mov     cl, APC_LEVEL           ; set APC interrupt bypass disable

ifndef NT_UP

        mov     edx, 1                  ; set swap from idle true

endif

        call    SwapContext             ; swap context to next thread

ifndef NT_UP

        mov     ecx, DISPATCH_LEVEL     ; set IRQL to dispatch level

        SetIrql                         ;

endif

        xor     edi, edi                ; clear check breakin interval
        jmp     KiIL20                  ; loop

;
; Swap from idle is blocked while the specified thread clears the context
; code. Release the context swap lock and try again.
;

ifndef NT_UP

KiIL40: mov     ecx, LockQueueContextSwapLock ; set queued spin lock number
        mov     dl, DISPATCH_LEVEL      ; set previous IRQL to dispatch level
        call    KeReleaseQueuedSpinLock ; release context swap lock
        jmp     KiIL20                  ; loop


;
; Under rare conditions, a thread can have been scheduled on this processor
; and subsequently made inelligible to run via a call to set affinity. If no
; other thread was available to run at the time of the call to set affinity,
; then the idle thread will have been rescheduled and this processor marked
; idle. If a new thread becomes available to run on this processor, then the
; net thread field in the prcoessr block may be unconditionally written.
;
; Protect clearing the next thread field by obtaining the dispatcher lock. If
; the next thread filed is no longer the idle thread, then a new thread has
; been scheduled for this processor and the next thread field must not be
; cleared.
;

KiIL60: lea     rcx, PbLockQueue + (16 * LockQueueContextSwapLock)[rbx] ; release
        call    KeReleaseQueuedSpinLockFromDpcLevel ;  the context swap lock
        lea     rcx, PbLockQueue + (16 * LockQueueDispatcherLock)[rbx] ; acquire
        call    KeAcquireQueuedSpinLockAtDpcLevel ;  the dispatcher lock
        cmp     rsi, PbNextThread[rbx]  ; check if the target thread still idle
        jne     short KiIL65            ; if ne, not idle thread
        mov     qword ptr PbNextThread[rbx], 0 ; clear next thread address
KiIL65: mov     ecx, LockQueueDispatcherLock ; set lock queue number
        mov     dl, DISPATCH_LEVEL      ; set previous IRQL
        call    KeReleaseQueuedSpinLock ; release dispatcher lock
        jmp     KiIL20                  ; loop

endif

        NESTED_END KiIdleLoop, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\exceptn.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    exceptn.c

Abstract:

    This module implement the code necessary to dispatch expections to the
    proper mode and invoke the exception dispatcher.

Author:

    David N. Cutler (davec) 5-May-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
KeContextFromKframes (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN OUT PCONTEXT ContextRecord
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified trap and
    exception frames into the specified context frame according to the
    specified context flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile
        context should be copied into the context record.

    ExceptionFrame - Supplies a pointer to an exception frame from which
        context should be copied into the context record.

    ContextRecord - Supplies a pointer to the context frame that receives
        the context copied from the trap and exception frames.

Return Value:

    None.

--*/

{

    ULONG ContextFlags;
    PLEGACY_SAVE_AREA NpxFrame;

    //
    // Set control information if specified.
    //

    ContextFlags = ContextRecord->ContextFlags;
    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set registers RIP, CS, RSP, SS, and EFlags.
        //

        ContextRecord->Rip = TrapFrame->Rip;
        ContextRecord->SegCs = TrapFrame->SegCs;
        ContextRecord->SegSs = TrapFrame->SegSs;
        ContextRecord->Rsp = TrapFrame->Rsp;
        ContextRecord->EFlags = TrapFrame->EFlags;
    }

    //
    // Set segment register contents if specified.
    //

    if ((ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS) {

        //
        // Set segment registers GS, FS, ES, DS.
        //

        ContextRecord->SegDs = KGDT64_R3_DATA | RPL_MASK;
        ContextRecord->SegEs = KGDT64_R3_DATA | RPL_MASK;
        ContextRecord->SegFs = KGDT64_R3_CMTEB | RPL_MASK;
        ContextRecord->SegGs = KGDT64_R3_DATA | RPL_MASK;
    }

    //
    // Set integer register contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers RAX, RCX, RDX, RSI, RDI, R8, R9, R10, RBX,
        // RBP, R11, R12, R13, R14, and R15.
        //

        ContextRecord->Rax = TrapFrame->Rax;
        ContextRecord->Rcx = TrapFrame->Rcx;
        ContextRecord->Rdx = TrapFrame->Rdx;
        ContextRecord->R8 = TrapFrame->R8;
        ContextRecord->R9 = TrapFrame->R9;
        ContextRecord->R10 = TrapFrame->R10;
        ContextRecord->R11 = TrapFrame->R11;
        ContextRecord->Rbp = TrapFrame->Rbp;

        ContextRecord->Rbx = ExceptionFrame->Rbx;
        ContextRecord->Rdi = ExceptionFrame->Rdi;
        ContextRecord->Rsi = ExceptionFrame->Rsi;
        ContextRecord->R12 = ExceptionFrame->R12;
        ContextRecord->R13 = ExceptionFrame->R13;
        ContextRecord->R14 = ExceptionFrame->R14;
        ContextRecord->R15 = ExceptionFrame->R15;
    }

    //
    // Set floating point context if specified.
    //
    //

    if ((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {

        //
        // Set XMM registers Xmm0-Xmm15 and the XMM CSR contents.
        //

        RtlCopyMemory(&ContextRecord->Xmm0,
                      &TrapFrame->Xmm0,
                      sizeof(M128) * 6);

        RtlCopyMemory(&ContextRecord->Xmm6,
                      &ExceptionFrame->Xmm6,
                      sizeof(M128) * 10);

        ContextRecord->MxCsr = TrapFrame->MxCsr;

        //
        // If the specified mode is user, then set the legacy floating
        // point state.
        //

        if ((TrapFrame->SegCs & MODE_MASK) == UserMode) {

            //
            // Set the floating registers MM0/ST0 - MM7/ST7 and control state.
            //

            NpxFrame = (PLEGACY_SAVE_AREA)(TrapFrame + 1);
            RtlCopyMemory(&ContextRecord->FltSave,
                          NpxFrame,
                          sizeof(LEGACY_SAVE_AREA));
        }
    }

    //
    //
    // Set debug register contents if requested.
    //

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {

        //
        // Set the debug registers DR0, DR1, DR2, DR3, DR6, and DR7.
        //

        ContextRecord->Dr0 = TrapFrame->Dr0;
        ContextRecord->Dr1 = TrapFrame->Dr1;
        ContextRecord->Dr2 = TrapFrame->Dr2;
        ContextRecord->Dr3 = TrapFrame->Dr3;
        ContextRecord->Dr6 = TrapFrame->Dr6;
        ContextRecord->Dr7 = TrapFrame->Dr7;
    }

    return;
}

VOID
KeContextToKframes (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextRecord,
    IN ULONG ContextFlags,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified context frame
    into the specified trap and exception frames according to the specified
    context flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that receives the volatile
        context from the context record.

    ExceptionFrame - Supplies a pointer to an exception frame that receives
        the nonvolatile context from the context record.

    ContextRecord - Supplies a pointer to a context frame that contains the
        context that is to be copied into the trap and exception frames.

    ContextFlags - Supplies the set of flags that specify which parts of the
        context frame are to be copied into the trap and exception frames.

    PreviousMode - Supplies the processor mode for which the exception and
        trap frames are being built.

Return Value:

    None.

--*/

{

    PLEGACY_SAVE_AREA NpxFrame;

    //
    // Set control information if specified.
    //

    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set registers RIP, RSP, and EFlags.
        //

        TrapFrame->EFlags = SANITIZE_EFLAGS(ContextRecord->EFlags, PreviousMode);
        TrapFrame->Rip = ContextRecord->Rip;
        TrapFrame->Rsp = ContextRecord->Rsp;
    }

    //
    // The segment registers DS, ES, FS, and GS are never restored from saved
    // data. However, SS and CS are restored from the trap frame. Make sure
    // that these segment registers have the proper values.
    //

    if (PreviousMode == UserMode) {
        TrapFrame->SegSs = KGDT64_R3_DATA | RPL_MASK;
        if (ContextRecord->SegCs != (KGDT64_R3_CODE | RPL_MASK)) {
            TrapFrame->SegCs = KGDT64_R3_CMCODE | RPL_MASK;

        } else {
            TrapFrame->SegCs = KGDT64_R3_CODE | RPL_MASK;
        }

    } else {
        TrapFrame->SegCs = KGDT64_R0_CODE;
        TrapFrame->SegSs = KGDT64_NULL;
    }

    //
    // Set integer registers contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers RAX, RCX, RDX, RSI, RDI, R8, R9, R10, RBX,
        // RBP, R11, R12, R13, R14, and R15.
        //

        TrapFrame->Rax = ContextRecord->Rax;
        TrapFrame->Rcx = ContextRecord->Rcx;
        TrapFrame->Rdx = ContextRecord->Rdx;
        TrapFrame->R8 = ContextRecord->R8;
        TrapFrame->R9 = ContextRecord->R9;
        TrapFrame->R10 = ContextRecord->R10;
        TrapFrame->R11 = ContextRecord->R11;
        TrapFrame->Rbp = ContextRecord->Rbp;

        ExceptionFrame->Rbx = ContextRecord->Rbx;
        ExceptionFrame->Rsi = ContextRecord->Rsi;
        ExceptionFrame->Rdi = ContextRecord->Rdi;
        ExceptionFrame->R12 = ContextRecord->R12;
        ExceptionFrame->R13 = ContextRecord->R13;
        ExceptionFrame->R14 = ContextRecord->R14;
        ExceptionFrame->R15 = ContextRecord->R15;
    }

    //
    // Set floating register contents if requested.
    //

    if ((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) {

        //
        // Set XMM registers Xmm0-Xmm15 and the XMM CSR contents.
        //

        RtlCopyMemory(&TrapFrame->Xmm0,
                      &ContextRecord->Xmm0,
                      sizeof(M128) * 6);

        RtlCopyMemory(&ExceptionFrame->Xmm6,
                      &ContextRecord->Xmm6,
                      sizeof(M128) * 10);

        //
        // Clear all reserved bits in MXCSR.
        //

        TrapFrame->MxCsr = SANITIZE_MXCSR(ContextRecord->MxCsr);

        //
        // If the specified mode is user, then also set the legacy floating
        // point state.
        //

        if ((TrapFrame->SegCs & MODE_MASK) == UserMode) {

            //
            // Set the floating state MM0/ST0 - MM7/ST7 and the control state.
            //

            NpxFrame = (PLEGACY_SAVE_AREA)(TrapFrame + 1);
            RtlCopyMemory(NpxFrame,
                          &ContextRecord->FltSave,
                          sizeof(LEGACY_SAVE_AREA));

            NpxFrame->ControlWord = SANITIZE_FCW(NpxFrame->ControlWord);
        }
    }

    //
    // Set debug register state if specified.
    //

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {

        //
        // Set the debug registers DR0, DR1, DR2, DR3, DR6, and DR7.
        //

        TrapFrame->Dr0 = SANITIZE_DRADDR(ContextRecord->Dr0, PreviousMode);
        TrapFrame->Dr1 = SANITIZE_DRADDR(ContextRecord->Dr1, PreviousMode);
        TrapFrame->Dr2 = SANITIZE_DRADDR(ContextRecord->Dr2, PreviousMode);
        TrapFrame->Dr3 = SANITIZE_DRADDR(ContextRecord->Dr3, PreviousMode);
        TrapFrame->Dr6 = 0;
        TrapFrame->Dr7 = SANITIZE_DR7(ContextRecord->Dr7, PreviousMode);
    }

    return;
}

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to dispatch an exception to the proper mode and
    to cause the exception dispatcher to be called. If the previous mode is
    kernel, then the exception dispatcher is called directly to process the
    exception. Otherwise the exception record, exception frame, and trap
    frame contents are copied to the user mode stack. The contents of the
    exception frame and trap are then modified such that when control is
    returned, execution will commense in user mode in a routine which will
    call the exception dispatcher.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame. For NT386,
        this should be NULL.

    TrapFrame - Supplies a pointer to a trap frame.

    PreviousMode - Supplies the previous processor mode.

    FirstChance - Supplies a boolean value that specifies whether this is
        the first (TRUE) or second (FALSE) chance for the exception.

Return Value:

    None.

--*/

{

    CONTEXT ContextRecord;
    EXCEPTION_RECORD ExceptionRecord1;
    BOOLEAN ExceptionWasForwarded = FALSE;
    PMACHINE_FRAME MachineFrame;
    PKPROCESS Process;
    PKTHREAD Thread;
    ULONG64 UserStack1;
    ULONG64 UserStack2;

    //
    // If the exception is a data misalignment, the previous mode was user,
    // this is the first chance for handling the exception, and the current
    // thread has enabled automatic alignment fixup, then attempt to emulate
    // the unaligned reference.
    //

    if (ExceptionRecord->ExceptionCode == STATUS_DATATYPE_MISALIGNMENT) {
        if (KiHandleAlignmentFault(ExceptionRecord,
                                   ExceptionFrame,
                                   TrapFrame,
                                   PreviousMode,
                                   FirstChance,
                                   &ExceptionWasForwarded) != FALSE ) {

            goto Handled2;
        }
    }

    //
    // Move machine state from trap and exception frames to a context frame
    // and increment the number of exceptions dispatched.
    //

    KeGetCurrentPrcb()->KeExceptionDispatchCount += 1;
    ContextRecord.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
    KeContextFromKframes(TrapFrame, ExceptionFrame, &ContextRecord);

    //
    // If the exception is a break point, then convert the break point to a
    // fault.
    //

    if (ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) {
        ContextRecord.Rip -= 1;
    }

    //
    // Select the method of handling the exception based on the previous mode.
    //

    if (PreviousMode == KernelMode) {

        //
        // Previous mode was kernel.
        //
        // If the kernel debugger is active, then give the kernel debugger
        // the first chance to handle the exception. If the kernel debugger
        // handles the exception, then continue execution. Otherwise, attempt
        // to dispatch the exception to a frame based handler. If a frame
        // based handler handles the exception, then continue execution.
        //
        // If a frame based handler does not handle the exception, give the
        // kernel debugger a second chance, if it's present.
        //
        // If the exception is still unhandled call bugcheck.
        //

        if (FirstChance != FALSE) {
            if ((KiDebugRoutine != NULL) &&
               (((KiDebugRoutine)(TrapFrame,
                                  ExceptionFrame,
                                  ExceptionRecord,
                                  &ContextRecord,
                                  PreviousMode,
                                  FALSE)) != FALSE)) {

                goto Handled1;
            }

            //
            // Kernel debugger didn't handle exception.
            //
            // ******fix
            //
            // If interrupts are disabled, then bugcheck.
            //
            // ******fix

            if (RtlDispatchException(ExceptionRecord, &ContextRecord) != FALSE) {
                goto Handled1;
            }
        }

        //
        // This is the second chance to handle the exception.
        //

        if ((KiDebugRoutine != NULL) &&
            (((KiDebugRoutine)(TrapFrame,
                               ExceptionFrame,
                               ExceptionRecord,
                               &ContextRecord,
                               PreviousMode,
                               TRUE)) != FALSE)) {

            goto Handled1;
        }

        KeBugCheckEx(KMODE_EXCEPTION_NOT_HANDLED,
                     ExceptionRecord->ExceptionCode,
                     (ULONG64)ExceptionRecord->ExceptionAddress,
                     ExceptionRecord->ExceptionInformation[0],
                     ExceptionRecord->ExceptionInformation[1]);

    } else {

        //
        // Previous mode was user.
        //
        // If this is the first chance and the current process has a debugger
        // port, then send a message to the debugger port and wait for a reply.
        // If the debugger handles the exception, then continue execution. Else
        // transfer the exception information to the user stack, transition to
        // user mode, and attempt to dispatch the exception to a frame based
        // handler. If a frame based handler handles the exception, then continue
        // execution with the continue system service. Else execute the
        // NtRaiseException system service with FirstChance == FALSE, which
        // will call this routine a second time to process the exception.
        //
        // If this is the second chance and the current process has a debugger
        // port, then send a message to the debugger port and wait for a reply.
        // If the debugger handles the exception, then continue execution. Else
        // if the current process has a subsystem port, then send a message to
        // the subsystem port and wait for a reply. If the subsystem handles the
        // exception, then continue execution. Else terminate the thread.
        //

        if (FirstChance == TRUE) {

            //
            // This is the first chance to handle the exception.
            //

            if (PsGetCurrentProcess()->DebugPort != NULL) {
                if ((KiDebugRoutine != NULL) &&
                    (KdIsThisAKdTrap(ExceptionRecord, &ContextRecord, UserMode) != FALSE)) {
                    if ((((KiDebugRoutine)(TrapFrame,
                                           ExceptionFrame,
                                           ExceptionRecord,
                                           &ContextRecord,
                                           PreviousMode,
                                           FALSE)) != FALSE)) {

                        goto Handled1;
                    }
                }

            } else {
                if ((KiDebugRoutine != NULL) &&
                    (((KiDebugRoutine)(TrapFrame,
                                       ExceptionFrame,
                                       ExceptionRecord,
                                       &ContextRecord,
                                       PreviousMode,
                                       FALSE)) != FALSE)) {

                    goto Handled1;
                }
            }

            if ((ExceptionWasForwarded == FALSE) &&
                (DbgkForwardException(ExceptionRecord, TRUE, FALSE))) {

                goto Handled2;
            }

            //
            // If the user mode thread is executing in 32-bit mode, then
            // clear the upper 32-bits of the stack address since they
            // may contain garbage.
            //

            if ((ContextRecord.SegCs & 0xfff8) == KGDT64_R3_CMCODE) {
                ContextRecord.Rsp &= 0xffffffff;
            }

            //
            // Transfer exception information to the user stack, transition
            // to user mode, and attempt to dispatch the exception to a frame
            // based handler.
            //

        repeat:
            try {

                //
                // Compute address of aligned machine frame, compute address
                // of exception record, compute address of context record,
                // and probe user stack for writeability.
                //

                MachineFrame =
                    (PMACHINE_FRAME)((ContextRecord.Rsp - sizeof(MACHINE_FRAME)) & ~STACK_ROUND);

                UserStack1 = (ULONG64)MachineFrame - EXCEPTION_RECORD_LENGTH;
                UserStack2 = UserStack1 - CONTEXT_LENGTH;
                ProbeForWriteSmallStructure((PVOID)UserStack2,
                                            sizeof(MACHINE_FRAME) + EXCEPTION_RECORD_LENGTH + CONTEXT_LENGTH,
                                            STACK_ALIGN);

                //
                // Fill in machine frame information.
                //

                MachineFrame->Rsp = ContextRecord.Rsp;
                MachineFrame->Rip = ContextRecord.Rip;

                //
                // Copy exception record to the user stack.
                //

                RtlCopyMemory((PVOID)UserStack1,
                              ExceptionRecord,
                              sizeof(EXCEPTION_RECORD));

                //
                // Copy context record to the user stack.
                //

                RtlCopyMemory((PVOID)UserStack2,
                              &ContextRecord,
                              sizeof(CONTEXT));

                //
                // Set address of exception record, context record, and the
                // and the new stack pointer in the current trap frame.
                //

                ExceptionFrame->Rsi = UserStack1;
                ExceptionFrame->Rdi = UserStack2;
                TrapFrame->Rsp = UserStack2;

                //
                // Set the user mode 64-bit code selector.
                //

                TrapFrame->SegCs = KGDT64_R3_CODE | RPL_MASK;

                //
                // Set the address of the exception routine that will call the
                // exception dispatcher and then return to the trap handler.
                // The trap handler will restore the exception and trap frame
                // context and continue execution in the routine that will
                // call the exception dispatcher.
                //

                TrapFrame->Rip = (ULONG64)KeUserExceptionDispatcher;
                return;

            } except (KiCopyInformation(&ExceptionRecord1,
                        (GetExceptionInformation())->ExceptionRecord)) {

                //
                // If the exception is a stack overflow, then attempt to
                // raise the stack overflow exception. Otherwise, the user's
                // stack is not accessible, or is misaligned, and second
                // chance processing is performed.
                //

                if (ExceptionRecord1.ExceptionCode == STATUS_STACK_OVERFLOW) {
                    ExceptionRecord1.ExceptionAddress = ExceptionRecord->ExceptionAddress;
                    RtlCopyMemory((PVOID)ExceptionRecord,
                                  &ExceptionRecord1,
                                  sizeof(EXCEPTION_RECORD));

                    goto repeat;
                }
            }
        }

        //
        // This is the second chance to handle the exception.
        //

        if (DbgkForwardException(ExceptionRecord, TRUE, TRUE)) {
            goto Handled2;

        } else if (DbgkForwardException(ExceptionRecord, FALSE, TRUE)) {
            goto Handled2;

        } else {
            ZwTerminateThread(NtCurrentThread(), ExceptionRecord->ExceptionCode);
            KeBugCheckEx(KMODE_EXCEPTION_NOT_HANDLED,
                         ExceptionRecord->ExceptionCode,
                         (ULONG64)ExceptionRecord->ExceptionAddress,
                         ExceptionRecord->ExceptionInformation[0],
                         ExceptionRecord->ExceptionInformation[1]);
        }
    }

    //
    // Move machine state from context frame to trap and exception frames and
    // then return to continue execution with the restored state.
    //

Handled1:
    KeContextToKframes(TrapFrame,
                       ExceptionFrame,
                       &ContextRecord,
                       ContextRecord.ContextFlags,
                       PreviousMode);

    //
    // Exception was handled by the debugger or the associated subsystem
    // and state was modified, if necessary, using the get state and set
    // state capabilities. Therefore the context frame does not need to
    // be transfered to the trap and exception frames.
    //

Handled2:
    return;
}

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    )

/*++

Routine Description:

    This function is called from an exception filter to copy the exception
    information from one exception record to another when an exception occurs.

Arguments:

    ExceptionRecord1 - Supplies a pointer to the destination exception record.

    ExceptionRecord2 - Supplies a pointer to the source exception record.

Return Value:

    A value of EXCEPTION_EXECUTE_HANDLER is returned as the function value.

--*/

{

    //
    // Copy one exception record to another and return value that causes
    // an exception handler to be executed.
    //

    RtlCopyMemory((PVOID)ExceptionRecord1,
                  (PVOID)ExceptionRecord2,
                  sizeof(EXCEPTION_RECORD));

    return EXCEPTION_EXECUTE_HANDLER;
}

NTSTATUS
KeRaiseUserException (
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This function causes an exception to be raised in the calling thread's
    user context.

Arguments:

    ExceptionCode - Supplies the status value to be raised.

Return Value:

    The status value that should be returned by the caller.

--*/

{

    PTEB Teb;
    PKTHREAD Thread;
    PKTRAP_FRAME TrapFrame;

    ASSERT(KeGetPreviousMode() == UserMode);

    //
    // Save the exception code in the TEB and set the return address in the
    // trap frame to return to the raise user exception code in user mode.
    // This replaces the normal return which would go to the system service
    // dispatch stub. The system service dispatch stub is called thus the
    // return to the system service call site is on the top of the user stack.
    //

    Thread = KeGetCurrentThread();
    TrapFrame = Thread->TrapFrame;
    if (TrapFrame != NULL) {
        Teb = (PTEB)Thread->Teb;
        try {
            Teb->ExceptionCode = ExceptionCode;
    
        } except (EXCEPTION_EXECUTE_HANDLER) {
            return ExceptionCode;
        }

        TrapFrame->Rip = (ULONG64)KeRaiseUserExceptionDispatcher;
    }

    return ExceptionCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\flush.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    flush.c

Abstract:

    This module implements AMD64 machine dependent kernel functions to
    flush the data and instruction caches on all processors.

Author:

    David N. Cutler (davec) 22-Apr-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Define prototypes for forward referenced functions.
//

VOID
KiInvalidateAllCachesTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

BOOLEAN
KeInvalidateAllCaches (
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function writes back and invalidates the cache on all processors
    that are currently running threads which are children of the current
    process or on all processors in the host configuration.

Arguments:

    AllProcessors - Supplies a boolean value that determines which data
        caches are flushed.

Return Value:

    TRUE is returned as the function value.

--*/

{

    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;

    //
    // Compute the target set of processors, disable context switching,
    // and send the writeback invalidate all to the target processors,
    // if any, for execution.
    //

#if !defined(NT_UP)

    if (AllProcessors != FALSE) {
        OldIrql = KeRaiseIrqlToSynchLevel();
        Prcb = KeGetCurrentPrcb();
        TargetProcessors = KeActiveProcessors;

    } else {
        KiLockContextSwap(&OldIrql);
        Prcb = KeGetCurrentPrcb();
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    //
    // Send packet to target processors.
    //

    TargetProcessors &= Prcb->NotSetMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiInvalidateAllCachesTarget,
                        NULL,
                        NULL,
                        NULL);
    }

#endif

    //
    // Invalidate cache on current processor.
    //

    WritebackInvalidate();

    //
    // Wait until all target processors have finished and complete packet.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Lower IRQL and unlock as appropriate.
    //

    if (AllProcessors != FALSE) {
        KeLowerIrql(OldIrql);

    } else {
        KiUnlockContextSwap(OldIrql);
    }

#endif

    return TRUE;
}

#if !defined(NT_UP)

VOID
KiInvalidateAllCachesTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for writeback invalidating the cache on
    target processors.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Parameter2 - Parameter3 - not used.

Return Value:

    None.

--*/

{

    //
    // Write back invalidate current cache.
    //

    KiIpiSignalPacketDone(SignalDone);
    WritebackInvalidate();
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\initkr.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    initkr.c

Abstract:

    This module contains the code to initialize the kernel data structures
    and to initialize the idle thread, its process, the processor control
    block, and the processor control region.

Author:

    David N. Cutler (davec) 22-Apr-2000

Environment:

    Kernel mode only.

--*/

#include "ki.h"

//
// Define default profile IRQL level.
//

KIRQL KiProfileIrql = PROFILE_LEVEL;

//
// Define the process and thread for the initial system process and startup
// thread.
//

EPROCESS KiInitialProcess;
ETHREAD KiInitialThread;

//
// Define macro to initialize an IDT entry.
//
// KiInitializeIdtEntry (
//     IN PKIDTENTRY64 Entry,
//     IN PVOID Address,
//     IN USHORT Level
//     )
//
// Arguments:
//
//     Entry - Supplies a pointer to an IDT entry.
//
//     Address - Supplies the address of the vector routine.
//
//     Dpl - Descriptor privilege level.
//
//     Ist - Interrupt stack index.
//

#define KiInitializeIdtEntry(Entry, Address, Level, Index)                  \
    (Entry)->OffsetLow = (USHORT)((ULONG64)(Address));                      \
    (Entry)->Selector = KGDT64_R0_CODE;                                     \
    (Entry)->IstIndex = Index;                                              \
    (Entry)->Type = 0xe;                                                    \
    (Entry)->Dpl = (Level);                                                 \
    (Entry)->Present = 1;                                                   \
    (Entry)->OffsetMiddle = (USHORT)((ULONG64)(Address) >> 16);             \
    (Entry)->OffsetHigh = (ULONG)((ULONG64)(Address) >> 32)                 \

//
// Define forward referenced prototypes.
//

ULONG
KiFatalFilter (
    IN ULONG Code,
    IN PEXCEPTION_POINTERS Pointers
    );

VOID
KiSetCacheInformation (
    VOID
    );

VOID
KiSetCpuVendor (
    VOID
    );

VOID
KiSetFeatureBits (
    VOID
    );

VOID
KiSetProcessorType (
    VOID
    );

#pragma alloc_text(INIT, KiFatalFilter)
#pragma alloc_text(INIT, KiInitializeBootStructures)
#pragma alloc_text(INIT, KiInitializeKernel)
#pragma alloc_text(INIT, KiInitMachineDependent)
#pragma alloc_text(INIT, KiSetCacheInformation)
#pragma alloc_text(INIT, KiSetCpuVendor)
#pragma alloc_text(INIT, KiSetFeatureBits)
#pragma alloc_text(INIT, KiSetProcessorType)

VOID
KiInitializeKernel (
    IN PKPROCESS Process,
    IN PKTHREAD Thread,
    IN PVOID IdleStack,
    IN PKPRCB Prcb,
    IN CCHAR Number,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function gains control after the system has been booted, but before
    the system has been completely initialized. Its function is to initialize
    the kernel data structures, initialize the idle thread and process objects,
    complete the initialization of the processor control block (PRCB) and
    processor control region (PCR), call the executive initialization routine,
    then return to the system startup routine. This routine is also called to
    initialize the processor specific structures when a new processor is
    brought on line.

Arguments:

    Process - Supplies a pointer to a control object of type process for
        the specified processor.

    Thread - Supplies a pointer to a dispatcher object of type thread for
        the specified processor.

    IdleStack - Supplies a pointer the base of the real kernel stack for
        idle thread on the specified processor.

    Prcb - Supplies a pointer to a processor control block for the specified
        processor.

    Number - Supplies the number of the processor that is being
        initialized.

    LoaderBlock - Supplies a pointer to the loader parameter block.

Return Value:

    None.

--*/

{

    ULONG FeatureBits;
    LONG  Index;
    ULONG64 DirectoryTableBase[2];
    KIRQL OldIrql;
    PKPCR Pcr = KeGetPcr();

    //
    // Set CPU vendor.
    //

    KiSetCpuVendor();

    //
    // Set processor type.
    //

    KiSetProcessorType();

    //
    // Set the processor feature bits.
    //

    KiSetFeatureBits();
    FeatureBits = Prcb->FeatureBits;

    //
    // If this is the boot processor, then enable global pages, set the page
    // attributes table, set machine check enable, set large page enable, and
    // enable debug extensions.
    //
    // N.B. This only happens on the boot processor and at a time when there
    //      can be no coherency problem. On subsequent, processors this happens
    //      during the transistion into 64-bit mode which is also at a time
    //      that there can be no coherency problems.
    //

    if (Number == 0) {

        //
        // Flush the entire TB and enable global pages.
        //
    
        KeFlushCurrentTb();
    
        //
        // Set page attributes table and flush cache.
        //
    
        KiSetPageAttributesTable();
        WritebackInvalidate();

        //
        // Set machine check enable, large page enable, and debugger extensions.
        //

        WriteCR4(ReadCR4() | CR4_DE | CR4_MCE | CR4_PSE);

        //
        // Flush the entire TB.
        //

        KeFlushCurrentTb();
    }

    //
    // set processor cache size information.
    //

    KiSetCacheInformation();

    //
    // Initialize DPC listhead, spin lock, and queuing parameters.
    //

    InitializeListHead(&Prcb->DpcListHead);
    KeInitializeSpinLock(&Prcb->DpcLock);
    Prcb->MaximumDpcQueueDepth = KiMaximumDpcQueueDepth;
    Prcb->MinimumDpcRate = KiMinimumDpcRate;
    Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;

    //
    // Initialize power state information.
    //

    PoInitializePrcb(Prcb);

    //
    // initialize the per processor lock queue entry for implemented locks.
    //

    KiInitQueuedSpinLocks(Prcb, Number);

    //
    // If the initial processor is being initialized, then initialize the
    // per system data structures.
    //

    if (Number == 0) {

        //
        // Set default node until the node topology is available.
        //

        KeNodeBlock[0] = &KiNode0;

#if defined(KE_MULTINODE)

        for (Index = 1; Index < MAXIMUM_CCNUMA_NODES; Index += 1) {
            KeNodeBlock[Index] = &KiNodeInit[Index];
        }

#endif

        Prcb->ParentNode = KeNodeBlock[0];
        KeNodeBlock[0]->ProcessorMask = Prcb->SetMember;

        //
        // Set global architecture and feature information.
        //

        KeProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
        KeProcessorLevel = (USHORT)Prcb->CpuType;
        KeProcessorRevision = Prcb->CpuStep;
        KeFeatureBits = FeatureBits;

        //
        // Lower IRQL to APC level.
        //

        KeLowerIrql(APC_LEVEL);

        //
        // Initialize kernel internal spinlocks
        //

        KeInitializeSpinLock(&KiFreezeExecutionLock);

        //
        // Performance architecture independent initialization.
        //

        KiInitSystem();

        //
        // Initialize idle thread process object and then set:
        //
        //  1. the process quantum.
        //

        DirectoryTableBase[0] = 0;
        DirectoryTableBase[1] = 0;
        KeInitializeProcess(Process,
                            (KPRIORITY)0,
                            (KAFFINITY)(-1),
                            &DirectoryTableBase[0],
                            FALSE);

        Process->ThreadQuantum = MAXCHAR;

    } else {

        //
        // If the CPU feature bits are not identical, then bugcheck.
        //
        // N.B. This will probably need to be relaxed at some point.
        //

        if (FeatureBits != KeFeatureBits) {
            KeBugCheckEx(MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED,
                         (ULONG64)FeatureBits,
                         (ULONG64)KeFeatureBits,
                         0,
                         0);
        }

        //
        // Lower IRQL to DISPATCH level.
        //

        KeLowerIrql(DISPATCH_LEVEL);
    }

    //
    // Set global processor features.
    //

    SharedUserData->ProcessorFeatures[PF_COMPARE_EXCHANGE_DOUBLE] = TRUE;
    SharedUserData->ProcessorFeatures[PF_MMX_INSTRUCTIONS_AVAILABLE] = TRUE;
    SharedUserData->ProcessorFeatures[PF_XMMI_INSTRUCTIONS_AVAILABLE] = TRUE;
    SharedUserData->ProcessorFeatures[PF_3DNOW_INSTRUCTIONS_AVAILABLE] = TRUE;
    SharedUserData->ProcessorFeatures[PF_RDTSC_INSTRUCTION_AVAILABLE] = TRUE;
    SharedUserData->ProcessorFeatures[PF_PAE_ENABLED] = TRUE;
    SharedUserData->ProcessorFeatures[PF_XMMI64_INSTRUCTIONS_AVAILABLE] = TRUE;

    //
    // Initialize idle thread object and then set:
    //
    //      1. the next processor number to the specified processor.
    //      2. the thread priority to the highest possible value.
    //      3. the state of the thread to running.
    //      4. the thread affinity to the specified processor.
    //      5. the specified member in the process active processors set.
    //

    KeInitializeThread(Thread,
                       (PVOID)((ULONG64)IdleStack),
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       Process);

    Thread->NextProcessor = Number;
    Thread->Priority = HIGH_PRIORITY;
    Thread->State = Running;
    Thread->Affinity = AFFINITY_MASK(Number);
    Thread->WaitIrql = DISPATCH_LEVEL;
    Process->ActiveProcessors |= AFFINITY_MASK(Number);

    //
    // Call the executive initialization routine.
    //

    try {
        ExpInitializeExecutive(Number, LoaderBlock);

    } except(KiFatalFilter(GetExceptionCode(), GetExceptionInformation())) {
    }

    //
    // If the initial processor is being initialized, then compute the timer
    // table reciprocal value, reset the PRCB values for the controllable DPC
    // behavior in order to reflect any registry overrides, and initialize the
    // global unwind history table.
    //

    if (Number == 0) {
        KiTimeIncrementReciprocal = KiComputeReciprocal((LONG)KeMaximumIncrement,
                                                        &KiTimeIncrementShiftCount);

        Prcb->MaximumDpcQueueDepth = KiMaximumDpcQueueDepth;
        Prcb->MinimumDpcRate = KiMinimumDpcRate;
        Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;
        RtlInitializeHistoryTable();
    }

    //
    // Raise IRQL to dispatch level and eet the priority of the idle thread
    // to zero. This will have the effect of immediately causing the phase
    // one initialization thread to get scheduled for execution. The idle
    // thread priority is then set ot the lowest realtime priority.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    KeSetPriorityThread(Thread, 0);
    Thread->Priority = LOW_REALTIME_PRIORITY;

    //
    // Raise IRQL to highest level.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // If the current processor is a secondary processor and a thread has
    // not been selected for execution, then set the appropriate bit in the
    // idle summary.
    //

#if !defined(NT_UP)

    if ((Number != 0) && (Prcb->NextThread == NULL)) {
        KiIdleSummary |= AFFINITY_MASK(Number);
    }

#endif

    //
    // Signal that this processor has completed its initialization.
    //

    LoaderBlock->Prcb = (ULONG64)NULL;
    return;
}

VOID
KiInitializeBootStructures (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function initializes the boot structures for a processor. It is only
    called by the system start up code. Certain fields in the boot structures
    have already been initialized. In particular:

    The address and limit of the GDT and IDT in the PCR.

    The address of the system TSS in the PCR.

    The processor number in the PCR.

    The special registers in the PRCB.

    N.B. All uninitialized fields are zero.

Arguments:

    LoaderBlock - Supplies a pointer to the loader block that has been
        initialized for this processor.

Return Value:

    None.

--*/

{

    PKIDTENTRY64 IdtBase;
    ULONG Index;
    PKPCR Pcr = KeGetPcr();
    PKPRCB Prcb = KeGetCurrentPrcb();
    UCHAR Number;
    PKTHREAD Thread;
    PKTSS64 TssBase;

    //
    // Initialize the PCR major and minor version numbers.
    //

    Pcr->MajorVersion = PCR_MAJOR_VERSION;
    Pcr->MinorVersion = PCR_MINOR_VERSION;

    //
    // initialize the PRCB major and minor version numbers and build type.
    //

    Prcb->MajorVersion = PRCB_MAJOR_VERSION;
    Prcb->MinorVersion =  PRCB_MINOR_VERSION;
    Prcb->BuildType = 0;

#if DBG

    Prcb->BuildType |= PRCB_BUILD_DEBUG;

#endif

#if defined(NT_UP)

    Prcb->BuildType |= PRCB_BUILD_UNIPROCESSOR;

#endif

    //
    // Initialize the PRCR processor number and the PCR and PRCB set member.
    //

    Number = Pcr->Number;
    Prcb->Number = Number;
    Prcb->SetMember = AFFINITY_MASK(Number);
    Prcb->NotSetMember = ~Prcb->SetMember;

    //
    // If this is processor zero, then initialize the address of the system
    // process and initial thread.
    //

    if (Number == 0) {
        LoaderBlock->Process = (ULONG64)&KiInitialProcess;
        LoaderBlock->Thread = (ULONG64)&KiInitialThread;
    }

    //
    // Initialize the PRCB scheduling thread address and the thread process
    // address.
    //

    Thread = (PVOID)LoaderBlock->Thread;
    Prcb->CurrentThread = Thread;
    Prcb->NextThread = NULL;
    Prcb->IdleThread = Thread;
    Thread->ApcState.Process = (PKPROCESS)LoaderBlock->Process;

    //
    // Initialize the processor block address.
    //

    KiProcessorBlock[Number] = Prcb;

    //
    // Initialize the PRCB address of the DPC stack.
    //

    Prcb->DpcStack = (PVOID)LoaderBlock->KernelStack;

    //
    // Initialize the PRCB symmetric multithreading member.
    //

    Prcb->MultiThreadProcessorSet = Prcb->SetMember;

    //
    // Initialize the IDT.
    //

    IdtBase = Pcr->IdtBase;
    KiInitializeIdtEntry(&IdtBase[0], &KiDivideErrorFault, 0, 0);
    KiInitializeIdtEntry(&IdtBase[1], &KiDebugTrapOrFault, 0, 0);
    KiInitializeIdtEntry(&IdtBase[2], &KiNmiInterrupt, 0, TSS_IST_PANIC);
    KiInitializeIdtEntry(&IdtBase[3], &KiBreakpointTrap, 3, 0);
    KiInitializeIdtEntry(&IdtBase[4], &KiOverflowTrap, 3, 0);
    KiInitializeIdtEntry(&IdtBase[5], &KiBoundFault, 0, 0);
    KiInitializeIdtEntry(&IdtBase[6], &KiInvalidOpcodeFault, 0, 0);
    KiInitializeIdtEntry(&IdtBase[7], &KiNpxNotAvailableFault, 0, 0);
    KiInitializeIdtEntry(&IdtBase[8], &KiDoubleFaultAbort, 0, TSS_IST_PANIC);
    KiInitializeIdtEntry(&IdtBase[9], &KiNpxSegmentOverrunAbort, 0, 0);
    KiInitializeIdtEntry(&IdtBase[10], &KiInvalidTssFault, 0, 0);
    KiInitializeIdtEntry(&IdtBase[11], &KiSegmentNotPresentFault, 0, 0);
    KiInitializeIdtEntry(&IdtBase[12], &KiStackFault, 0, 0);
    KiInitializeIdtEntry(&IdtBase[13], &KiGeneralProtectionFault, 0, 0);
    KiInitializeIdtEntry(&IdtBase[14], &KiPageFault, 0, 0);
    KiInitializeIdtEntry(&IdtBase[15], &KxUnexpectedInterrupt0[15], 0, 0);

    KiInitializeIdtEntry(&IdtBase[16], &KiFloatingErrorFault, 0, 0);
    KiInitializeIdtEntry(&IdtBase[17], &KiAlignmentFault, 0, 0);
    KiInitializeIdtEntry(&IdtBase[18], &KiMcheckAbort, 0, TSS_IST_MCA);
    KiInitializeIdtEntry(&IdtBase[19], &KiXmmException, 0, 0);
    KiInitializeIdtEntry(&IdtBase[20], &KxUnexpectedInterrupt0[20], 0, 0);
    KiInitializeIdtEntry(&IdtBase[21], &KxUnexpectedInterrupt0[21], 0, 0);
    KiInitializeIdtEntry(&IdtBase[22], &KxUnexpectedInterrupt0[22], 0, 0);
    KiInitializeIdtEntry(&IdtBase[23], &KxUnexpectedInterrupt0[23], 0, 0);
    KiInitializeIdtEntry(&IdtBase[24], &KxUnexpectedInterrupt0[24], 0, 0);
    KiInitializeIdtEntry(&IdtBase[25], &KxUnexpectedInterrupt0[25], 0, 0);
    KiInitializeIdtEntry(&IdtBase[26], &KxUnexpectedInterrupt0[26], 0, 0);
    KiInitializeIdtEntry(&IdtBase[27], &KxUnexpectedInterrupt0[27], 0, 0);
    KiInitializeIdtEntry(&IdtBase[28], &KxUnexpectedInterrupt0[28], 0, 0);
    KiInitializeIdtEntry(&IdtBase[29], &KxUnexpectedInterrupt0[29], 0, 0);
    KiInitializeIdtEntry(&IdtBase[30], &KxUnexpectedInterrupt0[30], 0, 0);
    KiInitializeIdtEntry(&IdtBase[31], &KiApcInterrupt, 0, 0);

    KiInitializeIdtEntry(&IdtBase[32], &KxUnexpectedInterrupt0[32], 0, 0);
    KiInitializeIdtEntry(&IdtBase[33], &KxUnexpectedInterrupt0[33], 0, 0);
    KiInitializeIdtEntry(&IdtBase[34], &KxUnexpectedInterrupt0[34], 0, 0);
    KiInitializeIdtEntry(&IdtBase[35], &KxUnexpectedInterrupt0[35], 0, 0);
    KiInitializeIdtEntry(&IdtBase[36], &KxUnexpectedInterrupt0[36], 0, 0);
    KiInitializeIdtEntry(&IdtBase[37], &KxUnexpectedInterrupt0[37], 0, 0);
    KiInitializeIdtEntry(&IdtBase[38], &KxUnexpectedInterrupt0[38], 0, 0);
    KiInitializeIdtEntry(&IdtBase[39], &KxUnexpectedInterrupt0[39], 0, 0);
    KiInitializeIdtEntry(&IdtBase[40], &KxUnexpectedInterrupt0[40], 0, 0);
    KiInitializeIdtEntry(&IdtBase[41], &KxUnexpectedInterrupt0[41], 0, 0);
    KiInitializeIdtEntry(&IdtBase[42], &KxUnexpectedInterrupt0[42], 0, 0);
    KiInitializeIdtEntry(&IdtBase[43], &KxUnexpectedInterrupt0[43], 0, 0);
    KiInitializeIdtEntry(&IdtBase[44], &KxUnexpectedInterrupt0[44], 0, 0);
    KiInitializeIdtEntry(&IdtBase[45], &KiDebugServiceTrap, 3, 0);
    KiInitializeIdtEntry(&IdtBase[46], &KxUnexpectedInterrupt0[46], 0, 0);
    KiInitializeIdtEntry(&IdtBase[47], &KiDpcInterrupt, 0, 0);

    //
    // Initialize unexpected interrupt entries.
    //

    for (Index = PRIMARY_VECTOR_BASE; Index <= MAXIMUM_IDTVECTOR; Index += 1) {
        KiInitializeIdtEntry(&IdtBase[Index],
                             &KxUnexpectedInterrupt0[Index],
                             0,
                             0);
    }

    //
    // Initialize the system TSS I/O Map.
    //

    TssBase = Pcr->TssBase;
    RtlFillMemory(&TssBase->IoMap[0], sizeof(KIO_ACCESS_MAP), -1);
    TssBase->IoMapEnd = -1;
    TssBase->IoMapBase = KiComputeIopmOffset(FALSE);

    //
    // Initialize the stack base and limit.
    //

    Pcr->NtTib.StackBase = (PVOID)(TssBase->Rsp0);
    Pcr->NtTib.StackLimit = (PVOID)(TssBase->Rsp0 - KERNEL_STACK_SIZE);

    //
    // Initialize the system call MSRs.
    //
    // N.B. CSTAR must be written before LSTAR to work around a bug in the
    //      simulator.
    //

    WriteMSR(MSR_STAR,
             ((ULONG64)KGDT64_R0_CODE << 32) | (((ULONG64)KGDT64_R3_CMCODE | RPL_MASK) << 48));

    WriteMSR(MSR_CSTAR, (ULONG64)&KiSystemCall32);
    WriteMSR(MSR_LSTAR, (ULONG64)&KiSystemCall64);
    WriteMSR(MSR_SYSCALL_MASK, EFLAGS_IF_MASK | EFLAGS_TF_MASK);

    //
    // Initialize the HAL for this processor.
    //

    HalInitializeProcessor(Number, LoaderBlock);

    //
    // Set the appropriate member in the active processors set.
    //

    KeActiveProcessors |= AFFINITY_MASK(Number);

    //
    // Set the number of processors based on the maximum of the current
    // number of processors and the current processor number.
    //

    if ((Number + 1) > KeNumberProcessors) {
        KeNumberProcessors = Number + 1;
    }

    return;
}

ULONG
KiFatalFilter (
    IN ULONG Code,
    IN PEXCEPTION_POINTERS Pointers
    )

/*++

Routine Description:

    This function is executed if an unhandled exception occurs during
    phase 0 initialization. Its function is to bug check the system
    with all the context information still on the stack.

Arguments:

    Code - Supplies the exception code.

    Pointers - Supplies a pointer to the exception information.

Return Value:

    None - There is no return from this routine even though it appears there
    is.

--*/

{

    KeBugCheckEx(PHASE0_EXCEPTION,
                 Code,
                 (ULONG64)Pointers,
                 0,
                 0);

    return EXCEPTION_EXECUTE_HANDLER;
}

BOOLEAN
KiInitMachineDependent (
    VOID
    )

/*++

Routine Description:

    This function initializes machine dependent data structures and hardware.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Size;
    NTSTATUS Status;
    BOOLEAN UseFrameBufferCaching;

    //
    // Query the HAL to determine if the write combining can be used for the
    // frame buffer.
    //

    Status = HalQuerySystemInformation(HalFrameBufferCachingInformation,
                                       sizeof(BOOLEAN),
                                       &UseFrameBufferCaching,
                                       &Size);

    //
    // If the status is successful and frame buffer caching is disabled,
    // then don't enable write combining.
    //

    if (!NT_SUCCESS(Status) || (UseFrameBufferCaching != FALSE)) {
        MmEnablePAT();
    }

    return TRUE;
}

VOID
KiSetCacheInformation (
    VOID
    )

/*++

Routine Description:

    This function sets the current processor cache information in the PCR.

Arguments:

    None.

Return Value:

    None.

--*/

{

    UCHAR Associativity;
    ULONG CacheSize;
    CPU_INFO CpuInfo;
    ULONG LineSize;
    PKPCR Pcr = KeGetPcr();

    //
    // Get the CPU L2 cache information.
    //

    KiCpuId(0x80000006, &CpuInfo);

    //
    // Get the L2 cache line size.
    //

    LineSize = CpuInfo.Ecx & 0xff;

    //
    // Get the L2 cache size.
    //

    CacheSize = (CpuInfo.Ecx >> 16) << 10;

    //
    // Compute the L2 cache associativity. 
    //

    switch ((CpuInfo.Ecx >> 12) & 0xf) {

        //
        // Two way set associative.
        //

    case 2:
        Associativity = 2;
        break;

        //
        // Four way set associative.
        //

    case 4:
        Associativity = 4;
        break;

        //
        // Six way set associative.
        //

    case 6:
        Associativity = 6;
        break;

        //
        // Eight way set associative.
        //

    case 8:
        Associativity = 8;
        break;

        //
        // Fully associative.
        //

    case 255:
        Associativity = 16;
        break;

        //
        // Direct mapped.
        //

    default:
        Associativity = 1;
        break;
    }

    //
    // Set L2 cache information.
    //

    Pcr->SecondLevelCacheAssociativity = Associativity;
    Pcr->SecondLevelCacheSize = CacheSize;

    //
    // If the line size is greater then the current largest line size, then
    // set the new largest line size.
    //

    if (LineSize > KeLargestCacheLine) {
        KeLargestCacheLine = LineSize;
    }

    return;
}

VOID
KiSetCpuVendor (
    VOID
    )

/*++

Routine Description:

    Set the current processor cpu vendor information in the PRCB.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PKPRCB Prcb = KeGetCurrentPrcb();
    CPU_INFO CpuInfo;
    ULONG Temp;

    //
    // Get the CPU vendor string.
    //

    KiCpuId(0, &CpuInfo);

    //
    // Copy vendor string to PRCB.
    //

    Temp = CpuInfo.Ecx;
    CpuInfo.Ecx = CpuInfo.Edx;
    CpuInfo.Edx = Temp;
    RtlCopyMemory(Prcb->VendorString,
                  &CpuInfo.Ebx,
                  sizeof(Prcb->VendorString) - 1);

    Prcb->VendorString[sizeof(Prcb->VendorString) - 1] = '\0';
    return;
}

VOID
KiSetFeatureBits (
    VOID
    )

/*++

Routine Description:

    Set the current processor feature bits in the PRCB.

Arguments:

    None.

Return Value:

    None.

--*/

{

    CPU_INFO CpuInfo;
    ULONG FeatureBits;
    PKPRCB Prcb = KeGetCurrentPrcb(); 

    //
    // Get CPU feature information.
    //

    KiCpuId(1, &CpuInfo);

    //
    // Set the initial APIC ID.
    //

    Prcb->InitialApicId = (UCHAR)(CpuInfo.Ebx >> 24);

    //
    // If the required fetures are not present, then bugcheck.
    //

    if ((CpuInfo.Edx & HF_REQUIRED) != HF_REQUIRED) {
        KeBugCheckEx(UNSUPPORTED_PROCESSOR, CpuInfo.Edx, 0, 0, 0);
    }

    FeatureBits = KF_REQUIRED;
    if (CpuInfo.Edx & 0x00200000) {
        FeatureBits |= KF_DTS;
    }

    //
    // Get extended CPU feature information.
    //

    KiCpuId(0x80000000, &CpuInfo);

    //
    // Check the extended feature bits.
    //

    if (CpuInfo.Edx & 0x80000000) {
        FeatureBits |= KF_3DNOW;
    }

    Prcb->LogicalProcessorsPerPhysicalProcessor = 1;
    Prcb->FeatureBits = FeatureBits;
    return;
}              

VOID
KiSetProcessorType (
    VOID
    )

/*++

Routine Description:

    This function sets the current processor family and stepping in the PRCB.

Arguments:

    None.

Return Value:

    None.

--*/

{

    CPU_INFO CpuInfo;
    PKPRCB Prcb = KeGetCurrentPrcb();

    //
    // Get cpu feature information.
    //

    KiCpuId(1, &CpuInfo);

    //
    // Set processor family and stepping information.
    //

    Prcb->CpuID = TRUE;
    Prcb->CpuType = (CCHAR)((CpuInfo.Eax >> 8) & 0xf);
    Prcb->CpuStep = (USHORT)(((CpuInfo.Eax << 4) & 0xf00) | (CpuInfo.Eax & 0xf));
    return;
}

VOID
KeOptimizeProcessorControlState (
    VOID
    )

/*++

Routine Description:

    This function performs no operation on AMD64.

Arguments:

    None.

Return Value:

    None.

--*/

{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\flushtb.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    flushtb.c

Abstract:

    This module implements machine dependent functions to flush the TB
    for an AMD64 system.

    N.B. This module contains only MP versions of the TB flush routines.

Author:

    David N. Cutler (davec) 22-April-2000

Environment:

    Kernel mode only.

--*/

#include "ki.h"

//
// Define prototypes for forward referenced functions.
//

VOID
KiFlushTargetEntireTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Invalid,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiFlushTargetMultipleTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiFlushTargetSingleTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

#if !defined(NT_UP)

VOID
KeFlushEntireTb (
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes the entire translation buffer (TB) on all
    processors that are currently running threads which are children
    of the current process or flushes the entire translation buffer
    on all processors in the host configuration.

Arguments:

    Invalid - Supplies a boolean value that specifies the reason for
        flushing the translation buffer.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

Return Value:

    None.

--*/

{

    KAFFINITY EntireSet;
    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;

    //
    // Compute the target set of processors, disable context switching,
    // and send the flush entire parameters to the target processors,
    // if any, for execution.
    //

    if (AllProcessors != FALSE) {
        OldIrql = KeRaiseIrqlToSynchLevel();
        Prcb = KeGetCurrentPrcb();
        TargetProcessors = KeActiveProcessors;

    } else {
        KiLockContextSwap(&OldIrql);
        Prcb = KeGetCurrentPrcb();
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    EntireSet = KeActiveProcessors & Prcb->NotSetMember;
    TargetProcessors &= Prcb->NotSetMember;

    //
    // If the target set of processors is equal to the full set of processors,
    // then set the TB flush time stamp busy.
    //

    if (TargetProcessors == EntireSet) {
        KiSetTbFlushTimeStampBusy();
    }

    //
    // Send packet to target processors.
    //

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushTargetEntireTb,
                        NULL,
                        NULL,
                        NULL);
    }

    IPI_INSTRUMENT_COUNT(Prcb->Number, FlushEntireTb);

    //
    // Flush TB on current processor.
    //

    KeFlushCurrentTb();

    //
    // Wait until all target processors have finished and complete packet.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // If the target set of processors is equal to the full set of processors,
    // then clear the TB flush time stamp busy.
    //

    if (TargetProcessors == EntireSet) {
        KiClearTbFlushTimeStampBusy();
    }

    //
    // Lower IRQL and unlock as appropriate.
    //

    if (AllProcessors != FALSE) {
        KeLowerIrql(OldIrql);

    } else {
        KiUnlockContextSwap(OldIrql);
    }

    return;
}

VOID
KiFlushTargetEntireTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for flushing the entire TB.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Parameter1 - Parameter3 - Not used.

Return Value:

    None.

--*/

{

    //
    // Flush the entire TB on the current processor.
    //

    KiIpiSignalPacketDone(SignalDone);
    KeFlushCurrentTb();
    return;
}

VOID
KeFlushMultipleTb (
    IN ULONG Number,
    IN PVOID *Virtual,
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors,
    IN PHARDWARE_PTE *PtePointer OPTIONAL,
    IN HARDWARE_PTE PteValue
    )

/*++

Routine Description:

    This function flushes multiple entries from the translation buffer
    on all processors that are currently running threads which are
    children of the current process or flushes a multiple entries from
    the translation buffer on all processors in the host configuration.

Arguments:

    Number - Supplies the number of TB entries to flush.

    Virtual - Supplies a pointer to an array of virtual addresses that
        are within the pages whose translation buffer entries are to be
        flushed.

    Invalid - Supplies a boolean value that specifies the reason for
        flushing the translation buffer.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

    PtePointer - Supplies an optional pointer to an array of pointers to
       page table entries that receive the specified page table entry
       value.

    PteValue - Supplies the the new page table entry value.

Return Value:

    The previous contents of the specified page table entry is returned
    as the function value.

--*/

{

    ULONG Index;
    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;

    //
    // Compute target set of processors.
    //

    if (AllProcessors != FALSE) {
        OldIrql = KeRaiseIrqlToSynchLevel();
        Prcb = KeGetCurrentPrcb();
        TargetProcessors = KeActiveProcessors;

    } else {
        KiLockContextSwap(&OldIrql);
        Prcb = KeGetCurrentPrcb();
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    //
    // If a page table entry address array is specified, then set the
    // specified page table entries to the specific value.
    //

    if (ARGUMENT_PRESENT(PtePointer)) {
        for (Index = 0; Index < Number; Index += 1) {
            *PtePointer[Index] = PteValue;
        }
    }

    //
    // If any target processors are specified, then send a flush multiple
    // packet to the target set of processors.
    //

    TargetProcessors &= Prcb->NotSetMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushTargetMultipleTb,
                        (PVOID)Invalid,
                        (PVOID)((ULONG64)Number),
                        (PVOID)Virtual);

    }

    IPI_INSTRUMENT_COUNT (Prcb->Number, FlushMultipleTb);

    //
    // Flush the specified entries from the TB on the current processor.
    //

    for (Index = 0; Index < Number; Index += 1) {
        KiFlushSingleTb(Invalid, Virtual[Index]);
    }

    //
    // Wait until all target processors have finished and complete packet.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Release the context swap lock.
    //

    if (AllProcessors != FALSE) {
        KeLowerIrql(OldIrql);

    } else {
        KiUnlockContextSwap(OldIrql);
    }

    return;
}

VOID
KiFlushTargetMultipleTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Invalid,
    IN PVOID Number,
    IN PVOID Virtual
    )

/*++

Routine Description:

    This is the target function for flushing multiple TB entries.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Invalid - Supplies a boolean value that determines whether the virtual
        address is invalid.

    Number - Supplies the number of TB entries to flush.

    Virtual - Supplies a pointer to an array of virtual addresses that
        are within the pages whose translation buffer entries are to be
        flushed.

Return Value:

    None.

--*/

{

    ULONG Index;
    PVOID VirtualAddress[FLUSH_MULTIPLE_MAXIMUM];

    //
    // Capture the virtual addresses that are to be flushed from the TB
    // on the current processor and signal pack done.
    //

    for (Index = 0; Index < (ULONG64)Number; Index += 1) {
        VirtualAddress[Index] = ((PVOID *)(Virtual))[Index];
    }

    KiIpiSignalPacketDone(SignalDone);

    //
    // Flush the specified virtual address for the TB on the current
    // processor.
    //

    for (Index = 0; Index < (ULONG64)Number; Index += 1) {
        KiFlushSingleTb((BOOLEAN)Invalid, VirtualAddress [Index]);
    }
}

HARDWARE_PTE
KeFlushSingleTb (
    IN PVOID Virtual,
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors,
    IN PHARDWARE_PTE PtePointer,
    IN HARDWARE_PTE PteValue
    )

/*++

Routine Description:

    This function flushes a single entry from translation buffer (TB)
    on all processors that are currently running threads which are
    children of the current process.

Arguments:

    Virtual - Supplies a virtual address that is within the page whose
        translation buffer entry is to be flushed.

    Invalid - Supplies a boolean value that specifies the reason for
        flushing the translation buffer.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

    PtePointer - Supplies a pointer to the page table entry which
        receives the specified value.

    PteValue - Supplies the the new page table entry value.

Return Value:

    The previous contents of the specified page table entry is returned
    as the function value.

--*/

{

    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    HARDWARE_PTE OldPte;
    KAFFINITY TargetProcessors;

    //
    // Compute the target set of processors and send the flush single
    // parameters to the target processors, if any, for execution.
    //

    if (AllProcessors != FALSE) {
        OldIrql = KeRaiseIrqlToSynchLevel();
        Prcb = KeGetCurrentPrcb();
        TargetProcessors = KeActiveProcessors;

    } else {
        KiLockContextSwap(&OldIrql);
        Prcb = KeGetCurrentPrcb();
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    //
    // Capture the previous contents of the page table entry and set the
    // page table entry to the new value.
    //

    OldPte = *PtePointer;
    *PtePointer = PteValue;

    //
    // If any target processors are specified, then send a flush single
    // packet to the target set of processors.
    //

    TargetProcessors &= Prcb->NotSetMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushTargetSingleTb,
                        (PVOID)Invalid,
                        (PVOID)Virtual,
                        NULL);
    }

    IPI_INSTRUMENT_COUNT(Prcb->Number, FlushSingleTb);

    //
    // Flush the specified entry from the TB on the current processor.
    //

    KiFlushSingleTb(Invalid, Virtual);

    //
    // Wait until all target processors have finished and complete packet.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Release the context swap lock.
    //

    if (AllProcessors != FALSE) {
        KeLowerIrql(OldIrql);

    } else {
        KiUnlockContextSwap(OldIrql);
    }

    return OldPte;
}

VOID
KiFlushTargetSingleTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Invalid,
    IN PVOID VirtualAddress,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for flushing a single TB entry.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Invalid - Supplies a boolean value that determines whether the virtual
        address is invalid.

    Virtual - Supplies a virtual address that is within the page whose
        translation buffer entry is to be flushed.

    Parameter3 - Not used.

Return Value:

    None.

--*/

{

    //
    // Flush a single entry from the TB on the current processor.
    //

    KiIpiSignalPacketDone(SignalDone);
    KiFlushSingleTb((BOOLEAN)Invalid, (PVOID)VirtualAddress);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\intobj.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    intobj.c

Abstract:

    This module implements the kernel interrupt object. Functions are provided
    to initialize, connect, and disconnect interrupt objects.

Author:

    David N. Cutler (davec) 7-May-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

VOID
KeInitializeInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN PKSPIN_LOCK SpinLock OPTIONAL,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KIRQL SynchronizeIrql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector,
    IN CCHAR ProcessorNumber,
    IN BOOLEAN FloatingSave
    )

/*++

Routine Description:

    This function initializes a kernel interrupt object. The service routine,
    service context, spin lock, vector, IRQL, SynchronizeIrql, and floating
    context save flag are initialized.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

    ServiceRoutine - Supplies a pointer to a function that is to be
        executed when an interrupt occurs via the specified interrupt
        vector.

    ServiceContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the ServiceRoutine parameter.

    SpinLock - Supplies a pointer to an executive spin lock.

    Vector - Supplies the HAL-generated interrupt vector.  Note that this
        is not be directly used as an index into the Interrupt Dispatch Table.

    Irql - Supplies the request priority of the interrupting source.

    SynchronizeIrql - Supplies the request priority that the interrupt should be
        synchronized with.

    InterruptMode - Supplies the mode of the interrupt; LevelSensitive or

    ShareVector - Supplies a boolean value that specifies whether the
        vector can be shared with other interrupt objects or not.  If FALSE
        then the vector may not be shared, if TRUE it may be.
        Latched.

    ProcessorNumber - Supplies the number of the processor to which the
        interrupt will be connected.

    FloatingSave - Supplies a boolean value that determines whether the
        floating point registers are to be saved before calling the service
        routine function. N.B. This argument is ignored.

Return Value:

    None.

--*/

{

    LONG Index;

    //
    // Initialize standard control object header.
    //

    Interrupt->Type = InterruptObject;
    Interrupt->Size = sizeof(KINTERRUPT);

    //
    // Initialize the address of the service routine, the service context,
    // the address of the spin lock, the address of the actual spinlock
    // that will be used, the vector number, the IRQL of the interrupting
    // source, the IRQL used for synchronize execution, the interrupt mode,
    // the processor number, and the floating context save flag.
    //

    Interrupt->ServiceRoutine = ServiceRoutine;
    Interrupt->ServiceContext = ServiceContext;
    if (ARGUMENT_PRESENT(SpinLock)) {
        Interrupt->ActualLock = SpinLock;

    } else {
        KeInitializeSpinLock (&Interrupt->SpinLock);
        Interrupt->ActualLock = &Interrupt->SpinLock;
    }

    Interrupt->Vector = Vector;
    Interrupt->Irql = Irql;
    Interrupt->SynchronizeIrql = SynchronizeIrql;
    Interrupt->Mode = InterruptMode;
    Interrupt->ShareVector = ShareVector;
    Interrupt->Number = ProcessorNumber;

    //
    // Copy the interrupt dispatch code template into the interrupt object.
    //

    for (Index = 0; Index < NORMAL_DISPATCH_LENGTH; Index += 1) {
        Interrupt->DispatchCode[Index] = KiInterruptTemplate[Index];
    }

#if defined(_AMD64_)

    //
    // Set DispatchAddress to KiInterruptDispatch as a default value.
    // The AMD64 HAL expects this to be set here.  Other clients will
    // overwrite this value as approriate via KeConnectInterrupt().
    //

    Interrupt->DispatchAddress = &KiInterruptDispatch;

#endif

    //
    // Set the connected state of the interrupt object to FALSE.
    //

    Interrupt->Connected = FALSE;
    return;
}

BOOLEAN
KeConnectInterrupt (
    IN PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function connects an interrupt object to the interrupt vector
    specified by the interrupt object.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is already connected or an attempt is made to
    connect to an interrupt vector that cannot be connected, then a value
    of FALSE is returned. Otherwise, a value of TRUE is returned.

--*/

{

    BOOLEAN Connected;
    PVOID Dispatch;
    ULONG IdtIndex;
    PKINTERRUPT Interruptx;
    KIRQL Irql;
    CCHAR Number;
    KIRQL OldIrql;
    PVOID Unexpected;
    ULONG Vector;

    //
    // If the interrupt object is already connected, the interrupt vector
    // number is invalid, an attempt is being made to connect to a vector
    // that cannot be connected, the interrupt request level is invalid, or
    // the processor number is invalid, then do not connect the interrupt
    // object. Otherwise, connect the interrupt object to the specified
    // vector and establish the proper interrupt dispatcher.
    //

    Connected = FALSE;
    Irql = Interrupt->Irql;
    Number = Interrupt->Number;
    Vector = Interrupt->Vector;
    IdtIndex = HalVectorToIDTEntry(Vector);
    if (((IdtIndex > MAXIMUM_PRIMARY_VECTOR) ||
        (Irql > HIGH_LEVEL) ||
        (Irql != (IdtIndex >> 4)) ||
        (Number >= KeNumberProcessors) ||
        (Interrupt->SynchronizeIrql < Irql)) == FALSE) {

        //
        // Set the system affinity to the specified processor, raise IRQL to
        // dispatcher level, and lock the dispatcher database.
        //

        KeSetSystemAffinityThread(AFFINITY_MASK(Number));
        KiLockDispatcherDatabase(&OldIrql);

        //
        // If the specified interrupt vector is not connected, then
        // connect the interrupt vector to the interrupt object dispatch
        // code, establish the dispatcher address, and set the new
        // interrupt mode and enable masks. Otherwise, if the interrupt is
        // already chained, then add the new interrupt object at the end
        // of the chain. If the interrupt vector is not chained, then
        // start a chain with the previous interrupt object at the front
        // of the chain. The interrupt mode of all interrupt objects in
        // a chain must be the same.
        //

        if (Interrupt->Connected == FALSE) {
            KeGetIdtHandlerAddress(Vector, &Dispatch);
            Unexpected = &KxUnexpectedInterrupt0[IdtIndex];
            if (Unexpected == Dispatch) {

                //
                // The interrupt vector is not connected.
                //

                Connected = HalEnableSystemInterrupt(Vector,
                                                     Irql,
                                                     Interrupt->Mode);

                if (Connected != FALSE) {
                    Interrupt->DispatchAddress = &KiInterruptDispatch;
                    KeSetIdtHandlerAddress(Vector, &Interrupt->DispatchCode[0]);
                }

            } else if (IdtIndex >= PRIMARY_VECTOR_BASE) {

                //
                // The interrupt vector is connected. Make sure the interrupt
                // mode matchs and that both interrupt objects allow sharing
                // of the interrupt vector.
                //

                Interruptx = CONTAINING_RECORD(Dispatch,
                                               KINTERRUPT,
                                               DispatchCode[0]);

                if ((Interrupt->Mode == Interruptx->Mode) &&
                    (Interrupt->ShareVector != FALSE) &&
                    (Interruptx->ShareVector != FALSE)) {
                    Connected = TRUE;

                    //
                    // If the chained dispatch routine is not being used,
                    // then switch to chained dispatch.
                    //

                    if (Interruptx->DispatchAddress != &KiChainedDispatch) {
                        InitializeListHead(&Interruptx->InterruptListEntry);
                        Interruptx->DispatchAddress = &KiChainedDispatch;
                    }

                    InsertTailList(&Interruptx->InterruptListEntry,
                                   &Interrupt->InterruptListEntry);
                }
            }
        }

        //
        // Unlock dispatcher database, lower IRQL to its previous value, and
        // set the system affinity back to the original value.
        //

        KiUnlockDispatcherDatabase(OldIrql);
        KeRevertToUserAffinityThread();
    }

    //
    // Return whether interrupt was connected to the specified vector.
    //

    Interrupt->Connected = Connected;
    return Connected;
}

BOOLEAN
KeDisconnectInterrupt (
    IN PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function disconnects an interrupt object from the interrupt vector
    specified by the interrupt object.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is not connected, then a value of FALSE is
    returned. Otherwise, a value of TRUE is returned.

--*/

{

    BOOLEAN Disconnected;
    PVOID Dispatch;
    ULONG IdtIndex;
    PKINTERRUPT Interruptx;
    PKINTERRUPT Interrupty;
    KIRQL Irql;
    KIRQL OldIrql;
    PVOID Unexpected;
    ULONG Vector;

    //
    // Set the system affinity to the specified processor, raise IRQL to
    // dispatcher level, and lock dispatcher database.
    //

    KeSetSystemAffinityThread(AFFINITY_MASK(Interrupt->Number));
    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the interrupt object is connected, then disconnect it from the
    // specified vector.
    //

    Disconnected = Interrupt->Connected;
    if (Disconnected != FALSE) {
        Irql = Interrupt->Irql;
        Vector = Interrupt->Vector;
        IdtIndex = HalVectorToIDTEntry(Vector);

        //
        // If the specified interrupt vector is not connected to the chained
        // interrupt dispatcher, then disconnect it by setting its dispatch
        // address to the unexpected interrupt routine. Otherwise, remove the
        // interrupt object from the interrupt chain. If there is only
        // one entry remaining in the list, then reestablish the dispatch
        // address.
        //

        KeGetIdtHandlerAddress(Vector, &Dispatch);
        Interruptx = CONTAINING_RECORD(Dispatch, KINTERRUPT, DispatchCode[0]);
        if (Interruptx->DispatchAddress == &KiChainedDispatch) {

            //
            // The interrupt object is connected to the chained dispatcher.
            //

            if (Interrupt == Interruptx) {
                Interruptx = CONTAINING_RECORD(Interruptx->InterruptListEntry.Flink,
                                               KINTERRUPT,
                                               InterruptListEntry);

                Interruptx->DispatchAddress = &KiChainedDispatch;
                KeSetIdtHandlerAddress(Vector, &Interruptx->DispatchCode[0]);
            }

            RemoveEntryList(&Interrupt->InterruptListEntry);
            Interrupty = CONTAINING_RECORD(Interruptx->InterruptListEntry.Flink,
                                           KINTERRUPT,
                                           InterruptListEntry);

            if (Interruptx == Interrupty) {
                Interrupty->DispatchAddress = KiDispatchInterrupt;
                KeSetIdtHandlerAddress(Vector, &Interrupty->DispatchCode[0]);
            }

        } else {

            //
            // The interrupt object is not connected to the chained interrupt
            // dispatcher.
            //

            HalDisableSystemInterrupt(Vector, Irql);
            Unexpected = &KxUnexpectedInterrupt0[IdtIndex];
            KeSetIdtHandlerAddress(Vector, Unexpected);
        }

        Interrupt->Connected = FALSE;
    }

    //
    // Unlock dispatcher database, lower IRQL to its previous value, and
    // set the system affinity back to the original value.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    KeRevertToUserAffinityThread();

    //
    // Return whether interrupt was disconnected from the specified vector.
    //

    return Disconnected;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\intipi.asm ===
title  "Interprocessor Interrupts"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   intipi.asm
;
; Abstract:
;
;   This module implements the code necessary to process interprocessor
;   interrupt requests.
;
; Author:
;
;   David N. Cutler (davec) 1-Sep-2000
;
; Environment:
;
;    Kernel mode only.
;
;--

include ksamd64.inc

        extern  KiFreezeTargetExecution:proc
        extern  KiIpiProcessRequests:proc

        subttl  "Interprocess Interrupt Service Routine"
;++
;
; VOID
; KeIpiInterrupt (
;     IN PKTRAP_FRAME TrapFrame
;     )
;
; Routine Description:
;
;   This routine is entered as the result of an interprocessor interrupt.
;   It processes all interrupt immediate and packet requests.
;
; Arguments:
;
;   TrapFrame (rcx) - Supplies a pointer to a trap frame.
;
; Return Value:
;
;   None.
;
;--

IiFrame struct
        P1Home  dq ?                    ; trap frame parameter
Iiframe ends

        NESTED_ENTRY KeIpiInterrupt, _TEXT$00

        alloc_stack (sizeof IiFrame)    ; allocate stack frame

        END_PROLOGUE

        mov     IiFrame.P1Home[rsp], rcx ; save trap frame address

;
; Process all interprocessor requests except for freeze execution requests.
;

        call    KiIpiProcessRequests    ; process interprocessor requests
        and     eax, IPI_FREEZE         ; check if freeze execution requested
        jz      short KiII10            ; if z, freeze execution not requested

;
; Freeze target execution.
;
; N.B. A intermediary routine is used to freeze the target execution to
;      enable the construction of an exception record.
;

        mov     rcx, IiFrame.P1Home[rsp] ; set trap frame address
        call    KiFreezeCurrentProcessor ; freeze current processor
KiII10: add     rsp, sizeof IiFrame    ; deallocate stack frame
        ret                             ; return

        NESTED_END KeIpiInterrupt, _TEXT$00

        subttl  "Freeze Current Processor"
;++
;
; VOID
; KiFreezeCurrentProcessor (
;     IN PKTRAP_FRAME TrapFrame
;     )
;
; Routine Description:
;
;   This routine constructs and exception frame and freezes the execution
;   of the current processor.
;
; Arguments:
;
;   TrapFrame (rcx) - Supplies a pointer to a trap frame.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiFreezeCurrentProcessor, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        mov     rdx, rsp                ; set address of exception frame
        call    KiFreezeTargetExecution ; freeze current processor execution

        RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        NESTED_END KiFreezeCurrentProcessor, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\intplt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    intplt.c

Abstract:

    This module implements platform specific code to support the processing
    of interrupts.

Author:

    David N. Cutler (davec) 30-Aug-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

BOOLEAN
KeSynchronizeExecution (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    )

/*++

Routine Description:

   This function synchronizes the execution of the specified routine with
   the execution of the service routine associated with the specified
   interrupt object.

Arguments:

   Interrupt - Supplies a pointer to an interrupt object.

   SynchronizeRoutine - Supplies a pointer to the function whose
       execution is to be synchronized with the execution of the service
       routine associated with the specified interrupt object.

   SynchronizeContext - Supplies a context pointer which is to be
       passed to the synchronization function as a parameter.

Return Value:

   The value returned by the synchronization routine is returned as the
   function value.

--*/

{

    KIRQL OldIrql;
    BOOLEAN Status;

    //
    // Raise IRQL to the interrupt synchronization level and acquire the
    // actual interrupt spinlock.
    //

    OldIrql = KfRaiseIrql(Interrupt->SynchronizeIrql);
    KiAcquireSpinLock(Interrupt->ActualLock);

    //
    // Call the specfied synchronization routine.
    //

    Status = (SynchronizeRoutine)(SynchronizeContext);

    //
    // Release the spin lock, lower IRQL to its previous value, and return
    // the sysnchronization routine status.
    //

    KiReleaseSpinLock(Interrupt->ActualLock);
    KeLowerIrql(OldIrql);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\intsup.asm ===
TITLE  "Interrupt Object Support Routines"
;++
;
; Copyright (c) 2000 Microsoft Corporation
;
; Module Name:
;
;    intsup.asm
;
; Abstract:
;
;    This module implements the platform specific code to support interrupt
;    objects. It contains the interrupt dispatch code and the code template
;    that gets copied into an interrupt object.
;
; Author:
;
;    David N. Cutler (davec) 19-Jun-2000
;
; Environment:
;
;    Kernel mode only.
;
;--

include ksamd64.inc

        extern  KeBugCheck:proc
        extern  KiInitiateUserApc:proc
        extern  __imp_HalEndSystemInterrupt:qword

        subttl  "Interrupt Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; KiInterruptHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PDISPATCHER_CONTEXT DispatcherContext
;    )
;
; Routine Description:
;
;   This routine is the exception handler for the interrupt dispatcher. The
;   dispatching or unwinding of an exception across an interrupt causes a
;   bug check.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to  the dispatcher context
;       record.
;
; Return Value:
;
;   There is no return from this routine.
;
;--

IhFrame struct
        P1Home  dq ?                    ; parameter home address
IhFrame ends

        NESTED_ENTRY KiInterruptHandler, _TEXT$00

        alloc_stack (sizeof IhFrame)    ; allocate stack frame

        END_PROLOGUE

        mov     ecx, INTERRUPT_UNWIND_ATTEMPTED ; set bug check code
        test    dword ptr ErExceptionFlags[rcx], EXCEPTION_UNWIND ; test for unwind
        jnz     short KiIH10            ; if nz, unwind in progress
        mov     ecx, INTERRUPT_EXCEPTION_NOT_HANDLED ; set bug check code
KiIH10: call    KeBugCheck              ; bug check - no return
        nop                             ; fill - do not remove

        NESTED_END KiInterruptHandler, _TEXT$00

        subttl  "Chained Dispatch"
;++
;
; VOID
; KiChainedDispatch (
;     VOID
;     );
;
; Routine Description:
;
;   This routine is entered as the result of an interrupt being generated
;   via a vector that is connected to more than one interrupt object.
;
; Arguments:
;
;   rbp - Supplies a pointer to the interrupt object.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiChainedDispatch, _TEXT$00, KiInterruptHandler

        .pushframe code                 ; mark machine frame
        .pushreg rbp                    ; mark mark nonvolatile register push

        GENERATE_INTERRUPT_FRAME        ; generate interrupt frame

        movzx   ecx, byte ptr InIrql[rsi] ; set interrupt IRQL

	ENTER_INTERRUPT	<NoEOI>         ; raise IRQL and enable interrupts

        call    KiScanInterruptObjectList ; scan interrupt object list

        EXIT_INTERRUPT                  ; do EOI, lower IRQL, and restore state

        NESTED_END KiChainedDispatch, _TEXT$00

        subttl  "Scan Interrupt Object List"
;++
;
; Routine Description:
;
;   This routine scans the list of interrupt objects for chained interrupt
;   dispatch. If the mode of the interrupt is latched, then a complete scan
;   of the list must be performed. Otherwise, the scan can be cut short as
;   soon as an interrupt routine returns
;
; Arguments:
;
;   rsi - Supplies a pointer to the interrupt object.
;
; Return Value:
;
;   None.
;
;--

SiFrame struct
        P1Home  dq ?                    ; interrupt object parameter
        P2Home  dq ?                    ; service context parameter
        Return  db ?                    ; service routine return value
        Fill    db 15 dup (?)           ; fill
        SavedRbx dq ?                   ; saved register RBX
        SavedRdi dq ?                   ; saved register RDI
        SavedR12 dq ?                   ; saved register RSI
SiFrame ends

        NESTED_ENTRY KiScanInterruptObjectList, _TEXT$00

        push_reg r12                    ; save nonvolatile registers
        push_reg rdi                    ;
        push_reg rbx                    ;
        alloc_stack (sizeof SiFrame - (3 * 8)) ; allocate stack frame

        END_PROLOGUE

        lea     rbx, InInterruptListEntry[rsi] ; get list head address
        mov     r12, rbx                ; set address of first list entry

;
; Scan the list of connected interrupt objects and call the service routine.
;

Si05:   xor     edi, edi                ; clear interrupt handled flag
Si10:   sub     r12, InInterruptListEntry ; compute interrupt object address
        movzx   ecx, byte ptr InSynchronizeIrql[r12] ; get synchronization IRQL
        cmp     cl, InIrql[rsi]         ; check if equal interrupt IRQL
        je      short Si20              ; if e, IRQL levels equal

        SetIrql                         ; set IRQL to synchronization level

Si20:   AcquireSpinLock InActualLock[r12] ; acquire interrupt spin lock

        mov     rcx, r12                ; set interrupt object parameter
        mov     rdx, InServiceContext[r12] ; set context parameter
        call    qword ptr InServiceRoutine[r12] ; call interrupt service routine
        mov     SiFrame.Return[rsp], al ; save return value

        ReleaseSpinLock InActualLock[r12] ; release interrupt spin lock

        movzx   ecx, byte ptr InIrql[rsi] ; get interrupt IRQL
        cmp     cl, InSynchronizeIrql[r12] ; check if equal synchronization IRQL
        je      short Si30              ; if e, IRQL levels equal

        SetIrql                         ; set IRQL to interrupt level

Si30:   test    byte ptr SiFrame.Return[rsp], 0ffh ; test if interrupt handled
        jz      short Si40              ; if z, interrupt not handled
        cmp     word ptr InMode[r12], InLatched ; check if latched interrupt
        jne     short Si50              ; if ne, not latched interrupt
        inc     edi                     ; indicate latched interrupt handled
Si40:   mov     r12, InInterruptListEntry[r12] ; get next interrupt list entry
        cmp     r12, rbx                ; check if end of list
        jne     Si10                    ; if ne, not end of list

;
; The complete interrupt object list has been scanned. This can only happen
; if the interrupt is a level sensitive interrupt and no interrupt was handled
; or the interrupt is a latched interrupt. Therefore, if any interrupt was
; handled it was a latched interrupt and the list needs to be scanned again
; to ensure that no interrupts are lost.
;

        test    edi, edi                ; test if any interrupts handled
        jnz     Si05                    ; if nz, latched interrupt handled
Si50:   add     rsp, sizeof SiFrame - (3 * 8) ; deallocate stack frame
        pop     rbx                     ; restore nonvolatile register
        pop     rdi                     ;
        pop     r12                     ;
        ret                             ;

        NESTED_END KiscanInterruptObjectList, _TEXT$00

        subttl  "Interrupt Dispatch"
;++
;
; Routine Description:
;
;   This routine is entered as the result of an interrupt being generated
;   via a vector that is connected to an interrupt object. Its function is
;   to directly call the specified interrupt service routine.
;
;   N.B. On entry rbp and rsi have been saved on the stack.
;
; Arguments:
;
;   rbp - Supplies a pointer to the interrupt object.
;
; Return Value:
;
;   None.
;
;--

        NESTED_ENTRY KiInterruptDispatch, _TEXT$00, KiInterruptHandler

        .pushframe code                 ; mark machine frame
        .pushreg rbp                    ; mark mark nonvolatile register push

        GENERATE_INTERRUPT_FRAME        ; generate interrupt frame

;
; N.B. It is possible for a interrupt to occur at an IRQL that is lower
;      than the current IRQL. This happens when the IRQL raised and at
;      the same time an interrupt request is granted.
;

        movzx   ecx, byte ptr InIrql[rsi] ; set interrupt IRQL

	ENTER_INTERRUPT <NoEOI>         ; raise IRQL and enable interrupts

        lea     rax, (-128)[rbp]        ; set trap frame address
        mov     InTrapFrame[rsi], rax   ;

        AcquireSpinLock InActualLock[rsi] ; acquire interrupt spin lock

        mov     rcx, rsi                ; set address of interrupt object
        mov     rdx, InServiceContext[rsi] ; set service context
        call    qword ptr InServiceRoutine[rsi] ; call interrupt service routine

        ReleaseSpinLock InActualLock[rsi] ; release interrupt spin lock

        EXIT_INTERRUPT                  ; do EOI, lower IRQL, and restore state

        NESTED_END KiInterruptDispatch, _TEXT$00

        subttl  "Disable Processor Interrupts"
;++
;
; BOOLEAN
; KeDisableInterrupts(
;    VOID
;    )
;
; Routine Description:
;
;   This function saves the state of the interrupt enable flag, clear the
;   state of the interrupt flag (disables interrupts), and return the old
;   inerrrupt enable flag state.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   If interrupts were previously enabled, then 1 is returned as the function
;   value. Otherwise, 0 is returned.
;
;--

DiFrame struct
        Flags   dd ?                    ; processor flags
        Fill    dd ?                    ; fill
DiFrame ends

        NESTED_ENTRY KeDisableInterrupts, _TEXT$00

        push_eflags                     ; push processor flags

        END_PROLOGUE

        mov     eax, DiFrame.Flags[rsp] ; isolate interrupt enable bit
        shr     eax, EFLAGS_IF_SHIFT    ;
        and     al, 1                   ;
        cli                             ; disable interrupts
        add     rsp, sizeof DiFrame     ; deallocate stack frame
        ret                             ; return

        NESTED_END KeDisableInterrupts, _TEXT$00

        subttl  "Interrupt Template"
;++
;
; Routine Description:
;
;   This routine is a template that is copied into each interrupt object.
;   Its function is to save volatile machine state, compute the interrupt
;   object address, and transfer control to the appropriate interrupt
;   dispatcher.
;
;   N.B. Interrupts are disabled on entry to this routine.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    N.B. Control does not return to this routine. The respective interrupt
;         dispatcher dismisses the interrupt directly.
;
;--

        LEAF_ENTRY KiInterruptTemplate, _TEXT$00

        push    rax                     ; push dummy vector number
        push    rbp                     ; save nonvolatile register
        lea     rbp, KiInterruptTemplate - InDispatchCode ; get interrupt object address
        jmp     qword ptr InDispatchAddress[rbp] ; finish in common code

        LEAF_END KiInterruptTemplate, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\ipi.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ipi.c

Abstract:

    This module implements AMD64 specific interprocessor interrupt
    routines.

Author:

    David N. Cutler (davec) 24-Aug-2000

Environment:

    Kernel mode only.


--*/

#include "ki.h"

VOID
KiRestoreProcessorState (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function restores the processor state to the specified exception
    and trap frames, and restores the processor control state.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame.

Return Value:

    None.

--*/

{

    PKPRCB Prcb;

    //
    // Get the address of the current processor block, move the specified
    // register state from the processor context structure to the specified
    // trap and exception frames, and restore the processor control state.
    //

#if !defined(NT_UP)

    Prcb = KeGetCurrentPrcb();
    KeContextToKframes(TrapFrame,
                       ExceptionFrame,
                       &Prcb->ProcessorState.ContextFrame,
                       CONTEXT_FULL,
                       KernelMode);

    KiRestoreProcessorControlState(&Prcb->ProcessorState);

#endif

    return;
}

VOID
KiSaveProcessorState (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function saves the processor state from the specified exception
    and trap frames, and saves the processor control state.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame.

Return Value:

    None.

--*/

{

    PKPRCB Prcb;

    //
    // Get the address of the current processor block, move the specified
    // register state from specified trap and exception frames to the current
    // processor context structure, and save the processor control state.
    //

#if !defined(NT_UP)

    Prcb = KeGetCurrentPrcb();
    Prcb->ProcessorState.ContextFrame.ContextFlags = CONTEXT_FULL;
    KeContextFromKframes(TrapFrame,
                         ExceptionFrame,
                         &Prcb->ProcessorState.ContextFrame);

    KiSaveProcessorControlState(&Prcb->ProcessorState);

#endif

    return;
}

BOOLEAN
KiIpiServiceRoutine (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:


    This function is called at IPI_LEVEL to process outstanding interprocess
    requests for the current processor.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame.

    ExceptionFrame - Supplies a pointer to an exception frame

Return Value:

    A value of TRUE is returned, if one of more requests were service.
    Otherwise, FALSE is returned.

--*/

{

    ULONG RequestMask;

    //
    // Process any outstanding interprocessor requests.
    //

#if !defined(NT_UP)

    RequestMask = KiIpiProcessRequests();

    //
    // If freeze is requested, then freeze target execution.
    //

    if ((RequestMask & IPI_FREEZE) != 0) {
        KiFreezeTargetExecution(TrapFrame, ExceptionFrame);
    }

    //
    // Return whether any requests were processed.
    //

    return (RequestMask & ~IPI_FREEZE) != 0;

#else

    return TRUE;

#endif

}

ULONG
KiIpiProcessRequests (
    VOID
    )

/*++

Routine Description:

    This routine processes interprocessor requests and returns a summary
    of the requests that were processed.

    N.B. This routine does not process freeze execution requests. It is the
         responsibilty of the caller to determine that a freeze execution
         request is outstanding and process it accordingly.

Arguments:

    None.

Return Value:

    The request summary is returned as the function value.

--*/

{

    PKPRCB CurrentPrcb;
    ULONG RequestMask;
    PVOID RequestPacket;
    ULONG64 RequestSummary;
    PKPRCB RequestSource;

#if !defined(NT_UP)

    //
    // Get the current request summary value.
    //

    CurrentPrcb = KeGetCurrentPrcb();
    RequestSummary = InterlockedExchange64(&CurrentPrcb->RequestSummary, 0);
    RequestMask = (ULONG)(RequestSummary & ((1 << IPI_PACKET_SHIFT) - 1));
    RequestPacket = (PVOID)(RequestSummary >> IPI_PACKET_SHIFT);

    //
    // If a packet request is ready, then process the packet request.
    //

    if (RequestPacket != NULL) {
        RequestSource = (PKPRCB)((ULONG64)RequestPacket & ~1);
        (RequestSource->WorkerRoutine)((PKIPI_CONTEXT)RequestPacket,
                                       RequestSource->CurrentPacket[0],
                                       RequestSource->CurrentPacket[1],
                                       RequestSource->CurrentPacket[2]);
    }

    //
    // If an APC interrupt is requested, then request a software interrupt
    // at APC level on the current processor.
    //

    if ((RequestMask & IPI_APC) != 0) {
        KiRequestSoftwareInterrupt(APC_LEVEL);
    }

    //
    // If a DPC interrupt is requested, then request a software interrupt
    // at DPC level on the current processor.
    //

    if ((RequestMask & IPI_DPC) != 0) {
        KiRequestSoftwareInterrupt(DISPATCH_LEVEL);
    }

    return RequestMask;

#else

    return 0;

#endif

}

VOID
KiIpiSend (
    IN KAFFINITY TargetSet,
    IN KIPI_REQUEST Request
    )

/*++

Routine Description:

    This function requests the specified operation on the targt set of
    processors.

    N.B. This function MUST be called from a non-context switchable state.

Arguments:

    TargetSet - Supplies the target set of processors on which the specified
        operation is to be executed.

    Request - Supplies the request operation flags.

Return Value:

     None.

--*/

{

    PKPRCB *NextPrcb;
    KAFFINITY SummarySet;

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    //
    // Loop through the target set of processors and merge the request into
    // the request summary of the target processors.
    //

#if !defined(NT_UP)

    SummarySet = TargetSet;
    NextPrcb = &KiProcessorBlock[0];
    do {
        if ((SummarySet & 1) != 0) {
            InterlockedOr64(&(*NextPrcb)->RequestSummary,
                            Request);
        }

        NextPrcb += 1;
    } while ((SummarySet >>= 1) != 0);

    //
    // Request interprocessor interrupts on the target set of processors.
    //

    HalRequestIpi(TargetSet);

#endif

    return;
}

VOID
KiIpiSendPacket (
    IN KAFFINITY TargetSet,
    IN PKIPI_WORKER WorkerFunction,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This routine executes the specified worker function on the specified
    set of processors.

    N.B. This function MUST be called from a non-context switchable state.

Arguments:

   TargetProcessors - Supplies the set of processors on which the specfied
       operation is to be executed.

   WorkerFunction  - Supplies the address of the worker function.

   Parameter1 - Parameter3 - Supplies worker function specific paramters.

Return Value:

    None.

--*/

{

    PKPRCB CurrentPrcb;
    PKPRCB *NextPrcb;
    LONG64 RequestSummary;
    KAFFINITY SummarySet;
    PKPRCB TargetPrcb;

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    //
    // Initialize the worker packet information.
    //

#if !defined(NT_UP)

    CurrentPrcb = KeGetCurrentPrcb();
    CurrentPrcb->CurrentPacket[0] = Parameter1;
    CurrentPrcb->CurrentPacket[1] = Parameter2;
    CurrentPrcb->CurrentPacket[2] = Parameter3;
    CurrentPrcb->TargetSet = TargetSet;
    CurrentPrcb->WorkerRoutine = WorkerFunction;

    //
    // If the target set contains one and only one processor, then use the
    // target set for signal done synchronization. Otherwise, use packet
    // barrier for signal done synchronization.
    //

    if ((TargetSet & (TargetSet - 1)) == 0) {
        CurrentPrcb = (PKPRCB)((ULONG64)CurrentPrcb | 1);

    } else {
        CurrentPrcb->PacketBarrier = 1;
    }

    //
    // Loop through the target set of processors and merge the request into
    // the request summary of the target processors.
    //

    SummarySet = TargetSet;
    NextPrcb = &KiProcessorBlock[0];
    do {
        if ((SummarySet & 1) != 0) {
            TargetPrcb = *NextPrcb;
            do {
                do {
                    RequestSummary = TargetPrcb->RequestSummary;
                } while ((RequestSummary >> IPI_PACKET_SHIFT) != 0);

            } while (InterlockedCompareExchange64(&TargetPrcb->RequestSummary,
                                                  RequestSummary | ((ULONG64)CurrentPrcb << IPI_PACKET_SHIFT),
                                                  RequestSummary) != RequestSummary);
        }

        NextPrcb += 1;
    } while ((SummarySet >>= 1) != 0);

    //
    // Request interprocessor interrupts on the target set of processors.
    //

    HalRequestIpi(TargetSet);

#endif

    return;
}

VOID
KiIpiSignalPacketDone (
    IN PKIPI_CONTEXT SignalDone
    )

/*++

Routine Description:

    This routine signals that a processor has completed a packet by clearing
    the calling processor's set member of the requesting processor's packet.

Arguments:

    SignalDone - Supplies a pointer to the processor block of the sending
        processor.

Return Value:

     None.

--*/

{

    PKPRCB TargetPrcb;
    KAFFINITY TargetSet;

    //
    // If the low bit of signal is set, then use target set to notify the
    // sender that the operation is complete on the current processor.
    // Otherwise, use packet barrier to notify the sender that the operation
    // is complete on the current processor.
    //

#if !defined(NT_UP)

    if (((ULONG64)SignalDone & 1) == 0) {
       TargetPrcb = (PKPRCB)SignalDone;
       TargetSet = InterlockedXor64((PLONG64)&TargetPrcb->TargetSet,
                                    TargetPrcb->SetMember);

       //
       // If no more bits are set in the target set, then clear packet
       // barrier.
       //

       if ((TargetPrcb->TargetSet ^ TargetSet) == 0) {
           TargetPrcb->PacketBarrier = 0;
       }

    } else {
        TargetPrcb = (PKPRCB)((ULONG64)SignalDone - 1);
        TargetPrcb->TargetSet = 0;
    }

#endif

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\misc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module implements machine dependent miscellaneous kernel functions.

Author:

    David N. Cutler (davec) - 6-Dec-2000

Environment:

    Kernel mode only.

--*/

#include "ki.h"

VOID
KeRestoreProcessorSpecificFeatures(
    VOID
    )

/*++

Routine Description:

    Restore processor specific features.  This routine is called
    when processors have been restored to a powered on state to
    restore those things which are not part of the processor's
    "normal" context which may have been lost.  For example, this
    routine is called when a system is resumed from hibernate or
    suspend.

Arguments:

    None.

Return Value:

    None.

--*/

{

    return;
}

VOID
KeSaveStateForHibernate (
    IN PKPROCESSOR_STATE ProcessorState
    )

/*++

Routine Description:

    Saves all processor-specific state that must be preserved
    across an S4 state (hibernation).

Arguments:

    ProcessorState - Supplies the KPROCESSOR_STATE where the
        current CPU's state is to be saved.

Return Value:

    None.

--*/

{

    RtlCaptureContext(&ProcessorState->ContextFrame);
    KiSaveProcessorControlState(ProcessorState);
}

VOID
KiCheckBreakInRequest (
    VOID
    )

/*++

Routine Description:

    This routine conditionally generates a debug break with status if a
    break in request is pending.

Arguments:

    None.

Return Value:

    None.

--*/

{

    if (KdPollBreakIn() != FALSE) {
        DbgBreakPointWithStatus(DBG_STATUS_CONTROL_C);
    }

    return;
}


VOID
KiInstantiateInlineFunctions (
    VOID
    )

/*++

Routine Description:

    This function exists solely to instantiate functions that are:

    - Exported from the kernel
    - Inlined within the kernel
    - For whatever reason are not instantiated elsewhere in the kernel

    Note: This funcion is never actually executed

Arguments:

    None

Return Value:

    None

--*/

{
    KeRaiseIrqlToDpcLevel();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\pat.c ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    pat.c

Abstract:

    This module initializes the page attributes table.

Author:

    David N. Cutler (davec) 2-May-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#pragma alloc_text(PAGELK, KiSetPageAttributesTable)

VOID
KiSetPageAttributesTable (
    VOID
    )

/*++

Routine Description:

    This function initializes the page attribute table for the current
    processor. The page attribute table is set up to provide write back,
    write combining, uncacheable/stronly order, and uncacheable/weakly
    ordered.

    PAT_Entry   PAT Index   PCD PWT     Memory Type

    0            0           0   0       WB
    1            0           0   1       WC *
    2            0           1   0       WEAK_UC
    3            0           1   1       STRONG_UC
    4            1           0   0       WB
    5            1           0   1       WC *
    6            1           1   0       WEAK_UC
    7            1           1   1       STRONG_UC

    N.B. The caller must have the PAGELK code locked before calling this
         function.

  Arguments:

    None.

Return Value:

    None.

--*/

{

    PAT_ATTRIBUTES Attributes;

    //
    // Initialize the page attribute table.
    //

    Attributes.hw.Pat[0] = PAT_TYPE_WB;
    Attributes.hw.Pat[1] = PAT_TYPE_USWC;
    Attributes.hw.Pat[2] = PAT_TYPE_WEAK_UC;
    Attributes.hw.Pat[3] = PAT_TYPE_STRONG_UC;
    Attributes.hw.Pat[4] = PAT_TYPE_WB;
    Attributes.hw.Pat[5] = PAT_TYPE_USWC;
    Attributes.hw.Pat[6] = PAT_TYPE_WEAK_UC;
    Attributes.hw.Pat[7] = PAT_TYPE_STRONG_UC;

    //
    // Invalidate the cache on the current proccesor, write the page attributes
    // table, and invalidate the cache a second time.
    //

    WritebackInvalidate();
    WriteMSR(MSR_PAT, Attributes.QuadPart);
    WritebackInvalidate();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\kiamd64.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    kiamd64.h

Abstract:

    This module contains the private (internal) platform specific header file
    for the kernel.

Author:

    David N. Cutler (davec) 15-May-2000

Revision History:

--*/

#if !defined(_KIAMD64_)
#define _KIAMD64_

VOID
KiCheckBreakInRequest (
    VOID
    );

VOID
KiInitializeBootStructures (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    );

extern KIRQL KiProfileIrql;

BOOLEAN
KeInvalidateAllCaches (
    IN BOOLEAN AllProcessors
    );

VOID
KiRetireDpcList (
    PKPRCB Prcb
    );

//
// Define function prototypes for trap processing functions.
//

VOID
KiDivideErrorFault (
    VOID
    );

VOID
KiDebugTrapOrFault (
    VOID
    );

VOID
KiNmiInterrupt (
    VOID
    );

VOID
KiBreakpointTrap (
    VOID
    );

VOID
KiOverflowTrap (
    VOID
    );

VOID
KiBoundFault (
    VOID
    );

VOID
KiInvalidOpcodeFault (
    VOID
    );

VOID
KiNpxNotAvailableFault (
    VOID
    );

VOID
KiDoubleFaultAbort (
    VOID
    );

VOID
KiNpxSegmentOverrunAbort (
    VOID
    );

VOID
KiInvalidTssFault (
    VOID
    );

VOID
KiSegmentNotPresentFault (
    VOID
    );

VOID
KiSetPageAttributesTable (
    VOID
    );

VOID
KiStackFault (
    VOID
    );

VOID
KiGeneralProtectionFault (
    VOID
    );

VOID
KiPageFault (
    VOID
    );

VOID
KiFloatingErrorFault (
    VOID
    );

VOID
KiAlignmentFault (
    VOID
    );

VOID
KiMcheckAbort (
    VOID
    );

VOID
KiXmmException (
    VOID
    );

VOID
KiApcInterrupt (
    VOID
    );

VOID
KiDebugServiceTrap (
    VOID
    );

VOID
KiDpcInterrupt (
    VOID
    );

VOID
KiSystemCall32 (
    VOID
    );

VOID
KiSystemCall64 (
    VOID
    );

//
// Define unexpected interrupt structure and table.
//
// N.B. The actual table is generated in assembler.
//

typedef struct _UNEXPECTED_INTERRUPT {
    ULONG Array[4];
} UNEXPECTED_INTERRUPT, *PUNEXPECTED_INTERRUPT;

UNEXPECTED_INTERRUPT KxUnexpectedInterrupt0[];

//
// PAE definitions.
//

#define MAX_IDENTITYMAP_ALLOCATIONS 30

typedef struct _IDENTITY_MAP  {
    PHARDWARE_PTE TopLevelDirectory;
    ULONG64 IdentityCR3;
    ULONG64 IdentityAddr;
    ULONG PagesAllocated;
    PVOID PageList[MAX_IDENTITYMAP_ALLOCATIONS];
} IDENTITY_MAP, *PIDENTITY_MAP;

VOID
Ki386ClearIdentityMap(
    PIDENTITY_MAP IdentityMap
    );

VOID
Ki386EnableTargetLargePage(
    PIDENTITY_MAP IdentityMap
    );

BOOLEAN
Ki386CreateIdentityMap(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PVOID StartVa,
    IN     PVOID EndVa
    );

BOOLEAN
Ki386EnableCurrentLargePage (
    IN ULONG IdentityAddr,
    IN ULONG IdentityCr3
    );

extern PVOID Ki386EnableCurrentLargePageEnd;

#define PPI_BITS    2
#define PDI_BITS    9
#define PTI_BITS    9

#define PDI_MASK    ((1 << PDI_BITS) - 1)
#define PTI_MASK    ((1 << PTI_BITS) - 1)

#define KiGetPpeIndex(va) ((((ULONG)(va)) >> PPI_SHIFT) & PPI_MASK)
#define KiGetPdeIndex(va) ((((ULONG)(va)) >> PDI_SHIFT) & PDI_MASK)
#define KiGetPteIndex(va) ((((ULONG)(va)) >> PTI_SHIFT) & PTI_MASK)

extern ULONG KeAmd64MachineType;

#endif // !defined(_KIAMD64_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\miscs.asm ===
title  "Miscellaneous Functions"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   miscs.asm
;
; Abstract:
;
;   This module implements machine dependent miscellaneous kernel functions.
;
; Author:
;
;   David N. Cutler (davec) 8-Aug-2000
;
; Environment:
;
;   Kernel mode only.
;
;--

include ksamd64.inc

        extern  KeTestAlertThread:proc
        extern  KiContinue:proc
        extern  KiExceptionExit:proc
        extern  KiRaiseException:proc

        subttl  "Continue Execution System Service"
;++
;
; NTSTATUS
; NtContinue (
;     IN PCONTEXT ContextRecord,
;     IN BOOLEAN TestAlert
;     )
;
; Routine Description:
;
;   This routine is called as a system service to continue execution after
;   an exception has occurred. Its function is to transfer information from
;   the specified context record into the trap frame that was built when the
;   system service was executed, and then exit the system as if an exception
;   had occurred.
;
; Arguments:
;
;   ContextRecord (rcx) - Supplies a pointer to a context record.
;
;   TestAlert (dl) - Supplies a boolean value that specifies whether alert
;       should be tested for the previous processor mode.
;
; Implicit Arguments:
;
;   rbp - Supplies the address of a trap frame.
;
; Return Value:
;
;   Normally there is no return from this routine. However, if the specified
;   context record is misaligned or is not accessible, then the appropriate
;   status code is returned.
;
;--

        NESTED_ENTRY NtContinue, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

;
; Transfer information from the context frame to the exception and trap frames.
;
; N.B. If the previous mode is user, then the legacy floating point state is
;      saved in case the context record does not specify floating context.
;

        test    byte ptr TrSegCs[rbp], MODE_MASK ; check if previous mode user
        jz      short KiCO10            ; if z, preevious mode not user
        lea     rsi, (KTRAP_FRAME_LENGTH - 128)[rbp] ; get save area address
        fnsaved [rsi]                   ; save legacy floating state
KiCO10: mov     bl, dl                  ; save test alert argument
        mov     rdx, rsp                ; set exception frame address
        lea     r8, (-128)[rbp]         ; set trap frame address
        call    KiContinue              ; transfer context to kernel frames

;
; If the kernel continuation routine returns success, then exit via the
; exception exit code. Otherwise, return to the system service dispatcher.
;

        test    eax, eax                ; test if service failed
        jnz     short KiCO40            ; if nz, service failed

;
; Check to determine if alert should be tested for the previous processor
; mode and restore the previous mode in the thread object.
;

        mov     rax, gs:[PcCurrentThread] ; get current thread address
        mov     r8, TrTrapFrame[rbp]    ; set previous trap frame address
        mov     ThTrapFrame[rax], r8    ;
        mov     cl, ThPreviousMode[rax] ; get thread previous mode
        mov     dl, TrPreviousMode[rbp] ; get frame previous mode
        mov     ThPreviousMode[rax], dl ; set thread previous mode
        test    bl, bl                  ; test if test alert specified
        jz      short KiCO20            ; if z, test alert not specified
        call    KeTestAlertThread       ; test alert for current thread

;
; If the previous mode is user, then restore the legacy floating state.
;

KiCO20: test    byte ptr TrSegCs[rbp], MODE_MASK ; check if previous mode user
        jz      short KiCO30            ; if z, previous mode not user
        mov     ax, LfControlWord[rsi]  ; save current control word
        mov     word ptr LfControlWord[rsi], 03fh ; set to mask all exceptions
        frstord [rsi]                   ; restore legacy floating state
        mov     LfControlWord[rsi], ax  ; restore control word
        fldcw   word ptr LfControlWord[rsi] ; load legacy control word
KiCO30: jmp     KiExceptionExit         ;

;
; Context record is misaligned or not accessible.
;

KiCO40: RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        NESTED_END NtContinue, _TEXT$00

        subttl  "Raise Exception System Service"
;++
;
; NTSTATUS
; NtRaiseException (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PCONTEXT ContextRecord,
;     IN BOOLEAN FirstChance
;     )
;
; Routine Description:
;
;   This routine is called as a system service to raise an exception. Its
;   function is to transfer information from the specified context record
;   into the trap frame that was built when the system service was executed.
;   The exception may be raised as a first or second chance exception.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   ContextRecord (rdx) - Suppilies a pointer to a context record.
;
;   FirstChance (r8b) - Supplies a boolean value that specifies whether
;       this is the first (TRUE) or second chance (FALSE) for dispatching
;       the exception.
;
; Implicit Arguments:
;
;   rbp - Supplies a pointer to a trap frame.
;
; Return Value:
;
;   Normally there is no return from this routine. However, if the specified
;   context record or exception record is misaligned or is not accessible,
;   then the appropriate status code is returned.
;
;--

        NESTED_ENTRY NtRaiseException, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

;
; Call the raise exception kernel routine which will marshall the arguments
; and then call the exception dispatcher.
;
; N.B. If the previous mode is user, then the legacy floating point state is
;      saved in case the context record does not specify floating context.
;

        lea     r9, (-128)[rbp]         ; set trap frame address
        test    byte ptr TrSegCs[rbp], MODE_MASK ; check if previous mode user
        jz      short KiRE10            ; if z, previous mode not user
        fnsaved KTRAP_FRAME_LENGTH[r9]  ; save legacy floating state
KiRE10: mov     ExP5[rsp], r8b          ; set first chance parameter
        mov     r8, rsp                 ; set exception frame address
        call    KiRaiseException        ; call raise exception routine

;
; If the kernel raise exception routine returns success, then exit via the
; exception exit code. Otherwise, return to the system service dispatcher.
;

        test    eax, eax                ; test if service failed
        jnz     short KiRE20            ; if nz, service failed

;
; Exit via the exception exit code which will restore the machine state.
;

        mov     rax, gs:[PcCurrentThread] ; get current thread address
        mov     r8, TrTrapFrame[rbp]    ; set previous trap frame address
        mov     ThTrapFrame[rax], r8    ;
        jmp     KiExceptionExit         ;

;
; The context or exception record is misaligned or not accessible, or the
; exception was not handled.
;

KiRE20: RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        NESTED_END NtRaiseException, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\iopm.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    iopm.c

Abstract:

    This module implements interfaces that support manipulation of I/O
    Permission Maps (IOPMs).

Author:

    David N. Cutler (davec) 4-May-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Define forward referenced function prototypes.
//

VOID
KiSetIoAccessMap (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID MapSource,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiSetIoAccessProcess (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID MapOffset,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KeQueryIoAccessMap (
    PKIO_ACCESS_MAP IoAccessMap
    )

/*++

Routine Description:

    This function queries the current I/O Permissions Map and copies it
    to the specified buffer.

Arguments:

    IoAccessMap - Supplies a pointer to an I/O Permissions Map that will
        receive the current I/O Permissions Map.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;

    //
    // Raise IRQL and acquire the context swap lock..
    //

    KiLockContextSwap(&OldIrql);

    //
    // Copy the current I/O Permissions Map to the specified buffer.
    //


    RtlCopyMemory(IoAccessMap, &KeGetPcr()->TssBase->IoMap[0], IOPM_SIZE);

    //
    // Release the context swap lock and lower IRQL.
    //

    KiUnlockContextSwap(OldIrql);
    return;
}

VOID
KeSetIoAccessMap (
    PKIO_ACCESS_MAP IoAccessMap
    )

/*++

Routine Description:

    This funtion copies the specified I/O Permission Map to the current
    I/O Permissions Map on all processors in the host configuration.

Arguments:

    IoAccessMap - Supplies a pointer to the new I/O Permissions Map.

Return Value:

    None.

--*/

{

    KIRQL OldIrql;
    PKPRCB Prcb;
    KAFFINITY TargetProcessors;

    //
    // Raise IRQL and acquire the context swap lock.
    //

    KiLockContextSwap(&OldIrql);

    //
    // Compute the target set of processors and send a message to copy
    // the new I/O Permissions Map.
    //

#if !defined(NT_UP)

    Prcb = KeGetCurrentPrcb();
    TargetProcessors = KeActiveProcessors & Prcb->NotSetMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiSetIoAccessMap,
                        IoAccessMap,
                        NULL,
                        NULL);
    }

#endif

    //
    // Copy the I/O Permissions Map into the current map.
    //

    RtlCopyMemory(&KeGetPcr()->TssBase->IoMap[0], IoAccessMap, IOPM_SIZE);

    //
    // Wait until all of the target processors have finished copying the
    // new map.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    //
    // Release the context swap lock and lower IRQL.
    //

    KiUnlockContextSwap(OldIrql);
    return;
}

#if !defined(NT_UP)

VOID
KiSetIoAccessMap (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID MapSource,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for copying the new I/O Permissions Map.

Arguments:

    MapSource - Supplies a pointer to the new I/O Permission Map.

    Parameter2 - Parameter3 - Not used.

Return Value:

    None.

--*/

{

    //
    // Copy the specified I/O Permissions map into the current map.
    //

    RtlCopyMemory(&KeGetPcr()->TssBase->IoMap[0], MapSource, IOPM_SIZE);
    KiIpiSignalPacketDone(SignalDone);
    return;
}

#endif

VOID
KeSetIoAccessProcess (
    PKPROCESS Process,
    BOOLEAN Enable
    )

/*++

Routine Description:

    This function enables or disables use of the I/O Permissions Map by
    the specified process.

Arguments:

    Process - Supplies a pointer to a process object.

    Enable - Supplies a value that determines whether the current I/O
        Permissions Map is enabled (TRUE) or disabled (FALSE) for the
        specified process.

Return Value:

    None.

--*/

{

    USHORT MapOffset;
    KIRQL OldIrql;
    PKPRCB Prcb;
    KAFFINITY TargetProcessors;

    //
    // Raise IRQL and acquire the context swap lock.
    //

    KiLockContextSwap(&OldIrql);

    //
    // Compute the new I/O Permissions Map offset and set the new offset for
    // the specified process.
    //

    MapOffset = KiComputeIopmOffset(Enable);
    Process->IopmOffset = MapOffset;

    //
    // Compute the target set of processors and send a message specifing a
    // new I/O Permsissions Map offset.
    //

    Prcb = KeGetCurrentPrcb();

#if !defined(NT_UP)

    TargetProcessors = Process->ActiveProcessors & Prcb->NotSetMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiSetIoAccessProcess,
                        (PVOID)((ULONG64)MapOffset),
                        NULL,
                        NULL);
    }

#endif

    //
    // If the specified process has a child thread that is running on the
    // current processor, then set the new I/O Permissions Map offset.
    //

    if (Process->ActiveProcessors & Prcb->SetMember) {
        KeGetPcr()->TssBase->IoMapBase = MapOffset;
    }

    //
    // Wait until all of the target processors have finished setting the new
    // map offset.
    //

#if !defined(NT_UP)

    KiIpiStallOnPacketTargets(TargetProcessors);

#endif

    //
    // Release the context swap lock and lower IRQL.
    //

    KiUnlockContextSwap(OldIrql);
    return;
}

#if !defined(NT_UP)

VOID
KiSetIoAccessProcess (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID MapOffset,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function to set the I/O Permissions Map offset.

Arguments:

    MapOffset - Supplies the new I/O Permissions Map offset.

    Parameter2 - Parameter3 - Not Used.

Return Value:

    None.

--*/

{

    //
    // Update IOPM field in TSS from current process
    //

    KeGetPcr()->TssBase->IoMapBase = (USHORT)((ULONG64)MapOffset);
    KiIpiSignalPacketDone(SignalDone);
    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\procstat.asm ===
title  "Processor State Save Restore"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   procstat.asm
;
; Abstract:
;
;   This module implements routines to save and restore processor control
;   state.
;
; Author:
;
;   David N. Cutler (davec) 24-Aug-2000
;
; Environment:
;
;   Kernel mode only.
;
;--

include ksamd64.inc

        subttl  "Restore Processor Control State"
;++
;
; KiRestoreProcessorControlState(
;     VOID
;     );
;
; Routine Description:
;
;   This routine restores the control state of the current processor.
;
; Arguments:
;
;   ProcessorState (rcx) - Supplies a pointer to a processor state structure.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY KiRestoreProcessorControlState, _TEXT$00

        mov     rax, PsCr0[rcx]         ; restore processor control registers
        mov     cr0, rax                ;
        mov     rax, PsCr3[rcx]         ;
        mov     cr3, rax                ;
        mov     rax, PsCr4[rcx]         ;
        mov     cr4, rax                ;

        xor     eax, eax                ; restore debug registers
        mov     dr7, rax                ;
        mov     rax, PsKernelDr0[rcx]   ;
        mov     dr0, rax                ;
        mov     rax, PsKernelDr1[rcx]   ;
        mov     dr1, rax                ;
        mov     rax, PsKernelDr2[rcx]   ;
        mov     dr2, rax                ;
        mov     rax, PsKernelDr3[rcx]   ;
        mov     dr3, rax                ;
        xor     edx, edx                ;
        mov     dr6, rdx                ;
        mov     rax, PsKernelDr7[rcx]   ;
        mov     dr7, rax                ;

        lgdt    fword ptr PsGdtr[rcx]   ; restore GDTR
        lidt    fword ptr PsIdtr[rcx]   ; restore IDTR

;
; Force the TSS descriptor into a non-busy state, so we don't fault
; when we load the TR.
;

	movzx	eax, word ptr PsTr[rcx] ; rax == TSS selector
	add	rax, PsGdtr[rcx]+2	; rax -> TSS GDT entry
	and	byte ptr [rax]+5, NOT 2 ; Busy bit clear
        ltr     word ptr PsTr[rcx]      ; restore TR

	sub	eax, eax		; load a NULL selector into the ldt
	lldt	ax			

        ldmxcsr dword ptr PsMxCsr[rcx]  ; restore XMM control/status
        ret                             ; return

        LEAF_END KiRestoreProcessorControlState, _TEXT$00

        subttl  "Save Processor Control State"
;++
;
; KiSaveProcessorControlState(
;     PKPROCESSOR_STATE ProcessorState
;     );
;
; Routine Description:
;
;   This routine saves the control state of the current processor.
;
; Arguments:
;
;   ProcessorState (rcx) - Supplies a pointer to a processor state structure.
;
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY KiSaveProcessorControlState, _TEXT$00

        mov     rax, cr0                ; save processor control state
        mov     PsCr0[rcx], rax         ;
        mov     rax, cr2                ;
        mov     PsCr2[rcx], rax         ;
        mov     rax, cr3                ;
        mov     PsCr3[rcx], rax         ;
        mov     rax, cr4                ;
        mov     PsCr4[rcx], rax         ;

        mov     rax, dr0                ; save debug registers
        mov     PsKernelDr0[rcx], rax   ;
        mov     rax, dr1                ;
        mov     PsKernelDr1[rcx], rax   ;
        mov     rax, dr2                ;
        mov     PsKernelDr2[rcx], rax   ;
        mov     rax, dr3                ;
        mov     PsKernelDr3[rcx], rax   ;
        mov     rax, dr6                ;
        mov     PsKernelDr6[rcx], rax   ;
        mov     rax, dr7                ;
        mov     PsKernelDr7[rcx], rax   ;
        xor     eax, eax                ;
        mov     dr7, rax                ;

        sgdt    fword ptr PsGdtr[rcx]   ; save GDTR
        sidt    fword ptr PsIdtr[rcx]   ; save IDTR

        str     word ptr PsTr[rcx]      ; save TR
        sldt    word ptr PsLdtr[rcx]    ; save LDTR

        stmxcsr dword ptr PsMxCsr[rcx]  ; save XMM control/status
        ret                             ; return

        LEAF_END KiSaveProcessorControlState, _TEXT$00

        subttl  "Restore Floating Point State"
;++
;
; NTSTATUS
; KiRestoreFloatingPointState(
;     PKFLOATING_STATE SaveArea
;     );
;
; Routine Description:
;
;   This routine restore the floating status and control information from
;   the specified save area.
;
; Arguments:
;
;   SaveArea (rcx) - Supplies a pointer to a floating state save area.
;
; Return Value:
;
;    STATUS_SUCCESS.
;
;--

        LEAF_ENTRY KeRestoreFloatingPointState, _TEXT$00

        ldmxcsr FsMxCsr[rcx]            ; restore floating status/control
        xor     eax, eax                ; set success status
        ret                             ; return

        LEAF_END KeRestoreFloatingPointState, _TEXT$00

        subttl  "Save Floating Point State"
;++
;
; NTSTATUS
; KisaveFloatingPointState(
;     PKFLOATING_STATE SaveArea
;     );
;
; Routine Description:
;
;   This routine saves the floating status and control information in the
;   specified save area and sets the control information to the system
;   defautl value.
;
; Arguments:
;
;   SaveArea (rcx) - Supplies a pointer to a floating state save area.
;
; Return Value:
;
;    STATUS_SUCCESS.
;
;--

        LEAF_ENTRY KeSaveFloatingPointState, _TEXT$00

        stmxcsr FsMxCsr[rcx]            ; save floating status/control
        ldmxcsr dword ptr gs:[PcMxCsr]  ; set default XMM control/status
        xor     eax, eax                ; set success status
        ret                             ;

        LEAF_END KeSaveFloatingPointState, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\queuelock.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    spinlock.c

Abstract:

    This module implements the platform specific functions for acquiring
    and releasing spin locks.

Author:

    David N. Cutler (davec) 12-Jun-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

__forceinline
VOID
KxAcquireQueuedSpinLock (
    IN PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    This function acquires a queued spin lock at the current IRQL.

Arguments:

    LockQueue - Supplies a pointer to a spin lock queue.

Return Value:

    None.

--*/

{

    PKSPIN_LOCK_QUEUE TailQueue;

    //
    // Insert the specified lock queue entry at the end of the lock queue
    // list. If the list was previously empty, then lock ownership is
    // immediately granted. Otherwise, wait for ownership of the lock to
    // be granted.
    //

#if !defined(NT_UP)

    TailQueue = InterlockedExchangePointer((PVOID *)LockQueue->Lock,
                                           LockQueue);

    if (TailQueue != NULL) {
        LockQueue->Lock = (PKSPIN_LOCK)((ULONG64)LockQueue->Lock | LOCK_QUEUE_WAIT);
        TailQueue->Next = LockQueue;
        do {
        } while (((ULONG64)LockQueue->Lock & LOCK_QUEUE_WAIT) != 0);
    }

#endif

    return;
}

__forceinline
LOGICAL
KxTryToAcquireQueuedSpinLock (
    IN PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    This function attempts to acquire the specified queued spin lock at
    the current IRQL.

Arguments:

    LockQueue - Supplies a pointer to a spin lock queue.

Return Value:

    A value of TRUE is returned is the specified queued spin lock is
    acquired. Otherwise, a value of FALSE is returned.

--*/

{

    //
    // Insert the specified lock queue entry at the end of the lock queue
    // list iff the lock queue list is currently empty. If the lock queue
    // was empty, then lock ownership is granted and TRUE is returned.
    // Otherwise, FALSE is returned.
    //

#if !defined(NT_UP)

    if ((*LockQueue->Lock != 0) ||
        (InterlockedCompareExchangePointer((PVOID *)LockQueue->Lock,
                                                  LockQueue,
                                                  NULL) != NULL)) {
        return FALSE;

    }

#endif

    return TRUE;
}

__forceinline
VOID
KxReleaseQueuedSpinLock (
    IN PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    The function release a queued spin lock at the current IRQL.

Arguments:

    LockQueue - Supplies a pointer to a spin lock queue.

Return Value:

    None.

--*/

{

    PKSPIN_LOCK_QUEUE NextQueue;

    //
    // Attempt to release the lock. If the lock queue is not empty, then wait
    // for the next entry to be written in the lock queue entry and then grant
    // ownership of the lock to the next lock queue entry.
    //

#if !defined(NT_UP)

    NextQueue = LockQueue->Next;
    if (NextQueue == NULL) {
        if (InterlockedCompareExchangePointer((PVOID *)LockQueue->Lock,
                                              NULL,
                                              LockQueue) == LockQueue) {
            return;
        }

        do {
        } while ((NextQueue = LockQueue->Next) == NULL);
    }

    ASSERT(((ULONG64)NextQueue->Lock & LOCK_QUEUE_WAIT) != 0);

    NextQueue->Lock = (PKSPIN_LOCK)((ULONG64)NextQueue->Lock ^ LOCK_QUEUE_WAIT);

#endif

    return;
}

#undef KeAcquireQueuedSpinLock

KIRQL
KeAcquireQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )

/*++

Routine Description:

    This function raises IRQL to DISPATCH_LEVEL and acquires the specified
    numbered queued spin lock.

Arguments:

    Number  - Supplies the queued spin lock number.

Return Value:

    The previous IRQL is returned as the function value.

--*/

{

    KIRQL OldIrql;

    //
    // Raise IRQL to DISPATCH_LEVEL and acquire the specified queued spin
    // lock.
    //

    OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    KxAcquireQueuedSpinLock(&KeGetCurrentPrcb()->LockQueue[Number]);
    return OldIrql;
}

#undef KeAcquireQueuedSpinLockRaiseToSynch

KIRQL
KeAcquireQueuedSpinLockRaiseToSynch (
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )

/*++

Routine Description:

    This function raises IRQL to SYNCH_LEVEL and acquires the specified
    numbered queued spin lock.

Arguments:

    Number - Supplies the queued spinlock number.

Return Value:

    The previous IRQL is returned as the function value.

--*/

{

    KIRQL OldIrql;

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the specified queued spin
    // lock.
    //

    OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    KxAcquireQueuedSpinLock(&KeGetCurrentPrcb()->LockQueue[Number]);
    return OldIrql;
}

#undef KeAcquireQueuedSpinLockAtDpcLevel

VOID
KeAcquireQueuedSpinLockAtDpcLevel (
    IN PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    This function acquires the specified queued spin lock at the current IRQL.

Arguments:

    LockQueue - Supplies a pointer to the lock queue entry for the specified
        queued spin lock.

Return Value:

    None.

--*/

{

    //
    // Acquire the specified queued spin lock at the current IRQL.
    //

    KxAcquireQueuedSpinLock(LockQueue);
    return;
}

#undef KeTryToAcquireQueuedSpinLock

LOGICAL
KeTryToAcquireQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    OUT PKIRQL OldIrql
    )

/*++

Routine Description:

    This function raises IRQL to DISPATCH_LEVEL and attempts to acquire the
    specified numbered queued spin lock. If the spin lock is already owned,
    then IRQL is restored to its previous value and FALSE is returned.
    Otherwise, the spin lock is acquired and TRUE is returned.

Arguments:

    Number - Supplies the queued spinlock number.

    OldIrql - Supplies a pointer to the variable to receive the old IRQL.

Return Value:

    If the spin lock is acquired a value TRUE is returned. Otherwise, FALSE
    is returned as the function value.

--*/

{

    //
    // Try to acquire the specified queued spin lock at DISPATCH_LEVEL.
    //

    *OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    if (KxTryToAcquireQueuedSpinLock(&KeGetCurrentPrcb()->LockQueue[Number]) == FALSE) {
        KeLowerIrql(*OldIrql);
        return FALSE;

    }

    return TRUE;
}

#undef KeTryToAcquireQueuedSpinLockRaiseToSynch

LOGICAL
KeTryToAcquireQueuedSpinLockRaiseToSynch (
    IN  KSPIN_LOCK_QUEUE_NUMBER Number,
    OUT PKIRQL OldIrql
    )

/*++

Routine Description:

    This function raises IRQL to SYNCH_LEVEL and attempts to acquire the
    specified numbered queued spin lock. If the spin lock is already owned,
    then IRQL is restored to its previous value and FALSE is returned.
    Otherwise, the spin lock is acquired and TRUE is returned.

Arguments:

    Number - Supplies the queued spinlock number.

    OldIrql - Supplies a pointer to the variable to receive the old IRQL.

Return Value:

    If the spin lock is acquired a value TRUE is returned. Otherwise, FALSE
    is returned as the function value.

--*/

{

    //
    // Try to acquire the specified queued spin lock at SYNCH_LEVEL.
    //

    *OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    if (KxTryToAcquireQueuedSpinLock(&KeGetCurrentPrcb()->LockQueue[Number]) == FALSE) {
        KeLowerIrql(*OldIrql);
        return FALSE;

    }

    return TRUE;
}

#undef KeTryToAcquireQueuedSpinLockAtRaisedIrql

LOGICAL
KeTryToAcquireQueuedSpinLockAtRaisedIrql (
    IN PKSPIN_LOCK_QUEUE LockQueue
    )

/*++

Routine Description:

    This function attempts to acquire the specified queued spin lock at the
    current IRQL.

Arguments:

    LockQueue - Supplies a pointer to a lock queue entry.

Return Value:

    If the spin lock is acquired a value TRUE is returned as the function
    value. Otherwise, FALSE is returned as the function value.

--*/

{

    //
    // Try to acquire the specified queued spin lock at the current IRQL.
    //

    return KxTryToAcquireQueuedSpinLock(LockQueue);
}

#undef KeReleaseQueuedSpinLock

VOID
KeReleaseQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function releases a numbered queued spin lock and lowers the IRQL to
    its previous value.

Arguments:

    Number - Supplies the queued spinlock number.

    OldIrql  - Supplies the previous IRQL value.

Return Value:

    None.

--*/

{

    //
    // Release the specified queued spin lock and lower IRQL.
    //

    KxReleaseQueuedSpinLock(&KeGetCurrentPrcb()->LockQueue[Number]);
    KeLowerIrql(OldIrql);
    return;
}

#undef KeReleaseQueuedSpinLockFromDpcLevel

VOID
KeReleaseQueuedSpinLockFromDpcLevel (
    IN PKSPIN_LOCK_QUEUE LockQueue
    )

/*

Routine Description:

    This function releases a queued spinlock from the current IRQL.

Arguments:

    LockQueue - Supplies a pointer to a lock queue entry.

Return Value:

    None.

--*/

{

    //
    // Release the specified queued spin lock at the current IRQL.
    //

    KxReleaseQueuedSpinLock(LockQueue);
    return;
}

VOID
KeAcquireInStackQueuedSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This function raises IRQL to DISPATCH_LEVEL and acquires the specified
    in stack queued spin lock.

Arguments:

    SpinLock - Supplies the home address of the queued spin lock.

    LockHandle - Supplies the adress of a lock queue handle.

Return Value:

    None.

--*/

{

    //
    // Raise IRQL to DISPATCH_LEVEL and acquire the specified in stack
    // queued spin lock.
    //

    LockHandle->OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    LockHandle->LockQueue.Lock = SpinLock;
    LockHandle->LockQueue.Next = NULL;
    KxAcquireQueuedSpinLock(&LockHandle->LockQueue);
    return;
}

VOID
KeAcquireInStackQueuedSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This funtions raises IRQL to SYNCH_LEVEL and acquires the specified
    in stack queued spin lock.

Arguments:

    SpinLock - Supplies the home address of the queued spin lock.

    LockHandle - Supplies the address of a lock queue handle.

Return Value:

    None.

--*/

{

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the specified in stack
    // queued spin lock.
    //

    LockHandle->OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    LockHandle->LockQueue.Lock = SpinLock;
    LockHandle->LockQueue.Next = NULL;
    KxAcquireQueuedSpinLock(&LockHandle->LockQueue);
    return;
}

VOID
KeAcquireInStackQueuedSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This function acquires the specified in stack queued spin lock at the
    current IRQL.

Arguments:

    SpinLock - Supplies a pointer to thehome address of a spin lock.

    LockHandle - Supplies the address of a lock queue handle.

Return Value:

    None.

--*/

{

    //
    // Acquire the specified in stack queued spin lock at the current
    // IRQL.
    //

    LockHandle->LockQueue.Lock = SpinLock;
    LockHandle->LockQueue.Next = NULL;
    KxAcquireQueuedSpinLock(&LockHandle->LockQueue);
    return;
}

VOID
KeReleaseInStackQueuedSpinLock (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This function releases an in stack queued spin lock and lowers the IRQL
    to its previous value.

Arguments:

    LockHandle - Supplies the address of a lock queue handle.

Return Value:

    None.

--*/

{

    //
    // Release the specified in stack queued spin lock and lower IRQL.
    //

    KxReleaseQueuedSpinLock(&LockHandle->LockQueue);
    KeLowerIrql(LockHandle->OldIrql);
    return;
}

VOID
KeReleaseInStackQueuedSpinLockFromDpcLevel (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

/*++

Routine Description:

    This function releases an in stack queued spinlock at the current IRQL.

Arguments:

   LockHandle - Supplies a pointer to lock queue handle.

Return Value:

    None.

--*/

{

    //
    // Release the specified in stack queued spin lock at the current IRQL.
    //

    KxReleaseQueuedSpinLock(&LockHandle->LockQueue);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\threadbg.asm ===
title  "Thread Startup"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;    threadbg.asm
;
; Abstract:
;
;    This module implements the code necessary to startup a thread in kernel
;    mode.
;
; Author:
;
;    David N. Cutler (davec) 10-Jun-2000
;
; Environment:
;
;    Kernel mode only, IRQL APC_LEVEL.
;
;--

include ksamd64.inc

        altentry KiThreadStartup

        extern  KeBugCheck:proc
        extern  KiExceptionExit:proc

        subttl  "Thread Startup"
;++
;
; Routine Description:
;
;   This routine is called at thread startup. Its function is to call the
;   initial thread procedure. If control returns from the initial thread
;   procedure and a user mode context was established when the thread
;   was initialized, then the user mode context is restored and control
;   is transfered to user mode. Otherwise a bug check will occur.
;
;   N.B. At thread startup the stack contains at least a legacy floating
;        point save area and an exception frame. If the thread is a user
;        mode thread, then it also contains a trap frame. The exception
;        frame contains the system start call address and parameters. As
;        soon as these values are captured the exception frame is deallocated.
;
; Arguments:
;
;   r12 - Supplies a logical value that specifies whether a user mode thread
;       context was established when the thread was initialized.
;
;   r13 - Supplies the starting context parameter for the initial thread
;       routine.
;
;   r14 - Supplies the starting address of the initial thread routine.
;
;   r15 -  Supplies the starting address of the initial system routine.
;
;   rbp - Supplies the address of a trap frame if a user thread is being
;       started. Otherwise, it contains the value 128 and is not meaningful.
;
; Return Value:
;
;    None.
;
;--

        NESTED_ENTRY KxThreadStartup, _TEXT$00

        alloc_stack LEGACY_SAVE_AREA_LENGTH - 8 ; allocate legacy save area

        set_frame  rbx, 0               ; set frame register

        END_PROLOGUE

        sub     rsp, KEXCEPTION_FRAME_LENGTH ; allocate exception frame

        ALTERNATE_ENTRY KiThreadStartup

        mov     rbx, ExRbx[rsp]         ; set frame register
        mov     r12, ExR12[rsp]         ; get user context address
        mov     r13, ExR13[rsp]         ; get startup context parameter
        mov     r14, ExR14[rsp]         ; get initial thread routine address
        mov     r15, ExR15[rsp]         ; get initial system routine address
        test    r12, r12                ; test if user context specified
        jnz     short KiTs10            ; if nz, user context specified
        add     rsp, KEXCEPTION_FRAME_LENGTH - (2 * 8) ; deallocate exception frame
KiTs10: mov     ecx, APC_LEVEL          ; set IRQL to APC level

        SetIrql                         ; 

        mov     rcx, r14                ; set address of thread routine
        mov     rdx, r13                ; set startup context parameter
        call    r15                     ; call system routine
        test    r12, r12                ; test if user context specified
        jz      short KiTs20            ; if z, no user context specified
        jmp     KiExceptionExit         ; finish in exception exit code

KiTs20: mov     rcx, NO_USER_MODE_CONTEXT ; set bug check parameter
        call    KeBugCheck              ; call bug check - no return

        NESTED_END KxThreadStartup, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\spinlock.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    spinlock.c

Abstract:

    This module implements the platform specific functions for acquiring
    and releasing spin locks.

Author:

    David N. Cutler (davec) 12-Jun-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

__forceinline
VOID
KxAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function acquires a spin lock at the current IRQL.

Arguments:

    SpinLock - Supplies a pointer to an spin lock.

Return Value:

    None.

--*/

{

    PKTHREAD Thread;

    //
    // Acquire the specified spin lock at the current IRQL.
    //

#if !defined(NT_UP)

#if DBG

    Thread = KeGetCurrentThread();
    while (InterlockedCompareExchange64((PLONGLONG)SpinLock,
                                        (LONGLONG)Thread,
                                        0) != 0) {

#else

    while (InterlockedExchange64((PLONGLONG)SpinLock,
                                 (LONGLONG)SpinLock) != 0) {

#endif // DBG

        do {
        } while (*(volatile LONGLONG *)SpinLock != 0);
    }

#endif // !defined(NT_UP)

    return;
}

__forceinline
BOOLEAN
KxTryToAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function attempts acquires a spin lock at the current IRQL. If
    the spinlock is already owned, then FALSE is returned. Otherwise,
    TRUE is returned.

Arguments:

    SpinLock - Supplies a pointer to a spin lock.

Return Value:

    If the spin lock is acquired a value TRUE is returned. Otherwise, FALSE
    is returned as the function value.

--*/

{

    PKTHREAD Thread;

    //
    // Try to acquire the specified spin lock at the current IRQL.
    //

#if !defined(NT_UP)

    if (*(volatile ULONGLONG *)SpinLock == 0) {

#if DBG

        Thread = KeGetCurrentThread();
        return InterlockedCompareExchange64((PLONGLONG)SpinLock,
                                            (LONGLONG)Thread,
                                            0) == 0;

#else

        return InterlockedExchange64((PLONGLONG)SpinLock,
                                     (LONGLONG)SpinLock) == 0;

#endif // DBG

    } else {
        return FALSE;
    }

#else

    return TRUE;

#endif // !defined(NT_UP)

}

__forceinline
VOID
KxReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function releases the specified spin lock at the current IRQL.

Arguments:

    SpinLock - Supplies a pointer to a spin lock.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

#if DBG

    ASSERT(*(volatile ULONGLONG *)SpinLock == (ULONGLONG)KeGetCurrentThread());

#endif // DBG

    *(volatile ULONGLONG *)SpinLock = 0;

#endif // !defined(NT_UP)

    return;
}

VOID
KeInitializeSpinLock (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function initializes a spin lock.

Arguments:

    SpinLock - Supplies a pointer to a spin lock.

Return Value:

    None.

--*/

{

    *(volatile ULONGLONG *)SpinLock = 0;
    return;
}

KIRQL
KeAcquireSpinLockRaiseToDpc (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function raises IRQL to DISPATCH_LEVEL and acquires the specified
    spin lock.

Arguments:

    SpinLock - Supplies a pointer to a spin lock.

Return Value:

    The previous IRQL is returned.

--*/

{

    KIRQL OldIrql;

    //
    // Raise IRQL to DISPATCH_LEVEL and acquire the specified spin lock.
    //

    OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    KxAcquireSpinLock(SpinLock);
    return OldIrql;
}

KIRQL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function raises IRQL to SYNCH_LEVEL and acquires the specified
    spin lock.

Arguments:

    SpinLock - Supplies a pointer to a spin lock.

Return Value:

    The previous IRQL is returned as the function value.

--*/

{

    KIRQL OldIrql;

    //
    // Raise IRQL to SYNCH_LEVEL and acquire the specified spin lock.
    //

    OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    KxAcquireSpinLock(SpinLock);
    return OldIrql;
}

VOID
KeAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function acquires a spin lock at the current IRQL.

Arguments:

    SpinLock - Supplies a pointer to an spin lock.

Return Value:

    None.

--*/

{

    //
    // Acquired the specified spin lock at the current IRQL.
    //

    KxAcquireSpinLock(SpinLock);
    return;
}

BOOLEAN
KeTryToAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock,
    OUT PKIRQL OldIrql
    )

/*++

Routine Description:

    This function raises IRQL to DISPATCH level and attempts to acquire a
    spin lock. If the spin lock is already owned, then IRQL is restored to
    its previous value and FALSE is returned. Otherwise, the spin lock is
    acquired and TRUE is returned.

Arguments:

    SpinLock - Supplies a pointer to a spin lock.

    OldIrql - Supplies a pointer to a variable that receives the old IRQL.

Return Value:

    If the spin lock is acquired a value TRUE is returned. Otherwise, FALSE
    is returned.

--*/

{

    //
    // Raise IRQL to DISPATCH level and attempt to acquire the specified
    // spin lock.
    //

    *OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    if (KxTryToAcquireSpinLock(SpinLock) == FALSE) {
        KeLowerIrql(*OldIrql);
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
KeTryToAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function attempts acquires a spin lock at the current IRQL. If
    the spinlock is already owned, then FALSE is returned. Otherwise,
    TRUE is returned.

Arguments:

    SpinLock - Supplies a pointer to a spin lock.

Return Value:

    If the spin lock is acquired a value TRUE is returned. Otherwise, FALSE
    is returned as the function value.

--*/

{

    //
    // Try to acquire the specified spin lock at the current IRQL.
    //

    return KxTryToAcquireSpinLock(SpinLock);
}

VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    This function releases the specified spin lock and lowers IRQL to a
    previous value.

Arguments:

    SpinLock - Supplies a pointer to a spin lock.

    OldIrql - Supplies the previous IRQL value.

Return Value:

    None.

--*/

{

    //
    // Release the specified spin lock and lower IRQL.
    //

    KxReleaseSpinLock(SpinLock);
    KeLowerIrql(OldIrql);
    return;
}

VOID
KeReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function releases a spin lock at the current IRQL.

Arguments:

    SpinLock - Supplies a pointer to a spin lock.

Return Value:

    None.

--*/

{

    //
    // Release the specified spin lock.
    //

    KxReleaseSpinLock(SpinLock);
    return;
}

#if defined(KeTestSpinLock)
#undef KeTestSpinLock
#endif


BOOLEAN
KeTestSpinLock (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    This function tests a spin lock to determine if it is currently owned.
    If the spinlock is already owned, then FALSE is returned. Otherwise,
    TRUE is returned.

Arguments:

    SpinLock - Supplies a pointer to a spin lock.

Return Value:

    If the spin lock is currently owned, then a value of FALSE is returned.
    Otherwise, a value of TRUE is returned.

--*/

{

#if !defined(NT_UP)
    return (*(volatile ULONGLONG *)SpinLock == 0);
#else
    return TRUE;
#endif // !defined(NT_UP)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\procswap.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    procswap.c

Abstract:

    This module implements the platform dependent kernel function to swap
    processes.

Author:

    David N. Cutler (davec) 10-Jun-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

BOOLEAN
KiSwapProcess (
    IN PKPROCESS NewProcess,
    IN PKPROCESS OldProcess
    )

/*++

Routine Description:

    This function swaps the address space to another process by flushing the
    the translation buffer and establishings a new directory table base. It
    also swaps the I/O permission map to the new process.

    N.B. There is code similar to this code in swap context.

    N.B. This code is executed at DPC level.

Arguments:

    NewProcess - Supplies a pointer to the new process object.

    Oldprocess - Supplies a pointer to the old process object.

Return Value:

    None.

--*/

{

    PKSPIN_LOCK_QUEUE LockQueue;
    PKPRCB Prcb;
    PKTSS64 TssBase;

    //
    // Acquire the context swap lock and update the active processor
    // masks for the new and old process.
    //

    Prcb = KeGetCurrentPrcb();

#if !defined(NT_UP)

    LockQueue = &Prcb->LockQueue[LockQueueContextSwapLock];
    KeAcquireQueuedSpinLockAtDpcLevel(LockQueue);
    OldProcess->ActiveProcessors ^= Prcb->SetMember;

    ASSERT((OldProcess->ActiveProcessors & Prcb->SetMember) == 0);

    NewProcess->ActiveProcessors ^= Prcb->SetMember;

    ASSERT((NewProcess->ActiveProcessors & Prcb->SetMember) != 0);

    KeReleaseQueuedSpinLockFromDpcLevel(LockQueue);

#endif // !defined(NT_UP)

    //
    // Set the offset of the I/O permissions map for the new process and
    // load the new directory table base.
    //

    TssBase = KeGetPcr()->TssBase;
    TssBase->IoMapBase = NewProcess->IopmOffset;
    WriteCR3(NewProcess->DirectoryTableBase[0]);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\start.asm ===
title  "System Startup"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   start.asm
;
; Abstract:
;
;   This module implements the code necessary to initially startup the NT
;   system on an AMD64 system.
;
; Author:
;
;   David N. Cutler (davec) 22-Sep-2000
;
; Environment:
;
;    Kernel mode only.
;
;--

include ksamd64.inc

        extern  KdInitSystem:proc
        extern  KeLoaderBlock:qword
        extern  KiBarrierWait:dword
        extern  KiIdleLoop:proc
        extern  KiInitializeBootStructures:proc
        extern  KiInitializeKernel:proc
        extern  KiInitialPCR:byte

TotalFrameLength EQU (LEGACY_SAVE_AREA_LENGTH + KEXCEPTION_FRAME_LENGTH + KSWITCH_FRAME_LENGTH)

        subttl  "System Startup"
;++
;
; Routine Description:
;
;   This routine is called at system startup to perform early initialization
;   and to inititialize the kernel debugger. This allows breaking into the
;   kernel debugger very early during system startup. After kernel debugger
;   initialization, kernel initialization is performed. On return from kernel
;   initialization the idle loop is entered. The idle loop begins execution
;   and immediately finds the system startup (phase 1) thread ready to run.
;   Phase 1 initialization is performed and all other processors are started.
;   As each process starts it also passes through the system startup code, but
;   it does not initialization the kernel debugger.
;
; Arguments:
;
;   LoaderBlock (rcx) - Supplies a pointer to the loader block.
;
; Implicit Arguments:
;
;   When the system starts up the loader has done some initialization. In
;   particular all structures have at least been zeroed and the GDT and
;   TSS have been completely initialized.
;
;   The loader block has been reformatted by the loader into a 64-bit loader
;   block and all pertinent fields have been filled in.
;
;   The address of the PRCB is passed in the loader block (only for processors
;   other than zero).
;
;   The address of the idle thread and idle process are passed in the loader
;   block (only for processors other than zero).
;
;   The GDT and IDT address and limits are contained in the gdtr and idtr
;   registers.
;
;   The address of the TSS must be extraced from the appropriate GDT entry
;   and stored in the PCR.
;
;   The stack register (RSP) is loaded with the idle thread stack and the
;   kernel stack field of the loader block contains the address of the DPC
;   stack.
;
; Return Value:
;
;   None - function does not return.
;
;--

SsFrame struct
        P1Home  dq ?                    ;
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        P5      dq ?                    ; parameter 5
        P6      dq ?                    ; parameter 6
        Fill    dq ?                    ; fill to 8 mode 16
SsFrame ends

        NESTED_ENTRY KiSystemStartup, INIT

        alloc_stack (sizeof SsFrame)    ; allocate stack frame

        END_PROLOGUE

;
; Save the address of the loader block.
;
; N.B. This is the same address for all processors.
;

        mov     KeLoaderBlock, rcx      ; save loader block address

;
; Initialize PCR self address and the current PRCB address.
;

        mov     rdx, LpbPrcb[rcx]       ; get specified PRCB address
        lea     rax, KiInitialPCR + PcPrcb ; get builtin PRCB address
        test    rdx, rdx                ; test if PRCB address specified
        cmovz   rdx, rax                ; if z, set builtin PRCB address
        mov     LpbPrcb[rcx], rdx       ; set loader block PRCB address
        mov     r8, rdx                 ; copy PRCB address
        sub     rdx, PcPrcb             ; compute PCR address
        mov     PcSelf[rdx], rdx        ; set PCR self address
        mov     PcCurrentPrcb[rdx], r8  ; set current PRCB address

;
; Initialize kernel special registers and the address of the GDT, TSS, and
; IDT in the PRCB and PCR.
;
; N.B. The debug registers are zeroed in the PRCB.
;

        mov     r8, cr0                 ; save CR0
        mov     PcCr0[rdx], r8          ;
        mov     r8, cr2                 ; save CR2
        mov     PcCr2[rdx], r8          ;
        mov     r8, cr3                 ; save CR3
        mov     PcCr3[rdx], r8          ;
        mov     r8, cr4                 ; save CR4
        mov     PcCr4[rdx], r8          ;

        sgdt    PcGdtrLimit[rdx]        ; save GDT limit and base
        mov     r8, PcGdtrBase[rdx]     ; set GDT base address
        mov     PcGdt[rdx], r8          ;
        sidt    PcIdtrLimit[rdx]        ; save IDT limit and base
        mov     r9, PcIdtrBase[rdx]     ; set IDT base address
        mov     PcIdt[rdx], r9          ;

        str     word ptr PcTr[rdx]      ; save TR selector
        sldt    word ptr PcLdtr[rdx]    ; save LDT selector

        mov     dword ptr PcMxCsr[rdx], INITIAL_MXCSR ; set initial MXCSR

;
; Set connical selector values (note CS, GS, and SS are already set).
;

        mov     ax, KGDT64_R3_DATA or RPL_MASK ;
        mov     ds, ax                  ;
        mov     es, ax                  ;
        mov     ax, KGDT64_R3_CMTEB or RPL_MASK ;
        mov     fs, ax                  ;

;
; Load a NULL selector into the LDT.
;

        xor     eax, eax                ; set NULL selector for LDT
        lldt    ax                      ; 

;
; Extract TSS address from GDT entry and store in PCR.
;

        mov     ax, KGDT64_SYS_TSS + KgdtBaseLow[r8] ; set low 16-bits
        mov     PcTss[rdx], ax          ;
        mov     al, KGDT64_SYS_TSS + KgdtBaseMiddle[r8] ; set middle 8-bits
        mov     PcTss + 2[rdx], al      ;
        mov     al, KGDT64_SYS_TSS + KgdtBaseHigh[r8] ; set high 8-bits
        mov     PcTss + 3[rdx], al      ;
        mov     eax, KGDT64_SYS_TSS +KgdtBaseUpper[r8] ; set upper 32-bits
        mov     PcTss + 4[rdx], eax     ;

;
; Initialize the GS base and swap addresses.
;

        mov     eax, edx                ; set low 32-bits of address
        shr     rdx, 32                 ; set high 32-bits of address
        mov     ecx, MSR_GS_BASE        ; get GS base address MSR number
        wrmsr                           ; write GS base address
        mov     ecx, MSR_GS_SWAP        ; get GS swap base MSR number
        wrmsr                           ; write GS swap base address

;
; Initialize boot structures.
;

        mov     rcx, KeLoaderBlock      ; set loader block address
        call    KiInitializeBootStructures ; initialize boot structures

;
; Initialize the kernel debugger if this is processor zero.
;

        xor     ecx, ecx                ; set phase to 0
        mov     rdx, KeLoaderBlock      ; set loader block address
        call    KdInitSystem            ; initialize debugger

;
; Raise IRQL to high level and initialize the kernel.
;

KiSS10: mov     ecx, HIGH_LEVEL         ; set high IRQL

        SetIrql                         ;

;
; Reserve space for idle thread stack initialization.
;
; N.B. This reservation ensures that the initialization of the thread stack
;      does not overwrite any information on the current stack which is the
;      same stack.
;

        sub     rsp, TotalFrameLength   ; allocate stack

;
; Initialize kernel.
;

        mov     rax, KeLoaderBlock      ; set loader block address
        mov     rcx, LpbProcess[rax]    ; set idle process address
        mov     rdx, LpbThread[rax]     ; set idle thread address
        mov     r8, gs:[PcTss]          ; set idle stack address
        mov     r8, TssRsp0[r8]         ;
        mov     r9, LpbPrcb[rax]        ; set PRCB address
        mov     r10b, PbNumber[r9]      ; set processor number
        mov     SsFrame.P5[rsp], r10    ;
        mov     SsFrame.P6[rsp], rax    ; set loader block address
        call    KiInitializeKernel      ; Initialize kernel

;
; Reset stack to include only the space for the legacy NPX state.
;

        mov     rcx, gs:[PcTss]         ; get TSS address
        mov     rcx, TssRsp0[rcx]       ; get idle stack address
        lea     rsp, (-LEGACY_SAVE_AREA_LENGTH)[rcx] ; deallocate stack space

;
; Enable interrupts, lower IRQL to dispatch level, and set the wait IRQL for
; the idle thread.
;

        sti                             ; enable interrupts
        mov     ecx, DISPATCH_LEVEL     ; set dispatch IRQL

        SetIrql                         ;

        mov     rcx, gs:[PcCurrentThread] ; get current thread address
        mov     byte ptr ThWaitIrql[rcx], DISPATCH_LEVEL ; set wait IRQL

;
; In a multiprocessor system the boot processor proceeds directly into the
; idle loop. As other processors start executing, however, they do not enter
; the idle loop directly - they spin until all processors have been started
; and the boot master allows them to proceed.
;

ifndef NT_UP

KiSS20: cmp     KiBarrierWait, 0        ; check if barrier set
        jnz     short KiSS20            ; if nz, barrier set

endif

        call    KiIdleLoop              ; enter idle loop - no return

        NESTED_END KisystemStartup, INIT

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\profint.asm ===
title  "Profile Interrupt"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   profint.asm
;
; Abstract:
;
;   This module implements the architecture dependent code necessary to
;   process the profile interrupt.
;
; Author:
;
;   David N. Cutler (davec) 12-Sep-2000
;
; Environment:
;
;   Kernel mode only.
;
;--

include ksamd64.inc

        extern  KiProfileListHead:qword
        extern  KiProfileLock:qword

        subttl  "Profile Interrupt"
;++
;
; VOID
; KeProfileInterruptWithSource (
;     IN KPROFILE_SOURCE ProfileSource
;     )
;
; Routine Description:
;
;   This routine is executed is response to an interrupt generated by one
;   of the profile sources. Its function is to process the system and process
;   profile lists and update bucket hit counters.
;
; Arguments:
;
;   TrapFrame (rcx) - Supplies the address of a trap frame.
;
;   ProfileSource (rdx) - Supplies the source of profile interrupt.
;
; Return Value:
;
;    None.
;
;--

PiFrame struct
        Source  dq ?                    ; profile interrupt source
        Fill    dq ?                    ; fill to 8 mod 16
        SavedRbp dq ?                   ; saved register RBP
PiFrame ends

        NESTED_ENTRY KeProfileInterruptWithSource, _TEXT$00

        push_reg rbp                    ; save nonvolatile register
        alloc_stack (sizeof PiFrame - (1 * 8)) ; allocate stack frame

        END_PROLOGUE

        mov     PiFrame.Source[rsp], rdx ; save interrupt source
        lea     r11, KiProfileLock      ; get address of spin lock
        AcquireSpinLock r11             ; acquire profile spin lock
        mov     rcx, PiFrame.Source[rsp] ; set interrupt source
        mov     rdx, gs:[PcCurrentThread] ; get current thread address
        mov     rdx, ThApcState + AsProcess[rdx] ; get current process address
        add     rdx, PrProfileListHead  ; compute profile listhead address
        call    KiProcessProfileList    ; process profile list
        mov     rcx, PiFrame.Source[rsp] ; set interrupt source
        lea     rdx, KiProfileListHead  ; get system profile listhead address
        call    KiProcessProfileList    ; process profile list
        lea     rcx, KiProfileLock      ; get address of spin lock
        ReleaseSpinLock r11             ; release spin lock
        add     rsp, sizeof PiFrame - (1 * 8) ; deallocate stack frame
        pop     rbp                     ; restore nonvolatile register
        ret                             ; return

        NESTED_END KeProfileInterruptWithSource, _TEXT$00

        subttl  "Process Profile List"
;++
;
; VOID
; KiProcessProfileList (
;     IN KPROFILE_SOURCE Source,
;     IN PLIST_ENTRY ListHead
;     )
;
; Routine Description:
;
;   This routine processes a profile list.
;
; Arguments:
;
;   Source (cx) - Supplies the source of profile interrupt.
;
;   ListHead (rdx) - Supplies a pointer to a profile list.
;
; Implicit Arguments:
;
;   rbp - Supplies a pointer to a trap frame.
;
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY KiProcessProfileList, _TEXT$00

        mov     r8, LsFlink[rdx]        ; get first entry address
        cmp     r8, rdx                 ; check if list is empty
        je      short KiPP30            ; if e, list is empty
        mov     r9, gs:[PcSetMember]    ; get procecessor set member
        mov     r10, TrRip[rbp]         ; get profile interrupt address
        mov     ax, cx                  ; save profile source

;
; Process list entry.
;

KiPP10: cmp     ax, (PfSource - PfProfileListEntry)[r8] ; check for source match
        jne     short KiPP20            ; if ne, source mismatch
        cmp     r10, (PfRangeBase - PfProfileListEntry)[r8] ; check if below base
        jb      short KiPP20            ; if b, address below base
        cmp     r10, (PfRangeLimit - PfProfileListEntry)[r8] ; check if above limit
        jae     short KiPP20            ; if ae, address above limit
        test    r9, (PfAffinity - PfProfileListEntry)[r8] ; check if in set
        jz      short KiPP20            ; if z, processor not in set
        mov     cl, (PfBucketShift - PfProfileListEntry)[r8] ; get shift count
        mov     r11, r10                ; compute offset into profile buffer
        sub     r11, (PfRangeBase - PfProfileListEntry)[r8] ;
        shr     r11, cl                 ;
        and     r11, NOT 3              ;
        mov     rcx, (PfBuffer - PfProfileListEntry)[r8] ; get profile buffer address
        inc     dword ptr [r11][rcx]    ; increment profile bucket
KiPP20: mov     r8, LsFlink[r8]         ; get next entry address
        cmp     r8, rdx                 ; check if end of list
        jne     short KiPP10            ; if ne, not end of list
KiPP30: ret                             ; return

        LEAF_END KiProcessProfileList, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\thredini.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    thredini.c

Abstract:

    This module implements the machine dependent function to set the initial
    context and data alignment handling mode for a process or thread object.

Author:

    David N. Cutler (davec) 4-May-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// The following assert macros are used to check that an input object is
// really the proper type.
//

#define ASSERT_PROCESS(E) {                    \
    ASSERT((E)->Header.Type == ProcessObject); \
}

#define ASSERT_THREAD(E) {                    \
    ASSERT((E)->Header.Type == ThreadObject); \
}

VOID
KiInitializeContextThread (
    IN PKTHREAD Thread,
    IN PKSYSTEM_ROUTINE SystemRoutine,
    IN PKSTART_ROUTINE StartRoutine OPTIONAL,
    IN PVOID StartContext OPTIONAL,
    IN PCONTEXT ContextRecord OPTIONAL
    )

/*++

Routine Description:

    This function initializes the machine dependent context of a thread
    object.

    N.B. This function does not check if context record is accessibile.
         It is assumed the the caller of this routine is either prepared
         to handle access violations or has probed and copied the context
         record as appropriate.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    SystemRoutine - Supplies a pointer to the system function that is to be
        called when the thread is first scheduled for execution.

    StartRoutine - Supplies an optional pointer to a function that is to be
        called after the system has finished initializing the thread. This
        parameter is specified if the thread is a system thread and will
        execute totally in kernel mode.

    StartContext - Supplies an optional pointer to a data structure that
        will be passed to the StartRoutine as a parameter. This parameter
        is specified if the thread is a system thread and will execute
        totally in kernel mode.

    ContextRecord - Supplies an optional pointer a context record which
        contains the initial user mode state of the thread. This parameter
        is specified if the thread will execute in user mode.

Return Value:

    None.

--*/

{

    CONTEXT ContextFrame;
    PKEXCEPTION_FRAME ExFrame;
    ULONG64 InitialStack;
    PLEGACY_SAVE_AREA NpxFrame;
    PKSWITCH_FRAME SwFrame;
    PKTRAP_FRAME TrFrame;

    //
    // Allocate a legacy floating point save area at the base of the thread
    // stack and record the initial stack as this address. All threads have
    // a legacy floating point save are to avoid special cases in the context
    // switch code.
    //

    InitialStack = (ULONG64)Thread->InitialStack;
    NpxFrame = (PLEGACY_SAVE_AREA)(InitialStack - LEGACY_SAVE_AREA_LENGTH);
    RtlZeroMemory(NpxFrame, LEGACY_SAVE_AREA_LENGTH);

    //
    // If a context record is specified, then initialize a trap frame, and
    // an exception frame with the specified user mode context.
    //

    if (ARGUMENT_PRESENT(ContextRecord)) {
        RtlCopyMemory(&ContextFrame, ContextRecord, sizeof(CONTEXT));
        ContextRecord = &ContextFrame;
        ContextRecord->ContextFlags |= CONTEXT_CONTROL;
        ContextRecord->ContextFlags &= ~(CONTEXT_DEBUG_REGISTERS ^ CONTEXT_AMD64);

        //
        // If auto alignment is not specified, then turn on alignment faults.
        //

        ContextRecord->EFlags &= ~EFLAGS_AC_MASK;
        if (Thread->AutoAlignment == FALSE) {
            ContextRecord->EFlags |= EFLAGS_AC_MASK;
        }

        //
        // Allocate a trap frame, an exception frame, and a context switch
        // frame.
        //

        TrFrame = (PKTRAP_FRAME)(((ULONG64)NpxFrame - KTRAP_FRAME_LENGTH));
        ExFrame = (PKEXCEPTION_FRAME)(((ULONG64)TrFrame - KEXCEPTION_FRAME_LENGTH));
        SwFrame = (PKSWITCH_FRAME)(((ULONG64)ExFrame - KSWITCH_FRAME_LENGTH));

        //
        // Set CS and SS for user mode 64-bit execution in the machine frame.
        //

        ContextRecord->SegCs = KGDT64_R3_CODE | RPL_MASK;
        ContextRecord->SegSs = KGDT64_R3_DATA | RPL_MASK;

        //
        // The main entry point for the user thread will be jumped to via a
        // continue operation from the user APC dispatcher. Therefore, the
        // user stack must be initialized to an 8 mod 16 boundary.
        //
        // In addition, we must have room for the home addresses for the
        // first four parameters.
        //

        ContextRecord->Rsp =
            (ContextRecord->Rsp & ~STACK_ROUND) - ((4 * 8) + 8);

        //
        // Zero the exception and trap frames and copy information from the
        // specified context frame to the trap and exception frames.
        //

        RtlZeroMemory(ExFrame, sizeof(KEXCEPTION_FRAME));
        RtlZeroMemory(TrFrame, sizeof(KTRAP_FRAME));
        KeContextToKframes(TrFrame,
                           ExFrame,
                           ContextRecord,
                           ContextRecord->ContextFlags,
                           UserMode);

        //
        // Set the initial legacy floating point control/tag word state and
        // the XMM control/status state.
        //

        NpxFrame->ControlWord = 0x23f;
        TrFrame->MxCsr = INITIAL_MXCSR;
        NpxFrame->StatusWord = 0;
        NpxFrame->TagWord = 0xffff;
        NpxFrame->ErrorOffset = 0;
        NpxFrame->ErrorSelector = 0;
        NpxFrame->ErrorOpcode = 0;
        NpxFrame->DataOffset = 0;
        NpxFrame->DataSelector = 0;

        //
        // Set legacy floating point state to user mode.
        //

        Thread->NpxState = UserMode;

        //
        // Set the saved previous processor mode in the trap frame and the
        // previous processor mode in the thread object to user mode.
        //

        TrFrame->PreviousMode = UserMode;
        Thread->PreviousMode = UserMode;

    } else {

        //
        // Allocate an exception frame and a context switch frame.
        //

        TrFrame = NULL;
        ExFrame = (PKEXCEPTION_FRAME)(((ULONG64)NpxFrame - KEXCEPTION_FRAME_LENGTH));
        SwFrame = (PKSWITCH_FRAME)(((ULONG64)ExFrame - KSWITCH_FRAME_LENGTH));

        //
        // Set legacy floating point state to kernel mode.
        //

        Thread->NpxState = KernelMode;

        //
        // Set the previous mode in thread object to kernel.
        //

        Thread->PreviousMode = KernelMode;
    }

    //
    // Initialize context switch frame and set thread start up parameters.
    //

    ExFrame->Rbx = (ULONG64)NpxFrame;
    ExFrame->R12 = (ULONG64)ContextRecord;
    ExFrame->R13 = (ULONG64)StartContext;
    ExFrame->R14 = (ULONG64)StartRoutine;
    ExFrame->R15 = (ULONG64)SystemRoutine;
    SwFrame->MxCsr = INITIAL_MXCSR;
    SwFrame->ApcBypass = APC_LEVEL;
    SwFrame->NpxSave = FALSE;
    SwFrame->Return = (ULONG64)KiThreadStartup;
    SwFrame->Rbp = (ULONG64)TrFrame + 128;

    //
    // Set the initial kernel stack pointer.
    //

    Thread->InitialStack = (PVOID)NpxFrame;
    Thread->KernelStack = SwFrame;
    return;
}

BOOLEAN
KeSetAutoAlignmentProcess (
    IN PKPROCESS Process,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function sets the data alignment handling mode for the specified
    process and returns the previous data alignment handling mode.

Arguments:

    Process  - Supplies a pointer to a dispatcher object of type process.

    Enable - Supplies a boolean value that determines the handling of data
        alignment exceptions for the process. A value of TRUE causes all
        data alignment exceptions to be automatically handled by the kernel.
        A value of FALSE causes all data alignment exceptions to be actually
        raised as exceptions.

Return Value:

    A value of TRUE is returned if data alignment exceptions were previously
    automatically handled by the kernel. Otherwise, FALSE is returned.

--*/

{

    KIRQL OldIrql;
    BOOLEAN Previous;

    ASSERT_PROCESS(Process);

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the previous data alignment handling mode and set the
    // specified data alignment mode.
    //

    Previous = Process->AutoAlignment;
    Process->AutoAlignment = Enable;

    //
    // Unlock dispatcher database, lower IRQL to its previous value, and
    // return the previous data alignment mode.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Previous;
}

BOOLEAN
KeSetAutoAlignmentThread (
    IN PKTHREAD Thread,
    IN BOOLEAN Enable
    )

/*++

Routine Description:

    This function sets the data alignment handling mode for the specified
    thread and returns the previous data alignment handling mode.

Arguments:

    Thread - Supplies a pointer to a dispatcher object of type thread.

    Enable - Supplies a boolean value that determines the handling of data
        alignment exceptions for the specified thread. A value of TRUE causes
        all data alignment exceptions to be automatically handled by the kernel.
        A value of FALSE causes all data alignment exceptions to be actually
        raised as exceptions.

Return Value:

    A value of TRUE is returned if data alignment exceptions were previously
    automatically handled by the kernel. Otherwise, FALSE is returned.

--*/

{

    BOOLEAN Previous;
    PKAPC Apc;
    PKEVENT Event;
    KIRQL OldIrql;

    ASSERT_THREAD(Thread);

    //
    // Raise IRQL and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // Capture the previous data alignment handling mode and set the
    // specified data alignment mode.
    //

    Previous = Thread->AutoAlignment;
    Thread->AutoAlignment = Enable;

    //
    // Unlock dispatcher database and lower IRQL.
    //

    KiUnlockDispatcherDatabase(OldIrql);
    return Previous;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\timindex.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    timindex.asm

Abstract:

    This module implements the code necessary to compute the timer table
    index for a timer.

Author:

    David N. Cutler (davec) 16-Jun-2000

Environment:

    Any mode.

Revision History:

--*/

#include "ki.h"

ULONG
KiComputeTimerTableIndex (
    IN LARGE_INTEGER Interval,
    IN LARGE_INTEGER CurrentTime,
    IN PKTIMER Timer
    )

/*++

Routine Description:

    This function computes the timer table index for the specified timer
    object and stores the due time in the timer object.

    N.B. The interval parameter is guaranteed to be negative since it is
         expressed as relative time.

    The formula for due time calculation is:

    Due Time = Current Time - Interval

    The formula for the index calculation is:

    Index = (Due Time / Maximum time) & (Table Size - 1)

    The time increment division is performed using reciprocal multiplication.

Arguments:

    Interval - Supplies the relative time at which the timer is to
        expire.

    CurrentCount - Supplies the current system tick count.

    Timer - Supplies a pointer to a dispatch object of type timer.

Return Value:

    The time table index is returned as the function value and the due
    time is stored in the timer object.

--*/

{

    LONG64 DueTime;
    LONG64 HighTime;
    ULONG Index;

    //
    // Compute the due time of the timer.
    //

    DueTime = CurrentTime.QuadPart - Interval.QuadPart;
    Timer->DueTime.QuadPart = DueTime;

    //
    // Compute the timer table index.
    //

    HighTime = MultiplyHigh(DueTime, KiTimeIncrementReciprocal.QuadPart);
    Index = (ULONG)(HighTime >> KiTimeIncrementShiftCount);
    return (Index & (TIMER_TABLE_SIZE - 1));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\zero.asm ===
title  "Zero Page"
;++
;
; Copyright (c) 2001  Microsoft Corporation
;
; Module Name:
;
;   zero.asm
;
; Abstract:
;
;   This module implements the architecture dependent code necessary to
;   zero a page of memory is the fastest possible way.
;
; Author:
;
;   David N. Cutler (davec) 9-Jan-2001
;
; Environment:
;
;   Kernel mode only.
;
;--

include ksamd64.inc

        subttl  "Zero Page"
;++
;
; VOID
; KeZeroPage (
;     IN PVOID PageBase
;     )
;
; Routine Description:
;
;   This routine zeros the specfied page of memory using nontemporal moves.
;
; Arguments:
;
;   PageBase (rcx) - Supplies the address of the page to zero.
;
; Return Value:
;
;    None.
;
;--

        LEAF_ENTRY KeZeroPage, _TEXT$00

        pxor    xmm0, xmm0              ; clear register
        mov     eax, PAGE_SIZE / 128    ; compute loop count
KeZP10: movntdq 0[rcx], xmm0            ; zero 128-byte block
        movntdq 16[rcx], xmm0           ;
        movntdq 32[rcx], xmm0           ;
        movntdq 48[rcx], xmm0           ;
        movntdq 64[rcx], xmm0           ;
        movntdq 80[rcx], xmm0           ;
        movntdq 96[rcx], xmm0           ;
        movntdq 112[rcx], xmm0          ;
        add     rcx, 128                ; advance to next block
        dec     eax                     ; decrement loop count
        jnz     short KeZP10            ; if nz, more bytes to zero
        sfence                          ; force stores to complete
        ret                             ;


        LEAF_END KeZeroPage, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\trap.asm ===
title  "Trap Processing"
;++
;
; Copyright (c) 2000  Microsoft Corporation
;
; Module Name:
;
;   trap.asm
;
; Abstract:
;
;   This module implements the code necessary to field and process AMD64
;   trap conditions.
;
; Author:
;
;   David N. Cutler (davec) 28-May-2000
;
; Environment:
;
;   Kernel mode only.
;
;--

include ksamd64.inc

        altentry KiExceptionExit
        altentry KiSystemService
        altentry KiSystemServiceCopyEnd
        altentry KiSystemServiceCopyStart
        altentry KiSystemServiceExit

        extern  ExpInterlockedPopEntrySListFault:byte
        extern  ExpInterlockedPopEntrySListResume:byte
        extern  KdpOweBreakpoint:byte
        extern  KdSetOwedBreakpoints:proc
        extern  KeBugCheck:proc
        extern  KeBugCheckEx:proc
        extern  KeGdiFlushUserBatch:qword
        extern  KeServiceDescriptorTableShadow:qword
        extern  KiConvertToGuiThread:proc
        extern  KiDispatchException:proc
        extern  KiEmulateReferenceComplete:proc
        extern  KiInitiateUserApc:proc
        extern  MmAccessFault:proc
        extern  MmUserProbeAddress:qword
        extern  RtlUnwind:proc
        extern  PsWatchEnabled:byte
        extern  PsWatchWorkingSet:proc
        extern  __imp_HalEndSystemInterrupt:qword
        extern  __imp_HalHandleMcheck:qword
        extern  __imp_HalHandleNMI:qword

        subttl  "Divide Error Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of an attempted division by zero
;   or the result of an attempted division does not fit in the destination
;   operand (i.e., the largest negative number divided by minus one).
;
;   N.B. The two possible conditions that can cause this exception are not
;        separated and the exception is reported as a divide by zero.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        NESTED_ENTRY KiDivideErrorFault, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_INTEGER_DIVIDE_BY_ZERO ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        NESTED_END KiDivideErrorFault, _TEXT$00

        subttl  "Debug Trap Or Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a debug trap or fault. The
;   following conditions cause entry to this routine:
;
;   1. Instruction fetch breakpoint fault.
;   2. Data read or write breakpoint trap.
;   3. I/O read or write breakpoint trap.
;   4. General detect condition fault (in-circuit emulator).
;   5. Single step trap (TF set).
;   6. Task switch trap (not possible on this system).
;   7. Execution of an int 1 instruction.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        NESTED_ENTRY KiDebugTrapOrFault, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     rcx, rsp                ; set address of trap frame
        call    KiEmulateReferenceComplete ; complete emulation reference
        or      al, al                  ; test is reference complete
        jnz     kdt10                   ; if nz, reference not completed

        RESTORE_TRAP_STATE <Volatile>   ; restore trap state and exit

kdt10:  mov     ecx, STATUS_SINGLE_STEP ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        NESTED_END KiDebugTrapOrFault, _TEXT$00

        subttl  "Nonmaskable Interrupt"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a nonmaskable interrupt. A
;   switch to the panic stack occurs before the exception frame is pushed
;   on the stack.
;
;   N.B. This routine executes on the panic stack.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack and the HAL is
;   called to determine if the nonmaskable interrupt is fatal. If the HAL
;   call returns, then system operation is continued.
;
;--

        NESTED_ENTRY KiNmiInterrupt, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        xor     ecx, ecx                ; set parameter value
        call    __imp_HalHandleNMI      ; give HAL a chance to handle NMI

        RESTORE_TRAP_STATE <Volatile>   ; restore trap state and exit

        NESTED_END KiNmiInterrupt, _TEXT$00

        subttl  "Breakpoint Trap"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the execution of an int 3
;   instruction.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        NESTED_ENTRY KiBreakpointTrap, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_BREAKPOINT  ; set exception code
        mov     edx, 1                  ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        dec     r8                      ;
        mov     r9d, BREAKPOINT_BREAK   ; set parameter 1 value
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        NESTED_END KiBreakpointTrap, _TEXT$00

        subttl  "Overflow Trap"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the execution of an into
;   instruction when the OF flag is set.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        NESTED_ENTRY KiOverflowTrap, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_INTEGER_OVERFLOW ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        dec     r8                      ;
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        NESTED_END KiOverflowTrap, _TEXT$00

        subttl  "Bound Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the execution of a bound
;   instruction and when the bound range is exceeded.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        NESTED_ENTRY KiBoundFault, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_ARRAY_BOUNDS_EXCEEDED ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        NESTED_END KiBoundFault, _TEXT$00

        subttl  "Invalid Opcode Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the execution of an invalid
;   instruction.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        NESTED_ENTRY KiInvalidOpcodeFault, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_ILLEGAL_INSTRUCTION ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        NESTED_END KiInvalidOpcodeFault, _TEXT$00

        subttl  "NPX Not Available Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the numeric coprocessor not
;   being available for one of the following conditions:
;
;   1. A floating point instruction was executed and EM is set in CR0 -
;       this condition should never happen since EM will never be set.
;
;   2. A floating point instruction was executed and the TS flag is set
;       in CR0 - this condition should never happen since TS will never
;       be set.
;
;   3. A WAIT of FWAIT instruction was executed and the MP and TS flags
;       are set in CR0 - this condition should never occur since neither
;       TS nor MP will ever be set.
;
;   N.B. The NPX state should always be available.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack and bug check
;   is called.
;
;--

        NESTED_ENTRY KiNpxNotAvailableFault, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     r8, TrRip[rbp]          ; set parameter 5 to exception address
        mov     TrP5[rbp], r8           ;
        mov     r9, cr4                 ; set parameter 4 to control register 4
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, 1                  ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KeBugCheckEx            ; bugcheck system - no return
        nop                             ; fill - do not remove

        NESTED_END KiNpxNotAvailableFault, _TEXT$00

        subttl  "Double Fault Abort"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the generation of a second
;   exception while another exception is being generated. A switch to the
;   panic stack occurs before the exception frame is pushed on the stack.
;
;   N.B. This routine executes on the panic stack.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the new stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack and bug check
;   is called.
;
;--

        NESTED_ENTRY KiDoubleFaultAbort, _TEXT$00

        GENERATE_TRAP_FRAME <ErrorCode> ; generate trap frame

        mov     r8, TrRip[rbp]          ; set parameter 5 to exception address
        mov     TrP5[rbp], r8           ;
        mov     r9, cr4                 ; set parameter 4 to control register 4
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, 2                  ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KeBugCheckEx            ; bugcheck system - no return
        nop                             ; fill - do not remove

        NESTED_END KiDoubleFaultAbort, _TEXT$00

        subttl  "NPX Segment Overrrun Abort"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a hardware failure since this
;   vector is obsolete.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the new stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   This trap should never occur and the system is shutdown via a call to
;   bug check.
;
;--

        NESTED_ENTRY KiNpxSegmentOverrunAbort, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     r8, TrRip[rbp]          ; set parameter 5 to exception address
        mov     TrP5[rbp], r8           ;
        mov     r9, cr4                 ; set parameter 4 to control register 4
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, 3                  ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KeBugCheckEx            ; bugcheck system - no return
        nop                             ; fill - do not remove

        NESTED_END KiNpxSegmentOverrunAbort, _TEXT$00

        subttl  "Invalid TSS Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a hardware or software failure
;   since there is no task switching in 64-bit mode and 32-bit code does not
;   have any task state segments.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the new stack.
;   The segment selector index for the segment descriptor that caused the
;   violation is pushed as the error code.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack and bug check
;   is called.
;
;--

        NESTED_ENTRY KiInvalidTssFault, _TEXT$00

        GENERATE_TRAP_FRAME <ErrorCode> ; generate trap frame

        mov     r8, TrRip[rbp]          ; set parameter 5 to exception address
        mov     TrP5[rbp], r8           ;
        mov     r9d, TrErrorCode[rbp]   ; set parameter 4 to selector index
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, 4                  ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KeBugCheckEx            ; bugcheck system - no return
        nop                             ; fill - do not remove

        NESTED_END KiInvalidTssFault, _TEXT$00

        subttl  "Segment Not Present Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a segment not present (P bit 0)
;   fault. This fault can only occur in legacy 32-bit code.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the new stack.
;   The segment selector index for the segment descriptor that is not
;   present is pushed as the error code.
;
; Disposition:
;
;   A standard trap frame is constructed. If the previous mode is user,
;   then the exception parameters are loaded into registers and the exception
;   is dispatched via common code. Otherwise, bug check is called.
;
;--

        NESTED_ENTRY KiSegmentNotPresentFault, _TEXT$00

        GENERATE_TRAP_FRAME <ErrorCode> ; generate trap frame

        mov     r8, TrRip[rbp]          ; get exception address
        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jz      short KiSN10            ; if z, previous mode not user

;
; The previous mode was user.
;

        mov     ecx, STATUS_ACCESS_VIOLATION ; set exception code
        mov     edx, 2                  ; set number of parameters
        mov     r9d, TrErrorCode[rbp]   ; set parameter 1 value
        or      r9d, RPL_MASK           ;
        and     r9d, 0ffffh             ;
        xor     r10, r10                ; set parameter 2 value
        call    KiExceptionDispatch     ; dispatch exception - no return

;
; The previous mode was kernel.
;

KiSN10: mov     TrP5[rbp], r8           ; set parameter 5 to exception address
        mov     r9d, TrErrorCode[rbp]   ; set parameter 4 to selector index
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, 5                  ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KeBugCheckEx            ; bugcheck system - no return
        nop                             ; fill - do not remove

        NESTED_END KiSegmentNotPresentFault, _TEXT$00

        subttl  "Stack Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a stack fault. This fault can
;   only occur in legacy 32-bit code.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the new stack.
;   The segment selector index for the segment descriptor that caused the
;   exception is pushed as the error code.
;
; Disposition:
;
;   A standard trap frame is constructed. If the previous mode is user,
;   then the exception parameters are loaded into registers and the exception
;   is dispatched via common code. Otherwise, bug check is called.
;
;--

        NESTED_ENTRY KiStackFault, _TEXT$00

        GENERATE_TRAP_FRAME <ErrorCode> ; generate trap frame

        mov     r8, TrRip[rbp]          ; get exception address
        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jz      short KiSF10            ; if z, previous mode not user

;
; The previous mode was user.
;

        mov     ecx, STATUS_ACCESS_VIOLATION ; set exception code
        mov     edx, 2                  ; set number of parameters
        mov     r9d, TrErrorCode[rbp]   ; set parameter 1 value
        or      r9d, RPL_MASK           ;
        and     r9d, 0ffffh             ;
        xor     r10, r10                ; set parameter 2 value
        call    KiExceptionDispatch     ; dispatch exception - no return

;
; The previous mode was kernel.
;

KiSF10: mov     TrP5[rbp], r8           ;
        mov     r9d, TrErrorCode[rbp]   ; set parameter 4 to selector index
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, 6                  ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KeBugCheckEx            ; bugcheck system - no return
        nop                             ; fill - do not remove

        NESTED_END KiStackFault, _TEXT$00

        subttl  "General Protection Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a general protection violation.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   The segment selector index for the segment descriptor that caused the
;   exception, the IDT vector number for the descriptor that caused the
;   exception, or zero is pushed as the error code.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        NESTED_ENTRY KiGeneralProtectionFault, _TEXT$00

        GENERATE_TRAP_FRAME <ErrorCode> ; generate trap frame

        mov     ecx, STATUS_ACCESS_VIOLATION ; set exception code
        mov     edx, 2                  ; set number of parameters
        mov     r9d, TrErrorCode[rbp]   ; set parameter 1 to error code
        and     r9d, 0ffffh             ;
        xor     r10, r10                ; set parameter 2 value
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        NESTED_END KiGeneralProtectionFault, _TEXT$00

        subttl  "Page Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a page fault which can occur
;   because of the following reasons:
;
;   1. The referenced page is not present.
;
;   2. The referenced page does not allow the requested access.
;
; Arguments:
;
;   A standard exception frame is pushed by hardware on the kernel stack.
;   A special format error code is pushed which specifies the cause of the
;   page fault as not present, read/write access denied, from user/kernel
;   mode, and attempting to set reserved bits.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack and memory
;   management is called to resolve the page fault. If memory management
;   successfully resolves the page fault, then working set information is
;   recorded, owed breakpoints are inserted, and execution is continued.
;   If memory management cannot resolve the page fault and the fault
;   address is the pop SLIST code, then the execution of the pop SLIST
;   code is continued at the resumption address. Otherwise, if the page
;   fault occurred at an IRQL greater than APC_LEVEL, then the system is
;   shut down via a call to bug check. Otherwise, an appropriate exception
;   is raised.
;
;--

        NESTED_ENTRY KiPageFault, _TEXT$00

        GENERATE_TRAP_FRAME <Virtual>   ; generate trap frame

;
; The registers eax and rcx are loaded with the error code and the virtual
; address of the fault respectively when the trap frame is generated.
;

        shr     eax, 1                  ; isolate load/store and i/d indicators
        and     eax, 09h                ;

;
; Save the load/store indicator and the faulting virtual address in the
; exception record in case an exception is raised.
;

        mov     TrExceptionRecord + ErExceptionInformation[rbp], rax ;
        mov     TrExceptionRecord + ErExceptionInformation + 8[rbp], rcx ;
        lea     r9, (-128)[rbp]         ; set trap frame address
        mov     r8b, TrSegCs[rbp]       ; isolate previous mode
        and     r8b, MODE_MASK          ;
        mov     rdx, rcx                ; set faulting virtual address
        mov     cl, al                  ; set load/store indicator
        call    MmAccessFault           ; attempt to resolve page fault
        test    eax, eax                ; test for successful completion
        jl      short KiPF20            ; if l, not successful completion

;
; If watch working set is enabled, then record working set information.
;

        cmp     PsWatchEnabled, 0       ; check if working set watch enabled
        je      short KiPF10            ; if e, working set watch not enabled
        mov     r8, TrExceptionRecord + ErExceptionInformation + 8[rbp] ;
        mov     rdx, TrRip[rbp]         ; set exception address
        mov     ecx, eax                ; set completion status
        call    PsWatchWorkingSet       ; record working set information

;
; If the debugger has any breakpoints that should be inserted, then attempt
; to insert them now.
;

KiPF10: cmp     KdpOweBreakPoint, 0     ; check if breakpoints are owed
        je      KiPF60                  ; if e, no owed breakpoints
        call    KdSetOwedBreakpoints    ; notify the debugger of new page
        jmp     KiPF60                  ; finish in common code

;
; Check to determine if the page fault occurred in the interlocked pop entry
; SLIST code. There is a case where a page fault may occur in this code when
; the right set of circumstances present themselves. The page fault can be
; ignored by simply restarting the instruction sequence.
;

KiPF20: lea     rcx, ExpInterlockedPopEntrySListFault ; get fault address
        cmp     rcx, TrRip[rbp]         ; check if address matches
        je      KiPF50                  ; if e, address match

;
; Memory management failed to resolve the fault.
;
; STATUS_IN_PAGE_ERROR | 0x10000000 is a special status that indicates a
;       page fault at IRQL greater than APC level. This status causes a
;       bugcheck.
;
; The following status values can be raised:
;
; STATUS_ACCESS_VIOLATION
; STATUS_GUARD_PAGE_VIOLATION
; STATUS_STACK_OVERFLOW
;
; All other status values are sconverted to:
;
; STATUS_IN_PAGE_ERROR
;

        mov     ecx, eax                ; set status code
        mov     edx, 2                  ; set number of parameters
        cmp     ecx, STATUS_IN_PAGE_ERROR or 10000000h ; check for bugcheck code
        je      short KiPF40            ; if e, bugcheck code returned
        cmp     ecx, STATUS_ACCESS_VIOLATION ; check for status values
        je      short KiPF30            ; if e, raise exception with code
        cmp     ecx, STATUS_GUARD_PAGE_VIOLATION ; check for status code
        je      short KiPF30            ; if e, raise exception with code
        cmp     ecx, STATUS_STACK_OVERFLOW ; check for status code
        je      short KiPF30            ; if e, raise exception with code
        mov     ecx, STATUS_IN_PAGE_ERROR ; convert all other status codes
        mov     edx, 3                  ; set number of parameters
        mov     r11d, eax               ; set parameter 3 to real status value

;
; Set virtual address, load/store and i/d indicators, exception address, and
; dispatch the exception.
;

KiPF30: mov     r10, TrExceptionRecord + ErExceptionInformation + 8[rbp] ;
        mov     r9, TrExceptionRecord + ErExceptionInformation[rbp] ;
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return

;
; A page fault occurred at an IRQL that was greater than APC_LEVEL. Set bug
; check parameters and join common code.
;

KiPF40: CurrentIrql                     ; get current IRQL

        mov     r8, TrRip[rbp]          ; set parameter 5 to exception address
        mov     TrP5[rbp], r8           ;
        mov     r9, TrExceptionRecord + ErExceptionInformation[rbp] ;
        and     eax, 0ffh               ; isolate current IRQL
        mov     r8, rax                 ;
        mov     rdx, TrExceptionRecord + ErExceptionInformation + 8[rbp] ;
        mov     ecx, IRQL_NOT_LESS_OR_EQUAL ; set bug check code
        call    KeBugCheckEx            ; bug check system - no return

;
; An unresolved page fault occurred in the pop SLIST code at the resumable
; fault address.
;

KiPF50: lea     rax, ExpInterlockedPopEntrySListResume ; get resume address
        mov     TrRip[rbp], rax         ; set resume address

;
; Test if a user APC should be delivered and exit exception.
;

KiPF60: RESTORE_TRAP_STATE <Volatile>   ; restore trap state and exit

        NESTED_END KiPageFault, _TEXT$00

        subttl  "Legacy Floating Error"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a legacy floating point fault.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack. If the previous
;   mode is user, then reason for the exception is determine, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code. Otherwise, bug check is called.
;
;--

        NESTED_ENTRY KiFloatingErrorFault, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     edx, 7                  ; set unexpected trap number
        test    byte ptr TrSegCs[rbp], MODE_MASK ; check if previous mode user
        jz      KiFE30                  ; if z,  previous mode not user

;
; The previous mode was user mode.
;

        fnstcw  TrErrorCode[rbp]        ; store floating control word
        fnstsw  ax                      ; store floating status word
        mov     cx, TrErrorCode[rbp]    ; get control word
        and     cx, FSW_ERROR_MASK      ; isolate masked exceptions
        not     cx                      ; compute enabled exceptions
        and     ax, cx                  ; isolate exceptions
        mov     ecx, STATUS_FLOAT_INVALID_OPERATION ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        test    ax, FSW_INVALID_OPERATION ; test for invalid operation
        jz      short KiFE10            ; if z, non invalid operation
        test    ax, FSW_STACK_FAULT     ; test is caused by stack fault
        jz      short KiFE20            ; if z, not caused by stack fault
        mov     ecx, STATUS_FLOAT_STACK_CHECK ; set exception code
        jmp     short KiFE20            ; finish in common code

KiFE10: mov     ecx, STATUS_FLOAT_DIVIDE_BY_ZERO ; set exception code
        test    ax, FSW_ZERO_DIVIDE     ; test for divide by zero
        jnz     short KiFE20            ; if nz, divide by zero
        mov     ecx, STATUS_FLOAT_INVALID_OPERATION ; set exception code
        test    ax, FSW_DENORMAL        ; test if denormal operand
        jnz     short KiFE20            ; if nz, denormal operand
        mov     ecx, STATUS_FLOAT_OVERFLOW ; set exception code
        test    ax, FSW_OVERFLOW        ; test if overflow
        jnz     short KiFE20            ; if nz, overflow
        mov     ecx, STATUS_FLOAT_UNDERFLOW ; set exception code
        test    ax, FSW_UNDERFLOW       ; test if underflow
        jnz     short KiFE20            ; if nz, underflow
        mov     ecx, STATUS_FLOAT_INEXACT_RESULT ; set exception code
        mov     edx, 8                  ; set unexpected trap number
        test    ax, FSW_PRECISION       ; test for inexact result
        jz      short KiFE30            ; if z, not inexact result
KiFe20: call    KiExceptionDispatch     ; dispatch exception - no return

;
; The previous mode was kernel mode or the cause of the exception is unknown.
;

KiFE30: mov     r8, TrRip[rbp]          ; set parameter 5 to exception address
        mov     TrP5[rbp], r8           ;
        mov     r9, cr4                 ; set parameter 4 to control register 4
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KeBugCheckEx            ; bugcheck system - no return
        nop                             ; fill - do not remove

        NESTED_END KiFloatingErrorFault, _TEXT$00

        subttl  "Alignment Fault"
;++
;
; Routine Description:
;
;   This routine is entered as the result of an attempted access to unaligned
;   data.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   An error error code of zero is pushed on the stack.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        NESTED_ENTRY KiAlignmentFault, _TEXT$00

        GENERATE_TRAP_FRAME <ErrorCode> ; generate trap frame

        mov     ecx, STATUS_DATATYPE_MISALIGNMENT ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        NESTED_END KiAlignmentFault, _TEXT$00

        subttl  "Machine Check Abort"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a machine check. A switch to
;   the machine check stack occurs before the exception frame is pushed on
;   the stack.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap and exception frame are constructed on the kernel stack
;   and the HAL is called to determine if the machine check abort is fatal.
;   If the HAL call returns, then system operation is continued.
;
;--

        NESTED_ENTRY KiMcheckAbort, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        call    KxMcheckAbort           ; call secondary routine

        RESTORE_TRAP_STATE <Volatile>   ; restore trap state and exit

        NESTED_END KiMcheckAbort, _TEXT$00

;
; This routine generates an exception frame, then calls the HAL to process
; the machine check.
;

        NESTED_ENTRY KxMcheckAbort, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        lea     rcx, (-128)[rbp]        ; set trap frame address
        mov     rdx, rsp                ; set exception frame address
        call    __imp_HalHandleMcheck   ; give HAL a chance to handle mcheck

        RESTORE_EXCEPTION_STATE         ; restore exception state/deallocate

        ret                             ; return

        NESTED_END KxMcheckAbort, _TEXT$00

        subttl  "XMM Floating Error"
;++
;
; Routine Description:
;
;   This routine is entered as the result of a XMM floating point fault.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, mode is user,
;   then reason for the exception is determine, the exception parameters are
;   loaded into registers, and the exception is dispatched via common code.
;   If no reason can be determined for the exception, then bug check is called.
;
;--

        NESTED_ENTRY KiXmmException, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ax, TrMxCsr[rbp]        ; get saved MXCSR
        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jnz     short KiXE05            ; if nz, previous mode user
        stmxcsr TrErrorCode[rbp]        ; get floating control/status word
        mov     ax, TrErrorCode[rbp]    ;  for kernel mode
KiXE05: mov     cx, ax                  ; shift enables into position
        shr     cx, XSW_ERROR_SHIFT     ;
        and     cx, XSW_ERROR_MASK      ; isolate masked exceptions
        not     cx                      ; compute enabled exceptions
        and     ax, cx                  ; isolate exceptions
        mov     ecx, STATUS_FLOAT_INVALID_OPERATION ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        test    ax, XSW_INVALID_OPERATION ; test for invalid operation
        jnz     short KiXE10            ; if z, invalid operation
        mov     ecx, STATUS_FLOAT_DIVIDE_BY_ZERO ; set exception code
        test    ax, XSW_ZERO_DIVIDE     ; test for divide by zero
        jnz     short KiXE10            ; if nz, divide by zero
        mov     ecx, STATUS_FLOAT_INVALID_OPERATION ; set exception code
        test    ax, XSW_DENORMAL        ; test if denormal operand
        jnz     short KiXE10            ; if nz, denormal operand
        mov     ecx, STATUS_FLOAT_OVERFLOW ; set exception code
        test    ax, XSW_OVERFLOW        ; test if overflow
        jnz     short KiXE10            ; if nz, overflow
        mov     ecx, STATUS_FLOAT_UNDERFLOW ; set exception code
        test    ax, XSW_UNDERFLOW       ; test if underflow
        jnz     short KiXE10            ; if nz, underflow
        mov     ecx, STATUS_FLOAT_INEXACT_RESULT ; set exception code
        test    ax, XSW_PRECISION       ; test for inexact result
        jz      short KiXE20            ; if z, not inexact result
KiXE10: call    KiExceptionDispatch     ; dispatch exception - no return

;
; The previous mode was kernel mode or the cause of the exception is unknown.
;

KiXE20: mov     r8, TrRip[rbp]          ; set parameter 5 to exception address
        mov     TrP5[rbp], r8           ;
        mov     r9, cr4                 ; set parameter 4 to control register 4
        mov     r8, cr0                 ; set parameter 3 to control register 0
        mov     edx, 9                  ; set unexpected trap number
        mov     ecx, UNEXPECTED_KERNEL_MODE_TRAP ; set bugcheck code
        call    KeBugCheckEx            ; bugcheck system - no return
        nop                             ; fill - do not remove

        NESTED_END KiXmmException, _TEXT$00

        subttl  "Debug Service Trap"
;++
;
; Routine Description:
;
;   This routine is entered as the result of the execution of an int 2d
;   instruction.
;
; Arguments:
;
;   The standard exception frame is pushed by hardware on the kernel stack.
;   There is no error code for this exception.
;
; Disposition:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   arguments are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        NESTED_ENTRY KiDebugServiceTrap, _TEXT$00

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_BREAKPOINT  ; set exception code
        mov     edx, 1                  ; set number of parameters
        mov     r9, TrRax[rbp]          ; set parameter 1 value
        mov     r8, TrRip[rbp]          ; set exception address
        inc     qword ptr TrRip[rbp]    ; point to int 3 instruction
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        NESTED_END KiDebugServiceTrap, _TEXT$00

        subttl  "System Service Call 32-bit"
;++
;
; Routine Description:
;
;   This routine gains control when a system call instruction is executed
;   from 32-bit mode. System service calls from 32-bit code are not supported
;   and this exception is turned into an invalid opcode fault.
;
;   N.B. This routine is never entered from kernel mode and it executed with
;        interrupts disabled.
;
; Arguments:
;
;   The standard exception frame is pushed on the stack.
;
; Return Value:
;
;   A standard trap frame is constructed on the kernel stack, the exception
;   parameters are loaded into registers, and the exception is dispatched via
;   common code.
;
;--

        NESTED_ENTRY KiSystemCall32, _TEXT$00

        swapgs                          ; swap GS base to kernel PCR
        mov     r8, gs:[PcTss]          ; get address of task state segment
        mov     r9, rsp                 ; save user stack pointer
        mov     rsp, TssRsp0[r8]        ; set kernel stack pointer
        pushq   KGDT64_R3_DATA or RPL_MASK ; push dummy SS selector
        push    r9                      ; push user stack pointer
        pushq   r11                     ; push previous EFLAGS
        pushq   KGDT64_R3_CODE or RPL_MASK ; push dummy 64-bit CS selector
        pushq   rcx                     ; push return address

        GENERATE_TRAP_FRAME             ; generate trap frame

        mov     ecx, STATUS_ILLEGAL_INSTRUCTION ; set exception code
        xor     edx, edx                ; set number of parameters
        mov     r8, TrRip[rbp]          ; set exception address
        call    KiExceptionDispatch     ; dispatch exception - no return
        nop                             ; fill - do not remove

        NESTED_END KiSystemCall32, _TEXT$00

        subttl  "System Service Exception Handler"
;++
;
; EXCEPTION_DISPOSITION
; KiSystemServiceHandler (
;    IN PEXCEPTION_RECORD ExceptionRecord,
;    IN PVOID EstablisherFrame,
;    IN OUT PCONTEXT ContextRecord,
;    IN OUT PDISPATCHER_CONTEXT DispatcherContext
;    )
;
; Routine Description:
;
;   This routine is the exception handler for the system service dispatcher.
;
;   If an unwind is being performed and the system service dispatcher is
;   the target of the unwind, then an exception occured while attempting
;   to copy the user's in-memory argument list. Control is transfered to
;   the system service exit by return a continue execution disposition
;   value.
;
;   If an unwind is being performed and the previous mode is user, then
;   bug check is called to crash the system. It is not valid to unwind
;   out of a system service into user mode.
;
;   If an unwind is being performed and the previous mode is kernel, then
;   the previous mode field from the trap frame is restored to the thread
;   object.
;
;   If an exception is being raised and the exception PC is the address
;   of the system service dispatcher in-memory argument copy code, then an
;   unwind to the system service exit code is initiated.
;
;   If an exception is being raised and the exception PC is not within
;   the range of the system service dispatcher, and the previous mode is
;   not user, then a continue search disposition value is returned. Otherwise,
;   a system service has failed to handle an exception and bug check is
;   called. It is invalid for a system service not to handle all exceptions
;   that can be raised in the service.
;
; Arguments:
;
;   ExceptionRecord (rcx) - Supplies a pointer to an exception record.
;
;   EstablisherFrame (rdx) - Supplies the frame pointer of the establisher
;       of this exception handler.
;
;   ContextRecord (r8) - Supplies a pointer to a context record.
;
;   DispatcherContext (r9) - Supplies a pointer to  the dispatcher context
;       record.
;
; Return Value:
;
;   If bug check is called, there is no return from this routine and the
;   system is crashed. If an exception occured while attempting to copy
;   the user in-memory argument list, then there is no return from this
;   routine, and unwind is called. Otherwise, ExceptionContinueSearch is
;   returned as the function value.
;
;--

ShFrame struct
        P1Home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        P4Home  dq ?                    ;
        Fill    dq ?                    ; fill to 8 mod 16
ShFrame ends

        NESTED_ENTRY KiSystemServiceHandler, _TEXT$00

        alloc_stack (sizeof ShFrame)    ; allocate stack frame

        END_PROLOGUE

        test    dword ptr ErExceptionFlags[rcx], EXCEPTION_UNWIND ; test for unwind
        jnz     short KiSH30            ; if nz, unwind in progress

;
; An exception is in progress.
;
; If the exception PC is the address of the in-memory argument copy code for
; the system service dispatcher, then call unwind to transfer control to the
; system service exit code. Otherwise, check if the previous mode is user
; or kernel mode.
;

        lea     rax, KiSystemServiceCopyStart ; get copy code start address
        cmp     rax, ErExceptionAddress[rcx] ; check if within range
        jb      short KiSH10            ; if b, address not within range
        lea     rax, KiSystemServiceCopyEnd ; get copy code end address
        cmp     rax, ErExceptionAddress[rcx] ; check if within range
        jae     short KiSH10            ; if ae, not within range

;
; The exception was raised by the system service dispatcher argument copy
; code. Unwind to the system service exit with the exception status code as
; the return value.
;

        mov     r9d, ErExceptionCode[rcx] ; set return value
        xor     r8, r8                  ; set exception record address
        mov     rcx, rdx                ; set target frame address
        lea     rdx, KiSystemServiceExit ; set target IP address
        call    RtlUnwind               ; unwind - no return

;
; If the previous mode was kernel mode, then the continue the search for an
; exception handler. Otherwise, bug check the system.
;

KiSH10: mov     rax, gs:[PcCurrentThread] ; get current thread address
        cmp     byte ptr ThPreviousMode[rax], KernelMode ; check for kernel mode
        je      short KiSH20            ; if e, previous mode kernel

;
; Previous mode is user mode - bug check the system.
;

        mov     ecx, SYSTEM_SERVICE_EXCEPTION ; set bug check code
        call    KeBugCheck              ; bug check - no return

;
; Previous mode is kernel mode - continue search for a handler.
;

KiSH20: mov     eax, ExceptionContinueSearch ; set return value
        add     rsp, sizeof ShFrame     ; deallocate stack frame
        ret                             ; return

;
; An unwind is in progress.
;
; If a target unwind is being performed, then continue the unwind operation.
; Otherwise, check if the previous mode is user or kernel mode.
;

KiSH30: test    dword ptr ErExceptionFlags[rcx], EXCEPTION_TARGET_UNWIND ; test for target unwind
        jnz     short KiSH20            ; if nz, target unwind in progress

;
; If the previous mode was kernel mode, then restore the previous mode and
; continue the unwind operation. Otherwise, bug check the system.
;

        mov     rax, gs:[PcCurrentThread] ; get current thread address
        cmp     byte ptr ThPreviousMode[rax], KernelMode ; check for kernel mode
        je      short KiSH40            ; if e, previous mode kernel

;
; Previous mode was user mode - bug check the system.
;

        mov     ecx, SYSTEM_UNWIND_PREVIOUS_USER ; set bug check code
        call    KeBugCheck              ; bug check - no return

;
; Previous mode is kernel mode - restore previous mode and continue unwind
; operation.
;

KiSH40: mov     rcx, ThTrapFrame[rax]   ; get current frame pointer address
        mov     cl, TrPreviousMode[rcx] ; get previous mode
        mov     ThPreviousMode[rax], cl ; restore previous mode
        jmp     short KiSH20            ; finish in common code

        NESTED_END KiSystemServiceHandler, _TEXT$00

        subttl  "System Service Call 64-bit"
;++
;
; Routine Description:
;
;   This routine gains control when a system call instruction is executed
;   from 64-bit mode. The specified system service is executed by locating
;   its routine address in system service dispatch table and calling the
;   specified function.
;
;   N.B. This routine is never entered from kernel mode and it executed with
;        interrupts disabled.
;
; Arguments:
;
;   eax - Supplies the system service number.
;
; Return Value:
;
;   eax - System service status code.
;
;   r10, rdx, r8, and r9 - Supply the first four system call arguments.
;
;   rcx - Supplies the RIP of the system call.
;
;   r11 - Supplies the previous EFLAGS.
;
;--

        NESTED_ENTRY KiSystemCall64, _TEXT$00, KiSystemServiceHandler

        swapgs                          ; swap GS base to kernel PCR
        mov     gs:[PcSavedRcx], rcx    ; save return address
        mov     gs:[PcSavedR11], r11    ; save previous EFLAGS
        mov     rcx, gs:[PcTss]         ; get address of task state segment
        mov     r11, rsp                ; save user stack pointer
        mov     rsp, TssRsp0[rcx]       ; set kernel stack pointer
        pushq   KGDT64_R3_DATA or RPL_MASK ; push dummy SS selector
        push    r11                     ; push user stack pointer
        pushq   gs:[PcSavedR11]         ; push previous EFLAGS
        pushq   KGDT64_R3_CODE or RPL_MASK ; push dummy 64-bit CS selector
        pushq   gs:[PcSavedRcx]         ; push return address
        mov     rcx, r10                ; set first argument value

;
; Generate a trap frame without saving any of the volatile registers, i.e.,
; they are assumed to be destroyed as per the AMD64 calling standard.
;
; N.B. RBX, RDI, and RSI are also saved in this trap frame.
;

        ALTERNATE_ENTRY KiSystemService

        push_frame                      ; mark machine frame
        alloc_stack 8                   ; allocate dummy error code
        push_reg rbp                    ; save standard register
        push_reg rsi                    ; save extra registers
        push_reg rdi                    ;
        push_reg rbx                    ;
        alloc_stack (KTRAP_FRAME_LENGTH - (10 * 8)) ; allocate fixed frame
        set_frame rbp, 128              ; set frame pointer

        END_PROLOGUE

        SAVE_TRAP_STATE <Service>       ; save trap state

        sti                             ; enable interrupts
        mov     rbx, gs:[PcCurrentThread] ; get current thread address
        mov     r10b, TrSegCs[rbp]      ; ioslate system call previous mode
        and     r10b, MODE_MASK         ;
        mov     r11b, ThPreviousMode[rbx] ; save previous mode in trap frame
        mov     TrPreviousMode[rbp], r11b ;
        mov     ThPreviousMode[rbx], r10b ; set thread previous mode
        mov     r10, ThTrapFrame[rbx]   ; save previous frame pointer address
        mov     TrTrapFrame[rbp], r10   ;

;
; Dispatch system service.
;
;   eax - Supplies the system service number.
;   rbx - Supplies the current thread address.
;   rcx - Supplies the first argument if present.
;   rdx - Supplies the second argument if present.
;   r8 - Supplies the third argument if present.
;   r9 - Supplies the fourth argument if present.
;

        ALTERNATE_ENTRY KiSystemServiceRepeat

        mov     ThTrapFrame[rbx], rsp   ; set current frame pointer address
        mov     edi, eax                ; copy system service number
        shr     edi, SERVICE_TABLE_SHIFT ; isolate service table number
        and     edi, SERVICE_TABLE_MASK ;
        mov     esi, edi                ; save service table number
        add     rdi, ThServiceTable[rbx] ; compute service descriptor address
        mov     r10d, eax               ; save system service number
        and     eax, SERVICE_NUMBER_MASK ; isolate service table offset

;
; If the specified system service number is not within range, then attempt
; to convert the thread to a GUI thread and retry the service dispatch.
;

        cmp     eax, SdLimit[rdi]       ; check if valid service
        jae     KiSS50                  ;if ae, not valid service

;
; If the service is a GUI service and the GDI user batch queue is not empty,
; then call the appropriate service to flush the user batch.
;

        cmp     esi, SERVICE_TABLE_TEST ; check if GUI service
        jne     short KiSS10            ; if ne, not GUI service
        mov     r10, ThTeb[rbx]         ; get user TEB adresss
        cmp     dword ptr TeGdiBatchCount[r10], 0 ; check batch queue depth
        je      short KiSS10            ; if e, batch queue empty
        mov     TrRax[rbp], eax         ; save system service table offset
        mov     TrP1Home[rbp], rcx      ; save system service arguments
        mov     TrP2Home[rbp], rdx      ;
        mov     TrP3Home[rbp], r8       ;
        mov     TrP4Home[rbp], r9       ;
        call    KeGdiFlushUserBatch     ; call flush GDI user batch routine
        mov     eax, TrRax[rbp]         ; restore system service table offset
        mov     rcx, TrP1Home[rbp]      ; restore system service arguments
        mov     rdx, TrP2Home[rbp]      ;
        mov     r8, TrP3Home[rbp]       ;
        mov     r9, TrP4Home[rbp]       ;

;
; Check if system service has any in memory arguments.
;

KiSS10: mov     r10, SdBase[rdi]        ; get service table base address
        mov     r10, [r10][rax * 8]     ; get system service routine address
        btr     r10, 0                  ; check if any in memory arguments
        jnc     short KiSS30            ; if nc, no in memory arguments
        mov     TrP1Home[rbp], rcx      ; save first argument if present
        mov     rdi, SdNumber[rdi]      ; get argument table address
        movzx   ecx, byte ptr [rdi][rax] ; get number of in memory bytes
        sub     rsp, rcx                ; allocate stack argument area
        and     spl, 0f0h               ; align stack on 0 mod 16 boundary
        mov     rdi, rsp                ; set copy destination address
        mov     rsi, TrRsp[rbp]         ; get previous stack address
        add     rsi, 5 * 8              ; compute copy source address
        test    byte ptr TrSegCs[rbp], MODE_MASK ; check if previous mode user
        jz      short KiSS20            ; if z, previous mode kernel
        cmp     rsi, MmUserProbeAddress ; check if source address in range
        cmovae  rsi, MmUserProbeAddress ; if ae, reset copy source address
KiSS20: shr     ecx, 3                  ; compute number of quadwords

        ALTERNATE_ENTRY KiSystemServiceCopyStart

        rep     movsq                   ; move arguments to kernel stack

        ALTERNATE_ENTRY KiSystemServiceCopyEnd

        sub     rsp, 4 * 8              ; allocate argument home area
        mov     rcx, TrP1Home[rbp]      ; restore first argument if present

;
; Call system service.
;

KiSS30: call    r10                     ; call system service
        inc     dword ptr gs:[PcSystemCalls] ; increment number of system calls

;
; System service exit.
;
;   eax - Supplies the system service status.
;
;   rbp - Supplies the address of the trap frame.
;

        ALTERNATE_ENTRY KiSystemServiceExit

        mov     rcx, gs:[PcCurrentThread] ; get current thread address
        mov     rdx, TrTrapFrame[rbp]   ; restore frame pointer address
        mov     ThTrapFrame[rcx], rdx   ;
        mov     dl, TrPreviousMode[rbp] ; restore previous mode
        mov     ThPreviousMode[rbx], dl ;
        mov     rbx, TrRbx[rbp]         ; restore extra registers
        mov     rdi, TrRdi[rbp]         ;
        mov     rsi, TrRsi[rbp]         ;

;
; Test if a user APC should be delivered and exit system service.
;

        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jz      KiSS40                  ; if z, previous mode not user

        RESTORE_TRAP_STATE <Service>    ; restore trap state/exit to user mode

KiSS40: RESTORE_TRAP_STATE <Kernel>     ; restore trap state/exit to kernel mode

;
; The specified system service number is not within range. Attempt to convert
; the thread to a GUI thread if the specified system service is a GUI service
; and the thread has not already been converted to a GUI thread.
;

KiSS50: cmp     esi, SERVICE_TABLE_TEST ; check if GUI service
        jne     short KiSS60            ; if ne, not GUI service
        mov     TrRax[rbp], r10d        ; save system service number
        mov     TrP1Home[rbp], rcx      ; save system service arguments
        mov     TrP2Home[rbp], rdx      ;
        mov     TrP3Home[rbp], r8       ;
        mov     TrP4Home[rbp], r9       ;
        call    KiConvertToGuiThread    ; attempt to convert to GUI thread
        or      eax, eax                ; check if service was successful
        mov     eax, TrRax[rbp]         ; restore system service number
        mov     rcx, TrP1Home[rbp]      ; restore system service arguments
        mov     rdx, TrP2Home[rbp]      ;
        mov     r8, TrP3Home[rbp]       ;
        mov     r9, TrP4Home[rbp]       ;
        jz      KiSystemServiceRepeat   ; if z, successful conversion to GUI

;
; The conversion to a GUI thread failed. The correct return value is encoded
; in a byte table indexed by the service number that is at the end of the
; service address table. The encoding is as follows:
;
;   0 - return 0.
;   -1 - return -1.
;   1 - return status code.
;

        lea     rdi, KeServiceDescriptorTableShadow + SERVICE_TABLE_TEST ;
        mov     esi, SdLimit[rdi]       ; get service table limit
        mov     rdi, SdBase[rdi]        ; get service table base
        lea     rdi, [rdi][rsi * 8]     ; get ending service table address
        and     eax, SERVICE_NUMBER_MASK ; isolate service number
        movsx   eax, byte ptr [rdi][rax] ; get status byte value
        or      eax, eax                ; check for 0 or - 1
        jle     KiSystemServiceExit     ; if le, return status byte value
KiSS60: mov     eax, STATUS_INVALID_SYSTEM_SERVICE ; set return status
        jmp     KiSystemServiceExit     ; finish in common code

        NESTED_END KiSystemCall64, _TEXT$00

        subttl  "Common Exception Dispatch"
;++
;
; Routine Description:
;
;   This routine allocates an exception frame on stack, saves nonvolatile
;   machine state, and calls the system exception dispatcher.
;
;   N.B. It is the responsibility of the caller to initialize the exception
;        record.
;
; Arguments:
;
;   ecx - Supplies the exception code.
;
;   edx - Supplies the number of parameters.
;
;   r8 - Supplies the exception address.
;
;   r9 - r11 - Supply the exception  parameters.
;
;   rbp - Supplies a pointer to the trap frame.
;
;   rsp - Supplies a pointer to the trap frame.
;
; Return Value:
;
;    There is no return from this function.
;
;--

        NESTED_ENTRY KiExceptionDispatch, _TEXT$00

        GENERATE_EXCEPTION_FRAME        ; generate exception frame

        lea     rax, TrExceptionRecord[rbp] ; get exception record address
        mov     ErExceptionCode[rax], ecx ; set exception code
        xor     ecx, ecx                ;
        mov     dword ptr ErExceptionFlags[rax], ecx ; clear exception flags
        mov     ErExceptionRecord[rax], rcx ; clear exception record address
        mov     ErExceptionAddress[rax], r8 ; set exception address
        mov     ErNumberParameters[rax], edx ; set number of parameters
        mov     ErExceptionInformation[rax], r9 ; set exception parameters
        mov     ErExceptionInformation + 8[rax], r10 ;
        mov     ErExceptionInformation + 16[rax], r11 ;
        mov     r9b, TrSegCs[rbp]       ; isolate previous mode
        and     r9b, MODE_MASK          ;
        jz      short KiEE10            ; if z, previous mode not user
        lea     rbx, (KTRAP_FRAME_LENGTH - 128)[rbp] ; get save area address
        fnsaved [rbx]                   ; save legacy floating state
KiEE10: mov     byte ptr ExP5[rsp], TRUE ; set first chance parameter
        lea     r8, (-128)[rbp]         ; set trap frame address
        mov     rdx, rsp                ; set exception frame address
        mov     rcx, rax                ; set exception record address
        call    KiDispatchException     ; dispatch exception

        subttl  "Common Exception Exit"
;++
;
; Routine Description:
;
;   This routine is called to exit an exception.
;
;   N.B. This transfer of control occurs from:
;
;        1. a fall through from above.
;        2. the exit from a continue system service.
;        3. the exit form a raise exception system service.
;        4. the exit into user mode from thread startup.
;
;   N.B. Control is transfered to this code via a jump.
;
; Arguments:
;
;   rbp - Supplies the address of the trap frame.
;
;   rsp - Supplies the address of the exception frame.
;
; Return Value:
;
;   Function does not return.
;
;--

        ALTERNATE_ENTRY KiExceptionExit

        RESTORE_EXCEPTION_STATE <NoPop> ; restore exception state/deallocate

        RESTORE_TRAP_STATE <Volatile>   ; restore trap state and exit

        NESTED_END KiExceptionDispatch, _TEXT$00

        subttl "Check for Allowable Invalid Address"
;++
;
; BOOLEAN
; KeInvalidAccessAllowed (
;     IN PVOID TrapFrame
;     )
;
; Routine Description:
;
;   This function checks to determine if the fault address in the specified
;   trap frame is an allowed fault address. Currently there is only one such
;   address and it is the pop SLIST fault address.
;
; Arguments:
;
;   TrapFrame (rcx) - Supplies a pointer to a trap frame.
;
; Return value:
;
;   If the fault address is allowed, then TRUE is returned. Otherwise, FALSE
;   is returned.
;
;--

        LEAF_ENTRY KeInvalidAccessAllowed, _TEXT$00

        lea     rdx, ExpInterlockedPopEntrySListFault ; get fault address
        cmp     rdx, TrRip[rcx]         ; check if address match
        sete    al                      ; set return value
        ret                             ; return

        LEAF_END  KeInvalidAccessAllowed, _TEXT$00

        subttl  "System Service Linkage"
;++
;
; VOID
; KiServiceLinkage (
;     VOID
;     )
;
; Routine Description:
;
;   This is a dummay function that only exists to make trace back through
;   a kernel mode to kernel mode system call work.
; Arguments:
;
;   None.
;
; Return value:
;
;   None.
;
;--

        LEAF_ENTRY KiServiceLinkage, _TEXT$00

        ret                             ;

        LEAF_END  KiServiceLinkage, _TEXT$00

        subttl  "Unexpected Interrupt Code"
;++
;
; RoutineDescription:
;
;   An entry in the following table is generated for each vector that can
;   receive an unexpected interrupt. Each entry in the table contains code
;   to push the vector number on the stack and then jump to common code to
;   process the unexpected interrupt.
;
; Arguments:
;
;    None.
;
;--

        NESTED_ENTRY KiUnexpectedInterrupt, _TEXT$00

        .pushframe code                 ; mark machine frame
        .pushreg rbp                    ; mark nonvolatile register push

        GENERATE_INTERRUPT_FRAME <Vector>  ; generate interrupt frame

        mov     ecx, eax                ; compute interrupt IRQL
        shr     ecx, 4                  ;

	ENTER_INTERRUPT <NoEOI>         ; raise IRQL and enable interrupts

        EXIT_INTERRUPT                  ; do EOI, lower IRQL, and restore state

        NESTED_END KiUnexpectedInterrupt, _TEXT$00

        subttl  "Unexpected Interrupt Dispatch Code"
;++
;   The following code is a table of unexpected interrupt dispatch code
;   fragments for each interrupt vector. Empty interrupt vectors are
;   initialized to jump to this code which pushes the interrupt vector
;   number on the stack and jumps to the above unexpected interrupt code.
;--

EMPTY_VECTOR macro Vector

        LEAF_ENTRY KxUnexpectedInterrupt&Vector, _TEXT$00

        push    &Vector                 ; push vector number
        push    rbp                     ; push nonvolatile register
        jmp     KiUnexpectedInterrupt   ; finish in common code

        LEAF_END KxUnexpectedInterrupt&Vector,  _TEXT$00

        endm

interrupt_vector = 0

        rept (MAXIMUM_PRIMARY_VECTOR + 1)

        EMPTY_VECTOR %interrupt_vector

interrupt_vector = interrupt_vector + 1

        endm

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\amd64\xcpt4.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    xcpt4.c

Abstract:

    This module implements user mode exception tests.

Author:

    David N. Cutler (davec) 18-Sep-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#pragma hdrstop
#include "setjmpex.h"

#include "float.h"

#pragma warning(disable:4532)

//
// Define switch constants.
//

#define BLUE 0
#define RED 1

//
// Define guaranteed fault.
//

#define FAULT *(volatile int *)0

//
// Define function prototypes.
//

VOID
addtwo (
    IN LONG First,
    IN LONG Second,
    IN PLONG Place
    );

VOID
bar1 (
    IN NTSTATUS Status,
    IN PLONG Counter
    );

VOID
bar2 (
    IN PLONG BlackHole,
    IN PLONG BadAddress,
    IN PLONG Counter
    );

VOID
dojump (
    IN jmp_buf JumpBuffer,
    IN PLONG Counter
    );

LONG
Echo(
    IN LONG Value
    );

VOID
eret (
    IN NTSTATUS Status,
    IN PLONG Counter
    );

VOID
except1 (
    IN PLONG Counter
    );

ULONG
except2 (
    IN PEXCEPTION_POINTERS ExceptionPointers,
    IN PLONG Counter
    );

ULONG
except3 (
    IN PEXCEPTION_POINTERS ExceptionPointers,
    IN PLONG Counter
    );

VOID
foo1 (
    IN NTSTATUS Status
    );

VOID
foo2 (
    IN PLONG BlackHole,
    IN PLONG BadAddress
    );

VOID
fret (
    IN PLONG Counter
    );

BOOLEAN
Tkm (
    VOID
    );

VOID
Test61Part2 (
    IN OUT PULONG Counter
    );

VOID
PerformFpTest(
    VOID
    );

double
SquareDouble (
    IN double   op
    );

VOID
SquareDouble17E300 (
    OUT PVOID   ans
    );

LONG
test66sub (
    IN PLONG Counter
    );

LONG
test67sub (
    IN PLONG Counter
    );

VOID
xcpt4 (
    VOID
    )

{

    PLONG BadAddress;
    PCHAR BadByte;
    PLONG BlackHole;
    ULONG Index1;
    ULONG Index2 = RED;
    jmp_buf JumpBuffer;
    LONG Counter;
    EXCEPTION_RECORD ExceptionRecord;
    double  doubleresult;

    //
    // Announce start of exception test.
    //

    DbgPrint("Start of exception test\n");

    //
    // Initialize exception record.
    //

    ExceptionRecord.ExceptionCode = STATUS_INTEGER_OVERFLOW;
    ExceptionRecord.ExceptionFlags = 0;
    ExceptionRecord.ExceptionRecord = NULL;
    ExceptionRecord.NumberParameters = 0;

    //
    // Initialize pointers.
    //

    BadAddress = (PLONG)NULL;
    BadByte = (PCHAR)NULL;
    BadByte += 1;
    BlackHole = &Counter;

    //
    // Simply try statement with a finally clause that is entered sequentially.
    //

    DbgPrint("    test1...");
    Counter = 0;
    try {
        Counter += 1;

    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 1;
        }
    }

    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try statement with an exception clause that is never executed
    // because there is no exception raised in the try clause.
    //

    DbgPrint("    test2...");
    Counter = 0;
    try {
        Counter += 1;

    } except (Counter) {
        Counter += 1;
    }

    if (Counter != 1) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try statement with an exception handler that is never executed
    // because the exception expression continues execution.
    //

    DbgPrint("    test3...");
    Counter = 0;
    try {
        Counter -= 1;
        RtlRaiseException(&ExceptionRecord);

    } except (Counter) {
        Counter -= 1;
    }

    if (Counter != - 1) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try statement with an exception clause that is always executed.
    //

    DbgPrint("    test4...");
    Counter = 0;
    try {
        Counter += 1;
        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

    } except (Counter) {
        Counter += 1;
    }

    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try statement with an exception clause that is always executed.
    //

    DbgPrint("    test5...");
    Counter = 0;
    try {
        Counter += 1;
        *BlackHole += *BadAddress;

    } except (Counter) {
        Counter += 1;
    }

    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simply try statement with a finally clause that is entered as the
    // result of an exception.
    //

    DbgPrint("    test6...");
    Counter = 0;
    try {
        try {
            Counter += 1;
            RtlRaiseException(&ExceptionRecord);

        } finally {
            if (abnormal_termination() != FALSE) {
                Counter += 1;
            }
        }

    } except (Counter) {
        if (Counter == 2) {
            Counter += 1;
        }
    }

    if (Counter != 3) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simply try statement with a finally clause that is entered as the
    // result of an exception.
    //

    DbgPrint("    test7...");
    Counter = 0;
    try {
        try {
            Counter += 1;
            *BlackHole += *BadAddress;

        } finally {
            if (abnormal_termination() != FALSE) {
                Counter += 1;
            }
        }

    } except (Counter) {
        if (Counter == 2) {
            Counter += 1;
        }
    }

    if (Counter != 3) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try that calls a function which raises an exception.
    //

    DbgPrint("    test8...");
    Counter = 0;
    try {
        Counter += 1;
        foo1(STATUS_ACCESS_VIOLATION);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
    }

    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try that calls a function which raises an exception.
    //

    DbgPrint("    test9...");
    Counter = 0;
    try {
        Counter += 1;
        foo2(BlackHole, BadAddress);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
    }

    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try that calls a function which calls a function that
    // raises an exception. The first function has a finally clause
    // that must be executed for this test to work.
    //

    DbgPrint("    test10...");
    Counter = 0;
    try {
        bar1(STATUS_ACCESS_VIOLATION, &Counter);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter -= 1;
    }

    if (Counter != 98) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try that calls a function which calls a function that
    // raises an exception. The first function has a finally clause
    // that must be executed for this test to work.
    //

    DbgPrint("    test11...");
    Counter = 0;
    try {
        bar2(BlackHole, BadAddress, &Counter);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter -= 1;
    }

    if (Counter != 98) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A try within an except
    //

    DbgPrint("    test12...");
    Counter = 0;
    try {
        foo1(STATUS_ACCESS_VIOLATION);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
        try {
            foo1(STATUS_SUCCESS);

        } except ((GetExceptionCode() == STATUS_SUCCESS) ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            if (Counter != 1) {
                DbgPrint("failed, count = %d\n", Counter);

            } else {
                DbgPrint("succeeded...");
            }

            Counter += 1;
        }
    }

    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A try within an except
    //

    DbgPrint("    test13...");
    Counter = 0;
    try {
        foo2(BlackHole, BadAddress);

    } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
        try {
            foo1(STATUS_SUCCESS);

        } except ((GetExceptionCode() == STATUS_SUCCESS) ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            if (Counter != 1) {
                DbgPrint("failed, count = %d\n", Counter);

            } else {
                DbgPrint("succeeded...");
            }

            Counter += 1;
        }
    }

    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A goto from an exception clause that needs to pass
    // through a finally
    //

    DbgPrint("    test14...");
    Counter = 0;
    try {
        try {
            foo1(STATUS_ACCESS_VIOLATION);

        } except ((GetExceptionCode() == STATUS_ACCESS_VIOLATION) ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            Counter += 1;
            goto t9;
        }

    } finally {
        Counter += 1;
    }

t9:;
    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A goto from an finally clause that needs to pass
    // through a finally
    //

    DbgPrint("    test15...");
    Counter = 0;
    try {
        try {
            Counter += 1;

        } finally {
            Counter += 1;
            goto t10;
        }

    } finally {
        Counter += 1;
    }

t10:;
    if (Counter != 3) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A goto from an exception clause that needs to pass
    // through a finally into the outer finally clause.
    //

    DbgPrint("    test16...");
    Counter = 0;
    try {
        try {
            try {
                Counter += 1;
                foo1(STATUS_INTEGER_OVERFLOW);

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Counter += 1;
                goto t11;
            }

        } finally {
            Counter += 1;
        }
t11:;
    } finally {
        Counter += 1;
    }

    if (Counter != 4) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A goto from an finally clause that needs to pass
    // through a finally into the outer finally clause.
    //

    DbgPrint("    test17...");
    Counter = 0;
    try {
        try {
            Counter += 1;

        } finally {
            Counter += 1;
            goto t12;
        }
t12:;
    } finally {
        Counter += 1;
    }

    if (Counter != 3) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A return from an except clause
    //

    DbgPrint("    test18...");
    Counter = 0;
    try {
        Counter += 1;
        eret(STATUS_ACCESS_VIOLATION, &Counter);

    } finally {
        Counter += 1;
    }

    if (Counter != 4) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A return from a finally clause
    //

    DbgPrint("    test19...");
    Counter = 0;
    try {
        Counter += 1;
        fret(&Counter);

    } finally {
        Counter += 1;
    }

    if (Counter != 5) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A simple set jump followed by a long jump.
    //

    DbgPrint("    test20...");
    Counter = 0;
    if (setjmp(JumpBuffer) == 0) {
        Counter += 1;
        longjmp(JumpBuffer, 1);

    } else {
        Counter += 1;
    }

    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A set jump followed by a long jump out of a finally clause that is
    // sequentially executed.
    //

    DbgPrint("    test21...");
    Counter = 0;
    if (setjmp(JumpBuffer) == 0) {
        try {
            Counter += 1;

        } finally {
            Counter += 1;
            longjmp(JumpBuffer, 1);
        }

    } else {
        Counter += 1;
    }

    if (Counter != 3) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A set jump within a try clause followed by a long jump out of a
    // finally clause that is sequentially executed.
    //

    DbgPrint("    test22...");
    Counter = 0;
    try {
        if (setjmp(JumpBuffer) == 0) {
            Counter += 1;

        } else {
            Counter += 1;
        }

    } finally {
        Counter += 1;
        if (Counter == 2) {
            Counter += 1;
            longjmp(JumpBuffer, 1);
        }
    }

    if (Counter != 5) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A set jump followed by a try/except, followed by a try/finally where
    // the try body of the try/finally raises an exception that is handled
    // by the try/excecpt which causes the try/finally to do a long jump out
    // of a finally clause. This will create a collided unwind.
    //

    DbgPrint("    test23...");
    Counter = 0;
    if (setjmp(JumpBuffer) == 0) {
        try {
            try {
                Counter += 1;
                RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

            } finally {
                Counter += 1;
                longjmp(JumpBuffer, 1);
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Counter += 1;
        }

    } else {
        Counter += 1;
    }

    if (Counter != 3) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A set jump followed by a try/except, followed by a several nested
    // try/finally's where the inner try body of the try/finally raises an
    // exception that is handled by the try/except which causes the
    // try/finally to do a long jump out of a finally clause. This will
    // create a collided unwind.
    //

    DbgPrint("    test24...");
    Counter = 0;
    if (setjmp(JumpBuffer) == 0) {
        try {
            try {
                try {
                    try {
                        Counter += 1;
                        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

                    } finally {
                        Counter += 1;
                    }

                } finally {
                    Counter += 1;
                    longjmp(JumpBuffer, 1);
                }

            } finally {
                Counter += 1;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Counter += 1;
        }

    } else {
        Counter += 1;
    }

    if (Counter != 5) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A set jump followed by a try/except, followed by a try/finally which
    // calls a subroutine which contains a try finally that raises an
    // exception that is handled to the try/except.
    //

    DbgPrint("    test25...");
    Counter = 0;
    if (setjmp(JumpBuffer) == 0) {
        try {
            try {
                try {
                    Counter += 1;
                    dojump(JumpBuffer, &Counter);

                } finally {
                    Counter += 1;
                }

            } finally {
                Counter += 1;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Counter += 1;
        }

    } else {
        Counter += 1;
    }

    if (Counter != 7) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A set jump followed by a try/except, followed by a try/finally which
    // calls a subroutine which contains a try finally that raises an
    // exception that is handled to the try/except.
    //

    DbgPrint("    test26...");
    Counter = 0;
    if (setjmp(JumpBuffer) == 0) {
        try {
            try {
                try {
                    try {
                        Counter += 1;
                        dojump(JumpBuffer, &Counter);

                    } finally {
                        Counter += 1;
                    }

                } finally {
                    Counter += 1;
                    longjmp(JumpBuffer, 1);
                }

            } finally {
                Counter += 1;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Counter += 1;
        }

    } else {
        Counter += 1;
    }

    if (Counter != 8) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Test nested exceptions.
    //

    DbgPrint("    test27...");
    Counter = 0;
    try {
        try {
            Counter += 1;
            except1(&Counter);

        } except(except2(GetExceptionInformation(), &Counter)) {
            Counter += 2;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Counter += 3;
    }

    if (Counter != 55) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try that causes an integer overflow exception.
    //

    DbgPrint("    test28...");
    Counter = 0;
    try {
        Counter += 1;
        addtwo(0x7fff0000, 0x10000, &Counter);

    } except ((GetExceptionCode() == STATUS_INTEGER_OVERFLOW) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
    }

    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Simple try that raises an misaligned data exception.
    //

#if 0

    DbgPrint("    test29...");
    Counter = 0;
    try {
        Counter += 1;
        foo2(BlackHole, (PLONG)BadByte);

    } except ((GetExceptionCode() == STATUS_DATATYPE_MISALIGNMENT) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Counter += 1;
    }

    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

#endif

    //
    // Continue from a try body with an exception clause in a loop.
    //

    DbgPrint("    test30...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            if ((Index1 & 0x1) == 0) {
                continue;

            } else {
                Counter += 1;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 40;
        }

        Counter += 2;
    }

    if (Counter != 15) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Continue from a try body with an finally clause in a loop.
    //

    DbgPrint("    test31...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            if ((Index1 & 0x1) == 0) {
                continue;

            } else {
                Counter += 1;
            }

        } finally {
            Counter += 2;
        }

        Counter += 3;
    }

    if (Counter != 40) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Continue from doubly nested try body with an exception clause in a
    // loop.
    //

    DbgPrint("    test32...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 0) {
                    continue;

                } else {
                    Counter += 1;
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Counter += 10;
            }

            Counter += 2;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 20;
        }

        Counter += 3;
    }

    if (Counter != 30) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Continue from doubly nested try body with an finally clause in a loop.
    //

    DbgPrint("    test33...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 0) {
                    continue;

                } else {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
            }

            Counter += 3;

        } finally {
            Counter += 4;
        }

        Counter += 5;
    }

    if (Counter != 105) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Continue from a finally clause in a loop.
    //

    DbgPrint("    test34...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            if ((Index1 & 0x1) == 0) {
                Counter += 1;
            }

        } finally {
            Counter += 2;
            continue;
        }

        Counter += 4;
    }

    if (Counter != 25) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Continue from a doubly nested finally clause in a loop.
    //

    DbgPrint("    test35...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 0) {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
                continue;
            }

            Counter += 4;

        } finally {
            Counter += 5;
        }

        Counter += 6;
    }

    if (Counter != 75) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Continue from a doubly nested finally clause in a loop.
    //

    DbgPrint("    test36...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 0) {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
            }

            Counter += 4;

        } finally {
            Counter += 5;
            continue;
        }

        Counter += 6;
    }

    if (Counter != 115) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from a try body with an exception clause in a loop.
    //

    DbgPrint("    test37...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            if ((Index1 & 0x1) == 1) {
                break;

            } else {
                Counter += 1;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 40;
        }

        Counter += 2;
    }

    if (Counter != 3) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from a try body with an finally clause in a loop.
    //

    DbgPrint("    test38...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            if ((Index1 & 0x1) == 1) {
                break;

            } else {
                Counter += 1;
            }

        } finally {
            Counter += 2;
        }

        Counter += 3;
    }

    if (Counter != 8) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from doubly nested try body with an exception clause in a
    // loop.
    //

    DbgPrint("    test39...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    break;

                } else {
                    Counter += 1;
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Counter += 10;
            }

            Counter += 2;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 20;
        }

        Counter += 3;
    }

    if (Counter != 6) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from doubly nested try body with an finally clause in a loop.
    //

    DbgPrint("    test40...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    break;

                } else {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
            }

            Counter += 3;

        } finally {
            Counter += 4;
        }

        Counter += 5;
    }

    if (Counter != 21) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from a finally clause in a loop.
    //

    DbgPrint("    test41...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            if ((Index1 & 0x1) == 1) {
                Counter += 1;
            }

        } finally {
            Counter += 2;
            break;
        }

        Counter += 4;
    }

    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from a doubly nested finally clause in a loop.
    //

    DbgPrint("    test42...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
                break;
            }

            Counter += 4;

        } finally {
            Counter += 5;
        }

        Counter += 6;
    }

    if (Counter != 7) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from a doubly nested finally clause in a loop.
    //

    DbgPrint("    test43...");
    Counter = 0;
    for (Index1 = 0; Index1 < 10; Index1 += 1) {
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
            }

            Counter += 4;

        } finally {
            Counter += 5;
            break;
        }

        Counter += 6;
    }

    if (Counter != 11) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from a try body with an exception clause in a switch.
    //

    DbgPrint("    test44...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            if ((Index1 & 0x1) == 1) {
                break;

            } else {
                Counter += 1;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 40;
        }

        Counter += 2;
        break;
    }

    if (Counter != 0) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from a try body with an finally clause in a switch.
    //

    DbgPrint("    test45...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            if ((Index1 & 0x1) == 1) {
                break;

            } else {
                Counter += 1;
            }

        } finally {
            Counter += 2;
        }

        Counter += 3;
    }

    if (Counter != 2) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from doubly nested try body with an exception clause in a
    // switch.
    //

    DbgPrint("    test46...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    break;

                } else {
                    Counter += 1;
                }

            } except (EXCEPTION_EXECUTE_HANDLER) {
                Counter += 10;
            }

            Counter += 2;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 20;
        }

        Counter += 3;
    }

    if (Counter != 0) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from doubly nested try body with an finally clause in a switch.
    //

    DbgPrint("    test47...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    break;

                } else {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
            }

            Counter += 3;

        } finally {
            Counter += 4;
        }

        Counter += 5;
    }

    if (Counter != 6) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from a finally clause in a switch.
    //

    DbgPrint("    test48...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            if ((Index1 & 0x1) == 1) {
                Counter += 1;
            }

        } finally {
            Counter += 2;
            break;
        }

        Counter += 4;
    }

    if (Counter != 3) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from a doubly nested finally clause in a switch.
    //

    DbgPrint("    test49...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
                break;
            }

            Counter += 4;

        } finally {
            Counter += 5;
        }

        Counter += 6;
    }

    if (Counter != 8) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Break from a doubly nested finally clause in a switch.
    //

    DbgPrint("    test50...");
    Counter = 0;
    Index1 = 1;
    switch (Index2) {
    case BLUE:
        Counter += 100;
        break;

    case RED:
        try {
            try {
                if ((Index1 & 0x1) == 1) {
                    Counter += 1;
                }

            } finally {
                Counter += 2;
            }

            Counter += 4;

        } finally {
            Counter += 5;
            break;
        }

        Counter += 6;
    }

    if (Counter != 12) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Leave from an if in a simple try/finally.
    //

    DbgPrint("    test51...");
    Counter = 0;
    try {
        if (Echo(Counter) == Counter) {
            Counter += 3;
            leave;

        } else {
            Counter += 100;
        }

    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 5;
        }
    }

    if (Counter != 8) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Leave from a loop in a simple try/finally.
    //

    DbgPrint("    test52...");
    Counter = 0;
    try {
        for (Index1 = 0; Index1 < 10; Index1 += 1) {
            if (Echo(Index1) == Index1) {
                Counter += 3;
                leave;
            }

            Counter += 100;
        }

    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 5;
        }
    }

    if (Counter != 8) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Leave from a switch in a simple try/finally.
    //

    DbgPrint("    test53...");
    Counter = 0;
    try {
        switch (Index2) {
        case BLUE:
            break;

        case RED:
            Counter += 3;
            leave;
        }

        Counter += 100;

    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 5;
        }
    }

    if (Counter != 8) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Leave from an if in doubly nested try/finally followed by a leave
    // from an if in the outer try/finally.
    //

    DbgPrint("    test54...");
    Counter = 0;
    try {
        try {
            if (Echo(Counter) == Counter) {
                Counter += 3;
                leave;

            } else {
                Counter += 100;
            }

        } finally {
            if (abnormal_termination() == FALSE) {
                Counter += 5;
            }
        }

        if (Echo(Counter) == Counter) {
            Counter += 3;
            leave;

         } else {
            Counter += 100;
         }


    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 5;
        }
    }

    if (Counter != 16) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Leave from an if in doubly nested try/finally followed by a leave
    // from the finally of the outer try/finally.
    //

    DbgPrint("    test55...");
    Counter = 0;
    try {
        try {
            if (Echo(Counter) == Counter) {
                Counter += 3;
                leave;

            } else {
                Counter += 100;
            }

        } finally {
            if (abnormal_termination() == FALSE) {
                Counter += 5;
                leave;
            }
        }

        Counter += 100;

    } finally {
        if (abnormal_termination() == FALSE) {
            Counter += 5;
        }
    }

    if (Counter != 13) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Try/finally within the except clause of a try/except that is always
    // executed.
    //

    DbgPrint("    test56...");
    Counter = 0;
    try {
        Counter += 1;
        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

    } except (Counter) {
        try {
            Counter += 3;

        } finally {
            if (abnormal_termination() == FALSE) {
                Counter += 5;
            }
        }
    }

    if (Counter != 9) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Try/finally within the finally clause of a try/finally.
    //

    DbgPrint("    test57...");
    Counter = 0;
    try {
        Counter += 1;

    } finally {
        if (abnormal_termination() == FALSE) {
            try {
                Counter += 3;

            } finally {
                if (abnormal_termination() == FALSE) {
                    Counter += 5;
                }
            }
        }
    }

    if (Counter != 9) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Try/except within the finally clause of a try/finally.
    //

    DbgPrint("    test58...");
    Counter = 0;
    try {
        Counter -= 1;

    } finally {
        try {
            Counter += 2;
            RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

        } except (Counter) {
            try {
                Counter += 3;

            } finally {
                if (abnormal_termination() == FALSE) {
                    Counter += 5;
                }
            }
        }
    }

    if (Counter != 9) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Try/except within the except clause of a try/except that is always
    // executed.
    //

    DbgPrint("    test59...");
    Counter = 0;
    try {
        Counter += 1;
        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

    } except (Counter) {
        try {
            Counter += 3;
            RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

        } except(Counter - 3) {
            Counter += 5;
        }
    }

    if (Counter != 9) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Try with a Try which exits the scope with a goto
    //

    DbgPrint("    test60...");
    Counter = 0;
    try {
        try {
            goto outside;

        } except(1) {
            Counter += 1;
        }

outside:
    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

    } except(1) {
        Counter += 3;
    }

    if (Counter != 3) {
        DbgPrint("failed, count = %d\n", Counter);
    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Try/except which gets an exception from a subfunction within
    // a try/finally which has a try/except in the finally clause
    //

    DbgPrint("    test61...");
    Counter = 0;
    try {
        Test61Part2 (&Counter);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Counter += 11;
    }

    if (Counter != 24) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Try/except within a try/except where the outer try/except gets
    // a floating overflow exception.
    //

    DbgPrint("    test62...");
    _controlfp(_controlfp(0,0) & ~EM_OVERFLOW, _MCW_EM);
    Counter = 0;
    try {
        doubleresult = SquareDouble(1.7e300);

        try {
            doubleresult = SquareDouble (1.0);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 3;
        }

    } except ((GetExceptionCode() == STATUS_FLOAT_OVERFLOW) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

        Counter += 1;
    }

    if (Counter != 1) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    _clearfp ();

    //
    // Try/except within a try/except where the outer try/except gets
    // a floating overflow exception in a subfunction.
    //

    DbgPrint("    test63...");
    Counter = 0;
    try {
        SquareDouble17E300((PVOID)&doubleresult);
        try {
            SquareDouble17E300((PVOID)&doubleresult);

        } except (EXCEPTION_EXECUTE_HANDLER) {
            Counter += 3;
        }

    } except ((GetExceptionCode() == STATUS_FLOAT_OVERFLOW) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

        Counter += 1;
    }

    if (Counter != 1) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    _clearfp ();

    //
    // Try/finally within a try/except where the finally body causes an
    // exception that leads to a collided unwind during the exception
    // dispatch.
    //

    DbgPrint("    test64...");
    Counter = 0;
    try {
        Counter += 1;
        try {
            Counter += 1;
            FAULT;
            Counter += 20;

        } finally {
            if (abnormal_termination() == FALSE) {
                Counter += 20;

            } else {
                Counter += 1;
                FAULT;
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Counter += 10;
    }
   
    if (Counter != 13) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Try/finally within a try/finally within a try/except that leads to a
    // collided unwind during the exception dispatch.
    //

    DbgPrint("    test65...");
    Counter = 0;
    try {
        Counter += 1;
        try {
            Counter += 1;
            FAULT;
            Counter += 20;

        } finally {
            if (abnormal_termination() == FALSE) {
                Counter += 20;

            } else {
                try {
                    Counter += 1;
                    FAULT;
                    Counter += 20;
    
                } finally {
                    if (abnormal_termination() == FALSE) {
                        Counter += 20;

                    } else {
                        Counter += 1;
                    }
                }
            }

            FAULT;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        Counter += 10;
    }
   
    if (Counter != 14) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A call to a function with a try/finally that returns out of the try
    // body.
    //

    DbgPrint("    test66...");
    Counter = 0;
    if ((test66sub(&Counter) + 1) != Counter) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // A call to a function with a try finally that returnss out of the 
    // termination hander.
    //

    DbgPrint("    test67...");
    Counter = 0;
    if (test67sub(&Counter) != Counter) {
        DbgPrint("failed, count = %d\n", Counter);

    } else {
        DbgPrint("succeeded\n");
    }

    //
    // Announce end of exception test.
    //

    DbgBreakPoint();
    DbgPrint("End of exception test\n");
    return;
}

VOID
addtwo (
    long First,
    long Second,
    long *Place
    )

{

    RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);
    *Place = First + Second;
    return;
}

VOID
bar1 (
    IN NTSTATUS Status,
    IN PLONG Counter
    )
{

    try {
        foo1(Status);

    } finally {
        if (abnormal_termination() != FALSE) {
            *Counter = 99;

        } else {
            *Counter = 100;
        }
    }

    return;
}

VOID
bar2 (
    IN PLONG BlackHole,
    IN PLONG BadAddress,
    IN PLONG Counter
    )
{

    try {
        foo2(BlackHole, BadAddress);

    } finally {
        if (abnormal_termination() != FALSE) {
            *Counter = 99;

        } else {
            *Counter = 100;
        }
    }

    return;
}

VOID
dojump (
    IN jmp_buf JumpBuffer,
    IN PLONG Counter
    )

{

    try {
        try {
            *Counter += 1;
            RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

        } finally {
            *Counter += 1;
        }

    } finally {
        *Counter += 1;
        longjmp(JumpBuffer, 1);
    }
}

VOID
eret(
    IN NTSTATUS Status,
    IN PLONG Counter
    )

{

    try {
        try {
            foo1(Status);

        } except ((GetExceptionCode() == Status) ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
            *Counter += 1;
            return;
        }

    } finally {
        *Counter += 1;
    }

    return;
}

VOID
except1 (
    IN PLONG Counter
    )

{

    try {
        *Counter += 5;
        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

    } except (except3(GetExceptionInformation(), Counter)) {
        *Counter += 7;
    }

    *Counter += 9;
    return;
}

ULONG
except2 (
    IN PEXCEPTION_POINTERS ExceptionPointers,
    IN PLONG Counter
    )

{

    PEXCEPTION_RECORD ExceptionRecord;

    ExceptionRecord = ExceptionPointers->ExceptionRecord;
    if ((ExceptionRecord->ExceptionCode == STATUS_UNSUCCESSFUL) &&
       ((ExceptionRecord->ExceptionFlags & EXCEPTION_NESTED_CALL) == 0)) {
        *Counter += 11;
        return EXCEPTION_EXECUTE_HANDLER;

    } else {
        *Counter += 13;
        return EXCEPTION_CONTINUE_SEARCH;
    }
}

ULONG
except3 (
    IN PEXCEPTION_POINTERS ExceptionPointers,
    IN PLONG Counter
    )

{

    PEXCEPTION_RECORD ExceptionRecord;

    ExceptionRecord = ExceptionPointers->ExceptionRecord;
    if ((ExceptionRecord->ExceptionCode == STATUS_INTEGER_OVERFLOW) &&
       ((ExceptionRecord->ExceptionFlags & EXCEPTION_NESTED_CALL) == 0)) {
        *Counter += 17;
        RtlRaiseStatus(STATUS_UNSUCCESSFUL);

    } else if ((ExceptionRecord->ExceptionCode == STATUS_UNSUCCESSFUL) &&
        ((ExceptionRecord->ExceptionFlags & EXCEPTION_NESTED_CALL) != 0)) {
        *Counter += 19;
        return EXCEPTION_CONTINUE_SEARCH;
    }

    *Counter += 23;
    return EXCEPTION_EXECUTE_HANDLER;
}

VOID
foo1 (
    IN NTSTATUS Status
    )

{

    //
    // Raise exception.
    //

    RtlRaiseStatus(Status);
    return;
}

VOID
foo2 (
    IN PLONG BlackHole,
    IN PLONG BadAddress
    )

{

    //
    // Raise exception.
    //

    *BlackHole += *BadAddress;
    return;
}

VOID
fret (
    IN PLONG Counter
    )

{

    try {
        try {
            *Counter += 1;

        } finally {
            *Counter += 1;
            return;
        }
    } finally {
        *Counter += 1;
    }

    return;
}

LONG
Echo (
    IN LONG Value
    )

{
    return Value;
}

VOID
Test61Part2 (
    IN OUT PULONG Counter
    )
{

    try {
        *Counter -= 1;
        RtlRaiseStatus(STATUS_INTEGER_OVERFLOW);

    } finally {
        *Counter += 2;
        *Counter += 5;
        *Counter += 7;
    }
}


double
SquareDouble (
    IN double   op
    )
{
    return op * op;
}

VOID
SquareDouble17E300 (
    OUT PVOID   output
    )
{
    double  ans;

    ans = SquareDouble (1.7e300);
    *(double *) output = ans;
}

LONG
test66sub (
    IN PLONG Counter
    )

{

    *Counter += 1;
    try {
        *Counter += 1;
        return(*Counter);

    } finally {
        *Counter += 1;
    }
}

LONG
test67sub (
    IN PLONG Counter
    )

{

    *Counter += 1;
    try {
        *Counter += 1;

    } finally {
        *Counter += 1;
        return(*Counter);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\abiosc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    abiosc.c

Abstract:

    This module implements ABIOS support C routines for i386 NT.

Author:

    Shie-Lin Tzong (shielint) 20-May-1991

Environment:

    Boot loader privileged, FLAT mode.


Revision History:

--*/

#include "ki.h"
#pragma hdrstop
#include "abios.h"

extern PKCOMMON_DATA_AREA KiCommonDataArea;
extern BOOLEAN KiAbiosPresent;

//
// The reason of having these variables defined in here is to isolate
// ABIOS from current system.
//

//
// KiNumberFreeSelectors defines the number of available selectors for
// ABIOS specific drivers.  This number should be the same accross all
// the processors.
//

static USHORT KiNumberFreeSelectors = 0;

//
// KiFreeGdtListHead points to the head of free GDT list on the processor 0.
//

static PKFREE_GDT_ENTRY KiFreeGdtListHead = 0L;

//
// Logica Id Table to control the ownership of logical Id.
//

PKLID_TABLE_ENTRY KiLogicalIdTable;

//
// KiAbiosGdt[] defines the Starting address of GDT for each processor.
//

ULONG KiAbiosGdt[MAXIMUM_PROCESSORS];

//
// SpinLock for accessing GDTs
//

KSPIN_LOCK KiAbiosGdtLock;

//
// Spinlock for accessing Logical Id Table
//

KSPIN_LOCK KiAbiosLidTableLock;

//
// KiStack16GdtEntry defines the address of the gdt entry for 16 bit stack.
//

ULONG KiStack16GdtEntry;

VOID
KiInitializeAbiosGdtEntry (
    OUT PKGDTENTRY GdtEntry,
    IN ULONG Base,
    IN ULONG Limit,
    IN USHORT Type
    )

/*++

Routine Description:

    This function initializes a GDT entry for abios specific code.  Base,
    Limit, and Type (code, data) are set according to parameters.  All other
    fields of the entry are set to match standard system values.

    N.B. The BIG and GRANULARITY are always set to 0.

Arguments:

    GdtEntry - GDT descriptor to be filled in.

    Base - Linear address of the first byte mapped by the selector.

    Limit - Size of the selector in BYTE.

    Type - Code or Data.  All code selectors are marked readable,
            all data selectors are marked writeable.

Return Value:

    Pointer to the GDT entry.

--*/

{
    GdtEntry->LimitLow = (USHORT)(Limit & 0xffff);
    GdtEntry->BaseLow = (USHORT)(Base & 0xffff);
    GdtEntry->HighWord.Bytes.BaseMid = (UCHAR)((Base & 0xff0000) >> 16);
    GdtEntry->HighWord.Bits.Type = Type;
    GdtEntry->HighWord.Bits.Dpl = 0;
    GdtEntry->HighWord.Bits.Pres = 1;
    GdtEntry->HighWord.Bits.LimitHi = (Limit & 0xf0000) >> 16;
    GdtEntry->HighWord.Bits.Sys = 0;
    GdtEntry->HighWord.Bits.Reserved_0 = 0;
    GdtEntry->HighWord.Bits.Default_Big = 0;
    GdtEntry->HighWord.Bits.Granularity = 0;
    GdtEntry->HighWord.Bytes.BaseHi = (UCHAR)((Base & 0xff000000) >> 24);
}

ULONG
KiI386SelectorBase (
    IN USHORT Selector
    )

/*++

Routine Description:

    This function returns the base address of the specified GDT selector.

Arguments:

    Selector - Supplies the desired selector.

Return Value:

    SelectorBase - Return the base address of the specified selector;
                   (return -1L if invalid selector)


--*/

{
    PKGDTENTRY GdtEntry;


    GdtEntry = (PKGDTENTRY)(KiAbiosGetGdt() + Selector);
    if (GdtEntry->HighWord.Bits.Pres) {
        return ((ULONG)GdtEntry->BaseLow |
                (ULONG)GdtEntry->HighWord.Bytes.BaseMid << 16 |
                (ULONG)GdtEntry->HighWord.Bytes.BaseHi << 24);
    } else {
        return (ULONG)(-1L);
    }
}

NTSTATUS
KeI386GetLid(
    IN USHORT DeviceId,
    IN USHORT RelativeLid,
    IN BOOLEAN SharedLid,
    IN PDRIVER_OBJECT DriverObject,
    OUT PUSHORT LogicalId
    )

/*++

Routine Description:

    This function searches Device Blocks and Common Data Area for the
    Logical Id matching the specified Device Id.

    N.B. (WARNING shielint) To speed the search, this routine ASSUMES that
    the LIDs with the same Device ID always appear consecutively in the
    Common Data Area.  IBM ABIOS doc does not explicitly specify this.
    But from the way ABIOS initializes Device Block and Function Transfer
    Table, I think the assumption is true.

Arguments:

    DeviceId - Desired Device Id.

    RelativeLid - Specifies the Nth logical Id for this device Id.  A value
                  of 0 indicates the first available Lid.

    SharedLid - A boolean value indicates if it is a shared or exclusively
                owned logical Id.

    DriverObject - Supplies a 32-bit flat pointer of the requesting device
                driver's driver object.  The DriverObject is used to establish
                the ownership of the desired LID.

    LogicalId - A pointer to a variable which will receive the Lid.

Return Value:

    STATUS_SUCCESS - If the requested LID is available.

    STATUS_ABIOS_NOT_PRESENT - If there is no ABIOS support in the system.

    STATUS_ABIOS_LID_NOT_EXIST - If the specified LID does not exist.

    STATUS_ABIOS_LID_ALREADY_OWNED - If the caller requests an exclusively
                                     owned LID.

--*/

{
    PKDB_FTT_SECTION CdaPointer;
    PKDEVICE_BLOCK DeviceBlock;
    USHORT Lid, RelativeLidCount = 1;
    ULONG Owner;
    USHORT Increment;
    KIRQL OldIrql;
    NTSTATUS Status;

    if (!KiAbiosPresent) {
        return STATUS_ABIOS_NOT_PRESENT;
    }

    if (SharedLid) {
        Owner = LID_NO_SPECIFIC_OWNER;
        Increment = 1;
    } else {
        Owner = (ULONG)DriverObject;
        Increment = 0;
    }

    //
    // If the Logical Id Table hasn't been created yet, create it now.
    //
    if (KiLogicalIdTable==NULL) {
        KiLogicalIdTable = ExAllocatePoolWithTag(NonPagedPool,
                                          NUMBER_LID_TABLE_ENTRIES *
                                          sizeof(KLID_TABLE_ENTRY),
                                          '  eK');
        if (KiLogicalIdTable == NULL) {
            return(STATUS_NO_MEMORY);
        }
        RtlZeroMemory(KiLogicalIdTable, NUMBER_LID_TABLE_ENTRIES*sizeof(KLID_TABLE_ENTRY));
    }

    //
    // For each Lid defined in Common Data Area, we check if it has non
    // empty device block and function transfer table.  If yes, we proceed
    // to check the device id.  Otherwise, we skip the Lid.
    //

    CdaPointer = (PKDB_FTT_SECTION)KiCommonDataArea + 2;
    Status = STATUS_ABIOS_LID_NOT_EXIST;

    ExAcquireSpinLock(&KiAbiosLidTableLock, &OldIrql);

    for (Lid = 2; Lid < KiCommonDataArea->NumberLids; Lid++) {
        if (CdaPointer->DeviceBlock.Selector != 0 &&
            CdaPointer->FunctionTransferTable.Selector != 0) {

            DeviceBlock = (PKDEVICE_BLOCK)(KiI386SelectorBase(
                                               CdaPointer->DeviceBlock.Selector)
                                           + (CdaPointer->DeviceBlock.Offset));
            if (DeviceBlock->DeviceId == DeviceId) {
                if (RelativeLid == RelativeLidCount || RelativeLid == 0) {
                    if (KiLogicalIdTable[Lid].Owner == 0L) {
                        KiLogicalIdTable[Lid].Owner = Owner;
                        KiLogicalIdTable[Lid].OwnerCount += Increment;
                        *LogicalId = Lid;
                        Status = STATUS_SUCCESS;
                    } else if (KiLogicalIdTable[Lid].Owner == LID_NO_SPECIFIC_OWNER) {
                        if (SharedLid) {
                            *LogicalId = Lid;
                            KiLogicalIdTable[Lid].OwnerCount += Increment;
                            Status = STATUS_SUCCESS;
                        } else {
                            Status = STATUS_ABIOS_LID_ALREADY_OWNED;
                        }
                    } else if (KiLogicalIdTable[Lid].Owner == (ULONG)DriverObject) {
                        *LogicalId = Lid;
                        Status = STATUS_SUCCESS;
                    } else if (RelativeLid != 0) {
                        Status = STATUS_ABIOS_LID_ALREADY_OWNED;
                    }
                    break;
                } else {
                    RelativeLidCount++;
                }
            }
        }
        CdaPointer++;
    }

    ExReleaseSpinLock(&KiAbiosLidTableLock, OldIrql);
    return Status;
}

NTSTATUS
KeI386ReleaseLid(
    IN USHORT LogicalId,
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This function releases a logical Id.  This routine is called at ABIOS
    device driver destallation or termination.

Arguments:

    LogicalId - Logical Id to be released.

    DriverObject - Supplies a 32-bit flat pointer of the requesting device
                driver's driver object.  The DriverObject is used to check
                the ownership of the specified LID.

Return Value:

    STATUS_SUCCESS - If the requested LID is released.

    STATUS_ABIOS_NOT_PRESENT - If there is no ABIOS support in the system.

    STATUS_ABIOS_NOT_LID_OWNER - If the caller does not own the LID.

--*/

{
    KIRQL OldIrql;
    NTSTATUS Status;

    if (!KiAbiosPresent) {
        return STATUS_ABIOS_NOT_PRESENT;
    }

    ExAcquireSpinLock(&KiAbiosLidTableLock, &OldIrql);

    if (KiLogicalIdTable[LogicalId].Owner == (ULONG)DriverObject) {
        KiLogicalIdTable[LogicalId].Owner = 0L;
        Status = STATUS_SUCCESS;
    } else if (KiLogicalIdTable[LogicalId].Owner == LID_NO_SPECIFIC_OWNER) {
        KiLogicalIdTable[LogicalId].OwnerCount--;
        if (KiLogicalIdTable[LogicalId].OwnerCount == 0L) {
            KiLogicalIdTable[LogicalId].Owner = 0L;
        }
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_ABIOS_NOT_LID_OWNER;
    }

    ExReleaseSpinLock(&KiAbiosLidTableLock, OldIrql);

    return Status;
}

NTSTATUS
KeI386AbiosCall(
    IN USHORT LogicalId,
    IN PDRIVER_OBJECT DriverObject,
    IN PUCHAR RequestBlock,
    IN USHORT EntryPoint
    )

/*++

Routine Description:

    This function calls an ABIOS service routine on behave of device driver
    using Operating System Transfer Convension.

Arguments:

    LogicalId - Logical Id for the call.

    DriverObject - Supplies a 32-bit flat pointer of the requesting device
                driver's driver object.  The DriverObject is used to verify
                the ownership of the desired LID.

    RequestBlock - A 16:16 (selector:offset) pointer to the request block.

    EntryPoint - Specifies which ABIOS entry point:

                 0 - Start Routine
                 1 - Interrupt Routine
                 2 - Timeout Routine

Return Value:

    STATUS_SUCCESS - If no error.

    STATUS_ABIOS_NOT_PRESENT - If there is no ABIOS support in the system.

    STATUS_ABIOS_INVALID_COMMAND - if the specified entry point is not supported.

    STATUS_ABIOS_INVALID_LID - If the Lid specified is invalid.

    STATUS_ABIOS_NOT_LID_OWNER - If the caller does not own this Lid.

    (Note that the request specific ABIOS returned code is in RequestBlock.)

--*/

{

    KABIOS_POINTER FuncTransferTable;
    KABIOS_POINTER DeviceBlock;
    KABIOS_POINTER AbiosFunction;
    PKFUNCTION_TRANSFER_TABLE FttPointer;

    if (!KiAbiosPresent) {
        return STATUS_ABIOS_NOT_PRESENT;
    }

    if (LogicalId >= KiCommonDataArea->NumberLids) {
        return STATUS_ABIOS_INVALID_LID;
    } else if (KiLogicalIdTable[LogicalId].Owner != (ULONG)DriverObject &&
               KiLogicalIdTable[LogicalId].Owner != LID_NO_SPECIFIC_OWNER) {
        return STATUS_ABIOS_NOT_LID_OWNER;
    } else if (EntryPoint > 2) {
        return STATUS_ABIOS_INVALID_COMMAND;
    }

    FuncTransferTable = ((PKDB_FTT_SECTION)KiCommonDataArea + LogicalId)->
                                               FunctionTransferTable;
    DeviceBlock = ((PKDB_FTT_SECTION)KiCommonDataArea + LogicalId)->DeviceBlock;
    FttPointer = (PKFUNCTION_TRANSFER_TABLE)(KiI386SelectorBase(FuncTransferTable.Selector) +
                                             (ULONG)FuncTransferTable.Offset);
    AbiosFunction = FttPointer->CommonRoutine[EntryPoint];
    KiI386CallAbios(AbiosFunction,
                    DeviceBlock,
                    FuncTransferTable,
                    *(PKABIOS_POINTER)&RequestBlock
                    );

    return STATUS_SUCCESS;
}

NTSTATUS
KeI386AllocateGdtSelectors(
    OUT PUSHORT SelectorArray,
    IN USHORT NumberOfSelectors
    )

/*++

Routine Description:

    This function allocates a set of GDT selectors for a device driver to use.
    Usually this allocation is performed at device driver initialization time
    to reserve the selectors for later use.

Arguments:

    SelectorArray - Supplies a pointer to an array of USHORT to be filled
                    in with the GDT selectors allocated.

    NumberOfSelectors - Specifies the number of selectors to be allocated.

Return Value:

    STATUS_SUCCESS - If the requested selectors are allocated.

    STATUS_ABIOS_SELECTOR_NOT_AVAILABLE - if systen can not allocate the number
                               of selectors requested.

--*/

{
    PKFREE_GDT_ENTRY GdtEntry;
    KIRQL OldIrql;

    if (KiNumberFreeSelectors >= NumberOfSelectors) {
        ExAcquireSpinLock(&KiAbiosGdtLock, &OldIrql);

        //
        // The Free Gdt link list is maintained on Processor 0's GDT ONLY.
        // Because the 'selector' is an offset to the beginning of GDT and
        // it should be the same accross all the processors.
        //

        KiNumberFreeSelectors -= NumberOfSelectors;
        GdtEntry = KiFreeGdtListHead;
        while (NumberOfSelectors != 0) {
            *SelectorArray++ = (USHORT)((ULONG)GdtEntry - KiAbiosGdt[0]);
            GdtEntry = GdtEntry->Flink;
            NumberOfSelectors--;
        }
        KiFreeGdtListHead = GdtEntry;
        ExReleaseSpinLock(&KiAbiosGdtLock, OldIrql);
        return STATUS_SUCCESS;
    } else {
        return STATUS_ABIOS_SELECTOR_NOT_AVAILABLE;
    }
}

NTSTATUS
KeI386ReleaseGdtSelectors(
    OUT PUSHORT SelectorArray,
    IN USHORT NumberOfSelectors
    )

/*++

Routine Description:

    This function releases a set of GDT selectors for a device driver.
    Usually this function is called at device driver termination or
    deinstallation time.

Arguments:

    SelectorArray - Supplies a pointer to an array of USHORT selectors
                    to be freed.

    NumberOfSelectors - Specifies the number of selectors to be released.

Return Value:

    STATUS_SUCCESS - If the requested LID is released.

--*/
{
    PKFREE_GDT_ENTRY GdtEntry;
    KIRQL OldIrql;
    ULONG Gdt;

    ExAcquireSpinLock(&KiAbiosGdtLock, &OldIrql);

    //
    // The Free Gdt link list is maintained on Processor 0's GDT ONLY.
    // Because the 'selector' is an offset to the beginning of GDT and
    // it should be the same accross all the processors.
    //

    KiNumberFreeSelectors += NumberOfSelectors;
    Gdt = KiAbiosGdt[0];
    while (NumberOfSelectors != 0) {
        GdtEntry = (PKFREE_GDT_ENTRY)(Gdt + *SelectorArray++);
        GdtEntry->Flink = KiFreeGdtListHead;
        KiFreeGdtListHead = GdtEntry;
        NumberOfSelectors--;
    }
    ExReleaseSpinLock(&KiAbiosGdtLock, OldIrql);
    return STATUS_SUCCESS;
}

NTSTATUS
KeI386FlatToGdtSelector(
    IN ULONG SelectorBase,
    IN USHORT Length,
    IN USHORT Selector
    )

/*++

Routine Description:

    This function converts a 32-bit flat address to a GDT selector-offset
    pair.  The segment set up is always 16-bit ring 0 data segment.

Arguments:

    SelectorBase - Supplies 32 bit flat address to be set as the base address
                   of the desired selector.

    Length - Supplies the Length of the segment.  The Length is a 16 bit value
             and zero means 64KB.

    Selector - Supplies the selector to be set up.

Return Value:

    STATUS_SUCCESS - If the requested LID is released.

    STATUS_ABIOS_NOT_PRESENT - If there is no ABIOS support in the system.

    STATUS_ABIOS_INVALID_SELECTOR - If the selector supplied is invalid.


--*/

{
    PKGDTENTRY GdtEntry, GdtEntry1;
    KIRQL OldIrql;
    ULONG i;

    if (!KiAbiosPresent) {
        return STATUS_ABIOS_NOT_PRESENT;
    }
    if (Selector < RESERVED_GDT_ENTRIES * sizeof(KGDTENTRY)) {
        return STATUS_ABIOS_INVALID_SELECTOR;
    } else {
        ExAcquireSpinLock(&KiAbiosGdtLock, &OldIrql);
        GdtEntry = (PKGDTENTRY)(KiAbiosGdt[0] + Selector);
        GdtEntry->LimitLow = (USHORT)(Length - 1);
        GdtEntry->BaseLow = LOWWORD(SelectorBase);
        GdtEntry->HighWord.Bytes.BaseMid = LOWBYTE(HIGHWORD(SelectorBase));
        GdtEntry->HighWord.Bytes.BaseHi = HIGHBYTE(HIGHWORD(SelectorBase));
        GdtEntry->HighWord.Bits.Pres = 1;
        GdtEntry->HighWord.Bits.Type = TYPE_DATA;
        GdtEntry->HighWord.Bits.Dpl = DPL_SYSTEM;
        for (i = 1; i < (ULONG)KeNumberProcessors; i++) {
            GdtEntry1 = (PKGDTENTRY)(KiAbiosGdt[i] + Selector);
            *GdtEntry1 = *GdtEntry;
        }
        ExReleaseSpinLock(&KiAbiosGdtLock, OldIrql);
        return STATUS_SUCCESS;
    }
}

VOID
Ki386InitializeGdtFreeList (
    PKFREE_GDT_ENTRY EndOfGdt
    )

/*++

Routine Description:

    This function initializes gdt free list by linking all the unused gdt
    entries to a free list.

Arguments:

    EndOfGdt - Supplies the ending address of desired GDT.

Return Value:

    None.

--*/
{
    PKFREE_GDT_ENTRY GdtEntry;

    GdtEntry = EndOfGdt - 1;
    KiFreeGdtListHead = (PKFREE_GDT_ENTRY)0;
    while (GdtEntry != (PKFREE_GDT_ENTRY)KiAbiosGetGdt() +
                        RESERVED_GDT_ENTRIES - 1) {
        if (GdtEntry->Present == 0) {
            GdtEntry->Flink = KiFreeGdtListHead;
            KiFreeGdtListHead = GdtEntry;
            KiNumberFreeSelectors++;
        }
        GdtEntry--;
    }
}

VOID
KiInitializeAbios (
    IN UCHAR Processor
    )

/*++

Routine Description:

    This function initializes gdt free list and sets up selector for
    KiI386AbiosCall (16-bit code).

Arguments:

    Processor - the processor who performs the initialization.

Return Value:

    None.

--*/

{

    ULONG GdtLength;
    PKGDTENTRY AliasGdtSelectorEntry;
    PKFREE_GDT_ENTRY EndOfGdt;

    //
    // First check if abios is recognized by osloader.
    //

    KiCommonDataArea = KeLoaderBlock->u.I386.CommonDataArea;

    //
    // NOTE For now we want to disable ABIOS support on MP.
    //

    if (KiCommonDataArea == NULL || Processor != 0) {
        KiAbiosPresent = FALSE;
    } else {
        KiAbiosPresent = TRUE;
    }

    //
    // Initialize the spinlocks for accessing GDTs and Lid Table.
    //

    KeInitializeSpinLock( &KiAbiosGdtLock );
    KeInitializeSpinLock( &KiAbiosLidTableLock );

    //
    // Determine the starting and ending addresses of GDT.
    //

    KiAbiosGdt[Processor] = KiAbiosGetGdt();

    AliasGdtSelectorEntry = (PKGDTENTRY)(KiAbiosGetGdt() + KGDT_GDT_ALIAS);
    GdtLength = 1 + (ULONG)(AliasGdtSelectorEntry->LimitLow) +
                (ULONG)(AliasGdtSelectorEntry->HighWord.Bits.LimitHi << 16);
    EndOfGdt = (PKFREE_GDT_ENTRY)(KiAbiosGetGdt() + GdtLength);

    //
    // Prepare selector for 16 bit stack segment
    //

    KiStack16GdtEntry = KiAbiosGetGdt() + KGDT_STACK16;

    KiInitializeAbiosGdtEntry(
                (PKGDTENTRY)KiStack16GdtEntry,
                0L,
                0xffff,
                TYPE_DATA
                );

    //
    // Establish the addressability of Common Data Area selector.
    //

    KiInitializeAbiosGdtEntry(
                (PKGDTENTRY)(KiAbiosGetGdt() + KGDT_CDA16),
                (ULONG)KiCommonDataArea,
                0xffff,
                TYPE_DATA
                );

    //
    // Set up 16-bit code selector for KiI386AbiosCall
    //

    KiInitializeAbiosGdtEntry(
                (PKGDTENTRY)(KiAbiosGetGdt() + KGDT_CODE16),
                (ULONG)&KiI386CallAbios,
                (ULONG)&KiEndOfCode16 - (ULONG)&KiI386CallAbios - 1,
                0x18                   // TYPE_CODE
                );

    //
    // Link all the unused GDT entries to our GDT free list.
    //

    if (Processor == 0) {
        Ki386InitializeGdtFreeList(EndOfGdt);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\allproc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    allproc.c

Abstract:

    This module allocates and initializes kernel resources required
    to start a new processor, and passes a complete process_state
    structre to the hal to obtain a new processor.  This is done
    for every processor.

Author:

    Ken Reneris (kenr) 22-Jan-92

Environment:

    Kernel mode only.
    Phase 1 of bootup

Revision History:

--*/


#include "ki.h"

#ifdef NT_UP

VOID
KeStartAllProcessors (
    VOID
    )
{
        // UP Build - this function is a nop
}

#else

static VOID
KiCloneDescriptor (
   IN PKDESCRIPTOR  pSrcDescriptorInfo,
   IN PKDESCRIPTOR  pDestDescriptorInfo,
   IN PVOID         Base
   );

static VOID
KiCloneSelector (
   IN ULONG    SrcSelector,
   IN PKGDTENTRY    pNGDT,
   IN PKDESCRIPTOR  pDestDescriptor,
   IN PVOID         Base
   );

VOID
KiAdjustSimultaneousMultiThreadingCharacteristics(
    VOID
    );

VOID
KiProcessorStart(
    VOID
    );

BOOLEAN
KiStartWaitAcknowledge(
    VOID
    );

#if defined(KE_MULTINODE)

NTSTATUS
KiNotNumaQueryProcessorNode(
    IN ULONG ProcessorNumber,
    OUT PUSHORT Identifier,
    OUT PUCHAR Node
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, KiNotNumaQueryProcessorNode)
#endif

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,KeStartAllProcessors)
#pragma alloc_text(INIT,KiCloneDescriptor)
#pragma alloc_text(INIT,KiCloneSelector)
#pragma alloc_text(INIT,KiAllProcessorsStarted)
#pragma alloc_text(INIT,KiAdjustSimultaneousMultiThreadingCharacteristics)
#pragma alloc_text(INIT,KiStartWaitAcknowledge)
#endif

enum {
    KcStartContinue,
    KcStartWait,
    KcStartGetId,
    KcStartDoNotStart,
    KcStartCommandError = 0xff
} KiProcessorStartControl = KcStartContinue;

ULONG KiProcessorStartData[4];

ULONG KiBarrierWait = 0;

//
// KeNumprocSpecified is set to the number of processors specified with
// /NUMPROC in OSLOADOPTIONS.   This will bypass the license increase for
// logical processors limiting the total number of processors to the number
// specified.
//

ULONG KeNumprocSpecified;

#if defined(KE_MULTINODE)

PHALNUMAQUERYPROCESSORNODE KiQueryProcessorNode = KiNotNumaQueryProcessorNode;

//
// Statically preallocate enough KNODE structures to allow MM
// to allocate pages by node during system initialization.  As
// processors are brought online, real KNODE structures are
// allocated in the appropriate memory for the node.
//
// This statically allocated set will be deallocated once the
// system is initialized.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITDATA")
#endif

KNODE KiNodeInit[MAXIMUM_CCNUMA_NODES];

#endif

#define REJECT_PROCESSOR_LIMIT  64

#define ROUNDUP16(x)        (((x)+15) & ~15)


VOID
KeStartAllProcessors (
    VOID
    )
/*++

Routine Description:

    Called by p0 during phase 1 of bootup.  This function implements
    the x86 specific code to contact the hal for each system processor.

Arguments:

Return Value:

    All available processors are sent to KiSystemStartup.

--*/
{
    KPROCESSOR_STATE    ProcessorState;
    KDESCRIPTOR         Descriptor;
    KDESCRIPTOR         TSSDesc, DFTSSDesc, NMITSSDesc, PCRDesc;
    PKGDTENTRY          pGDT;
    PVOID               pStack;
    PVOID               pDpcStack;
    ULONG               DFStack;
    PUCHAR              pThreadObject;
    PULONG              pTopOfStack;
    ULONG               NewProcessorNumber;
    BOOLEAN             NewProcessor;
    PKPROCESS           Process;
    PKTHREAD            Thread;
    PKTSS               pTSS;
    PLIST_ENTRY         NextEntry;
    LONG                NumberProcessors;
    SIZE_T              ProcessorDataSize;
    UCHAR               NodeNumber = 0;
    USHORT              ProcessorId;
    PVOID               PerProcessorAllocation;
    PUCHAR              Base;
    ULONG               IdtOffset;
    ULONG               GdtOffset;
    NTSTATUS            Status;
    PKNODE              Node;
    BOOLEAN             NewLicense;
    UCHAR               RejectedProcessorCount = 0;
    PKPRCB              NewPrcb;

#if defined(KE_MULTINODE)

    //
    // In the unlikely event that processor 0 is not on node
    // 0, fix it.
    //


    if (KeNumberNodes > 1) {
        Status = KiQueryProcessorNode(0,
                                      &ProcessorId,
                                      &NodeNumber);

        if (NT_SUCCESS(Status)) {

            //
            // This should never fail.
            //

            if (NodeNumber != 0) {
                KeNodeBlock[0]->ProcessorMask &= ~1;
                KeNodeBlock[NodeNumber]->ProcessorMask |= 1;
                KeGetCurrentPrcb()->ParentNode = KeNodeBlock[NodeNumber];
            }
        }
    }

#endif

    //
    // Calculate the size of the per processor data.  This includes
    //   PCR (+PRCB)
    //   TSS
    //   Idle Thread Object
    //   NMI TSS
    //   Double Fault TSS
    //   Double Fault Stack
    //   GDT
    //   IDT
    //
    // If this is a multinode system, the KNODE structure is allocated
    // as well.   It isn't very big so we waste a few bytes for
    // processors that aren't the first in a node.
    //
    // A DPC and Idle stack are also allocated but these are done
    // seperately.
    //

    ProcessorDataSize = ROUNDUP16(sizeof(KPCR))                 +
                        ROUNDUP16(sizeof(KTSS))                 +
                        ROUNDUP16(sizeof(ETHREAD))              +
                        ROUNDUP16(FIELD_OFFSET(KTSS, IoMaps))   +
                        ROUNDUP16(FIELD_OFFSET(KTSS, IoMaps))   +
                        ROUNDUP16(DOUBLE_FAULT_STACK_SIZE);

#if defined(KE_MULTINODE)

    ProcessorDataSize += ROUNDUP16(sizeof(KNODE));

#endif

    //
    // Add sizeof GDT
    //

    GdtOffset = ProcessorDataSize;
    _asm {
        sgdt    Descriptor.Limit
    }
    ProcessorDataSize += Descriptor.Limit + 1;

    //
    // Add sizeof IDT
    //

    IdtOffset = ProcessorDataSize;
    _asm {
        sidt    Descriptor.Limit
    }
    ProcessorDataSize += Descriptor.Limit + 1;

    //
    // If the registered number of processors is greater than the maximum
    // number of processors supported, then only allow the maximum number
    // of supported processors.
    //

    if (KeRegisteredProcessors > MAXIMUM_PROCESSORS) {
        KeRegisteredProcessors = MAXIMUM_PROCESSORS;
    }

    //
    // Set barrier that will prevent any other processor from entering the
    // idle loop until all processors have been started.
    //

    KiBarrierWait = 1;

    //
    // Loop asking the HAL for the next processor.   Stop when the
    // HAL says there aren't any more.
    //

    for (NewProcessorNumber = 1;
         NewProcessorNumber < MAXIMUM_PROCESSORS;
         NewProcessorNumber++) {

        if ((KeFeatureBits & KF_SMT) == 0) {

            //
            // If all the processors in the system support Simultaneous
            // Multi-Threading we allow the additional logical processors
            // in a set to run under the same license as the first logical
            // processor in a set.
            //
            // Otherwise, do not attempt to start more processors than 
            // there are licenses for.   (This is because as of Whistler
            // Beta2 we are having problems with systems that send SMIs
            // to processors that are not in "wait for SIPI" state.   The
            // code to scan for additional logical processors causes 
            // processors not licensed to be in a halted state).
            //
            // PeterJ 03/02/01.
            //

            if (NewProcessorNumber >= KeRegisteredProcessors) {
                break;
            }
        }


#if defined(KE_MULTINODE)

        Status = KiQueryProcessorNode(NewProcessorNumber,
                                      &ProcessorId,
                                      &NodeNumber);
        if (!NT_SUCCESS(Status)) {

            //
            // No such processor, advance to next.
            //

            continue;
        }

        Node = KeNodeBlock[NodeNumber];

#endif

        //
        // Allocate memory for the new processor specific data.  If
        // the allocation fails, stop starting processors.
        //

        PerProcessorAllocation =
            MmAllocateIndependentPages (ProcessorDataSize, NodeNumber);

        if (PerProcessorAllocation == NULL) {
            break;
        }

        Base = (PUCHAR)PerProcessorAllocation;

        //
        //  Build up a processor state for new processor
        //

        RtlZeroMemory ((PVOID) &ProcessorState, sizeof ProcessorState);

        //
        //  Give the new processor its own GDT
        //

        _asm {
            sgdt    Descriptor.Limit
        }

        KiCloneDescriptor (&Descriptor,
                           &ProcessorState.SpecialRegisters.Gdtr,
                           Base + GdtOffset);

        pGDT = (PKGDTENTRY) ProcessorState.SpecialRegisters.Gdtr.Base;


        //
        //  Give new processor its own IDT
        //

        _asm {
            sidt    Descriptor.Limit
        }
        KiCloneDescriptor (&Descriptor,
                           &ProcessorState.SpecialRegisters.Idtr,
                           Base + IdtOffset);


        //
        //  Give new processor its own TSS and PCR
        //

        KiCloneSelector (KGDT_R0_PCR, pGDT, &PCRDesc, Base);
        RtlZeroMemory (Base, ROUNDUP16(sizeof(KPCR)));
        Base += ROUNDUP16(sizeof(KPCR));

        KiCloneSelector (KGDT_TSS, pGDT, &TSSDesc, Base);
        Base += ROUNDUP16(sizeof(KTSS));

        //
        // Idle Thread thread object.
        //

        pThreadObject = Base;
        RtlZeroMemory(Base, sizeof(ETHREAD));
        Base += ROUNDUP16(sizeof(ETHREAD));

        //
        // NMI TSS and double-fault TSS & stack.
        //

        KiCloneSelector (KGDT_DF_TSS, pGDT, &DFTSSDesc, Base);
        Base += ROUNDUP16(FIELD_OFFSET(KTSS, IoMaps));

        KiCloneSelector (KGDT_NMI_TSS, pGDT, &NMITSSDesc, Base);
        Base += ROUNDUP16(FIELD_OFFSET(KTSS, IoMaps));

        Base += DOUBLE_FAULT_STACK_SIZE;

        pTSS = (PKTSS)DFTSSDesc.Base;
        pTSS->Esp0 = (ULONG)Base;
        pTSS->Esp  = (ULONG)Base;

        pTSS = (PKTSS)NMITSSDesc.Base;
        pTSS->Esp0 = (ULONG)Base;
        pTSS->Esp  = (ULONG)Base;

        //
        //  Set other SpecialRegisters in processor state
        //

        _asm {
            mov     eax, cr0
            and     eax, NOT (CR0_AM or CR0_WP)
            mov     ProcessorState.SpecialRegisters.Cr0, eax
            mov     eax, cr3
            mov     ProcessorState.SpecialRegisters.Cr3, eax

            pushfd
            pop     eax
            mov     ProcessorState.ContextFrame.EFlags, eax
            and     ProcessorState.ContextFrame.EFlags, NOT EFLAGS_INTERRUPT_MASK
        }

        ProcessorState.SpecialRegisters.Tr  = KGDT_TSS;
        pGDT[KGDT_TSS>>3].HighWord.Bytes.Flags1 = 0x89;

#if defined(_X86PAE_)
        ProcessorState.SpecialRegisters.Cr4 = CR4_PAE;
#endif

        //
        // Allocate a DPC stack, idle thread stack and ThreadObject for
        // the new processor.
        //

        pStack = MmCreateKernelStack (FALSE, NodeNumber);
        pDpcStack = MmCreateKernelStack (FALSE, NodeNumber);

        //
        //  Setup context
        //  Push variables onto new stack
        //

        pTopOfStack = (PULONG) pStack;
        pTopOfStack[-1] = (ULONG) KeLoaderBlock;
        ProcessorState.ContextFrame.Esp = (ULONG) (pTopOfStack-2);
        ProcessorState.ContextFrame.Eip = (ULONG) KiSystemStartup;

        ProcessorState.ContextFrame.SegCs = KGDT_R0_CODE;
        ProcessorState.ContextFrame.SegDs = KGDT_R3_DATA;
        ProcessorState.ContextFrame.SegEs = KGDT_R3_DATA;
        ProcessorState.ContextFrame.SegFs = KGDT_R0_PCR;
        ProcessorState.ContextFrame.SegSs = KGDT_R0_DATA;


        //
        //  Initialize new processor's PCR & Prcb
        //

        KiInitializePcr (
            (ULONG)       NewProcessorNumber,
            (PKPCR)       PCRDesc.Base,
            (PKIDTENTRY)  ProcessorState.SpecialRegisters.Idtr.Base,
            (PKGDTENTRY)  ProcessorState.SpecialRegisters.Gdtr.Base,
            (PKTSS)       TSSDesc.Base,
            (PKTHREAD)    pThreadObject,
            (PVOID)       pDpcStack
        );

        NewPrcb = ((PKPCR)(PCRDesc.Base))->Prcb;

        //
        // Assume new processor will be the first processor in its
        // SMT set.   (Right choice for non SMT processors, adjusted
        // later if not correct).
        //

        NewPrcb->MultiThreadSetMaster = NewPrcb;

#if defined(KE_MULTINODE)

        //
        // If this is the first processor on this node, use the
        // space allocated for KNODE as the KNODE.
        //

        if (KeNodeBlock[NodeNumber] == &KiNodeInit[NodeNumber]) {
            Node = (PKNODE)Base;
            *Node = KiNodeInit[NodeNumber];
            KeNodeBlock[NodeNumber] = Node;
        }
        Base += ROUNDUP16(sizeof(KNODE));

        NewPrcb->ParentNode = Node;

#else

        NewPrcb->ParentNode = KeNodeBlock[0];

#endif

        ASSERT(((PUCHAR)PerProcessorAllocation + GdtOffset) == Base);

        //
        //  Adjust LoaderBlock so it has the next processors state
        //

        KeLoaderBlock->KernelStack = (ULONG) pTopOfStack;
        KeLoaderBlock->Thread = (ULONG) pThreadObject;
        KeLoaderBlock->Prcb = (ULONG) NewPrcb;

RetryStartProcessor:

        //
        // Get CPUID(1) info from the starting processor.
        //

        KiProcessorStartData[0] = 1;
        KiProcessorStartControl = KcStartGetId;

        //
        //  Contact hal to start new processor
        //

        NewProcessor = HalStartNextProcessor (KeLoaderBlock, &ProcessorState);


        if (!NewProcessor) {

            //
            //  There wasn't another processor, so free resources and
            //  break
            //

            KiProcessorBlock[NewProcessorNumber] = NULL;
            MmFreeIndependentPages ( PerProcessorAllocation, ProcessorDataSize);
            MmDeleteKernelStack ( pStack, FALSE);
            MmDeleteKernelStack ( pDpcStack, FALSE);
            break;
        }

        //
        // Wait for the new processor to fill in the CPUID data requested.
        //

        NewLicense = TRUE;
        if (KiStartWaitAcknowledge() == TRUE) {

            if (KiProcessorStartData[3] & 0x10000000) {

                //
                // This processor might support SMT, in which case, if this
                // is not the first logical processor in an SMT set, it should
                // not be charged a license.   If it is the first in a set, 
                // and the total number of sets exceeds the number of licensed
                // processors, this processor should not be allowed to start.
                //

                ULONG ApicMask;
                ULONG ApicId;
                ULONG i;
                PKPRCB SmtCheckPrcb;

                //
                // Round number of logical processors per physical processor
                // up to a power of two then subrtact 1 to get the logical
                // processor apic mask.
                //

                ApicMask = (KiProcessorStartData[1] >> 16) & 0xff;
                ApicMask = ApicMask + ApicMask - 1;
                KeFindFirstSetLeftMember(ApicMask, &ApicMask);
                ApicMask = ~((1 << ApicMask) - 1);
                ApicId = (KiProcessorStartData[1] >> 24) & ApicMask;

                //
                // Check to see if any started processor is in the same
                // set.
                //

                for (i = 0; i < NewProcessorNumber; i++) {
                    SmtCheckPrcb = KiProcessorBlock[i];
                    if (SmtCheckPrcb) {
                        if ((SmtCheckPrcb->InitialApicId & ApicMask) == ApicId) {
                            NewLicense = FALSE;
                            NewPrcb->MultiThreadSetMaster = SmtCheckPrcb;
                            break;
                        }
                    }
                }
            }
        }

        if ((NewLicense == FALSE)  &&
            ((KeNumprocSpecified == 0) ||
             (KeRegisteredProcessors < KeNumprocSpecified))) {

            //
            // This processor is a logical processor in the same SMT
            // set as another logical processor.   Don't charge a 
            // license for it.
            //

            KeRegisteredProcessors++;
        } else {

            //
            // The new processor is the first or only logical processor
            // in a physical processor.  If the number of physical
            // processors exceeds the license, don't start this processor.
            //

            if ((ULONG)KeNumberProcessors >= KeRegisteredProcessors) {
                KiProcessorStartControl = KcStartDoNotStart;
                KiStartWaitAcknowledge();

                if (++RejectedProcessorCount > REJECT_PROCESSOR_LIMIT) {

                    //
                    // The HAL must not be advancing to the next
                    // processor.   Give up.
                    //
                    // Note:  This test is due to the introduction
                    // of this feature of asking the HAL for a new
                    // processor (using the same processor number
                    // as the just rejected processor).   If the 
                    // HAL does not support advancing under this
                    // condition we would loop here forever.
                    //

                    break;
                }

                //
                // The new processor has now returned to the state it
                // was in before the HAL initialized it.  Have the
                // HAL start the next processor using the same resource
                // set.
                //

                goto RetryStartProcessor;
            }
        }
        KiProcessorStartControl = KcStartContinue;

#if defined(KE_MULTINODE)

        Node->ProcessorMask |= 1 << NewProcessorNumber;

#endif

        //
        //  Wait for processor to initialize in kernel, then loop for another
        //

        while (*((volatile ULONG *) &KeLoaderBlock->Prcb) != 0) {
            KeYieldProcessor();
        }
    }

    //
    // All processors have been stated.
    //

    KiAllProcessorsStarted();

    //
    // Reset and synchronize the performance counters of all processors, by
    // applying a null adjustment to the interrupt time
    //

    KiAdjustInterruptTime (0);

    //
    // Allow all processors that were started to enter the idle loop and
    // begin execution.
    //

    KiBarrierWait = 0;
}



static VOID
KiCloneSelector (
   IN ULONG    SrcSelector,
   IN PKGDTENTRY    pNGDT,
   IN PKDESCRIPTOR  pDestDescriptor,
   IN PVOID         Base
   )

/*++

Routine Description:

    Makes a copy of the current selector's data, and updates the new
    gdt's linear address to point to the new copy.

Arguments:

    SrcSelector     -   Selector value to clone
    pNGDT           -   New gdt table which is being built
    DescDescriptor  -   descriptor structure to fill in with resulting memory
    Base            -   Base memory for the new descriptor.

Return Value:

    None.

--*/

{
    KDESCRIPTOR Descriptor;
    PKGDTENTRY  pGDT;
    ULONG       CurrentBase;
    ULONG       NewBase;

    _asm {
        sgdt    fword ptr [Descriptor.Limit]    ; Get GDT's addr
    }

    pGDT   = (PKGDTENTRY) Descriptor.Base;
    pGDT  += SrcSelector >> 3;
    pNGDT += SrcSelector >> 3;

    CurrentBase = pGDT->BaseLow | (pGDT->HighWord.Bits.BaseMid << 16) |
                 (pGDT->HighWord.Bits.BaseHi << 24);

    Descriptor.Base  = CurrentBase;
    Descriptor.Limit = pGDT->LimitLow;
    if (pGDT->HighWord.Bits.Granularity & GRAN_PAGE)
        Descriptor.Limit = (Descriptor.Limit << PAGE_SHIFT) -1;

    KiCloneDescriptor (&Descriptor, pDestDescriptor, Base);
    NewBase = pDestDescriptor->Base;

    pNGDT->BaseLow = (USHORT) NewBase & 0xffff;
    pNGDT->HighWord.Bits.BaseMid = (UCHAR) (NewBase >> 16) & 0xff;
    pNGDT->HighWord.Bits.BaseHi  = (UCHAR) (NewBase >> 24) & 0xff;
}



static VOID
KiCloneDescriptor (
   IN PKDESCRIPTOR  pSrcDescriptor,
   IN PKDESCRIPTOR  pDestDescriptor,
   IN PVOID         Base
   )

/*++

Routine Description:

    Makes a copy of the specified descriptor, and supplies a return
    descriptor for the new copy

Arguments:

    pSrcDescriptor  - descriptor to clone
    pDescDescriptor - the cloned descriptor
    Base            - Base memory for the new descriptor.

Return Value:

    None.

--*/
{
    ULONG   Size;

    Size = pSrcDescriptor->Limit + 1;
    pDestDescriptor->Limit = (USHORT) Size -1;
    pDestDescriptor->Base  = (ULONG)  Base;

    RtlCopyMemory(Base, (PVOID)pSrcDescriptor->Base, Size);
}


VOID
KiAdjustSimultaneousMultiThreadingCharacteristics(
    VOID
    )

/*++

Routine Description:

    This routine is called (possibly while the dispatcher lock is held)
    after processors are added to or removed from the system.   It runs
    thru the PRCBs for each processor in the system and adjusts scheduling
    data.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG ProcessorNumber;
    ULONG BuddyNumber;
    KAFFINITY ProcessorSet;
    PKPRCB Prcb;
    PKPRCB BuddyPrcb;
    ULONG ApicMask;
    ULONG ApicId;
    ULONG NextIndependent;

    if ((KeFeatureBits & KF_SMT) == 0) {

        //
        // Nobody doing SMT, nothing to do.
        //

        return;
    }

    for (ProcessorNumber = 0;
         ProcessorNumber < (ULONG)KeNumberProcessors;
         ProcessorNumber++) {

        Prcb = KiProcessorBlock[ProcessorNumber];

        //
        // Skip processors which are not present or which do not
        // support Simultaneous Multi Threading.
        //

        if ((Prcb == NULL) || ((Prcb->FeatureBits & KF_SMT) == 0)) {
            continue;
        }

        NextIndependent = 0;

        //
        // Find all processors with the same physical processor APIC ID.
        // The APIC ID for the physical processor is the upper portion
        // of the APIC ID, the number of bits in the lower portion is
        // log 2 (number logical processors per physical rounded up to
        // a power of 2).
        //

        ASSERT(Prcb->LogicalProcessorsPerPhysicalProcessor);

        ApicId = Prcb->InitialApicId;
        ApicMask = Prcb->LogicalProcessorsPerPhysicalProcessor;

        if (ApicMask == 0) {

            //
            // Sanity fails:  This processor isn't right.
            //

            continue;
        }

        //
        // Round number of logical processors up to a power of 2
        // then subtract one to get the logical processor apic mask.
        //

        ApicMask = ApicMask + ApicMask - 1;
        KeFindFirstSetLeftMember(ApicMask, &ApicMask);
        ApicMask = ~((1 << ApicMask) - 1);

        ApicId &= ApicMask;

        ProcessorSet = 1 << Prcb->Number;

        //
        // Examine each remaining processor to see if it is part of
        // the same set.
        //

        for (BuddyNumber = ProcessorNumber + 1;
             BuddyNumber < (ULONG)KeNumberProcessors;
             BuddyNumber++) {

            BuddyPrcb = KiProcessorBlock[BuddyNumber];

            //
            // Skip not present, not SMT.
            //

            if ((BuddyPrcb == NULL) ||
                ((BuddyPrcb->FeatureBits & KF_SMT) == 0)) {
                continue;
            }

            //
            // Does this processor have the same ID as the one
            // we're looking for?
            //

            if ((BuddyPrcb->InitialApicId & ApicMask) != ApicId) {

                //
                // No, if this is the first occurance on another
                // APIC Id (relative to the processor we're examining)
                // then remember this processor as it's the next
                // independent processor.
                //

                if (!NextIndependent) {
                    NextIndependent = BuddyNumber;
                }
                continue;
            }

            //
            // Match.
            //

            ASSERT(Prcb->LogicalProcessorsPerPhysicalProcessor ==
                   BuddyPrcb->LogicalProcessorsPerPhysicalProcessor);

            ProcessorSet |= 1 << BuddyPrcb->Number;
            BuddyPrcb->MultiThreadProcessorSet |= ProcessorSet;
        }

        Prcb->MultiThreadProcessorSet |= ProcessorSet;
    }
}


VOID
KiAllProcessorsStarted(
    VOID
    )

/*++

Routine Description:

    This routine is called once all processors in the system
    have been started.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG i;

    //
    // If the system contains Simultaneous Multi Threaded processors,
    // adjust grouping information now that each processor is started.
    //

    KiAdjustSimultaneousMultiThreadingCharacteristics();

#if defined(KE_MULTINODE)

    //
    // Make sure there are no references to the temporary nodes
    // used during initialization.
    //

    for (i = 0; i < KeNumberNodes; i++) {
        if (KeNodeBlock[i] == &KiNodeInit[i]) {

            //
            // No processor started on this node so no new node
            // structure has been allocated.   This is possible
            // if the node contains only memory or IO busses.  At
            // this time we need to allocate a permanent node
            // structure for the node.
            //

            KeNodeBlock[i] = ExAllocatePoolWithTag(NonPagedPool,
                                                   sizeof(KNODE),
                                                   '  eK');
            if (KeNodeBlock[i]) {
                *KeNodeBlock[i] = KiNodeInit[i];
            }
        }
    }

    for (i = KeNumberNodes; i < MAXIMUM_CCNUMA_NODES; i++) {
        KeNodeBlock[i] = NULL;
    }

#endif

    if (KeNumberNodes == 1) {

        //
        // For Non NUMA machines, Node 0 gets all processors.
        //

        KeNodeBlock[0]->ProcessorMask = KeActiveProcessors;
    }
}


#if defined(KE_MULTINODE)

NTSTATUS
KiNotNumaQueryProcessorNode(
    IN ULONG ProcessorNumber,
    OUT PUSHORT Identifier,
    OUT PUCHAR Node
    )

/*++

Routine Description:

    This routine is a stub used on non NUMA systems to provide a
    consistent method of determining the NUMA configuration rather
    than checking for the presense of multiple nodes inline.

Arguments:

    ProcessorNumber supplies the system logical processor number.
    Identifier      supplies the address of a variable to receive
                    the unique identifier for this processor.
    NodeNumber      supplies the address of a variable to receive
                    the number of the node this processor resides on.

Return Value:

    Returns success.

--*/

{
    *Identifier = (USHORT)ProcessorNumber;
    *Node = 0;
    return STATUS_SUCCESS;
}

#endif

VOID
KiProcessorStart(
    VOID
    )

/*++

Routine Description:

    
    This routine is a called when a processor begins execution.
    It is used to pass processor characteristic information to 
    the boot processor and to control the starting or non-starting
    of this processor.

Arguments:

    None.

Return Value:

    None.

--*/

{
    while (TRUE) {
        switch (KiProcessorStartControl) {

        case KcStartContinue:
            return;

        case KcStartWait:
            KeYieldProcessor();
            break;

        case KcStartGetId:
            CPUID(KiProcessorStartData[0],
                  &KiProcessorStartData[0],
                  &KiProcessorStartData[1],
                  &KiProcessorStartData[2],
                  &KiProcessorStartData[3]);
            KiProcessorStartControl = KcStartWait;
            break;

        case KcStartDoNotStart:

            //
            // The boot processor has determined that this processor
            // should NOT be started.
            //
            // Acknowledge the command so the boot processor will
            // continue, disable interrupts (should already be 
            // the case here) and HALT the processor.
            //

            KiProcessorStartControl = KcStartWait;
            _disable();
            while(1) {
                _asm { hlt };
            }

        default:

            //
            // Not much we can do with unknown commands.
            //

            KiProcessorStartControl = KcStartCommandError;
            break;
        }
    }
}

BOOLEAN
KiStartWaitAcknowledge(
    VOID
    )
{
    while (KiProcessorStartControl != KcStartWait) {
        if (KiProcessorStartControl == KcStartCommandError) {
            return FALSE;
        }
        KeYieldProcessor();
    }
    return TRUE;
}

#endif      // !NT_UP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\abios.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    abios.h

Abstract:

    This module contains the i386 kernel ABIOS specific header file.

Author:

    Shie-Lin Tzong (shielint) 22-May-1991

Revision History:

--*/

//
// Define public portion of the ABIOS Device Block
//

typedef struct _KDEVICE_BLOCK {
    USHORT Length;
    UCHAR Revision;
    UCHAR SecondDeviceId;
    USHORT LogicalId;
    USHORT DeviceId;
    USHORT NumberExclusivePortPairs;
    USHORT NumberCommonPortPairs;
} KDEVICE_BLOCK, *PKDEVICE_BLOCK; 


typedef struct _KABIOS_POINTER {
    USHORT Offset;
    USHORT Selector;
} KABIOS_POINTER, *PKABIOS_POINTER;

#pragma pack(1)

//
// ABIOS Function Transfer Table definition
//

typedef struct _KFUNCTION_TRANSFER_TABLE {
    KABIOS_POINTER CommonRoutine[3];
    USHORT FunctionCount;
    USHORT Reserved;
    KABIOS_POINTER SpecificRoutine;
} KFUNCTION_TRANSFER_TABLE, *PKFUNCTION_TRANSFER_TABLE;


//
// ABIOS Commom Data Area definitions
//

typedef struct _KDB_FTT_SECTION {
    KABIOS_POINTER DeviceBlock;
    KABIOS_POINTER FunctionTransferTable;
} KDB_FTT_SECTION, *PKDB_FTT_SECTION;

typedef struct _KCOMMON_DATA_AREA {
    USHORT DataPointer0Offset;
    USHORT NumberLids;
    ULONG Reserved;
    PKDB_FTT_SECTION DbFttPointer;
} KCOMMON_DATA_AREA, *PKCOMMON_DATA_AREA;

#pragma pack()

//
// Available GDT Entry
//

typedef struct _KFREE_GDT_ENTRY {
    struct _KFREE_GDT_ENTRY *Flink;
    ULONG BaseMid : 8;
    ULONG Type : 5;
    ULONG Dpl : 2;
    ULONG Present : 1;
    ULONG LimitHi : 4;
    ULONG Sys : 1;
    ULONG Reserved_0 : 1;
    ULONG Default_Big : 1;
    ULONG Granularity : 1;
    ULONG BaseHi : 8;
} KFREE_GDT_ENTRY, *PKFREE_GDT_ENTRY;

//
// Logical Id table entry
//

typedef struct _KLID_TABLE_ENTRY {
    ULONG Owner;
    ULONG OwnerCount;
} KLID_TABLE_ENTRY, *PKLID_TABLE_ENTRY;

#define LID_NO_SPECIFIC_OWNER  0xffffffff
#define NUMBER_LID_TABLE_ENTRIES 1024

//
// Macro to extract the high byte of a short offset
//

#define HIGHBYTE(l) ((UCHAR)(((USHORT)(l)>>8) & 0xff))

//
// Macro to extract the low byte of a short offset
//

#define LOWBYTE(l) ((UCHAR)(l))

//
// The following selectors are reserved for 16 bit stack, code and 
// ABIOS Common Data Area.
//

#define KGDT_STACK16 0xf8
#define KGDT_CODE16 0xf0
#define KGDT_CDA16  0xe8         
#define KGDT_GDT_ALIAS 0x70

//
// Misc. definitions
//

#define RESERVED_GDT_ENTRIES  28

//
// External references
//

extern PKFREE_GDT_ENTRY KiAbiosGdtStart;
extern PKFREE_GDT_ENTRY KiAbiosGdtEnd;
extern PUCHAR KiEndOfCode16;
extern ULONG KiStack16GdtEntry;

extern 
VOID
KiI386CallAbios(
    IN KABIOS_POINTER AbiosFunction,
    IN KABIOS_POINTER DeviceBlockPointer,
    IN KABIOS_POINTER FunctionTransferTable,
    IN KABIOS_POINTER RequestBlock
    );

VOID
KiInitializeAbiosGdtEntry (
    OUT PKGDTENTRY GdtEntry,
    IN ULONG Base,
    IN ULONG Limit,
    IN USHORT Type
    );

extern
ULONG
KiAbiosGetGdt (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\abiosa.asm ===
title  "Abios Support Assembly Routines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    abiosa.asm
;
; Abstract:
;
;    This module implements assembley code for ABIOS support.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 25-May-1991
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
        .list

extrn   _DbgPrint:proc

EXTRNP _KeRaiseIrql,2,IMPORT
EXTRNP _KeLowerIrql,1,IMPORT
EXTRNP _KeGetCurrentIrql,0,IMPORT
extrn _KiStack16GdtEntry:DWORD

;
; This should be either 0 or 1, if it's greater than 1, then we've re-entered the BIOS.
;
extrn _KiInBiosCall:DWORD
extrn _FlagState:DWORD
extrn _KiBiosFrame:DWORD

OPERAND_OVERRIDE        equ     66h
ADDRESS_OVERRIDE        equ     67h
KGDT_CDA16              equ     0E8h

LocalStack                              equ     16          ; 4 DWORDS of slop for PnPBioses.

if DBG
extrn  KiBiosReenteredAssert:DWORD
endif

; Macro change note:
;
;   This macro pair used to do an uncondtional sti coming back from the 16-bit
;   side, this potentially caused problems in APM. Now we save and restore the
;   flag state
;

;++
;
;   STACK32_TO_STACK16
;
;   Macro Description:
;
;       This macro remaps current 32bit stack to 16bit stack.
;
;   Arguments:
;
;       None.
;
;--

STACK32_TO_STACK16      macro

        pushfd
        mov     ecx,[esp]
        mov     _FlagState,ecx
        popfd
        mov     eax, fs:PcStackLimit    ; [eax] = 16-bit stack selector base
        mov     edx, eax
        mov     ecx, _KiStack16GdtEntry
        mov     word ptr [ecx].KgdtBaseLow, ax
        shr     eax, 16
        mov     byte ptr [ecx].KgdtBaseMid, al
        mov     byte ptr [ecx].KgdtBaseHi, ah
        mov     eax, esp
        sub     eax, edx
        cli
        mov     esp, eax
        mov     eax, KGDT_STACK16
        mov     ss, ax

;
; NOTE that we MUST leave interrupts remain off.
; We'll turn it back on after we switch to 16 bit code.
;

endm

;++
;
;   STACK16_TO_STACK32
;
;   Macro Description:
;
;       This macro remaps current 32bit stack to 16bit stack.
;
;   Arguments:
;
;       None.
;
;--

STACK16_TO_STACK32      macro   Stack32

        db      OPERAND_OVERRIDE
        mov     eax, esp
        db      OPERAND_OVERRIDE
        db      ADDRESS_OVERRIDE
        add     eax, fs:PcStackLimit
        cli
        db      OPERAND_OVERRIDE
        mov     esp, eax
        db      OPERAND_OVERRIDE
        mov     eax, KGDT_R0_DATA
        mov     ss, ax
        db      OPERAND_OVERRIDE
        db      ADDRESS_OVERRIDE
        push ds:_FlagState
        db      OPERAND_OVERRIDE
        popfd
endm

COPY_CALL_FRAME macro FramePtr

        mov     [FramePtr].TsEax,eax
        mov     [FramePtr].TsEbx,ebx
        mov     [FramePtr].TsEcx,ecx
        mov     [FramePtr].TsEdx,edx
        mov     [FramePtr].TsEsi,esi
        mov     [FramePtr].TsEdi,edi
        mov     [FramePtr].TsEbp,ebp
        mov     [FramePtr].TsHardwareEsp,esp
        mov     [FramePtr].TsSegFs,fs
        mov     [FramePtr].TsSegCs,cs
endm
        page ,132
        subttl  "Abios Support Code"
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; BBT cannot instrument code between this label and BBT_Exclude_Selector_Code_End
;
        public  _BBT_Exclude_Selector_Code_Begin
_BBT_Exclude_Selector_Code_Begin  equ     $
        int 3


;++
; ULONG
; KiAbiosGetGdt (
;     VOID
;     )
;
; Routine Description:
;
;     This routine returns the starting address of GDT of current processor.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     return Pcr->GDT
;
;--

cPublicProc _KiAbiosGetGdt,0

        mov     eax, fs:PcGdt
        stdRET    _KiAbiosGetGdt

stdENDP _KiAbiosGetGdt

;++
; VOID
; KiI386CallAbios(
;     IN KABIOS_POINTER AbiosFunction,
;     IN KABIOS_POINTER DeviceBlockPointer,
;     IN KABIOS_POINTER FunctionTransferTable,
;     IN KABIOS_POINTER RequestBlock
;     )
;
; Routine Description:
;
;     This function invokes ABIOS service function for device driver.  This
;     routine is executing at DIAPTCH_LEVEL to prevent context swapping.
;
;     N.B. We arrive here from the Ke386AbiosCall with a 32bit CS. That is,
;     we're executing the code with cs:eip where cs contains a selector for a
;     32bit flat segment. We want to get to a 16bit cs. That is, cs:ip.
;     The reason is that ABIOS is running at 16 bit segment.
;     Before we can call ABIOS service we must load ss and cs segment
;     registers with selectors for 16bit segments.  We start by pushing a far
;     pointer to a label in the macro and then doing a retf. This allows us
;     to fall through to the next instruction, but we're now executing
;     through cs:ip with a 16bit CS. Then, we remap our 32-bit stack to 16-bit
;     stack.
;
; Arguments:
;
;     AbiosFunction - a 16:16 pointer to the abios service function.
;
;     DeviceBlockPointer - a 16:16 pointer to Device Block.
;
;     FunctionTransferTable - a 16:16 pointer to Function Transfer Table.
;
;     RequestBlock - a 16:16 pointer to device driver's request block.
;
; Return Value:
;
;     None.
;--

KacAbiosFunction        equ     [ebp + 8]
KacDeviceBlock          equ     [ebp + 12]
KacFunctionTable        equ     [ebp + 16]
KacRequestBlock         equ     [ebp + 20]

cPublicProc _KiI386CallAbios,4

;
; We're using a 32bit CS:EIP - go to a 16bit CS:IP
; Note the base of KiAbiosCallSelector is the flat address of _KiI386AbiosCall
; routine.
;

        push    ebp
        mov     ebp, esp
        push    ebx

        COPY_CALL_FRAME _KiBiosFrame
        sub     esp,LocalStack          ; After C style frame
        stdCall _KeGetCurrentIrql
        push    eax                             ; Local Varible

        cmp     al, DISPATCH_LEVEL              ; Is irql > Dispatch_level?
        jae     short Kac00

; Raise to Dispatch Level
        mov     eax, esp
        stdCall   _KeRaiseIrql, <DISPATCH_LEVEL,eax>

Kac00:

;
; Set up parameters on stack before remapping stack.
;

        push    word ptr KGDT_CDA16             ; CDA anchor selector
        push    KacRequestBlock                 ; Request Block
        push    KacFunctionTable                ; Func transfer table
        push    KacDeviceBlock                  ; Device Block
        mov     ebx, KacAbiosFunction           ; (ebx)-> Abios Entry

;
; Remap current stack to 16:16 stack.  The base of the 16bit stack selector is
; the base of current kernel stack.
;

        inc     _KiInBiosCall                         ; Set the 'In Bios' flag
if DBG
        cmp   _KiInBiosCall,2
        jb  @F
        push    offset FLAT:KiBiosReenteredAssert
        call    _dbgPrint
        add     esp, 4
@@:
endif

        STACK32_TO_STACK16                      ; Switch to 16bit stack
        push    word ptr KGDT_CODE16
IFDEF STD_CALL
        push    word ptr (offset FLAT:Kac40 - offset FLAT:_KiI386CallAbios@16)
        push    KGDT_CODE16
        push    offset FLAT:Kac30 - offset FLAT:_KiI386CallAbios@16
ELSE
        push    word ptr (offset FLAT:Kac40 - offset FLAT:_KiI386CallAbios)
        push    KGDT_CODE16
        push    offset FLAT:Kac30 - offset FLAT:_KiI386CallAbios
ENDIF
        retf

Kac30:

;
; Stack switching (from 32 to 16) turns interrupt off.  We must turn it
; back on.
;

        sti
        push    bx                              ; Yes, BX not EBX!
        retf
Kac40:
        add     esp, 14                         ; pop out all the parameters

        STACK16_TO_STACK32                      ; switch back to 32 bit stack

;
; Pull callers flat return address off stack and push the
; flat code selector followed by the return offset, then
; execute a far return and we'll be back in the 32-bit code space.
;

        db      OPERAND_OVERRIDE
        push    KGDT_R0_CODE
        db      OPERAND_OVERRIDE
        push    offset FLAT:Kac50
        db      OPERAND_OVERRIDE
        retf
Kac50:
        pop     eax                             ; [eax] = OldIrql
        pop     ebx                             ; restore ebx
        cmp     al, DISPATCH_LEVEL
        jae     short Kac60

        stdCall   _KeLowerIrql, <eax>             ; Lower irql to original level
Kac60:

        dec     _KiInBiosCall                          ;Clear 'In Bios' Flag

        add     esp,LocalStack                           ; subtract off the scratch space
        pop     ebp
        stdRET    _KiI386CallAbios

stdENDP _KiI386CallAbios


;; ********************************************************
;;
;; BEGIN - power_management
;;
;;

;++
; VOID
; KeI386Call16BitFunction (
;     IN OUT PCONTEXT Regs
;     )
;
; Routine Description:
;
;     This function calls the 16 bit function specified in the Regs.
;
; Parameters:
;
;     Regs - supplies a pointer to register context to call 16 function.
;
;   NOTE: Caller must be at DPC_LEVEL
;
;--

cPublicProc _KeI386Call16BitFunction,1

    ;  verify CurrentIrql
    ;  verify context flags

        push    ebp                             ; save nonvolatile registers
        push    ebx
        push    esi
        push    edi
        mov     ebx, dword ptr [esp + 20]       ; (ebx)-> Context

        COPY_CALL_FRAME _KiBiosFrame

        sub     esp,LocalStack          ; After prolog

        inc    _KiInBiosCall                         ; Set the 'In Bios' flag
if DBG
        cmp   _KiInBiosCall,2
        jb  @F
        push    offset FLAT:KiBiosReenteredAssert
        call    _dbgPrint
        add     esp, 4
@@:
endif

;
; We're using a 32bit CS:EIP - go to a 16bit CS:IP
; Note the base of KiAbiosCallSelector is the flat address of _KiI386AbiosCall
; routine.
;

;
; Remap current stack to 16:16 stack.  The base of the 16bit stack selector is
; the base of current kernel stack.
;

        STACK32_TO_STACK16                      ; Switch to 16bit stack
    ;
    ; Push return address from 16 bit function call to kernel
    ;

        push    word ptr KGDT_CODE16
        push    word ptr (offset FLAT:Kbf40 - offset FLAT:_KiI386CallAbios@16)

        ;
        ; Load context to call with
        ;

        push    word ptr [ebx].CsEFlags
        push    word ptr [ebx].CsSegCs
        push    word ptr [ebx].CsEip

        mov     eax, [ebx].CsEax
        mov     ecx, [ebx].CsEcx
        mov     edx, [ebx].CsEdx
        mov     edi, [ebx].CsEdi
        mov     esi, [ebx].CsEsi
        mov     ebp, [ebx].CsEbp
        push    [ebx].CsSegGs
        push    [ebx].CsSegFs
        push    [ebx].CsSegEs
        push    [ebx].CsSegDs
        mov     ebx, [ebx].CsEbx
        pop     ds
        pop     es
        pop     fs
        pop     gs

    ;
    ; Switch to 16bit CS
    ;
        push    KGDT_CODE16
        push    offset FLAT:Kbf30 - offset FLAT:_KiI386CallAbios@16
        retf

Kbf30:
    ;
    ; "call" to 16 bit function
    ;
        iretd

Kbf40:
    ;
    ; Push some of the returned context which will be needed to
    ; switch back to the 32 bit SS & CS.
    ;
        db      OPERAND_OVERRIDE
        push    ds

        db      OPERAND_OVERRIDE
        push    es

        db      OPERAND_OVERRIDE
        push    fs

        db      OPERAND_OVERRIDE
        push    gs

        db      OPERAND_OVERRIDE
        push    eax

        db      OPERAND_OVERRIDE
        pushfd

        db      OPERAND_OVERRIDE
        mov     eax, KGDT_R0_PCR
        mov     fs, ax

        db      OPERAND_OVERRIDE
        mov     eax, KGDT_R3_DATA OR RPL_MASK
        mov     ds, ax
        mov     es, ax

        xor     eax, eax

    ;
    ; Switch back to 32 bit stack
    ;

        STACK16_TO_STACK32

;
; Push the flat code selector followed by the return offset, then
; execute a far return and we'll be back in the 32-bit code space.
;


        db      OPERAND_OVERRIDE
        push    KGDT_R0_CODE
        db      OPERAND_OVERRIDE
        push    offset FLAT:Kbf50
        db      OPERAND_OVERRIDE
        retf

Kbf50:
    ;
    ; Return resulting context
    ;

        mov     eax, dword ptr [esp+44+LocalStack]     ; (eax) = Context Record
        pop     [eax].CsEflags
        pop     [eax].CsEax
        pop     [eax].CsSegGs
        pop     [eax].CsSegFs
        pop     [eax].CsSegEs
        pop     [eax].CsSegDs

        mov     [eax].CsEbx, ebx
        mov     [eax].CsEcx, ecx
        mov     [eax].CsEdx, edx
        mov     [eax].CsEdi, edi
        mov     [eax].CsEsi, esi
        mov     [eax].CsEbp, ebp

;
; Restore regs & return
;
        dec     _KiInBiosCall                         ; Clear  the 'In Bios' flag

        add     esp,LocalStack                                          ;remove scratch space
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        stdRET    _KeI386Call16BitFunction

stdENDP _KeI386Call16BitFunction

;++
; USHORT
; KeI386Call16BitCStyleFunction (
;     IN ULONG EntryOffset,
;     IN ULONG EntrySelector,
;     IN PUCHAR Parameters,
;     IN ULONG Size
;     )
;
; Routine Description:
;
;     This function calls the 16 bit function which supports C style calling convension.
;
; Parameters:
;
;     EntryOffset and EntrySelector - specifies the entry point of the 16 bit function.
;
;     Parameters - supplies a pointer to a parameter block which will be
;         passed to 16 bit function as parameters.
;
;     Size - supplies the size of the parameter block.
;
;   NOTE: Caller must be at DPC_LEVEL
;
; Returned Value:
;
;     AX returned by 16 bit function.
;
;--

cPublicProc _KeI386Call16BitCStyleFunction,4

;
;  verify CurrentIrql
;  verify context flags
;

        push    ebp                             ; save nonvolatile registers
        push    ebx
        push    esi
        push    edi

        COPY_CALL_FRAME _KiBiosFrame

        inc     _KiInBiosCall                         ; Set the 'In Bios' flag
if DBG
        cmp   _KiInBiosCall,2
        jb  @F
        push    offset FLAT:KiBiosReenteredAssert
        call    _dbgPrint
        add     esp, 4
@@:
endif

        mov     edi, esp
        sub     esp,LocalStack          ;  now, add in some scratch space
        mov     esi, dword ptr [esp + LocalStack +28]       ; (esi)->BiosParameters
        or         esi, esi
        jz         short @f

        mov    ecx, [esp + LocalStack +32]                 ; (ecx) = parameter size
        sub    esp, ecx                        ; allocate space on TOS to copy parameters

        mov   edi, esp
        rep     movsb                           ; (edi)-> Top of nonvolatile reg save area
        add    edi, LocalStack           ; edi now points to original stack

@@:

;
; We're using a 32bit CS:EIP - go to a 16bit CS:IP
; Note the base of KiAbiosCallSelector is the flat address of _KiI386AbiosCall
; routine.
;

;
; Remap current stack to 16:16 stack.  The base of the 16bit stack selector is
; the base of current kernel stack.
;

        STACK32_TO_STACK16                      ; Switch to 16bit stack

;
; Push return address from 16 bit function call to kernel
;

        push    word ptr KGDT_CODE16
        push    word ptr (offset FLAT:Kbfex40 - offset FLAT:_KiI386CallAbios@16)

        push    word ptr 0200h                  ; flags
        push    word ptr [edi + 24 ]             ; entry selector
        push    word ptr [edi + 20 ]             ; entry offset

;
; Switch to 16bit CS
;
        push    KGDT_CODE16
        push    offset FLAT:Kbfex30 - offset FLAT:_KiI386CallAbios@16
        retf

Kbfex30:
;
; "call" to 16 bit function
;
        iretd

Kbfex40:
;
; Save return value.
;

        db      OPERAND_OVERRIDE
        push    eax

;
; Restore Flat mode segment registers.
;

        db      OPERAND_OVERRIDE
        mov     eax, KGDT_R0_PCR
        mov     fs, ax

        db      OPERAND_OVERRIDE
        mov     eax, KGDT_R3_DATA OR RPL_MASK
        mov     ds, ax
        mov     es, ax

        xor     eax, eax

;
; Switch back to 32 bit stack
;

        STACK16_TO_STACK32

;
; Push the flat code selector followed by the return offset, then
; execute a far return and we'll be back in the 32-bit code space.
;


        db      OPERAND_OVERRIDE
        push    KGDT_R0_CODE
        db      OPERAND_OVERRIDE
        push    offset FLAT:Kbfex50
        db      OPERAND_OVERRIDE
        retf

Kbfex50:
        pop     eax

;
; Restore regs & return
;
        dec    _KiInBiosCall                         ; Clear  the 'In Bios' flag

        mov     esp, edi                                 ; Also removes the scratch space!
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        stdRET    _KeI386Call16BitCStyleFunction

stdENDP _KeI386Call16BitCStyleFunction

;
; BBT cannot instrument code between BBT_Exclude_Selector_Code_Begin and this label
;

        public  _BBT_Exclude_Selector_Code_End
_BBT_Exclude_Selector_Code_End  equ     $
        int 3

;;
;; END - power_management
;;
;; ********************************************************


        public  _KiEndOfCode16
_KiEndOfCode16  equ     $



_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\biosa.asm ===
TITLE   "Call Bios support"
;++
;
;  Copyright (c) 1989  Microsoft Corporation
;
;  Module Name:
;
;     spinlock.asm
;
;  Abstract:
;
;     This module implements the support routines for executing int bios
;     call in v86 mode.
;
;  Author:
;
;     Shie-Lint Tzong (shielint) Sept 10, 1992
;
;  Environment:
;
;     Kernel mode only.
;
;  Revision History:
;
;--

.386p

include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc

VdmStartExecution       EQU     0
V86_STACK_POINTER       equ     11ffeh  ; see BIOSC.C

        EXTRNP  _NtVdmControl,2
        extrn   _KiExceptionExit:PROC

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        PAGE
        SUBTTL "Switch to V86 mode"
;++
;
;  VOID
;  Ki386SetupAndExitToV86Code (
;     VOID
;     )
;
;  Routine Description:
;
;     This function sets up return trap frame, switch stack and
;     calls VdmStartExecution routine to put vdm context to
;     base trap frame and causes the system to execute in v86 mode by
;     doing a KiExceptionExit.
;
;  Arguments:
;
;     BiosArguments - Supplies a pointer to a structure which contains
;                     the arguments for v86 int function.
;
;  Return Value:
;
;     None.
;
;--

cPublicProc _Ki386SetupAndExitToV86Code,1

NewTEB                  equ     [ecx+32] ; location of the parameter based on
                                         ; the ecx stack pointer.
KsaeInitialStack        equ     [ecx]
OriginalThTeb           equ     [ecx+4]
OriginalPcTeb           equ     [ecx+8]

;
; Allocate TRAP FRAME at the bottom of the stack.
;

        push    ebp
        push    ebx
        push    esi
        push    edi
        sub     esp, 12                 ; 12 bytes for local variable
        mov     ecx, esp                ; (ecx) = saved esp

        sub     esp, NPX_FRAME_LENGTH
        and     esp, 0fffffff0h         ; FXSAVE 16 byte alignment requirement
        sub     esp, KTRAP_FRAME_LENGTH ; (esp)-> new trap frame
        mov     eax, esp                ; (eax)->New base trap frame

;
; Initialize newly allocated trap frame to caller's nonvolatle context.
; Note that it is very important that the trap frame we are going to create
; is a USER mode frame.  The system expects the top trap frame for user
; mode thread is a user mode frame.  (Get/SetContext enforce the rule.)
;
; (eax)-> Base of trap frame.
;

        mov     dword ptr [eax].TsSegCs, KGDT_R0_CODE OR RPL_MASK
                                        ; an invalid cs to trap it back to kernel
        mov     dword ptr [eax].TsSegEs, 0
        mov     dword ptr [eax].TsSegDs, 0
        mov     dword ptr [eax].TsSegFs, 0
        mov     dword ptr [eax].TsSegGs, 0
        mov     dword ptr [eax].TsErrCode, 0
        mov     ebx, fs:PcSelfPcr       ; (ebx)->Pcr
        mov     edx, [ebx].PcInitialStack
        mov     KsaeInitialStack, edx  ; (edx)->Pcr InitialSack

        mov     edi, [ebx]+PcPrcbData+PbCurrentThread ; (edi)->CurrentThread
        mov     edx, [edi].ThTeb
        mov     OriginalThTeb, edx

        mov     edx, fs:[PcTeb]
        mov     OriginalPcTeb, edx

        mov     edi, offset Ki386BiosCallReturnAddress
        mov     [eax].TsEsi, ecx       ; Saved esp
        mov     [eax].TsEip, edi       ; set up return address
        pushfd
        pop     edi
        and     edi, 60dd7h
        or      edi, 200h              ; sanitize EFLAGS
        mov     dword ptr [eax].TsHardwareSegSs, KGDT_R3_DATA OR RPL_MASK
        mov     dword ptr [eax].TsHardwareEsp, V86_STACK_POINTER
        mov     [eax].TsEflags, edi
        mov     [eax].TsExceptionList, EXCEPTION_CHAIN_END
        mov     [eax].TsPreviousPreviousMode, 0ffffffffh ; No previous mode
if DBG
        mov     [eax].TsDbgArgMark, 0BADB0D00h ; set trap frame mark
endif

        add     eax, KTRAP_FRAME_LENGTH

;
; Disable interrupt and change the stack pointer to make the new
; trap frame be the current thread's base trap frame.
;
; (eax)->Npx save area
;

        cli

;
; Set up various stack pointers
;
;  Low  |           |
;       |-----------| <- New esp
;       |  New Base |
;       |Trap Frame |
;       |-----------| <- Tss.Esp0
;       |V86 segs   |
;       |-----------| <- Pcr.InitialStack
;       |Npx Area   |
;       |-----------| <- Old Esp =  Thread.InitialStack
;       |           |
;  High |           |
;
;
; Copy the FP state to the new FP state save area (NPX frame)
;

        push    ecx     ; save ecx (saved esp)
        mov     esi, [ebx].PcInitialStack
        mov     ecx, NPX_FRAME_LENGTH/4
        mov     edi, eax
        rep movsd
        pop     ecx     ; restore ecx

        mov     edi, [ebx]+PcPrcbData+PbCurrentThread ; (edi)->CurrentThread
        mov     [ebx].PcInitialStack, eax
        mov     esi,[ebx]+PcTss         ; (esi)->TSS
        sub     eax,TsV86Gs - TsHardwareSegSs ; bias for missing fields
        mov     [ebx].PcExceptionList, EXCEPTION_CHAIN_END
        mov     [esi]+TssEsp0,eax
        add     eax, NPX_FRAME_LENGTH + (TsV86Gs - TsHardwareSegSs)
        mov     [edi].ThInitialStack, eax

;
; Set up the pointers to the fake TEB so we can execute the int10
; call
;
        mov     eax, NewTeb
        mov     fs:[PcTeb], eax
        mov     [edi].ThTeb, eax

        mov     ebx, PCR[PcGdt]
        mov     [ebx]+(KGDT_R3_TEB+KgdtBaseLow), ax
        shr     eax, 16
        mov     [ebx]+(KGDT_R3_TEB+KgdtBaseMid), al
        mov     [ebx]+(KGDT_R3_TEB+KgdtBaseHi), ah

        sti

; Now call VdmControl to save return 32bit frame and put vdm context
; to new base trap frame

        stdCall _NtVdmControl, <VdmStartExecution, 0>

if 0
;
; Now call _VdmpStartExecution to save return 32bit frame and put vdm context
; to new base trap frame
;

        mov     eax, ExecAddr
        stdCall _VdmpStartExecution, <eax>
endif

;
; Call KiexceptionExit to 'exit' to v86 code.
;

        mov     ebp, esp                ; (ebp)->Exit trap frame
        jmp     _KiExceptionExit        ; go execute int 10

        public  Ki386BiosCallReturnAddress
Ki386BiosCallReturnAddress:

;
; After ROM BIOS int completes, the bop instruction gets executed.
; This results in a trap to kernel mode bop handler where the
; 16 bit Vdm context will be saved to VdmTib->VdmCOntext, and
; the faked 32 bit user mode context (i.e. the one we created earlier)
; be restored.  Since the faked user mode context does NOT have a valid
; iret address, the 'iret' instruction of the EXIT_ALL will be trapped to
; our GP fault handler which recognizes this and transfers control back to
; here.
;
; when we come back here, all the segment registers are set up properly
; Interrupts are disabled.
;

;
; restore all the pointers.
;

        mov     eax, fs:PcSelfPcr       ; (eax)->Pcr
        mov     edi, [ebp].TsEsi        ; Fetch previous stack address
        mov     edi, [edi]              ; Initial Stack is saved at stack top

;
; Copy the FP state back down to the default stack
;

        mov     esi, [eax].PcInitialStack
        mov     ecx, NPX_FRAME_LENGTH/4
        mov     [eax].PcInitialStack, edi ; Restore Pcr InitialStack
        rep movsd                       ; copy FP state
                                        ; (n.b. edi+= NPX_FRAME_LENGTH)
        mov     esp, [ebp].TsEsi        ; Shink stack
        add     esp, 4                  ; drop saved stack address


        mov     ecx, [eax]+PcPrcbData+PbCurrentThread ; (ecx)->CurrentThread
        mov     [ecx].ThInitialStack, edi ; Restore Thread.InitialStack

        mov     eax,[eax]+PcTss         ; (eax)->TSS
        sub     edi, (TsV86Gs - TsHardwareSegSs) + NPX_FRAME_LENGTH
        mov     [eax]+TssEsp0,edi

;
; restore pointers to the original TEB
;
        pop     edx                     ; (edx) = OriginalThTeb
        mov     [ecx].ThTeb, edx
        pop     edx                     ; (edx) = OriginalPcTeb
        mov     fs:[PcTeb], edx

        mov     ebx, PCR[PcGdt]
        mov     [ebx]+(KGDT_R3_TEB+KgdtBaseLow), dx
        shr     edx, 16
        mov     [ebx]+(KGDT_R3_TEB+KgdtBaseMid), dl
        mov     [ebx]+(KGDT_R3_TEB+KgdtBaseHi), dh


        sti

        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        stdRET  _Ki386SetupAndExitToV86Code

stdENDP _Ki386SetupAndExitToV86Code

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\callback.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    callback.c

Abstract:

    This module implements user mode call back services.

Author:

    David N. Cutler (davec) 29-Oct-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, KeUserModeCallback)
#endif


NTSTATUS
KeUserModeCallback (
    IN ULONG ApiNumber,
    IN PVOID InputBuffer,
    IN ULONG InputLength,
    OUT PVOID *OutputBuffer,
    IN PULONG OutputLength
    )

/*++

Routine Description:

    This function call out from kernel mode to a user mode function.

Arguments:

    ApiNumber - Supplies the API number.

    InputBuffer - Supplies a pointer to a structure that is copied
        to the user stack.

    InputLength - Supplies the length of the input structure.

    Outputbuffer - Supplies a pointer to a variable that receives
        the address of the output buffer.

    Outputlength - Supplies a pointer to a variable that receives
        the length of the output buffer.

Return Value:

    If the callout cannot be executed, then an error status is
    returned. Otherwise, the status returned by the callback function
    is returned.

--*/

{

    ULONG Length;
    ULONG NewStack;
    ULONG OldStack;
    NTSTATUS Status;
    PULONG UserStack;
    PVOID ValueBuffer;
    ULONG ValueLength;
    ULONG GdiBatchCount;
    PEXCEPTION_REGISTRATION_RECORD ExceptionList;
    PTEB Teb;

    ASSERT(KeGetPreviousMode() == UserMode);
    ASSERT(KeGetCurrentThread()->ApcState.KernelApcInProgress == FALSE);

    //
    // Get the user mode stack pointer and attempt to copy input buffer
    // to the user stack.
    //

    UserStack = KiGetUserModeStackAddress();
    OldStack = *UserStack;
    try {

        //
        // Compute new user mode stack address, probe for writability,
        // and copy the input buffer to the user stack.
        //

        Length =  (InputLength + sizeof(CHAR) - 1) & ~(sizeof(CHAR) - 1);
        NewStack = OldStack - Length;
        ProbeForWrite((PCHAR)(NewStack - 16), Length + 16, sizeof(CHAR));
        RtlCopyMemory((PVOID)NewStack, InputBuffer, Length);

        //
        // Push arguments onto user stack.
        //

        *(PULONG)(NewStack - 4) = (ULONG)InputLength;
        *(PULONG)(NewStack - 8) = (ULONG)NewStack;
        *(PULONG)(NewStack - 12) = ApiNumber;
        *(PULONG)(NewStack - 16) = 0;
        NewStack -= 16;

        //
        // Save the exception list in case another handler is defined during
        // the callout.
        //

        Teb = (PTEB)KeGetCurrentThread()->Teb;
        ExceptionList = Teb->NtTib.ExceptionList;

        //
        // Call user mode.
        //

        *UserStack = NewStack;
        Status = KiCallUserMode(OutputBuffer, OutputLength);

        //
        // Restore exception list.
        //

        Teb->NtTib.ExceptionList = ExceptionList;

    //
    // If an exception occurs during the probe of the user stack, then
    // always handle the exception and return the exception code as the
    // status value.
    //

    } except (EXCEPTION_EXECUTE_HANDLER) {
        return GetExceptionCode();
    }

    //
    // When returning from user mode, any drawing done to the GDI TEB
    // batch must be flushed.  If the TEB cannot be accessed then blindly
    // flush the GDI batch anyway.
    //

    GdiBatchCount = 1;

    try {
        GdiBatchCount = Teb->GdiBatchCount;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        NOTHING;
    }

    if (GdiBatchCount > 0) {

        //
        // call GDI batch flush routine
        //

        *UserStack -= 256;
        KeGdiFlushUserBatch();
    }

    *UserStack = OldStack;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\biosc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    abiosc.c

Abstract:

    This module implements ROM BIOS support C routines for i386 NT.

Author:

    Shie-Lin Tzong (shielint) 10-Sept-1992

Environment:

    Kernel mode.


Revision History:

--*/
#include "ki.h"
#pragma hdrstop
#include "vdmntos.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,Ke386CallBios)
#endif


//
// Never change these equates without checking biosa.asm
//

#define V86_CODE_ADDRESS    0x10000
#define INT_OPCODE          0xcd
#define V86_BOP_OPCODE      0xfec4c4
#define V86_STACK_POINTER   0x1ffe
#define IOPM_OFFSET         FIELD_OFFSET(KTSS, IoMaps[0].IoMap)
#define VDM_TIB_ADDRESS     0x12000
#define INT_10_TEB          0x13000

//
// External References
//

PVOID Ki386IopmSaveArea;
VOID
Ki386SetupAndExitToV86Code (
   PVOID ExecutionAddress
   );


NTSTATUS
Ke386CallBios (
    IN ULONG BiosCommand,
    IN OUT PCONTEXT BiosArguments
    )

/*++

Routine Description:

    This function invokes specified ROM BIOS code by executing
    "INT BiosCommand."  Before executing the BIOS code, this function
    will setup VDM context, change stack pointer ...etc.  If for some reason
    the operation fails, a status code will be returned.  Otherwise, this
    function always returns success regardless of the result of the BIOS
    call.

    N.B. This implementation relies on the fact that the direct
         I/O access operations between apps are serialized by win user.

Arguments:

    BiosCommand - Supplies which ROM BIOS function to invoke.

    BiosArguments - Supplies a pointer to the context which will be used
                    to invoke ROM BIOS.

Return Value:

    NTSTATUS code to specify the failure.

--*/

{

    PVDM_TIB VdmTib;
    PUCHAR BaseAddress = (PUCHAR)V86_CODE_ADDRESS;
    PTEB UserInt10Teb = (PTEB)INT_10_TEB;
    PKTSS Tss;
    PKPROCESS Process;
    PKTHREAD Thread;
    USHORT OldIopmOffset, OldIoMapBase;
    PVDM_PROCESS_OBJECTS VdmObjects;
    ULONG   ContextLength;
    BOOLEAN ThreadDebugActive;

    //
    // Map in ROM BIOS area to perform the int 10 code
    //

    try {

        RtlZeroMemory(UserInt10Teb, sizeof(TEB));

        //
        // Write "Int BiosCommand; bop" to reserved user space (0x1000).
        // Later control will transfer to the user space to execute
        // these two instructions.
        //

        *BaseAddress++ = INT_OPCODE;
        *BaseAddress++ = (UCHAR)BiosCommand;
        *(PULONG)BaseAddress = V86_BOP_OPCODE;

        //
        // Set up Vdm(v86) context to execute the int BiosCommand
        // instruction by copying user supplied context to VdmContext
        // and updating the control registers to predefined values.
        //

        //
        // We want to use a constant number for the int10.
        //
        // Create a fake TEB so we can switch the thread to it while we
        // do an int10
        //

        UserInt10Teb->Vdm = (PVOID)VDM_TIB_ADDRESS;
        VdmTib = (PVDM_TIB)VDM_TIB_ADDRESS;
        RtlZeroMemory(VdmTib, sizeof(VDM_TIB));
        VdmTib->Size = sizeof(VDM_TIB);

        *FIXED_NTVDMSTATE_LINEAR_PC_AT = 0;

        //
        // extended registers are never going to matter to
        //  an Int10 call, so only copy the old part of the
        //  context record.
        //
        ContextLength = FIELD_OFFSET(CONTEXT, ExtendedRegisters);

        RtlCopyMemory(&(VdmTib->VdmContext), BiosArguments, ContextLength);
        VdmTib->VdmContext.SegCs = (ULONG)BaseAddress >> 4;
        VdmTib->VdmContext.SegSs = (ULONG)BaseAddress >> 4;
        VdmTib->VdmContext.Eip = 0;
        VdmTib->VdmContext.Esp = 2 * PAGE_SIZE - sizeof(ULONG);
        VdmTib->VdmContext.EFlags |= EFLAGS_V86_MASK | EFLAGS_INTERRUPT_MASK;
        VdmTib->VdmContext.ContextFlags = CONTEXT_FULL;

    } except (EXCEPTION_EXECUTE_HANDLER) {

        return GetExceptionCode();
    }

    //
    // The vdm kernel code finds the Tib by looking at a pointer cached in
    // kernel memory, which was probed at Vdm creation time.  Since the
    // creation semantics for this vdm are peculiar, we do something similar
    // here.
    //

    //
    // We never get here on a process that is a real vdm.  If we do,
    // bad things will happen  (pool leak, failure to execute dos and
    // windows apps).
    //

    ASSERT(PsGetCurrentProcess()->VdmObjects == NULL);

    VdmObjects = ExAllocatePoolWithTag (NonPagedPool,
                                        sizeof(VDM_PROCESS_OBJECTS),
                                        '  eK'
                                        );

    //
    // Since we are doing this on behalf of CSR not a user process, we aren't
    // charging quota.
    //

    if (VdmObjects == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // We are only initializing the VdmTib pointer, because that's the only
    // part of the VdmObjects we use for ROM calls.  We aren't set up
    // to simulate interrupts, or any of the other stuff that would be done
    // in a conventional vdm
    //

    RtlZeroMemory( VdmObjects, sizeof(VDM_PROCESS_OBJECTS));

    VdmObjects->VdmTib = VdmTib;

    PsGetCurrentProcess()->VdmObjects = VdmObjects;

    //
    // Since we are going to v86 mode and accessing some I/O ports, we
    // need to make sure the IopmOffset is set correctly across context
    // swap and the I/O bit map has all the bits cleared.
    // N.B.  This implementation assumes that there is only one full
    //       screen DOS app and the io access between full screen DOS
    //       app and the server code is serialized by win user.  That
    //       means even we change the IOPM, the full screen dos app won't
    //       be able to run on this IOPM.
    //     * In another words, IF THERE IS
    //     * MORE THAN ONE FULL SCREEN DOS APPS, THIS CODE IS BROKEN.*
    //
    // NOTE This code works on the assumption that winuser serializes
    //      direct I/O access operations.
    //

    //
    // Call the bios from the processor which booted the machine.
    //

    Thread = KeGetCurrentThread();
    KeSetSystemAffinityThread(1);
    Tss = KeGetPcr()->TSS;

    //
    // Save away the original IOPM bit map and clear all the IOPM bits
    // to allow v86 int 10 code to access ALL the io ports.
    //

    //
    // Make sure there are at least 2 IOPM maps.
    //

    ASSERT(KeGetPcr()->GDT[KGDT_TSS / 8].LimitLow >= (0x2000 + IOPM_OFFSET - 1));
    RtlCopyMemory (Ki386IopmSaveArea,
                   (PVOID)&Tss->IoMaps[0].IoMap,
                   PAGE_SIZE * 2
                   );
    RtlZeroMemory ((PVOID)&Tss->IoMaps[0].IoMap, PAGE_SIZE * 2);

    Process = Thread->ApcState.Process;
    OldIopmOffset = Process->IopmOffset;
    OldIoMapBase = Tss->IoMapBase;
    Process->IopmOffset = (USHORT)(IOPM_OFFSET);      // Set Process IoPmOffset before
    Tss->IoMapBase = (USHORT)(IOPM_OFFSET);           // updating Tss IoMapBase

    //
    // The context setup for the BIOS will not have valid debug registers
    // in it, don't try to load them.
    //

    ThreadDebugActive = Thread->DebugActive;
    Thread->DebugActive = FALSE;
    KeGetPcr()->DebugActive = FALSE;

    //
    // Call ASM routine to switch stack to exit to v86 mode to
    // run Int BiosCommand.
    //

    Ki386SetupAndExitToV86Code(UserInt10Teb);

    //
    // After we return from v86 mode, the control comes here.
    //
    // Restore Thread's DebugActive flag.
    //

    KeGetPcr()->DebugActive = ThreadDebugActive;
    Thread->DebugActive = ThreadDebugActive;

    //
    // Restore old IOPM
    //

    RtlCopyMemory ((PVOID)&Tss->IoMaps[0].IoMap,
                   Ki386IopmSaveArea,
                   PAGE_SIZE * 2
                   );

    Process->IopmOffset = OldIopmOffset;
    Tss->IoMapBase = OldIoMapBase;

    //
    // Restore old affinity for current thread.
    //

    KeRevertToUserAffinityThread();

    //
    // Copy 16 bit vdm context back to caller.
    //
    // Extended register state is not going to matter,
    // so copy only the old part of the context record.
    //

    ContextLength = FIELD_OFFSET(CONTEXT, ExtendedRegisters);
    RtlCopyMemory(BiosArguments, &(VdmTib->VdmContext), ContextLength);
    BiosArguments->ContextFlags = CONTEXT_FULL;

    //
    // Free the pool used for the VdmTib pointer
    //

    PsGetCurrentProcess()->VdmObjects = NULL;
    ExFreePool(VdmObjects);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\apcuser.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    apcuser.c

Abstract:

    This module implements the machine dependent code necessary to initialize
    a user mode APC.

Author:

    David N. Cutler (davec) 23-Apr-1990

Environment:

    Kernel mode only, IRQL APC_LEVEL.

Revision History:

--*/

#include "ki.h"

VOID
KiInitializeUserApc (
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN PKNORMAL_ROUTINE NormalRoutine,
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This function is called to initialize the context for a user mode APC.

Arguments:

    ExceptionFrame - Supplies a pointer to an exception frame.

    TrapFrame - Supplies a pointer to a trap frame.

    NormalRoutine - Supplies a pointer to the user mode APC routine.

    NormalContext - Supplies a pointer to the user context for the APC
        routine.

    SystemArgument1 - Supplies the first system supplied value.

    SystemArgument2 - Supplies the second system supplied value.

Return Value:

    None.

--*/

{

    EXCEPTION_RECORD ExceptionRecord;
    CONTEXT ContextFrame;
    LONG Length;
    ULONG UserStack;


    //
    // APCs are not defined for V86 mode; however, it is possible a
    // thread is trying to set it's context to V86 mode - this isn't
    // going to work, but we don't want to crash the system so we
    // check for the possibility before hand.
    //

    if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
        return ;
    }

    //
    // Move machine state from trap and exception frames to the context frame.
    //

    ContextFrame.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
    KeContextFromKframes(TrapFrame, ExceptionFrame, &ContextFrame);

    //
    // Transfer the context information to the user stack, initialize the
    // APC routine parameters, and modify the trap frame so execution will
    // continue in user mode at the user mode APC dispatch routine.
    //


    try {
        ASSERT((TrapFrame->SegCs & MODE_MASK) != KernelMode); // Assert usermode frame

        //
        // Compute length of context record and new aligned user stack pointer.
        //

        Length = ((sizeof(CONTEXT) + CONTEXT_ROUND) &
                    ~CONTEXT_ROUND) + sizeof(KAPC_RECORD);
        UserStack = (ContextFrame.Esp & ~CONTEXT_ROUND) - Length;

        //
        // Probe user stack area for writability and then transfer the
        // context record to the user stack.
        //

        ProbeForWrite((PCHAR)UserStack, Length, CONTEXT_ALIGN);
        RtlCopyMemory((PULONG)(UserStack + (sizeof(KAPC_RECORD))),
                     &ContextFrame, sizeof(CONTEXT));

        //
        // Force correct R3 selectors into TrapFrame.
        //

        TrapFrame->SegCs = SANITIZE_SEG(KGDT_R3_CODE, UserMode);
        TrapFrame->HardwareSegSs = SANITIZE_SEG(KGDT_R3_DATA, UserMode);
        TrapFrame->SegDs = SANITIZE_SEG(KGDT_R3_DATA, UserMode);
        TrapFrame->SegEs = SANITIZE_SEG(KGDT_R3_DATA, UserMode);
        TrapFrame->SegFs = SANITIZE_SEG(KGDT_R3_TEB, UserMode);
        TrapFrame->SegGs = 0;
        TrapFrame->EFlags = SANITIZE_FLAGS( ContextFrame.EFlags, UserMode );

        //
        // If thread is supposed to have IOPL, then force it on in eflags
        //

        if (KeGetCurrentThread()->Iopl) {
            TrapFrame->EFlags |= (EFLAGS_IOPL_MASK & -1);  // IOPL = 3
        }

        //
        // Set the address of the user APC routine, the APC parameters, the
        // new frame pointer, and the new stack pointer in the current trap
        // frame. Set the continuation address so control will be transferred
        // to the user APC dispatcher.
        //

        TrapFrame->HardwareEsp = UserStack;
        TrapFrame->Eip = (ULONG)KeUserApcDispatcher;
        TrapFrame->ErrCode = 0;
        *((PULONG)UserStack)++ = (ULONG)NormalRoutine;
        *((PULONG)UserStack)++ = (ULONG)NormalContext;
        *((PULONG)UserStack)++ = (ULONG)SystemArgument1;
        *((PULONG)UserStack)++ = (ULONG)SystemArgument2;
    } except (KiCopyInformation(&ExceptionRecord,
                                (GetExceptionInformation())->ExceptionRecord)) {

        //
        // Set the address of the exception to the current program address
        // and raise the exception by calling the exception dispatcher.
        //

        ExceptionRecord.ExceptionAddress = (PVOID)(TrapFrame->Eip);
        KiDispatchException(&ExceptionRecord,
                            ExceptionFrame,
                            TrapFrame,
                            UserMode,
                            TRUE);
    }
    return;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\cpu.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       cpu.inc
;
;   Abstract:
;
;       This module contains the assembly structures and definitions
;       for INTEL 80x86 CPU specifiec information.  This include file
;       is mainly used by CPU.ASM to determine CPU type and stepping
;       number.
;
;   Author:
;
;       Shie-Lin (shielint) 1-Oct-1991
;
;   Revision History:
;
;--

;
; The following equates define the control bits of CR0 register
;

CR0_AM          equ     40000h
CR0_ET          equ     00010h

;
; The following equates define the control bits of EFALGS register
;

EFLAGS_AC       equ     40000h
EFLAGS_VM       equ     20000h
EFLAGS_RF       equ     10000h
EFLAGS_NF       equ     4000h
EFLAGS_IOPL     equ     3000h
EFLAGS_IF       equ     200h
EFLAGS_TF       equ     100h
EFLAGS_ID       equ     200000h

;
; Define the iret frame
;

IretFrame       struc

IretEip        dd      0
IretCs         dd      0
IretEFlags     dd      0

IretFrame       ends

;
; Misc. definitions
;

ADDRESS_OVERRIDE        equ     67h
OPERAND_OVERRIDE        equ     66h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\callout.asm ===
title  "Call Out to User Mode"
;++
;
; Copyright (c) 1994  Microsoft Corporation
;
; Module Name:
;
;    callout.asm
;
; Abstract:
;
;    This module implements the code necessary to call out from kernel
;    mode to user mode.
;
; Author:
;
;    David N. Cutler (davec) 1-Nov-1994
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

        extrn   _KiServiceExit:PROC
        extrn   _KeUserCallbackDispatcher:DWORD

        EXTRNP  _MmGrowKernelStack,1

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Call User Mode Function"
;++
;
; NTSTATUS
; KiCallUserMode (
;    IN PVOID *Outputbuffer,
;    IN PULONG OutputLength
;    )
;
; Routine Description:
;
;    This function calls a user mode function from kernel mode.
;
;    N.B. This function calls out to user mode and the NtCallbackReturn
;        function returns back to the caller of this function. Therefore,
;        the stack layout must be consistent between the two routines.
;
; Arguments:
;
;    OutputBuffer - Supplies a pointer to the variable that receivies
;        the address of the output buffer.
;
;    OutputLength - Supplies a pointer to a variable that receives
;        the length of the output buffer.
;
; Return Value:
;
;    The final status of the call out function is returned as the status
;    of the function.
;
;    N.B. This function does not return to its caller. A return to the
;        caller is executed when a NtCallbackReturn system service is
;        executed.
;
;    N.B. This function does return to its caller if a kernel stack
;         expansion is required and the attempted expansion fails.
;
;--

;
; To support the debugger, the callback stack frame is now defined in i386.h.
; If the stack frame is changed, i386.h must be updated and geni386
; rebuilt and run, then rebuild this file and ntos\kd.
;
; The FPO record below must also be updated to correctly represent
; the stack frame.
;

cPublicProc _KiCallUserMode, 2

.FPO (3, 2, 4, 4, 0, 0)

;
; Save nonvolatile registers.
;

        push    ebp                     ; save nonvolatile registers
        push    ebx                     ;
        push    esi                     ;
        push    edi                     ;

;
; Check if sufficient room is available on the kernel stack for another
; system call.
;

        mov     ebx,PCR[PcPrcbData + PbCurrentThread] ; get current thread address
        lea     eax,[esp]-KERNEL_LARGE_STACK_COMMIT ; compute bottom address
        cmp     eax,[ebx]+ThStackLimit  ; check if limit exceeded
        jae     short Kcb10             ; if ae, limit not exceeded
        stdCall _MmGrowKernelStack,<esp> ; attempt to grow kernel stack
        or      eax, eax                ; check for successful completion
        jne     Kcb20                   ; if ne, attempt to grow failed
        mov     eax, [ebx].ThStackLimit ; get new stack limit
        mov     PCR[PcStackLimit], eax  ; set new stack limit

;
; Get the address of the current thread and save the previous trap frame
; and calback stack addresses in the current frame. Also save the new
; callback stack address in the thread object.
;

Kcb10:  push    [ebx].ThCallbackStack   ; save callback stack address
        mov     edx,[ebx].ThTrapFrame   ; get current trap frame address
        push    edx                     ; save trap frame address
        mov     esi,[ebx].ThInitialStack ; get initial stack address
        push    esi                     ; save initial stack address
        mov     [ebx].ThCallbackStack,esp ; save callback stack address

KcbPrologEnd: ; help for the debugger

;
; Copy the numeric save area from the previous save area to the new save
; area and establish a new initial kernel stack.
;

        ;
        ; Make sure that the destination NPX Save area is 16-byte aligned
        ; as required by fxsave\fxrstor
        ;
        and     esp, 0fffffff0h
        mov     edi,esp                 ; set new initial stack address
        sub     esp,NPX_FRAME_LENGTH    ; compute destination NPX save area
        sub     esi,NPX_FRAME_LENGTH    ; compute source NPX save area
        cli                             ; disable interrupts
        mov     ecx,[esi].FpControlWord ; copy NPX state to new frame
        mov     [esp].FpControlWord,ecx ;
        mov     ecx,[esi].FpStatusWord  ;
        mov     [esp].FpStatusWord,ecx  ;
        mov     ecx,[esi].FpTagWord     ;
        mov     [esp].FpTagWord,ecx     ;
        mov     ecx,[esi].FxMXCsr       ;
        mov     [esp].FxMXCsr,ecx       ;
        mov     ecx,[esi].FpCr0NpxState ;
        mov     [esp].FpCr0NpxState,ecx ;
        mov     esi,PCR[PcTss]          ; get address of task switch segment
        mov     [ebx].ThInitialStack,edi ; reset initial stack address
        mov     PCR[PcInitialStack],esp ; set stack check base address
        sub     esp,TsV86Gs - TsHardwareSegSs ; bias for missing V86 fields
        mov     [esi].TssEsp0,esp       ; set kernel entry stack address

;
; Construct a trap frame to facilitate the transfer into user mode via
; the standard system call exit.
;

        sub     esp,TsHardwareSegSs + 4 ; allocate trap frame
        mov     ebp,esp                 ; set address of trap frame
        mov     ecx,(TsHardwareSegSs - TsSegFs + 4) / 4; set repeat count
        lea     edi,[esp].TsSegFs       ; set destination address
        lea     esi,[edx].TsSegFs       ; set source address
        rep     movsd                   ; copy trap information

        test    byte ptr [ebx]+ThDebugActive, -1 ; Do we need to restore Debug reg?
        jnz     short Kcb18             ; Yes, go save them.

Kcb15:  mov     eax,_KeUserCallbackDispatcher ; st address of callback dispatchr
        mov     [esp].TsEip,eax         ;
        mov     eax,PCR[PcExceptionList] ; get current exception list
        mov     [esp].TsExceptionList,eax ; set previous exception list
        mov     eax,[edx].TsPreviousPreviousMode ; get previous mode
        mov     [esp].TsPreviousPreviousMode,eax ; set previous mode
        sti                             ; enable interrupts

        SET_DEBUG_DATA                  ; set system call debug data for exit

        jmp     _KiServiceExit          ; exit through service dispatch

Kcb18:
        mov     ecx,(TsDr7 - TsDr0 + 4) / 4; set repeat count
        lea     edi,[esp].TsDr0         ; set destination address
        lea     esi,[edx].TsDr0         ; set source address
        rep     movsd                   ; copy trap information
        jmp     short Kcb15

;
; An attempt to grow the kernel stack failed.
;

Kcb20:  pop     edi                     ; restore nonvolitile register
        pop     esi                     ;
        pop     ebx                     ;
        pop     ebp                     ;
        stdRET  _KiCallUserMode

stdENDP _KiCallUserMode

        page ,132
        subttl  "Switch Kernel Stack"
;++
;
; PVOID
; KeSwitchKernelStack (
;    IN PVOID StackBase,
;    IN PVOID StackLimit
;    )
;
; Routine Description:
;
;    This function switches to the specified large kernel stack.
;
;    N.B. This function can ONLY be called when there are no variables
;        in the stack that refer to other variables in the stack, i.e.,
;        there are no pointers into the stack.
;
; Arguments:
;
;    StackBase (esp + 4) - Supplies a pointer to the base of the new kernel
;        stack.
;
;    StackLimit (esp + 8) - Suplies a pointer to the limit of the new kernel
;        stack.
;
; Return Value:
;
;    The old kernel stack is returned as the function value.
;
;--

SsStkBs equ     4                       ; new kernel stack base address
SsStkLm equ     8                       ; new kernel stack limit address

cPublicProc _KeSwitchKernelStack, 2

;
; Save the address of the new stack and copy the old stack to the new
; stack.
;

        push    esi                     ; save string move registers
        push    edi                     ;
        mov     edx,PCR[PcPrcbData + PbCurrentThread] ; get current thread address
        mov     edi,[esp]+SsStkBs + 8   ; get new kernel stack base address
        mov     ecx,[edx].ThStackBase   ; get current stack base address
        sub     ebp,ecx                 ; relocate the callers frame pointer
        add     ebp,edi                 ;
        mov     eax,[edx].ThTrapFrame   ; relocate the current trap frame address
        sub     eax,ecx                 ;
        add     eax,edi                 ;
        mov     [edx].ThTrapFrame,eax   ;
        sub     ecx,esp                 ; compute length of copy
        sub     edi,ecx                 ; set destination address of copy
        mov     esi,esp                 ; set source address of copy
        push    edi                     ; save new stack pointer address
        rep     movsb                   ; copy old stack to new stack
        pop     edi                     ; restore new stack pointer address

;
; Switch to the new kernel stack and return the address of the old kernel
; stack.
;

        mov     eax,[edx].ThStackBase   ; get old kernel stack base address
        mov     ecx,[esp]+SsStkBs + 8   ; get new kernel stack base address
        mov     esi,[esp]+SsStkLm + 8   ; get new kernel stack limit address
        cli                             ; disable interrupts
        mov     [edx].ThStackBase,ecx   ; set new kernel stack base address
        mov     [edx].ThStackLimit,esi  ; set new kernel stack limit address
        mov     byte ptr [edx].ThLargeStack, 1 ; set large stack TRUE
        mov     [edx].ThInitialStack,ecx ; set new initial stack address
        sub     ecx,NPX_FRAME_lENGTH    ; compute NPX save area address
        mov     PCR[PcInitialStack],ecx ; set stack check base address
        mov     PCR[PcStackLimit],esi   ; set stack check limit address
        mov     edx,PCR[PcTss]          ; get address of task switch segment
        sub     ecx,TsV86Gs - TsHardwareSegSs ; bias for missing V86 fields
        mov     [edx].TssEsp0,ecx       ; set kernel entry stack address
        mov     esp,edi                 ; set new stack pointer address
        sti                             ;
        pop     edi                     ; restore string move registers
        pop     esi                     ;
        stdRET  _KeSwitchKernelStack

stdENDP _KeSwitchKernelStack

        page ,132
        subttl  "Get User Mode Stack Address"
;++
;
; PULONG
; KiGetUserModeStackAddress (
;    VOID
;    )
;
; Routine Description:
;
;    This function returns the address of the user stack address in the
;    current trap frame.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    The address of the user stack address.
;
;--

cPublicProc _KiGetUserModeStackAddress, 0

        mov     eax,PCR[PcPrcbData + PbCurrentThread] ; get current thread address
        mov     eax,[eax].ThTrapFrame   ; get current trap frame address
        lea     eax,[eax].TsHardwareEsp ; get address of stack address
        stdRET  _KiGetUserModeStackAddress

stdENDP _KiGetUserModeStackAddress

        page ,132
        subttl  "Return from User Mode Callback"
;++
;
; NTSTATUS
; NtCallbackReturn (
;    IN PVOID OutputBuffer OPTIONAL,
;    IN ULONG OutputLength,
;    IN NTSTATUS Status
;    )
;
; Routine Description:
;
;    This function returns from a user mode callout to the kernel
;    mode caller of the user mode callback function.
;
;    N.B. This function returns to the function that called out to user
;        mode and the KiCallUserMode function calls out to user mode.
;        Therefore, the stack layout must be consistent between the
;        two routines.
;
; Arguments:
;
;    OutputBuffer - Supplies an optional pointer to an output buffer.
;
;    OutputLength - Supplies the length of the output buffer.
;
;    Status - Supplies the status value returned to the caller of the
;        callback function.
;
; Return Value:
;
;    If the callback return cannot be executed, then an error status is
;    returned. Otherwise, the specified callback status is returned to
;    the caller of the callback function.
;
;    N.B. This function returns to the function that called out to user
;         mode is a callout is currently active.
;
;--

cPublicProc _NtCallbackReturn, 3

        mov     eax,PCR[PcPrcbData + PbCurrentThread] ; get current thread address
        mov     ecx,[eax].ThCallbackStack ; get callback stack address
        cmp     ecx, 0
        je      CbExit                    ; if zero, no callback stack present

;
; Restore the current exception list from the saved exception list in the
; current trap frame, restore the trap frame and callback stack addresses,
; store the output buffer address and length, and set the service status.
;

        mov     ebx,[eax].ThTrapFrame   ; get current trap frame address
        mov     edx,[ebx].TsExceptionList ; get saved exception list address
        mov     PCR[PcExceptionList],edx ; restore exception list address
        mov     edi,[esp] + 4           ; get output buffer address
        mov     esi,[esp] + 8           ; get output buffer length
        mov     ebp,[esp] + 12          ; get callout service status
        mov     ebx,[ecx].CuOutBf       ; get address to store output buffer
        mov     [ebx],edi               ; store output buffer address
        mov     ebx,[ecx].CuOutLn       ; get address to store output length
        mov     [ebx],esi               ; store output buffer length
        mov     ebx,[ecx]               ; get previous initial stack address
        cli                             ; disable interrupt
        mov     esi,PCR[PcInitialStack] ; get source NPX save area address
        mov     [eax].ThInitialStack,ebx ; restore initial stack address
        sub     ebx,NPX_FRAME_LENGTH    ; compute destination NPX save area
        mov     edx,[esi].FpControlWord ; copy NPX state to previous frame
        mov     [ebx].FpControlWord,edx ;
        mov     edx,[esi].FpStatusWord  ;
        mov     [ebx].FpStatusWord,edx  ;
        mov     edx,[esi].FpTagWord     ;
        mov     [ebx].FpTagWord,edx     ;
        mov     edx,[esi].FxMXCsr       ;
        mov     [ebx].FxMXCsr,edx       ;
        mov     edx,[esi].FpCr0NpxState ;
        mov     [ebx].FpCr0NpxState,edx ;
        mov     edx,PCR[PcTss]          ; get address of task switch segment
        mov     PCR[PcInitialStack],ebx ; restore stack check base address
        sub     ebx,TsV86Gs - TsHardwareSegSs ; bias for missing V86 fields
        mov     [edx].TssEsp0,ebx       ; restore kernel entry stack address
        mov     esp,ecx                 ; trim stack back to callback frame
        add     esp,4                   ;
        sti                             ; enable interrupts
        pop     [eax].ThTrapFrame       ; restore current trap frame address
        pop     [eax].ThCallbackStack   ; restore callback stack address
        mov     eax,ebp                 ; set callback service status

;
; Restore nonvolatile registers, clean call parameters from stack, and
; return to callback caller.
;

        pop     edi                     ; restore nonvolatile registers
        pop     esi                     ;
        pop     ebx                     ;
        pop     ebp                     ;
        pop     edx                     ; save return address
        add     esp,8                   ; remove parameters from stack
        jmp     edx                     ; return to callback caller

;
; No callback is currently active.
;

CbExit: mov     eax,STATUS_NO_CALLBACK_ACTIVE ; set service status
        stdRET  _NtCallBackReturn

stdENDP _NtCallbackReturn

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\cpu.asm ===
title  "Processor type and stepping detection"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    cpu.asm
;
; Abstract:
;
;    This module implements the assembley code necessary to determine
;    cpu type and stepping information.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 28-Oct-1991.
;        Some of the code is extracted from Cruiser (mainly,
;        the code to determine 386 stepping.)
;
; Environment:
;
;    80x86
;
; Revision History:
;
;--

        .xlist
include i386\cpu.inc
include ks386.inc
include callconv.inc
include mac386.inc
        .list

;
; constant for i386 32-bit multiplication test
;

MULTIPLIER            equ     00000081h
MULTIPLICAND          equ     0417a000h
RESULT_HIGH           equ     00000002h
RESULT_LOW            equ     0fe7a000h

;
; Constants for Floating Point test
;

REALLONG_LOW          equ     00000000
REALLONG_HIGH         equ     3FE00000h
PSEUDO_DENORMAL_LOW   equ     00000000h
PSEUDO_DENORMAL_MID   equ     80000000h
PSEUDO_DENORMAL_HIGH  equ     0000h

.586p

INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;++
;
; USHORT
; KiSetProcessorType (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines type of processor (80486, 80386),
;    and it's corrisponding stepping.  The results are saved in
;    the current processor's PRCB.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Prcb->CpuType
;       3, 4, 5, ...    3 = 386, 4 = 486, etc..
;
;    Prcb->CpuStep is encoded as follows:
;       lower byte as stepping #
;       upper byte as stepping letter (0=a, 1=b, 2=c, ...)
;
;    (ax) = x86h or 0 if unrecongnized processor.
;
;--
cPublicProc _KiSetProcessorType,0

        mov     byte ptr fs:PcPrcbData.PbCpuID, 0

        push    edi
        push    esi
        push    ebx                     ; Save C registers
        mov     eax, cr0
        push    eax
        pushfd                          ; save Cr0 & flags

        pop     ebx                     ; Get flags into eax
        push    ebx                     ; Save original flags

        mov     ecx, ebx
        xor     ecx, EFLAGS_ID          ; flip ID bit
        push    ecx
        popfd                           ; load it into flags
        pushfd                          ; re-save flags
        pop     ecx                     ; get flags into eax
        cmp     ebx, ecx                ; did bit stay flipped?
        jne     short cpu_has_cpuid     ; Yes, go use CPUID

cpuid_unsupported:
        pop     ebx                     ; Get flags into eax
        push    ebx                     ; Save original flags

        mov     ecx, ebx
        xor     ecx, EFLAGS_AC          ; flip AC bit
        push    ecx
        popfd                           ; load it into flags
        pushfd                          ; re-save flags
        pop     ecx                     ; get flags into eax
        cmp     ebx, ecx                ; did bit stay flipped?
        je      short cpu_is_386        ; No, then this is a 386

cpu_is_486:
        mov     byte ptr fs:PcPrcbData.PbCpuType, 4h    ; Save CPU Type
        call    Get486Stepping
        jmp     cpu_save_stepping

cpu_is_386:
        mov     byte ptr fs:PcPrcbData.PbCpuType, 3h    ; Save CPU Type
        call    Get386Stepping
        jmp     cpu_save_stepping

cpu_has_cpuid:
        or      ebx, EFLAGS_ID
        push    ebx
        popfd                           ; Make sure ID bit is set

        mov     ecx, fs:PcIdt           ; Address of IDT
        push    dword ptr [ecx+30h]     ; Save Trap06 handler incase
        push    dword ptr [ecx+34h]     ; the CPUID instruction faults

        mov     eax, offset CpuIdTrap6Handler
        mov     word ptr [ecx+30h], ax  ; Set LowWord
        shr     eax, 16
        mov     word ptr [ecx+36h], ax  ; Set HighWord

        mov     eax, 0                  ; argument to CPUID
        cpuid                           ; Uses eax, ebx, ecx, edx

        mov     ecx, fs:PcIdt           ; Address of IDT
        pop     dword ptr [ecx+34h]     ; restore trap6 handler
        pop     dword ptr [ecx+30h]

        cmp     eax, 1                  ; make sure level 1 is supported
        jc      short cpuid_unsupported ; no, then punt


        ; Get the family and stepping (cpuid fn=1).  If processor family
        ; is less than 0xf, the format returned is as below:
        ; 3          2         1          
        ; 10987654321098765432109876543210
        ; --------------------------------
        ;                   ppffffmmmmssss
        ; where
        ;    pp = Processor Type 
        ;  ffff = Family
        ;  mmmm = Model
        ;  ssss = Stepping
        ;
        ; This is transformed and saved in the PRCB as
        ; 
        ; PRCB->CpuStep = 0000mmmm0000ssss                v v
        ;     ->CpuID   = 00000001                        | | v
        ;     ->CpuType = 0000ffff                        | | | v
        ;                                                 | | | |
        ; ie the dword that contains all this looks like 0M0S010F
        ;


        ; If the processor family is 0xf or greater, the format returned is:
        ;  3         2         1          
        ; 10987654321098765432109876543210
        ; --------------------------------
        ; RRRRFFFFFFFFMMMMRRppffffmmmmssss
        ; where
        ;    pp = Processor Type 
        ;  ffff = Family
        ;  mmmm = Model
        ;  ssss = Stepping
        ;  MMMM = Extended Model
        ;  FFFFFFFF = Extended Family
        ;  RRRR, RR = Reserved
         
        ; This is transformed and saved in the PRCB as
        ; 
        ; PRCB->CpuStep = EEEEEEEE0000ssss                v v
        ;     ->CpuID   = 00000001                        | | v
        ;     ->CpuType = XXXXXXXX                        | | | v
        ;                                                 | | | |
        ; ie the dword that contains all this looks like EE0S01XX
        ;
        ; where
        ; EEEEEEEE = ((MMMM) << 4)8 bits + (mmmm)zero extended 8 bits
        ; XXXXXXXX = (FFFFFFFF) + (ffff)zero extended 8 bits

        ; The value for Extended Family cannot go beyond F0H inorder to support
        ; a maximum value of FFH for the final Family value(XXXXXXXX).

        ; The maximum value of Extended Model is FH and the maximum value for 
        ; the final Model value(EEEEEEEE) is FFH

        mov     eax, 1                  ; get the family and stepping
        cpuid

        mov     ebx, eax
        mov     edx, eax                

        and     edx, 0F00h              ; get the Family
        cmp     edx, 0F00h              ; (edx) = 00000000000000000000ffff00000000 
        jne     short cpu_not_extended  ; Family less than F
    
        mov     ah, al                  ; (eax) = RRRRFFFFFFFFMMMMmmmmssssmmmmssss 
        shr     eax, 4                  ; (eax) = 0000RRRRFFFFFFFFMMMMmmmmssssmmmm
        mov     al, bl                  ; (eax) = 0000RRRRFFFFFFFFMMMMmmmmmmmmssss
        and     eax, 0FF0Fh             ; (eax) = 0000000000000000EEEEEEEE0000ssss
        and     ebx, 0FF00000h          ; (ebx) = 0000FFFFFFFF00000000000000000000  
        shr     ebx, 12                 ; (ebx) = 0000000000000000FFFFFFFF00000000
        add     ebx, edx                ; (ebx) = 0000000000000000XXXXXXXX00000000
        jmp     short cpu_save_signature

cpu_not_extended:
        and     eax, 0F0h               ; (eax) = Model
        shl     eax, 4
        mov     al, bl
        and     eax, 0F0Fh              ; (eax) = Model[15:8] | Step[7:0]

        and     ebx, 0F00h              ; (bh) = CpuType

cpu_save_signature:
        mov     byte ptr fs:PcPrcbData.PbCpuID, 1       ; Has ID support
        mov     byte ptr fs:PcPrcbData.PbCpuType, bh    ; Save CPU Type

cpu_save_stepping:
        mov     word ptr fs:PcPrcbData.PbCpuStep, ax    ; Save CPU Stepping
        popfd                                   ; Restore flags
        pop     eax
        mov     cr0, eax
        pop     ebx
        pop     esi
        pop     edi
        stdRET  _KiSetProcessorType

cpuid_trap:
        mov     ecx, fs:PcIdt           ; Address of IDT
        pop     dword ptr [ecx+34h]     ; restore trap6 handler
        pop     dword ptr [ecx+30h]
        jmp     cpuid_unsupported       ; Go get processor information

stdENDP _KiSetProcessorType

;++
;
; BOOLEAN
; CpuIdTrap6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted CPUID instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

CpuIdTrap6Handler   proc

        mov     [esp].IretEip,offset cpuid_trap
        iretd

CpuIdTrap6Handler  endp


;++
;
; USHORT
; Get386Stepping (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for i386 CPU stepping.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    [ax] - Cpu stepping.
;           0 = A, 1 = B, 2 = C, ...
;
;--

        public  Get386Stepping
Get386Stepping  proc

        call    MultiplyTest            ; Perform mutiplication test
        jnc     short G3s00             ; if nc, muttest is ok
        mov     ax, 0
        ret
G3s00:
        call    Check386B0              ; Check for B0 stepping
        jnc     short G3s05             ; if nc, it's B1/later
        mov     ax, 100h                ; It is B0/earlier stepping
        ret

G3s05:
        call    Check386D1              ; Check for D1 stepping
        jc      short G3s10             ; if c, it is NOT D1
        mov     ax, 301h                ; It is D1/later stepping
        ret

G3s10:
        mov     ax, 101h                ; assume it is B1 stepping
        ret

Get386Stepping  endp

;++
;
; USHORT
; Get486Stepping (
;    VOID
;    )
;
; Routine Description:
;
;    This function determines cpu stepping for i486 CPU type.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    [ax] - Cpu stepping.  For example, [ax] = D0h for D0 stepping.
;
;--

        public  Get486Stepping
Get486Stepping          proc

        call    Check486AStepping       ; Check for A stepping
        jnc     short G4s00             ; if nc, it is NOT A stepping

        mov     ax, 0                   ; set to A stepping
        ret

G4s00:  call    Check486BStepping       ; Check for B stepping
        jnc     short G4s10             ; if nc, it is NOT a B stepping

        mov     ax, 100h                ; set to B stepping
        ret

;
; Before we test for 486 C/D step, we need to make sure NPX is present.
; Because the test uses FP instruction to do the detection.
;
G4s10:
        call    _KiIsNpxPresent         ; Check if cpu has coprocessor support?
        or      ax, ax
        jz      short G4s15             ; it is actually 486sx

        call    Check486CStepping       ; Check for C stepping
        jnc     short G4s20             ; if nc, it is NOT a C stepping
G4s15:
        mov     ax, 200h                ; set to C stepping
        ret

G4s20:  mov     ax, 300h                ; Set to D stepping
        ret

Get486Stepping          endp

;++
;
; BOOLEAN
; Check486AStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 A Stepping.
;
;    It takes advantage of the fact that on the A-step of the i486
;    processor, the ET bit in CR0 could be set or cleared by software,
;    but was not used by the hardware.  On B or C -step, ET bit in CR0
;    is now hardwired to a "1" to force usage of the 386 math coprocessor
;    protocol.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if B or later stepping.
;    Carry Flag set if A or earlier stepping.
;
;--
        public  Check486AStepping
Check486AStepping       proc    near
        mov     eax, cr0                ; reset ET bit in cr0
        and     eax, NOT CR0_ET
        mov     cr0, eax

        mov     eax, cr0                ; get cr0 back
        test    eax, CR0_ET             ; if ET bit still set?
        jnz     short cas10             ; if nz, yes, still set, it's NOT A step
        stc
        ret

cas10:  clc
        ret
Check486AStepping       endp

;++
;
; BOOLEAN
; Check486BStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 B Stepping.
;
;    On the i486 processor, the "mov to/from DR4/5" instructions were
;    aliased to "mov to/from DR6/7" instructions.  However, the i486
;    B or earlier steps generate an Invalid opcode exception when DR4/5
;    are used with "mov to/from special register" instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if C or later stepping.
;    Carry Flag set if B stepping.
;
;--
        public  Check486BStepping
Check486BStepping       proc

        push    ebx

        mov     ebx, fs:PcIdt           ; Address of IDT
        push    dword ptr [ebx+30h]
        push    dword ptr [ebx+34h]     ; Save Trap06 handler

        mov     eax, offset Temporary486Int6
        mov     word ptr [ebx+30h], ax  ; Set LowWord
        shr     eax, 16
        mov     word ptr [ebx+36h], ax  ; Set HighWord

c4bs50: db      0fh, 21h, 0e0h          ; mov eax, DR4
        nop
        nop
        nop
        nop
        nop
        clc                             ; it is C step
        jmp     short c4bs70
c4bs60: stc                             ; it's B step
c4bs70: pop     dword ptr [ebx+34h]     ; restore old int 6 vector
        pop     dword ptr [ebx+30h]

        pop     ebx
        ret

        ret

Check486BStepping       endp

;++
;
; BOOLEAN
; Temporary486Int6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted execution of an mov to/from DR4/5 instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

Temporary486Int6        proc

        mov     [esp].IretEIp,offset c4bs60 ; set EIP to stc instruction
        iretd

Temporary486Int6        endp

;++
;
; BOOLEAN
; Check486CStepping (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 486 C Stepping.
;
;    This routine takes advantage of the fact that FSCALE produces
;    wrong result with Denormal or Pseudo-denormal operand on 486
;    C and earlier steps.
;
;    If the value contained in ST(1), second location in the floating
;    point stack, is between 1 and 11, and the value in ST, top of the
;    floating point stack, is either a pseudo-denormal number or a
;    denormal number with the underflow exception unmasked, the FSCALE
;    instruction produces an incorrect result.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D or later stepping.
;    Carry Flag set if C stepping.
;
;--

FpControl       equ     [ebp - 2]
RealLongSt1     equ     [ebp - 10]
PseudoDenormal  equ     [ebp - 20]
FscaleResult    equ     [ebp - 30]

        public  Check486CStepping
Check486CStepping       proc

        push    ebp
        mov     ebp, esp
        sub     esp, 30                 ; Allocate space for temp real variables

        mov     eax, cr0                ; Don't trap while doing math
        and     eax, NOT (CR0_ET+CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, eax

;
; Initialize the local FP variables to predefined values.
; RealLongSt1 = 1.0 * (2 ** -1) = 0.5 in normalized double precision FP form
; PseudoDenormal =  a unsupported format by IEEE.
;                   Sign bit = 0
;                   Exponent = 000000000000000B
;                   Significand = 100000...0B
; FscaleResult = The result of FSCALE instruction.  Depending on 486 step,
;                the value will be different:
;                Under C and earlier steps, 486 returns the original value
;                in ST as the result.  The correct returned value should be
;                original significand and an exponent of 0...01.
;

        mov     dword ptr RealLongSt1, REALLONG_LOW
        mov     dword ptr RealLongSt1 + 4, REALLONG_HIGH
        mov     dword ptr PseudoDenormal, PSEUDO_DENORMAL_LOW
        mov     dword ptr PseudoDenormal + 4, PSEUDO_DENORMAL_MID
        mov     word ptr PseudoDenormal + 8, PSEUDO_DENORMAL_HIGH

.387
        fnstcw  FpControl               ; Get FP control word
        fwait
        or      word ptr FpControl, 0FFh ; Mask all the FP exceptions
        fldcw   FpControl               ; Set FP control

        fld     qword ptr RealLongSt1   ; 0 < ST(1) = RealLongSt1 < 1
        fld     tbyte ptr PseudoDenormal; Denormalized operand. Note, i486
                                        ; won't report denormal exception
                                        ; on 'FLD' instruction.
                                        ; ST(0) = Extended Denormalized operand
        fscale                          ; try to trigger 486Cx errata
        fstp    tbyte ptr FscaleResult  ; Store ST(0) in FscaleResult
        cmp     word ptr FscaleResult + 8, PSEUDO_DENORMAL_HIGH
                                        ; Is Exponent changed?
        jz      short c4ds00            ; if z, no, it is C step
        clc
        jmp     short c4ds10
c4ds00: stc
c4ds10: mov     esp, ebp
        pop     ebp
        ret

Check486CStepping       endp

;++
;
; BOOLEAN
; Check386B0 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 386 B0 or earlier stepping.
;
;    It takes advantage of the fact that the bit INSERT and
;    EXTRACT instructions that existed in B0 and earlier versions of the
;    386 were removed in the B1 stepping.  When executed on the B1, INSERT
;    and EXTRACT cause an int 6 (invalid opcode) exception.  This routine
;    can therefore discriminate between B1/later 386s and B0/earlier 386s.
;    It is intended to be used in sequence with other checks to determine
;    processor stepping by exercising specific bugs found in specific
;    steppings of the 386.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if B1 or later stepping
;    Carry Flag set if B0 or prior
;
;--

Check386B0      proc

        push    ebx

        mov     ebx, fs:PcIdt           ; Address of IDT
        push    dword ptr [ebx+30h]
        push    dword ptr [ebx+34h]     ; Save Trap06 handler

        mov     eax, offset TemporaryInt6
        mov     word ptr [ebx+30h], ax  ; Set LowWord
        shr     eax, 16
        mov     word ptr [ebx+36h], ax  ; Set HighWord


;
; Attempt execution of Extract Bit String instruction.  Execution on
; B0 or earlier with length (CL) = 0 will return 0 into the destination
; (CX in this case).  Execution on B1 or later will fail either due to
; taking the invalid opcode trap, or if the opcode is valid, we don't
; expect CX will be zeroed by any new instruction supported by newer
; steppings.  The dummy int 6 handler will clears the Carry Flag and
; returns execution to the appropriate label.  If the instruction
; actually executes, CX will *probably* remain unchanged in any new
; stepping that uses the opcode for something else.  The nops are meant
; to handle newer steppings with an unknown instruction length.
;

        xor     eax,eax
        mov     edx,eax
        mov     ecx,0ff00h              ; Extract length (CL) == 0, (CX) != 0

b1c50:  db      0fh, 0a6h, 0cah         ; xbts cx,dx,ax,cl
        nop
        nop
        nop
        nop
        nop
        stc                             ; assume B0
        jecxz    short b1c70            ; jmp if B0
b1c60:  clc
b1c70:  pop     dword ptr [ebx+34h]     ; restore old int 6 vector
        pop     dword ptr [ebx+30h]

        pop     ebx
        ret

Check386B0      endp

;++
;
; BOOLEAN
; TemporaryInt6 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 6 handler - assumes the cause of the exception was the
;    attempted execution of an XTBS instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    none.
;
;--

TemporaryInt6    proc

        mov     [esp].IretEip,offset b1c60 ; set IP to clc instruction
        iretd

TemporaryInt6   endp

;++
;
; BOOLEAN
; Check386D1 (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks for 386 D1 Stepping.
;
;    It takes advantage of the fact that on pre-D1 386, if a REPeated
;    MOVS instruction is executed when single-stepping is enabled,
;    a single step trap is taken every TWO moves steps, but should
;    occuu each move step.
;
;    NOTE: This routine cannot distinguish between a D0 stepping and a D1
;    stepping.  If a need arises to make this distinction, this routine
;    will need modification.  D0 steppings will be recognized as D1.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear if D1 or later stepping
;    Carry Flag set if B1 or prior
;
;--

Check386D1      proc
        push    ebx

        mov     ebx, fs:PcIdt           ; Address of IDT
        push    dword ptr [ebx+08h]
        push    dword ptr [ebx+0ch]     ; Save Trap01 handler

        mov     eax, offset TemporaryInt1
        mov     word ptr [ebx+08h], ax  ; Set LowWord
        shr     eax, 16
        mov     word ptr [ebx+0eh], ax  ; Set HighWord

;
; Attempt execution of rep movsb instruction with the Trace Flag set.
; Execution on B1 or earlier with length (CX) > 1 will trace over two
; iterations before accepting the trace trap.  Execution on D1 or later
; will accept the trace trap after a single iteration.  The dummy int 1
; handler will return execution to the instruction following the movsb
; instruction.  Examination of (CX) will reveal the stepping.
;

        sub     esp,4                   ; make room for target of movsb
        mov     esi, offset TemporaryInt1 ; (ds:esi) -> some present data
        mov     edi,esp
        mov     ecx,2                   ; 2 iterations
        pushfd
        or      dword ptr [esp], EFLAGS_TF
        popfd                           ; cause a single step trap
        rep movsb

d1c60:  add     esp,4                   ; clean off stack
        pop     dword ptr [ebx+0ch]     ; restore old int 1 vector
        pop     dword ptr [ebx+08h]
        stc                             ; assume B1
        jecxz   short d1cx              ; jmp if <= B1
        clc                             ; else clear carry to indicate >= D1
d1cx:
        pop     ebx
        ret

Check386D1      endp

;++
;
; BOOLEAN
; TemporaryInt1 (
;    VOID
;    )
;
; Routine Description:
;
;    Temporary int 1 handler - assumes the cause of the exception was
;    trace trap at the above rep movs instruction.
;
; Arguments:
;
;    (esp)->eip of trapped instruction
;           cs  of trapped instruction
;           eflags of trapped instruction
;
;--

TemporaryInt1   proc

        and     [esp].IretEFlags,not EFLAGS_TF ; clear caller's Trace Flag
        mov     [esp].IretEip,offset d1c60     ; set IP to next instruction
        iretd

TemporaryInt1   endp

;++
;
; BOOLEAN
; MultiplyTest (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks the 386 32-bit multiply instruction.
;    The reason for this check is because some of the i386 fail to
;    perform this instruction.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear on success
;    Carry Flag set on failure
;
;--
;

MultiplyTest    proc

        xor     cx,cx                   ; 64K times is a nice round number
mlt00:  push    cx
        call    Multiply                ; does this chip's multiply work?
        pop     cx
        jc      short mltx              ; if c, No, exit
        loop    mlt00                   ; if nc, YEs, loop to try again
        clc
mltx:
        ret

MultiplyTest    endp

;++
;
; BOOLEAN
; Multiply (
;    VOID
;    )
;
; Routine Description:
;
;    This routine performs 32-bit multiplication test which is known to
;    fail on bad 386s.
;
;    Note, the supplied pattern values must be used for consistent results.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Carry Flag clear on success.
;    Carry Flag set on failure.
;
;--

Multiply        proc

        mov     ecx, MULTIPLIER
        mov     eax, MULTIPLICAND
        mul     ecx

        cmp     edx, RESULT_HIGH        ; Q: high order answer OK ?
        stc                             ; assume failure
        jnz     short mlpx              ;   N: exit with error

        cmp     eax, RESULT_LOW         ; Q: low order answer OK ?
        stc                             ; assume failure
        jnz     short mlpx              ;   N: exit with error

        clc                             ; indicate success
mlpx:
        ret

Multiply        endp

;++
;
; BOOLEAN
; KiIsNpxPresent(
;     VOID
;     );
;
; Routine Description:
;
;     This routine determines if there is any Numeric coprocessor
;     present.
;
;     Note that we do NOT determine its type (287, 387).
;     This code is extracted from Intel book.
;
; Arguments:
;
;     None.
;
; Return:
;
;     TRUE - If NPX is present.  Else a value of FALSE is returned.
;     Sets CR0 NPX bits accordingly.
;
;--

cPublicProc _KiIsNpxPresent,0

        push    ebp                     ; Save caller's bp
        mov     eax, cr0
        and     eax, NOT (CR0_ET+CR0_MP+CR0_TS+CR0_EM)
        mov     cr0, eax
        xor     edx, edx
.287
        fninit                          ; Initialize NPX
        mov     ecx, 5A5A5A5Ah          ; Put non-zero value
        push    ecx                     ;   into the memory we are going to use
        mov     ebp, esp
        fnstsw  word ptr [ebp]          ; Retrieve status - must use non-wait
        cmp     byte ptr [ebp], 0       ; All bits cleared by fninit?
        jne     Inp10

        or      eax, CR0_ET
        mov     edx, 1

        cmp     fs:PcPrcbData.PbCpuType, 3h
        jbe     Inp10

        or      eax, CR0_NE

Inp10:
        or      eax, CR0_EM+CR0_TS      ; During Kernel Initialization set
                                        ; the EM bit
        mov     cr0, eax
        pop     eax                     ; clear scratch value
        pop     ebp                     ; Restore caller's bp
        mov     eax, edx
        stdRet  _KiIsNpxPresent


stdENDP _KiIsNpxPresent


;++
;
; VOID
; CPUID (
;     ULONG   InEax,
;     PULONG  OutEax,
;     PULONG  OutEbx,
;     PULONG  OutEcx,
;     PULONG  OutEdx
;     );
;
; Routine Description:
;
;   Executes the CPUID instruction and returns the registers from it
;
;   Only available at INIT time
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _CPUID,5

    push    ebx
    push    esi

    mov     eax, [esp+12]

    cpuid

    mov     esi, [esp+16]   ; return EAX
    mov     [esi], eax

    mov     esi, [esp+20]   ; return EBX
    mov     [esi], ebx

    mov     esi, [esp+24]   ; return ECX
    mov     [esi], ecx

    mov     esi, [esp+28]   ; return EDX
    mov     [esi], edx

    pop     esi
    pop     ebx

    stdRET  _CPUID

stdENDP _CPUID

;++
;
; LONGLONG
; RDTSC (
;       VOID
;     );
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _RDTSC
    rdtsc
    stdRET  _RDTSC

stdENDP _RDTSC

INIT    ENDS

_TEXT   SEGMENT DWORD PUBLIC 'CODE'      ; Put IdleLoop in text section
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; ULONGLONG
; FASTCALL
; RDMSR (
;   IN ULONG MsrRegister
;   );
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;--
cPublicFastCall RDMSR, 1
    rdmsr
    fstRET  RDMSR
fstENDP RDMSR


;++
;
; VOID
; WRMSR (
;   IN ULONG MsrRegister
;   IN LONGLONG MsrValue
;   );
;
; Routine Description:
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _WRMSR, 3
    mov     ecx, [esp+4]
    mov     eax, [esp+8]
    mov     edx, [esp+12]
    wrmsr
    stdRET  _WRMSR
stdENDP _WRMSR

;++
;
; VOID
; KeYieldProcessor (
;   VOID
;   );
;
; Routine Description:
;
;   Yields a thread of the processor
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _KeYieldProcessor
    YIELD
    stdRET _KeYieldProcessor
stdENDP _KeYieldProcessor

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\clockint.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    clockint.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.  It works on UP and SystemPro.
;
;--

.386p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
        .list

        EXTRNP  Kei386EoiHelper
        EXTRNP  HalRequestSoftwareInterrupt,1,IMPORT,FASTCALL
        EXTRNP  _HalEndSystemInterrupt,2,IMPORT
        extrn   _KeTimeIncrement:DWORD
        extrn   _KeMaximumIncrement:DWORD
        extrn   _KeTickCount:DWORD
        extrn   _KeTimeAdjustment:DWORD
        extrn   _KiAdjustDpcThreshold:DWORD
        extrn   _KiIdealDpcRate:DWORD
        extrn   _KiMaximumDpcQueueDepth:DWORD
        extrn   _KiTickOffset:DWORD
        extrn   _KiTimerTableListHead:DWORD
        extrn   _KiTimerExpireDpc:DWORD
        extrn   _KiTimeUpdateNotifyRoutine:DWORD
        extrn   _KiProfileListHead:DWORD
        extrn   _KiProfileLock:DWORD
        extrn   _KiProfileInterval:DWORD
        extrn   _KdDebuggerEnabled:BYTE
        EXTRNP  _DbgBreakPoint
        EXTRNP  _DbgBreakPointWithStatus,1
        EXTRNP  _KdPollBreakIn
        EXTRNP  _KiDeliverApc,3
        extrn   _KeI386MachineType:DWORD
        extrn   _PPerfGlobalGroupMask:DWORD
        EXTRNP  PerfProfileInterrupt,2,,FASTCALL

if DBG
        extrn   _DbgPrint:near
        extrn   _KiDPCTimeout:DWORD
        extrn   _MsgDpcTimeout:BYTE
endif

ifdef NT_UP
    LOCK_INC  equ   inc
else
    LOCK_INC  equ   lock inc
endif


_DATA   SEGMENT  DWORD PUBLIC 'DATA'
public  ProfileCount
ProfileCount    DD      0

_DATA   ends

        page ,132
        subttl  "Update System Time"

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
; VOID
; KeUpdateSystemTime (
;       IN KIRQL PreviousIrql,
;       IN KTRAP_FRAME TrapFrame
;       )
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by CLOCK2.
;    Its function is to update the system time and check to determine if a timer
;    has expired.
;
;    N.B. This routine is executed on a single processor in a multiprocess
;       system. The remainder of the processors only execute the quantum end
;       and runtime update code.
;
;    N.B. This routine is not called, but directly jumped to.  Thus, there
;       is no return address.  It returns via the INTERRUPT_EXIT macro.
;
; Arguments:
;
;    PreviousIrql   (esp)   - supplies previous irql of system
;
;    HardwareVector (esp+4) - supplies hardware vector for EndSystemInterrupt
;
;    TrapFrame      (esp+8) - supplies base of trap frame
;
;    EAX is the TimeIncrement value
;
;    EBP is a pointer to the trap frame
;
;
; Environment:
;
;    IRQL = CLOCK_LEVEL
;
; Return Value:
;
;    None.
;
;--
cPublicProc _KeUpdateSystemTime     ,0

.FPO (2, 0, 0, 0, 0, 1) ; treat params as locals since functions is JMPed too

if DBG
        cmp     byte ptr PCR[PcPrcbData+PbSkipTick], 0
        jnz     kust_skiptick
endif

;
; Update interrupt time.
;
; N.B. The interrupt time is updated in a very strict manner so that an
;      interlock does not have to be used in an MP system to read time.
;

        mov     ecx,USER_SHARED_DATA    ; set address of user shared data
        mov     edi,[ecx].UsInterruptTime+0 ; get low interrupt time
        mov     esi,[ecx].UsInterruptTime+4 ; get high interrupt time
        add     edi,eax                 ; add time increment
        adc     esi,0                   ; propagate carry
        mov     [ecx].UsInterruptTime+8,esi ; store high 2 interrupt time
        mov     [ecx].UsInterruptTime+0,edi ; store low interrupt time
        mov     [ecx].UsInterruptTime+4,esi ; store high 1 interrupt time

        sub     _KiTickOffset,eax       ; subtract time increment
        mov     eax,_KeTickCount+0      ; get low tick count
        mov     ebx,eax                 ; copy low tick count
        jg      kust10                  ; if greater, not complete tick

;
; Update system time.
;
; N.B. The system time is updated in a very strict manner so that an
;      interlock does not have to be used in an MP system to read time.
;

        mov     ebx,USER_SHARED_DATA    ; set address of user shared data
        mov     ecx,[ebx].UsSystemTime+0 ; get low interrupt time
        mov     edx,[ebx].UsSystemTime+4 ; get high interrupt time
        add     ecx,_KeTimeAdjustment   ; add time increment
        adc     edx,0                   ; propagate carry
        mov     [ebx].UsSystemTime+8,edx ; store high 2 interrupt time
        mov     [ebx].UsSystemTime+0,ecx ; store low interrupt time
        mov     [ebx].UsSystemTime+4,edx ; store high 1 interrupt time
        mov     ebx,eax                 ; restore low tick count

;
; Update tick count.
;
; N.B. The tick count is updated in a very strict manner so that an
;      interlock does not have to be used in an MP system to read count.
;

        mov     ecx,eax                 ; copy low tick count
        mov     edx,_KeTickCount+4      ; get high tick count
        add     ecx,1                   ; increment tick count
        adc     edx,0                   ; propagate carry
        mov     _KeTickCount+8,edx      ; store high 2 tick count
        mov     _KeTickCount+0,ecx      ; store low tick count
        mov     _KeTickCount+4,edx      ; store high 1 tick count
        mov     USERDATA[UsTickCountLow], ecx

if 0
    ; debug code
        push    eax
        mov     edx, esi
        mov     eax, edi                ; (eax:edx) = InterruptTime
        mov     ecx, _KeMaximumIncrement
        div     ecx
        cmp     al, bl                      ; same bucket?
        je      short @f
    int 3                                   ; no - stop
@@:
        pop     eax
endif

;
; Check to determine if a timer has expired.
; (edi:esi) = KiInterruptTime
; (eax) = KeTickCount.LowPart
; (ebx) = KeTickCount.LowPart
;

        and     eax,TIMER_TABLE_SIZE-1  ; isolate current hand value
        lea     ecx,_KiTimerTableListHead[eax*8] ; get listhead addrees
        mov     edx,[ecx]               ; get first entry address
        cmp     ecx,edx                 ; check if list is empry
        je      short kust5             ; if equal, list is empty
        cmp     esi,[edx].TiDueTime.TmHighTime-TiTimerListEntry ; compare high
        jb      short kust5             ; if below, timer has not expired
        ja      short kust15            ; if above, timer has expired
        cmp     edi,[edx].TiDueTime.TmLowTime-TiTimerListEntry ; compare low
        jae     short kust15            ; if above or equal, time has expired
kust5:  inc     eax                     ; advance hand value to next entry
        inc     ebx

;
; Check to determine if a timer has expired.
; (edi:esi) = KiInterruptTime
; (eax) = bucket
; (ebx) = KeTickCount.LowPart
;

kust10: and     eax,TIMER_TABLE_SIZE-1  ; isolate current hand value
        lea     ecx,_KiTimerTableListHead[eax*8] ; get listhead addrees
        mov     edx,[ecx]               ; get first entry address
        cmp     ecx,edx                 ; check if list is empry
        je      kustxx                  ; if equal, list is empty
        cmp     esi,[edx].TiDueTime.TmHighTime-TiTimerListEntry ; compare high
        jb      kustxx                  ; if below, timer has not expired
        ja      short kust15            ; if above, timer has expired
        cmp     edi,[edx].TiDueTime.TmLowTime-TiTimerListEntry ; compare low
        jb      kustxx                  ; if below, timer has not expired

kust15:
;
; Timer has expired, put timer expiration DPC in the current processor's DPC
; queue.
;
; (ebx) = KeTickCount.LowPart
;

        mov     ecx,PCR[PcPrcb]         ; get processor control block address
        lea     eax,_KiTimerExpireDpc+DpDpcListEntry ; get list entry address
        lea     edx,[ecx]+PbDpcLock     ; get DPC lock address
        cmp     dword ptr [eax]+(DpLock-DpDpcListEntry), 0H ; check if inserted
        jnz     kustxx                  ; if nz, DPC already inserted

kust20: cli
        ACQUIRE_SPINLOCK edx, kust60

        inc     dword ptr [ecx].PbDpcQueueDepth ; increment DPC queue depth
        mov     dword ptr [eax]+(DpLock-DpDpcListEntry), edx ; set lock address
        mov     [eax]+(DpSystemArgument1-DpDpcListEntry),ebx  ; pass tick count
        add     ecx,PbDpcListHead       ; compute DPC listhead address
        mov     ebx,[ecx]+LsBlink       ; get address of last entry in list
        mov     [ecx]+LsBlink, eax      ; set new address of last entry
        mov     [ebx]+LsFlink, eax      ; set forward link in old last entry
        mov     [eax]+LsFlink, ecx      ; set forward link in new last entry
        mov     [eax]+LsBlink, ebx      ; set backward link in new last entry

        RELEASE_SPINLOCK edx
        sti                             ; enable interrupt

; request dispatch interrupt

        mov     ecx, DISPATCH_LEVEL
        fstCall HalRequestSoftwareInterrupt

kustxx:
if DEVL
        cmp     _KdDebuggerEnabled, 0
        jnz     short kust45
kust30:
endif
        cmp     _KiTickOffset,0         ; check if full tick
        jg      short Kust40            ; if not less, not a full tick

        mov     eax,_KeMaximumIncrement ; get maximum time incrmeent
        add     _KiTickOffset,eax       ; add maximum tine to residue

;
; call KeUpdateRunTime to do the acutal work
;

; TOS const PreviousIrql
        push    [esp]
        call    _KeUpdateRunTime@4

;
; Do interrupt exit processing
;

        INTERRUPT_EXIT

kust40:
        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]
        INTERRUPT_EXIT

if DEVL
kust45:
        stdCall _KdPollBreakIn
        or      al,al
        jz      short kust30
        stdCall _DbgBreakPointWithStatus,<DBG_STATUS_CONTROL_C>
        jmp     short kust30
endif

if DBG
kust_skiptick:
        mov     byte ptr PCR[PcPrcbData+PbSkipTick], 0
        jmp     short kust40
endif

;
; Lock is currently owned; spin until free and then attempt to acquire
; lock again.
;

ALIGN 4
kust60: sti                             ; spin with interrupts enabled
        SPIN_ON_SPINLOCK    edx, kust20,,DbgMp

stdENDP _KeUpdateSystemTime


        page ,132
        subttl  "Update Thread and Process Runtime"
;++
;
; Routine Description:
;
;    This routines does the actual work to update the runtime of the current
;    thread, update the runtime of the current thread's process, and
;    decrement the current thread's quantum.
;
;    It also updates the system global counters for user and kernel mode time.
;
;    It increments InterruptCount so that clock ticks get counted as
;    interrupts.
;
; Arguments:
;
;    esp+4 constant PreviousIrql
;
;    ebp MUST point to the machine state frame.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KeUpdateRunTime   ,1
cPublicFpo 1, 1

        mov     eax, PCR[PcSelfPcr]
if DBG
        cmp     byte ptr [eax]+PcPrcbData+PbSkipTick, 0
        jnz     kutp_skiptick
endif
        push    ebx                     ; we will destroy ebx
        inc     dword ptr [eax]+PcPrcbData+PbInterruptCount
        mov     ebx, [eax]+PcPrcbData+PbCurrentThread ; (ebx)->current thread
        mov     ecx, ThApcState+AsProcess[ebx]
                                        ; (ecx)->current thread's process

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jne     Kutp20                  ; if ne, user mode

        test    byte ptr [ebp]+TsSegCs, MODE_MASK ; test if prev mode was kernel
        jne     Kutp20                  ; if ne, user mode

;
; Update the total time spent in kernel mode
;

        mov     edx, 0                  ; set kernel mode
        inc     dword ptr [eax].PcPrcbData.PbKernelTime
        cmp     byte ptr [esp+8], DISPATCH_LEVEL
        jc      short Kutp4             ; OldIrql<2, then kernel
        ja      short Kutp3             ; OldIrql>2, then interrupt

        cmp     dword ptr PCR[PcPrcbData.PbDpcRoutineActive], 0
        jz      short Kutp4             ; Executing Dpc?, no then thread time

        inc     dword ptr [eax].PcPrcbData.PbDpcTime
if DBG
;
; Check for dpcs which run for too long
;

        inc     dword ptr [eax].PcPrcbData.PbDebugDpcTime
        mov     edx, _KiDPCTimeout
        cmp     dword ptr [eax].PcPrcbData.PbDebugDpcTime, edx
        jc      Kutp51                  ; Jump if not over limit

;
; Dpc time has exceeded the allowed quanta
;

        push    offset FLAT:_MsgDpcTimeout ; push message address
        call    _DbgPrint               ; print debug message
        add     esp, 1 * 4              ; remove arguments from stack

        cmp     _KdDebuggerEnabled, 0   ; check if debugger enabled
        je      short Kutp6             ; if eq, no debugger, continue
        stdCall _DbgBreakPoint          ; break into debugger

Kutp6:  mov     eax, PCR[PcSelfPcr]     ; restore PCR address
        mov     dword ptr [eax].PcPrcbData.PbDebugDpcTime, 0 ; Reset Time
endif
        jmp     Kutp51

ALIGN 4
Kutp3:
;
; Update the time spent at interrupt time for this processor
;

        inc     dword ptr [eax].PcPrcbData.PbInterruptTime
        jmp     Kutp51

ALIGN 4
Kutp4:

;
; Update the time spent in kernel mode for the current thread and the current
; thread's process.
;
        inc     dword ptr [ebx]+ThKernelTime

        LOCK_INC    dword ptr [ecx]+PrKernelTime

        jmp     Kutp50


;
; Update total time spent in user mode
;

ALIGN 4
Kutp20:
        mov     edx, 1                  ; set user mode
        inc     dword ptr [eax].PcPrcbData.PbUserTime
;
; Update the time spend in user mode for the current thread and the current
; thread's process.
;

        inc     dword ptr [ebx]+ThUserTime

        LOCK_INC    dword ptr [ecx]+PrUserTime

;
; Notify registered callout routine of update time.
;
; N.B. The register edx contains the processor mode.
;

ALIGN 4
Kutp50:                                 ;

ifndef NT_UP

        cmp     _KiTimeUpdateNotifyRoutine, 0 ; check for callout routine
        je      short Kutp51            ; if eq, no callout routine registered
        mov     ecx, [ebx].EtCid.CidUniqueThread ; set current thread unique id
        call    [_KiTimeUpdateNotifyRoutine] ; notify callout routine
        mov     eax, PCR[PcSelfPcr]     ; restore PCR address

endif

;
; Update the DPC request rate which is computed as the average between
; the previous rate and the current rate.
;

ALIGN 4
Kutp51: mov     ecx, [eax].PcPrcbData.PbDpcCount ; get current DPC count
        mov     edx, [eax].PcPrcbData.PbDpcLastCount ; get last DPC count
        mov     [eax].PcPrcbData.PbDpcLastCount, ecx ; set last DPC count
        sub     ecx, edx                ; compute count during interval
        add     ecx, [eax].PcPrcbData.PbDpcRequestRate ; compute sum
        shr     ecx, 1                  ; average current and last
        mov     [eax].PcPrcbData.PbDpcRequestRate, ecx ; set new DPC request rate

;
; If the current DPC queue depth is not zero, a DPC routine is not active,
; and a DPC interrupt has not been requested, then request a dispatch
; interrupt, decrement the maximum DPC queue depth, and reset the threshold
; counter if appropriate.
;

        cmp     dword ptr [eax].PcPrcbData.PbDpcQueueDepth, 0 ; check queue depth
        je      short Kutp53            ; if eq, DPC queue depth is zero
        cmp     dword ptr [eax].PcPrcbData.PbDpcRoutineActive, 0 ; check if DPC active
        jne     short Kutp53            ; if ne, DPC routine active
        cmp     dword ptr [eax].PcPrcbData.PbDpcInterruptRequested, 0 ; check if interrupt
        jne     short Kutp53            ; if ne, DPC routine active
        mov     ecx, DISPATCH_LEVEL     ; request a dispatch interrupt
        fstCall HalRequestSoftwareInterrupt ;
        mov     eax, PCR[PcSelfPcr]     ; restore address of current PCR
        mov     ecx, [eax].PcPrcbData.PbDpcRequestRate ; get DPC request rate
        mov     edx, _KiAdjustDpcThreshold ; reset initial threshold counter
        mov     [eax].PcPrcbData.PbAdjustDpcThreshold, edx ;
        cmp     ecx, _KiIdealDpcRate    ; test if current rate less than ideal
        jge     short Kutp55            ; if ge, rate greater or equal ideal
        cmp     [eax].PcPrcbData.PbMaximumDpcQueueDepth, 1 ; check if depth one
        je      short Kutp55            ; if eq, maximum depth is one
        dec     dword ptr [eax].PcPrcbData.PbMaximumDpcQueueDepth ; decrement depth
        jmp     short Kutp55            ;

;
; The DPC queue is empty or a DPC routine is active or a DPC interrupt
; has been requested. Count down the adjustment threshold and if the
; count reaches zero, then increment the maximum DPC queue depth, but
; no above the initial value and reset the adjustment threshold value.
;

Kutp53: dec     dword ptr [eax].PcPrcbData.PbAdjustDpcThreshold ; decrement threshold
        jnz     short Kutp55            ; if nz, threshold not zero
        mov     ecx, _KiAdjustDpcThreshold ; reset initial threshold counter
        mov     [eax].PcprcbData.PbAdjustDpcThreshold, ecx ;
        mov     ecx, _KiMaximumDpcQueueDepth ; get maximum DPC queue depth
        cmp     ecx, [eax].PcPrcbData.PbMaximumDpcQueueDepth ; check depth
        je      short Kutp55            ; if eq, aleady a maximum level
        inc     dword ptr [eax].PcPrcbData.PbMaximumDpcQueueDepth ; increment maximum depth

;
; Decrement current thread quantum and check to determine if a quantum end
; has occurred.
;

ALIGN 4
Kutp55: sub     byte ptr [ebx]+ThQuantum, CLOCK_QUANTUM_DECREMENT ; decrement quantum
        jg      Kutp75                      ; if > 0, time remaining on quantum

;
; Set quantum end flag and initiate a dispather interrupt on the current
; processor.
;

        cmp     ebx,[eax].PcPrcbData.PbIdleThread ; check if idle thread
        jz      Kutp75                      ; if z, then idle thread
        mov     [eax].PcPrcbData.PbQuantumEnd, esp ; set quantum end indicator
        mov     ecx, DISPATCH_LEVEL         ; request dispatch interrupt
        fstCall HalRequestSoftwareInterrupt ;
Kutp75:                                     ;
        pop     ebx                         ;
        stdRET    _KeUpdateRunTime          ;

if DBG
kutp_skiptick:
        mov     byte ptr [eax]+PcPrcbData+PbSkipTick, 0
        stdRET    _KeUpdateRunTime
endif

stdENDP _KeUpdateRunTime


;++
;
;   PROFILING SUPPORT
;
;--


;++
;
; VOID
; KeProfileInterrupt (
;       IN PKTRAP_FRAME TrapFrame,
;       )
;
; Routine Description:
;
;    This procedure is the ISR for the profile sampling interrupt,
;    which for x86 machines is driven off the 8254 timer1 channel 0.
;
;    The procedure scans the list of profile objects, looking for those
;    which match the address space and return program counter captured
;    at entry.  For each object that does match, the counter in its
;    profile buffer matching the bucket the PC falls into is computed,
;    and that counter is incremented.
;
;    N.B. This routine is executed on all processors in a multiprocess
;       system.
;
; Arguments:
;
;    Return Address (esp)
;
;    TrapFrame (esp+4) - supplies pointer to profile trap frame
;
; Environment:
;
;    IRQL = KiProfileIrql
;
;
; Return Value:
;
;    None.
;
;    WARNING: Uses ALL registers
;
;--

cPublicProc _KeProfileInterrupt ,1
;
; rearrange arguments to pass a source of 0 to KeProfileInterruptWithSource
;
        pop     eax     ; return code in eax
        pop     ebx     ; trap frame in ebx
        push    0       ; push source of 0 (ProfileTime)
        push    ebx     ; push trap frame
        push    eax     ; push return address
        jmp     short   _KeProfileInterruptWithSource@8
stdENDP _KeProfileInterrupt

;++
;
; VOID
; KeProfileInterruptWithSource (
;       IN PKTRAP_FRAME TrapFrame,
;       IN KPROFILE_SOURCE ProfileSource
;       )
;
; Routine Description:
;
;    This procedure is the ISR for the multiple-source profile interrupt.
;
;    Since no x86 HAL currently implements any source other than the
;    clock interrupt, this routine is just a stub that calls KeProfileInterrupt
;
; Arguments:
;
;    Return Address (esp)
;
;    TrapFrame (esp+4) - supplies pointer to profile trap frame
;
;    ProfileSource (esp+8) - supplies source of profile interrupt
;
; Environment:
;
;    IRQL = KiProfileIrql
;
;
; Return Value:
;
;    None.
;
;    WARNING: Uses ALL registers
;
;--
cPublicProc _KeProfileInterruptWithSource,2

kipieip         equ     <dword ptr [ebp+TsEip]>
kipsegcs        equ     <word ptr [ebp+TsSegCs]>
kipeflags       equ     <dword ptr [ebp+TsEFlags]>

        mov     ebp, dword ptr [esp+4]  ; (ebp)-> trap frame
        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

        cmp     _PPerfGlobalGroupMask, 0 ; check if event tracing is on
        je      short kipi03

        ;; add profile interrupt to perfinfo
        mov        ecx, [esp+8]
        mov        edx,kipieip
        fstCall    PerfProfileInterrupt
        mov     ebp, dword ptr [esp+4]  ; (ebp)-> trap frame
kipi03:

ifndef NT_UP
        lea     eax,_KiProfileLock
kipi05: ACQUIRE_SPINLOCK    eax,kipi96
endif

;
;   Update profile data
;
;   NOTE:
;   System and Process update loops are duplicates, to avoid overhead
;   of call instruction in what could be very high freq. interrupt.
;   be sure to update both loops for changes.
;
;   NOTE:
;   The process loop contains code to update segment profile objects.
;   This code is not present in the system loop, because we do not
;   allow attachment of profile objects for non-flat segments on a
;   system wide basis.
;
;   NOTE:
;   Profiling in V86 mode is handled by converting the CS:IP value to
;   a linear address (CS<<4 + IP)
;

        inc     ProfileCount            ; total number of hits

;
;   Update system profile entries
;

        mov     ebx, kipieip
        mov     edx,offset FLAT:_KiProfileListHead
        mov     esi,[edx].LsFlink       ; (esi) -> profile object
ifndef NT_UP
        mov     edi, PCR[PcSetMember]   ; (edi) = current processor
endif
        mov     ecx, [esp+8]            ; (cx) = profile source
        cmp     esi,edx
        je      kipi30                  ; end of system list, go do process

;
;   (ebx) = sample program counter
;   (esi) -> profile object
;

ALIGN 4
kipi10: cmp     ebx,[esi+PfRangeBase-PfProfileListEntry]    ; >= base?
        jb      kipi20                                      ; no, skip entry
        cmp     ebx,[esi+PfRangeLimit-PfProfileListEntry]   ; < limit?
        jae     kipi20                                      ; no, skip entry
        cmp     cx,word ptr [esi+PfSource-PfProfileListEntry]       ; == source?
        jne     kipi20                                      ; no, skip entry
ifndef NT_UP
        test    edi,[esi+PfAffinity-PfProfileListEntry]     ; affinity match?
        jz      kipi20                                      ; no, skip entry
endif

;
;   RangeBase <= program counter < RangeLimit, we have a hit
;

        sub     ebx,[esi+PfRangeBase-PfProfileListEntry]    ; (ebx) = offset in profile range
        mov     cl,[esi+PfBucketShift-PfProfileListEntry]
        shr     ebx,cl
        and     ebx,NOT 3               ; (ebx) = offset of counter for bucket
        mov     edi,[esi+PfBuffer-PfProfileListEntry] ; (edi) -> buffer
        inc     dword ptr [edi+ebx]     ; record hit
        mov     ebx, kipieip            ; (ebx) = sample pc
        mov     ecx, [esp+8]            ; (cx) = profile source
ifndef NT_UP
        mov     edi, PCR[PcSetMember]   ; (edi) = current processor
endif


;
;   Go to next entry
;

ALIGN 4
kipi20: mov     esi,[esi].LsFlink       ; (esi) -> profile object
        cmp     esi,edx
        jne     kipi10                  ; not end of list, repeat


;
;   Update process profile entries
;   (ebx) = sample program counter
;

ALIGN 4
kipi30: mov     eax,PCR[PcPrcbData+PbCurrentThread] ; (eax)-> current thread
        mov     eax,ThApcState+AsProcess[eax]       ; (eax)-> current process
        lea     edx,[eax]+PrProfileListHead         ; (edx)-> listhead
        mov     esi,[edx].LsFlink                   ; (esi)-> profile object
        cmp     esi,edx
        je      kipi60                              ; process list end, return

;
;   Check for 16 bitness
;
        movzx   ecx,word ptr kipsegcs
        test    kipeflags,EFLAGS_V86_MASK
        jnz     kipi100                             ; convert cs:ip to linear

        cmp     cx,KGDT_R0_CODE
        je      short kipi40

        cmp     cx,KGDT_R3_CODE or RPL_MASK
        jne     kipi110

;
;   (ebx) = sample program counter
;   (esi) -> profile object
;

ALIGN 4
kipi40: cmp     [esi+PfSegment-PfProfileListEntry],word ptr 0 ; flat object?
        jne     kipi50                                      ; no, skip entry
        cmp     ebx,[esi+PfRangeBase-PfProfileListEntry]    ; >= base?
        jb      kipi50                                      ; no, skip entry
        cmp     ebx,[esi+PfRangeLimit-PfProfileListEntry]   ; < limit?
        jae     kipi50                                      ; no, skip entry
        mov     ecx, [esp+8]                                ; (cx) = profile source
        cmp     cx,word ptr [esi+PfSource-PfProfileListEntry]       ; == source?
        jne     kipi50                                      ; no, skip entry
ifndef NT_UP
        mov     edi,PCR[PcSetMember]                        ; (edi) = set member
        test    edi,[esi+PfAffinity-PfProfileListEntry]     ; affinity match?
        jz      kipi50                                      ; no, skip entry
endif


;
;   RangeBase <= program counter < RangeLimit, we have a hit
;

        sub     ebx,[esi+PfRangeBase-PfProfileListEntry]    ; (ebx) = offset in profile range
        mov     cl,[esi+PfBucketShift-PfProfileListEntry]
        shr     ebx,cl
        and     ebx,NOT 3               ; (ebx) = offset of counter for bucket
        mov     edi,[esi+PfBuffer-PfProfileListEntry] ; (edi) -> buffer
        inc     dword ptr [edi+ebx]     ; record hit
        mov     ebx, kipieip            ; (ebx) = sample pc
        mov     ecx, [esp+8]                                ; (cx) = profile source

;
;   Go to next entry
;

ALIGN 4
kipi50: mov     esi,[esi].LsFlink       ; (esi) -> profile object
        cmp     esi,edx
        jne     kipi40                  ; not end of list, repeat

ALIGN 4
kipi60:

ifndef  NT_UP
        lea     eax,_KiProfileLock
        RELEASE_SPINLOCK    eax
endif
        stdRet  _KeProfileInterruptWithSource

ifndef NT_UP
ALIGN 4
kipi96: SPIN_ON_SPINLOCK    eax,kipi05,,DbgMp
endif

ALIGN 4
kipi100:
        shl     ecx,4                   ; segment -> paragraph
        add     ebx,ecx                 ; paragraph offset -> linear
        jmp     kipi40

;
;   Update segment profile objects
;

;
;   (ebx) = sample program counter
;   (esi) -> profile object
;

ALIGN 4
kipi110:
        cmp     [esi+PfSegment-PfProfileListEntry],ecx      ; This segment?
        jne     kipi120                                     ; no, skip entry
        cmp     ebx,[esi+PfRangeBase-PfProfileListEntry]    ; >= base?
        jb      kipi120                                     ; no, skip entry
        cmp     ebx,[esi+PfRangeLimit-PfProfileListEntry]   ; < limit?
        jae     kipi120                                     ; no, skip entry
        mov     ecx, [esp+8]                                ; (cx) = profile source
        cmp     cx,word ptr [esi+PfSource-PfProfileListEntry]       ; == source?
        jne     kipi120                                     ; no, skip entry
ifndef NT_UP
        mov     edi,PCR[PcSetMember]                        ; (edi) = set member
        test    edi,[esi+PfAffinity-PfProfileListEntry]     ; affinity match?
        jnz     kipi120                                     ; no, skip entry
endif

;
;   RangeBase <= program counter < RangeLimit, we have a hit
;

        sub     ebx,[esi+PfRangeBase-PfProfileListEntry]    ; (ebx) = offset in profile range
        mov     cl,[esi+PfBucketShift-PfProfileListEntry]
        shr     ebx,cl
        and     ebx,NOT 3               ; (ebx) = offset of counter for bucket
        mov     edi,[esi+PfBuffer-PfProfileListEntry] ; (edi) -> buffer
        inc     dword ptr [edi+ebx]     ; record hit
        mov     ebx, kipieip            ; (ebx) = sample pc
        mov     cx,kipsegcs             ; ecx = sample cs

;
;   Go to next entry
;

ALIGN 4
kipi120:
        mov     esi,[esi].LsFlink       ; (esi) -> profile object
        cmp     esi,edx
        jne     kipi110                 ; not end of list, repeat

        jmp     kipi60

stdENDP _KeProfileInterruptWithSource
_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\ctxswap.asm ===
title  "Context Swap"
;++
;
; Copyright (c) 1989, 2000  Microsoft Corporation
;
; Module Name:
;
;    ctxswap.asm
;
; Abstract:
;
;    This module implements the code necessary to field the dispatch
;    interrupt and to perform kernel initiated context switching.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 14-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   22-feb-90   bryanwi
;       write actual swap context procedure
;
;--

.586p
        .xlist
include ks386.inc
include i386\kimacro.inc
include mac386.inc
include callconv.inc
FPOFRAME macro a, b
.FPO ( a, b, 0, 0, 0, 0 )
endm
        .list

        EXTRNP  KeAcquireQueuedSpinLockAtDpcLevel,1,,FASTCALL
        EXTRNP  KeReleaseQueuedSpinLockFromDpcLevel,1,,FASTCALL
        EXTRNP  KeTryToAcquireQueuedSpinLockAtRaisedIrql,1,,FASTCALL
        EXTRNP  KeAcquireQueuedSpinLockRaiseToSynch,1,,FASTCALL

        EXTRNP  KfAcquireSpinLock,1,IMPORT,FASTCALL

        EXTRNP  HalClearSoftwareInterrupt,1,IMPORT,FASTCALL
        EXTRNP  HalRequestSoftwareInterrupt,1,IMPORT,FASTCALL
        EXTRNP  KiActivateWaiterQueue,1,,FASTCALL
        EXTRNP  KiReadyThread,1,,FASTCALL
        EXTRNP  KiWaitTest,2,,FASTCALL
        EXTRNP  KfLowerIrql,1,IMPORT,FASTCALL
        EXTRNP  KfRaiseIrql,1,IMPORT,FASTCALL
        EXTRNP  _KeGetCurrentIrql,0,IMPORT
        EXTRNP  ___KeGetCurrentThread,0
        EXTRNP  _KiDeliverApc,3
        EXTRNP  _KiQuantumEnd,0
        EXTRNP  _KeBugCheckEx,5
        EXTRNP  _KeBugCheck,1

        extrn   _KiTrap13:PROC
        extrn   _KeI386FxsrPresent:BYTE
        extrn   _KiDispatcherLock:DWORD
        extrn   _KeFeatureBits:DWORD
        extrn   _KeThreadSwitchCounters:DWORD

        extrn   __imp_@KfLowerIrql@4:DWORD

        extrn   _KiDispatcherReadyListHead:DWORD
        extrn   _KiIdleSummary:DWORD
        extrn   _KiIdleSMTSummary:DWORD
        extrn   _KiReadySummary:DWORD
        extrn   _PPerfGlobalGroupMask:DWORD
        
        EXTRNP  WmiTraceContextSwap,2,,FASTCALL
        EXTRNP  PerfInfoLogDpc,3,,FASTCALL

if DBG
        extrn   _KdDebuggerEnabled:BYTE
        EXTRNP  _DbgBreakPoint,0
        EXTRNP  _KdPollBreakIn,0
        extrn   _DbgPrint:near
        extrn   _MsgDpcTrashedEsp:BYTE
        extrn   _MsgDpcTimeout:BYTE
        extrn   _KiDPCTimeout:DWORD
endif


_TEXT$00   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cPublicFastCall KiRDTSC, 1
        rdtsc                   ; read the timestamp counter
        mov     [ecx], eax      ; return the low 32 bits
        mov     [ecx+4], edx    ; return the high 32 bits
        fstRET  KiRDTSC
fstENDP KiRDTSC

        page ,132
        subttl  "Unlock Dispatcher Database"
;++
;
; VOID
; KiUnlockDispatcherDatabase (
;    IN KIRQL OldIrql
;    )
;
; Routine Description:
;
;    This routine is entered at IRQL DISPATCH_LEVEL with the dispatcher
;    database locked. Its function is to either unlock the dispatcher
;    database and return or initiate a context switch if another thread
;    has been selected for execution.
;
; Arguments:
;
;    (TOS)   Return address
;
;    (ecx)   OldIrql - Supplies the IRQL when the dispatcher database
;        lock was acquired.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KiUnlockDispatcherDatabase, 1

;
; Check if a new thread is scheduled for execution.
;

        cmp     PCR[PcPrcbData+PbNextThread], 0 ; check if next thread
        jne     short Kiu20             ; if ne, new thread scheduled

;
; Release dispatcher database lock, lower IRQL to its previous level,
; and return.
;

Kiu00:                                  ;

ifndef NT_UP

        mov     eax, PCR[PcPrcb]                ; get address of PRCB
        push    ecx                             ; save IRQL for lower IRQL
        lea     ecx, [eax]+PbLockQueue+(8*LockQueueDispatcherLock)
        fstCall KeReleaseQueuedSpinLockFromDpcLevel
        pop     ecx                             ; get OldIrql

endif

;
; N.B. This exit jumps directly to the lower IRQL routine which has a
;      compatible fastcall interface.
;

        jmp     dword ptr [__imp_@KfLowerIrql@4] ; lower IRQL to previous level

;
; A new thread has been selected to run on the current processor, but
; the new IRQL is not below dispatch level. If the current processor is
; not executing a DPC, then request a dispatch interrupt on the current
; processor.
;

Kiu10:  cmp     dword ptr PCR[PcPrcbData.PbDpcRoutineActive],0  ; check if DPC routine active
        jne     short Kiu00             ; if ne, DPC routine is active

        push    ecx                     ; save new IRQL

ifndef NT_UP

        mov     eax, PCR[PcPrcb]                ; get address of PRCB
        lea     ecx, [eax]+PbLockQueue+(8*LockQueueDispatcherLock)
        fstCall KeReleaseQueuedSpinLockFromDpcLevel

endif

        mov     cl, DISPATCH_LEVEL      ; request dispatch interrupt
        fstCall HalRequestSoftwareInterrupt ;
        pop     ecx                     ; restore new IRQL

;
; N.B. This exit jumps directly to the lower IRQL routine which has a
;      compatible fastcall interface.
;

        jmp     dword ptr [__imp_@KfLowerIrql@4] ; lower IRQL to previous level

;
; Check if the previous IRQL is less than dispatch level.
;

Kiu20:  cmp     cl, DISPATCH_LEVEL      ; check if IRQL below dispatch level
        jge     short Kiu10             ; if ge, not below dispatch level

;
; There is a new thread scheduled for execution and the previous IRQL is
; less than dispatch level. Context switch to the new thread immediately.
;
;
; N.B. The following registers MUST be saved such that ebp is saved last.
;      This is done so the debugger can find the saved ebp for a thread
;      that is not currently in the running state.
;

.fpo (0, 0, 0, 4, 1, 0)
        sub     esp, 4*4
        mov     [esp+12], ebx           ; save registers
        mov     [esp+8], esi            ;
        mov     [esp+4], edi            ;
        mov     [esp+0], ebp            ;
        mov     ebx, PCR[PcSelfPcr]     ; get address of PCR
        mov     esi, [ebx].PcPrcbData.PbNextThread ; get next thread address
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; get current thread address
        mov     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread address
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set current thread address
        mov     [edi].ThWaitIrql, cl    ; save previous IRQL
        mov     ecx, edi                ; set address of current thread
        mov     byte ptr [edi].ThIdleSwapBlock, 1
        fstCall KiReadyThread           ; reready thread for execution
        mov     cl, [edi].ThWaitIrql    ; set APC interrupt bypass disable
        CAPSTART <@KiUnlockDispatcherDatabase@4,SwapContext>
        call    SwapContext             ; swap context
        CAPEND   <@KiUnlockDispatcherDatabase@4>
        or      al, al                  ; check if kernel APC pending
        mov     cl, [esi].ThWaitIrql    ; get original wait IRQL
        jnz     short Kiu50             ; if nz, kernel APC pending

Kiu30:  mov     ebp, [esp+0]            ; restore registers
        mov     edi, [esp+4]            ;
        mov     esi, [esp+8]            ;
        mov     ebx, [esp+12]           ;
        add     esp, 4*4

;
; N.B. This exit jumps directly to the lower IRQL routine which has a
;      compatible fastcall interface.
;

        jmp     dword ptr [__imp_@KfLowerIrql@4] ; lower IRQL to previous level

Kiu50:  mov     cl, APC_LEVEL           ; lower IRQL to APC level
        fstCall KfLowerIrql             ;
        xor     eax, eax                ; set previous mode to kernel
        CAPSTART <@KiUnlockDispatcherDatabase@4,_KiDeliverApc@12>
        stdCall _KiDeliverApc, <eax, eax, eax> ; deliver kernel mode APC
        CAPEND <@KiUnlockDispatcherDatabase@4>
        xor     ecx, ecx                ; set original wait IRQL
        jmp     short Kiu30

fstENDP KiUnlockDispatcherDatabase

        page ,132
        subttl  "Swap Context"
;++
;
; BOOLEAN
; KiSwapContext (
;    IN PKTHREAD Thread
;    )
;
; Routine Description:
;
;    This function is a small wrapper, callable from C code, that marshalls
;    arguments and calls the actual swap context routine.
;
; Arguments:
;
;    Thread (ecx) - Supplies the address of the new thread.
;
; Return Value:
;
;    If a kernel APC is pending, then a value of TRUE is returned. Otherwise,
;    a value of FALSE is returned.
;
;--

cPublicFastCall KiSwapContext, 1
.fpo (0, 0, 0, 4, 1, 0)

;
; N.B. The following registers MUST be saved such that ebp is saved last.
;      This is done so the debugger can find the saved ebp for a thread
;      that is not currently in the running state.
;

        sub     esp, 4*4
        mov     [esp+12], ebx           ; save registers
        mov     [esp+8], esi            ;
        mov     [esp+4], edi            ;
        mov     [esp+0], ebp            ;
        mov     ebx, PCR[PcSelfPcr]     ; set address of PCR
        mov     esi, ecx                ; set next thread address
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; get current thread address
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set current thread address
        mov     cl, [edi].ThWaitirql    ; set APC interrupt bypass disable
        call    SwapContext             ; swap context
        mov     ebp, [esp+0]            ; restore registers
        mov     edi, [esp+4]            ;
        mov     esi, [esp+8]            ;
        mov     ebx, [esp+12]           ;
        add     esp, 4*4                ;
        fstRET  KiSwapContext           ;

fstENDP KiSwapContext

        page ,132
        subttl  "Dispatch Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a software interrupt generated
;    at DISPATCH_LEVEL. Its function is to process the Deferred Procedure Call
;    (DPC) list, and then perform a context switch if a new thread has been
;    selected for execution on the processor.
;
;    This routine is entered at IRQL DISPATCH_LEVEL with the dispatcher
;    database unlocked. When a return to the caller finally occurs, the
;    IRQL remains at DISPATCH_LEVEL, and the dispatcher database is still
;    unlocked.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--

        align 16
cPublicProc _KiDispatchInterrupt ,0
cPublicFpo 0, 0

        mov     ebx, PCR[PcSelfPcr]     ; get address of PCR
kdi00:  lea     eax, [ebx].PcPrcbData.PbDpcListHead ; get DPC listhead address

;
; Disable interrupts and check if there is any work in the DPC list
; of the current processor.
;

kdi10:  cli                             ; disable interrupts
        cmp     eax, [eax].LsFlink      ; check if DPC List is empty
        je      short kdi40             ; if eq, list is empty
        push    ebp                     ; save register

;
; Exceptions occuring in DPCs are unrelated to any exception handlers
; in the interrupted thread.  Terminate the exception list.
;

        push    [ebx].PcExceptionList
        mov     [ebx].PcExceptionList, EXCEPTION_CHAIN_END

;
; Switch to the DPC stack for this processor.
;

        mov     edx, esp
        mov     esp, [ebx].PcPrcbData.PbDpcStack
        push    edx

.fpo (0, 0, 0, 1, 1, 0)

        mov     ebp, eax                ; set address of DPC listhead
        CAPSTART <_KiDispatchInterrupt,KiRetireDpcList>
        call    KiRetireDpcList         ; process the current DPC list
        CAPEND <_KiDispatchInterrupt>

;
; Switch back to the current thread stack, restore the exception list
; and saved EBP.
;

        pop     esp
        pop     [ebx].PcExceptionList
        pop     ebp 
.fpo (0, 0, 0, 0, 0, 0)

;
; Check to determine if quantum end is requested.
;
; N.B. If a new thread is selected as a result of processing the quantum
;      end request, then the new thread is returned with the dispatcher
;      database locked. Otherwise, NULL is returned with the dispatcher
;      database unlocked.
;

kdi40:  sti                             ; enable interrupts
        cmp     dword ptr [ebx].PcPrcbData.PbQuantumEnd, 0 ; quantum end requested
        jne     kdi90                   ; if neq, quantum end request

;
; Check to determine if a new thread has been selected for execution on this
; processor.
;

        cmp     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; check addr of next thread object
        je      kdi70                   ; if eq, then no new thread

;
; Disable interrupts and attempt to acquire the dispatcher database lock.
;

ifndef NT_UP

        cli
        cmp     dword ptr _KiDispatcherLock, 0
        jnz     short kdi80
        lea     ecx, [ebx]+PcPrcbData+PbLockQueue+(8*LockQueueDispatcherLock)
        fstCall KeTryToAcquireQueuedSpinLockAtRaisedIrql
        jz      short kdi80             ; jif not acquired
        mov ecx, SYNCH_LEVEL            ; raise IRQL to synchronization level
        fstCall KfRaiseIrql             ;
        sti                             ; enable interrupts

endif

        mov     eax, [ebx].PcPrcbData.PbNextThread ; get next thread address

;
; N.B. The following registers MUST be saved such that ebp is saved last.
;      This is done so the debugger can find the saved ebp for a thread
;      that is not currently in the running state.
;

.fpo (0, 0, 0, 3, 1, 0)

kdi60:  sub     esp, 3*4
        mov     [esp+8], esi            ; save registers
        mov     [esp+4], edi            ;
        mov     [esp+0], ebp            ;
        mov     esi, eax                ; set next thread address
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; get current thread address
        mov     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; clear next thread address
        mov     [ebx].PcPrcbData.PbCurrentThread, esi ; set current thread address
        mov     ecx, edi                ; set address of current thread
        mov     byte ptr [edi].ThIdleSwapBlock, 1
        fstCall KiReadyThread           ; reready thread for execution
        CAPSTART <_KiDispatchInterrupt,SwapContext>
        mov     cl, 1                   ; set APC interrupt bypass disable
        call    SwapContext             ; swap context
        CAPEND <_KiDispatchInterrupt>
        mov     ebp, [esp+0]            ; restore registers
        mov     edi, [esp+4]            ;
        mov     esi, [esp+8]            ;
        add     esp, 3*4
kdi70:  stdRET  _KiDispatchInterrupt    ; return

;
; Enable interrupts and check DPC queue.
;

ifndef NT_UP

kdi80: sti                              ; enable interrupts
       YIELD                            ; rest
       jmp     kdi00                    ;

endif

;
; Process quantum end event.
;
; N.B. If the quantum end code returns a NULL value, then no next thread
;      has been selected for execution. Otherwise, a next thread has been
;      selected and the dispatcher databased is locked.
;

kdi90:  mov     dword ptr [ebx].PcPrcbData.PbQuantumEnd, 0 ; clear quantum end indicator
        CAPSTART <_KiDispatchInterrupt,_KiQuantumEnd@0>
        stdCall _KiQuantumEnd           ; process quantum end
        CAPEND <_KiDispatchInterrupt>
        or      eax, eax                ; check if new thread selected
        jne     kdi60                   ; if ne, new thread selected
        stdRET  _KiDispatchInterrupt    ; return

stdENDP _KiDispatchInterrupt

        page ,132
        subttl  "Swap Context to Next Thread"
;++
;
; Routine Description:
;
;    This routine is called to swap context from one thread to the next.
;    It swaps context, flushes the data, instruction, and translation
;    buffer caches, restores nonvolatile integer registers, and returns
;    to its caller.
;
;    N.B. It is assumed that the caller (only callers are within this
;         module) saved the nonvolatile registers, ebx, esi, edi, and
;         ebp. This enables the caller to have more registers available.
;
; Arguments:
;
;    cl - APC interrupt bypass disable (zero enable, nonzero disable).
;    edi - Address of previous thread.
;    esi - Address of next thread.
;    ebx - Address of PCR.
;
; Return value:
;
;    al - Kernel APC pending.
;    ebx - Address of PCR.
;    esi - Address of current thread object.
;
;--

;
;   NOTE:   The ES: override on the move to ThState is part of the
;           lazy-segment load system.  It assures that ES has a valid
;           selector in it, thus preventing us from propagating a bad
;           ES accross a context switch.
;
;           Note that if segments, other than the standard flat segments,
;           with limits above 2 gig exist, neither this nor the rest of
;           lazy segment loads are reliable.
;
; Note that ThState must be set before the dispatcher lock is released
; to prevent KiSetPriorityThread from seeing a stale value.
;

ifndef NT_UP

        public  _ScPatchFxb
        public  _ScPatchFxe

endif

        align   16
        public  SwapContext

SwapContext     proc

;
; Save the APC disable flag and set new thread state to running.
;

        or      cl, cl                  ; set zf in flags
        mov     byte ptr es:[esi]+ThState, Running ; set thread state to running
        pushfd
cPublicFpo 0, 1

;
; Acquire the context swap lock so the address space of the old process
; cannot be deleted and then release the dispatcher database lock.
;
; N.B. This lock is used to protect the address space until the context
;    switch has sufficiently progressed to the point where the address
;    space is no longer needed. This lock is also acquired by the reaper
;    thread before it finishes thread termination.
;

ifndef NT_UP

        lea     ecx, [ebx]+PcPrcbData+PbLockQueue+(8*LockQueueContextSwapLock)
        fstCall KeAcquireQueuedSpinLockAtDpcLevel ; Acquire ContextSwap lock

        lea     ecx, [ebx]+PcPrcbData+PbLockQueue+(8*LockQueueDispatcherLock)
        fstCall KeReleaseQueuedSpinLockFromDpcLevel ; release Dispatcher Lock

endif

;
; Save the APC disable flag and the exception listhead.
; (also, check for DPC running which is illegal right now).
;

SwapContextFromIdle:

        mov     ecx, [ebx]+PcExceptionList ; save exception list
        cmp     [ebx]+PcPrcbData+PbDpcRoutineActive, 0
        push    ecx
cPublicFpo 0, 2
        jne     sc91                    ; bugcheck if DPC active.

;
; Check for context swap logging
;



        cmp     _PPerfGlobalGroupMask, 0 ; Is the global pointer != null?
        jne     sc92                     ; If not, then check if we are enabled
sc03:

ifndef NT_UP

if DBG

        mov     cl, [esi]+ThNextProcessor ; get current processor number
        cmp     cl, [ebx]+PcPrcbData+PbNumber ; same as running processor?
        jne     sc_error2               ; if ne, processor number mismatch

endif
endif

;
; Accumulate the total time spent in a thread.
;

ifdef PERF_DATA

        test    _KeFeatureBits, KF_RDTSC ; feature supported?
        jz      short @f                 ; if z, feature not present

        rdtsc                            ; read cycle counter

        sub     eax, [ebx].PcPrcbData.PbThreadStartCount.LiLowPart ; sub off thread
        sbb     edx, [ebx].PcPrcbData.PbThreadStartCount.LiHighPart ; starting time
        add     [edi].EtPerformanceCountLow, eax ; accumlate thread run time
        adc     [edi].EtPerformanceCountHigh, edx ;
        add     [ebx].PcPrcbData.PbThreadStartCount.LiLowPart, eax ; set new thread
        adc     [ebx].PcPrcbData.PbThreadStartCount.LiHighPart, edx ; starting time
@@:                                     ;

endif

;
; On a uniprocessor system the NPX state is swapped in a lazy manner.
; If a thread whose state is not in the coprocessor attempts to perform
; a coprocessor operation, the current NPX state is swapped out (if needed),
; and the new state is swapped in durning the fault.  (KiTrap07)
;
; On a multiprocessor system we still fault in the NPX state on demand, but
; we save the state when the thread switches out (assuming the NPX state
; was loaded).  This is because it could be difficult to obtain the thread's
; NPX in the trap handler if it was loaded into a different processor's
; coprocessor.
;
        mov     ebp, cr0                ; get current CR0
        mov     edx, ebp

ifndef NT_UP
        cmp     byte ptr [edi]+ThNpxState, NPX_STATE_LOADED ; check if NPX state
        je      sc_save_npx_state
endif


sc05:   mov     cl, [esi]+ThDebugActive ; get debugger active state
        mov     [ebx]+PcDebugActive, cl ; set new debugger active state

;
; Switch stacks:
;
;   1.  Save old esp in old thread object.
;   2.  Copy stack base and stack limit into TSS AND PCR
;   3.  Load esp from new thread object
;
; Keep interrupts off so we don't confuse the trap handler into thinking
; we've overrun the kernel stack.
;

        cli                             ; disable interrupts
        mov     [edi]+ThKernelStack, esp ; save old kernel stack pointer
        mov     eax, [esi]+ThInitialStack ; get new initial stack pointer
        mov     ecx, [esi]+ThStackLimit ; get stack limit
        sub     eax, NPX_FRAME_LENGTH   ; space for NPX_FRAME & NPX CR0 flags
        mov     [ebx]+PcStackLimit, ecx ; set new stack limit
        mov     [ebx]+PcInitialStack, eax ; set new stack base

.errnz (NPX_STATE_NOT_LOADED - CR0_TS - CR0_MP)
.errnz (NPX_STATE_LOADED - 0)

; (eax) = Initial Stack
; (ebx) = PCR
; (edi) = OldThread
; (esi) = NewThread
; (ebp) = Current CR0
; (edx) = Current CR0

        xor     ecx, ecx
        mov     cl, [esi]+ThNpxState            ; New NPX state is (or is not) loaded

        and     edx, NOT (CR0_MP+CR0_EM+CR0_TS) ; clear thread settable NPX bits
        or      ecx, edx                        ; or in new thread's cr0
        or      ecx, [eax]+FpCr0NpxState        ; merge new thread settable state
        cmp     ebp, ecx                ; check if old and new CR0 match
        jne     sc_reload_cr0           ; if ne, no change in CR0

;
; N.B. It is important that the following adjustment NOT be applied to
;      the initial stack value in the PCR. If it is, it will cause the
;      location in memory that the processor pushes the V86 mode segment
;      registers and the first 4 ULONGs in the FLOATING_SAVE_AREA to
;      occupy the same memory locations, which could result in either
;      trashed segment registers in V86 mode, or a trashed NPX state.
;
;      Adjust ESP0 so that V86 mode threads and 32 bit threads can share
;      a trapframe structure, and the NPX save area will be accessible
;      in the same manner on all threads
;
;      This test will check the user mode flags. On threads with no user
;      mode context, the value of esp0 does not matter (we will never run
;      in user mode without a usermode context, and if we don't run in user
;      mode the processor will never use the esp0 value.
;

        align   4
sc06:   test    dword ptr [eax] - KTRAP_FRAME_LENGTH + TsEFlags, EFLAGS_V86_MASK
        jnz     short sc07              ; if nz, V86 frame, no adjustment
        sub     eax, TsV86Gs - TsHardwareSegSs ; bias for missing fields
sc07:   mov     ecx, [ebx]+PcTss        ;
        mov     [ecx]+TssEsp0, eax      ;
        mov     esp, [esi]+ThKernelStack ; set new stack pointer
        mov     eax, [esi]+ThTeb        ; get user TEB address
        mov     [ebx]+PcTeb, eax        ; set user TEB address
        sti                             ; enable interrupts

;
; If the new process is not the same as the old process, then switch the
; address space to the new process.
;

        mov     eax, [edi].ThApcState.AsProcess ; get old process address
        cmp     eax, [esi].ThApcState.AsProcess ; check if process match

;
; The old thread is no longer on the processor.   It is no longer
; necessary to protect context swap against an idle processor picking
; up that thread before it has been completely removed from this
; processor.
;

        mov     byte ptr [edi].ThIdleSwapBlock, 0

        jz      short sc22                      ; if z old process same as new
        mov     edi, [esi].ThApcState.AsProcess ; get new process address
;
; NOTE: Keep KiSwapProcess (below) in sync with this code!
;
; Update the processor set masks.
;

ifndef NT_UP

        mov     ecx, [ebx]+PcSetMember  ; get processor set member
        xor     [eax]+PrActiveProcessors, ecx ; clear bit in old processor set
        xor     [edi]+PrActiveProcessors, ecx ; set bit in new processor set

if DBG
        test    [eax]+PrActiveProcessors, ecx ; test if bit clear in old set
        jnz     sc_error4               ; if nz, bit not clear in old set
        test    [edi]+PrActiveProcessors, ecx ; test if bit set in new set
        jz      sc_error5               ; if z, bit not set in new set

endif
endif

;
; LDT switch
;

        test    word ptr [edi]+PrLdtDescriptor, 0FFFFH
        jnz     short sc_load_ldt       ; if nz, LDT limit
        xor     eax, eax                ; set LDT NULL
sc21:   lldt    ax

;
; All system structures have been updated, release the context swap
; lock.   This thread is still at raised IRQL so it cannot be context
; switched, remaining setup can be done without the lock held.
;

ifndef NT_UP

        lea     ecx, [ebx]+PcPrcbData+PbLockQueue+(8*LockQueueContextSwapLock)
        fstCall KeReleaseQueuedSpinLockFromDpcLevel

endif

;
; New CR3, flush tb, sync tss, set IOPM
; CS, SS, DS, ES all have flat (GDT) selectors in them.
; FS has the pcr selector.
; Therefore, GS is only selector we need to flush.  We null it out,
; it will be reloaded from a stack frame somewhere above us.
; Note: this load of GS before CR3 works around P6 step B0 errata 11
;

        xor     eax, eax
        mov     gs,  eax                ; (16bit gs = 32bit eax, truncates
                                        ; saves 1 byte, is faster).
        mov     eax, [edi]+PrDirectoryTableBase ; get new directory base
        mov     ebp, [ebx]+PcTss        ; get new TSS
        mov     ecx, [edi]+PrIopmOffset ; get IOPM offset
        mov     [ebp]+TssCR3, eax       ; make TSS be in sync with hardware
        mov     cr3, eax                ; flush TLB and set new directory base
        mov     [ebp]+TssIoMapBase, cx  ;
        jmp short sc23

;
; Release the context swap lock.
;

        align   4
sc22:                                   ;

ifndef NT_UP

        lea     ecx, [ebx]+PcPrcbData+PbLockQueue+(8*LockQueueContextSwapLock)
        fstCall KeReleaseQueuedSpinLockFromDpcLevel

endif

;
; Edit the TEB descriptor to point to the TEB
;

sc23:
        mov     eax, [ebx]+PcTeb
        mov     ecx, [ebx]+PcGdt        ;
        mov     [ecx]+(KGDT_R3_TEB+KgdtBaseLow), ax  ;
        shr     eax, 16                 ;
        mov     [ecx]+(KGDT_R3_TEB+KgdtBaseMid), al  ;
        mov     [ecx]+(KGDT_R3_TEB+KgdtBaseHi), ah

;
; Update context switch counters.
;

        inc     dword ptr [esi]+ThContextSwitches ; thread count
        inc     dword ptr [ebx]+PcPrcbData+PbContextSwitches ; processor count
        pop     ecx                     ; restore exception list
        mov     [ebx].PcExceptionList, ecx ;

;
; If the new thread has a kernel mode APC pending, then request an APC
; interrupt.
;

        cmp     byte ptr [esi].ThApcState.AsKernelApcPending, 0 ; APC pending?
        jne     short sc80              ; if ne, kernel APC pending
        popfd                           ; restore flags
        xor     eax, eax                ; clear kernel APC pending
        ret                             ; return

;
; The new thread has an APC interrupt pending. If APC interrupt bypass is
; enable, then return kernel APC pending. Otherwise, request a software
; interrupt at APC_LEVEL and return no kernel APC pending.
;

sc80:   popfd                           ; restore flags
        jnz     short sc90              ; if nz, APC interupt bypass disabled
        mov     al, 1                   ; set kernel APC pending
        ret                             ;

sc90:   mov     cl, APC_LEVEL           ; request software interrupt level
        fstCall HalRequestSoftwareInterrupt ;
        xor     eax, eax                ; clear kernel APC pending
        ret                             ;

;
; Set for new LDT value
;

sc_load_ldt:
        mov     ebp, [ebx]+PcGdt        ;
        mov     eax, [edi+PrLdtDescriptor] ;
        mov     [ebp+KGDT_LDT], eax     ;
        mov     eax, [edi+PrLdtDescriptor+4] ;
        mov     [ebp+KGDT_LDT+4], eax   ;
        mov     eax, KGDT_LDT           ;

;
; Set up int 21 descriptor of IDT.  If the process does not have an Ldt, it
; should never make any int 21 calls.  If it does, an exception is generated. If
; the process has an Ldt, we need to update int21 entry of LDT for the process.
; Note the Int21Descriptor of the process may simply indicate an invalid
; entry.  In which case, the int 21 will be trapped to the kernel.
;

        mov     ebp, [ebx]+PcIdt        ;
        mov     ecx, [edi+PrInt21Descriptor] ;
        mov     [ebp+21h*8], ecx        ;
        mov     ecx, [edi+PrInt21Descriptor+4] ;
        mov     [ebp+21h*8+4], ecx      ;
        jmp     sc21

;
; Cr0 has changed (ie, floating point processor present), load the new value.
;

sc_reload_cr0:
if DBG

        test    byte ptr [esi]+ThNpxState, NOT (CR0_TS+CR0_MP)
        jnz     sc_error                ;
        test    dword ptr [eax]+FpCr0NpxState, NOT (CR0_PE+CR0_MP+CR0_EM+CR0_TS)
        jnz     sc_error3               ;

endif
        mov     cr0,ecx                 ; set new CR0 NPX state
        jmp     sc06


ifndef NT_UP


; Save coprocessor's current context.  FpCr0NpxState is the current thread's
; CR0 state.  The following bits are valid: CR0_MP, CR0_EM, CR0_TS.  MVDMs
; may set and clear MP & EM as they please and the settings will be reloaded
; on a context switch (but they will not be saved from CR0 to Cr0NpxState).
; The kernel sets and clears TS as required.
;
; (ebp) = Current CR0
; (edx) = Current CR0

sc_save_npx_state:
        and     edx, NOT (CR0_MP+CR0_EM+CR0_TS) ; we need access to the NPX state

        mov     ecx,[ebx]+PcInitialStack        ; get NPX save save area address

        cmp     ebp, edx                        ; Does CR0 need reloading?
        je      short sc_npx10

        mov     cr0, edx                        ; set new cr0
        mov     ebp, edx                        ; (ebp) = (edx) = current cr0 state

sc_npx10:
;
; The fwait following the fnsave is to make sure that the fnsave has stored the
; data into the save area before this coprocessor state could possibly be
; context switched in and used on a different (co)processor.  I've added the
; clocks from when the dispatcher lock is released and don't believe it's a
; possibility.  I've also timed the impact this fwait seems to have on a 486
; when performing lots of numeric calculations.  It appears as if there is
; nothing to wait for after the fnsave (although the 486 manual says there is)
; and therefore the calculation time far outweighed the 3clk fwait and it
; didn't make a noticable difference.
;

;
; If FXSR feature is NOT present on the processor, the fxsave instruction is
; patched at boot time to start using fnsave instead
;

_ScPatchFxb:
;       fxsave  [ecx]                   ; save NPX state
        db      0FH, 0AEH, 01
_ScPatchFxe:

        mov     byte ptr [edi]+ThNpxState, NPX_STATE_NOT_LOADED ; set no NPX state
        mov     dword ptr [ebx].PcPrcbData+PbNpxThread, 0  ; clear npx owner
        jmp     sc05
endif


;
; This code is out of line to optimize the normal case 
; (which is expected to be the case where tracing is off)
; First we grab the pointer to our flags struct and place it in eax.
; To take advantage of spare cycles while the load is occuring, we 
; prepare for our upcoming funciton call by copying parameters between regs.
; Next we dereference that pointer plus the offset of the flag we need
; to check and bitwise AND that value with our flag.  If the result is
; nonzero, then we make the function call to trace this context swap.
;
; NOTE: The flags struct is a static global.
;
sc92:
        mov     eax, _PPerfGlobalGroupMask      ; Load the ptr into eax
        cmp     eax, 0                          ; catch race here
        jz      sc03
        mov     edx, esi                        ; pass the new ETHREAD object
        mov     ecx, edi                        ; pass the old ETHREAD object
        test    dword ptr [eax+PERF_CONTEXTSWAP_OFFSET], PERF_CONTEXTSWAP_FLAG
        jz      sc03                            ; return if our flag is not set

        fstCall WmiTraceContextSwap             ; call the Wmi context swap trace
        jmp     sc03

.fpo (2, 0, 0, 0, 0, 0)
sc91:   stdCall _KeBugCheck <ATTEMPTED_SWITCH_FROM_DPC>
        ret                             ; return

if DBG
sc_error5:  int 3
sc_error4:  int 3
sc_error3:  int 3
sc_error2:  int 3
sc_error:   int 3
endif

SwapContext     endp

        page , 132
        subttl "Interlocked Swap PTE"

;++
;
; HARDWARE_PTE
; KeInterlockedSwapPte (
;     IN PKI_INTERNAL_PTE PtePointer,
;     IN PKI_INTERNAL_PTE NewPteContents
;     )
;
; Routine Description:
;
;     This function performs an interlocked swap of a PTE.  This is only needed
;     for the PAE architecture where the PTE width is larger than the register
;     width.
;
;     Both PTEs must be valid or a careful write would have been done instead.
;
; Arguments:
;
;     PtePointer - Address of Pte to update with new value.
;
;     NewPteContents - Pointer to the new value to put in the Pte.  Will simply
;         be assigned to *PtePointer, in a fashion correct for the hardware.
;
; Return Value:
;
;     Returns the contents of the PtePointer before the new value
;     is stored.
;
;--

cPublicProc _KeInterlockedSwapPte ,2

    push    ebx
    push    esi

    mov     ebx, [esp] + 16         ; ebx = NewPteContents
    mov     esi, [esp] + 12         ; esi = PtePointer

    mov     ecx, [ebx] + 4
    mov     ebx, [ebx]              ; ecx:ebx = source pte contents

    mov     edx, [esi] + 4
    mov     eax, [esi]              ; edx:eax = target pte contents

swapagain:

    ;
    ; cmpxchg loads edx:eax with the new contents of the target quadword
    ; in the event of failure
    ;

ifndef NT_UP
    lock cmpxchg8b qword ptr [esi]  ; compare and exchange
else
    cmpxchg8b qword ptr [esi]       ; compare and exchange
endif

    jnz     short swapagain         ; if z clear, exchange failed

    pop     esi
    pop     ebx

    stdRET   _KeInterlockedSwapPte
stdENDP _KeInterlockedSwapPte

        page , 132
        subttl "Flush EntireTranslation Buffer"
;++
;
; VOID
; KeFlushCurrentTb (
;     )
;
; Routine Description:
;
;     This function flushes the entire translation buffer (TB) on the current
;     processor and also flushes the data cache if an entry in the translation
;     buffer has become invalid.
;
; Arguments:
;
; Return Value:
;
;     None.
;
;--

cPublicProc _KeFlushCurrentTb ,0

ktb00:  mov     eax, cr3                ; (eax) = directory table base
        mov     cr3, eax                ; flush TLB
        stdRET    _KeFlushCurrentTb

ktb_gb: mov     eax, cr4                ; *** see Ki386EnableGlobalPage ***
        and     eax, not CR4_PGE        ; This FlushCurrentTb version gets copied into
        mov     cr4, eax                ; ktb00 at initialization time if needed.
        or      eax, CR4_PGE
        mov     cr4, eax
ktb_eb: stdRET    _KeFlushCurrentTb

stdENDP _KeFlushCurrentTb
        ;;
        ;; moved KiFlushDcache below KeFlushCurrentTb for BBT purposes.  BBT
        ;; needs an end label to treat KeFlushCurrentTb as data and to keep together.
        ;;
        page , 132
        subttl "Flush Data Cache"
;++
;
; VOID
; KiFlushDcache (
;     )
;
; VOID
; KiFlushIcache (
;     )
;
; Routine Description:
;
;   This routine does nothing on i386 and i486 systems.   Why?  Because
;   (a) their caches are completely transparent,  (b) they don't have
;   instructions to flush their caches.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--

cPublicProc _KiFlushDcache  ,0
cPublicProc _KiFlushIcache  ,0

        stdRET    _KiFlushIcache

stdENDP _KiFlushIcache
stdENDP _KiFlushDcache


_TEXT$00   ends

INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; Ki386EnableGlobalPage (
;     IN volatile PLONG Number
;     )
;
; /*++
;
; Routine Description:
;
;     This routine enables the global page PDE/PTE support in the system,
;     and stalls until complete and them sets the current processor's cr4
;     register to enable global page support.
;
; Arguments:
;
;     Number - Supplies a pointer to the count of the number of processors in
;     the configuration.
;
; Return Value:
;
;     None.
;--

cPublicProc _Ki386EnableGlobalPage,1
        push    esi
        push    edi
        push    ebx

        mov     edx, [esp+16]           ; pointer to Number
        pushfd
        cli

;
; Wait for all processors
;
        lock dec dword ptr [edx]        ; count down
egp10:  YIELD
        cmp     dword ptr [edx], 0      ; wait for all processors to signal
        jnz     short egp10

        cmp     byte ptr PCR[PcNumber], 0 ; processor 0?
        jne     short egp20

;
; Install proper KeFlushCurrentTb function.
;

        mov     edi, ktb00
        mov     esi, ktb_gb
        mov     ecx, ktb_eb - ktb_gb + 1
        rep movsb

        mov     byte ptr [ktb_eb], 0

;
; Wait for P0 to signal that proper flush TB handlers have been installed
;
egp20:  cmp     byte ptr [ktb_eb], 0
        jnz     short egp20

;
; Flush TB, and enable global page support
; (note load of CR4 is explicitly done before the load of CR3
; to work around P6 step B0 errata 11)
;
        mov     eax, cr4
        and     eax, not CR4_PGE        ; should not be set, but let's be safe
        mov     ecx, cr3
        mov     cr4, eax

        mov     cr3, ecx                ; Flush TB

        or      eax, CR4_PGE            ; enable global TBs
        mov     cr4, eax
        popfd
        pop     ebx
        pop     edi
        pop     esi

        stdRET  _Ki386EnableGlobalPage
stdENDP _Ki386EnableGlobalPage

;++
;
; VOID
; Ki386EnableDE (
;     IN volatile PLONG Number
;     )
;
; /*++
;
; Routine Description:
;
;     This routine sets DE bit in CR4 to enable IO breakpoints
;
; Arguments:
;
;     Number - Supplies a pointer to the count of the number of processors in
;     the configuration.
;
; Return Value:
;
;     None.
;--

cPublicProc _Ki386EnableDE,1

        mov     eax, cr4
        or      eax, CR4_DE
        mov     cr4, eax

        stdRET  _Ki386EnableDE
stdENDP _Ki386EnableDE


;++
;
; VOID
; Ki386EnableFxsr (
;     IN volatile PLONG Number
;     )
;
; /*++
;
; Routine Description:
;
;     This routine sets OSFXSR bit in CR4 to indicate that OS supports
;     FXSAVE/FXRSTOR for use during context switches
;
; Arguments:
;
;     Number - Supplies a pointer to the count of the number of processors in
;     the configuration.
;
; Return Value:
;
;     None.
;--

cPublicProc _Ki386EnableFxsr,1

        mov     eax, cr4
        or      eax, CR4_FXSR
        mov     cr4, eax

        stdRET  _Ki386EnableFxsr
stdENDP _Ki386EnableFxsr


;++
;
; VOID
; Ki386EnableXMMIExceptions (
;     IN volatile PLONG Number
;     )
;
; /*++
;
; Routine Description:
;
;     This routine installs int 19 XMMI unmasked Numeric Exception handler
;     and sets OSXMMEXCPT bit in CR4 to indicate that OS supports
;     unmasked Katmai New Instruction technology exceptions.
;
; Arguments:
;
;     Number - Supplies a pointer to count of the number of processors in
;     the configuration.
;
; Return Value:
;
;     None.
;--

cPublicProc _Ki386EnableXMMIExceptions,1


        ;Set up IDT for INT19
        mov     ecx,PCR[PcIdt]              ;Get IDT address
        lea     eax, [ecx] + 098h           ;XMMI exception is int 19
        mov     byte ptr [eax + 5], 08eh    ;P=1,DPL=0,Type=e
        mov     word ptr [eax + 2], KGDT_R0_CODE ;Kernel code selector
        mov     edx, offset FLAT:_KiTrap13  ;Address of int 19 handler
        mov     ecx,edx
        mov     word ptr [eax],cx           ;addr moves into low byte
        shr     ecx,16
        mov     word ptr [eax + 6],cx       ;addr moves into high byte
        ;Enable XMMI exception handling
        mov     eax, cr4
        or      eax, CR4_XMMEXCPT
        mov     cr4, eax

        stdRET  _Ki386EnableXMMIExceptions
stdENDP _Ki386EnableXMMIExceptions


;++
;
; VOID
; Ki386EnableCurrentLargePage (
;     IN ULONG IdentityAddr,
;     IN ULONG IdentityCr3
;     )
;
; /*++
;
; Routine Description:
;
;     This routine enables the large page PDE support in the processor.
;
; Arguments:
;
;     IdentityAddr - Supplies the linear address of the beginning of this
;     function where (linear == physical).
;
;     IdentityCr3 - Supplies a pointer to the temporary page directory and
;     page tables that provide both the kernel (virtual ->physical) and
;     identity (linear->physical) mappings needed for this function.
;
; Return Value:
;
;     None.
;--

public _Ki386EnableCurrentLargePageEnd
cPublicProc _Ki386EnableCurrentLargePage,2
        mov     ecx,[esp]+4             ; (ecx)-> IdentityAddr
        mov     edx,[esp]+8             ; (edx)-> IdentityCr3
        pushfd                          ; save current IF state
        cli                             ; disable interrupts

        mov     eax, cr3                ; (eax)-> original Cr3
        mov     cr3, edx                ; load Cr3 with Identity mapping

        sub     ecx, offset _Ki386EnableCurrentLargePage
        add     ecx, offset _Ki386LargePageIdentityLabel
        jmp     ecx                     ; jump to (linear == physical)

_Ki386LargePageIdentityLabel:
        mov    ecx, cr0
        and    ecx, NOT CR0_PG          ; clear PG bit to disable paging
        mov    cr0, ecx                 ; disable paging
        jmp    $+2
        mov     edx, cr4
        or      edx, CR4_PSE            ; enable Page Size Extensions
        mov     cr4, edx
        mov     edx, offset OriginalMapping
        or      ecx, CR0_PG             ; set PG bit to enable paging
        mov     cr0, ecx                ; enable paging
        jmp     edx                     ; Return to original mapping.

OriginalMapping:
        mov     cr3, eax                ; restore original Cr3
        popfd                           ; restore interrupts to previous

        stdRET  _Ki386EnableCurrentLargePage

_Ki386EnableCurrentLargePageEnd:

stdENDP _Ki386EnableCurrentLargePage

INIT    ends

_TEXT$00   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page , 132
        subttl "Flush Single Translation Buffer"
;++
;
; VOID
; FASTCALL
; KiFlushSingleTb (
;     IN BOOLEAN Invalid,
;     IN PVOID Virtual
;     )
;
; Routine Description:
;
;     This function flushes a single TB entry.
;
;     It only works on a 486 or greater.
;
; Arguments:
;
;     Invalid - Supplies a boolean value that specifies the reason for
;               flushing the translation buffer.
;
;     Virtual - Supplies the virtual address of the single entry that is
;               to be flushed from the translation buffer.
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KiFlushSingleTb ,2

;
; 486 or above code
;
        invlpg  [edx]
        fstRET  KiFlushSingleTb

fstENDP KiFlushSingleTb

        page , 132
        subttl "Swap Process"
;++
;
; VOID
; KiSwapProcess (
;     IN PKPROCESS NewProcess,
;     IN PKPROCESS OldProcess
;     )
;
; Routine Description:
;
;     This function swaps the address space to another process by flushing
;     the data cache, the instruction cache, the translation buffer, and
;     establishes a new directory table base.
;
;     It also swaps in the LDT and IOPM of the new process.  This is necessary
;     to avoid bogus mismatches in SwapContext.
;
;     NOTE: keep in sync with process switch part of SwapContext
;
; Arguments:
;
;     Process - Supplies a pointer to a control object of type process.
;
; Return Value:
;
;     None.
;
;--

cPublicProc _KiSwapProcess  ,2
cPublicFpo 2, 0

ifndef NT_UP

;
; Acquire the context swap lock.
;

        mov     ecx, PCR[PcPrcb]
        lea     ecx, [ecx]+PbLockQueue+(8*LockQueueContextSwapLock)
        fstCall KeAcquireQueuedSpinLockAtDpcLevel

        mov     edx,[esp]+4             ; (edx)-> New process
        mov     eax,[esp]+8             ; (eax)-> Old Process

;
; Clear the processor set member in the old process, set the processor
; member in the new process, and release the context swap lock.
;

        mov     ecx, PCR[PcSetMember]
        xor     [eax]+PrActiveProcessors,ecx ; clear bit in old processor set
        xor     [edx]+PrActiveProcessors,ecx ; set bit in new processor set

if DBG

        test    [eax]+PrActiveProcessors,ecx ; test if bit clear in old set
        jnz     kisp_error              ; if nz, bit not clear in old set
        test    [edx]+PrActiveProcessors,ecx ; test if bit set in new set
        jz      kisp_error1             ; if z, bit not set in new set

endif

        mov     ecx, PCR[PcPrcb]
        lea     ecx, [ecx]+PbLockQueue+(8*LockQueueContextSwapLock)
        fstCall KeReleaseQueuedSpinLockFromDpcLevel

endif

        mov     ecx,PCR[PcTss]          ; (ecx)-> TSS
        mov     edx,[esp]+4             ; (edx)-> New process

;
;   Change address space
;

        xor     eax,eax                         ; assume ldtr is to be NULL
        mov     gs,ax                           ; Clear gs.  (also workarounds
                                                ; P6 step B0 errata 11)
        mov     eax,[edx]+PrDirectoryTableBase
        mov     [ecx]+TssCR3,eax        ; be sure TSS in sync with processor
        mov     cr3,eax

;
;   Change IOPM
;

        mov     ax,[edx]+PrIopmOffset
        mov     [ecx]+TssIoMapBase,ax

;
;   Change LDT
;

        xor     eax, eax
        cmp     word ptr [edx]+PrLdtDescriptor,ax ; limit 0?
        jz      short kisp10                    ; null LDT, go load NULL ldtr

;
;   Edit LDT descriptor
;

        mov     ecx,PCR[PcGdt]
        mov     eax,[edx+PrLdtDescriptor]
        mov     [ecx+KGDT_LDT],eax
        mov     eax,[edx+PrLdtDescriptor+4]
        mov     [ecx+KGDT_LDT+4],eax

;
;   Set up int 21 descriptor of IDT.  If the process does not have Ldt, it
;   should never make any int 21 call.  If it does, an exception is generated.
;   If the process has Ldt, we need to update int21 entry of LDT for the process.
;   Note the Int21Descriptor of the process may simply indicate an invalid
;   entry.  In which case, the int 21 will be trapped to the kernel.
;

        mov     ecx, PCR[PcIdt]
        mov     eax, [edx+PrInt21Descriptor]
        mov     [ecx+21h*8], eax
        mov     eax, [edx+PrInt21Descriptor+4]
        mov     [ecx+21h*8+4], eax

        mov     eax,KGDT_LDT                    ;@@32-bit op to avoid prefix

;
;   Load LDTR
;

kisp10: lldt    ax
        stdRET    _KiSwapProcess

if DBG
kisp_error1: int 3
kisp_error:  int 3
endif

stdENDP _KiSwapProcess

        page ,132
        subttl  "Idle Loop"
;++
;
; VOID
; KiIdleLoop(
;     VOID
;     )
;
; Routine Description:
;
;    This routine continuously executes the idle loop and never returns.
;
; Arguments:
;
;    ebx - Address of the current processor's PCR.
;
; Return value:
;
;    None - routine never returns.
;
;--

cPublicFastCall KiIdleLoop  ,0
cPublicFpo 0, 0

        lea     ebp, [ebx].PcPrcbData.PbDpcListHead ; set DPC listhead address

if DBG

        xor     edi, edi                ; reset poll breakin counter

endif

        jmp     short kid20             ; Skip HalIdleProcessor on first iteration

;
; There are no entries in the DPC list and a thread has not been selected
; for execution on this processor. Call the HAL so power managment can be
; performed.
;
; N.B. The HAL is called with interrupts disabled. The HAL will return
;      with interrupts enabled.
;
; N.B. Use a call instruction instead of a push-jmp, as the call instruction
;      executes faster and won't invalidate the processor's call-return stack
;      cache.
;

kid10:  lea     ecx, [ebx].PcPrcbData.PbPowerState
        call    dword ptr [ecx].PpIdleFunction      ; (ecx) = Arg0

;
; Give the debugger an opportunity to gain control on debug systems.
;
; N.B. On an MP system the lowest numbered idle processor is the only
;      processor that polls for a breakin request.
;

kid20:

if DBG
ifndef NT_UP

        mov     eax, _KiIdleSummary     ; get idle summary
        mov     ecx, [ebx].PcSetMember  ; get set member
        dec     ecx                     ; compute right bit mask
        and     eax, ecx                ; check if any lower bits set
        jnz     short CheckDpcList      ; if nz, not lowest numbered

endif

        dec     edi                     ; decrement poll counter
        jg      short CheckDpcList      ; if g, not time to poll

        POLL_DEBUGGER                   ; check if break in requested
endif

kid30:

if DBG
ifndef NT_UP

        mov     edi, 20 * 1000          ; set breakin poll interval

else

        mov     edi, 100                ; UP idle loop has a HLT in it

endif
endif

CheckDpcList0:
        YIELD

;
; Disable interrupts and check if there is any work in the DPC list
; of the current processor or a target processor.
;

CheckDpcList:

;
; N.B. The following code enables interrupts for a few cycles, then
;      disables them again for the subsequent DPC and next thread
;      checks.
;

        sti                             ; enable interrupts
        nop                             ;
        nop                             ;
        cli                             ; disable interrupts

;
; Process the deferred procedure call list for the current processor.
;

        cmp     ebp, [ebp].LsFlink      ; check if DPC list is empty
        je      short CheckNextThread   ; if eq, DPC list is empty
        mov     cl, DISPATCH_LEVEL      ; set interrupt level
        fstCall HalClearSoftwareInterrupt ; clear software interrupt
        CAPSTART <@KiIdleLoop@0,KiRetireDpcList>
        call    KiRetireDpcList         ; process the current DPC list
        CAPEND   <@KiIdleLoop@0>

if DBG

        xor     edi, edi                ; clear breakin poll interval

endif

;
; Check if a thread has been selected to run on the current processor.
;

CheckNextThread:                        ;
        cmp     dword ptr [ebx].PcPrcbData.PbNextThread, 0 ; thread selected?
        je      short kid10             ; if eq, no thread selected

ifndef NT_UP

;
; A thread has been selected for execution on this processor. Acquire
; the dispatcher database lock, get the thread address again (it may have
; changed), clear the address of the next thread in the processor block,
; and call swap context to start execution of the selected thread.
;
; N.B. If the dispatcher database lock cannot be obtained immediately,
;      then attempt to process another DPC rather than spinning on the
;      dispatcher database lock.
; N.B. On MP systems, the dispatcher database is always locked at
; SYNCH level to ensure the lock is held for as short a period as
; possible (reduce contention).  On UP systems there really is no
; lock, it is sufficient to be at DISPATCH level (which is the
; current level at this point in the code).

;
; Raise IRQL to synchronization level and enable interrupts.
;

        mov     ecx, SYNCH_LEVEL        ; raise IRQL to synchronization level
        fstCall KfRaiseIrql             ;

endif

        sti                             ; enable interrupts

ifndef NT_UP

;
; Acquire the context swap lock, this must be done with interrupts 
; enabled to avoid deadlocks with processors that receive IPIs while
; holding the dispatcher lock.
;
; N.B. KeAcquireQueuedSpinLockAtDpcLevel doesn't touch IRQL, it
; is OK that we are at SYNCH level at this time.

        lea     ecx, [ebx]+PcPrcbData+PbLockQueue+(8*LockQueueContextSwapLock)
        fstCall KeAcquireQueuedSpinLockAtDpcLevel

endif

kidsw:  mov     esi, [ebx].PcPrcbData.PbNextThread    ; get next thread address
        mov     edi, [ebx].PcPrcbData.PbCurrentThread ; get current thread address
ifndef NT_UP
        cmp     byte ptr [esi].ThIdleSwapBlock, 0
        jne     short kidndl

;
; If a thread had been scheduled for this processor but was removed from
; from eligibility (eg AffinitySet to not include this processor), then 
; the NextThread could be the idle thread and this processor is marked
; as idle (again).   In this case, the scheduler may assign another thread
; to this processor in the window between reading the NextThread field
; above, and zeroing it below.
;
; Detection of this condition is done here because this processor is not
; otherwise busy.
;

        cmp     esi, edi
        je      short kisame

endif
        or      ecx, 1                                ; set APC disable
        mov     [ebx].PcPrcbData.PbCurrentThread, esi

;
; Other processors might be examining the Prcb->CurrentThread entry
; for this processor while holding the dispatcher database lock
; which is not held here.   However, they always check the NextThread
; field first and if non NULL will acquire the context swap lock.
; Setting the CurrentThread field before clearing the NextThread 
; field assures correct locking semantics.
;

        mov     byte  ptr es:[esi]+ThState, Running ; set thread state running
        mov     dword ptr [ebx].PcPrcbData.PbNextThread, 0

        CAPSTART <@KiIdleLoop@0,SwapContext>

;
; Set the stack as though code from SwapContext thru SwapContextFromIdle
; had been executed.
;

        push    FLAT:@f                             ; set return address
        pushfd                                      ; set saved flags
        jmp     SwapContextFromIdle
@@:

        CAPEND   <@KiIdleLoop@0>

ifndef NT_UP
        mov     ecx, DISPATCH_LEVEL     ; lower IRQL to dispatch level
        fstCall KfLowerIrql             ;
endif

        lea     ebp, [ebx].PcPrcbData.PbDpcListHead ; set DPC listhead address
        jmp     kid30                   ;

ifndef NT_UP

;
; The new thread is still on another processor and cannot be switched to
; yet.   Drop the context swap lock and take another pass around the idle
; loop.
;

kidndl: lea     ecx, [ebx]+PcPrcbData+PbLockQueue+(8*LockQueueContextSwapLock)
@@:     fstCall KeReleaseQueuedSpinLockFromDpcLevel

        mov     ecx, DISPATCH_LEVEL     ; lower IRQL to dispatch level
        fstCall KfLowerIrql             ;

        lea     ebp, [ebx].PcPrcbData.PbDpcListHead ; set DPC listhead address
        jmp     kid30                   ;

;
; The new thread is the Idle thread (same as old thread).   This can happen
; rarely when a thread scheduled for this processor is made unable to run
; on this processor.   As this processor has again been marked idle, other
; processors may unconditionally assign new threads to this processor.
;
; Acquire the dispatcher database lock to protect against this condition.
;

kisame: lea     ecx, [ebx]+PcPrcbData+PbLockQueue+(8*LockQueueContextSwapLock)
        fstCall KeReleaseQueuedSpinLockFromDpcLevel

        lea     ecx, [ebx]+PcPrcbData+PbLockQueue+(8*LockQueueDispatcherLock)
        fstCall KeAcquireQueuedSpinLockAtDpcLevel

;
; At this time, the NextThread field may have changed, if not, it is safe
; to clear it under the protection of the dispatcher lock.   If it has
; changed, don't clear it.
;

        cmp     esi, [ebx].PcPrcbData.PbNextThread
        jne     short @b
        mov     dword ptr [ebx].PcPrcbData.PbNextThread, 0

;
; Release the dispatcher database lock and continue executing the idle
; loop. N.B. ecx still contains the address of the dispatcher database
; lock.
;
        jmp     short @b

endif

fstENDP KiIdleLoop

        page ,132
        subttl  "Retire Deferred Procedure Call List"
;++
;
; Routine Description:
;
;    This routine is called to retire the specified deferred procedure
;    call list. DPC routines are called using the idle thread (current)
;    stack.
;
;    N.B. Interrupts must be disabled and the DPC list lock held on entry
;         to this routine. Control is returned to the caller with the same
;         conditions true.
;
;    N.B. The registers ebx and ebp are preserved across the call.
;
; Arguments:
;
;    ebx - Address of the target processor PCR.
;    ebp - Address of the target DPC listhead.
;
; Return value:
;
;    None.
;
;--

if DBG
LOCAL_OFFSET     equ  4
else
LOCAL_OFFSET     equ  0
endif

        public  KiRetireDpcList
KiRetireDpcList proc


?FpoValue = 0

ifndef NT_UP

?FpoValue = 1
        push    esi                     ; save register
        lea     esi, [ebx].PcPrcbData.PbDpcLock ; get DPC lock address

endif

        push    0                       ; Used to indicate whether DPC event logging is on or off
        sub     esp, 12                 ; space for saved DPC address and timestamp

        cmp     _PPerfGlobalGroupMask, 0 ; Is event tracing on?
        jne     rdl70                   ; go check if DPC tracing is on
rdl3:

FPOFRAME ?FpoValue,0

rdl5:   mov     PCR[PcPrcbData.PbDpcRoutineActive], esp ; set DPC routine active


;
; Process the DPC List.
;


rdl10:                                  ;

ifndef NT_UP

        ACQUIRE_SPINLOCK esi, rdl50, NoChecking ; acquire DPC lock
        cmp     ebp, [ebp].LsFlink      ; check if DPC list is empty
        je      rdl45                   ; if eq, DPC list is empty

endif

        mov     edx, [ebp].LsFlink      ; get address of next entry
        mov     ecx, [edx].LsFlink      ; get address of next entry
        mov     [ebp].LsFlink, ecx      ; set address of next in header
        mov     [ecx].LsBlink, ebp      ; set address of previous in next
        sub     edx, DpDpcListEntry     ; compute address of DPC object
        mov     ecx, [edx].DpDeferredRoutine ; get DPC routine address
if DBG

        push    edi                     ; save register
        mov     edi, esp                ; save current stack pointer

endif


FPOFRAME ?FpoValue,0

        push    [edx].DpSystemArgument2 ; second system argument
        push    [edx].DpSystemArgument1 ; first system argument
        push    [edx].DpDeferredContext ; get deferred context argument
        push    edx                     ; address of DPC object
        mov     dword ptr [edx]+DpLock, 0 ; clear DPC inserted state
        dec     dword ptr [ebx].PcPrcbData.PbDpcQueueDepth ; decrement depth
if DBG
        mov     PCR[PcPrcbData.PbDebugDpcTime], 0 ; Reset the time in DPC
endif

ifndef NT_UP

        RELEASE_SPINLOCK esi, NoChecking ; release DPC lock

endif

        sti                             ; enable interrupts

        cmp     [esp+LOCAL_OFFSET+28], 0 ; Are we doing event tracing?
        jne     rdl80
rdl20:

        CAPSTART <KiRetireDpcList,ecx>
        call    ecx                     ; call DPC routine
        CAPEND   <KiRetireDpcList>

        cmp     [esp+LOCAL_OFFSET+12], 0 ; Are we doing event tracing?
        jne     rdl90
rdl25:

if DBG

        stdCall _KeGetCurrentIrql       ; get current IRQL
        cmp     al, DISPATCH_LEVEL      ; check if still at dispatch level
        jne     rdl55                   ; if ne, not at dispatch level
        cmp     esp, edi                ; check if stack pointer is correct
        jne     rdl60                   ; if ne, stack pointer is not correct
rdl30:  pop     edi                     ; restore register

endif

FPOFRAME ?FpoValue,0

rdl35:  cli                             ; disable interrupts
        cmp     ebp, [ebp].LsFlink      ; check if DPC list is empty
        jne     rdl10                   ; if ne, DPC list not empty

;
; Clear DPC routine active and DPC requested flags.
;

rdl40:  mov     [ebx].PcPrcbData.PbDpcRoutineActive, 0
        mov     [ebx].PcPrcbData.PbDpcInterruptRequested, 0

;
; Check one last time that the DPC list is empty. This is required to
; close a race condition with the DPC queuing code where it appears that
; a DPC routine is active (and thus an interrupt is not requested), but
; this code has decided the DPC list is empty and is clearing the DPC
; active flag.
;

        cmp     ebp, [ebp].LsFlink      ; check if DPC list is empty
        jne     rdl5                    ; if ne, DPC list not empty

        add     esp, 16                 ; pop locals

ifndef NT_UP

        pop     esi                     ; retore register

endif
        ret                             ; return

;
; Unlock DPC list and clear DPC active.
;

rdl45:                                  ;

ifndef NT_UP

        RELEASE_SPINLOCK esi, NoChecking ; release DPC lock
        jmp     short rdl40             ;

endif

ifndef NT_UP

rdl50:  sti                             ; enable interrupts
        SPIN_ON_SPINLOCK esi, <short rdl35> ; spin until lock is freee

endif


if DBG

rdl55:  stdCall _KeBugCheckEx, <IRQL_NOT_GREATER_OR_EQUAL, ebx, eax, 0, 0> ;

rdl60:  push    dword ptr [edi+12]      ; push address of DPC function
        push    offset FLAT:_MsgDpcTrashedEsp ; push message address
        call    _DbgPrint               ; print debug message
        add     esp, 8                  ; remove arguments from stack
        int     3                       ; break into debugger
        mov     esp, edi                ; reset stack pointer
        jmp     rdl30                   ;

endif

;
; Check if logging is on.  If so, set logical on stack.
;
rdl70:
        mov     eax, _PPerfGlobalGroupMask ; Load the ptr into eax
        cmp     eax, 0
        jz      rdl3
        test    dword ptr [eax+PERF_DPC_OFFSET], PERF_DPC_FLAG
        jz      rdl3                    ; return if our flag is not set
        
        mov     [esp+12], 1             ; indicate DPC logging is on
        jmp     rdl3

;
; If logging DPC info, grab a timestamp to calculate the time in
; the service routine.
;
rdl80:
        push    ecx                     ; save DpcRoutine
        PERF_GET_TIMESTAMP              ; Places 64bit in edx:eax and trashes ecx
        pop     ecx

        mov     [esp+LOCAL_OFFSET+16], eax
        mov     [esp+LOCAL_OFFSET+20], edx
        mov     edx, [esp]
        mov     [esp+LOCAL_OFFSET+24], ecx ; Saves the service routine address

        jmp     rdl20


;
; Log the service routine and inital timestamp
;
rdl90:
        mov     eax, [esp+LOCAL_OFFSET]         ; pass the initial time
        mov     edx, [esp+LOCAL_OFFSET+4]
        push    edx
        push    eax  
        mov     ecx, [esp+LOCAL_OFFSET+16]      ; load saved service routine address
        fstCall PerfInfoLogDpc
        
        jmp     rdl25
        
KiRetireDpcList endp

ifdef DBGMP
cPublicProc _KiPollDebugger,0
cPublicFpo 0,3
        push    eax
        push    ecx
        push    edx
        POLL_DEBUGGER
        pop     edx
        pop     ecx
        pop     eax
        stdRET    _KiPollDebugger
stdENDP _KiPollDebugger

endif

        page , 132
        subttl "Adjust TSS ESP0 value"
;++
;
; VOID
; KiAdjustEsp0 (
;     IN PKTRAP_FRAME TrapFrame
;     )
;
; Routine Description:
;
;     This routine puts the apropriate ESP0 value in the esp0 field of the
;     TSS.  This allows protect mode and V86 mode to use the same stack
;     frame.  The ESP0 value for protected mode is 16 bytes lower than
;     for V86 mode to compensate for the missing segment registers.
;
; Arguments:
;
;     TrapFrame - Supplies a pointer to the TrapFrame.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _Ki386AdjustEsp0 ,1

        stdCall ___KeGetCurrentThread

        mov     edx,[esp + 4]                   ; edx -> trap frame
        mov     eax,[eax]+thInitialStack        ; eax = base of stack
        test    dword ptr [edx]+TsEFlags,EFLAGS_V86_MASK  ; is this a V86 frame?
        jnz     short ae10

        sub     eax,TsV86Gs - TsHardwareSegSS   ; compensate for missing regs
ae10:   sub     eax,NPX_FRAME_LENGTH
        pushfd                                  ; Make sure we don't move
        cli                                     ; processors while we do this
        mov     edx,PCR[PcTss]
        mov     [edx]+TssEsp0,eax               ; set Esp0 value
        popfd
        stdRET    _Ki386AdjustEsp0

stdENDP _Ki386AdjustEsp0


_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\emv86.asm ===
title  "Vdm Instuction Emulation"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    emv86.asm
;
; Abstract:
;
;    This module contains the routines for emulating instructions and
;    faults from v86 mode.
;
; Author:
;
;   sudeep bharati (sudeepb) 16-Nov-1992
;
; Environment:
;
;    Kernel mode only.
;
; Notes:
;
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include mac386.inc
include i386\mi.inc
include callconv.inc
include ..\..\vdm\i386\vdm.inc
include vdmtib.inc
        .list

        extrn   VdmOpcode0f:proc
        extrn   _DbgPrint:proc
        extrn   _KeI386VdmIoplAllowed:dword
        extrn   _KeI386VirtualIntExtensions:dword
        EXTRNP  _Ki386VdmDispatchIo,5
        EXTRNP  _Ki386VdmDispatchStringIo,8
        EXTRNP  _KiDispatchException,5
        EXTRNP  _Ki386VdmReflectException,1
        EXTRNP  _VdmEndExecution,2
        EXTRNP  _VdmDispatchBop,1
        EXTRNP  _VdmPrinterStatus,3
        EXTRNP  _VdmPrinterWriteData, 3
        EXTRNP  _VdmDispatchInterrupts,2
        EXTRNP  _KeBugCheck,1
        EXTRNP  _VdmSkipNpxInstruction,4
        EXTRNP  _VdmFetchBop1,1

ifdef VDMDBG
        EXTRNP  _VdmTraceEvent,4
endif

        extrn   _ExVdmOpcodeDispatchCounts:dword
        extrn   OpcodeIndex:byte
        extrn   _VdmUserCr0MapIn:byte

        extrn   _MmUserProbeAddress:DWORD


        page ,132

ifdef VDMDBG
%out Debugging version
endif

;   Force assume into place

_PAGE   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_PAGE   ENDS

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_TEXT$00   ENDS

PAGEDATA   SEGMENT  DWORD PUBLIC 'DATA'

;
;  Instruction emulation emulates the following instructions.
;  The emulation affects the noted user mode registers.
;
;
;  In V86 mode, the following instruction are emulated in the kernel
;
;    Registers  (E)Flags (E)SP  SS  CS
;       PUSHF      X       X
;       POPF       X       X
;       INTnn      X       X         X
;       INTO       X       X         X
;       IRET       X       X         X
;       CLI        X
;       STI        X
;
;
;       INSB
;       INSW
;       OUTSB
;       OUTSW
;       INBimm
;       INWimm
;       OUTBimm
;       OUTWimm
;       INB
;       INW
;       OUTB
;       OUTW
;
;  WARNING What do we do about 32 bit io instructions??


;       OpcodeDispatchV86 - table of routines used to emulate instructions
;                           in v86 mode.

        public OpcodeDispatchV86
dtBEGIN OpcodeDispatchV86,OpcodeInvalidV86
        dtS    VDM_INDEX_0F              , Opcode0FV86
        dtS    VDM_INDEX_ESPrefix        , OpcodeESPrefixV86
        dtS    VDM_INDEX_CSPrefix        , OpcodeCSPrefixV86
        dtS    VDM_INDEX_SSPrefix        , OpcodeSSPrefixV86
        dtS    VDM_INDEX_DSPrefix        , OpcodeDSPrefixV86
        dtS    VDM_INDEX_FSPrefix        , OpcodeFSPrefixV86
        dtS    VDM_INDEX_GSPrefix        , OpcodeGSPrefixV86
        dtS    VDM_INDEX_OPER32Prefix    , OpcodeOPER32PrefixV86
        dtS    VDM_INDEX_ADDR32Prefix    , OpcodeADDR32PrefixV86
        dtS    VDM_INDEX_INSB            , OpcodeINSBV86
        dtS    VDM_INDEX_INSW            , OpcodeINSWV86
        dtS    VDM_INDEX_OUTSB           , OpcodeOUTSBV86
        dtS    VDM_INDEX_OUTSW           , OpcodeOUTSWV86
        dtS    VDM_INDEX_PUSHF           , OpcodePUSHFV86
        dtS    VDM_INDEX_POPF            , OpcodePOPFV86
        dtS    VDM_INDEX_INTnn           , OpcodeINTnnV86
        dtS    VDM_INDEX_INTO            , OpcodeINTOV86
        dtS    VDM_INDEX_IRET            , OpcodeIRETV86
        dts    VDM_INDEX_NPX             , OpcodeNPXV86
        dtS    VDM_INDEX_INBimm          , OpcodeINBimmV86
        dtS    VDM_INDEX_INWimm          , OpcodeINWimmV86
        dtS    VDM_INDEX_OUTBimm         , OpcodeOUTBimmV86
        dtS    VDM_INDEX_OUTWimm         , OpcodeOUTWimmV86
        dtS    VDM_INDEX_INB             , OpcodeINBV86
        dtS    VDM_INDEX_INW             , OpcodeINWV86
        dtS    VDM_INDEX_OUTB            , OpcodeOUTBV86
        dtS    VDM_INDEX_OUTW            , OpcodeOUTWV86
        dtS    VDM_INDEX_LOCKPrefix      , OpcodeLOCKPrefixV86
        dtS    VDM_INDEX_REPNEPrefix     , OpcodeREPNEPrefixV86
        dtS    VDM_INDEX_REPPrefix       , OpcodeREPPrefixV86
        dtS    VDM_INDEX_CLI             , OpcodeCLIV86
        dtS    VDM_INDEX_STI             , OpcodeSTIV86
        dtS    VDM_INDEX_HLT             , OpcodeHLTV86
dtEND   MAX_VDM_INDEX

PAGEDATA   ENDS

_PAGE   SEGMENT DWORD USE32 PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        page   ,132
        subttl "Overide Prefix Macro"
;++
;
;   Routine Description:
;
;       This macro generates the code for handling override prefixes
;       The routine name generated is OpcodeXXXXPrefix, where XXXX is
;       the name used in the macro invocation.  The code will set the
;       PREFIX_XXXX bit in the Prefix flags.
;
;   Arguments
;       name = name of prefix
;       esi = address of reg info
;       edx = opcode
;
;   Returns
;       user mode Eip advanced
;       eax advanced
;       edx contains next byte of opcode
;
;   NOTE: This routine exits by dispatching through the table again.
;--
opPrefix macro name
        public Opcode&name&PrefixV86
Opcode&name&PrefixV86 proc

        or      ebx,PREFIX_&name


ifdef VDMDBG
_DATA segment
Msg&name&Prefix db 'NTVDM: Encountered override prefix &name& %lx at '
                db 'address %lx', 0ah, 0dh, 0
_DATA ends

        push    [ebp].TsEip
        push    [ebp].TsSegCs
        push    offset FLAT:Msg&name&Prefix
        call    _DbgPrint
        add     esp,12

endif

        jmp     OpcodeGenericPrefixV86   ; dispatch to next handler

Opcode&name&PrefixV86 endp
endm

irp prefix, <ES, CS, SS, DS, FS, GS, OPER32, ADDR32, LOCK, REPNE, REP>

        opPrefix prefix

endm

        page   ,132
        subttl "Instruction Emulation Dispatcher for V86"
;++
;
;   Routine Description:
;
;       This routine dispatches to the opcode specific emulation routine,
;       based on the first byte of the opcode.  Two byte opcodes, and prefixes
;       result in another level of dispatching, from the handling routine.
;       This code is called at APC_LEVEL to prevent modifications to the
;       trap frame from NtSetContextThread.
;
;   Arguments:
;
;       [esp+4] = pointer to trap frame
;
;   Returns:
;
;       EAX = 0 failure
;             1 success

cPublicProc _Ki386DispatchOpcodeV86,1

        push	ebp
        mov     ebp, [esp+8]
        movzx   esi,word ptr [ebp].TsSegCs
        shl     esi,4
        and     dword ptr [ebp].TsEip, 0FFFFH
        and     dword ptr [ebp].TsHardwareEsp, 0FFFFH
        add     esi,[ebp].TsEip
        ;
        ; Probe and fetch the first byte from the instruction stream.
        ; Since we should be at APC_LEVEL here the trap frame can't be
        ; modified by the set context code. We don't have to capture.
        ;
        stdCall _VdmFetchBop1, <esi>
        movzx   edx, OpcodeIndex[eax]   ;get opcode index

        mov     edi,1
        xor     ebx,ebx

        ; All handler routines will get the following on entry
        ; ebx -> prefix flags
        ; ebp -> trap frame
        ; cl  -> byte at the faulting address
        ; interrupts enabled and Irql at APC level
        ; esi -> address of faulting instruction
        ; edi -> instruction length count
        ; All handler routines return
        ; EAX = 0 for failure
        ; EAX = 1 for success

if DEVL
        inc     _ExVdmOpcodeDispatchCounts[edx * type _ExVdmOpcodeDispatchCounts]
endif
ifdef VDMDBG
        pushad
        stdCall _VdmTraceEvent, <VDMTR_KERNEL_OP_V86,ecx,0,ebp>
        popad
endif
        call	dword ptr OpcodeDispatchV86[edx * type OpcodeDispatchV86]
        pop	ebp
        stdRet	_Ki386DispatchOpcodeV86

stdENDP _Ki386DispatchOpcodeV86


        page   ,132
        subttl "Invalid Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an invalid opcode.  It prints the invalid
;       opcode message, and causes a GP fault to be reflected to the
;       debuger
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeInvalidV86
OpcodeInvalidV86 proc

        xor     eax,eax                 ; ret fail
        ret

OpcodeInvalidV86 endp


        page   ,132
        subttl "Generic Prefix Handler"
;++
;
;   Routine Description:
;
;       This routine handles the generic portion of all of the prefixes,
;       and dispatches the next byte of the opcode.
;
;   Arguments:
;
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeGenericPrefixV86
OpcodeGenericPrefixV86 proc

        inc     esi
        inc     edi
        movzx   ecx, byte ptr [esi]
        movzx   edx, OpcodeIndex[ecx]   ;get opcode index
if DEVL
        inc     _ExVdmOpcodeDispatchCounts[edx * type _ExVdmOpcodeDispatchCounts]
endif
        jmp     OpcodeDispatchV86[edx * type OpcodeDispatchV86]

OpcodeGenericPrefixV86 endp


        page   ,132
        subttl "Byte string in Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INSB opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;  WARNING size override?  ds override?

        public OpcodeINSBV86
OpcodeINSBV86 proc

        push    ebp                     ; trap frame
        push    edi                     ; size of insb
        movzx   eax,word ptr [ebp].TsV86Es
        shl     eax,16
        movzx   ecx,word ptr [ebp].TsEdi
        or      eax,ecx
        push    eax                     ; address
        mov     eax,1
        xor     ecx, ecx
        test    ebx,PREFIX_REP          ; prefixREP
        jz      oisb20

        mov     ecx, 1
        movzx   eax,word ptr [ebp].TsEcx
oisb20:
        push    eax                     ; number of io ops
        push    TRUE                    ; read op
        push    ecx                     ; REP prefix ?
        push    1                       ; byte op
        movzx   eax,word ptr [ebp].TsEdx
        push    eax                     ; port number

        ; Ki386VdmDispatchStringIo enables interrupts
IFDEF STD_CALL
        call    _Ki386VdmDispatchStringIo@32 ; use retval
ELSE
        call    _Ki386VdmDispatchStringIo ; use retval
        add     esp,24
ENDIF
        ret

OpcodeINSBV86 endp

        page   ,132
        subttl "Word String In Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INSW opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeINSWV86
OpcodeINSWV86 proc

        push    ebp                     ; trap frame
        push    edi                     ; size of insw
        movzx   eax,word ptr [ebp].TsV86Es
        shl     eax,16
        movzx   ecx,word ptr [ebp].TsEdi
        or      eax,ecx
        push    eax                     ; address
        mov     eax,1
        xor     ecx, ecx
        test    ebx,PREFIX_REP          ; prefixREP
        jz      oisw20

        mov     ecx, 1
        movzx   eax,word ptr [ebp].TsEcx
oisw20:
        push    eax                     ; number of io ops
        push    TRUE                    ; read op
        push    ecx                     ; REP prefix ?
        push    2                       ; word op
        movzx   eax,word ptr [ebp].TsEdx
        push    eax                     ; port number

        ; Ki386VdmDispatchStringIo enables interrupts
IFDEF STD_CALL
        call    _Ki386VdmDispatchStringIo@32 ; use retval
ELSE
        call    _Ki386VdmDispatchStringIo ; use retval
        add     esp,24
ENDIF
        ret

OpcodeINSWV86 endp

        page   ,132
        subttl "Byte String Out Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTSB opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeOUTSBV86
OpcodeOUTSBV86 proc

        push    ebp                     ; trap frame
        push    edi                     ; size of outsb
        movzx   eax,word ptr [ebp].TsV86Ds
        shl     eax,16
        movzx   ecx,word ptr [ebp].TsEsi
        or      eax,ecx
        push    eax                     ; address
        mov     eax,1
        xor     ecx, ecx
        test    ebx,PREFIX_REP          ; prefixREP
        jz      oosb20

        mov     ecx, 1
        movzx   eax,word ptr [ebp].TsEcx
oosb20:
        push    eax                     ; number of io ops
        push    FALSE                   ; write op
        push    ecx                     ; REP prefix ?
        push    1                       ; byte op
        movzx   eax,word ptr [ebp].TsEdx
        push    eax                     ; port number

        ; Ki386VdmDispatchStringIo enables interrupts
IFDEF STD_CALL
        call    _Ki386VdmDispatchStringIo@32 ; use retval
ELSE
        call    _Ki386VdmDispatchStringIo ; use retval
        add     esp,24
ENDIF
        ret

OpcodeOUTSBV86 endp

        page   ,132
        subttl "Word String Out Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTSW opcode.  Currently, it prints
;       a message, and ignores the instruction
;
;   Arguments:
;
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeOUTSWV86
OpcodeOUTSWV86 proc

        push    ebp                     ; trap frame
        push    edi                     ; size of outsw
        movzx   eax,word ptr [ebp].TsV86Ds
        shl     eax,16
        movzx   ecx,word ptr [ebp].TsEsi
        or      eax,ecx
        push    eax                     ; address

        mov     eax,1
        xor     ecx, ecx
        test    ebx,PREFIX_REP          ; prefixREP
        jz      oosw20

        mov     ecx, 1
        movzx   eax,word ptr [ebp].TsEcx
oosw20:
        push    eax                     ; number of io ops
        push    FALSE                   ; write op
        push    ecx                     ; REP prefix ?
        push    2                       ; word op
        movzx   eax,word ptr [ebp].TsEdx
        push    eax                     ; port number

        ; Ki386VdmDispatchStringIo enables interrupts
IFDEF STD_CALL
        call    _Ki386VdmDispatchStringIo@32 ; use retval
ELSE
        call    _Ki386VdmDispatchStringIo ; use retval
        add     esp,24
ENDIF
        ret

OpcodeOUTSWV86 endp

        page   ,132
        subttl "PUSHF Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an PUSHF opcode.  Currently, it prints
;       a message, and simulates the instruction.
;
;       Get SS
;       shift left 4
;       get SP
;       subtract 2
;       get flags
;       put in virtual interrupt flag
;       put on stack
;       update sp
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
        public OpcodePUSHFV86
OpcodePUSHFV86 proc

        test    _KeI386VirtualIntExtensions, dword ptr V86_VIRTUAL_INT_EXTENSIONS
        jz      short puf00

        mov     eax,dword ptr [ebp].TsEFlags

        lea     ecx,ds:FIXED_NTVDMSTATE_LINEAR

        or      dword ptr [ecx], VDM_VIRTUAL_INTERRUPTS

        test    eax, EFLAGS_VIF         ; Is vif on
        jnz     short puf03

        and     dword ptr [ecx], NOT VDM_VIRTUAL_INTERRUPTS
        and     eax, NOT EFLAGS_INTERRUPT_MASK
        jmp     short puf03

puf00:
        lea     eax,ds:FIXED_NTVDMSTATE_LINEAR

        mov     edx,dword ptr [ebp].TsEFlags
        mov     eax, dword ptr [eax]         ; get virtual int flag
        and     edx,NOT EFLAGS_INTERRUPT_MASK
        and     eax,VDM_VIRTUAL_INTERRUPTS OR VDM_VIRTUAL_AC OR VDM_VIRTUAL_NT
        or      eax,edx
        or      eax,EFLAGS_IOPL_MASK
puf03:
        movzx   ecx,word ptr [ebp].TsHardwareSegSS
        movzx   edx,word ptr [ebp].TsHardwareEsp
        shl     ecx,4
        sub     dx,2

        test    ebx,PREFIX_OPER32               ; check operand size
        jnz     puf10

        mov     [ecx + edx],ax
puf05:
        mov     word ptr [ebp].TsHardwareEsp,dx ; update client esp
        add     dword ptr [ebp].TsEip,edi

        mov     eax, ds:FIXED_NTVDMSTATE_LINEAR
        test    eax, VDM_VIRTUAL_INTERRUPTS
        jz      short @f

        test    eax, VDM_INTERRUPT_PENDING
        jz      short @f

        call    VdmDispatchIntAck
@@:
        mov     eax,1
        ret

puf10:  sub     dx,2
        mov     [ecx + edx],eax
        jmp     puf05

OpcodePUSHFV86 endp

        page   ,132
        subttl "POPF Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an POPF opcode.  Currently, it prints
;       a message, and returns to the monitor.
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodePOPFV86
OpcodePOPFV86 proc

        lea     eax,ds:FIXED_NTVDMSTATE_LINEAR      ; get pointer to VDM State
        mov     ecx,[ebp].TsHardwareSegSS
        movzx   edx,word ptr [ebp].TsHardwareEsp
        shl     ecx,4
        mov     ecx,[ecx + edx]          ; get flags from stack => ecx
        add     edx,4
        test    ebx,PREFIX_OPER32        ; check operand size
        jnz     pof10
        and     ecx,0ffffh               ; only lower 16 bit for 16bit code
        sub     edx,2
pof10:
        mov     [ebp].TsHardwareEsp,edx

        and     ecx, NOT EFLAGS_IOPL_MASK
        mov     ebx,ecx                  ; [ebx]=[ecx]=user EFLAGS - IOPL
        and     ebx, NOT EFLAGS_NT_MASK  ; [ebx]=user eflags - iopl - NT
        and     ecx, (EFLAGS_INTERRUPT_MASK OR EFLAGS_ALIGN_CHECK OR EFLAGS_NT_MASK)

        ; [ecx]=IF + AC + NT of User eflgs
        ; [ebx]=User eflgs - IOPL - NT

        test    _KeI386VirtualIntExtensions, dword ptr V86_VIRTUAL_INT_EXTENSIONS
        jz      short pof15

        and     ebx, NOT (EFLAGS_VIP + EFLAGS_VIF)
                                         ; [ebx]=UserFlg -IOPL - NT - VIP - VIF
        test    ebx, EFLAGS_INTERRUPT_MASK
        jz      short @f

        or      ebx, EFLAGS_VIF          ; [ebx]=UserFlg-IOPL-NT-VIP+VIF
@@:
        or      ebx, (EFLAGS_INTERRUPT_MASK OR EFLAGS_V86_MASK) ;[ebx]=UserFlg-IOPL-NT-VIP+VIF+IF
        and     dword ptr [ebp].TsEFlags, EFLAGS_VIP
        or      [ebp].TsEFlags,ebx
        jmp     short pof20

pof15:
        or      ebx, (EFLAGS_INTERRUPT_MASK OR EFLAGS_V86_MASK)
        mov     [ebp].TsEFlags, ebx
pof20:
        MPLOCK and [eax],NOT (EFLAGS_INTERRUPT_MASK OR EFLAGS_ALIGN_CHECK OR EFLAGS_NT_MASK)
        MPLOCK or [eax],ecx
        add     dword ptr [ebp].TsEip,edi

        mov     eax,dword ptr [eax]
        test    eax,VDM_INTERRUPT_PENDING
        jz      pof25

        test    eax,VDM_VIRTUAL_INTERRUPTS
        jz      pof25

        call    VdmDispatchIntAck

pof25:
        mov     eax,1                    ; handled
        ret
OpcodePOPFV86 endp

        page   ,132
        subttl "INTnn Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INTnn opcode.  It retrieves the handler
;       from the IVT, pushes the current cs:ip and flags on the stack,
;       and dispatches to the handler.
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeINTnnV86
OpcodeINTnnV86 proc

;
; Int nn in v86 mode always disables interrupts
;

        mov     edx,[ebp].TsEflags
;
; If KeI386VdmIoplAllowed is true, direct IF manipulation is allowed
;
        test    _KeI386VdmIoplAllowed,1
        jz      oinnv10

        mov     eax,edx                      ; save original flags
        and     edx,NOT EFLAGS_INTERRUPT_MASK
        jmp     oinnv20

;
; Else, IF and some other flags bits are virtualized
;
oinnv10:
        lea     eax,ds:FIXED_NTVDMSTATE_LINEAR   ; get pointer to VDM State
        mov     ecx,dword ptr [eax]       ;[ecx]=vdmstate
        MPLOCK and [eax],NOT VDM_VIRTUAL_INTERRUPTS

        mov     eax, edx
        and     eax, NOT EFLAGS_INTERRUPT_MASK
.errnz (EFLAGS_INTERRUPT_MASK - VDM_VIRTUAL_INTERRUPTS)
        and     ecx, VDM_VIRTUAL_INTERRUPTS OR VDM_VIRTUAL_AC

        ; [edx]=eflags
        ; [eax]=eflgs-if
        ; [ecx]=IF + AC of vdmstate

        test    _KeI386VirtualIntExtensions, dword ptr V86_VIRTUAL_INT_EXTENSIONS
        jz      oinnv15
;
;VIF extension is enabled, we should migrate EFLAGS_VIF instead of
;VDM_VIRTUAL_INTERRUPT to the iret frame eflags IF.
;When VIF extension is enabled, RI_BIT_MASK is turned on. This in turn,
;redirects the FCLI/FSTI macro to execute cli/sti directly instead
;of simulation. Without this, we might disable v86 mode interrupt
;without the applications knowing it.
;
        and     ecx, VDM_VIRTUAL_AC         ;keep VDM_VIRTUAL_AC only
        or      eax, ecx                    ;[eax]=eflags + ac -if
        mov     ecx, edx
        and     ecx, EFLAGS_VIF
.errnz  ((EFLAGS_VIF SHR 10) - EFLAGS_INTERRUPT_MASK)
        ror     ecx, 10                     ;VIF -> IF
oinnv15:
        or      eax, ecx                    ;[eax]=eflags +ac +if

oinnv20:
        and     edx,NOT (EFLAGS_NT_MASK OR EFLAGS_TF_MASK OR EFLAGS_VIF)
        mov     [ebp].TsEflags,edx

        or      eax, EFLAGS_IOPL_MASK
        movzx   ecx,word ptr [ebp].TsHardwareSegSS
        shl     ecx,4
        movzx   edx,word ptr [ebp].TsHardwareEsp    ; ecx+edx is user stack
        sub     dx,2
        mov     word ptr [ecx+edx],ax       ; push flags
        mov     ax,word ptr [ebp].TsSegCS
        sub     dx,2
        mov     word ptr [ecx+edx],ax       ; push cs
        movzx   eax,word ptr [ebp].TsEip
        add     eax, edi
        inc     eax
        sub     dx,2
        mov     word ptr [ecx+edx],ax       ; push ip
        mov     [ebp].TsHardwareEsp,dx      ; update sp on trap frame

        inc     esi
        movzx   ecx,byte ptr [esi]          ; ecx is int#

;
;       Check if this is a v86 interrupt which must be reflected to a PM handler
;
        call    oinnvuserrefs               ; do user refs under a try/except block
        or      eax, eax
        je      oinnv30
;
;       Encode interrupt number in cs
;
        mov     eax,ebx
        shr     eax,16                      ; bop cs
        sub     eax,ecx                     ; new cs
        shl     ecx,4
        add     ebx,ecx                     ; new ip
        jmp     oinnv40
oinnv30:
;
;       Not hooked, just pick up new vector from RM IVT
;
        mov     ebx,[ecx*4]
        mov     eax,ebx
        shr     eax,16                      ; new cs
oinnv40:
        mov     word ptr [ebp].TsEip,bx
        mov     [ebp].TsSegCs,ax            ; cs:ip on trap frame is updated

        mov     eax,1
        ret

OpcodeINTnnV86 endp

oinnvuserrefs proc
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset oinnvuserrefs_fault  ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     eax,PCR[PcTeb]
        mov     eax,[eax].TeVdm             ; get pointer to VdmTib
        cmp     eax, _MmUserProbeAddress    ; Probe the TeVdm
        jae     @f
        mov     ebx,[eax].VtInterruptTable  ;
        cmp     ebx, 0                      ; there is no interrupt table
        je      @f                          ; so, don't reflect it.
        lea     ebx,[ebx + ecx*8]
        cmp     ebx, _MmUserProbeAddress    ; Probe the TeVdm
        jae     @f
        test    [ebx].ViFlags, VDM_INT_HOOKED    ; need to reflect to PM?
        jz      @f

        lea     ebx,[eax].VtDpmiInfo        ; point to DpmiInfo
        mov     ebx,[ebx].VpDosxRmReflector ; bop to reflect to PM
        mov     eax, 1
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp
        ret

@@:
oinnvuserrefs_fault_resume:
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp
        xor     eax, eax
        ret

oinnvuserrefs_fault:
;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.  We can take
; this short cut because we know that our handler is a leaf-node.
;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        jmp     oinnvuserrefs_fault_resume


oinnvuserrefs endp

        page   ,132
        subttl "INTO Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INTO opcode.  Currently, it prints
;       a message, and reflects a GP fault to the debugger.
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeINTOV86
OpcodeINTOV86 proc

        xor     eax,eax                 ; ret fail
        ret

OpcodeINTOV86 endp

        page   ,132
        subttl "IRET Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an IRET opcode.  It retrieves the flags,
;       and new instruction pointer from the stack and puts them into
;       the user context.
;
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeIRETV86
OpcodeIRETV86 proc

        lea     eax,ds:FIXED_NTVDMSTATE_LINEAR
        movzx   ecx,word ptr [ebp].TsHardwareSegSS
        movzx   edx,word ptr [ebp].TsHardwareEsp    ; ebx+edx is user stack
        shl     ecx,4
        add     ecx,edx
        test    ebx,PREFIX_OPER32
        jnz     irt50                               ; normally not

        movzx   edi,word ptr [ecx]                  ; get ip value
        mov     [ebp].TsEip,edi
        movzx   esi,word ptr [ecx+2]                ; get cs value
        mov     [ebp].TsSegCs,esi
        add     edx,6
        mov     [ebp].TsHardwareEsp,edx             ; update sp on trap frame
        movzx   ebx,word ptr [ecx+4]                ; get flag value

irt10:  ; [ebx]=UserFlgs
        and     ebx, NOT (EFLAGS_IOPL_MASK OR EFLAGS_NT_MASK OR EFLAGS_VIP OR EFLAGS_VIF)
        mov     ecx,ebx  ; [ecx]=[ebx]=UserFlgs - IOPL - NT - VIP - VIF

        test    _KeI386VirtualIntExtensions, dword ptr V86_VIRTUAL_INT_EXTENSIONS
        jz      short irt15

        or      ebx, EFLAGS_VIF
        test    ebx, EFLAGS_INTERRUPT_MASK
        jnz     irt15

        and     ebx, NOT EFLAGS_VIF
        ; [ebx] = UserFlgs - IOPL - NT - VIP

irt15:
        or      ebx, (EFLAGS_V86_MASK OR EFLAGS_INTERRUPT_MASK)
        and     dword ptr [ebp].TsEFlags, EFLAGS_VIP
        or      [ebp].TsEFlags, ebx                  ; update flags n trap frame
        and     ecx, EFLAGS_INTERRUPT_MASK
        MPLOCK and [eax],NOT VDM_VIRTUAL_INTERRUPTS
        MPLOCK or [eax],ecx
        mov     ebx,[eax]


        ; at this point esi is the cs and edi is the ip where v86 mode
        ; will return. Now we will check if this returning instruction
        ; is a bop. if so we will directly dispatch the bop from here
        ; saving a full round trip. This will be really helpful to
        ; com apps.

        shl     esi,4
        add     esi,edi
        cmp     esi, _MmUserProbeAddress            ; Probe 32 bit value
        jbe     @f
        mov     esi, _MmUserProbeAddress
@@:     mov     ax, word ptr [esi]
        cmp     ax, 0c4c4h
        je      irtbop

        test    ebx,VDM_INTERRUPT_PENDING
        jz      short irt25

        test    ebx,VDM_VIRTUAL_INTERRUPTS
        jz      short irt25

        call    VdmDispatchIntAck       ; VdmDispatchIntAck enables interrupts

irt25:
        mov     eax,1                   ; handled
        ret

        ; ireting to a bop
irtbop:
        stdCall _VdmDispatchBop, <ebp>

        jmp     short irt25

irt50:
        mov     edi, [ecx]                          ; get ip value
        mov     [ebp].TsEip,edi
        movzx   esi,word ptr [ecx+4]                ; get cs value
        mov     [ebp].TsSegCs,esi
        add     edx,12
        mov     [ebp].TsHardwareEsp,edx             ; update sp on trap frame
        mov     ebx, [ecx+8]                        ; get flag value
        jmp     irt10                               ; rejoin the common path

OpcodeIRETV86 endp


        page   ,132
        subttl "In Byte Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an in byte immediate opcode.  Currently, it
;       prints a message, and ignores the instruction.
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeINBimmV86
OpcodeINBimmV86 proc

        inc     esi
        inc     edi
        movzx   ecx,byte ptr [esi]

        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ecx, 1, TRUE, edi, ebp>
        ret

OpcodeINBimmV86 endp

        page   ,132
        subttl "Word In Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an in word immediate opcode.  Currently, it
;       prints a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeINWimmV86
OpcodeINWimmV86 proc

        inc     esi
        inc     edi
        movzx   ecx,byte ptr [esi]
; edi - instruction size
; TRUE - read op
; 2 - word op
; ecx - port number
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ecx, 2, TRUE, edi, ebp>

        ret

OpcodeINWimmV86 endp

        page   ,132
        subttl "Out Byte Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an invalid opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeOUTBimmV86
OpcodeOUTBimmV86 proc

        inc     edi
        inc     esi
        movzx   ecx,byte ptr [esi]
; edi - instruction size
; FALSE - write op
; 1 - byte op
; ecx - port #
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ecx, 1, FALSE, edi, ebp>

        ret

OpcodeOUTBimmV86 endp

        page   ,132
        subttl "Out Word Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an out word immediate opcode.  Currently,
;       it prints a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeOUTWimmV86
OpcodeOUTWimmV86 proc

        inc     esi
        inc     edi
        movzx   ecx,byte ptr [esi]
; edi - instruction size
; FALSE - write op
; 2 - word op
; ecx - port number
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ecx, 2, FALSE, edi, ebp>

        ret

OpcodeOUTWimmV86 endp

        page   ,132
        subttl "INB Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INB opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeINBV86
OpcodeINBV86 proc

        movzx   ebx,word ptr [ebp].TsEdx


; edi - instruction size
; TRUE - read op
; 1 - byte op
; ebx - port number

        cmp     ebx, 3bdh
        jz      oib_prt1
        cmp     ebx, 379h
        jz      oib_prt1
        cmp     ebx, 279h
        jz      oib_prt1

oib_reflect:
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ebx, 1, TRUE, edi, ebp>
        ret

oib_prt1:
        ; call printer status routine with port number, size, trap frame
        stdCall _VdmPrinterStatus, <ebx, edi, ebp>
        or      al,al
        jz      short oib_reflect
        ret

OpcodeINBV86 endp

        page   ,132
        subttl "INW Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INW opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeINWV86
OpcodeINWV86 proc

        movzx   ebx,word ptr [ebp].TsEdx

; edi - instruction size
; TRUE - read operation
; 2 - word op
; ebx - port number
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ebx, 2, TRUE, edi, ebp>

        ret
OpcodeINWV86 endp

        page   ,132
        subttl "OUTB Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTB opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeOUTBV86
OpcodeOUTBV86 proc

        movzx   ebx,word ptr [ebp].TsEdx

        cmp     ebx, 3bch
        jz      oob_prt1
        cmp     ebx, 378h
        jz      oob_prt1
        cmp     ebx, 278h
        jz      oob_prt1

oob_reflect:

; edi - instruction size
; FALSE - write op
; 1 - byte op
; ebx - port number
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ebx, 1, FALSE, edi, ebp>

        ret
oob_prt1:
        ; call printer write data routine with port number, size, trap frame
        stdCall _VdmPrinterWriteData, <ebx, edi, ebp>
        or      al,al
        jz      short oob_reflect
                                        ;al already has TRUE
        ret
OpcodeOUTBV86 endp

        page   ,132
        subttl "OUTW Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTW opcode.  Currently, it prints
;       a message, and ignores the instruction.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeOUTWV86
OpcodeOUTWV86 proc

        movzx   ebx,word ptr [ebp].TsEdx
; edi - instruction size
; FALSE - write op
; 2 - word op
; ebx - port #
        ; Ki386VdmDispatchIo enables interrupts
        stdCall   _Ki386VdmDispatchIo, <ebx, 2, FALSE, edi, ebp>

        ret

OpcodeOUTWV86 endp


        page   ,132
        subttl "CLI Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an CLI opcode.  Currently, it prints
;       a message, and clears the virtual interrupt flag in the VdmTeb.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeCLIV86
OpcodeCLIV86 proc
        lea     eax,ds:FIXED_NTVDMSTATE_LINEAR
        test    _KeI386VirtualIntExtensions, dword ptr V86_VIRTUAL_INT_EXTENSIONS
        jz      short oc50

        mov     edx, [ebp].TsEFlags       ; redundant code.  Just in case
        mov     eax,dword ptr [eax]
        and     edx, EFLAGS_VIF + EFLAGS_VIP
        cmp     edx, EFLAGS_VIF + EFLAGS_VIP
        jnz     short oc50

        test    eax,VDM_INTERRUPT_PENDING
        jz      short oc50

        call    VdmDispatchIntAck
        mov     eax,1
        ret

oc50:
        MPLOCK and dword ptr [eax],NOT VDM_VIRTUAL_INTERRUPTS
        add     dword ptr [ebp].TsEip,edi

        mov     eax,1
        ret

OpcodeCLIV86 endp

        page   ,132
        subttl "STI Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an STI opcode.  Currently, it prints
;       a message, and sets the virtual interrupt flag in the VDM teb.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;
;

        public OpcodeSTIV86
OpcodeSTIV86 proc

        lea     eax,ds:FIXED_NTVDMSTATE_LINEAR      ; get pointer to VDM State
        test    _KeI386VirtualIntExtensions, dword ptr V86_VIRTUAL_INT_EXTENSIONS
        jz      short os10

        or      [ebp].TsEFlags, dword ptr EFLAGS_VIF

os10:   MPLOCK or dword ptr [eax],EFLAGS_INTERRUPT_MASK
os20:   add     dword ptr [ebp].TsEip,edi
        mov     eax,dword ptr [eax]
        test    eax,VDM_INTERRUPT_PENDING
        jz      short os30

        call    VdmDispatchIntAck
os30:   mov     eax,1
        ret

OpcodeSTIV86 endp


;
;  If we get here, we have executed an NPX instruction in user mode
;  with the emulator installed.  If the EM bit was not set in CR0, the
;  app really wanted to execute the instruction for detection purposes.
;  In this case, we need to clear the TS bit, and restart the instruction.
;  Otherwise we need to reflect the exception
;
;
; Reginfo structure
;

    public Opcode0FV86
Opcode0FV86 proc

RI      equ     [ebp - REGINFOSIZE]

        push    ebp
        mov     ebp,esp
        sub     esp,REGINFOSIZE
        push    esi
        push    edi


        ; Initialize RegInfo
do10:   mov     esi,[ebp]


        ; initialize rest of the trap from which was'nt initialized for
        ; v86 mode
        mov     eax, [esi].TsV86Es
        mov     [esi].TsSegEs,eax
        mov     eax, [esi].TsV86Ds
        mov     [esi].TsSegDs,eax
        mov     eax, [esi].TsV86Fs
        mov     [esi].TsSegFs,eax
        mov     eax, [esi].TsV86Gs
        mov     [esi].TsSegGs,eax

        mov     RI.RiTrapFrame,esi
        mov     eax,[esi].TsHardwareSegSs
        mov     RI.RiSegSs,eax
        mov     eax,[esi].TsHardwareEsp
        mov     RI.RiEsp,eax
        mov     eax,[esi].TsEFlags
        mov     RI.RiEFlags,eax
        mov     eax,[esi].TsSegCs
        mov     RI.RiSegCs,eax
        mov     eax,[esi].TsEip
        dec     edi
        add     eax,edi                 ; for prefixes
        mov     RI.RiEip,eax

        mov     RI.RiPrefixFlags,ebx
        lea     esi,RI

        CsToLinearV86
        call    VdmOpcode0f                             ; enables interrupts

        test    eax,0FFFFh
        jz      do20

        mov     edi,RI.RiTrapFrame
        mov     eax,RI.RiEip                            ; advance eip
        mov     [edi].TsEip,eax
do19:   mov     eax,1
do20:
        pop     edi
        pop     esi
        mov     esp,ebp
        pop     ebp
        ret

Opcode0FV86 endp


;++
;
;   Routine Description: VdmDispatchIntAck
;       pushes stack arguments for VdmDispatchInterrupts
;       and invokes VdmDispatchInterrupts
;
;       Expects VDM_INTERRUPT_PENDING, and VDM_VIRTUAL_INTERRUPTS
;
;   Arguments:
;       EBP -> trap frame
;
;   Returns:
;       nothing
;
;
        public VdmDispatchIntAck
VdmDispatchIntAck proc
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset diafault             ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        test    ds:FIXED_NTVDMSTATE_LINEAR, VDM_INT_HARDWARE ; check interrupt int
        mov     eax,PCR[PcTeb]
        mov     eax,[eax].TeVdm             ; get pointer to VdmTib
        jz      short dia20

        cmp     eax, _MmUserProbeAddress    ; check if user address
        jae     short dia10                 ; if ae, then not user address


        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp
        ;
        ; dispatch hardware int directly from kernel
        ;
        stdCall _VdmDispatchInterrupts, <ebp, eax>  ; TrapFrame, VdmTib
        ret

dia10:
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp
        ret


        ;
        ; Switch to monitor context to dispatch timer int
        ;
dia20:
        cmp     eax, _MmUserProbeAddress    ; check if user address
        jae     dia10                       ; if ae, then not user address

        mov     dword ptr [eax].VtEIEvent,VdmIntAck ; 
        mov     dword ptr [eax].VtEIInstSize,0
        mov     dword ptr [eax].VtEiIntAckInfo,0

        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp

        stdCall _VdmEndExecution, <ebp, eax>        ; TrapFrame, VdmTib
        ret


diafault:

;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.  We can take
; this short cut because we know that our handler is a leaf-node.
;

        mov     esp, [esp+8]                ; (esp)-> ExceptionList
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp
        ret


VdmDispatchIntAck endp


        public vdmDebugPoint
vdmDebugPoint proc
        ret
vdmDebugPoint endp



        page   ,132
        subttl "HLT Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an HLT opcode.  If the halt instruction is
;       followed by the magic number (to be found in a crackerjack box),
;       we use the hlt + magic number as a prefix, and emulate the following
;       instruction.  This allows code running in segmented protected mode to
;       access the virtual interrupt flag.
;
;   Arguments:
;       EAX -> pointer to vdm state in DOS arena
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       interrupts disabled
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;

        public OpcodeHLTV86
OpcodeHLTV86 proc

        add     dword ptr [ebp].TsEip,edi
        mov     eax,1
        ret

OpcodeHLTV86 endp

_PAGE   ends

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING

        subttl "NPX Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates all NPX opcodes, when the system
;       has the R3 emulator installed and the c86 apps takes a
;       trap07.
;
;   Arguments:
;       EBX -> prefix flags
;       EBP -> trap frame
;       CL  -> byte at the faulting address
;       ESI -> address of faulting instruction
;       EDI -> instruction length count
;
;   Returns:
;       EAX = 0 for failure
;       EAX = 1 for success
;
;   All registers can be trashed except ebp/esp.
;   moved from emv86.asm as it must be non-pagable

    public OpcodeNPXV86
OpcodeNPXV86 proc
        mov     edx, PCR[PcInitialStack]
        mov     edx, [edx].FpCr0NpxState
        test    edx, CR0_EM             ; Does app want NPX traps?
        jnz     short onp40

    ; MP bit can never be set while the EM bit is cleared, so we know
    ; the faulting instruction is not an FWAIT

onp30:  and     ebx, PREFIX_ADDR32
        stdCall _VdmSkipNpxInstruction, <ebp, ebx, esi, edi>
        or      al, al                  ; was it handled?
        jnz     short onp60             ; no, go raise exception to app

onp40:  stdCall _Ki386VdmReflectException, <7>  ; trap #

onp60:  mov     eax,1
        ret


OpcodeNPXV86 endp


;++ KiVdmSetUserCR0
;
;       eax
;
        public KiVdmSetUserCR0
KiVdmSetUserCR0 proc

        and     eax, CR0_MP OR CR0_EM       ; Sanitize parameter
        shr     eax, 1
        movzx   eax, _VdmUserCr0MapIn[eax]

        push    esp                         ; Pass current Esp to handler
        push    offset scr_fault            ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     edx,PCR[PcTeb]
        mov     edx,[edx].TeVdm             ; get pointer to VdmTib
        cmp     edx, _MmUserProbeAddress    ; probe the pointer
        jbe     @f
        mov     edx, _MmUserProbeAddress    ; make us AV
@@:     mov     [edx].VtVdmContext.CsFloatSave.FpCtxtCr0NpxState, eax

scr10:  pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack

        mov     edx, PCR[PcInitialStack]    ; Get fp save area
        mov     ebx, PCR[PcPrcbData + PbCurrentThread]  ; (ebx) = current thread

scr20:  cli                                 ; sync with context swap
        and     [edx].FpCr0NpxState, NOT (CR0_MP+CR0_EM+CR0_PE)
        or      [edx].FpCr0NpxState,eax     ; set fp save area bits

        mov     eax,cr0
        and     eax, NOT (CR0_MP+CR0_EM+CR0_TS) ; turn off bits we will change
        or      al, [ebx].ThNpxState        ; set scheduler bits
        or      eax,[edx].FpCr0NpxState     ; set user's bits
        mov     cr0,eax
        sti
        ret

scr_fault:
;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.  We can take
; this short cut because we know that our handler is a leaf-node.
;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        jmp     short scr10


KiVdmSetUserCR0 endp

_TEXT$00   ENDS

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\emxcptn.asm ===
page    78,132
;*******************************************************************************
;        Copyright (c) Microsoft Corporation 1991
;        All Rights Reserved
;
;   ke\i386\emxcptn.asm
;
;       Module to support getting/setting context to and from the R3
;       emulator.
;
;Revision History:
;
;
;*******************************************************************************

        .386p
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;;*******************************************************************************
;;
;;   Include some more macros and constants.
;;
;;*******************************************************************************
;

NT386   equ     1

        include ks386.inc
        include em387.inc               ; Emulator TEB data layout
        include callconv.inc

        EXTRNP  _KeGetCurrentIrql,0
        EXTRNP  _KeBugCheck,1
        EXTRNP  _ExRaiseStatus,1
        extrn   _Ki387RoundModeTable:dword


        subttl  _KiEm87StateToNpxFrame
        page

;*** _KiEm87StateToNpxFrames
;
;  Translates the R3 emulators state to the NpxFrame
;
;  Returns TRUE if NpxFrame sucessfully completed.
;   else FALSE
;
;  Warning: This function can only be called at Irql 0 with interrupts
;  enabled.  It is intended to be called only to deal with R3 exceptions
;  when the emulator is being used.
;
;  Revision History:
;
;
;*******************************************************************************

cPublicProc _KiEm87StateToNpxFrame, 1
        push    ebp
        mov     ebp, esp
        push    ebx                     ; Save C runtime varibles
        push    edi
        push    esi

        push    esp                     ; Pass current Esp to handler
        push    offset stnpx_30         ; Set Handler address
        push    PCR[PcExceptionList]    ; Set next pointer
        mov     PCR[PcExceptionList],esp ; Link us on

if DBG
        pushfd                              ; Sanity check
        pop     ecx                         ; make sure interrupts are enabled
        test    ecx, EFLAGS_INTERRUPT_MASK
        jz      short stnpx_err

        stdCall _KeGetCurrentIrql           ; Sanity check
        cmp     al, DISPATCH_LEVEL          ; make sure Irql is below DPC level
        jnc     short stnpx_err
endif

        xor     eax, eax                ; set FALSE

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        jne     short stnpx_10               ; Yes, then not supported

        mov     ebx, PCR[PcTeb]         ; R3 Teb
        cmp     [ebx].Einstall, 0       ; Initialized?
        je      short stnpx_10          ; No, then don't return NpxFrame

        test    [ebx].CURErr, Summary   ; Completed?
        jz      short stnpx_10          ; No, then don't return NpxFrame

        mov     esi, [ebp+8]            ; (esi) = NpxFrame
        call    SaveState

        mov     eax, 1                  ; Return TRUE
stnpx_10:
        pop     PCR[PcExceptionList]    ; Remove our exception handle
        add     esp, 8                  ; clear stack
        pop     esi
        pop     edi
        pop     ebx
        pop     ebp
        stdRET  _KiEm87StateToNpxFrame

stnpx_30:
;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.  We can take
; this short cut because we know that our handler is a leaf-node.
;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        xor     eax, eax                ; Return FALSE
        jmp     short stnpx_10

if DBG
stnpx_err:
        stdCall _KeBugCheck <IRQL_NOT_LESS_OR_EQUAL>
endif
_KiEm87StateToNpxFrame ENDP


;*** SaveEnv
;
;
;   ARGUMENTS
;
;       (esi) = NpxFrame
;       (ebx) = PcTeb
;
;
;   DESCRIPTION
;

SaveEnv:
        xor     ax,ax
        mov     [esi].reserved1,ax
        mov     [esi].reserved2,ax
        mov     [esi].reserved3,ax
        mov     [esi].reserved4,ax
        mov     [esi].reserved5,ax
        mov     ax,[ebx].ControlWord
        mov     [esi].E32_ControlWord,ax
        call    GetEMSEGStatusWord
        mov     [esi].E32_StatusWord,ax
        call    GetTagWord
        mov     [esi].E32_TagWord,ax
        mov     ax,cs
        mov     [esi].E32_CodeSeg,ax    ; NOTE: Not R0 code & stack
        mov     ax,ss
        mov     [esi].E32_DataSeg,ax
        mov     eax,[ebx].PrevCodeOff
        mov     [esi].E32_CodeOff,eax
        mov     eax,[ebx].PrevDataOff
        mov     [esi].E32_DataOff,eax
        ret


;*** SaveState -
;
;   ARGUMENTS
;       (esi) = where to store environment
;       (ebx) = PcTeb
;
;   DESCRIPTION
;
;   REGISTERS
;       Destroys ALL, but EBX
;

SaveState:                              ; Enter here for debugger save state
        mov     dword ptr [esi].FpCr0NpxState, CR0_EM

        call    SaveEnv
        add     esi,size Env80x87_32    ;Skip over environment
        mov     ebp,NumLev              ;Save entire stack
        mov     edi,[ebx].CURstk
ss_loop:
        mov     eax,[ebx+edi].ExpSgn
        call    StoreTempReal           ;in emstore.asm
        add     esi,10

        mov     edi,[ebx].CURstk
;;;     NextStackElem   edi,SaveState
        cmp     edi,INITstk
        jae     short ss_wrap
        add     edi,Reg87Len
ss_continue:
        mov     [ebx].CURstk,edi
        dec     ebp
        jnz     short ss_loop
        ret
ss_wrap:
        mov     edi, BEGstk
        jmp     short ss_continue


;***    GetTagWord - figures out what the tag word is from the numeric stack
;                  and returns the value of the tag word in ax.
;
;   ARGUMENTS
;       (ebx) = PcTeb
;

GetTagWord:
        push    esi
        xor     eax, eax
        mov     ecx, NumLev             ; get tags for regs. 0, 7 - 1
        mov     esi, INITstk
GetTagLoop:
        mov     dh, [ebx+esi].bTag      ; The top 2 bits of Tag are the X87 tag bits.
        shld    ax, dx, 2
        sub     esi, Reg87Len
        loop    GetTagLoop
        rol     ax, 2                   ; This moves Tag(0) into the low 2 bits
        pop     esi
        ret


;***    GetEMSEGStatusWord
;
; User status word returned in ax.
; Uses status word in per-thread data area, otherwise
;   identical to GetStatusWord
;
;   ARGUMENTS
;       (ebx) = PcTeb

GetEMSEGStatusWord:
        mov     eax, [ebx].CURstk
        sub     eax, BEGstk

        ;
        ; Make sure the 'div' won't overflowed.
        ;

        cmp     eax, Reg87Len * (NumLev + 2)
        ja      short @f

        mov     dl,Reg87Len
        div     dl
        inc     eax
        and     eax, 7                  ; eax is now the stack number
        shl     ax, 11
        or      ax, [ebx].StatusWord    ; or in the rest of the status word.
        ret
@@:
        mov     eax, STATUS_INTEGER_OVERFLOW
        stdCall _ExRaiseStatus, <eax>
        ret                             ; Should never come here ...

;***  StoreTempReal
;
;
;   ARGUMENTS
;       ??
;       (ebx) = PcTeb
;

StoreTempReal:
        mov     edx,[ebx+edi].lManHi
        mov     edi,[ebx+edi].lManLo
;mantissa in edx:edi, exponent in high eax, sign in ah bit 7, tag in al
;memory destination is esi
        mov     ecx,eax                 ;get copy of sign and tag
        shr     ecx,16                  ;Bring exponent down
        cmp     al,bTAG_ZERO
        jz      short StoreIEEE80       ;Skip bias if zero
        add     ecx,IexpBias-TexpBias   ;Correct bias
        cmp     al,bTAG_DEN
        jz      short Denorm80
StoreIEEE80:
        and     eax,bSign shl 8
        or      ecx,eax                 ;Combine sign with exponent
        mov     [esi],edi
        mov     [esi+4],edx
        mov     [esi+8],cx
        ret

Denorm80:
;Must change it to a denormal
        dec     ecx
        neg     ecx                     ;Use as shift count
        cmp     cl,32                   ;Long shift?
        jae     LongDenorm
        shrd    edi,edx,cl
        shr     edx,cl
        xor     ecx,ecx                 ;Exponent is zero
        jmp     short StoreIEEE80

LongDenorm:
;edi must be zero if we have 32 bits to shift
        xchg    edx,edi                 ;32-bit right shift
        shr     edi,cl                  ;shift count is modulo-32
        xor     ecx,ecx                 ;Exponent is zero
        jmp     short StoreIEEE80


;****************************************************
;****************************************************
;****************************************************
;****************************************************


;*** _KiNpxFrameToEm87State
;
;  Translates the NpxFrame to the R3 emulators state
;
;  Returns TRUE if NpxFrame state sucessfully transfered.
;   else FALSE
;
;  Warning: This function can only be called at Irql 0 with interrupts
;  enabled.  It is intended to be called only to deal with R3 exceptions
;  when the emulator is being used.
;
;  Revision History:
;
;
;*******************************************************************************

cPublicProc _KiNpxFrameToEm87State, 1
        push    ebp
        mov     ebp, esp
        push    ebx                     ; Save C runtime varibles
        push    edi
        push    esi

        push    esp                     ; Pass current Esp to handler
        push    offset npxts_30         ; Set Handler address
        push    PCR[PcExceptionList]    ; Set next pointer
        mov     PCR[PcExceptionList],esp  ; Link us on

if DBG
        pushfd                              ; Sanity check
        pop     ecx                         ; make sure interrupts are enabled
        test    ecx, EFLAGS_INTERRUPT_MASK
        jz      short npxts_err

        stdCall _KeGetCurrentIrql           ; Sanity check
        cmp     al, DISPATCH_LEVEL          ; make sure Irql is below DPC level
        jnc     short npxts_err
endif

        xor     eax, eax                ; set FALSE

        mov     ebx,PCR[PcPrcbData+PbCurrentThread]
        mov     ebx,[ebx]+ThApcState+AsProcess
        cmp     dword ptr [ebx]+PrVdmObjects,0 ; is this a vdm process?
        jne     short npxts_10               ; Yes, then not supported

        mov     ebx, PCR[PcTeb]         ; R3 Teb
        cmp     [ebx].Einstall, 0       ; Initialized?
        je      short npxts_10          ; No, then don't set NpxFrame

        mov     esi, [ebp+8]            ; (esi) = NpxFrame
        call    StorState
        or      [ebx].CURErr, Summary   ; Set completed

        mov     eax, 1                  ; Return TRUE
npxts_10:
        pop     PCR[PcExceptionList]    ; Remove our exception handle
        add     esp, 8                  ; clear stack
        pop     esi
        pop     edi
        pop     ebx
        pop     ebp
        stdRet  _KiNpxFrameToEm87State

npxts_30:
;
; WARNING: Here we directly unlink the exception handler from the
; exception registration chain.  NO unwind is performed.  We can take
; this short cut because we know that our handler is a leaf-node.
;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        xor     eax, eax                ; Return FALSE
        jmp     short npxts_10
        ret

if DBG
npxts_err:
        stdCall _KeBugCheck <IRQL_NOT_LESS_OR_EQUAL>
endif
_KiNpxFrameToEm87State ENDP



;*** StorState - emulate FRSTOR  [address]
;
;   ARGUMENTS
;       (esi)  = where to get the environment
;       (ebx)  = PcTeb
;
;
;   DESCRIPTION
;           This routine emulates an 80387 FRSTOR (restore state)

StorState:
;First we set up the status word so that [CURstk] is initialized.
;The floating-point registers are stored in logical ST(0) - ST(7) order,
;not physical register order.  We don't do a full load of the environment
;because we're not ready to use the tag word yet.

        mov     ax, [esi].E32_StatusWord
        call    SetEmStatusWord         ;Initialize [CURstk]
        add     esi,size Env80x87_32    ;Skip over environment

;Load of temp real has one difference from real math chip: it is an invalid
;operation to load an unsupported format.  By ensuring the exception is
;masked, we will convert unsupported format to Indefinite.  Note that the
;mask and [CURerr] will be completely restored by the FLDENV at the end.

        mov     [ebx].CWmask,3FH        ;Mask off invalid operation exception
        mov     edi,[ebx].CURstk
        mov     ebp,NumLev
FrstorLoadLoop:
        push    esi
        call    LoadTempReal            ;In emload.asm
        pop     esi
        add     esi,10          ;Point to next temp real
;;;     NextStackElem   edi,Frstor
        cmp     edi,INITstk
        jae     short fr_wrap
        add     edi,Reg87Len
fr_continue:
        dec     ebp
        jnz     short FrstorLoadLoop
        sub     esi,NumLev*10+size Env80x87_32  ;Point to start of env.
;
; Stor Enviroment
; (esi) = where to get enviroment
; (ebx) = PcTeb
;

        mov     ax, [esi].E32_StatusWord
        call    SetEmStatusWord                 ; set up status word
        mov     ax, [esi].E32_ControlWord
        call    SetControlWord
        mov     ax, [esi].E32_TagWord
        call    UseTagWord

        mov     eax, [esi].E32_CodeOff
        mov     [ebx].PrevCodeOff, eax
        mov     eax, [esi].E32_DataOff
        mov     [ebx].PrevDataOff, eax
        ret

fr_wrap:
        mov     edi, BEGstk
        jmp     short fr_continue


;***    SetEmStatusWord -
;
; Given user status word in ax, set into emulator.
; Destroys ebx only.


SetEmStatusWord:
        and     ax,7F7FH
        mov     cx,ax
        and     cx,3FH                  ; set up CURerr in case user
        mov     [ebx].CURerr,cl         ; wants to force an exception
        mov     ecx, eax
        and     ecx, not (7 shl 11)     ; remove stack field.
        mov     [ebx].StatusWord, cx

        sub     ah, 8                   ; adjust for emulator's stack layout
        and     ah, 7 shl 3
        mov     al, ah
        shr     ah, 1
        add     al, ah                  ; stack field * 3 * 4
.erre   Reg87Len eq 12
        and     eax, 255                ; eax is now 12*stack number
        add     eax, BEGstk
        mov     [ebx].CURstk, eax
        ret

SetControlWord:
        and     ax,0F3FH                ; Limit to valid values
        mov     [ebx].ControlWord, ax   ; Store in the emulated control word
        not     al                      ;Flip mask bits for fast compare
        and     al,3FH                  ;Limit to valid mask bits
        mov     [ebx].ErrMask,al
        and     eax,(RoundControl + PrecisionControl) shl 8
.erre   RoundControl eq 1100B
.erre   PrecisionControl eq 0011B
        shr     eax,6                   ;Put PC and RC in bits 2-5
        mov     ecx,_Ki387RoundModeTable
        mov     ecx,[ecx+eax]           ;Get correct RoundMode vector
        mov     [ebx].RoundMode,ecx
        mov     [ebx].SavedRoundMode,ecx
        and     eax,RoundControl shl (8-6)      ;Mask off precision control
        mov     ecx,_Ki387RoundModeTable
        mov     ecx,[ecx+(eax+PC64 shl (8-6))];Get correct RoundMode vector
        mov     [ebx].TransRound,ecx    ;Round mode w/o precision
        ret


;***    UseTagWord - Set up tags using tag word from environment
;
;       ARGUMENTS
;              ax - should contain the tag word
;
;       Destroys ax,bx,cx,dx,di

UseTagWord:
        ror     ax, 2                   ; mov Tag(0) into top bits of ax
        mov     edi,INITstk
        mov     ecx, NumLev
UseTagLoop:
        mov     dl,bTAG_EMPTY
        cmp     ah, 0c0h                ;Is register to be tagged Empty?
        jae     short SetTag            ;Yes, go mark it
        mov     dl,[ebx+edi].bTag       ;Get current tag
        cmp     dl,bTAG_EMPTY           ;Is register currently Empty?
        je      short SetTagNotEmpty    ;If so, go figure out tag for it
SetTag:
        mov     [ebx+edi].bTag,dl
UseTagLoopCheck:
        sub     edi, Reg87Len
        shl     eax, 2
        loop    UseTagLoop
        ret

SetTagEmpty:
        mov     [ebx+edi].bTag, bTAG_EMPTY
        jmp     short UseTagLoopCheck

SetTagNotEmpty:
;Register is currently tagged empty, but new tag word says it is not empty.
;Figure out a new tag for it.  The rules are:
;
;1. Everything is either normalized or zero--unnormalized formats cannot
;get in.  So if the high half mantissa is zero, the number is zero.
;
;2. Although the exponent bias is different, NANs and Infinities are in
;standard IEEE format - exponent is TexpMax, mantissa indicates NAN vs.
;infinity (mantissa for infinity is 800..000H).
;
;3. Denormals have an exponent less than TexpMin.
;
;4. If the low half of the mantissa is zero, it is tagged bTAG_SNGL
;
;5. Everything else is bTAG_VALID

        cmp     [ebx+edi].lManHi, 0
        mov     dl,bTAG_ZERO            ;Try zero first
        jz      short SetTag            ;Is mantissa zero?
        mov     edx,[ebx+edi].ExpSgn
        mov     dl,bTAG_DEN
        cmp     edx,TexpMin shl 16      ;Is it denormal?
        jl      short SetTag
        cmp     [ebx+edi].lManLo,0      ;Is low half zero?
.erre   bTAG_VALID eq 1
.erre   bTAG_SNGL eq 0
        setnz   dl                      ;if low half==0 then dl=0 else dl=1
        cmp     edx,TexpMax shl 16      ;Is it NAN or Infinity?
        jl      short SetTag            ;If not, it's valid
.erre   (bTAG_VALID - bTAG_SNGL) shl TAG_SHIFT eq (bTAG_NAN - bTAG_INF)
        shl     dl,TAG_SHIFT
        add     dl,bTAG_INF - bTAG_SNGL
;If the low bits were zero we have just changed bTAG_SNGL to bTAG_INF
;If the low bits weren't zero, we changed bTAG_VALID to bTAG_NAN
;See if infinity is really possible: is high half 80..00H?
        cmp     [ebx+edi].lManHi,1 shl 31   ;Is it infinity?
        jz      short SetTag            ;Store tag for infinity or NAN
        mov     dl,bTAG_NAN
        jmp     short SetTag


;***    LoadTempReal
;
;
;

LoadTempReal:
        mov     ebx,[esi+4]             ;Get high half of mantissa
        mov     cx,[esi+8]              ;Get exponent and sign
        mov     esi,[esi]               ;Get low half of mantissa
        mov     eax,ecx
        and     ch,7FH                  ;Mask off sign bit
        shl     ecx,16                  ;Move exponent to high end
        mov     ch,ah                   ;Restore sign
        jz      short ZeroOrDenorm80
;Check for unsupported format: unnormals (MSB not set)
        or      ebx,ebx
        jns     short Unsupported
        sub     ecx,(IexpBias-TexpBias) shl 16  ;Correct the bias
        cmp     ecx,TexpMax shl 16
        jge     short NANorInf80
SetupTag:
        or      esi,esi                 ;Any bits in low half?
.erre   bTAG_VALID eq 1
.erre   bTAG_SNGL eq 0
        setnz   cl                      ;if low half==0 then cl=0 else cl=1
        jmp     short SaveStack

NANorInf80:
        mov     cl,bTAG_NAN
        cmp     ebx,1 shl 31            ;Only 1 bit set means infinity
        jnz     short SaveStack
        or      esi,esi
        jnz     short SaveStack
        mov     cl,bTAG_INF
        jmp     short SaveStack

ZeroOrDenorm80:
;Exponent is zero. Number is either zero or denormalized
        or      ebx,ebx
        jnz     short ShortNorm80       ;Are top 32 bits zero?
        or      esi,esi                 ;Are low 32 bits zero too?
        jnz     LongNorm80
        mov     cl,bTAG_ZERO
        jmp     short SaveStack

;This code accepts and works correctly with pseudo-denormals (MSB already set)
LongNorm80:
        xchg    ebx,esi                 ;Shift up 32 bits
        sub     ecx,32 shl 16           ;Correct exponent
ShortNorm80:
        add     ecx,(TexpBias-IexpBias+1-31) shl 16     ;Fix up bias
        bsr     edx,ebx                 ;Scan for MSB
;Bit number in edx ranges from 0 to 31
        mov     cl,dl
        not     cl                      ;Convert bit number to shift count
        shld    ebx,esi,cl
        shl     esi,cl
        shl     edx,16                  ;Move exp. adjustment to high end
        add     ecx,edx                 ;Adjust exponent
        jmp     short SetUpTag

SaveStack:
        mov     eax, PCR[PcTeb]
        mov     [eax].CURstk,edi
        mov     [eax+edi].lManLo,esi
        mov     [eax+edi].lManHi,ebx
        mov     [eax+edi].ExpSgn,ecx
        mov     ebx, eax                ; (ebx) = PcTeb
        ret

Unsupported:
        mov     ebx, PCR[PcTeb]
        or      [ebx].CURerr,Invalid    ; (assume it's masked?)
        mov     [ebx+edi].lManLo,0
        mov     [ebx+edi].lManHi,0C0000000H
        mov     [ebx+edi].ExpSgn,TexpMax shl 16 + bSign shl 8 + bTAG_NAN
        mov     [ebx].CURstk,edi        ;Update top of stack
        ret

_TEXT   ENDS
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\cyrix.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    cyrix.c

Abstract:

    Detects and initializes Cryix processors

Author:

    Ken Reneris (kenr) 24-Feb-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#define Cx486_SLC    0x0
#define Cx486_DLC    0x1
#define Cx486_SLC2   0x2
#define Cx486_DLC2   0x3
#define Cx486_SRx    0x4    // Retail Upgrade Cx486SLC
#define Cx486_DRx    0x5    // Retail Upgrade Cx486DLC
#define Cx486_SRx2   0x6    // Retail Upgrade 2x Cx486SLC
#define Cx486_DRx2   0x7    // Retail Upgrade 2x Cx486DLC
#define Cx486DX      0x1a
#define Cx486DX2     0x1b
#define M1           0x30

#define CCR0    0xC0
#define CCR1    0xC1
#define CCR2    0xC2
#define CCR3    0xC3

#define DIR0    0xFE
#define DIR1    0xFF


// SRx & DRx flags
#define CCR0_NC0        0x01        // No cache 64k @ 1M boundaries
#define CCR0_NC1        0x02        // No cache 640k - 1M
#define CCR0_A20M       0x04        // Enables A20M#
#define CCR0_KEN        0x08        // Enables KEN#
#define CCR0_FLUSH      0x10        // Enables FLUSH#

// DX flags
#define CCR1_NO_LOCK    0x10        // Ignore lock prefixes


ULONG
Ke386CyrixId (
    VOID
    );

UCHAR
ReadCyrixRegister (
    IN UCHAR    Register
    );

VOID
WriteCyrixRegister (
    IN UCHAR    Register,
    IN UCHAR    Value
    );

VOID
Ke386ConfigureCyrixProcessor (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,Ke386CyrixId)
#pragma alloc_text(PAGELK,Ke386ConfigureCyrixProcessor)
#endif


extern UCHAR CmpCyrixID[];



ULONG
Ke386CyrixId (
    VOID
    )
/*++

Routine Description:

    Detects and returns the Cyrix ID of the processor.
    This function only detects Cyrix processors which have internal
    cache support.

Arguments:

    Configure   - If TRUE, causes this function to alter
                  the Cyrix CCR registers for the optimal NT
                  performance.

                  If FALSE, the processors configuration is
                  not altered.


Return Value:

    Cyrix ID of the processor
    0 if not a Cyrix processor

--*/

{
    ULONG       CyrixID;
    UCHAR       r3, c;
    UCHAR       flags;
    PKPRCB      Prcb;

    CyrixID = 0;

    Prcb = KeGetCurrentPrcb();
    if (Prcb->CpuID  &&  strcmp (Prcb->VendorString, CmpCyrixID)) {

        //
        // Not a Cyrix processor
        //

        return 0;
    }

    //
    // Test Div instruction to see if the flags
    // do not get altered
    //

    _asm {
        xor     eax, eax
        sahf                    ; flags = ah

        lahf                    ; ah = flags
        mov     flags, ah       ; save flags

        mov     eax, 5
        mov     ecx, 2
        div     cl              ; 5 / 2 = ?

        lahf
        sub     flags, ah       ; flags = orig_flags - new_flags
    }

    if (flags == 0) {

        //
        // See if the Cyrix CCR3 register bit 0x80 can be editted.
        //

        r3 = ReadCyrixRegister(CCR3);       // Read CCR3
        c  = r3 ^ 0x80;                     // flip bit 80
        WriteCyrixRegister(CCR3, c);        // Write CCR3
        ReadCyrixRegister(CCR0);            // select new register
        c = ReadCyrixRegister(CCR3);        // Read new CCR3 value

        if (ReadCyrixRegister(CCR3) != r3) {

            //
            // Read the Cyrix ID type register
            //

            CyrixID = ReadCyrixRegister(DIR0) + 1;
        }

        WriteCyrixRegister(CCR3, r3);       // restore original CCR3 value
    }

    if (CyrixID > 0x7f) {
        // invalid setting
        CyrixID = 0;
    }

    return CyrixID;
}

static UCHAR
ReadCyrixRegister (
    IN UCHAR    Register
    )
/*++

Routine Description:

    Reads an internal Cyrix ID register.  Note the internal register
    space is accessed via I/O addresses which are hooked internally
    to the processor.

    The caller is responsible for only calling this function on
    a Cyrix processor.

Arguments:

    Register - Which Cyrix register to read

Return Value:

    The registers value

--*/

{
    UCHAR   Value;

    _asm {
        mov     al, Register
        cli
        out     22h, al
        in      al, 23h
        sti
        mov     Value, al
    }
    return  Value;
}


static VOID
WriteCyrixRegister (
    IN UCHAR    Register,
    IN UCHAR    Value
    )
/*++

Routine Description:

    Write an internal Cyrix ID register.  Note the internal register
    space is accessed via I/O addresses which are hooked internally
    to the processor.

    The caller is responsible for only calling this function on
    a Cyrix processor.

Arguments:

    Register - Which Cyrix register to written
    Value    - Value to write into the register

Return Value:

    The registers value

--*/

{
    _asm {
        mov     al, Register
        mov     cl, Value
        cli
        out     22h, al
        mov     al, cl
        out     23h, al
        sti
    }
}


VOID
Ke386ConfigureCyrixProcessor (
    VOID
    )
{
    UCHAR   r0, r1;
    ULONG   id, rev;


    PAGED_CODE();

    id = Ke386CyrixId();
    if (id) {

        ASSERT(ExPageLockHandle);
        MmLockPagableSectionByHandle(ExPageLockHandle);

        id  = id - 1;
        rev = ReadCyrixRegister(DIR1);

        if ((id >= 0x20  &&  id <= 0x27) ||
            ((id & 0xF0) == M1  &&  rev < 0x17)) {

            //
            // These steppings have a write-back cache problem.
            // On these chips the L1 w/b cache can be disabled by
            // setting only the NW bit.
            //

            _asm {
                cli

                mov     eax, cr0
                or      eax, CR0_NW
                mov     cr0, eax

                sti
            }
        }


        switch (id) {
            case Cx486_SRx:
            case Cx486_DRx:
            case Cx486_SRx2:
            case Cx486_DRx2:

                //
                // These processors have an internal cache feature
                // let's turn it on.
                //

                r0  = ReadCyrixRegister(CCR0);
                r0 |=  CCR0_NC1 | CCR0_FLUSH;
                r0 &= ~CCR0_NC0;
                WriteCyrixRegister(CCR0, r0);

                // Clear Non-Cacheable Region 1
                WriteCyrixRegister(0xC4, 0);
                WriteCyrixRegister(0xC5, 0);
                WriteCyrixRegister(0xC6, 0);
                break;

            case Cx486DX:
            case Cx486DX2:
                //
                // Set NO_LOCK flag on these processors according to
                // the number of booted processors
                //

                r1  = ReadCyrixRegister(CCR1);
                r1 |= CCR1_NO_LOCK;
                if (KeNumberProcessors > 1) {
                    r1 &= ~CCR1_NO_LOCK;
                }
                WriteCyrixRegister(CCR1, r1);
                break;
        }

        MmUnlockPagableImageSection (ExPageLockHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\flush.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    flush.c

Abstract:

    This module implements i386 machine dependent kernel functions to flush
    the data and instruction caches and to stall processor execution.

Author:

    David N. Cutler (davec) 26-Apr-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"


//
// Prototypes
//

VOID
KeInvalidateAllCachesTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

extern ULONG KeI386CpuType;

//  i386 and i486 have transparent caches, so these routines are nooped
//  out in macros in i386.h.

#if 0

VOID
KeSweepDcache (
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes the data cache on all processors that are currently
    running threads which are children of the current process or flushes the
    data cache on all processors in the host configuration.

Arguments:

    AllProcessors - Supplies a boolean value that determines which data
        caches are flushed.

Return Value:

    None.

--*/

{

    HalSweepDcache();
    return;
}

VOID
KeSweepIcache (
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes the instruction cache on all processors that are
    currently running threads which are children of the current process or
    flushes the instruction cache on all processors in the host configuration.

Arguments:

    AllProcessors - Supplies a boolean value that determines which instruction
        caches are flushed.

Return Value:

    None.

--*/

{

    HalSweepIcache();

#if defined(R4000)

    HalSweepDcache();

#endif

    return;
}

VOID
KeSweepIcacheRange (
    IN BOOLEAN AllProcessors,
    IN PVOID BaseAddress,
    IN ULONG Length
    )

/*++

Routine Description:

    This function flushes the an range of virtual addresses from the primary
    instruction cache on all processors that are currently running threads
    which are children of the current process or flushes the range of virtual
    addresses from the primary instruction cache on all processors in the host
    configuration.

Arguments:

    AllProcessors - Supplies a boolean value that determines which instruction
        caches are flushed.

    BaseAddress - Supplies a pointer to the base of the range that is flushed.

    Length - Supplies the length of the range that is flushed if the base
        address is specified.

Return Value:

    None.

--*/

{

    ULONG Offset;

    //
    // If the length of the range is greater than the size of the primary
    // instruction cache, then set the length of the flush to the size of
    // the primary instruction cache and set the ase address of zero.
    //
    // N.B. It is assumed that the size of the primary instruction and
    //      data caches are the same.
    //

    if (Length > PCR->FirstLevelIcacheSize) {
        BaseAddress = (PVOID)0;
        Length = PCR->FirstLevelIcacheSize;
    }

    //
    // Flush the specified range of virtual addresses from the primary
    // instruction cache.
    //

    Offset = (ULONG)BaseAddress & PCR->DcacheAlignment;
    Length = (Offset + Length + PCR->DcacheAlignment) & ~PCR->DcacheAlignment;
    BaseAddress = (PVOID)((ULONG)BaseAddress & ~PCR->DcacheAlignment);
    HalSweepIcacheRange(BaseAddress, Length);

#if defined(R4000)

    HalSweepDcacheRange(BaseAddress, Length);

#endif

    return;
}
#endif

BOOLEAN
KeInvalidateAllCaches (
    IN BOOLEAN AllProcessors
    )
/*++

Routine Description:

    This function writes back and invalidates the cache on all processors
    that are currently running threads which are children of the current
    process or on all processors in the host configuration.

Arguments:

    AllProcessors - Supplies a boolean value that determines which data
        caches are flushed.

Return Value:

    TRUE if the invalidation was done, FALSE otherwise.

--*/
{
    PKPRCB Prcb;
    PKPROCESS Process;
    KIRQL OldIrql;
    KAFFINITY TargetProcessors;

    //
    // Support for wbinvd on Pentium based platforms is vendor dependent.
    // Check for family first and support on Pentium Pro based platforms
    // onward.
    //

    if (KeI386CpuType < 6 ) {
        return FALSE;
    }

#ifndef NT_UP
    //
    // Compute target set of processors.
    //

    KiLockContextSwap(&OldIrql);
    Prcb = KeGetCurrentPrcb();
    if (AllProcessors) {
        TargetProcessors = KeActiveProcessors;
    } else {
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    TargetProcessors &= ~Prcb->SetMember;

    //
    // If any target processors are specified, then send writeback
    // invalidate packet to the target set of processors.
    //

    if (TargetProcessors != 0) {
        KiIpiSendSynchronousPacket(Prcb,
                                   TargetProcessors,
                                   KeInvalidateAllCachesTarget,
                                   (PVOID)&Prcb->ReverseStall,
                                   NULL,
                                   NULL);

        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // All target processors have written back and invalidated caches and
    // are waiting to proceed. Write back invalidate current cache and
    // then continue the execution of target processors.
    //
#endif
    _asm {
        ;
        ; wbinvd
        ;

        _emit 0Fh
        _emit 09h
    }

#ifndef NT_UP
    //
    // Wait until all target processors have finished and completed packet.
    //

    if (TargetProcessors != 0) {
        Prcb->ReverseStall += 1;
    }

    //
    // Release the context swap lock.
    //

    KiUnlockContextSwap(OldIrql);

#endif

    return TRUE;
}

VOID
KeInvalidateAllCachesTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Proceed,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )
/*++

Routine Description:

    This is the target function for writing back and invalidating the cache.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Proceed - pointer to flag to syncronize with

  Return Value:

    None.

--*/
{
    //
    // Write back invalidate current cache
    //

    _asm {
        ;
        ; wbinvd
        ;

        _emit 0Fh
        _emit 09h

    }

    KiIpiSignalPacketDoneAndStall (SignalDone, Proceed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\flushtb.c ===
/*++

Copyright (c) 1989  Microsoft Corporation
Copyright (c) 1990  Microsoft Corporation

Module Name:

    tbflush.c

Abstract:

    This module implements machine dependent functions to flush
    the translation buffers in an Intel x86 system.

    N.B. This module contains only MP versions of the TB flush routines.
         The UP versions are macros in ke.h
         KeFlushEntireTb remains a routine for the UP system since it is
         exported from the kernel for backwards compatibility.

Author:

    David N. Cutler (davec) 13-May-1989

Environment:

    Kernel mode only.

Revision History:

    Shie-Lin Tzong (shielint) 30-Aug-1990
        Implement MP version of KeFlushSingleTb and KeFlushEntireTb.

--*/

#include "ki.h"

VOID
KiFlushTargetEntireTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Invalid,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
KiFlushTargetMultipleTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );


VOID
KiFlushTargetSingleTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

HARDWARE_PTE
KiFlushSingleTbSynchronous (
    IN PVOID Virtual,
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors,
    IN PHARDWARE_PTE PtePointer,
    IN HARDWARE_PTE PteValue
    );

VOID
KiFlushTargetSingleTbSynchronous (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
Ki386UseSynchronousTbFlush (
    IN volatile PLONG Number
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,Ki386UseSynchronousTbFlush)
#endif

#if !defined(NT_UP)


VOID
KeFlushEntireTb (
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors
    )

/*++

Routine Description:

    This function flushes the entire translation buffer (TB) on all processors
    that are currently running threads which are child of the current process
    or flushes the entire translation buffer on all processors in the host
    configuration.

Arguments:

    Invalid - Supplies a boolean value that specifies the reason for flushing
        the translation buffer.

    AllProcessors - Supplies a boolean value that determines which translation
        buffers are to be flushed.

Return Value:

    None.

--*/

{

    KAFFINITY EntireSet;
    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;

    //
    // Compute the target set of processors, disable context switching,
    // and send the flush entire parameters to the target processors,
    // if any, for execution.
    //

    if (AllProcessors != FALSE) {
        OldIrql = KeRaiseIrqlToSynchLevel();
        Prcb = KeGetCurrentPrcb();
        TargetProcessors = KeActiveProcessors;

    } else {
        KiLockContextSwap(&OldIrql);
        Prcb = KeGetCurrentPrcb();
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    EntireSet = KeActiveProcessors & ~Prcb->SetMember;
    TargetProcessors &= ~Prcb->SetMember;

    //
    // If the target set of processors is equal to the full set of processors,
    // then set the TB flush time stamp busy.
    //

    if (TargetProcessors == EntireSet) {
        KiSetTbFlushTimeStampBusy();
    }

    //
    // Send packet to target processors.
    //

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushTargetEntireTb,
                        NULL,
                        NULL,
                        NULL);

        IPI_INSTRUMENT_COUNT (Prcb->Number, FlushEntireTb);
    }

    //
    // Flush TB on current processor.
    //

    KeFlushCurrentTb();

    //
    // Wait until all target processors have finished and complete packet.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // If the target set of processors is equal to the full set of processors,
    // then clear the TB flush time stamp busy.
    //

    if (TargetProcessors == EntireSet) {
        KiClearTbFlushTimeStampBusy();
    }

    //
    // Lower IRQL and unlock as appropriate.
    //

    if (AllProcessors != FALSE) {
        KeLowerIrql(OldIrql);

    } else {
        KiUnlockContextSwap(OldIrql);
    }

    return;
}



VOID
KiFlushTargetEntireTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for flushing the entire TB.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Parameter1 - Parameter3 - Not used.

Return Value:

    None.

--*/

{

    //
    // Flush the entire TB on the current processor.
    //

    KiIpiSignalPacketDone(SignalDone);
    KeFlushCurrentTb();
    return;
}

VOID
KeFlushMultipleTb (
    IN ULONG Number,
    IN PVOID *Virtual,
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors,
    IN PHARDWARE_PTE *PtePointer OPTIONAL,
    IN HARDWARE_PTE PteValue
    )

/*++

Routine Description:

    This function flushes multiple entries from the translation buffer
    on all processors that are currently running threads which are
    children of the current process or flushes a multiple entries from
    the translation buffer on all processors in the host configuration.

Arguments:

    Number - Supplies the number of TB entries to flush.

    Virtual - Supplies a pointer to an array of virtual addresses that
        are within the pages whose translation buffer entries are to be
        flushed.

    Invalid - Supplies a boolean value that specifies the reason for
        flushing the translation buffer.

    AllProcessors - Supplies a boolean value that determines which
        translation buffers are to be flushed.

    PtePointer - Supplies an optional pointer to an array of pointers to
       page table entries that receive the specified page table entry
       value.

    PteValue - Supplies the the new page table entry value.

Return Value:

    The previous contents of the specified page table entry is returned
    as the function value.

--*/

{

    ULONG Index;
    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    KAFFINITY TargetProcessors;

    //
    // Compute target set of processors.
    //

    if (AllProcessors != FALSE) {
        OldIrql = KeRaiseIrqlToSynchLevel();
        Prcb = KeGetCurrentPrcb();
        TargetProcessors = KeActiveProcessors;

    } else {
        KiLockContextSwap(&OldIrql);
        Prcb = KeGetCurrentPrcb();
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    TargetProcessors &= ~Prcb->SetMember;

    //
    // If a page table entry address array is specified, then set the
    // specified page table entries to the specific value.
    //

    if (ARGUMENT_PRESENT(PtePointer)) {
        for (Index = 0; Index < Number; Index += 1) {
            KI_FILL_PTE(PtePointer[Index], PteValue);
        }
    }

    //
    // If any target processors are specified, then send a flush multiple
    // packet to the target set of processors.
    //

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushTargetMultipleTb,
                        (PVOID)Invalid,
                        (PVOID)Number,
                        (PVOID)Virtual);

        IPI_INSTRUMENT_COUNT (Prcb->Number, FlushMultipleTb);
    }

    //
    // Flush the specified entries from the TB on the current processor.
    //

    for (Index = 0; Index < Number; Index += 1) {
        KiFlushSingleTb(Invalid, Virtual[Index]);
    }

    //
    // Wait until all target processors have finished and complete packet.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Release the context swap lock.
    //

    if (AllProcessors != FALSE) {
        KeLowerIrql(OldIrql);

    } else {
        KiUnlockContextSwap(OldIrql);
    }

    return;
}

VOID
KiFlushTargetMultipleTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Invalid,
    IN PVOID Number,
    IN PVOID Virtual
    )

/*++

Routine Description:

    This is the target function for flushing multiple TB entries.

Arguments:

    SignalDone - Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Invalid - Supplies a bollean value that determines whether the virtual
        address is invalid.

    Number - Supplies the number of TB entries to flush.

    Virtual - Supplies a pointer to an array of virtual addresses that
        are within the pages whose translation buffer entries are to be
        flushed.

Return Value:

    None.

--*/

{

    ULONG Index;
    PVOID VirtualAddress[FLUSH_MULTIPLE_MAXIMUM];

    //
    // Capture the virtual addresses that are to be flushed from the TB
    // on the current processor and signal pack done.
    //

    for (Index = 0; Index < (ULONG) Number; Index += 1) {
        VirtualAddress[Index] = ((PVOID *)(Virtual))[Index];
    }

    KiIpiSignalPacketDone(SignalDone);

    //
    // Flush the specified virtual address for the TB on the current
    // processor.
    //

    for (Index = 0; Index < (ULONG) Number; Index += 1) {
        KiFlushSingleTb((BOOLEAN)Invalid, VirtualAddress [Index]);
    }
}

HARDWARE_PTE
KeFlushSingleTb (
    IN PVOID Virtual,
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors,
    IN PHARDWARE_PTE PtePointer,
    IN HARDWARE_PTE PteValue
    )

/*++

Routine Description:

    This function flushes a single entry from translation buffer (TB) on all
    processors that are currently running threads which are child of the current
    process or flushes the entire translation buffer on all processors in the
    host configuration.

Arguments:

    Virtual - Supplies a virtual address that is within the page whose
        translation buffer entry is to be flushed.

    Invalid - Supplies a boolean value that specifies the reason for flushing
        the translation buffer.

    AllProcessors - Supplies a boolean value that determines which translation
        buffers are to be flushed.

    PtePointer - Address of Pte to update with new value.

    PteValue - New value to put in the Pte.  Will simply be assigned to
        *PtePointer, in a fashion correct for the hardware.

Return Value:

    Returns the contents of the PtePointer before the new value
    is stored.

--*/

{

    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    HARDWARE_PTE OldPteValue;
    KAFFINITY TargetProcessors;

    //
    // Compute target set of processors.
    //

    if (AllProcessors != FALSE) {
        OldIrql = KeRaiseIrqlToSynchLevel();
        Prcb = KeGetCurrentPrcb();
        TargetProcessors = KeActiveProcessors;

    } else {
        KiLockContextSwap(&OldIrql);
        Prcb = KeGetCurrentPrcb();
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    TargetProcessors &= ~Prcb->SetMember;

    //
    // Capture the previous contents of the page table entry and set the
    // page table entry to the new value.
    //

    KI_SWAP_PTE(PtePointer, PteValue, OldPteValue);

    //
    // If any target processors are specified, then send a flush single
    // packet to the target set of processors.
    //

    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiFlushTargetSingleTb,
                        (PVOID)Invalid,
                        (PVOID)Virtual,
                        NULL);

        IPI_INSTRUMENT_COUNT(Prcb->Number, FlushSingleTb);
    }


    //
    // Flush the specified entry from the TB on the current processor.
    //

    KiFlushSingleTb(Invalid, Virtual);

    //
    // Wait until all target processors have finished and complete packet.
    //

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // Release the context swap lock.
    //

    if (AllProcessors != FALSE) {
        KeLowerIrql(OldIrql);

    } else {
        KiUnlockContextSwap(OldIrql);
    }

    return(OldPteValue);
}

VOID
KiFlushTargetSingleTb (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Invalid,
    IN PVOID VirtualAddress,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This is the target function for flushing a single TB entry.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Invalid - Supplies a bollean value that determines whether the virtual
        address is invalid.

    Virtual - Supplies a virtual address that is within the page whose
        translation buffer entry is to be flushed.

    Parameter3 - Not used.

Return Value:

    None.

--*/

{

    //
    // Flush a single entry from the TB on the current processor.
    //

    KiIpiSignalPacketDone(SignalDone);
    KiFlushSingleTb((BOOLEAN)Invalid, (PVOID)VirtualAddress);
}

HARDWARE_PTE
KiFlushSingleTbSynchronous (
    IN PVOID Virtual,
    IN BOOLEAN Invalid,
    IN BOOLEAN AllProcessors,
    IN PHARDWARE_PTE PtePointer,
    IN HARDWARE_PTE PteValue
    )

/*++

Routine Description:

    This function is a slow synchronous version of KeFlushSingleTb.  We need
    this function as many P6's don't actually know how to deal with PTEs in
    an MP safe manner.

Arguments:

    See KeFlushSingleTb

Return Value:

    See KeFlushSingleTb

--*/
{

    KIRQL OldIrql;
    PKPRCB Prcb;
    PKPROCESS Process;
    HARDWARE_PTE OldPteValue;
    KAFFINITY TargetProcessors;

    //
    // Synchronize will all other single flush calls (and other
    // IPIs which use reverse stalls)
    //

    KiLockContextSwap(&OldIrql);

    //
    // Compute target set of processors.
    //

    Prcb = KeGetCurrentPrcb();
    if (AllProcessors != FALSE) {
        TargetProcessors = KeActiveProcessors;
    } else {
        Process = Prcb->CurrentThread->ApcState.Process;
        TargetProcessors = Process->ActiveProcessors;
    }

    TargetProcessors &= ~Prcb->SetMember;

    //
    // If any target processors are specified, then send a flush single
    // packet to the target set of processors.
    //

    if (TargetProcessors != 0) {
        KiIpiSendSynchronousPacket(Prcb,
                                   TargetProcessors,
                                   KiFlushTargetSingleTbSynchronous,
                                   (PVOID)Invalid,
                                   (PVOID)Virtual,
                                   (PVOID)&Prcb->ReverseStall
                                   );

        IPI_INSTRUMENT_COUNT(Prcb->Number, FlushSingleTb);

        //
        // Wait for the target processors to stall
        //

        KiIpiStallOnPacketTargets(TargetProcessors);

        //
        // Capture the previous contents of the page table entry and set the
        // page table entry to the new value.
        //

        KI_SWAP_PTE(PtePointer, PteValue, OldPteValue);

        //
        // Notify all prcessors it's time to go
        //

        Prcb->ReverseStall += 1;

    } else {

        //
        // Capture the previous contents of the page table entry and set the
        // page table entry to the new value.
        //

        KI_SWAP_PTE(PtePointer, PteValue, OldPteValue);
    }

    //
    // Flush the specified entry from the TB on the current processor.
    //

    KiFlushSingleTb(Invalid, Virtual);

    //
    // Done
    //

    KiUnlockContextSwap(OldIrql);
    return(OldPteValue);
}

VOID
KiFlushTargetSingleTbSynchronous (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Invalid,
    IN PVOID VirtualAddress,
    IN PVOID Proceed
    )

/*++

Routine Description:

    This is the target function for flushing a single TB entry synchronously.

Arguments:

    SignalDone Supplies a pointer to a variable that is cleared when the
        requested operation has been performed.

    Invalid - Supplies a bollean value that determines whether the virtual
        address is invalid.

    Virtual - Supplies a virtual address that is within the page whose
        translation buffer entry is to be flushed.

    Parameter3 - Not used.

Return Value:

    None.

--*/

{

    //
    // Flush a single entry from the TB on the current processor.
    //

    KiIpiSignalPacketDoneAndStall(SignalDone, Proceed);
    KiFlushSingleTb((BOOLEAN)Invalid, (PVOID)VirtualAddress);
}


VOID
Ki386UseSynchronousTbFlush (
    IN volatile PLONG Number
    )
{
    PKPRCB              Prcb;
    volatile PUCHAR     Patch;

    Prcb = KeGetCurrentPrcb();
    Patch = (PUCHAR) KeFlushSingleTb;

    //
    // Signal we're here and wait for others
    //

    InterlockedDecrement (Number);
    while (*Number) ;

    //
    // If this is processor 0 apply the patch
    //

    if (Prcb->Number == 0) {
        *((PULONG) &Patch[1]) = ((ULONG) &KiFlushSingleTbSynchronous) - ((ULONG) Patch) - 5;
        Patch[0] = 0xe9;
    }

    //
    // Wait for processor 0 to complete installation of handler
    //

    while (Patch[0] != 0xe9) ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\gdtsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    gdtsup.c

Abstract:

    This module implements interfaces that support manipulation of i386 GDTs.
    These entry points only exist on i386 machines.

Author:

    Dave Hastings (daveh) 28 May 1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, KeI386SetGdtSelector)
#pragma alloc_text(PAGE, Ke386GetGdtEntryThread)
#endif

VOID
Ke386GetGdtEntryThread(
    IN PKTHREAD Thread,
    IN ULONG Offset,
    IN PKGDTENTRY Descriptor
    )
/*++

Routine Description:

    This routine returns the contents of an entry in the GDT.  If the
    entry is thread specific, the entry for the specified thread is
    created and returned (KGDT_LDT, and KGDT_R3_TEB).  If the selector
    is processor dependent, the entry for the current processor is
    returned (KGDT_R0_PCR).

Arguments:

    Thread -- Supplies a pointer to the thread to return the entry for.

    Offset -- Supplies the offset in the Gdt.  This value must be 0
        mod 8.

    Descriptor -- Returns the contents of the Gdt descriptor

Return Value:

    None.

--*/

{
    PKGDTENTRY Gdt;
    PKPROCESS Process;

    //
    // If the entry is out of range, don't return anything
    //

    if (Offset >= KGDT_NUMBER * sizeof(KGDTENTRY)) {
        return ;
    }

    if (Offset == KGDT_LDT) {

        //
        // Materialize Ldt selector
        //

        Process = Thread->ApcState.Process;
        RtlCopyMemory( Descriptor,
            &(Process->LdtDescriptor),
            sizeof(KGDTENTRY)
            );

    } else {

        //
        // Copy Selector from Ldt
        //
        // N.B. We will change the base later, if it is KGDT_R3_TEB
        //


        Gdt = KiPcr()->GDT;

        RtlCopyMemory(Descriptor, (PCHAR)Gdt + Offset, sizeof(KGDTENTRY));

        //
        // if it is the TEB selector, fix the base
        //

        if (Offset == KGDT_R3_TEB) {
            Descriptor->BaseLow = (USHORT)((ULONG)(Thread->Teb) & 0xFFFF);
            Descriptor->HighWord.Bytes.BaseMid =
                (UCHAR) ( ( (ULONG)(Thread->Teb) & 0xFF0000L) >> 16);
            Descriptor->HighWord.Bytes.BaseHi =
                (CHAR)  ( ( (ULONG)(Thread->Teb) & 0xFF000000L) >> 24);
        }
    }

    return ;
}

NTSTATUS
KeI386SetGdtSelector (
    ULONG       Selector,
    PKGDTENTRY  GdtValue
    )
/*++

Routine Description:

    Sets a GDT entry obtained via KeI386AllocateGdtSelectors to the supplied
    GdtValue.

Arguments:

    Selector - Which GDT to set

    GdtValue - GDT value to set into GDT

Return Value:

    status code

--*/
{
    KAFFINITY       TargetSet;
    PKPRCB          Prcb;
    PKPCR           Pcr;
    PKGDTENTRY      GdtEntry;
    ULONG           GdtIndex, BitNumber;

    PAGED_CODE ();

    //
    // Verify GDT entry passed, and it's above the kernel GDT values
    //

    GdtIndex = Selector >> 3;
    if ((Selector & 0x7) != 0  || GdtIndex < KGDT_NUMBER) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set GDT entry in each processor's GDT
    //

    TargetSet = KeActiveProcessors;
    while (TargetSet != 0) {
        KeFindFirstSetLeftAffinity(TargetSet, &BitNumber);
        ClearMember(BitNumber, TargetSet);

        Prcb = KiProcessorBlock[BitNumber];
        Pcr  = CONTAINING_RECORD (Prcb, KPCR, PrcbData);
        GdtEntry = Pcr->GDT + GdtIndex;

        // set it
        *GdtEntry = *GdtValue;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\exceptn.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    exceptn.c

Abstract:

    This module implement the code necessary to dispatch expections to the
    proper mode and invoke the exception dispatcher.

Author:

    David N. Cutler (davec) 30-Apr-1989

Environment:

    Kernel mode only.

Revision History:

    14-Feb-1990    shielint

                   Modified for NT386 interrupt manager

    6-April-1990    bryanwi

                   Fix non-canonical stack case for 386.

--*/

#include "ki.h"

#define FN_BITS_PER_TAGWORD     16
#define FN_TAG_EMPTY            0x3
#define FN_TAG_MASK             0x3
#define FX_TAG_VALID            0x1
#define NUMBER_OF_FP_REGISTERS  8
#define BYTES_PER_FP_REGISTER   10
#define BYTES_PER_FX_REGISTER   16

extern UCHAR VdmUserCr0MapIn[];
extern BOOLEAN KeI386FxsrPresent;
extern BOOLEAN KeI386XMMIPresent;

VOID
Ki386AdjustEsp0(
    IN PKTRAP_FRAME TrapFrame
    );

BOOLEAN
KiEm87StateToNpxFrame(
    OUT PFLOATING_SAVE_AREA NpxFrmae
    );

BOOLEAN
KiNpxFrameToEm87State(
    IN PFLOATING_SAVE_AREA NpxFrmae
    );


ULONG
KiEspFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine fetches the correct esp from a trapframe, accounting
    for whether the frame is a user or kernel mode frame, and whether
    it has been edited.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

Return Value:

    Value of Esp.

--*/

{
    if (((TrapFrame->SegCs & MODE_MASK) != KernelMode) ||
         (TrapFrame->EFlags & EFLAGS_V86_MASK)) {

        //  User mode frame, real value of Esp is always in HardwareEsp.

        return TrapFrame->HardwareEsp;

    } else {

        if ((TrapFrame->SegCs & FRAME_EDITED) == 0) {

            //  Kernel mode frame which has had esp edited,
            //  value of Esp is in TempEsp.

            return TrapFrame->TempEsp;

        } else {

            //  Kernel mode frame has has not had esp edited, compute esp.

            return (ULONG)&TrapFrame->HardwareEsp;
        }
    }
}

VOID
KiEspToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG Esp
    )

/*++

Routine Description:

    This routine sets the specified value Esp into the trap frame,
    accounting for whether the frame is a user or kernel mode frame,
    and whether it has been edited before.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    Esp - New value for Esp.

Return Value:

    None.

--*/
{
    ULONG   OldEsp;

    OldEsp = KiEspFromTrapFrame(TrapFrame);

    if (((TrapFrame->SegCs & MODE_MASK) != KernelMode) ||
         (TrapFrame->EFlags & EFLAGS_V86_MASK)) {

        //
        //  User mode trap frame
        //

        TrapFrame->HardwareEsp = Esp;

    } else {

        //
        //  Kernel mode esp can't be lowered or iret emulation will fail
        //

        if (Esp < OldEsp)
            KeBugCheckEx(SET_OF_INVALID_CONTEXT,
                         Esp, OldEsp, (ULONG_PTR)TrapFrame, 0);

        //
        //  Edit frame, setting edit marker as needed.
        //

        if ((TrapFrame->SegCs & FRAME_EDITED) == 0) {

            //  Kernel frame that has already been edited,
            //  store value in TempEsp.

            TrapFrame->TempEsp = Esp;

        } else {

            //  Kernel frame for which Esp is being edited first time.
            //  Save real SegCs, set marked in SegCs, save Esp value.

            if (OldEsp != Esp) {
                TrapFrame->TempSegCs = TrapFrame->SegCs;
                TrapFrame->SegCs = TrapFrame->SegCs & ~FRAME_EDITED;
                TrapFrame->TempEsp = Esp;
            }
        }
    }
}

ULONG
KiSegSsFromTrapFrame(
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine fetches the correct ss from a trapframe, accounting
    for whether the frame is a user or kernel mode frame.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

Return Value:

    Value of SegSs.

--*/

{
    if (TrapFrame->EFlags & EFLAGS_V86_MASK){
        return TrapFrame->HardwareSegSs;
    } else if ((TrapFrame->SegCs & MODE_MASK) != KernelMode) {

        //
        // It's user mode.  The HardwareSegSs contains R3 data selector.
        //

        return TrapFrame->HardwareSegSs | RPL_MASK;
    } else {
        return KGDT_R0_DATA;
    }
}

VOID
KiSegSsToTrapFrame(
    IN PKTRAP_FRAME TrapFrame,
    IN ULONG SegSs
    )

/*++

Routine Description:

    It turns out that in a flat system there are only two legal values
    for SS.  Therefore, this procedure forces the appropriate one
    of those values to be used.  The legal SS value is a function of
    which CS value is already set.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    SegSs - value of SS caller would like to set.

Return Value:

    Nothing.

--*/

{
    SegSs &= SEGMENT_MASK;  // Throw away the high order trash bits

    if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
        TrapFrame->HardwareSegSs = SegSs;
    } else if ((TrapFrame->SegCs & MODE_MASK) == UserMode) {

        //
        // If user mode, we simply put SegSs to trapfram.  If the SegSs
        // is a bogus value.  The trap0d handler will be able to detect
        // this and handle it appropriately.
        //

        TrapFrame->HardwareSegSs = SegSs | RPL_MASK;
    }

    //
    //  else {
    //      The frame is a kernel mode frame, which does not have
    //      a place to store SS.  Therefore, do nothing.
    //
}

VOID
KeContextFromKframes (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN OUT PCONTEXT ContextFrame
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified trap and exception frames
    frames into the specified context frame according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame from which volatile context
        should be copied into the context record.

    ExceptionFrame - Supplies a pointer to an exception frame from which context
        should be copied into the context record. This argument is ignored since
        there is no exception frame on NT386.

    ContextFrame - Supplies a pointer to the context frame that receives the
        context copied from the trap and exception frames.

Return Value:

    None.

--*/

{

    PFX_SAVE_AREA NpxFrame;
    BOOLEAN StateSaved;
    ULONG i;
    struct _FPSaveBuffer {
        UCHAR               Buffer[15];
        FLOATING_SAVE_AREA  SaveArea;
    } FloatSaveBuffer;
    PFLOATING_SAVE_AREA PSaveArea;

    UNREFERENCED_PARAMETER( ExceptionFrame );

    //
    // Set control information if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        //
        // Set registers ebp, eip, cs, eflag, esp and ss.
        //

        ContextFrame->Ebp = TrapFrame->Ebp;
        ContextFrame->Eip = TrapFrame->Eip;

        if (((TrapFrame->SegCs & FRAME_EDITED) == 0) &&
            ((TrapFrame->EFlags & EFLAGS_V86_MASK) == 0)) {
            ContextFrame->SegCs = TrapFrame->TempSegCs & SEGMENT_MASK;
        } else {
            ContextFrame->SegCs = TrapFrame->SegCs & SEGMENT_MASK;
        }
        ContextFrame->EFlags = TrapFrame->EFlags;
        ContextFrame->SegSs = KiSegSsFromTrapFrame(TrapFrame);
        ContextFrame->Esp = KiEspFromTrapFrame(TrapFrame);
    }

    //
    // Set segment register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS) {

        //
        // Set segment registers gs, fs, es, ds.
        //
        // These values are junk most of the time, but useful
        // for debugging under certain conditions.  Therefore,
        // we report whatever was in the frame.
        //
        if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
            ContextFrame->SegGs = TrapFrame->V86Gs & SEGMENT_MASK;
            ContextFrame->SegFs = TrapFrame->V86Fs & SEGMENT_MASK;
            ContextFrame->SegEs = TrapFrame->V86Es & SEGMENT_MASK;
            ContextFrame->SegDs = TrapFrame->V86Ds & SEGMENT_MASK;
        }
        else {
            if (TrapFrame->SegCs == KGDT_R0_CODE) {
                //
                // Trap frames created from R0_CODE traps do not save
                // the following selectors.  Set them in the frame now.
                //

                TrapFrame->SegGs = 0;
                TrapFrame->SegFs = KGDT_R0_PCR;
                TrapFrame->SegEs = KGDT_R3_DATA | RPL_MASK;
                TrapFrame->SegDs = KGDT_R3_DATA | RPL_MASK;
            }

            ContextFrame->SegGs = TrapFrame->SegGs & SEGMENT_MASK;
            ContextFrame->SegFs = TrapFrame->SegFs & SEGMENT_MASK;
            ContextFrame->SegEs = TrapFrame->SegEs & SEGMENT_MASK;
            ContextFrame->SegDs = TrapFrame->SegDs & SEGMENT_MASK;
        }

    }

    //
    // Set integer register contents if specified.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers edi, esi, ebx, edx, ecx, eax
        //

        ContextFrame->Edi = TrapFrame->Edi;
        ContextFrame->Esi = TrapFrame->Esi;
        ContextFrame->Ebx = TrapFrame->Ebx;
        ContextFrame->Ecx = TrapFrame->Ecx;
        ContextFrame->Edx = TrapFrame->Edx;
        ContextFrame->Eax = TrapFrame->Eax;
    }

    if (((ContextFrame->ContextFlags & CONTEXT_EXTENDED_REGISTERS) ==
        CONTEXT_EXTENDED_REGISTERS) &&
        ((TrapFrame->SegCs & MODE_MASK) == UserMode)) {

        //
        // This is the base TrapFrame, and the NpxFrame is on the base
        // of the kernel stack, just above it in memory.
        //

        NpxFrame = (PFX_SAVE_AREA)(TrapFrame + 1);

        if (KeI386NpxPresent) {
            KiFlushNPXState (NULL);
            RtlCopyMemory( (PVOID)&(ContextFrame->ExtendedRegisters[0]),
                           (PVOID)&(NpxFrame->U.FxArea),                    
                           MAXIMUM_SUPPORTED_EXTENSION
                         );
        }
    }

    //
    // Fetch floating register contents if requested, and type of target
    // is user.  (system frames have no fp state, so ignore request)
    //
    if ( ((ContextFrame->ContextFlags & CONTEXT_FLOATING_POINT) ==
          CONTEXT_FLOATING_POINT) &&
         ((TrapFrame->SegCs & MODE_MASK) == UserMode)) {

        //
        // This is the base TrapFrame, and the NpxFrame is on the base
        // of the kernel stack, just above it in memory.
        //

        NpxFrame = (PFX_SAVE_AREA)(TrapFrame + 1);

        if (KeI386NpxPresent) {

            //
            // Force the coprocessors state to the save area and copy it
            // to the context frame.
            //

            if (KeI386FxsrPresent == TRUE) {

                //
                // FP state save was done using fxsave. Get the save
                // area in fnsave format
                //
                // Save area must be 16 byte aligned so we cushion it with
                // 15 bytes (in the locals declaration above) and round
                // down to align.
                //

                ULONG_PTR Temp;
                Temp = (ULONG_PTR)&FloatSaveBuffer.SaveArea;
                Temp &= ~0xf;
                PSaveArea = (PFLOATING_SAVE_AREA)Temp;
                KiFlushNPXState (PSaveArea);
            } else {

                PSaveArea = (PFLOATING_SAVE_AREA)&(NpxFrame->U.FnArea);
                KiFlushNPXState (NULL);

            }

            ContextFrame->FloatSave.ControlWord   = PSaveArea->ControlWord;
            ContextFrame->FloatSave.StatusWord    = PSaveArea->StatusWord;
            ContextFrame->FloatSave.TagWord       = PSaveArea->TagWord;
            ContextFrame->FloatSave.ErrorOffset   = PSaveArea->ErrorOffset;
            ContextFrame->FloatSave.ErrorSelector = PSaveArea->ErrorSelector;
            ContextFrame->FloatSave.DataOffset    = PSaveArea->DataOffset;
            ContextFrame->FloatSave.DataSelector  = PSaveArea->DataSelector;
            ContextFrame->FloatSave.Cr0NpxState   = NpxFrame->Cr0NpxState;

            for (i = 0; i < SIZE_OF_80387_REGISTERS; i++) {
                ContextFrame->FloatSave.RegisterArea[i] = PSaveArea->RegisterArea[i];
            }

        } else {

            //
            // The 80387 is being emulated by the R3 emulator.
            // ** The only time the Npx state is ever obtained or set is
            // ** for userlevel handling.  Current Irql must be 0 or 1.
            // Go slurp the emulator's R3 data and generate the
            // floating point context
            //

            StateSaved = KiEm87StateToNpxFrame(&ContextFrame->FloatSave);
            if (StateSaved) {
                ContextFrame->FloatSave.Cr0NpxState = NpxFrame->Cr0NpxState;
            } else {

                //
                // The floatingpoint state can not be determined.
                // Remove the floatingpoint flag from the context frame flags.
                //

                ContextFrame->ContextFlags &= (~CONTEXT_FLOATING_POINT) | CONTEXT_i386;
            }
        }
    }

    //
    // Fetch Dr register contents if requested.  Values may be trash.
    //

    if ((ContextFrame->ContextFlags & CONTEXT_DEBUG_REGISTERS) ==
        CONTEXT_DEBUG_REGISTERS) {

        ContextFrame->Dr0 = TrapFrame->Dr0;
        ContextFrame->Dr1 = TrapFrame->Dr1;
        ContextFrame->Dr2 = TrapFrame->Dr2;
        ContextFrame->Dr3 = TrapFrame->Dr3;
        ContextFrame->Dr6 = TrapFrame->Dr6;

        //
        // If it's a user mode frame, and the thread doesn't have DRs set,
        // and we just return the trash in the frame, we risk accidentally
        // making the thread active with trash values on a set.  Therefore,
        // Dr7 must be set to 0 if we get a non-active user mode frame.
        //

        if ((((TrapFrame->SegCs & MODE_MASK) != KernelMode) ||
            ((TrapFrame->EFlags & EFLAGS_V86_MASK) != 0)) &&
            (KeGetCurrentThread()->DebugActive == TRUE)) {

            ContextFrame->Dr7 = TrapFrame->Dr7;

        } else {

            ContextFrame->Dr7 = 0L;

        }
    }

}

VOID
KeContextToKframes (
    IN OUT PKTRAP_FRAME TrapFrame,
    IN OUT PKEXCEPTION_FRAME ExceptionFrame,
    IN PCONTEXT ContextFrame,
    IN ULONG ContextFlags,
    IN KPROCESSOR_MODE PreviousMode
    )

/*++

Routine Description:

    This routine moves the selected contents of the specified context frame into
    the specified trap and exception frames according to the specified context
    flags.

Arguments:

    TrapFrame - Supplies a pointer to a trap frame that receives the volatile
        context from the context record.

    ExceptionFrame - Supplies a pointer to an exception frame that receives
        the nonvolatile context from the context record. This argument is
        ignored since there is no exception frame on NT386.

    ContextFrame - Supplies a pointer to a context frame that contains the
        context that is to be copied into the trap and exception frames.

    ContextFlags - Supplies the set of flags that specify which parts of the
        context frame are to be copied into the trap and exception frames.

    PreviousMode - Supplies the processor mode for which the trap and exception
        frames are being built.

Return Value:

    None.

--*/

{

    PFX_SAVE_AREA     NpxFrame;
    ULONG i;
    ULONG j;
    ULONG TagWord;
    BOOLEAN StateSaved;
    BOOLEAN ModeChanged;
#if DBG
    PKPCR   Pcr;
    KIRQL   OldIrql;
#endif

    UNREFERENCED_PARAMETER( ExceptionFrame );

    //
    // Set control information if specified.
    //

    if ((ContextFlags & CONTEXT_CONTROL) == CONTEXT_CONTROL) {

        if ((ContextFrame->EFlags & EFLAGS_V86_MASK) !=
            (TrapFrame->EFlags & EFLAGS_V86_MASK)) {
            ModeChanged = TRUE;
        } else {
            ModeChanged = FALSE;
        }


        //
        // Set registers eflag, ebp, eip, cs, esp and ss.
        // Eflags is set first, so that the auxilliary routines
        // can check the v86 bit to determine as well as cs, to
        // determine if the frame is kernel or user mode. (v86 mode cs
        // can have any value)
        //

        TrapFrame->EFlags = SANITIZE_FLAGS(ContextFrame->EFlags, PreviousMode);
        TrapFrame->Ebp = ContextFrame->Ebp;
        TrapFrame->Eip = ContextFrame->Eip;
        if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
            TrapFrame->SegCs = ContextFrame->SegCs;
        } else {
            TrapFrame->SegCs = SANITIZE_SEG(ContextFrame->SegCs, PreviousMode);
            if (PreviousMode != KernelMode && TrapFrame->SegCs < 8) {

                //
                // If user mode and the selector value is less than 8, we
                // know it is an invalid selector.  Set it to flat user
                // mode selector.  Another reason we need to check for this
                // is that any cs value less than 8 causes our exit kernel
                // macro to treat its exit trap fram as an edited frame.
                //

                TrapFrame->SegCs = KGDT_R3_CODE | RPL_MASK;
            }
        }
        KiSegSsToTrapFrame(TrapFrame, ContextFrame->SegSs);
        KiEspToTrapFrame(TrapFrame, ContextFrame->Esp);
        if (ModeChanged) {
            Ki386AdjustEsp0(TrapFrame);             // realign esp0 in the tss
        }
    }

    //
    // Set segment register contents if specified.
    //

    if ((ContextFlags & CONTEXT_SEGMENTS) == CONTEXT_SEGMENTS) {

        //
        // Set segment registers gs, fs, es, ds.
        //

        //
        // There's only one legal value for DS and ES, so simply set it.
        // This allows KeContextFromKframes to report the real values in
        // the frame. (which are junk most of the time, but sometimes useful
        // for debugging.)
        // Only 2 legal values for FS, let either one be set.
        // Force GS to be 0 to deal with entry via SysCall and exit
        // via exception.
        //
        // For V86 mode, the FS, GS, DS, and ES registers must be properly
        // set from the supplied context.
        //

        if (TrapFrame->EFlags & EFLAGS_V86_MASK) {
            TrapFrame->V86Fs = ContextFrame->SegFs;
            TrapFrame->V86Es = ContextFrame->SegEs;
            TrapFrame->V86Ds = ContextFrame->SegDs;
            TrapFrame->V86Gs = ContextFrame->SegGs;
        } else if (((TrapFrame->SegCs & MODE_MASK) == KernelMode)) {

            //
            // set up the standard selectors
            //

            TrapFrame->SegFs = SANITIZE_SEG(ContextFrame->SegFs, PreviousMode);
            TrapFrame->SegEs = KGDT_R3_DATA | RPL_MASK;
            TrapFrame->SegDs = KGDT_R3_DATA | RPL_MASK;
            TrapFrame->SegGs = 0;
        } else {

            //
            // If user mode, we simply return whatever left in context frame
            // and let trap 0d handle it (if later we trap while popping the
            // trap frame.) V86 mode also get handled here.
            //

            TrapFrame->SegFs = ContextFrame->SegFs;
            TrapFrame->SegEs = ContextFrame->SegEs;
            TrapFrame->SegDs = ContextFrame->SegDs;
            if (TrapFrame->SegCs == (KGDT_R3_CODE | RPL_MASK)) {
                TrapFrame->SegGs = 0;
            } else {
                TrapFrame->SegGs = ContextFrame->SegGs;
            }
        }
    }
    //
    // Set integer registers contents if specified.
    //

    if ((ContextFlags & CONTEXT_INTEGER) == CONTEXT_INTEGER) {

        //
        // Set integer registers edi, esi, ebx, edx, ecx, eax.
        //
        //  Can NOT call RtlCopyMemory here because the regs aren't
        //  contiguous in pusha frame, and we don't want to export
        //  bits of junk into context record.
        //

        TrapFrame->Edi = ContextFrame->Edi;
        TrapFrame->Esi = ContextFrame->Esi;
        TrapFrame->Ebx = ContextFrame->Ebx;
        TrapFrame->Ecx = ContextFrame->Ecx;
        TrapFrame->Edx = ContextFrame->Edx;
        TrapFrame->Eax = ContextFrame->Eax;

    }

    //
    // Set extended register contents if requested, and type of target
    // is user.  (system frames have no extended state, so ignore request)
    //

    if (((ContextFlags & CONTEXT_EXTENDED_REGISTERS) == CONTEXT_EXTENDED_REGISTERS) &&
        ((TrapFrame->SegCs & MODE_MASK) == UserMode)) {

        //
        // This is the base TrapFrame, and the NpxFrame is on the base
        // of the kernel stack, just above it in memory.
        //

        NpxFrame = (PFX_SAVE_AREA)(TrapFrame + 1);

        if (KeI386NpxPresent) {
            KiFlushNPXState (NULL);
            RtlCopyMemory( (PVOID)&(NpxFrame->U.FxArea),
                      (PVOID)&(ContextFrame->ExtendedRegisters[0]),
                           MAXIMUM_SUPPORTED_EXTENSION
                         );
            //
            // Make sure only valid floating state bits are moved to Cr0NpxState.
            //

            NpxFrame->Cr0NpxState &= ~(CR0_EM | CR0_MP | CR0_TS);

            //
            // Make sure all reserved bits are clear in MXCSR so we don't get a GP
            // fault when doing an FRSTOR on this state.
            //
            NpxFrame->U.FxArea.MXCsr = SANITIZE_MXCSR(NpxFrame->U.FxArea.MXCsr);

            //
            // Only let VDMs turn on the EM bit.  The kernel can't do
            // anything for FLAT apps
            //
            if (PsGetCurrentProcess()->VdmObjects != NULL) {
                NpxFrame->Cr0NpxState |= ContextFrame->FloatSave.Cr0NpxState &
                                      (CR0_EM | CR0_MP);
            }
        }
    }

    //
    // Set floating register contents if requested, and type of target
    // is user.  (system frames have no fp state, so ignore request)
    //

    if (((ContextFlags & CONTEXT_FLOATING_POINT) == CONTEXT_FLOATING_POINT) &&
        ((TrapFrame->SegCs & MODE_MASK) == UserMode)) {

        //
        // This is the base TrapFrame, and the NpxFrame is on the base
        // of the kernel stack, just above it in memory.
        //

        NpxFrame = (PFX_SAVE_AREA)(TrapFrame + 1);

        if (KeI386NpxPresent) {

            //
            // Set coprocessor stack, control and status registers
            //

            KiFlushNPXState (NULL);

            if (KeI386FxsrPresent == TRUE) {

                //
                // Restore FP state in the fxrstor format
                //

                NpxFrame->U.FxArea.ControlWord   =
                                    (USHORT)ContextFrame->FloatSave.ControlWord;
                NpxFrame->U.FxArea.StatusWord    =
                                    (USHORT)ContextFrame->FloatSave.StatusWord;

                //
                // Construct the tag word from fnsave format to fxsave format
                //

                NpxFrame->U.FxArea.TagWord = 0; // Mark every register invalid

                TagWord = ContextFrame->FloatSave.TagWord;

                for (i = 0; i < FN_BITS_PER_TAGWORD; i+=2) {

                    if (((TagWord >> i) & FN_TAG_MASK) != FN_TAG_EMPTY) {

                        //
                        // This register is valid
                        //

                        NpxFrame->U.FxArea.TagWord |= (FX_TAG_VALID << (i/2));
                    }
                }

                NpxFrame->U.FxArea.ErrorOffset   =
                                        ContextFrame->FloatSave.ErrorOffset;
                NpxFrame->U.FxArea.ErrorSelector =
                               (ContextFrame->FloatSave.ErrorSelector & 0xFFFF);
                NpxFrame->U.FxArea.ErrorOpcode =
                    (USHORT)((ContextFrame->FloatSave.ErrorSelector >> 16) & 0xFFFF);
                NpxFrame->U.FxArea.DataOffset    =
                                ContextFrame->FloatSave.DataOffset;
                NpxFrame->U.FxArea.DataSelector  =
                                ContextFrame->FloatSave.DataSelector;

                //
                // Fxrstor format has each FP register in 128 bits (16 bytes)
                // where as fnsave saves each FP register in 80 bits (10 bytes)
                //
                RtlZeroMemory ((PVOID)&NpxFrame->U.FxArea.RegisterArea[0],
                               SIZE_OF_FX_REGISTERS
                              );

                for (i = 0; i < NUMBER_OF_FP_REGISTERS; i++) {
                    for (j = 0; j < BYTES_PER_FP_REGISTER; j++) {
                        NpxFrame->U.FxArea.RegisterArea[i*BYTES_PER_FX_REGISTER+j] =
                                ContextFrame->FloatSave.RegisterArea[i*BYTES_PER_FP_REGISTER+j];
                    }
                }

            } else {
                NpxFrame->U.FnArea.ControlWord   =
                                        ContextFrame->FloatSave.ControlWord;
                NpxFrame->U.FnArea.StatusWord    =
                                        ContextFrame->FloatSave.StatusWord;
                NpxFrame->U.FnArea.TagWord       =
                                        ContextFrame->FloatSave.TagWord;
                NpxFrame->U.FnArea.ErrorOffset   =
                                        ContextFrame->FloatSave.ErrorOffset;
                NpxFrame->U.FnArea.ErrorSelector =
                                        ContextFrame->FloatSave.ErrorSelector;
                NpxFrame->U.FnArea.DataOffset    =
                                        ContextFrame->FloatSave.DataOffset;
                NpxFrame->U.FnArea.DataSelector  =
                                        ContextFrame->FloatSave.DataSelector;

                for (i = 0; i < SIZE_OF_80387_REGISTERS; i++) {
                    NpxFrame->U.FnArea.RegisterArea[i] =
                            ContextFrame->FloatSave.RegisterArea[i];
                }

            }

            //
            // Make sure only valid floating state bits are moved to Cr0NpxState.
            //

            NpxFrame->Cr0NpxState &= ~(CR0_EM | CR0_MP | CR0_TS);

            //
            // Only let VDMs turn on the EM bit.  The kernel can't do
            // anything for FLAT apps
            //
            if (PsGetCurrentProcess()->VdmObjects != NULL) {
                NpxFrame->Cr0NpxState |= ContextFrame->FloatSave.Cr0NpxState &
                                      (CR0_EM | CR0_MP);
            }

        } else {

            if (PsGetCurrentProcess()->VdmObjects != NULL) {

                //
                // This is a special hack to allow SetContext for VDMs to
                // turn on/off it's CR0_EM bit.
                //

                NpxFrame->Cr0NpxState &= ~(CR0_MP | CR0_TS | CR0_EM | CR0_PE);
                NpxFrame->Cr0NpxState |=
                    VdmUserCr0MapIn[ContextFrame->FloatSave.Cr0NpxState & (CR0_EM | CR0_MP)];

            } else {

                //
                // The 80387 is being emulated by the R3 emulator.
                // ** The only time the Npx state is ever obtained or set is
                // ** for userlevel handling.  Current Irql must be 0 or 1.
                // And the context being set must be for the current thread.
                // Go smash the floatingpoint context into the R3 emulator's
                // data area.
                //
#if DBG
                OldIrql = KeRaiseIrqlToSynchLevel();
                Pcr = KeGetPcr();
                ASSERT (Pcr->Prcb->CurrentThread->Teb == Pcr->NtTib.Self);
                KeLowerIrql (OldIrql);
#endif

                StateSaved = KiNpxFrameToEm87State(&ContextFrame->FloatSave);
                if (StateSaved) {

                    //
                    // Make sure only valid floating state bits are moved to
                    // Cr0NpxState.  Since we are emulating, don't allow
                    // resetting CR0_EM.
                    //

                    NpxFrame->Cr0NpxState &= ~(CR0_MP | CR0_TS);
                    NpxFrame->Cr0NpxState |=
                        ContextFrame->FloatSave.Cr0NpxState & CR0_MP;
                }
            }
        }
    }

    //
    // Set debug register state if specified.  If previous mode is user
    // mode (i.e. it's a user frame we're setting) and if effect will be to
    // cause at least one of the LE (local enable) bits in Dr7 to be
    // set (i.e. at least one of Dr0,1,2,3 are active) then set DebugActive
    // in the thread object to true.  Otherwise set it to false.
    //

    if ((ContextFlags & CONTEXT_DEBUG_REGISTERS) == CONTEXT_DEBUG_REGISTERS) {

        TrapFrame->Dr0 = SANITIZE_DRADDR(ContextFrame->Dr0, PreviousMode);
        TrapFrame->Dr1 = SANITIZE_DRADDR(ContextFrame->Dr1, PreviousMode);
        TrapFrame->Dr2 = SANITIZE_DRADDR(ContextFrame->Dr2, PreviousMode);
        TrapFrame->Dr3 = SANITIZE_DRADDR(ContextFrame->Dr3, PreviousMode);
        TrapFrame->Dr6 = SANITIZE_DR6(ContextFrame->Dr6, PreviousMode);
        TrapFrame->Dr7 = SANITIZE_DR7(ContextFrame->Dr7, PreviousMode);

        if (PreviousMode != KernelMode) {
            KeGetPcr()->DebugActive = KeGetCurrentThread()->DebugActive =
                (BOOLEAN)((ContextFrame->Dr7 & DR7_ACTIVE) != 0);
        }
    }

    //
    // If thread is supposed to have IOPL, then force it on in eflags
    //
    if (KeGetCurrentThread()->Iopl) {
        TrapFrame->EFlags |= (EFLAGS_IOPL_MASK & -1);  // IOPL = 3
    }

    return;
}

VOID
KiDispatchException (
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PKEXCEPTION_FRAME ExceptionFrame,
    IN PKTRAP_FRAME TrapFrame,
    IN KPROCESSOR_MODE PreviousMode,
    IN BOOLEAN FirstChance
    )

/*++

Routine Description:

    This function is called to dispatch an exception to the proper mode and
    to cause the exception dispatcher to be called. If the previous mode is
    kernel, then the exception dispatcher is called directly to process the
    exception. Otherwise the exception record, exception frame, and trap
    frame contents are copied to the user mode stack. The contents of the
    exception frame and trap are then modified such that when control is
    returned, execution will commense in user mode in a routine which will
    call the exception dispatcher.

Arguments:

    ExceptionRecord - Supplies a pointer to an exception record.

    ExceptionFrame - Supplies a pointer to an exception frame. For NT386,
        this should be NULL.

    TrapFrame - Supplies a pointer to a trap frame.

    PreviousMode - Supplies the previous processor mode.

    FirstChance - Supplies a boolean value that specifies whether this is
        the first (TRUE) or second (FALSE) chance for the exception.

Return Value:

    None.

--*/

{
    CONTEXT ContextFrame;
    EXCEPTION_RECORD ExceptionRecord1, ExceptionRecord2;
    LONG Length;
    ULONG UserStack1;
    ULONG UserStack2;

    //
    // Move machine state from trap and exception frames to a context frame,
    // and increment the number of exceptions dispatched.
    //

    KeGetCurrentPrcb()->KeExceptionDispatchCount += 1;
    ContextFrame.ContextFlags = CONTEXT_FULL | CONTEXT_DEBUG_REGISTERS;
    if (PreviousMode == UserMode) {
        //
        // For usermode exceptions always try to dispatch the floating
        // point state.  This allows expection handlers & debuggers to
        // examine/edit the npx context if required.  Plus it allows
        // exception handlers to use fp instructions without detroying
        // the npx state at the time of the exception.
        //
        // Note: If there's no 80387, ContextTo/FromKFrames will use the
        // emulator's current state.  If the emulator can not give the
        // current state, then the context_floating_point bit will be
        // turned off by ContextFromKFrames.
        //

        ContextFrame.ContextFlags |= CONTEXT_FLOATING_POINT;
        if (KeI386XMMIPresent) {
            ContextFrame.ContextFlags |= CONTEXT_EXTENDED_REGISTERS;
        }
    }

    KeContextFromKframes(TrapFrame, ExceptionFrame, &ContextFrame);

    //
    // if it is BREAK_POINT exception, we subtract 1 from EIP and report
    // the updated EIP to user.  This is because Cruiser requires EIP
    // points to the int 3 instruction (not the instruction following int 3).
    // In this case, BreakPoint exception is fatal. Otherwise we will step
    // on the int 3 over and over again, if user does not handle it
    //
    // if the BREAK_POINT occured in V86 mode, the debugger running in the
    // VDM will expect CS:EIP to point after the exception (the way the
    // processor left it.  this is also true for protected mode dos
    // app debuggers.  We will need a way to detect this.
    //
    //

//    if ((ExceptionRecord->ExceptionCode == STATUS_BREAKPOINT) &&
//      !(ContextFrame.EFlags & EFLAGS_V86_MASK)) {

    switch (ExceptionRecord->ExceptionCode) {
        case STATUS_BREAKPOINT:
            ContextFrame.Eip--;
            break;
    }

    //
    // Select the method of handling the exception based on the previous mode.
    //

    ASSERT ((
             !((PreviousMode == KernelMode) &&
             (ContextFrame.EFlags & EFLAGS_V86_MASK))
           ));

    if (PreviousMode == KernelMode) {

        //
        // Previous mode was kernel.
        //
        // If the kernel debugger is active, then give the kernel debugger the
        // first chance to handle the exception. If the kernel debugger handles
        // the exception, then continue execution. Else attempt to dispatch the
        // exception to a frame based handler. If a frame based handler handles
        // the exception, then continue execution.
        //
        // If a frame based handler does not handle the exception,
        // give the kernel debugger a second chance, if it's present.
        //
        // If the exception is still unhandled, call KeBugCheck().
        //

        if (FirstChance == TRUE) {

            if ((KiDebugRoutine != NULL) &&
               (((KiDebugRoutine) (TrapFrame,
                                   ExceptionFrame,
                                   ExceptionRecord,
                                   &ContextFrame,
                                   PreviousMode,
                                   FALSE)) != FALSE)) {

                goto Handled1;
            }

            // Kernel debugger didn't handle exception.

            if (RtlDispatchException(ExceptionRecord, &ContextFrame) == TRUE) {
                goto Handled1;
            }
        }

        //
        // This is the second chance to handle the exception.
        //

        if ((KiDebugRoutine != NULL) &&
            (((KiDebugRoutine) (TrapFrame,
                                ExceptionFrame,
                                ExceptionRecord,
                                &ContextFrame,
                                PreviousMode,
                                TRUE)) != FALSE)) {

            goto Handled1;
        }

        KeBugCheckEx(
            KERNEL_MODE_EXCEPTION_NOT_HANDLED,
            ExceptionRecord->ExceptionCode,
            (ULONG)ExceptionRecord->ExceptionAddress,
            (ULONG)TrapFrame,
            0);

    } else {

        //
        // Previous mode was user.
        //
        // If this is the first chance and the current process has a debugger
        // port, then send a message to the debugger port and wait for a reply.
        // If the debugger handles the exception, then continue execution. Else
        // transfer the exception information to the user stack, transition to
        // user mode, and attempt to dispatch the exception to a frame based
        // handler. If a frame based handler handles the exception, then continue
        // execution with the continue system service. Else execute the
        // NtRaiseException system service with FirstChance == FALSE, which
        // will call this routine a second time to process the exception.
        //
        // If this is the second chance and the current process has a debugger
        // port, then send a message to the debugger port and wait for a reply.
        // If the debugger handles the exception, then continue execution. Else
        // if the current process has a subsystem port, then send a message to
        // the subsystem port and wait for a reply. If the subsystem handles the
        // exception, then continue execution. Else terminate the thread.
        //


        if (FirstChance == TRUE) {

            //
            // This is the first chance to handle the exception.
            //

            if ((KiDebugRoutine != NULL)  &&
                ((PsGetCurrentProcess()->DebugPort == NULL) ||
                 (KdIsThisAKdTrap(ExceptionRecord, &ContextFrame, UserMode))))
            {
                //
                // Now dispatch the fault to the kernel debugger.
                //

                if ((((KiDebugRoutine) (TrapFrame,
                                        ExceptionFrame,
                                        ExceptionRecord,
                                        &ContextFrame,
                                        PreviousMode,
                                        FALSE)) != FALSE)) {

                    goto Handled1;
                }
            }

            if (DbgkForwardException(ExceptionRecord, TRUE, FALSE)) {
                goto Handled2;
            }

            //
            // Transfer exception information to the user stack, transition
            // to user mode, and attempt to dispatch the exception to a frame
            // based handler.

        repeat:
            try {

                //
                // If the SS segment is not 32 bit flat, there is no point
                // to dispatch exception to frame based exception handler.
                //

                if (TrapFrame->HardwareSegSs != (KGDT_R3_DATA | RPL_MASK) ||
                    TrapFrame->EFlags & EFLAGS_V86_MASK ) {
                    ExceptionRecord2.ExceptionCode = STATUS_ACCESS_VIOLATION;
                    ExceptionRecord2.ExceptionFlags = 0;
                    ExceptionRecord2.NumberParameters = 0;
                    ExRaiseException(&ExceptionRecord2);
                }

                //
                // Compute length of context record and new aligned user stack
                // pointer.
                //

                Length = (sizeof(CONTEXT) + CONTEXT_ROUND) & ~CONTEXT_ROUND;
                UserStack1 = (ContextFrame.Esp & ~CONTEXT_ROUND) - Length;

                //
                // Probe user stack area for writability and then transfer the
                // context record to the user stack.
                //

                ProbeForWrite((PCHAR)UserStack1, Length, CONTEXT_ALIGN);
                RtlCopyMemory((PULONG)UserStack1, &ContextFrame, sizeof(CONTEXT));

                //
                // Compute length of exception record and new aligned stack
                // address.
                //

                Length = (sizeof(EXCEPTION_RECORD) - (EXCEPTION_MAXIMUM_PARAMETERS -
                         ExceptionRecord->NumberParameters) * sizeof(ULONG) +3) &
                         (~3);
                UserStack2 = UserStack1 - Length;

                //
                // Probe user stack area for writeability and then transfer the
                // context record to the user stack area.
                // N.B. The probing length is Length+8 because there are two
                //      arguments need to be pushed to user stack later.
                //

                ProbeForWrite((PCHAR)(UserStack2 - 8), Length + 8, sizeof(ULONG));
                RtlCopyMemory((PULONG)UserStack2, ExceptionRecord, Length);

                //
                // Push address of exception record, context record to the
                // user stack.  They are the two parameters required by
                // _KiUserExceptionDispatch.
                //

                *(PULONG)(UserStack2 - sizeof(ULONG)) = UserStack1;
                *(PULONG)(UserStack2 - 2*sizeof(ULONG)) = UserStack2;

                //
                // Set new stack pointer to the trap frame.
                //

                KiSegSsToTrapFrame(TrapFrame, KGDT_R3_DATA);
                KiEspToTrapFrame(TrapFrame, (UserStack2 - sizeof(ULONG)*2));

                //
                // Force correct R3 selectors into TrapFrame.
                //

                TrapFrame->SegCs = SANITIZE_SEG(KGDT_R3_CODE, PreviousMode);
                TrapFrame->SegDs = SANITIZE_SEG(KGDT_R3_DATA, PreviousMode);
                TrapFrame->SegEs = SANITIZE_SEG(KGDT_R3_DATA, PreviousMode);
                TrapFrame->SegFs = SANITIZE_SEG(KGDT_R3_TEB, PreviousMode);
                TrapFrame->SegGs = 0;

                //
                // Set the address of the exception routine that will call the
                // exception dispatcher and then return to the trap handler.
                // The trap handler will restore the exception and trap frame
                // context and continue execution in the routine that will
                // call the exception dispatcher.
                //

                TrapFrame->Eip = (ULONG)KeUserExceptionDispatcher;
                return;

            } except (KiCopyInformation(&ExceptionRecord1,
                        (GetExceptionInformation())->ExceptionRecord)) {

                //
                // If the exception is a stack overflow, then attempt
                // to raise the stack overflow exception. Otherwise,
                // the user's stack is not accessible, or is misaligned,
                // and second chance processing is performed.
                //

                if (ExceptionRecord1.ExceptionCode == STATUS_STACK_OVERFLOW) {
                    ExceptionRecord1.ExceptionAddress = ExceptionRecord->ExceptionAddress;
                    RtlCopyMemory((PVOID)ExceptionRecord,
                                  &ExceptionRecord1, sizeof(EXCEPTION_RECORD));
                    goto repeat;
                }
            }
        }

        //
        // This is the second chance to handle the exception.
        //

        if (DbgkForwardException(ExceptionRecord, TRUE, TRUE)) {
            goto Handled2;
        } else if (DbgkForwardException(ExceptionRecord, FALSE, TRUE)) {
            goto Handled2;
        } else {
            ZwTerminateThread(NtCurrentThread(), ExceptionRecord->ExceptionCode);
            KeBugCheckEx(
                KERNEL_MODE_EXCEPTION_NOT_HANDLED,
                ExceptionRecord->ExceptionCode,
                (ULONG)ExceptionRecord->ExceptionAddress,
                (ULONG)TrapFrame,
                0);
        }
    }

    //
    // Move machine state from context frame to trap and exception frames and
    // then return to continue execution with the restored state.
    //

Handled1:

    KeContextToKframes(TrapFrame, ExceptionFrame, &ContextFrame,
                       ContextFrame.ContextFlags, PreviousMode);

    //
    // Exception was handled by the debugger or the associated subsystem
    // and state was modified, if necessary, using the get state and set
    // state capabilities. Therefore the context frame does not need to
    // be transfered to the trap and exception frames.
    //

Handled2:
    return;
}

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    )

/*++

Routine Description:

    This function is called from an exception filter to copy the exception
    information from one exception record to another when an exception occurs.

Arguments:

    ExceptionRecord1 - Supplies a pointer to the destination exception record.

    ExceptionRecord2 - Supplies a pointer to the source exception record.

Return Value:

    A value of EXCEPTION_EXECUTE_HANDLER is returned as the function value.

--*/

{

    //
    // Copy one exception record to another and return value that causes
    // an exception handler to be executed.
    //

    RtlCopyMemory((PVOID)ExceptionRecord1,
                  (PVOID)ExceptionRecord2,
                  sizeof(EXCEPTION_RECORD));

    return EXCEPTION_EXECUTE_HANDLER;
}


NTSTATUS
KeRaiseUserException(
    IN NTSTATUS ExceptionCode
    )

/*++

Routine Description:

    This function causes an exception to be raised in the calling thread's user-mode
    context. It does this by editing the trap frame the kernel was entered with to
    point to trampoline code that raises the requested exception.

Arguments:

    ExceptionCode - Supplies the status value to be used as the exception
        code for the exception that is to be raised.

Return Value:

    The status value that should be returned by the caller.

--*/

{
    PKTHREAD Thread;
    PKTRAP_FRAME TrapFrame;
    PTEB Teb;
    ULONG PreviousEsp;

    ASSERT(KeGetPreviousMode() == UserMode);

    Thread = KeGetCurrentThread();
    TrapFrame = Thread->TrapFrame;
    if (TrapFrame == NULL) {
        return ExceptionCode;
    }

    Teb = (PTEB)Thread->Teb;

    //
    // In order to create the correct call stack, we push the old return
    // address onto the stack. The status code to be raised is passed
    // in the TEB.
    //

    try {
        Teb->ExceptionCode = ExceptionCode;

        PreviousEsp = KiEspFromTrapFrame (TrapFrame) - sizeof (ULONG);

        ProbeForWriteSmallStructure ((PLONG)PreviousEsp, sizeof (LONG), sizeof (UCHAR));
        *(PLONG)PreviousEsp = TrapFrame->Eip;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        return(ExceptionCode);
    }

    KiEspToTrapFrame (TrapFrame, PreviousEsp);

    TrapFrame->Eip = (ULONG)KeRaiseUserExceptionDispatcher;

    return ExceptionCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\i386pcr.asm ===
title  "I386 PCR"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    i386pcr.asm
;
; Abstract:
;
;    This module implements routines for accessing and initing the pcr.
;
; Author:
;
;    Bryan Willman (bryanwi) 20 Mar 90
;
; Environment:
;
;    Kernel mode, early init of first processor.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list

;
;   NOTE - This definition of PCR gives us 2 instructions to get to some
;       variables that need to be addressable in one instruction.  Any
;       such variable (such as current thread) must be accessed via its
;       own access procedure (see below), NOT by KeGetPcr()->PbCurrentThread.
;       (This is only an issue on MP machines.)
;

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; PKTHREAD
; KeGetCurrentThread()
;
; Return Value:
;
;   Pointer to current Thread object.
;
;--
cPublicProc ___KeGetCurrentThread   ,0

        mov     eax,PCR[PcPrcbData+PbCurrentThread]
        stdRET    ___KeGetCurrentThread

stdENDP ___KeGetCurrentThread


;++
;
; KPROCESSOR_MODE
; KeGetPreviousMode()
;
; Return Value:
;
;   PreviousMode of current thread.
;
;--
cPublicProc _KeGetPreviousMode

        mov     eax,PCR[PcPrcbData+PbCurrentThread] ; (eax) -> Thread
        movzx   eax,byte ptr [eax]+ThPreviousMode   ; (eax) = PreviousMode
        stdRET    _KeGetPreviousMode

stdENDP _KeGetPreviousMode


;++
;
; BOOLEAN
; KeIsExecutingDpc(
;       VOID
;       );
;
; Return Value:
;
;   Value of flag which indicates whether we're executing in DPC context
;
;--

cPublicProc ___KeIsExecutingDpc   ,0

        mov     eax,PCR[PcPrcbData.PbDpcRoutineActive]
        stdRET    ___KeIsExecutingDpc

stdENDP ___KeIsExecutingDpc


;++
;
; VOID
; GetMachineBootPointers(
;       )
;
; Routine Description:
;
;   This routine is called at system startup to extract the address of
;   the PCR and machine control values.  It is useful only for the P0
;   case where the boot loader must already init the machine before it
;   turns on paging and calls us.
;
;   Pcr address is extracted from the base of KGDT_R0_PCR.
;
;   Gdt and Idt are extracted from the machine GDTR and IDTR.
;
;   TSS is derived from the TSR and related descriptor.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;
;   (edi) -> gdt
;   (esi) -> pcr
;   (edx) -> tss
;   (eax) -> idt
;
;--

cPublicProc GetMachineBootPointers

        push    ebp
        mov     ebp,esp
        sub     esp,8

        sgdt    fword ptr [ebp-8]
        mov     edi,[ebp-6]             ; (edi) = gdt address

        mov     cx,fs
        and     cx,(NOT RPL_MASK)
        movzx   ecx,cx
        add     ecx,edi                 ; (ecx) -> pcr descriptor

        mov     dh,[ecx+KgdtBaseHi]
        mov     dl,[ecx+KgdtBaseMid]
        shl     edx,16
        mov     dx,[ecx+KgdtBaseLow]    ; (edx) -> pcr
        mov     esi,edx                 ; (esi) -> pcr

        str     cx
        movzx   ecx,cx
        add     ecx,edi                 ; (ecx) -> TSS descriptor

        mov     dh,[ecx+KgdtBaseHi]
        mov     dl,[ecx+KgdtBaseMid]
        shl     edx,16
        mov     dx,[ecx+KgdtBaseLow]    ; (edx) -> TSS

        sidt    fword ptr [ebp-8]
        mov     eax,[ebp-6]             ; (eax) -> Idt

        mov     esp,ebp
        pop     ebp
        stdRET    GetMachineBootPointers

stdENDP GetMachineBootPointers

_TEXT$00   ENDS
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\i386init.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    i386init.c

Abstract:

    This module contains code to manipulate i386 hardware structures used
    only by the kernel.

Author:

    Bryan Willman  22 Feb 90

Revision History:

--*/

#include    "ki.h"

VOID
KiInitializeMachineType (
    VOID
    );

#pragma alloc_text(INIT,KiInitializeMachineType)

KIRQL   KiProfileIrql = PROFILE_LEVEL;
ULONG   KeI386MachineType = 0;
BOOLEAN KeI386NpxPresent;
BOOLEAN KeI386FxsrPresent;
ULONG   KeI386ForceNpxEmulation;
ULONG   KiMXCsrMask;
ULONG   KeI386CpuType;
ULONG   KeI386CpuStep;
PVOID   Ki387RoundModeTable;    // R3 emulators RoundingMode vector table
ULONG   KiBootFeatureBits;

ULONG KiInBiosCall = FALSE;
ULONG FlagState = 0;                    // bios calls shouldn't automatically turn interrupts back on.

KTRAP_FRAME KiBiosFrame;

#if DBG
UCHAR   MsgDpcTrashedEsp[] = "\n*** DPC routine %lx trashed ESP\n";
UCHAR   MsgDpcTimeout[]    = "\n*** DPC routine > 1 sec --- This is not a break in KeUpdateSystemTime\n";
UCHAR   MsgISRTimeout[]    = "\n*** ISR at %lx took over .5 second\n";

ULONG   KiDPCTimeout       = 110;
ULONG   KiISRTimeout       = 55;
ULONG   KiSpinlockTimeout  = 55;
#endif
UCHAR   MsgISROverflow[]    = "\n*** ISR at %lx appears to have an interrupt storm\n";
USHORT  KiISROverflow      = 30000;

VOID
KiInitializeMachineType (
    VOID
    )

/*++

Routine Description:

    This function initializes machine type, i.e. MCA, ABIOS, ISA
    or EISA.
    N.B.  This is a temporary routine.  machine type:
          Byte 0 - Machine Type, ISA, EISA or MCA
          Byte 1 - CPU type, i386 or i486
          Byte 2 - Cpu Step, A or B ... etc.
          Highest bit indicates if NPX is present.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KeI386MachineType = KeLoaderBlock->u.I386.MachineType & 0x000ff;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\instemul.asm ===
title  "Vdm Instuction Emulation"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    instemul.asm
;
; Abstract:
;
;    This module contains the routines for emulating instructions and
;    faults to a VDM.
;
; Author:
;
;   Dave Hastings (daveh) 29-March-1991
;
; Environment:
;
;    Kernel mode only.
;
; Notes:
;
;
;sudeepb 09-Dec-1992 Very Sonn this file will be deleted and protected
;                    mode instruction emulation will be merged in
;                    emv86.asm. Particularly following routines will
;                    simply become OpcodeInvalid.
;               OpcodeIret
;               OpcodePushf
;               OpcodePopf
;               OpcodeHlt
;                    Other routines such as
;               OpcodeCli
;               OpcodeSti
;               OpcodeIN/OUT/SB/Immb etc
;                    will map exactly like emv86.asm
;               OpcodeInt will be the main differeing routine.
;
;               OpcodeDispatch Table will be deleted.
;
;       So before making any major changes in this file please see
;       Sudeepb or Daveh.
;
;neilsa 19-Oct-1993 Size and performance enhancements
;jonle 15-Nov-1993 - The Debug messages for each opcode may no longer work
;             correctly, because interrupts may not have been enabled
;
;
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include mac386.inc
include i386\mi.inc
include callconv.inc
include ..\..\vdm\i386\vdm.inc
include vdmtib.inc
        .list

        extrn   VdmOpcode0f:proc
        extrn   OpcodeNPXV86:proc
        extrn   VdmDispatchIntAck:proc   ;; only OpcodeSti uses this
ifdef VDMDBG
        EXTRNP  _VdmTraceEvent,4
endif
        extrn   CommonDispatchException:proc ;; trap.asm
        extrn   _DbgPrint:proc
        extrn   _KeI386VdmIoplAllowed:dword
        extrn   _KeI386VirtualIntExtensions:dword
        extrn   _MmHighestUserAddress:dword
        EXTRNP  _Ki386GetSelectorParameters,4
        EXTRNP  _Ki386VdmDispatchIo,5
        EXTRNP  _Ki386VdmDispatchStringIo,8
        EXTRNP  _KiDispatchException,5
        EXTRNP  _VdmPrinterStatus,3
        EXTRNP  KfLowerIrql,1,IMPORT, FASTCALL
        EXTRNP  _VdmPrinterWriteData, 3
        EXTRNP  _VdmClearPMCliTimeStamp, 0
        EXTRNP  _VdmSetPMCliTimeStamp, 1
        extrn   _MmUserProbeAddress:DWORD
        EXTRNP  _VdmFetchULONG,1

        page ,132

ifdef VDMDBG
%out Debugging version
endif

;
;   Force assume into place
;

_PAGE   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_PAGE   ENDS

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:NOTHING, FS:NOTHING, GS:NOTHING
_TEXT$00   ENDS

PAGECONST   SEGMENT  DWORD PUBLIC 'DATA'


;
;  Instruction emulation emulates the following instructions.
;  The emulation affects the noted user mode registers.
;
;  In protected mode, the following instructions are emulated in the kernel
;
;    Registers  (E)Flags (E)SP  SS  CS
;       INTnn      X       X     X   X
;       INTO       X       X     X   X
;       CLI        X
;       STI        X
;
;  The following instructions are always emulated by reflection to the
;  Usermode VDM monitor
;
;       INSB
;       INSW
;       OUTSB
;       OUTSW
;       INBimm
;       INWimm
;       OUTBimm
;       OUTWimm
;       INB
;       INW
;       OUTB
;       OUTW
;
;  WARNING What do we do about 32 bit io instructions??


;
;       OpcodeIndex - packed 1st level table to index OpcodeDispatch table
;
        public OpcodeIndex
diBEGIN OpcodeIndex,VDM_INDEX_Invalid
        dtI      0fh, VDM_INDEX_0F
        dtI      26h, VDM_INDEX_ESPrefix
        dtI      2eh, VDM_INDEX_CSPrefix
        dtI      36h, VDM_INDEX_SSPrefix
        dtI      3eh, VDM_INDEX_DSPrefix
        dtI      64h, VDM_INDEX_FSPrefix
        dtI      65h, VDM_INDEX_GSPrefix
        dtI      66h, VDM_INDEX_OPER32Prefix
        dtI      67h, VDM_INDEX_ADDR32Prefix
        dtI      6ch, VDM_INDEX_INSB
        dtI      6dh, VDM_INDEX_INSW
        dtI      6eh, VDM_INDEX_OUTSB
        dtI      6fh, VDM_INDEX_OUTSW
        dtI      9bh, VDM_INDEX_NPX
        dtI      9ch, VDM_INDEX_PUSHF
        dtI      9dh, VDM_INDEX_POPF
        dtI     0cdh, VDM_INDEX_INTnn
        dtI     0ceh, VDM_INDEX_INTO
        dtI     0cfh, VDM_INDEX_IRET
        dtI     0d8h, VDM_INDEX_NPX
        dtI     0d9h, VDM_INDEX_NPX
        dtI     0dah, VDM_INDEX_NPX
        dtI     0dbh, VDM_INDEX_NPX
        dtI     0dch, VDM_INDEX_NPX
        dtI     0ddh, VDM_INDEX_NPX
        dtI     0deh, VDM_INDEX_NPX
        dtI     0dfh, VDM_INDEX_NPX
        dtI     0e4h, VDM_INDEX_INBimm
        dtI     0e5h, VDM_INDEX_INWimm
        dtI     0e6h, VDM_INDEX_OUTBimm
        dtI     0e7h, VDM_INDEX_OUTWimm
        dtI     0ech, VDM_INDEX_INB
        dtI     0edh, VDM_INDEX_INW
        dtI     0eeh, VDM_INDEX_OUTB
        dtI     0efh, VDM_INDEX_OUTW
        dtI     0f0h, VDM_INDEX_LOCKPrefix
        dtI     0f2h, VDM_INDEX_REPNEPrefix
        dtI     0f3h, VDM_INDEX_REPPrefix
        dtI     0f4h, VDM_INDEX_HLT
        dtI     0fah, VDM_INDEX_CLI
        dtI     0fbh, VDM_INDEX_STI
diEND   NUM_OPCODE

;
;       OpcodeDispatch - table of routines used to emulate instructions
;

        public OpcodeDispatch
dtBEGIN OpcodeDispatch,OpcodeInvalid
        dtS     VDM_INDEX_0F          , Opcode0F
        dtS     VDM_INDEX_ESPrefix    , OpcodeESPrefix
        dtS     VDM_INDEX_CSPrefix    , OpcodeCSPrefix
        dtS     VDM_INDEX_SSPrefix    , OpcodeSSPrefix
        dtS     VDM_INDEX_DSPrefix    , OpcodeDSPrefix
        dtS     VDM_INDEX_FSPrefix    , OpcodeFSPrefix
        dtS     VDM_INDEX_GSPrefix    , OpcodeGSPrefix
        dtS     VDM_INDEX_OPER32Prefix, OpcodeOPER32Prefix
        dtS     VDM_INDEX_ADDR32Prefix, OpcodeADDR32Prefix
        dtS     VDM_INDEX_INSB        , OpcodeINSB
        dtS     VDM_INDEX_INSW        , OpcodeINSW
        dtS     VDM_INDEX_OUTSB       , OpcodeOUTSB
        dtS     VDM_INDEX_OUTSW       , OpcodeOUTSW
        dtS     VDM_INDEX_INTnn       , OpcodeINTnn
        dtS     VDM_INDEX_INTO        , OpcodeINTO
        dtS     VDM_INDEX_INBimm      , OpcodeINBimm
        dtS     VDM_INDEX_INWimm      , OpcodeINWimm
        dtS     VDM_INDEX_OUTBimm     , OpcodeOUTBimm
        dtS     VDM_INDEX_OUTWimm     , OpcodeOUTWimm
        dtS     VDM_INDEX_INB         , OpcodeINB
        dtS     VDM_INDEX_INW         , OpcodeINW
        dtS     VDM_INDEX_OUTB        , OpcodeOUTB
        dtS     VDM_INDEX_OUTW        , OpcodeOUTW
        dtS     VDM_INDEX_LOCKPrefix  , OpcodeLOCKPrefix
        dtS     VDM_INDEX_REPNEPrefix , OpcodeREPNEPrefix
        dtS     VDM_INDEX_REPPrefix   , OpcodeREPPrefix
        dtS     VDM_INDEX_CLI         , OpcodeCLI
        dtS     VDM_INDEX_STI         , OpcodeSTI
dtEND   MAX_VDM_INDEX

PAGECONST   ENDS

PAGEDATA   SEGMENT  DWORD PUBLIC 'DATA'

        public  _ExVdmOpcodeDispatchCounts,_ExVdmSegmentNotPresent
_ExVdmOpcodeDispatchCounts dd      MAX_VDM_INDEX dup(0)
_ExVdmSegmentNotPresent    dd      0

PAGEDATA   ENDS

_PAGE   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

        page   ,132
        subttl "Overide Prefix Macro"
;++
;
;   Routine Description:
;
;       This macro generates the code for handling override prefixes
;       The routine name generated is OpcodeXXXXPrefix, where XXXX is
;       the name used in the macro invocation.  The code will set the
;       PREFIX_XXXX bit in the Prefix flags.
;
;   Arguments
;       name = name of prefix
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns
;       user mode Eip advanced
;       eax advanced
;       edx contains next byte of opcode
;
;   NOTE: This routine exits by dispatching through the table again.
;--
opPrefix macro name
        public Opcode&name&Prefix
Opcode&name&Prefix proc

        or      [esi].RiPrefixFlags,PREFIX_&name
        jmp     OpcodeGenericPrefix     ; dispatch to next handler

Opcode&name&Prefix endp
endm

irp prefix, <ES, CS, SS, DS, FS, GS, OPER32, ADDR32, LOCK, REPNE, REP>

        opPrefix prefix

endm

        page   ,132
        subttl "Instruction Emulation Dispatcher"
;++
;
;   Routine Description:
;
;       This routine dispatches to the opcode specific emulation routine,
;       based on the first byte of the opcode.  Two byte opcodes, and prefixes
;       result in another level of dispatching, from the handling routine.
;
;   Arguments:
;
;       ebp = pointer to trap frame
;
;   Returns:
;
;       Nothing
;
;

cPublicProc _Ki386DispatchOpcode,0

        sub     esp,REGINFOSIZE
        mov     esi, esp                        ; scratch area

        CsToLinearPM [ebp].TsSegCs, doerr       ; initialize reginfo

        mov     edi,[ebp].TsEip                 ; get fault instruction address
        cmp     edi,[esi].RiCsLimit             ; check eip
        ja      doerr

        add     edi,[esi].RiCsBase
        cmp     edi, [_MmHighestUserAddress]
        ja      doerr

        movzx   ecx,byte ptr [edi]              ; get faulting opcode

        mov     eax,ecx
        and     eax,0F8h                                ; check for npx instr
        cmp     eax,0D8h
        je      do30                                    ; dispatch

        movzx   eax, OpcodeIndex[ecx]
        mov     ebx,1                           ; length count, flags

        ; All handler routines will get the following on entry
        ; ebp -> trap frame
        ; ebx -> prefix flags, instruction length count
        ; ecx -> byte at the faulting address
        ; edx -> pointer to vdm state in DOS arena
        ; interrupts enabled and Irql at APC level
        ; edi -> address of faulting instruction
        ; esi -> reginfo struct
        ; All handler routines will return
        ; EAX = 0 for failure
        ; EAX = 1 for success
if DEVL
        inc     _ExVdmOpcodeDispatchCounts[eax * type _ExVdmOpcodeDispatchCounts]
endif
ifdef VDMDBG
        pushad
        stdCall _VdmTraceEvent, <VDMTR_KERNEL_OP_PM,ecx,0,ebp>
        popad
endif

        call    OpcodeDispatch[eax * type OpcodeDispatch]
do20:
        add     esp,REGINFOSIZE
        stdRET  _Ki386DispatchOpcode

doerr:  xor     eax,eax
        jmp     do20

        ;
        ; If we get here, we have executed an NPX instruction in user mode
        ; with the emulator installed.  If the EM bit was not set in CR0, the
        ; app really wanted to execute the instruction for detection purposes.
        ; In this case, we need to clear the TS bit, and restart the instruction.
        ; Otherwise we need to reflect the exception
        ;
do30:
        call OpcodeNPXV86
        jmp  short do20

stdENDP _Ki386DispatchOpcode


        page   ,132
        subttl "Invalid Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine causes a GP fault to be reflected to the vdm
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeInvalid
OpcodeInvalid proc
        xor     eax,eax                 ; ret fail
        ret

OpcodeInvalid endp


        page   ,132
        subttl "Generic Prefix Handler"
;++
;
;   Routine Description:
;
;       This routine handles the generic portion of all of the prefixes,
;       and dispatches the next byte of the opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       user mode Eip advanced
;       edx contains next byte of opcode
;

        public OpcodeGenericPrefix
OpcodeGenericPrefix proc

        inc     edi                             ; increment eip
        inc     ebx                             ; increment size
        cmp     bl, 128                         ; set arbitrary inst size limit
        ja      ogperr                          ; in case of pointless prefixes

        mov     eax,edi                         ; current linear address
        sub     eax,[esi].RiCsBase              ; make address eip
        cmp     eax,[esi].RiCsLimit             ; check eip
        ja      ogperr

        cmp     edi, [_MmHighestUserAddress]
        ja      ogperr

        mov     cl,byte ptr [edi]               ; get next opcode

        movzx   eax, OpcodeIndex[ecx]
if DEVL
        inc     _ExVdmOpcodeDispatchCounts[eax * type _ExVdmOpcodeDispatchCounts]
endif
        jmp     OpcodeDispatch[eax * type OpcodeDispatch]

ogperr:
        xor     eax,eax             ; opcode was NOT handled
        ret

OpcodeGenericPrefix endp


        page   ,132
        subttl "0F Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates a 0Fh opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public Opcode0F
Opcode0F proc

        mov     eax,[ebp].TsEip                 ; get fault instruction address
        mov     [esi].RiEip,eax
        mov     [esi].RiTrapFrame,ebp
        mov     [esi].RiPrefixFlags,ebx
        mov     eax,dword ptr [ebp].TsEFlags
        mov     [esi].RiEFlags,eax

        call    VdmOpcode0F                     ; enables interrupts
        test    eax,0FFFFh
        jz      o0f20

        mov     eax,[esi].RiEip
        mov     [ebp].TsEip,eax
        mov     eax,1
o0f20:
        ret

Opcode0F endp

        page   ,132
        subttl "Byte string in Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INSB opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;
;  WARNING what to do about size override?  ds override?

        public OpcodeINSB
OpcodeINSB proc

        push    ebp                          ; Trap Frame
        push    ebx                          ; size of insb

        movzx   eax,word ptr [ebp].TsSegEs
        shl     eax,16
        ; WARNING no support for 32bit edi
        mov     ax,word ptr [ebp].TsEdi      ; don't support 32bit'ness
        push    eax                          ; address

        xor     eax, eax
        mov     ecx,1
        test    ebx,PREFIX_REP
        jz      @f

        mov     eax, 1
        ; WARNING no support for 32bit ecx
        movzx   ecx,word ptr [ebp].TsEcx
@@:

        push    ecx                          ; number of io ops
        push    TRUE                         ; read op
        push    eax                          ; REP prefix
        push    1                            ; byte op
        movzx   edx,word ptr [ebp].TsEdx
        push    edx                          ; port number
        call    _Ki386VdmDispatchStringIo@32 ; use retval

        ret

OpcodeINSB endp

        page   ,132
        subttl "Word String In Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INSW opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeINSW
OpcodeINSW proc

        push    ebp                             ; Trap frame
        push    ebx                             ; sizeof insw

        movzx   eax,word ptr [ebp].TsSegEs
        shl     eax,16
        ; WARNING no support for 32bit edi
        mov     ax,word ptr [ebp].TsEdi
        push    eax                             ; address

        xor     eax, eax
        mov     ecx,1
        test    ebx,PREFIX_REP
        jz      @f

        mov     eax, 1
        ; WARNING no support for 32bit ecx
        movzx   ecx,word ptr [ebp].TsEcx
@@:
        movzx   edx,word ptr [ebp].TsEdx
        push    ecx                             ; number of io ops
        push    TRUE                            ; read op
        push    eax                             ; REP prefix
        push    2                               ; word size
        push    edx                             ; port number
        call    _Ki386VdmDispatchStringIo@32 ; use retval

        ret

OpcodeINSW endp

        page   ,132
        subttl "Byte String Out Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTSB opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeOUTSB
OpcodeOUTSB proc

        push    ebp                           ; Trap Frame
        push    ebx                           ; size of outsb

        movzx   eax,word ptr [ebp].TsSegDs
        shl     eax,16
        ; WARNING don't support 32bit'ness, esi
        mov     ax,word ptr [ebp].TsEsi
        push    eax                           ; address

        xor     eax, eax
        mov     ecx,1
        test    ebx,PREFIX_REP
        jz      @f

        mov     eax, 1
        ; WARNING don't support 32bit'ness ecx
        movzx   ecx,word ptr [ebp].TsEcx
@@:
        movzx   edx,word ptr [ebp].TsEdx
        push    ecx                           ; number of io ops
        push    FALSE                         ; write op
        push    eax                           ; REP prefix
        push    1                             ; byte op
        push    edx                           ; port number
        call    _Ki386VdmDispatchStringIo@32 ; use retval

        ret

OpcodeOUTSB endp

        page   ,132
        subttl "Word String Out Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTSW opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeOUTSW
OpcodeOUTSW proc

        push    ebp                               ; Trap Frame
        push    ebx                               ; size of outsb

        movzx   eax,word ptr [ebp].TsSegDs
        shl     eax,16
        ; WARNING don't support 32bit'ness esi
        mov     ax,word ptr [ebp].TsEsi
        push    eax                               ; address

        xor     eax, eax
        mov     ecx,1
        test    ebx,PREFIX_REP
        jz      @f

        mov     eax, 1
        ; WARNING don't support 32bit'ness ecx
        movzx   ecx,word ptr [ebp].TsEcx
@@:
        movzx   edx,word ptr [ebp].TsEdx

        push    ecx                               ; number of io ops
        push    FALSE                             ; write op
        push    eax                               ; REP prefix
        push    2                                 ; byte op
        push    edx                               ; port number
        call    _Ki386VdmDispatchStringIo@32 ; use retval

        ret

OpcodeOUTSW endp

        page   ,132
        subttl "INTnn Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INTnn opcode.  It retrieves the handler
;       from the IVT, pushes the current cs:ip and flags on the stack,
;       and dispatches to the handler.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       Current CS:IP on user stack
;       RiCs:RiEip -> handler from IVT
;

        public OpcodeINTnn
OpcodeINTnn proc

        mov     eax, ds:FIXED_NTVDMSTATE_LINEAR
        and     eax, (VDM_INTERRUPT_PENDING + VDM_VIRTUAL_INTERRUPTS)
        cmp     eax, (VDM_INTERRUPT_PENDING + VDM_VIRTUAL_INTERRUPTS)
        jnz     short oi10

        call    VdmDispatchIntAck
        jmp     short oi99

oi10:
        mov     eax,dword ptr [ebp].TsEFlags
        call    GetVirtualBits                   ; set interrupt flag
        mov     [esi].RiEFlags,eax
        movzx   eax,word ptr [ebp].TsHardwareSegSs
        call    SsToLinear
        test    al,0FFh
        jz      oinerr

        inc     edi                             ; point to int #
        mov     eax,edi                         ; current linear address
        sub     eax,[esi].RiCsBase              ; make address eip
        cmp     eax,[esi].RiCsLimit             ; check eip
        ja      oinerr

        cmp     edi, [_MmHighestUserAddress]
        ja      oinerr

        movzx   ecx,byte ptr [edi]              ; get int #
        inc     eax                             ; inc past end of instruction
        mov     [esi].RiEip,eax                 ; save for pushint's benefit
        call    PushInt                         ; will return retcode in al
        test    al,0FFh
        jz      oinerr                          ; error!

        mov     eax,[esi].RiEsp
        mov     [ebp].TsHardwareEsp,eax
        mov     ax,word ptr [esi].RiSegCs
        or      ax, 7                           ; R3 LDT selectors only
        mov     word ptr [ebp].TsSegCs,ax
        mov     eax,[esi].RiEFlags
        mov     [ebp].TsEFlags,eax
        mov     eax,[esi].RiEip
        mov     [ebp].TsEip,eax
oi99:
        mov     eax,1
        ret

oinerr:
        xor     eax,eax
        ret


OpcodeINTnn endp

        page   ,132
        subttl "INTO Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INTO opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeINTO
OpcodeINTO proc

        xor     eax,eax
        ret

OpcodeINTO endp


        page   ,132
        subttl "In Byte Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an in byte immediate opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeINBimm
OpcodeINBimm proc

        inc     ebx                             ; length count
        inc     edi
        mov     eax,edi                         ; current linear address
        sub     eax,[esi].RiCsBase              ; make address eip
        cmp     eax,[esi].RiCsLimit             ; check eip
        ja      oibi20

        cmp     edi, [_MmHighestUserAddress]
        ja      oibi20

        movzx   ecx,byte ptr [edi]

; (eax) = inst. size
; read op
; I/O size = 1
; (ecx) = port number

        stdCall   _Ki386VdmDispatchIo, <ecx, 1, TRUE, ebx, ebp>
        ret
oibi20:
        xor     eax, eax                        ; not handled
        ret

OpcodeINBimm endp

        page   ,132
        subttl "Word In Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an in word immediate opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeINWimm
OpcodeINWimm proc

        inc     ebx                             ; length count
        inc     edi
        mov     eax,edi                         ; current linear address
        sub     eax,[esi].RiCsBase              ; make address eip
        cmp     eax,[esi].RiCsLimit             ; check eip
        ja      oiwi20

        cmp     edi, [_MmHighestUserAddress]
        ja      oiwi20

        movzx   ecx,byte ptr [edi]

; TRUE - read op
; 2 - word op
; ecx - port number
        stdCall   _Ki386VdmDispatchIo, <ecx, 2, TRUE, ebx, ebp>
        ret
oiwi20:
        xor     eax, eax                        ; not handled
        ret

OpcodeINWimm endp

        page   ,132
        subttl "Out Byte Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an invalid opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeOUTBimm
OpcodeOUTBimm proc

        inc     ebx                             ; length count
        inc     edi
        mov     eax,edi                         ; current linear address
        sub     eax,[esi].RiCsBase              ; make address eip
        cmp     eax,[esi].RiCsLimit             ; check eip
        ja      oobi20

        cmp     edi, [_MmHighestUserAddress]
        ja      oobi20

        movzx   ecx,byte ptr [edi]

; FALSE - write op
; 1 - byte op
; ecx - port #

        stdCall   _Ki386VdmDispatchIo, <ecx, 1, FALSE, ebx, ebp>
        ret
oobi20:
        xor     eax, eax                        ; not handled
        ret

OpcodeOUTBimm endp

        page   ,132
        subttl "Out Word Immediate Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an out word immediate opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeOUTWimm
OpcodeOUTWimm proc

        inc     ebx                             ; length count
        inc     edi
        mov     eax,edi                         ; current linear address
        sub     eax,[esi].RiCsBase              ; make address eip
        cmp     eax,[esi].RiCsLimit             ; check eip
        ja      oowi20

        cmp     edi, [_MmHighestUserAddress]
        ja      oowi20

        movzx   ecx,byte ptr [edi]

; FALSE - write op
; 2 - word op
; ecx - port number
        stdCall   _Ki386VdmDispatchIo, <ecx, 2, FALSE, ebx, ebp>
        ret

oowi20:
        xor     eax, eax                        ; not handled
        ret

OpcodeOUTWimm endp

        page   ,132
        subttl "INB Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INB opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeINB
OpcodeINB proc

        movzx   eax,word ptr [ebp].TsEdx

; TRUE - read op
; 1 - byte op
; eax - port number

        cmp     eax, 3bdh
        jz      oib_prt1
        cmp     eax, 379h
        jz      oib_prt1
        cmp     eax, 279h
        jz      oib_prt1

oib_reflect:
        stdCall   _Ki386VdmDispatchIo, <eax, 1, TRUE, ebx, ebp>
        ret

oib_prt1:
        ; call printer status routine with port number, size, trap frame
        movzx   ebx, bl                     ;clear prefix flags
        push    eax
        stdCall _VdmPrinterStatus, <eax, ebx, ebp>
        or      al,al
        pop     eax
        jz      short oib_reflect
        mov     al, 1
        ret

OpcodeINB endp

        page   ,132
        subttl "INW Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INW opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeINW
OpcodeINW proc

        movzx   eax,word ptr [ebp].TsEdx

; TRUE - read operation
; 2 - word op
; eax - port number
        stdCall   _Ki386VdmDispatchIo, <eax, 2, TRUE, ebx, ebp>
        ret

OpcodeINW endp

        page   ,132
        subttl "OUTB Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTB opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeOUTB
OpcodeOUTB proc

        movzx   eax,word ptr [ebp].TsEdx

        cmp     eax, 03BCh
        je      short oob_printerVDD
        cmp     eax, 0378h
        je      short oob_printerVDD
        cmp     eax, 0278h
        jz      short oob_printerVDD

oob_reflect:
; FALSE - write op
; 1 - byte op
; eax - port number
        stdCall   _Ki386VdmDispatchIo, <eax, 1, FALSE, ebx, ebp>
        ret

oob_printerVDD:
        movzx   ebx, bl                   ; instruction size
        push    eax                       ; save port address
        stdCall _VdmPrinterWriteData, <eax, ebx, ebp>
        or      al,al                     ;
        pop     eax
        jz      short oob_reflect
        mov     al, 1
        ret

OpcodeOUTB endp

        page   ,132
        subttl "OUTW Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an OUTW opcode.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeOUTW
OpcodeOUTW proc

        movzx   eax,word ptr [ebp].TsEdx

; FALSE - write op
; 2 - word op
; edi - port #
        stdCall   _Ki386VdmDispatchIo, <eax, 2, FALSE, ebx, ebp>
        ret

OpcodeOUTW endp

        page   ,132
        subttl "CLI Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an CLI opcode. It clears the virtual
;       interrupt flag in the VdmTeb.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeCLI
OpcodeCLI proc

        mov     eax, ds:FIXED_NTVDMSTATE_LINEAR
        and     eax, (VDM_INTERRUPT_PENDING + VDM_VIRTUAL_INTERRUPTS)
        cmp     eax, (VDM_INTERRUPT_PENDING + VDM_VIRTUAL_INTERRUPTS)
        jnz     short oc50

        call    VdmDispatchIntAck
        jmp     short oc99

oc50:
        mov     eax,[ebp].TsEFlags
        and     eax,NOT EFLAGS_INTERRUPT_MASK
        call    SetVirtualBits
        inc     dword ptr [ebp].TsEip
        stdCall _VdmSetPMCliTimeStamp, <0>
oc99:
        mov     eax,1
        ret

OpcodeCLI endp

        page   ,132
        subttl "STI Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an STI opcode.  It sets the virtual
;       interrupt flag in the VDM teb.
;
;   Arguments:
;       EBP -> trap frame
;       EBX -> prefix flags, BL = instruction length count
;       ECX -> byte at the faulting address
;       EDX -> pointer to vdm state in DOS arena
;       ESI -> Reginfo struct
;       EDI -> address of faulting instruction
;
;   Returns:
;
;       nothing
;

        public OpcodeSTI
OpcodeSTI proc

        stdCall _VdmClearPMCliTimeStamp
        mov     eax,[ebp].TsEFlags
        or      eax,EFLAGS_INTERRUPT_MASK
        call    SetVirtualBits
        inc     dword ptr [ebp].TsEip
        mov     eax, ds:FIXED_NTVDMSTATE_LINEAR
        test    eax,VDM_INTERRUPT_PENDING
        jz      os10

        call    VdmDispatchIntAck
os10:
        mov     eax,1
        ret

OpcodeSTI endp

        page   ,132
        subttl "Check Vdm Flags"
;++
;
;   Routine Description:
;
;       This routine checks the flags that are going to be used for the
;       dos or windows application.
;
;   Arguments:
;
;       ecx = EFlags to be set
;       esi = address of reg info
;
;   Returns:
;
;       ecx = fixed flags
;
        public CheckVdmFlags
CheckVdmFlags proc

        push    eax
        mov     eax,[esi].RiEFlags
        and     eax,EFLAGS_V86_MASK
        test    _KeI386VdmIoplAllowed,1
        jnz     cvf30

        test    _KeI386VirtualIntExtensions, V86_VIRTUAL_INT_EXTENSIONS OR PM_VIRTUAL_INT_EXTENSIONS
        jnz     cvf40

cvf10:  or      ecx,EFLAGS_INTERRUPT_MASK
cvf20:  and     ecx,NOT (EFLAGS_IOPL_MASK OR EFLAGS_NT_MASK OR EFLAGS_V86_MASK OR EFLAGS_VIF OR EFLAGS_VIP)
        or      ecx,eax                 ; restore original v86 bit
        pop     eax
        ret

cvf30:  test    eax,EFLAGS_V86_MASK
        jz      cvf10

        jmp     cvf20

cvf40:  test    eax,EFLAGS_V86_MASK
        jz      cvf60

        test    _KeI386VirtualIntExtensions,V86_VIRTUAL_INT_EXTENSIONS
        jz      cvf10

cvf50:  push    eax
        mov     eax,ecx
        and     eax,EFLAGS_INTERRUPT_MASK
        shl     eax,0ah
        pop     eax
        jmp     cvf10

cvf60:  test    _KeI386VirtualIntExtensions,PM_VIRTUAL_INT_EXTENSIONS
        jz      cvf10

        jmp     cvf50
CheckVdmFlags endp

        page   ,132
        subttl "Get Virtual Interrupt Flag"
;++
;
;   Routine Description:
;
;       This routine correctly gets the VDMs virtual interrupt flag and
;       puts it into an EFlags image to be put on the stack.
;
;   Arguments:
;
;       eax = EFlags value
;
;   Returns:
;
;       eax = EFlags value with correct setting for IF
;
;   Uses:
;       ecx
;
        public GetVirtualBits
GetVirtualBits proc

        push    ebp
        push    edx
        push    ebx
        push    esi
        push    edi

        test    _KeI386VdmIoplAllowed,1
        jnz     gvb60

        test    _KeI386VirtualIntExtensions, V86_VIRTUAL_INT_EXTENSIONS OR PM_VIRTUAL_INT_EXTENSIONS
        jnz     gvb30

gvb10:  and     eax,NOT EFLAGS_INTERRUPT_MASK
        call    gvbGetFixedStateLinear
        and     ecx,VDM_VIRTUAL_INTERRUPTS OR VDM_VIRTUAL_AC
        or      eax,ecx                 ; put virtual int flag into flags
        or      eax,EFLAGS_IOPL_MASK    ; make it look like a 386

gbvexit:

        pop     edi
        pop     esi
        pop     ebx
        pop     edx
        pop     ebp
        ret

gvb30:  test    eax, EFLAGS_V86_MASK
        jz      gvb50

        test    _KeI386VirtualIntExtensions, V86_VIRTUAL_INT_EXTENSIONS
        jz      gvb10

gvb40:  mov     ecx,eax
        and     ecx,EFLAGS_VIF
        shr     ecx,0ah                 ; mov vif to if posn
        and     eax,NOT EFLAGS_INTERRUPT_MASK
        or      eax,ecx

        call    gvbGetFixedStateLinear
        and     ecx,VDM_VIRTUAL_AC
        and     eax,NOT EFLAGS_ALIGN_CHECK
        or      eax,ecx
        or      eax,EFLAGS_IOPL_MASK
        jmp     gbvexit

gvb50:  test    _KeI386VirtualIntExtensions, PM_VIRTUAL_INT_EXTENSIONS
        jz      gvb10

        jmp     gvb40

gvb60:  test    eax,EFLAGS_V86_MASK
        jz      gvb10

        call    gvbGetFixedStateLinear
        and     ecx,VDM_VIRTUAL_AC
        and     eax,NOT EFLAGS_ALIGN_CHECK
        or      eax,ecx
        or      eax,EFLAGS_IOPL_MASK
        jmp     gbvexit

gvbGetFixedStateLinear:
        push    esp                         ; Pass current Esp to handler
        push    offset GetVirtualBits_Handler
        push    PCR[PcExceptionList]
        mov     PCR[PcExceptionList], esp

        mov     ecx, ds:FIXED_NTVDMSTATE_LINEAR

gvbexit1:
        pop     PCR[PcExceptionList]
        add     esp, 8                  ; pop out except handler
        ret


GetVirtualBits_Handler:
        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        xor     ecx, ecx
        jmp     gvbexit1


GetVirtualBits endp

        page   ,132
        subttl "Set Virtual Interrupt Flag"
;++
;
;   Routine Description:
;
;       This routine correctly sets the VDMs virtual interrupt flag.
;
;   Arguments:
;
;       eax = EFlags value
;
;   Returns:
;
;       Virtual interrupt flag set
;
        public SetVirtualBits
SetVirtualBits proc
Flags   equ [ebp - 4]

        push    ebp
        push    edx
        push    ebx
        push    esi
        push    edi
        push    esp                         ; Pass current Esp to handler
        push    offset SetVirtualBits_Handler
        push    PCR[PcExceptionList]
        mov     PCR[PcExceptionList], esp
        mov     ebp,esp
        sub     esp,4

        mov     Flags,eax
        lea     edx,ds:FIXED_NTVDMSTATE_LINEAR
        and     eax,EFLAGS_INTERRUPT_MASK ; isolate int flag
        MPLOCK and [edx],NOT VDM_VIRTUAL_INTERRUPTS
        MPLOCK or [edx],eax             ; place virtual int flag value
        test    _KeI386VirtualIntExtensions, V86_VIRTUAL_INT_EXTENSIONS OR PM_VIRTUAL_INT_EXTENSIONS
        jnz     svb40
svb20:
        ; WARNING 32 bit support!
        test    ebx,PREFIX_OPER32
        jz      svb30                   ; 16 bit instr

        mov     eax,Flags
        and     eax,EFLAGS_ALIGN_CHECK
        MPLOCK  and     dword ptr [edx],NOT EFLAGS_ALIGN_CHECK
        MPLOCK  or      [edx],eax
svb30:

        mov     esp,ebp
svbexit:
        pop     PCR[PcExceptionList]    ; Remove handler
        lea     esp, [esp+8]
        pop     edi
        pop     esi
        pop     ebx
        pop     edx
        pop     ebp
        ret

svb40:  test    Flags,dword ptr EFLAGS_V86_MASK
        jz      svb60

        test    _KeI386VirtualIntExtensions,V86_VIRTUAL_INT_EXTENSIONS
        jz      svb20

svb50:  shl     eax,0ah
        jmp     svb20

svb60:  test    _KeI386VirtualIntExtensions,PM_VIRTUAL_INT_EXTENSIONS
        jz      svb20

        jmp     svb50

SetVirtualBits_Handler:
        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        jmp     svbexit

SetVirtualBits endp

        page   ,132
        subttl "Reflect Exception to a Vdm"
;++
;
;   Routine Description:
;
;       This routine reflects an exception to a VDM.  It uses the information
;       in the trap frame to determine what exception to reflect, and updates
;       the trap frame with the new CS, EIP, SS, and SP values
;
;   Arguments:
;
;       ebp -> Trap frame
;       ss:esp + 4 = trap number
;
;   Returns
;
;       Nothing
;
;   Notes:
;       Interrupts are enabled upon entry, Irql is at APC level
;       This routine may not preserve all of the non-volatile registers if
;       a fault occurs.
;
cPublicProc _Ki386VdmReflectException,1

RI      equ     [ebp - REGINFOSIZE]

        ;
        ; First make sure this is for us to handle
        ;

        mov     eax,PCR[PcPrcbData+PbCurrentThread]
        mov     eax,[eax]+ThApcState+AsProcess
        cmp     dword ptr [eax]+PrVdmObjects,0 ; is this a vdm process?
        jne     short @f

        xor     eax, eax                    ; not handled
        ret
@@:
        push    ebp
        mov     ebp,esp
        sub     esp,REGINFOSIZE

        pushad

        lea     esi,ds:FIXED_NTVDMSTATE_LINEAR

        ;
        ; Look to see if the debugger wants exceptions
        ;
        stdCall _VdmFetchULONG, <esi>
        test    eax,VDM_BREAK_EXCEPTIONS
        jz      vredbg                          ; no, check for debug events

        mov     ebx,DBG_STACKFAULT
        cmp     word ptr [ebp + 8],0ch          ; stack fault?
        jz      @f                              ; yes, check dbg flag
        mov     ebx,DBG_GPFAULT
        cmp     word ptr [ebp + 8],0dh          ; gp fault?
        jne     vredbg                          ; no, continue

@@:
        test    eax,VDM_USE_DBG_VDMEVENT
        jnz     vrexc_event
        jmp     vrexcd                          ; reflect the exception to 32

        ;
        ; Look to see if the debugger wants debug events
        ;
vredbg:
        test    eax,VDM_BREAK_DEBUGGER
        jz      vrevdm                          ; no debug events, reflect to vdm

        mov     ebx,DBG_SINGLESTEP
        cmp     word ptr [ebp + 8],1
        jnz     @f
        test    eax,VDM_USE_DBG_VDMEVENT
        jnz     vrexc_event
        jmp     vrexc1

@@:
        mov     ebx,DBG_BREAK
        cmp     word ptr [ebp + 8],3
        jnz     vrevdm
        test    eax,VDM_USE_DBG_VDMEVENT
        jnz     vrexc_event
        jmp     vrexc3

        ;
        ; Reflect the exception to the VDM
        ;
vrevdm:
        mov     esi,[ebp]
        cmp     word ptr [esi].TsSegCs, KGDT_R3_CODE OR RPL_MASK  ; int sim after fault?
        je      vre28
if DEVL
        cmp     word ptr [ebp + 8],11
        jne     @f
        inc     _ExVdmSegmentNotPresent
@@:
endif

        mov     RI.RiTrapFrame,esi
        mov     eax,[esi].TsHardwareSegSs
        mov     RI.RiSegSs,eax
        mov     eax,[esi].TsHardwareEsp
        mov     RI.RiEsp,eax
        mov     eax,[esi].TsEFlags
        mov     RI.RiEFlags,eax
        mov     eax,[esi].TsEip
        mov     RI.RiEip,eax
        mov     eax,[esi].TsSegCs
        mov     RI.RiSegCs,eax
        lea     esi,RI
        call    CsToLinear                      ; uses eax as selector
        test    al,0FFh
        jz      vrerr

        mov     eax,[esi].RiSegSs
        call    SsToLinear
        test    al,0FFh
        jz      vrerr

        mov     ecx,[ebp + 8]
        call    PushException
        test    al,0FFh
        jz      vrerr

        mov     esi,RI.RiTrapFrame
        mov     eax,RI.RiEsp
        mov     [esi].TsHardwareEsp,eax
        xor     bl, bl                           ; R3 mask. 0 on V86 mode
        test    dword ptr [esi].TsEFlags, EFLAGS_V86_MASK ;
        jnz     @F                               ;
        mov     bl, 7                            ; protected mode, R3 LDT selectors only
@@:
        mov     eax,RI.RiSegSs
        or      al, bl
        mov     [esi].TsHardwareSegSs,eax
        mov     eax,RI.RiEFlags
        mov     [esi].TsEFlags,eax
        mov     eax,RI.RiSegCs
        or      al, bl
        mov     [esi].TsSegCs,eax
        mov     eax,RI.RiEip
        mov     [esi].TsEip,eax
        cmp     word ptr [ebp + 8],1
        jne     vre28
        and     dword ptr [esi].TsEFlags, NOT EFLAGS_TF_MASK

vre28:
        popad
        mov     eax,1                           ; handled

vre30:
        mov     esp,ebp
        pop     ebp
        stdRET  _Ki386VdmReflectException

vrerr:
        popad
        xor     eax,eax
        jmp     vre30

vrexc1:
        mov     eax, [ebp]
        and     dword ptr [eax]+TsEflags, not EFLAGS_TF_MASK
        mov     eax, [ebp]+TsEip        ; (eax)-> faulting instruction
        stdCall _VdmDispatchException <[ebp],STATUS_SINGLE_STEP,eax,0,0,0,0>
        jmp     vre28

vrexc3:
        mov     eax,BREAKPOINT_BREAK
        mov     ebx, [ebp]
        mov     ebx, [ebx]+TsEip
        dec     ebx                     ; (eax)-> int3 instruction
        stdCall _VdmDispatchException <[ebp],STATUS_BREAKPOINT,ebx,3,eax,ecx,edx>
        jmp     vre28

vrexcd:
        mov     eax, [ebp]
        mov     eax, [eax]+TsEip
        stdCall _VdmDispatchException <[ebp],STATUS_ACCESS_VIOLATION,eax,2,0,-1,0>
        jmp     vre28

vrexc_event:
        mov     eax, [ebp]
        cmp     ebx, DBG_SINGLESTEP
        jnz     vrexc_event2
        and     dword ptr [eax]+TsEflags, not EFLAGS_TF_MASK
vrexc_event2:
        mov     eax, [eax]+TsEip
        stdCall _VdmDispatchException <[ebp],STATUS_VDM_EVENT,eax,1,ebx,0,0>
        jmp     vre28


stdENDP _Ki386VdmReflectException


        page   ,132
        subttl "Reflect Segment Not Present Exception to a Vdm"
;++
;
;   Routine Description:
;
;       This routine reflects an TRAP B to a VDM.  It uses the information
;       in the trap frame to determine what exception to reflect, and updates
;       the trap frame with the new CS, EIP, SS, and SP values
;
;   Arguments:
;
;       ebp -> Trap frame
;
;   Returns
;
;       0 is returned if the reflection fails.
;

cPublicProc _Ki386VdmSegmentNotPresent,0

        mov     edi,PCR[PcTeb]
        mov     ecx,VDM_FAULT_HANDLER_SIZE * 0Bh

        ;
        ; Set up an exception handler in case we fault
        ; during the user-space accesses below.
        ;

        push    ebp
        push    offset FLAT:VdmSegNotPres_ExceptionHandler
                                        ; set up exception registration record
        push    PCR[PcExceptionList]
        mov     PCR[PcExceptionList], esp

        mov     edi,[edi].TeVdm
        xor     ebx, ebx
        cmp     edi, _MmUserProbeAddress     ; probe the TeVdm
        jae     reflect
        lea     esi,[edi].VtDpmiInfo         ; (edi)->dpmi info struct
        mov     edi, [edi].VtFaultTable      ;
        lea     edi,[edi+ecx]                ; (edi)->FaultHandler
        cmp     edi, _MmUserProbeAddress     ; probe the table address
        jae     reflect
        cmp     word ptr [esi].VpLockCount, 0 ; switching stacks?
        jz      short seg_not_pres           ; yes, we can handle it
                                             ; no, let normal code check
                                             ; for stack faults

reflect:

        ;
        ; WARNING: Here we directly unlink the exception handler from the
        ; exception registration chain.  NO unwind is performed.
        ;

        pop     PCR[PcExceptionList]
        add     esp, 4                  ; pop out except handler
        pop     ebp

        ;
        ; Reflect the failure (or exception) back to the usermode ntvdm 
        ; to handle.
        ;

        pop     eax                          ; (eax) = return addr
        push    0bh
        push    eax
        jmp     _Ki386VdmReflectException

seg_not_pres:
if DEVL
        inc     _ExVdmSegmentNotPresent
endif
        inc     word ptr [esi].VpLockCount

; save stuff just like SwitchToHandlerStack does
        mov     eax, [ebp].TsEip
        mov     [esi].VpSaveEip, eax
        mov     eax, [ebp].TsHardwareEsp
        mov     [esi].VpSaveEsp, eax
        mov     ax, [ebp].TsHardwareSegSs
        mov     [esi].VpSaveSsSelector, ax

        mov     bx,word ptr [esi].VpSsSelector
        mov     eax, PCR[PcPrcbData+PbCurrentThread]
        mov     eax, [eax+ThApcState+AsProcess]
        lea     eax, [eax+PrLdtDescriptor]
        mov     ch, [eax+KgdtBaseHi]
        mov     cl, [eax+KgdtBaseMid]
        shl     ecx, 16
        and     ebx, 0fffffff8h
        mov     cx, [eax+KgdtBaseLow]
        lea     eax, [ecx+ebx]
        mov     bh, [eax+KgdtBaseHi]
        mov     bl, [eax+KgdtBaseMid]
        shl     ebx, 16
        mov     bx, [eax+KgdtBaseLow]        ; (ebx) = Base of SS

        mov     eax, [ebp].TsEFlags
        call    GetVirtualBits               ; (eax) = app's eflags
        push    esi
        mov     edx, 0fe0h                   ; dpmistack offset (per win31)
        test    word ptr [esi].VpFlags, 1    ; 32-bit frame?
        jz      short @f
        sub     edx, 8 * 4
        add     edx, ebx
        mov     esi, [ebp].TsHardwareEsp
        mov     ecx, [ebp].TsHardwareSegSs
        mov     [edx + 20], eax              ; push flags
        mov     [edx + 24], esi              ; put esp on new stack
        mov     [edx + 28], ecx              ; put ss on new stack
        mov     ecx, [ebp].TsSegCs
        mov     eax, [ebp].TsEip
        mov     esi, [ebp].TsErrCode
        mov     [edx + 16], ecx              ; push cs
        mov     [edx + 12], eax              ; push ip
        mov     [edx + 8], esi               ; push error code
        pop     esi
        mov     ecx, [esi].VpDosxFaultIretD
        mov     eax, ecx
        shr     eax, 16
        and     ecx, 0ffffh
        mov     [edx + 4], eax               ; push fault iret seg
        mov     [edx], ecx                   ; push fault iret offset
        jmp     short vsnp_update
@@:
        sub     edx, 8 * 2
        add     edx, ebx
        mov     esi, [ebp].TsHardwareEsp
        mov     ecx, [ebp].TsHardwareSegSs
        mov     [edx + 10], ax               ; push flags
        mov     [edx + 12], si               ; put esp on new stack
        mov     [edx + 14], cx               ; put ss on new stack
        mov     ecx, [ebp].TsSegCs
        mov     eax, [ebp].TsEip
        mov     esi, [ebp].TsErrCode
        mov     [edx + 8], cx                ; push cs
        mov     [edx + 6], ax                ; push ip
        mov     [edx + 4], si                ; push error code
        pop     esi
        mov     ecx, [esi].VpDosxFaultIret
        mov     eax, ecx
        shr     eax, 16
        mov     [edx + 2], ax                ; push fault iret seg
        mov     [edx], cx                    ; push fault iret offset

vsnp_update:
        mov     eax,[edi].VfEip
        sub     edx, ebx
        mov     cx, word ptr [edi].VfCsSelector
        mov     bx, word ptr [esi].VpSsSelector
        test    dword ptr [edi].VfFlags, VDM_INT_INT_GATE
        jz      short @f

        lea     esi,ds:FIXED_NTVDMSTATE_LINEAR
        MPLOCK and      [esi],NOT VDM_VIRTUAL_INTERRUPTS
        and     dword ptr [ebp].TsEflags, 0FFF7FFFFH ; clear VIF
@@:
        or      cx, 7                       ; R3 LDT selectors only
        or      bx, 7                       ; R3 LDT selectors only
        mov     [ebp].TsSegCs, cx
        mov     [ebp].TsEip, eax
        mov     [ebp].TsHardwareEsp,edx
        mov     [ebp].TsHardwareSegSs,bx

        ;
        ; WARNING: Here we directly unlink the exception handler from the
        ; exception registration chain.  NO unwind is performed.
        ;

        pop     PCR[PcExceptionList]
        add     esp, 4                  ; pop out except handler
        pop     ebp

        mov     eax, 1
        stdRET    _Ki386VdmSegmentNotPresent


stdENDP _Ki386VdmSegmentNotPresent

        ;
        ;   Error and exception blocks for Ki386VdmSegmentNoPresent
        ;

VdmSegNotPres_ExceptionHandler:

        ;
        ; WARNING: Here we directly unlink the exception handler from the
        ; exception registration chain.  NO unwind is performed.
        ;

        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        jmp     reflect

        page   ,132
        subttl "Dispatch UserMode Exception to a Vdm"
;++
;
;   Routine Description:
;
;   Dispatches exception for vdm from in the kernel, by invoking
;   CommonDispatchException.
;
;   Arguments: See CommonDispatchException for parameter description
;
;   VOID
;   VdmDispatchException(
;        PKTRAP_FRAME TrapFrame,
;        NTSTATUS     ExcepCode,
;        PVOID        ExcepAddr,
;        ULONG        NumParms,
;        ULONG        Parm1,
;        ULONG        Parm2,
;        ULONG        Parm3
;        )
;
;   Returns
;
;       Nothing
;
;   Notes:
;
;       This routine may not preserve all of the non-volatile registers if
;       a fault occurs.
;
cPublicProc _VdmDispatchException,7

TrapFrame equ [ebp+8]
ExcepCode equ [ebp+12]
ExcepAddr equ [ebp+16]
NumParms  equ [ebp+20]
Parm1     equ [ebp+24]
Parm2     equ [ebp+28]
Parm3     equ [ebp+32]

        push    ebp
        mov     ebp,esp
        pushad

        xor     ecx, ecx            ; lower irql to 0
        fstCall KfLowerIrql         ; allow APCs and debuggers in!

        mov    eax, ExcepCode
        mov    ebx, ExcepAddr
        mov    ecx, NumParms
        mov    edx, Parm1
        mov    esi, Parm2
        mov    edi, Parm3
        mov    ebp, TrapFrame
        call   CommonDispatchException

        popad
        pop    ebp

        stdRET  _VdmDispatchException

stdENDP _VdmDispatchException




        page   ,132
        subttl "Push Interrupt frame on user stack"
;++
;
;   Routine Description:
;
;       This routine pushes an interrupt frame on the user stack
;
;   Arguments:
;
;       ecx = interrupt #
;       esi = address of reg info
;   Returns:
;
;       interrupt frame pushed on stack
;       reg info updated
;
        public PushInt
PushInt proc

        push    ebx
        push    edi

;
; Handle dispatching interrupts directly to the handler, rather than
; to the dos extender
;
        ;
        ; Get the information on the interrupt handler
        ;
        .errnz (VDM_INTERRUPT_HANDLER_SIZE - 8)
        mov     eax,PCR[PcTeb]

        ;
        ; Set up an exception handler in case we fault
        ; during the user-space accesses below.
        ;

        push    ebp
        push    offset FLAT:PushIntExceptionHandler     ; set up exception registration record
        push    PCR[PcExceptionList]
        mov     PCR[PcExceptionList], esp


        mov     eax,[eax].TbVdm
        cmp     eax, _MmUserProbeAddress
        jae     pierr
        mov     eax, [eax].VtInterruptTable
        lea     eax,[eax + ecx*8]
        cmp     eax, _MmUserProbeAddress
        jae     pierr

        ;
        ; Get SP
        ;
        mov     edi,[ebp].TsHardwareEsp
        test    [esi].RiSsFlags,SEL_TYPE_BIG
        jnz     @f

        movzx   edi,di                          ; zero high bits for 64k stack

        ;
        ; Update SP
        ;
@@:     test    [eax].ViFlags,dword ptr VDM_INT_32
        jz      @f

        ;
        ; 32 bit iret frame
        ;
        cmp     edi,12                          ; enough space on stack?
        jb      pierr                           ; no, go fault

        sub     edi,12
        mov     [esi].RiEsp,edi
        jmp     pi130

        ;
        ; 16 bit iret frame
        ;
@@:     cmp     edi,6                           ; enough space on stack?
        jb      pierr                           ; no, go fault

        sub     edi,6
        mov     [esi].RiEsp,edi

        ;
        ; Check limit
        ;
pi130:  test    [esi].RiSsFlags,SEL_TYPE_ED
        jz      pi140

        ;
        ; Expand down, Sp must be above limit
        ;
        cmp     edi,[esi].RiSsLimit
        jna     pierr
        jmp     pi150

        ;
        ; Normal, Sp must be below limit
        ;
pi140:  cmp     edi,[esi].RiSsLimit
        jnb     pierr

        ;
        ; Get base of ss
        ;
pi150:  mov     ebx,[esi].RiSsBase
        test    [eax].ViFlags,dword ptr VDM_INT_32
        jz      pi160

        ;
        ; "push" 32 bit iret frame
        ;
        mov     edx,[esi].RiEip
        mov     [edi + ebx],edx
        mov     dx,word ptr [ebp].TsSegCs
        mov     [edi + ebx] + 4,edx
        push    eax
        mov     eax,[esi].RiEFlags
        call    GetVirtualBits

        mov     [edi + ebx] + 8,eax
        pop     eax
        jmp     pi170

        ;
        ; push 16 bit iret frame
        ;
pi160:  mov     dx,word ptr [esi].RiEip
        mov     [edi + ebx],dx
        mov     dx,word ptr [ebp].TsSegCs
        mov     [edi + ebx] + 2,dx
        push    eax
        mov     eax,[esi].RiEFlags
        call    GetVirtualBits

        mov     [edi + ebx] + 4,ax
        pop     eax

        ;
        ; Update CS and IP
        ;
pi170:  mov     ebx,eax                                 ; save int info
        mov     dx,[eax].ViCsSelector
        mov     word ptr [esi].RiSegCs,dx
        mov     edx,[eax].ViEip
        mov     [esi].RiEip,edx

        movzx   eax, word ptr [esi].RiSegCs
        call    CsToLinear                      ; uses eax as selector

        test    al,0ffh
        jnz     pi175

        ;
        ; Check for destination not present
        ;
        test    [esi].RiCsFlags,SEL_TYPE_NP
        jz      pierr

        mov     al,0ffh                         ; succeeded
        jmp     pi180

        ;
        ; Check handler address
        ;
pi175:  mov     edx,[esi].RiEip
        cmp     edx,[esi].RiCsLimit
        jnb     pierr

        ;
        ; Turn off the trap flag
        ;
pi180:  and     [esi].RiEFlags,NOT EFLAGS_TF_MASK

        ;
        ; Turn off virtual interrupts if necessary
        ;
        test    [ebx].ViFlags,dword ptr VDM_INT_INT_GATE
        ; n.b. We know al is non-zero, because we succeeded in cstolinear
        jz      pi80

        test    _KeI386VirtualIntExtensions,PM_VIRTUAL_INT_EXTENSIONS
        jz      pi75

        and     [esi].RiEFlags, NOT (EFLAGS_VIF)

pi75:   lea     ebx,ds:FIXED_NTVDMSTATE_LINEAR
        MPLOCK and [ebx], NOT EFLAGS_INTERRUPT_MASK

pi80:   and     [esi].RiEFlags,NOT (EFLAGS_IOPL_MASK OR EFLAGS_NT_MASK OR EFLAGS_V86_MASK)
        or      [esi].RiEFlags,EFLAGS_INTERRUPT_MASK

pi90:

        ;
        ; WARNING: Here we directly unlink the exception handler from the
        ; exception registration chain.  NO unwind is performed.
        ;

        pop     PCR[PcExceptionList]
        add     esp, 4                  ; pop out except handler
        pop     ebp

        pop     edi
        pop     ebx
        ret

pierr:  xor     eax,eax
        jmp     pi90

PushInt endp

PushIntExceptionHandler:
        mov     esp, [esp+8]            ; (esp)-> ExceptionList
        xor     eax,eax
        jmp     pi90

        page   ,132
        subttl "Convert CS Segment or selector to linear address"
;++
;
;   Routine Description:
;
;       Convert CS segment or selector to linear address as appropriate
;       for the current user mode processor mode.
;
;   Arguments:
;
;       esi = reg info
;
;   Returns:
;
;       reg info updated
;
        public CsToLinear
CsToLinear proc

        test    [esi].RiEFlags,EFLAGS_V86_MASK
        jz      ctl10

        shl     eax,4
        mov     [esi].RiCsBase,eax
        mov     [esi].RiCsLimit,0FFFFh
        mov     [esi].RiCsFlags,0
        mov     eax,1
        ret


ctl10:
        push    edx                             ; WARNING volatile regs!!!
        lea     edx,[esi].RiCsLimit
        push    edx
        lea     edx,[esi].RiCsBase
        push    edx
        lea     edx,[esi].RiCsFlags
        push    edx
        push    eax                             ; push selector

IFDEF STD_CALL
        call    _Ki386GetSelectorParameters@16
ELSE
        call    _Ki386GetSelectorParameters
        add     esp,10h
ENDIF
        pop     edx

        or      al,al
        jz      ctlerr

        test    [esi].RiCsFlags,SEL_TYPE_EXECUTE
        jz      ctlerr

        test    [esi].RiCsFlags,SEL_TYPE_2GIG
        jz      ctl30

        ; Correct limit value for granularity
        shl     [esi].RiCsLimit,12
        or      [esi].RiCsLimit,0FFFh
ctl30:
        mov     eax,1
        ret

ctlerr: xor     eax,eax
        ret

CsToLinear endp


        page   ,132
        subttl "Verify that EIP is still valid"
;++
;
;   Routine Description:
;
;       Verify that Eip is still valid and put it into the trap frame
;
;   Arguments:
;
;       esi = address of reg info
;
;   Returns:
;
;
        public CheckEip
CheckEip proc
        mov     eax,[esi].RiEip
        test    [esi].RiEFlags,EFLAGS_V86_MASK
        jz      ce20

        and     eax,[esi].RiCsLimit
        mov     [esi].RiEip,eax
        jmp     ce40

ce20:   cmp     eax,[esi].RiCsLimit
        ja      ceerr
ce40:   mov     eax,1
ce50:   ret

ceerr:  xor     eax,eax
        jmp     ce50

CheckEip endp

        page   ,132
        subttl "Convert Ss Segment or selector to linear address"
;++
;
;   Routine Description:
;
;       Convert Ss segment or selector to linear address as appropriate
;       for the current user mode processor mode.
;
;   Arguments:
;
;       eax = selector to convert
;       esi = address of reg info
;
;   Returns:
;
;       reg info updated
;
        public SsToLinear
SsToLinear proc

        test    [esi].RiEFlags,EFLAGS_V86_MASK
        jz      stl10

        shl     eax,4
        mov     [esi].RiSsBase,eax
        mov     [esi].RiSsLimit,0FFFFh
        mov     [esi].RiSsFlags,0
        mov     eax,1
        ret

stl10:  push    ecx
        lea     ecx,[esi].RiSsLimit
        push    ecx
        lea     ecx,[esi].RiSsBase
        push    ecx
        lea     ecx,[esi].RiSsFlags
        push    ecx
        push    eax                             ;selector

IFDEF STD_CALL
        call    _Ki386GetSelectorParameters@16
ELSE
        call    _Ki386GetSelectorParameters
        add     esp,10h
ENDIF
        pop     ecx

        or      al,al
        jz      stlerr

        test    [esi].RiSsFlags,SEL_TYPE_WRITE
        jz      stlerr

        test    [esi].RiSsFlags,SEL_TYPE_2GIG
        jz      stl30

        ; Correct limit value for granularity

        mov     eax,[esi].RiSsLimit
        shl     eax,12
        or      eax,0FFFh
        mov     [esi].RiSsLimit,eax
stl30:
        mov     eax,1
stl40:  ret

stlerr: xor     eax,eax
        jmp     stl40

SsToLinear endp

        page   ,132
        subttl "Verify that Esp is still valid"
;++
;
;   Routine Description:
;
;       Verify that Esp is still valid
;
;   Arguments:
;
;       ecx = # of bytes needed for stack frame
;       esi = address of reg info
;
;   Returns:
;
;
;
        public CheckEsp
CheckEsp proc
        mov     eax,[esi].RiEsp
        test    [esi].RiEFlags,EFLAGS_V86_MASK
        jz      cs20

        and     eax,[esi].RiSsLimit
        mov     [esi].RiEsp,eax
        jmp     cs40

cs20:   test    [esi].RiSsFlags,SEL_TYPE_BIG
        jnz     cs25

        and     eax,0FFFFh                      ; only use 16 bit for 16 bit
cs25:
        cmp     ecx, eax                        ; StackOffset > SP?
        ja      cserr                           ; yes error
        dec     eax                             ; make limit checks work
        test    [esi].RiSsFlags,SEL_TYPE_ED     ; Expand down?
        jz      cs30                            ; jif no

;
;       Expand Down
;
        sub     eax, ecx                        ; New SP
        cmp     eax,[esi].RiSsLimit             ; NewSp < Limit?
        jb      cserr
        jmp     cs40

;
;       Not Expand Down
;
cs30:   cmp     eax,[esi].RiSsLimit
        ja      cserr

cs40:   mov     eax,1
cs50:   ret


cserr:  xor     eax,eax
        jmp     cs50

CheckEsp endp

        page   ,132
        subttl "Switch to protected mode interrupt stack"
;++
;
;   Routine Description:
;
;       Switch to protected mode interrupt handler stack
;
;   Arguments:
;
;       ecx = interrupt number
;       esi = address of reg info
;       edi = address of PM Stack info
;
;   Returns:
;
;       reg info updated
;
        public SwitchToHandlerStack
SwitchToHandlerStack proc


;
; Install exception handler
;
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset SwitchToHandlerStack_fault ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        cmp     word ptr [edi].VpLockCount, 0   ; already switched?
        jnz     short @f                        ; yes

        mov     eax, [esi].RiEip
        mov     [edi].VpSaveEip, eax
        mov     eax, [esi].RiEsp
        mov     [edi].VpSaveEsp, eax
        mov     eax, [esi].RiSegSs
        mov     [edi].VpSaveSsSelector, ax

        movzx   eax,word ptr [edi].VpSsSelector

        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp

        mov     [esi].RiSegSs,eax
        mov     dword ptr [esi].RiEsp,1000h     ; dpmi stack offset

        movzx   eax, word ptr [esi].RiSegSs
        push    ecx
        call    SsToLinear                      ; compute new base
        pop     ecx
        test    al,0FFh
        jz      shserr

        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset SwitchToHandlerStack_fault ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

@@:
        inc     word ptr [edi].VpLockCount      ; maintain lock count

        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp

        mov     eax,1
        ret


shserr:
        xor     eax,eax
        ret

SwitchToHandlerStack_fault:

        mov     esp, [esp+8]   
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp
        xor     eax,eax
        ret

SwitchToHandlerStack endp


        page   ,132
        subttl "Get protected mode interrupt handler address"
;++
;
;   Routine Description:
;
;       Get the address of the interrupt handler for the specified interrupt
;
;   Arguments:
;
;       ecx = interrupt number
;       esi = address of reg info
;
;   Returns:
;
;       reg info updated
;
        public GetHandlerAddress
GetHandlerAddress proc

        push    ebp
        push    ecx
        push    edx
        push    esp                             ; Pass current Esp to handler
        push    offset GetHandlerAddress_fault  ; Set Handler address
        push    PCR[PcExceptionList]            ; Set next pointer
        mov     PCR[PcExceptionList],esp        ; Link us on
        mov     eax,VDM_FAULT_HANDLER_SIZE
        mul     ecx
        mov     edi,PCR[PcTeb]
        mov     edi,[edi].TeVdm
        cmp     edi, _MmUserProbeAddress        ; Probe the VMD structure
        jae     @f
        mov     edi,[edi].VtFaultTable
        cmp     edi, _MmUserProbeAddress
        jae     @f
        movzx   ecx,word ptr [edi + eax].VfCsSelector
        mov     [esi].RiSegCs,ecx
        mov     ecx,[edi + eax].VfEip
        mov     [esi].RiEip,ecx
        mov     eax,1
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     edx
        pop     ecx
        pop     ebp
        ret
@@:
GetHandlerAddress_fault_resume:
        xor	eax, eax
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     edx
        pop     ecx
        pop     ebp
        ret

GetHandlerAddress_fault:
        mov     esp, [esp+8]   
        jmp     GetHandlerAddress_fault_resume


GetHandlerAddress endp

        page   ,132
        subttl "Push processor exception"
;++
;
;   Routine Description:
;
;       Update the stack and registers to emulate the specified exception
;
;   Arguments:
;
;       ecx = interrupt number
;       esi = address of reg info
;
;   Returns:
;
;       reg info updated
;
        public PushException
PushException Proc

        push    ebx
        push    edi

        test    [esi].RiEflags,EFLAGS_V86_MASK
        jz      pe40

;
; Push V86 mode exception
;
        cmp     ecx, 7                  ; device not available fault
        ja      peerr                   ; per win3.1, no exceptions
                                        ; above 7 for v86 mode
        mov     edx,[esi].RiEsp
        mov     ebx,[esi].RiSsBase
        and     edx,0FFFFh              ; only use a 16 bit sp
        sub     dx,2
        mov     eax,[esi].RiEFlags
        push    ecx
        call    GetVirtualBits
        pop     ecx
;
; Install exception handler
;
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     [ebx+edx],ax            ; push flags
        sub     dx,2
        mov     ax,word ptr [esi].RiSegCs
        mov     [ebx+edx],ax            ; push cs
        sub     dx,2
        mov     ax,word ptr [esi].RiEip
        mov     [ebx+edx],ax            ; push ip

        mov     eax,[ecx*4]             ; get new cs:ip value
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp

        push    eax
        movzx   eax,ax
        mov     [esi].RiEip,eax
        pop     eax
        shr     eax,16
        mov     [esi].RiSegCs,eax
        mov     word ptr [esi].RiEsp,dx
        jmp     pe60

perr1_fault:
        mov     esp, [esp+8]                ; (esp)-> ExceptionList
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp
        jmp     peerr1

perr_fault:
        mov     esp, [esp+8]                ; (esp)-> ExceptionList
        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp
        jmp     peerr
;
; Push PM exception
;
pe40:
        push    [esi].RiEsp                     ; save for stack frame
        push    [esi].RiSegSs

;
; Install exception handler
;
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr1_fault          ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     edi,PCR[PcTeb]
        mov     edi, [edi].TeVdm


        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp

        cmp     edi, _MmUserProbeAddress
        jae     peerr1
        lea     edi,[edi].VtDpmiInfo
        call    SwitchToHandlerStack
        test    al,0FFh
        jz      peerr1                          ; pop off stack and exit

        sub     [esi].RiEsp, 20h                ; win31 undocumented feature

        mov     ebx,[esi].RiSsBase
        mov     edx,[esi].RiEsp
        test    [esi].RiSsFlags,SEL_TYPE_BIG
        jnz     short @f
        movzx   edx,dx                          ; zero high bits for 64k stack
@@:

;
; Install exception handler
;
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr1_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        test    word ptr [edi].VpFlags, 1   ; 32 bit app?

        pop     PCR[PcExceptionList]        ; Remove our exception handle
        lea     esp, [esp+8]                ; clear stack
        pop     ebp

        jnz     pe45                        ; yes

;
;       push 16-bit frame
;
        push    ecx
        mov     ecx, 8*2                        ; room for 8 words?
        call    CheckEsp
        pop     ecx
        test    al,0FFh
        jz      peerr1                          ; pop off stack and exit

        sub     edx,8*2
        mov     [esi].RiEsp,edx

;
; Install exception handler
;
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr1_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     eax, [esp+4*4]
        mov     [ebx+edx+14], ax
        mov     eax, [esp+4*5]
        mov     [ebx+edx+12], ax

        pop     PCR[PcExceptionList]        ; Remove our exception handle
        lea     esp, [esp+8]                ; clear stack
        pop     ebp
        lea     esp, [esp+8]                ; clear stack

        mov     eax,[esi].RiEFlags
        push    ecx
        call    GetVirtualBits
        pop     ecx

;
; Install exception handler
;
        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     [ebx+edx+10],ax                 ; push flags
        movzx   eax,word ptr [esi].RiSegCs
        mov     [ebx+edx+8],ax                  ; push cs
        mov     eax,[esi].RiEip
        mov     [ebx+edx+6],ax                  ; push ip
        mov     eax,RI.RiTrapFrame
        mov     eax,[eax].TsErrCode
        mov     [ebx+edx+4],ax                  ; push error code
        mov     eax,[edi].VpDosxFaultIret
        mov     [ebx+edx],eax                   ; push iret address

        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp

        jmp     pe50
pe45:
;
;       push 32-bit frame
;
        push    ecx
        mov     ecx, 8*4                        ; room for 8 dwords?
        call    CheckEsp
        pop     ecx
        test    al,0FFh
        jz      peerr1                          ; pop off stack and exit

        sub     edx,8*4
        mov     [esi].RiEsp,edx

        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr1_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     eax, [esp+4*4]
        mov     [ebx+edx+28], eax
        mov     eax, [esp+4*5]
        mov     [ebx+edx+24], eax

        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp
        lea     esp, [esp+8]                ; drop ss etc

        mov     eax,[esi].RiEFlags
        push    ecx
        call    GetVirtualBits
        pop     ecx

        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     [ebx+edx+20],eax                ; push flags
        movzx   eax,word ptr [esi].RiSegCs
        mov     [ebx+edx+16],eax                ; push cs
        mov     eax,[esi].RiEip
        mov     [ebx+edx+12],eax                ; push ip
        mov     eax,RI.RiTrapFrame
        mov     eax,[eax].TsErrCode
        mov     [ebx+edx+8],eax                 ; push error code
        mov     eax,[edi].VpDosxFaultIretD
        shr     eax, 16
        mov     [ebx+edx+4],eax                 ; push iret seg
        mov     eax,[edi].VpDosxFaultIretD
        and     eax, 0ffffh
        mov     [ebx+edx],eax                   ; push iret offset

        pop     PCR[PcExceptionList]        ; Remove our exception handle
        add     esp, 8                      ; clear stack
        pop     ebp

pe50:
        call    GetHandlerAddress
        test    al,0FFh
        jz      peerr

pe60:   push    ecx
        movzx   eax,word ptr [esi].RiSegCs
        call    CsToLinear                      ; uses eax as selector
        pop     ecx
        test    al,0FFh
        jz      peerr

        mov     eax,[esi].RiEip
        cmp     eax,[esi].RiCsLimit
        ja      peerr

        mov     eax,VDM_FAULT_HANDLER_SIZE
        push    edx
        mul     ecx
        pop     edx

        push    ebp
        push    esp                         ; Pass current Esp to handler
        push    offset perr_fault           ; Set Handler address
        push    PCR[PcExceptionList]        ; Set next pointer
        mov     PCR[PcExceptionList],esp    ; Link us on

        mov     edi,PCR[PcTeb]
        mov     edi,[edi].TbVdm

        cmp     edi, _MmUserProbeAddress
        jb      @f
        mov     edi, _MmUserProbeAddress
@@:     mov     edi,[edi].VtFaultTable
        add     edi,eax
        cmp     edi, _MmUserProbeAddress
        jb      @f
        mov     edi, _MmUserProbeAddress
@@:     mov     eax,[esi].RiEFlags  ;WARNING 16 vs 32
        test    dword ptr [edi].VfFlags,VDM_INT_INT_GATE

        pop     PCR[PcExceptionList]        ; Remove our exception handle
        lea     esp, [esp+8]                ; clear stack
        pop     ebp

        jz      pe70

        and     eax,NOT (EFLAGS_INTERRUPT_MASK OR EFLAGS_TF_MASK)
        push    eax
        xor     ebx, ebx                ;  clear prefix flags
        call    SetVirtualBits
        pop     eax
pe70:   push    ecx
        mov     ecx,eax
        call    CheckVdmFlags
        and     ecx,NOT EFLAGS_TF_MASK
        mov     [esi].RiEFlags,ecx
        pop     ecx
        mov     eax,1                   ; success
pe80:   pop     edi
        pop     ebx
        ret

peerr1: add     esp, 8                  ;throw away esp, ss
peerr:  xor     eax,eax
        jmp     pe80

PushException endp


_PAGE   ends


_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

;
; Non-pagable code
;

        page   ,132
        subttl "Ipi worker for enabling Pentium extensions"
;++
;
;   Routine Description:
;
;       This routine sets or resets the VME bit in CR4 for each processor
;
;   Arguments:
;
;       [esp + 4] -- 1 if VME is to be set, 0 if it is to be reset
;   Returns:
;
;       0
;
cPublicProc _Ki386VdmEnablePentiumExtentions, 1

Enable equ [ebp + 8]
        push    ebp
        mov     ebp,esp
;
;       Insure we do not get an interrupt in here.  We may
;       be called at IPI_LEVEL - 1 by KiIpiGenericCall.
;
        pushf
        cli

;       mov     eax,cr4
        db      0fh, 020h,0e0h

        test    Enable,1
        je      vepe20

        or      eax,CR4_VME
        jmp     vepe30

vepe20: and     eax,NOT CR4_VME

;       mov     cr4,eax
vepe30: db      0fh,022h,0e0h

        popf
        xor     eax,eax

        mov     esp,ebp
        pop     ebp
        stdRET _Ki386VdmEnablePentiumExtentions
stdENDP _Ki386VdmEnablePentiumExtentions

_TEXT$00 ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\intobj.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    intobj.c

Abstract:

    This module implements the kernel interrupt object. Functions are provided
    to initialize, connect, and disconnect interrupt objects.

Author:

    David N. Cutler (davec) 30-Jul-1989

Environment:

    Kernel mode only.

Revision History:

    23-Jan-1990    shielint

                   Modified for NT386 interrupt manager

--*/

#include "ki.h"

//
//  Externs from trap.asm used to compute and set handlers for unexpected
//  hardware interrupts.
//

extern  ULONG   KiStartUnexpectedRange(VOID);
extern  ULONG   KiEndUnexpectedRange(VOID);
extern  ULONG   KiUnexpectedEntrySize;


VOID
KiInterruptDispatch2ndLvl(
    VOID
    );


VOID
KiChainedDispatch2ndLvl(
    VOID
    );


typedef enum {
    NoConnect,
    NormalConnect,
    ChainConnect,
    UnkownConnect
} CONNECT_TYPE, *PCONNECT_TYPE;

typedef struct {
    CONNECT_TYPE            Type;
    PKINTERRUPT             Interrupt;
    PKINTERRUPT_ROUTINE     NoDispatch;
    PKINTERRUPT_ROUTINE     InterruptDispatch;
    PKINTERRUPT_ROUTINE     FloatingDispatch;
    PKINTERRUPT_ROUTINE     ChainedDispatch;
    PKINTERRUPT_ROUTINE    *FlatDispatch;
} DISPATCH_INFO, *PDISPATCH_INFO;


VOID
KiGetVectorInfo (
    IN  ULONG                Vector,
    OUT PDISPATCH_INFO       DispatchInfo
    );

VOID
KiConnectVectorAndInterruptObject (
    IN PKINTERRUPT Interrupt,
    IN CONNECT_TYPE Type
    );


VOID
KeInitializeInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN PVOID ServiceContext,
    IN PKSPIN_LOCK SpinLock OPTIONAL,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KIRQL SynchronizeIrql,
    IN KINTERRUPT_MODE InterruptMode,
    IN BOOLEAN ShareVector,
    IN CCHAR ProcessorNumber,
    IN BOOLEAN FloatingSave
    )

/*++

Routine Description:

    This function initializes a kernel interrupt object. The service routine,
    service context, spin lock, vector, IRQL, SynchronizeIrql, and floating
    context save flag are initialized.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

    ServiceRoutine - Supplies a pointer to a function that is to be
        executed when an interrupt occurs via the specified interrupt
        vector.

    ServiceContext - Supplies a pointer to an arbitrary data structure which is
        to be passed to the function specified by the ServiceRoutine parameter.

    SpinLock - Supplies a pointer to an executive spin lock.

    Vector - Supplies the index of the entry in the Interrupt Dispatch Table
        that is to be associated with the ServiceRoutine function.

    Irql - Supplies the request priority of the interrupting source.

    SynchronizeIrql - The request priority that the interrupt should be
        synchronized with.

    InterruptMode - Supplies the mode of the interrupt; LevelSensitive or

    ShareVector - Supplies a boolean value that specifies whether the
        vector can be shared with other interrupt objects or not.  If FALSE
        then the vector may not be shared, if TRUE it may be.
        Latched.

    ProcessorNumber - Supplies the number of the processor to which the
        interrupt will be connected.

    FloatingSave - Supplies a boolean value that determines whether the
        floating point registers and pipe line are to be saved before calling
        the ServiceRoutine function.

Return Value:

    None.

--*/

{

    LONG Index;
    PULONG pl;
    PULONG NormalDispatchCode;

    //
    // Initialize standard control object header.
    //

    Interrupt->Type = InterruptObject;
    Interrupt->Size = sizeof(KINTERRUPT);

    //
    // Initialize the address of the service routine,
    // the service context, the address of the spin lock, the vector
    // number, the IRQL of the interrupting source, the Irql used for
    // synchronize execution, the interrupt mode, the processor
    // number, and the floating context save flag.
    //

    Interrupt->ServiceRoutine = ServiceRoutine;
    Interrupt->ServiceContext = ServiceContext;

    if (ARGUMENT_PRESENT(SpinLock)) {
        Interrupt->ActualLock = SpinLock;
    } else {
        KeInitializeSpinLock (&Interrupt->SpinLock);
        Interrupt->ActualLock = &Interrupt->SpinLock;
    }

    Interrupt->Vector = Vector;
    Interrupt->Irql = Irql;
    Interrupt->SynchronizeIrql = SynchronizeIrql;
    Interrupt->Mode = InterruptMode;
    Interrupt->ShareVector = ShareVector;
    Interrupt->Number = ProcessorNumber;
    Interrupt->FloatingSave = FloatingSave;

    //
    // Initialize fields for the interrupt storm detection. Set these
    // to -1 so that the first time through the interrupt dispatch they
    // will be reset correctly.
    //
    Interrupt->TickCount = (ULONG)-1;
    Interrupt->DispatchCount = (ULONG)-1;

    //
    // Copy the interrupt dispatch code template into the interrupt object
    // and edit the machine code stored in the structure (please see
    // _KiInterruptTemplate in intsup.asm.)  Finally, flush the dcache
    // on all processors that the current thread can
    // run on to ensure that the code is actually in memory.
    //

    NormalDispatchCode = &(Interrupt->DispatchCode[0]);

    pl = NormalDispatchCode;

    for (Index = 0; Index < NORMAL_DISPATCH_LENGTH; Index += 1) {
        *NormalDispatchCode++ = KiInterruptTemplate[Index];
    }

    //
    // The following two instructions set the address of current interrupt
    // object the the NORMAL dispatching code.
    //

    pl = (PULONG)((PUCHAR)pl + ((PUCHAR)&KiInterruptTemplateObject -
                                (PUCHAR)KiInterruptTemplate) -4); 
    *pl = (ULONG)Interrupt;

    KeSweepDcache(FALSE);

    //
    // Set the connected state of the interrupt object to FALSE.
    //

    Interrupt->Connected = FALSE;
    return;
}

BOOLEAN
KeConnectInterrupt (
    IN PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function connects an interrupt object to the interrupt vector
    specified by the interrupt object. If the interrupt object is already
    connected, or an attempt is made to connect to an interrupt that cannot
    be connected, then a value of FALSE is returned. Else the specified
    interrupt object is connected to the interrupt vector, the connected
    state is set to TRUE, and TRUE is returned as the function value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is already connected or an attempt is made to
    connect to an interrupt vector that cannot be connected, then a value
    of FALSE is returned. Else a value of TRUE is returned.

--*/

{
    DISPATCH_INFO DispatchInfo;
    BOOLEAN Connected;
    BOOLEAN ConnectError;
    BOOLEAN Enabled;
    KIRQL Irql;
    CCHAR Number;
    KIRQL OldIrql;
    ULONG Vector;

    //
    // If the interrupt object is already connected, the interrupt vector
    // number is invalid, an attempt is being made to connect to a vector
    // that cannot be connected, the interrupt request level is invalid, or
    // the processor number is invalid, then do not connect the interrupt
    // object. Else connect interrupt object to the specified vector and
    // establish the proper interrupt dispatcher.
    //

    Connected = FALSE;
    ConnectError = FALSE;
    Irql = Interrupt->Irql;
    Number = Interrupt->Number;
    Vector = Interrupt->Vector;
    if ( !((Irql > HIGH_LEVEL) ||
           (Number >= KeNumberProcessors) ||
           (Interrupt->SynchronizeIrql < Irql) ||
           (Interrupt->FloatingSave)    // R0 x87 usage not supported on x86
          )
       ) {

        //
        //
        // Set system affinity to the specified processor.
        //

        KeSetSystemAffinityThread((KAFFINITY)(1<<Number));

        //
        // Raise IRQL to dispatcher level and lock dispatcher database.
        //

        KiLockDispatcherDatabase(&OldIrql);

        //
        // Is interrupt object already connected?
        //

        if (!Interrupt->Connected) {

            //
            // Determine interrupt dispatch vector
            //

            KiGetVectorInfo (
                Vector,
                &DispatchInfo
                );

            //
            // If dispatch vector is not connected, then connect it
            //

            if (DispatchInfo.Type == NoConnect) {
                Connected = TRUE;
                Interrupt->Connected = TRUE;

                //
                // Connect interrupt dispatch to interrupt object dispatch code
                //

                InitializeListHead(&Interrupt->InterruptListEntry);
                KiConnectVectorAndInterruptObject (Interrupt, NormalConnect);

                //
                // Enabled system vector
                //

                Enabled = HalEnableSystemInterrupt(Vector, Irql, Interrupt->Mode);
                if (!Enabled) {
                    ConnectError = TRUE;
                }


            } else if (DispatchInfo.Type != UnkownConnect &&
                       Interrupt->ShareVector  &&
                       DispatchInfo.Interrupt->ShareVector  &&
                       DispatchInfo.Interrupt->Mode == Interrupt->Mode) {

                //
                // Vector is already connected as sharable.  New vector is sharable
                // and modes match.  Chain new vector.
                //

                Connected = TRUE;
                Interrupt->Connected = TRUE;

                ASSERT (Irql <= SYNCH_LEVEL);

                //
                // If not already using chained dispatch handler, set it up
                //

                if (DispatchInfo.Type != ChainConnect) {
                    KiConnectVectorAndInterruptObject (DispatchInfo.Interrupt, ChainConnect);
                }

                //
                // Add to tail of chained dispatch
                //

                InsertTailList(
                    &DispatchInfo.Interrupt->InterruptListEntry,
                    &Interrupt->InterruptListEntry
                    );

            }
        }

        //
        // Unlock dispatcher database and lower IRQL to its previous value.
        //

        KiUnlockDispatcherDatabase(OldIrql);

        //
        // Set system affinity back to the original value.
        //

        KeRevertToUserAffinityThread();
    }

    if (Connected  &&  ConnectError) {
#if DBG
        DbgPrint ("HalEnableSystemInterrupt failed\n");
#endif
        KeDisconnectInterrupt (Interrupt);
        Connected = FALSE;
    }

    //
    // Return whether interrupt was connected to the specified vector.
    //

    return Connected;
}

BOOLEAN
KeDisconnectInterrupt (
    IN PKINTERRUPT Interrupt
    )

/*++

Routine Description:

    This function disconnects an interrupt object from the interrupt vector
    specified by the interrupt object. If the interrupt object is not
    connected, then a value of FALSE is returned. Else the specified interrupt
    object is disconnected from the interrupt vector, the connected state is
    set to FALSE, and TRUE is returned as the function value.

Arguments:

    Interrupt - Supplies a pointer to a control object of type interrupt.

Return Value:

    If the interrupt object is not connected, then a value of FALSE is
    returned. Else a value of TRUE is returned.

--*/

{

    DISPATCH_INFO DispatchInfo;
    BOOLEAN Connected;
    PKINTERRUPT Interrupty;
    KIRQL Irql;
    KIRQL OldIrql;
    ULONG Vector;

    //
    // Set system affinity to the specified processor.
    //

    KeSetSystemAffinityThread((KAFFINITY)(1<<Interrupt->Number));

    //
    // Raise IRQL to dispatcher level and lock dispatcher database.
    //

    KiLockDispatcherDatabase(&OldIrql);

    //
    // If the interrupt object is connected, then disconnect it from the
    // specified vector.
    //

    Connected = Interrupt->Connected;
    if (Connected) {
        Irql = Interrupt->Irql;
        Vector = Interrupt->Vector;

        //
        // If the specified interrupt vector is not connected to the chained
        // interrupt dispatcher, then disconnect it by setting its dispatch
        // address to the unexpected interrupt routine. Else remove the
        // interrupt object from the interrupt chain. If there is only
        // one entry remaining in the list, then reestablish the dispatch
        // address.
        //

        //
        // Determine interrupt dispatch vector
        //

        KiGetVectorInfo (
            Vector,
            &DispatchInfo
            );


        //
        // Is dispatch a chained handler?
        //

        if (DispatchInfo.Type == ChainConnect) {

            ASSERT (Irql <= SYNCH_LEVEL);

            //
            // Is interrupt being removed from head?
            //

            if (Interrupt == DispatchInfo.Interrupt) {

                //
                // Update next interrupt object to be head
                //

                DispatchInfo.Interrupt = CONTAINING_RECORD(
                                               DispatchInfo.Interrupt->InterruptListEntry.Flink,
                                               KINTERRUPT,
                                               InterruptListEntry
                                               );

                KiConnectVectorAndInterruptObject (DispatchInfo.Interrupt, ChainConnect);
            }

            //
            // Remove interrupt object
            //

            RemoveEntryList(&Interrupt->InterruptListEntry);

            //
            // If there's only one interrupt object left on this vector,
            // determine proper interrupt dispatcher
            //

            Interrupty = CONTAINING_RECORD(
                                DispatchInfo.Interrupt->InterruptListEntry.Flink,
                                KINTERRUPT,
                                InterruptListEntry
                                );

            if (DispatchInfo.Interrupt == Interrupty) {
                KiConnectVectorAndInterruptObject (Interrupty, NormalConnect);
            }

        } else {

            //
            // Removing last interrupt object from the vector.  Disable the
            // vector, and set it to unconnected
            //

            HalDisableSystemInterrupt(Interrupt->Vector, Irql);
            KiConnectVectorAndInterruptObject (Interrupt, NoConnect);
        }


        KeSweepIcache(TRUE);
        Interrupt->Connected = FALSE;
    }

    //
    // Unlock dispatcher database and lower IRQL to its previous value.
    //

    KiUnlockDispatcherDatabase(OldIrql);

    //
    // Set system affinity back to the original value.
    //

    KeRevertToUserAffinityThread();

    //
    // Return whether interrupt was disconnected from the specified vector.
    //

    return Connected;
}

VOID
KiGetVectorInfo (
    IN  ULONG                Vector,
    OUT PDISPATCH_INFO       DispatchInfo
    )
{
    PKINTERRUPT_ROUTINE Dispatch;
    ULONG CurrentDispatch;
    ULONG DispatchType;
    UCHAR IDTEntry;

    //
    // Get second level dispatch point
    //


    DispatchType = HalSystemVectorDispatchEntry (
                        Vector,
                        &DispatchInfo->FlatDispatch,
                        &DispatchInfo->NoDispatch
                        );

    //
    // Get vector info
    //

    switch (DispatchType) {
        case 0:
            //
            // Primary dispatch
            //

            IDTEntry = HalVectorToIDTEntry(Vector);
            DispatchInfo->NoDispatch = (PKINTERRUPT_ROUTINE) (((ULONG) &KiStartUnexpectedRange) +
                                     (IDTEntry - PRIMARY_VECTOR_BASE) * KiUnexpectedEntrySize);

            DispatchInfo->InterruptDispatch = KiInterruptDispatch;
            DispatchInfo->FloatingDispatch = KiFloatingDispatch;
            DispatchInfo->ChainedDispatch = KiChainedDispatch;
            DispatchInfo->FlatDispatch = NULL;

            CurrentDispatch = (ULONG) KiReturnHandlerAddressFromIDT(Vector);
            DispatchInfo->Interrupt = CONTAINING_RECORD (
                                        CurrentDispatch,
                                        KINTERRUPT,
                                        DispatchCode
                                        );
            break;

        case 1:
            //
            // Secondardy dispatch.
            //

            DispatchInfo->InterruptDispatch = KiInterruptDispatch2ndLvl;
            DispatchInfo->FloatingDispatch = KiInterruptDispatch2ndLvl;
            DispatchInfo->ChainedDispatch = KiChainedDispatch2ndLvl;

            CurrentDispatch = (ULONG) *DispatchInfo->FlatDispatch;
            DispatchInfo->Interrupt = (PKINTERRUPT) ( (PUCHAR) CurrentDispatch -
                                            (PUCHAR) KiInterruptTemplate +
                                            (PUCHAR) &KiInterruptTemplate2ndDispatch
                                            );
            break;

        default:
            // Other values reserved
            KeBugCheck (MISMATCHED_HAL);
    }


    //
    // Determine dispatch type
    //

    if (((PKINTERRUPT_ROUTINE) CurrentDispatch) == DispatchInfo->NoDispatch) {

        //
        // Is connected to the NoDispatch function
        //

        DispatchInfo->Type = NoConnect;

    } else {
        Dispatch = DispatchInfo->Interrupt->DispatchAddress;

        if (Dispatch == DispatchInfo->ChainedDispatch) {
            //
            // Is connected to the chained handler
            //

            DispatchInfo->Type = ChainConnect;

        } else if (Dispatch == DispatchInfo->InterruptDispatch ||
                   Dispatch == DispatchInfo->FloatingDispatch) {
            //
            // If connection to the non-chained handler
            //

            DispatchInfo->Type = NormalConnect;

        } else {

            //
            // Unkown connection
            //

            DispatchInfo->Type = UnkownConnect;
#if DBG
            DbgPrint ("KiGetVectorInfo not understood\n");
#endif
        }
    }
}

VOID
KiConnectVectorAndInterruptObject (
    IN PKINTERRUPT Interrupt,
    IN CONNECT_TYPE Type
    )
{
    PKINTERRUPT_ROUTINE DispatchAddress;
    DISPATCH_INFO DispatchInfo;
    PULONG pl;

    //
    // Get current connect info
    //

    KiGetVectorInfo (
        Interrupt->Vector,
        &DispatchInfo
        );

    //
    // If disconnecting, set vector to NoDispatch
    //

    if (Type == NoConnect) {

        DispatchAddress = DispatchInfo.NoDispatch;

    } else {

        //
        // Set interrupt objects dispatch for new type
        //

        DispatchAddress = DispatchInfo.ChainedDispatch;

        if (Type == NormalConnect) {
            DispatchAddress = DispatchInfo.InterruptDispatch;
            if (Interrupt->FloatingSave) {
                DispatchAddress = DispatchInfo.FloatingDispatch;
            }
        }

        Interrupt->DispatchAddress = DispatchAddress;

        //
        // Set interrupt objects dispatch code to kernel dispatcher
        //

        pl = &(Interrupt->DispatchCode[0]);
        pl = (PULONG)((PUCHAR)pl +
                    ((PUCHAR)&KiInterruptTemplateDispatch -
                     (PUCHAR)KiInterruptTemplate) -4); 

        *pl = (ULONG)DispatchAddress-(ULONG)((PUCHAR)pl+4);

        //
        // Set dispatch vector to proper address dispatch code location
        //

        if (DispatchInfo.FlatDispatch) {

            //
            // Connect to flat dispatch
            //

            DispatchAddress = (PKINTERRUPT_ROUTINE)
                    ((PUCHAR) &(Interrupt->DispatchCode[0]) +
                     ((PUCHAR) &KiInterruptTemplate2ndDispatch -
                      (PUCHAR) KiInterruptTemplate));

        } else {

            //
            // Connect to enter_all dispatch
            //

            DispatchAddress = (PKINTERRUPT_ROUTINE) &Interrupt->DispatchCode;
        }
    }


    if (DispatchInfo.FlatDispatch) {

        //
        // Connect to flat dispatch
        //

        *DispatchInfo.FlatDispatch = DispatchAddress;

    } else {

        //
        // Connect to IDT
        //

        KiSetHandlerAddressToIDT (Interrupt->Vector, DispatchAddress);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\int.asm ===
title  "Trap Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    int.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process i386
;    interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 8-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include callconv.inc
        .list

;
; Interrupt flag bit maks for EFLAGS
;

EFLAGS_IF                       equ     200H
EFLAGS_SHIFT                    equ     9

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

; NOTE  This routine is never actually called on standard x86 hardware,
;       because passive level doesn't actually exist.  It's here to
;       fill out the portable skeleton.
;
; The following code is called when a passive release occurs and there is
; no interrupt to process.
;

cPublicProc _KiPassiveRelease       ,0
        stdRET    _KiPassiveRelease                             ; cReturn
stdENDP _KiPassiveRelease


        page ,132
        subttl  "Disable Processor Interrupts"
;++
;
; BOOLEAN
; KeDisableInterrupts(
;    VOID
;    )
;
; Routine Description:
;
;    This routine disables interrupts at the processor level.  It does not
;    edit the PICS or adjust IRQL, it is for use in the debugger only.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    (eax) = !0 if interrupts were on, 0 if they were off
;
;--

cPublicProc _KeDisableInterrupts    ,0
cPublicFpo 0, 0
        pushfd
        pop     eax
        and     eax,EFLAGS_IF               ; (eax) = the interrupt bit
        shr     eax,EFLAGS_SHIFT            ; low bit of (eax) == interrupt bit
        cli
        stdRET    _KeDisableInterrupts

stdENDP _KeDisableInterrupts

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\iopm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    iopm.c

Abstract:

    This module implements interfaces that support manipulation of i386
    i/o access maps (IOPMs).

    These entry points only exist on i386 machines.

Author:

    Bryan M. Willman (bryanwi) 18-Sep-91

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Our notion of alignment is different, so force use of ours
//

#undef  ALIGN_UP
#undef  ALIGN_DOWN
#define ALIGN_DOWN(address,amt) ((ULONG)(address) & ~(( amt ) - 1))
#define ALIGN_UP(address,amt) (ALIGN_DOWN( (address + (amt) - 1), (amt) ))

//
// Note on synchronization:
//
//  IOPM edits are always done by code running at synchronization level on
//  the processor whose TSS (map) is being edited.
//
//  IOPM only affects user mode code.  User mode code can never interrupt
//  synchronization level code, therefore, edits and user code never race.
//
//  Likewise, switching from one map to another occurs on the processor
//  for which the switch is being done by IPI_LEVEL code.  The active
//  map could be switched in the middle of an edit of some map, but
//  the edit will always complete before any user code gets run on that
//  processor, therefore, there is no race.
//
//  Multiple simultaneous calls to Ke386SetIoAccessMap *could* produce
//  weird mixes.  Therefore, KiIopmLock must be acquired to
//  globally serialize edits.
//

//
// Define forward referenced function prototypes.
//

VOID
KiSetIoMap(
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID MapSource,
    IN PVOID MapNumber,
    IN PVOID Parameter3
    );

VOID
KiLoadIopmOffset(
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

BOOLEAN
Ke386SetIoAccessMap (
    ULONG MapNumber,
    PKIO_ACCESS_MAP IoAccessMap
    )

/*++

Routine Description:

    The specified i/o access map will be set to match the
    definition specified by IoAccessMap (i.e. enable/disable
    those ports) before the call returns.  The change will take
    effect on all processors.

    Ke386SetIoAccessMap does not give any process enhanced I/O
    access, it merely defines a particular access map.

Arguments:

    MapNumber - Number of access map to set.  Map 0 is fixed.

    IoAccessMap - Pointer to bitvector (64K bits, 8K bytes) which
           defines the specified access map.  Must be in
           non-paged pool.

Return Value:

    TRUE if successful.  FALSE if failure (attempt to set a map
    which does not exist, attempt to set map 0)

--*/

{

    PKPROCESS CurrentProcess;
    KIRQL OldIrql;
    PKPRCB Prcb;
    PVOID pt;
    KAFFINITY TargetProcessors;

    //
    // Reject illegal requests
    //

    if ((MapNumber > IOPM_COUNT) || (MapNumber == IO_ACCESS_MAP_NONE)) {
        return FALSE;
    }

    //
    // Acquire the context swap lock so a context switch will not occur.
    //

    KiLockContextSwap(&OldIrql);

    //
    // Compute set of active processors other than this one, if non-empty
    // IPI them to set their maps.
    //

    Prcb = KeGetCurrentPrcb();

#if !defined(NT_UP)

    TargetProcessors = KeActiveProcessors & ~Prcb->SetMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiSetIoMap,
                        IoAccessMap,
                        (PVOID)MapNumber,
                        NULL);
    }

#endif

    //
    // Copy the IOPM map and load the map for the current process.
    //

    pt = &(KiPcr()->TSS->IoMaps[MapNumber-1].IoMap);
    RtlCopyMemory(pt, (PVOID)IoAccessMap, IOPM_SIZE);
    CurrentProcess = Prcb->CurrentThread->ApcState.Process;
    KiPcr()->TSS->IoMapBase = CurrentProcess->IopmOffset;

    //
    // Wait until all of the target processors have finished copying the
    // new map.
    //

#if !defined(NT_UP)

    if (TargetProcessors != 0) {
        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    //
    // Restore IRQL and unlock the context swap lock.
    //

    KiUnlockContextSwap(OldIrql);
    return TRUE;
}

#if !defined(NT_UP)


VOID
KiSetIoMap(
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID MapSource,
    IN PVOID MapNumber,
    IN PVOID Parameter3
    )
/*++

Routine Description:

    copy the specified map into this processor's TSS.
    This procedure runs at IPI level.

Arguments:

    Argument - actually a pointer to a KIPI_SET_IOPM structure
    ReadyFlag - pointer to flag to set once setiopm has completed

Return Value:

    none

--*/

{

    PKPROCESS CurrentProcess;
    PKPRCB Prcb;
    PVOID pt;

    //
    // Copy the IOPM map and load the map for the current process.
    //

    Prcb = KeGetCurrentPrcb();
    pt = &(KiPcr()->TSS->IoMaps[((ULONG) MapNumber)-1].IoMap);
    RtlCopyMemory(pt, MapSource, IOPM_SIZE);
    CurrentProcess = Prcb->CurrentThread->ApcState.Process;
    KiPcr()->TSS->IoMapBase = CurrentProcess->IopmOffset;
    KiIpiSignalPacketDone(SignalDone);
    return;
}

#endif


BOOLEAN
Ke386QueryIoAccessMap (
    ULONG MapNumber,
    PKIO_ACCESS_MAP IoAccessMap
    )

/*++

Routine Description:

    The specified i/o access map will be dumped into the buffer.
    map 0 is a constant, but will be dumped anyway.

Arguments:

    MapNumber - Number of access map to set.  map 0 is fixed.

    IoAccessMap - Pointer to buffer (64K bits, 8K bytes) which
           is to receive the definition of the access map.
           Must be in non-paged pool.

Return Value:

    TRUE if successful.  FALSE if failure (attempt to query a map
    which does not exist)

--*/

{

    ULONG i;
    PVOID Map;
    KIRQL OldIrql;
    PUCHAR p;

    //
    // Reject illegal requests
    //

    if (MapNumber > IOPM_COUNT) {
        return FALSE;
    }

    //
    // Acquire the context swap lock so a context switch will not occur.
    //

    KiLockContextSwap(&OldIrql);

    //
    // Copy out the map
    //

    if (MapNumber == IO_ACCESS_MAP_NONE) {

        //
        // no access case, simply return a map of all 1s
        //

        p = (PUCHAR)IoAccessMap;
        for (i = 0; i < IOPM_SIZE; i++) {
            p[i] = (UCHAR)-1;
        }

    } else {

        //
        // normal case, just copy the bits
        //

        Map = (PVOID)&(KiPcr()->TSS->IoMaps[MapNumber-1].IoMap);
        RtlCopyMemory((PVOID)IoAccessMap, Map, IOPM_SIZE);
    }

    //
    // Restore IRQL and unlock the context swap lock.
    //

    KiUnlockContextSwap(OldIrql);
    return TRUE;
}


BOOLEAN
Ke386IoSetAccessProcess (
    PKPROCESS Process,
    ULONG MapNumber
    )
/*++

Routine Description:

    Set the i/o access map which controls user mode i/o access
    for a particular process.

Arguments:

    Process - Pointer to kernel process object describing the
    process which for which a map is to be set.

    MapNumber - Number of the map to set.  Value of map is
    defined by Ke386IoSetAccessProcess.  Setting MapNumber
    to IO_ACCESS_MAP_NONE will disallow any user mode i/o
    access from the process.

Return Value:

    TRUE if success, FALSE if failure (illegal MapNumber)

--*/

{

    USHORT MapOffset;
    KIRQL OldIrql;
    PKPRCB Prcb;
    KAFFINITY TargetProcessors;

    //
    // Reject illegal requests
    //

    if (MapNumber > IOPM_COUNT) {
        return FALSE;
    }

    MapOffset = KiComputeIopmOffset(MapNumber);

    //
    // Acquire the context swap lock so a context switch will not occur.
    //

    KiLockContextSwap(&OldIrql);

    //
    // Store new offset in process object,  compute current set of
    // active processors for process, if this cpu is one, set IOPM.
    //

    Process->IopmOffset = MapOffset;

    TargetProcessors = Process->ActiveProcessors;
    Prcb = KeGetCurrentPrcb();
    if (TargetProcessors & Prcb->SetMember) {
        KiPcr()->TSS->IoMapBase = MapOffset;
    }

    //
    // Compute set of active processors other than this one, if non-empty
    // IPI them to load their IOPMs, wait for them.
    //

#if !defined(NT_UP)

    TargetProcessors = TargetProcessors & ~Prcb->SetMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        KiLoadIopmOffset,
                        NULL,
                        NULL,
                        NULL);

        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    //
    // Restore IRQL and unlock the context swap lock.
    //

    KiUnlockContextSwap(OldIrql);
    return TRUE;
}

#if !defined(NT_UP)


VOID
KiLoadIopmOffset(
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    Edit IopmBase of Tss to match that of currently running process.

Arguments:

    Argument - actually a pointer to a KIPI_LOAD_IOPM_OFFSET structure
    ReadyFlag - Pointer to flag to be set once we are done

Return Value:

    none

--*/

{

    PKPROCESS CurrentProcess;
    PKPRCB Prcb;

    //
    // Update IOPM field in TSS from current process
    //

    Prcb = KeGetCurrentPrcb();
    CurrentProcess = Prcb->CurrentThread->ApcState.Process;
    KiPcr()->TSS->IoMapBase = CurrentProcess->IopmOffset;
    KiIpiSignalPacketDone(SignalDone);
    return;
}

#endif


VOID
Ke386SetIOPL(
    IN PKPROCESS Process
    )

/*++

Routine Description:

    Gives IOPL to the specified process.

    All threads created from this point on will get IOPL.  The current
    process will get IOPL.  Must be called from context of thread and
    process that are to have IOPL.

    Iopl (to be made a boolean) in KPROCESS says all
    new threads to get IOPL.

    Iopl (to be made a boolean) in KTHREAD says given
    thread to get IOPL.

    N.B.    If a kernel mode only thread calls this procedure, the
            result is (a) poinless and (b) will break the system.

Arguments:

    Process - Pointer to the process == IGNORED!!!

Return Value:

    none

--*/

{

    PKTHREAD    Thread;
    PKPROCESS   Process2;
    PKTRAP_FRAME    TrapFrame;
    CONTEXT     Context;

    //
    // get current thread and Process2, set flag for IOPL in both of them
    //

    Thread = KeGetCurrentThread();
    Process2 = Thread->ApcState.Process;

    Process2->Iopl = 1;
    Thread->Iopl = 1;

    //
    // Force IOPL to be on for current thread
    //

    TrapFrame = (PKTRAP_FRAME)((PUCHAR)Thread->InitialStack -
                ALIGN_UP(sizeof(KTRAP_FRAME),KTRAP_FRAME_ALIGN) -
                sizeof(FX_SAVE_AREA));

    Context.ContextFlags = CONTEXT_CONTROL;
    KeContextFromKframes(TrapFrame,
                         NULL,
                         &Context);

    Context.EFlags |= (EFLAGS_IOPL_MASK & -1);  // IOPL == 3

    KeContextToKframes(TrapFrame,
                       NULL,
                       &Context,
                       CONTEXT_CONTROL,
                       UserMode);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\intsup.asm ===
TITLE  "Interrupt Object Support Routines"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    intsup.asm
;
; Abstract:
;
;    This module implements the code necessary to support interrupt objects.
;    It contains the interrupt dispatch code and the code template that gets
;    copied into an interrupt object.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 20-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--
.386p
        .xlist
KERNELONLY  equ     1
include ks386.inc
include i386\kimacro.inc
include mac386.inc
include callconv.inc
        .list

        EXTRNP  KfRaiseIrql,1,IMPORT,FASTCALL
        EXTRNP  KfLowerIrql,1,IMPORT,FASTCALL
        EXTRNP  _KeBugCheck,1
        EXTRNP  _KeBugCheckEx,5
        EXTRNP  _KiDeliverApc,3
        EXTRNP  _HalBeginSystemInterrupt,3,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2,IMPORT
        EXTRNP  Kei386EoiHelper
        EXTRNP  PerfInfoLogInterrupt,4,,FASTCALL

if DBG
        extrn   _DbgPrint:near
        extrn   _MsgISRTimeout:BYTE
        extrn   _KiISRTimeout:DWORD
endif
        extrn   _DbgPrint:near
        extrn   _MsgISROverflow:BYTE
        extrn   _KeTickCount:DWORD
        extrn   _KiISROverflow:WORD
        extrn   _KdDebuggerEnabled:BYTE
        extrn   _PPerfGlobalGroupMask:DWORD

MI_MOVEDI       EQU     0BFH            ; op code for mov  edi, constant
MI_DIRECTJMP    EQU     0E9H            ; op code for indirect jmp
                                        ; or index registers

if DBG
DETECT_INT_STORM    EQU 1
else
DETECT_INT_STORM    EQU 0
endif


if DETECT_INT_STORM

INT_TICK_MASK   EQU     03FH

;
; Macro to check for an interrupt storm on a particular interrupt object
;
CHECK_INT_STORM macro Prefix
        mov     eax, _KeTickCount               ; current time
        and     eax, NOT INT_TICK_MASK          ; mask to closest 640ms
        cmp     eax, dword ptr [edi].InTickCount  ; in same 640ms second range
        jg      Prefix&_overflowreset     ; tick count has advanced since last interrupt, reset counts
        jl      Prefix&_waittick          ; we have already overflowed interrupt count for this tick, do nothing
                                                ; until the clock advances to the next tick period

        dec     word ptr [edi].InDispatchCount
        jz      Prefix&_interruptoverflow           ; interrupt count has just overflowed
Prefix&_dbg2:

        endm

CHECK_INT_STORM_TAIL macro Prefix, BugCheckID
Prefix&_interruptoverflow:

        dec     word ptr [edi].InDispatchCount+2
        jz      short @f
        add     eax, INT_TICK_MASK+1
        mov     [edi].InTickCount, eax  ; bump tick count to next tick
        jmp     short Prefix&_overflowreset2
        
@@:
        cmp     _KdDebuggerEnabled, 0
        jnz     short @f
        stdCall _KeBugCheckEx, <HARDWARE_INTERRUPT_STORM, [edi].InServiceRoutine, [edi].InServiceContext, edi, BugCheckID>

        ;
        ; Debugger is enabled so do a BP instead of bugchecking
        ;
@@:
        push    [edi].InServiceRoutine
        push    offset FLAT:_MsgISROverflow
        call    _DbgPrint
        add     esp, 8
        int 3
        mov     eax, _KeTickCount               ; current time
        and     eax, NOT INT_TICK_MASK          ; mask to closest 20 second
        ;
        ; deliberately fall through to reset the count
        ;


Prefix&_overflowreset:
        mov     dword ptr [edi].InTickCount, eax  ; initialize time
        mov     word ptr [edi].InDispatchCount+2, 64     ; 
Prefix&_overflowreset2:
        mov     ax, _KiISROverflow
        mov     word ptr [edi].InDispatchCount, ax      ; reset count
        jmp     Prefix&_dbg2

;
; Additional work we do here in Prefix&_waittick is to make sure the tickcount
; didn't actually wrap and send us here.
;
Prefix&_waittick:
        add     eax, INT_TICK_MASK+1
        cmp     eax, dword ptr [edi].InTickCount
        je      Prefix&_dbg2                        ; exactly one tick apart, do nothing
        ;
        ; tick count must have wrapped - reset all counters
        ;
        mov     eax, _KeTickCount
        jmp     short Prefix&_overflowreset
        endm

else 

CHECK_INT_STORM macro Prefix
        endm

CHECK_INT_STORM_TAIL macro Prefix, BugCheckID
        endm

endif

        page ,132
        subttl  "Syn0chronize Execution"

_TEXT$00   SEGMENT PARA PUBLIC 'CODE'

;++
;
; BOOLEAN
; KeSynchronizeExecution (
;    IN PKINTERRUPT Interrupt,
;    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
;    IN PVOID SynchronizeContext
;    )
;
; Routine Description:
;
;    This function synchronizes the execution of the specified routine with the
;    execution of the service routine associated with the specified interrupt
;    object.
;
; Arguments:
;
;    Interrupt - Supplies a pointer to a control object of type interrupt.
;
;    SynchronizeRoutine - Supplies a pointer to a function whose execution
;       is to be synchronized with the execution of the service routine
;       associated with the specified interrupt object.
;
;    SynchronizeContext - Supplies a pointer to an arbitrary data structure
;       which is to be passed to the function specified by the
;       SynchronizeRoutine parameter.
;
; Return Value:
;
;    The value returned by the SynchronizeRoutine function is returned as the
;    function value.
;
;--
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
cPublicProc _KeSynchronizeExecution ,3

        push    ebx                     ; save nonvolatile register
        mov     ebx, 8[esp]             ; get interrupt object address
        mov     ecx, InSynchronizeIrql[ebx] ; get synchronization IRQL
        fstCall KfRaiseIrql             ; raise IRQL to synchronization level
        push    eax                     ; save previous IRQL

ifndef NT_UP
        mov     ebx,InActualLock[ebx]   ; get actual lock address

kse10:  ACQUIRE_SPINLOCK ebx,<short kse20>  ; acquire spin lock
endif

        push    20[esp]                 ; push synchronization context routine
        CAPSTART <_KeSynchronizeExecution@12,[esp+20]>
        call    20[esp]                 ; call synchronization routine
        CAPEND <_KeSynchronizeExecution@12>

ifndef NT_UP
        RELEASE_SPINLOCK ebx            ; release spin lock
endif

        mov     ebx, eax                ; save synchronization routine value
        pop     ecx                     ; retrieve previous IRQL
        fstCall KfLowerIrql             ; lower IRQL to previous value
        mov     eax, ebx                ; set return value
        pop     ebx                     ; restore nonvolatile register

        stdRET  _KeSynchronizeExecution

ifndef NT_UP
kse20:  SPIN_ON_SPINLOCK ebx,<short kse10>  ; wait until lock is free
endif

stdENDP _KeSynchronizeExecution

        page ,132
        subttl  "Chained Dispatch"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is connected to more than one interrupt object.
;
; Arguments:
;
;    edi - Supplies a pointer to the interrupt object.
;    esp - Supplies a pointer to the top of trap frame
;    ebp - Supplies a pointer to the top of trap frame
;
; Return Value:
;
;    None.
;
;--


align 16
cPublicProc _KiChainedDispatch      ,0
.FPO (2, 0, 0, 0, 0, 1)

;
; update statistic
;

        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

;
; set ebp to the top of trap frame.  We don't need to save ebp because
; it is saved in trap frame already.
;

        mov     ebp, esp                ; (ebp)->trap frame

;
; Save previous IRQL and set new priority level
;

        mov     eax, [edi].InVector     ; save vector
        push    eax
        sub     esp, 4                  ; make room for OldIrql
        mov     ecx, [edi].InIrql       ; Irql

;
; esp - pointer to OldIrql
; eax - vector
; ecx - Irql
;

        stdCall   _HalBeginSystemInterrupt, <ecx, eax, esp>
        or      eax, eax                ; check for spurious int.
        jz      kid_spuriousinterrupt

        stdCall _KiChainedDispatch2ndLvl

        INTERRUPT_EXIT                  ; will do an iret

stdENDP _KiChainedDispatch


        page ,132
        subttl  "Chained Dispatch 2nd Level"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is either connected to more than one interrupt object,
;    or is being 2nd level dispatched.  Its function is to walk the list
;    of connected interrupt objects and call each interrupt service routine.
;    If the mode of the interrupt is latched, then a complete traversal of
;    the chain must be performed. If any of the routines require saving the
;    floating point machine state, then it is only saved once.
;
; Arguments:
;
;    edi - Supplies a pointer to the interrupt object.
;
; Return Value:
;
;   None.
;   Uses all registers
;
;--


public _KiInterruptDispatch2ndLvl@0
_KiInterruptDispatch2ndLvl@0:
        nop

cPublicProc _KiChainedDispatch2ndLvl,0
cPublicFpo 0, 3

        push    ebp
        sub     esp, 20                 ; Make room for scratch and local values
;
;   [esp]       OldIrql
;   [esp+4]     Scratch
;   [esp+8]     TimeStamp
;   [esp+16]    ISRTracingOn
;

        xor     ebp, ebp                ; init (ebp) = Interrupthandled = FALSE
        lea     ebx, [edi].InInterruptListEntry
                                        ; (ebx)->Interrupt Head List

        cmp     _PPerfGlobalGroupMask, 0 ; Is event tracing on?
        mov     [esp+16], 0             ; ISRTracingOn = 0
        jne     kcd120

;
; Walk the list of connected interrupt objects and call the appropriate dispatch
; routine.
;

kcd40:

;
; Raise irql level to the SynchronizeIrql level if it is not equal to current
; irql.
;

        mov     cl, [edi+InIrql]        ; [cl] = Current Irql
        mov     esi,[edi+InActualLock]
        cmp     [edi+InSynchronizeIrql], cl ; Is SyncIrql > current IRQL?
        je      short kcd50             ; if e, no, go kcd50

;
; Arg1 ecx : Irql to raise to
;

        mov     ecx, [edi+InSynchronizeIrql] ; (ecx) = Irql to raise to
        fstCall KfRaiseIrql
        mov     [esp], eax              ; Save OldIrql


;
; Acquire the service routine spin lock and call the service routine.
;

kcd50:
        ACQUIRE_SPINLOCK esi,kcd110
;
; Check for an interrupt storm on this interrupt object
;
        CHECK_INT_STORM kcd
if DBG
        mov     eax, _KeTickCount       ; Grab ISR start time
        mov     [esp+4], eax            ; save to local varible
endif
        mov     eax, InServiceContext[edi] ; set parameter value
        push    eax
        push    edi                     ; pointer to interrupt object
        CAPSTART <_KiInterruptDispatch2ndLvl@0,InServiceRoutine[edi]>
        call    InServiceRoutine[edi]   ; call specified routine
        CAPEND <_KiInterruptDispatch2ndLvl@0>

if DBG
        mov     ecx, [esp+4]            ; (ecx) = time isr started
        add     ecx, _KiISRTimeout      ; adjust for timeout
        cmp     _KeTickCount, ecx       ; Did ISR timeout?
        jnc     kcd200
kcd51:
endif

;
; Release the service routine spin lock and check to determine if end of loop.
;

        RELEASE_SPINLOCK esi

;
; Lower IRQL to earlier level if we raised it to SynchronizedLevel.
;

        mov     cl, [edi+InIrql]
        cmp     [edi+InSynchronizeIrql], cl ; Is SyncIrql > current IRQL?
        je      short kcd55             ; if e, no, go kcd55

        mov     esi, eax                ; save ISR returned value

;
; Arg1 : Irql to Lower to
;

        mov     ecx, [esp]
        fstCall KfLowerIrql

        mov     eax, esi                ; [eax] = ISR returned value
kcd55:
        cmp     [esp+16], 0             ; check if ISR logging is enabled
        jne     kcd140
kcd57:

        or      al,al                   ; Is interrupt handled?
        je      short kcd60             ; if eq, interrupt not handled
        cmp     word ptr InMode[edi], InLevelSensitive
        je      short kcd70             ; if eq, level sensitive interrupt

        mov     ebp, eax                ; else edge shared int is handled. Remember it.
kcd60:  mov     edi, [edi].InInterruptListEntry
                                        ; (edi)->next obj's addr of listentry
        cmp     ebx, edi                ; Are we at end of interrupt list?
        je      short kcd65             ; if eq, reach end of list
        sub     edi, InInterruptListEntry; (edi)->addr of next interrupt object

        cmp     [esp+16], 0             ; check if ISR logging is enabled
        jne     kcd130                  ; If enable, grab the begin time
        jmp     kcd40

kcd65:
;
; If this is edge shared interrupt, we need to loop till no one handle the
; interrupt.  In theory only shared edge triggered interrupts come here.
;

        sub     edi, InInterruptListEntry; (edi)->addr of next interrupt object
        cmp     word ptr InMode[edi], InLevelSensitive
        je      short kcd70             ; if level, exit.  No one handle the interrupt?

        test    ebp, 0fh                ; does anyone handle the interrupt?
        je      short kcd70             ; if e, no one, we can exit.

        xor     ebp, ebp                ; init local var to no one handle the int

        cmp     [esp+16], 0             ; check if ISR logging is enabled
        jne     kcd130                  ; If enable, grab the begin time
        jmp     kcd40                   ; restart the loop.

;
; Either the interrupt is level sensitive and has been handled or the end of
; the interrupt object chain has been reached.
;

; restore frame pointer, and deallocate trap frame.

kcd70:
        add     esp, 20                 ; clear local variable space
        pop     ebp
        stdRet  _KiChainedDispatch2ndLvl


; Service routine Lock is currently owned, spin until free and then
; attempt to acquire lock again.

ifndef NT_UP
kcd110: SPIN_ON_SPINLOCK esi, kcd50,,DbgMp
endif

;
; If ISR event tracing is on, note that it is and take a timestamp
;
kcd120:
        mov     edx, _PPerfGlobalGroupMask  ; Load the ptr into edx
        cmp     edx, 0                  ; catch race here
        jz      kcd40
        test    dword ptr [edx+PERF_INTERRUPT_OFFSET], PERF_INTERRUPT_FLAG
        jz      kcd40                   ; return if our flag is not set

        mov     [esp+16], 1             ; records that ISR tracing is enabled
;
; Get the timestamp before the ISR is called
;
kcd130:        
        PERF_GET_TIMESTAMP              ; Places 64bit in edx:eax and trashes ecx

        mov     [esp+8], eax            ; Time saved on the stack
        mov     [esp+12], edx
        jmp     kcd40

;
; Log the ISR, initial time, and return value
;
kcd140:
        push    eax                     ; save the ISRs return value

        mov     edx, eax                ; pass ISRs return value
        mov     eax, [esp+12]           ; push the initial timestamp
        mov     ecx, [esp+16]
        push    ecx
        push    eax     
        mov     ecx, InServiceRoutine[edi]
        fstCall PerfInfoLogInterrupt

        pop     eax                     ; restore the ISRs return value
        jmp     kcd57 

;
; ISR took a long time to complete, abort to debugger
;

if DBG
kcd200: push    eax                     ; save return code
        push    InServiceRoutine[edi]
        push    offset FLAT:_MsgISRTimeout
        call    _DbgPrint
        add     esp,8
        pop     eax
        int     3
        jmp     kcd51                   ; continue
endif

    CHECK_INT_STORM_TAIL kcd, 2

stdENDP _KiChainedDispatch2ndLvl


        page ,132
        subttl  "Floating Dispatch"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is connected to an interrupt object. Its function is
;    to save the machine state and floating state and then call the specified
;    interrupt service routine.
;
; Arguments:
;
;    edi - Supplies a pointer to the interrupt object.
;    esp - Supplies a pointer to the top of trap frame
;    ebp - Supplies a pointer to the top of trap frame
;
; Return Value:
;
;    None.
;
;--

align 16
cPublicProc _KiFloatingDispatch     ,0
.FPO (2, 0, 0, 0, 0, 1)

;
; update statistic
;
        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

; set ebp to the top of trap frame.  We don't need to save ebp because
; it is saved in trap frame already.
;

        mov     ebp, esp                ; (ebp)->trap frame

;
; Save previous IRQL and set new priority level to interrupt obj's SyncIrql
;
        mov     eax, [edi].InVector
        mov     ecx, [edi].InSynchronizeIrql ; Irql
        push    eax                     ; save vector
        sub     esp, 4                  ; make room for OldIrql

; arg3 - ptr to OldIrql
; arg2 - vector
; arg1 - Irql
        stdCall   _HalBeginSystemInterrupt, <ecx, eax, esp>

        or      eax, eax                ; check for spurious int.
        jz      kid_spuriousinterrupt

        sub     esp, 12                 ; make room for ISRTracingOn and InitialTime

        cmp     _PPerfGlobalGroupMask, 0 ; Is event tracing on?
        mov     [ebp-12], 0             ; ISRTracingOn = 0
        jne     kfd110
kfd20:

;
; Acquire the service routine spin lock and call the service routine.
;

kfd30:  mov     esi,[edi+InActualLock]
        ACQUIRE_SPINLOCK esi,kfd100

;
; Check for an interrupt storm on this interrupt object
;
        CHECK_INT_STORM kfd
if DBG
        mov     ebx, _KeTickCount       ; Grab current tick time
endif
        mov     eax, InServiceContext[edi] ; set parameter value
        push    eax
        push    edi                     ; pointer to interrupt object
        CAPSTART <_KiFloatingDispatch,InServiceRoutine[edi]>
        call    InServiceRoutine[edi]   ; call specified routine
        CAPEND   <_KiFloatingDispatch>
if DBG
        add     ebx, _KiISRTimeout      ; adjust for ISR timeout
        cmp     _KeTickCount, ebx       ; Did ISR timeout?
        jnc     kfd200
kfd31:
endif

;
; Release the service routine spin lock.
;

        RELEASE_SPINLOCK esi

        cmp     [ebp-12], 0             ; check if ISR logging is enabled
        jne     kfd120
kfd40:
        add     esp, 12

;
; Do interrupt exit processing
;
        INTERRUPT_EXIT                  ; will do an iret

;
; Service routine Lock is currently owned; spin until free and
; then attempt to acquire lock again.
;

ifndef NT_UP
kfd100: SPIN_ON_SPINLOCK esi,kfd30,,DbgMp
endif

;
; If ISR event tracing is on, collect a time stamp and record that we did.
;
kfd110:
        mov     edx, _PPerfGlobalGroupMask  ; Load the ptr into edx
        cmp     edx, 0                  ; catch race here
        jz      kfd20
        test    dword ptr [edx+PERF_INTERRUPT_OFFSET], PERF_INTERRUPT_FLAG
        jz      kfd20                   ; return if our flag is not set

        PERF_GET_TIMESTAMP              ; Places 64bit in edx:eax and trashes ecx

        mov     [ebp-16], eax           ; Time saved on the stack
        mov     [ebp-20], edx
        mov     [ebp-12], 1             ; Records that timestamp is on stack
        jmp     kfd20

;
; Log the ISR, initial time, and return value
;
kfd120:
        mov     edx, eax                ; pass ISRs return value
        mov     eax, [ebp-16]           ; push InitialTime
        mov     ecx, [ebp-20]
        push    ecx
        push    eax     
        mov     ecx, InServiceRoutine[edi]       
        fstCall PerfInfoLogInterrupt
        jmp     kfd40 

;
; ISR took a long time to complete, abort to debugger
;

if DBG
kfd200: push    InServiceRoutine[edi]   ; timed out
        push    offset FLAT:_MsgISRTimeout
        call    _DbgPrint
        add     esp,8
        int     3
        jmp     kfd31                   ; continue
endif
        CHECK_INT_STORM_TAIL kfd, 1

stdENDP _KiFloatingDispatch

        page ,132
        subttl  "Interrupt Dispatch"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is connected to an interrupt object. Its function is
;    to directly call the specified interrupt service routine.
;
; Arguments:
;
;    edi - Supplies a pointer to the interrupt object.
;    esp - Supplies a pointer to the top of trap frame
;    ebp - Supplies a pointer to the top of trap frame
;
; Return Value:
;
;    None.
;
;--

align 16
cPublicProc _KiInterruptDispatch    ,0
.FPO (2, 0, 0, 0, 0, 1)

;
; update statistic
;
        inc     dword ptr PCR[PcPrcbData+PbInterruptCount]

;
; set ebp to the top of trap frame.  We don't need to save ebp because
; it is saved in trap frame already.
;

        mov     ebp, esp                ; (ebp)->trap frame

;
; Save previous IRQL and set new priority level
;
        mov     eax, [edi].InVector     ; save vector
        mov     ecx, [edi].InSynchronizeIrql ; Irql to raise to
        push    eax
        sub     esp, 4                  ; make room for OldIrql

        stdCall   _HalBeginSystemInterrupt,<ecx, eax, esp>

        or      eax, eax                ; check for spurious int.
        jz      kid_spuriousinterrupt

        sub     esp, 12                 ; make room for ISRTracingOn and InitialTime

        cmp     _PPerfGlobalGroupMask, 0 ; Is event tracing on?
        mov     [ebp-12], 0             ; ISRTracingOn = 0
        jne     kid110                  ; check if ISR logging is enabled
kid20:

;
; Acquire the service routine spin lock and call the service routine.
;

kid30:  mov     esi,[edi+InActualLock]
        ACQUIRE_SPINLOCK esi,kid100

;
; Check for an interrupt storm on this interrupt object
;
        CHECK_INT_STORM kid
if DBG
        mov     ebx, _KeTickCount
endif
        mov     eax, InServiceContext[edi] ; set parameter value
        push    eax
        push    edi                     ; pointer to interrupt object
        CAPSTART <_KiInterruptDispatch,InServiceRoutine[edi]>
        call    InServiceRoutine[edi]   ; call specified routine
        CAPEND   <_KiInterruptDispatch>

if DBG
        add     ebx, _KiISRTimeout      ; adjust for ISR timeout
        cmp     _KeTickCount, ebx       ; Did ISR timeout?
        jnc     kid200
kid31:
endif

;
; Release the service routine spin lock, retrieve the return address,
; deallocate stack storage, and return.
;

        RELEASE_SPINLOCK esi

        cmp     [ebp-12], 0             ; check if ISR logging is enabled
        jne     kid120
kid40:
        add     esp, 12

;
; Do interrupt exit processing
;

        INTERRUPT_EXIT                  ; will do an iret

        add     esp, 8                  ; clean stack

kid_spuriousinterrupt:
        add     esp, 8                  ; Irql wasn't raised, exit interrupt
        SPURIOUS_INTERRUPT_EXIT         ; without eoi or lower irql

;
; Lock is currently owned; spin until free and then attempt to acquire
; lock again.
;

ifndef NT_UP
kid100: SPIN_ON_SPINLOCK esi,kid30,,DbgMp
endif

;
; If ISR event tracing is on, collect a time stamp and record that we did.
;
kid110:
        mov     edx, _PPerfGlobalGroupMask  ; Load the ptr into edx
        cmp     edx, 0                  ; catch race here
        jz      kid20
        test    dword ptr [edx+PERF_INTERRUPT_OFFSET], PERF_INTERRUPT_FLAG
        jz      kid20                   ; return if our flag is not set

        PERF_GET_TIMESTAMP              ; Places 64bit in edx:eax and trashes ecx

        mov     [ebp-16], eax            ; Time saved on the stack
        mov     [ebp-20], edx
        mov     [ebp-12], 1             ; Records that timestamp is on stack
        jmp     kid20

;
; Log the ISR, initial time, and return value
;
kid120:
        mov     edx, eax                ; pass the ISRs return value
        mov     eax, [ebp-16]           ; push InitialTime
        mov     ecx, [ebp-20]
        push    ecx
        push    eax     
        mov     ecx, InServiceRoutine[edi]       
        fstCall PerfInfoLogInterrupt
        jmp     kid40 

;
; ISR took a long time to complete, abort to debugger
;

if DBG
kid200: push    InServiceRoutine[edi]   ; timed out
        push    offset FLAT:_MsgISRTimeout
        call    _DbgPrint
        add     esp,8
        int     3
        jmp     kid31                   ; continue
endif

CHECK_INT_STORM_TAIL kid, 0

stdENDP _KiInterruptDispatch

        page ,132
        subttl  "Interrupt Template"
;++
;
; Routine Description:
;
;    This routine is a template that is copied into each interrupt object. Its
;    function is to save machine state and pass the address of the respective
;    interrupt object and transfer control to the appropriate interrupt
;    dispatcher.
;
;    Control comes here through i386 interrupt gate and, upon entry, the
;    interrupt is disabled.
;
;    Note: If the length of this template changed, the corresponding constant
;          defined in Ki.h needs to be updated accordingly.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    edi - addr of interrupt object
;    esp - top of trap frame
;    interrupts are disabled
;
;--

_KiShutUpAssembler      proc

        public  _KiInterruptTemplate
_KiInterruptTemplate    label   byte

; Save machine state on trap frame

        ENTER_INTERRUPT kit_a,  kit_t

;
; the following instruction gets the addr of associated interrupt object.
; the value ? will be replaced by REAL interrupt object address at
; interrupt object initialization time.
;       mov     edi, addr of interrupt object
; 
; Template modifications made to support BBT, include replacing bogus
; insructions (created by db and dd) with real instructions.   
; This stuff gets overwritten anyway.  BBT just needs to see real instructions.

        public  _KiInterruptTemplate2ndDispatch
_KiInterruptTemplate2ndDispatch equ     this dword
        mov      edi,0  

        public  _KiInterruptTemplateObject
_KiInterruptTemplateObject      equ     this dword


; the following instruction transfers control to the appropriate dispatcher
; code.  The value ? will be replaced by real InterruptObj.DispatchAddr
; at interrupt initialization time.  The dispatcher routine will be any one
; of _KiInterruptDispatch, _KiFloatingDispatch, or _KiChainDispatch.
;       jmp     [IntObj.DispatchAddr]

        jmp _KeSynchronizeExecution

        public  _KiInterruptTemplateDispatch
_KiInterruptTemplateDispatch    equ     this dword

        ENTER_DR_ASSIST kit_a,  kit_t

; end of _KiInterruptTemplate

if  ($ - _KiInterruptTemplate) GT DISPATCH_LENGTH
    .err
    %out    <InterruptTemplate greater than dispatch_length>
endif

_KiShutUpAssembler      endp

        page ,132
        subttl  "Unexpected Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt being generated
;    via a vector that is not connected to an interrupt object.
;
;    For any unconnected vector, its associated 8259 irq is masked out at
;    Initialization time.  So, this routine should NEVER be called.
;    If somehow, this routine gets control we simple raise a BugCheck and
;    stop the system.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    None.
;
;--
        public _KiUnexpectedInterrupt
_KiUnexpectedInterrupt  proc
cPublicFpo 0,0

; stop the system
        stdCall   _KeBugCheck, <TRAP_CAUSE_UNKNOWN>
        nop

_KiUnexpectedInterrupt endp

_TEXT$00   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\kernlini.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kernlini.c

Abstract:

    This module contains the code to initialize the kernel data structures
    and to initialize the idle thread, its process, and the processor control
    block.

    For the i386, it also contains code to initialize the PCR.

Author:

    David N. Cutler (davec) 21-Apr-1989

Environment:

    Kernel mode only.

Revision History:

    24-Jan-1990  shielin

                 Changed for NT386

    20-Mar-1990     bryanwi

                Added KiInitializePcr

--*/

#include "ki.h"
#include "fastsys.inc"

#define TRAP332_GATE 0xEF00

VOID
KiSetProcessorType(
    VOID
    );

VOID
KiSetCR0Bits(
    VOID
    );

BOOLEAN
KiIsNpxPresent(
    VOID
    );

VOID
KiI386PentiumLockErrataFixup (
    VOID
    );

VOID
KiInitializeDblFaultTSS(
    IN PKTSS Tss,
    IN ULONG Stack,
    IN PKGDTENTRY TssDescriptor
    );

VOID
KiInitializeTSS2 (
    IN PKTSS Tss,
    IN PKGDTENTRY TssDescriptor
    );

VOID
KiSwapIDT (
    VOID
    );

VOID
KeSetup80387OrEmulate (
    IN PVOID *R3EmulatorTable
    );

VOID
KiGetCacheInformation(
    VOID
    );

ULONG
KiGetCpuVendor(
    VOID
    );

ULONG
KiGetFeatureBits (
    VOID
    );

NTSTATUS
KiMoveRegTree(
    HANDLE  Source,
    HANDLE  Dest
    );

VOID
Ki386EnableDE (
    IN volatile PLONG Number
    );

VOID
Ki386EnableFxsr (
    IN volatile PLONG Number
    );


VOID
Ki386EnableXMMIExceptions (
    IN volatile PLONG Number
    );


VOID
Ki386EnableGlobalPage (
    IN volatile PLONG Number
    );

VOID
Ki386UseSynchronousTbFlush (
    IN volatile PLONG Number
    );

BOOLEAN
KiInitMachineDependent (
    VOID
    );

VOID
KiInitializeMTRR (
    IN BOOLEAN LastProcessor
    );

VOID
KiInitializePAT (
    VOID
    );

VOID
KiAmdK6InitializeMTRR(
    VOID
    );

VOID
KiRestoreFastSyscallReturnState(
    VOID
    );

VOID
KiLogMcaErrors (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,KiInitializeKernel)
#pragma alloc_text(INIT,KiInitializePcr)
#pragma alloc_text(INIT,KiInitializeDblFaultTSS)
#pragma alloc_text(INIT,KiInitializeTSS2)
#pragma alloc_text(INIT,KiSwapIDT)
#pragma alloc_text(INIT,KeSetup80387OrEmulate)
#pragma alloc_text(INIT,KiGetFeatureBits)
#pragma alloc_text(INIT,KiGetCacheInformation)
#pragma alloc_text(INIT,KiGetCpuVendor)
#pragma alloc_text(INIT,KiMoveRegTree)
#pragma alloc_text(INIT,KiInitMachineDependent)
#pragma alloc_text(INIT,KiI386PentiumLockErrataFixup)
#pragma alloc_text(INIT,KiLogMcaErrors)
#endif

BOOLEAN KiI386PentiumLockErrataPresent = FALSE;
BOOLEAN KiIgnoreUnexpectedTrap07 = FALSE;

ULONG KiFastSystemCallDisable;

extern PVOID Ki387RoundModeTable;
extern PVOID Ki386IopmSaveArea;
extern ULONG KeI386ForceNpxEmulation;
extern WCHAR CmDisabledFloatingPointProcessor[];
extern UCHAR CmpCyrixID[];
extern UCHAR CmpIntelID[];
extern UCHAR CmpAmdID[];
extern UCHAR CmpTransmetaID[];
extern UCHAR CmpCentaurID[];
extern BOOLEAN KiFastSystemCallIsIA32;

#ifndef NT_UP
extern PVOID ScPatchFxb;
extern PVOID ScPatchFxe;
#endif

typedef enum {
    CPU_NONE,
    CPU_INTEL,
    CPU_AMD,
    CPU_CYRIX,
    CPU_TRANSMETA,
    CPU_CENTAUR,
    CPU_UNKNOWN
} CPU_VENDORS;


//
// If this processor does XMMI, take advantage of it.  Default is
// no XMMI.
//

BOOLEAN KeI386XMMIPresent;

//
// x86 statically provides the idle process and idle thread for
// processor 0.
//

EPROCESS    KiIdleProcess;
ETHREAD     KiIdleThread0;

//
// Define prototypes and static initialization for the fast zero
// page routines.
//

VOID
FASTCALL
KiZeroPage (
    PVOID PageBase
    );

VOID
FASTCALL
KiXMMIZeroPage (
    PVOID PageBase
    );

VOID
FASTCALL
KiXMMIZeroPageNoSave (
    PVOID PageBase
    );

KE_ZERO_PAGE_ROUTINE KeZeroPage = KiZeroPage;
KE_ZERO_PAGE_ROUTINE KeZeroPageFromIdleThread = KiZeroPage;

//
// Line size of the d-cache closest to the processor.   Used by machine
// dependent prefetch routines.  Default to 32.
//

ULONG KePrefetchNTAGranularity = 32;

VOID
FASTCALL
RtlPrefetchMemoryNonTemporal(
    PVOID   Memory,
    SIZE_T  Length
    );


//
// The following spinlock is for compatiblity with 486 systems that don't
// have a cmpxchg8b instruction and therefore need to synchronize using a
// spinlock.  NOTE: This spinlock should be initialized on x86 systems.
//

ULONG Ki486CompatibilityLock;

//
// Profile vars
//

extern  KIDTENTRY IDT[];

VOID
KiInitializeKernel (
    IN PKPROCESS Process,
    IN PKTHREAD Thread,
    IN PVOID IdleStack,
    IN PKPRCB Prcb,
    IN CCHAR Number,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function gains control after the system has been bootstrapped and
    before the system has been initialized. Its function is to initialize
    the kernel data structures, initialize the idle thread and process objects,
    initialize the processor control block, call the executive initialization
    routine, and then return to the system startup routine. This routine is
    also called to initialize the processor specific structures when a new
    processor is brought on line.

Arguments:

    Process - Supplies a pointer to a control object of type process for
        the specified processor.

    Thread - Supplies a pointer to a dispatcher object of type thread for
        the specified processor.

    IdleStack - Supplies a pointer the base of the real kernel stack for
        idle thread on the specified processor.

    Prcb - Supplies a pointer to a processor control block for the specified
        processor.

    Number - Supplies the number of the processor that is being
        initialized.

    LoaderBlock - Supplies a pointer to the loader parameter block.

Return Value:

    None.

--*/

{
    LONG  Index;
    ULONG DirectoryTableBase[2];
    KIRQL OldIrql;
    PKPCR Pcr;
    BOOLEAN NpxFlag;
    BOOLEAN FxsrPresent;
    BOOLEAN XMMIPresent;
    ULONG FeatureBits;

    KiSetProcessorType();
    KiSetCR0Bits();
    NpxFlag = KiIsNpxPresent();

    Pcr = KeGetPcr();

    //
    // Initialize DPC listhead and lock.
    //

    InitializeListHead(&Prcb->DpcListHead);
    KeInitializeSpinLock(&Prcb->DpcLock);
    Prcb->DpcRoutineActive = 0;
    Prcb->DpcQueueDepth = 0;
    Prcb->MaximumDpcQueueDepth = KiMaximumDpcQueueDepth;
    Prcb->MinimumDpcRate = KiMinimumDpcRate;
    Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;

    //
    // Initialize processor's PowerState
    //

    PoInitializePrcb (Prcb);

    //
    // Check for unsupported processor revision
    //

    if (Prcb->CpuType == 3) {
        KeBugCheckEx(UNSUPPORTED_PROCESSOR,0x386,0,0,0);
    }

    //
    // Get the processor FeatureBits for this processor.
    //

    FeatureBits = KiGetFeatureBits();
    Prcb->FeatureBits = FeatureBits;

    //
    // Do one time initialization of the ProcesorControlSpace in the PRCB
    // so local kernel debugger can get things like the GDT
    //

    KiSaveProcessorControlState(&Prcb->ProcessorState);

    //
    // Get processor Cache Size information.
    //

    KiGetCacheInformation();

    //
    // initialize the per processor lock queue entry for implemented locks.
    //

    KiInitQueuedSpinLocks(Prcb, Number);

    //
    // If the initial processor is being initialized, then initialize the
    // per system data structures.
    //

    if (Number == 0) {

        //
        // Set default node.  Used in non-multinode systems and in
        // multinode systems until the node topology is available.
        //

        KeNodeBlock[0] = &KiNode0;

#if defined(KE_MULTINODE)

        for (Index = 1; Index < MAXIMUM_CCNUMA_NODES; Index++) {

            //
            // Set temporary node.
            //

            KeNodeBlock[Index] = &KiNodeInit[Index];
        }

#endif

        Prcb->ParentNode = KeNodeBlock[0];
        KeNodeBlock[0]->ProcessorMask = Prcb->SetMember;

        //
        // Initial setting for global Cpu & Stepping levels
        //

        KeI386NpxPresent = NpxFlag;
        KeI386CpuType = Prcb->CpuType;
        KeI386CpuStep = Prcb->CpuStep;

        KeProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
        KeProcessorLevel = (USHORT)Prcb->CpuType;
        if (Prcb->CpuID == 0) {
            KeProcessorRevision = 0xFF00 |
                                  (((Prcb->CpuStep >> 4) + 0xa0 ) & 0x0F0) |
                                  (Prcb->CpuStep & 0xf);
        } else {
            KeProcessorRevision = Prcb->CpuStep;
        }

        KeFeatureBits = FeatureBits;

        KeI386FxsrPresent = ((KeFeatureBits & KF_FXSR) ? TRUE:FALSE);

        KeI386XMMIPresent = ((KeFeatureBits & KF_XMMI) ? TRUE:FALSE);

        //
        // As of Whistler, cmpxchg8b is a required instruction.
        //

        if ((KeFeatureBits & KF_CMPXCHG8B) == 0) {

            ULONG Vendor[3];

            //
            // Argument 1:
            //   bits 31-24: Unique value for missing feature.
            //   bits 23-0 : Family/Model/Stepping (this could compress).
            // Arguments 2 thru 4:
            //   Vendor Id string.
            //

            RtlCopyMemory(Vendor, Prcb->VendorString, sizeof(Vendor));
            KeBugCheckEx(UNSUPPORTED_PROCESSOR,
                         (1 << 24 )     // rev this for other required features
                          | (Prcb->CpuType << 16) | Prcb->CpuStep,
                         Vendor[0],
                         Vendor[1],
                         Vendor[2]
                         );
        }

        //
        // Lower IRQL to APC level.
        //

        KeLowerIrql(APC_LEVEL);


        //
        // Initialize kernel internal spinlocks
        //

        KeInitializeSpinLock(&KiFreezeExecutionLock);

        //
        // Initialize 486 compatibility lock
        //

        KeInitializeSpinLock(&Ki486CompatibilityLock);

#if !defined(NT_UP)

        //
        // Set this processor as the master (ie first found) processor
        // in this SMT set (whether or not it is actually SMT).
        //

        Prcb->MultiThreadSetMaster = Prcb;

        //
        // During Text Mode setup, it is possible the system is
        // running with an MP kernel and a UP HAL.  On X86 systems,
        // spinlocks are implemented in both the kernel and the HAL
        // with the verisons that alter IRQL in the HAL.   If the
        // HAL is UP, it will not actually acquire/release locks
        // while the MP kernel will which will cause the system to
        // hang (or crash).   As this can only occur during text
        // mode setup, we will detect the situation and disable
        // the kernel only versions of queued spinlocks if the HAL
        // is UP (and the kernel MP).
        //
        // We need to patch 3 routines, two of them are void and
        // the other returns a boolean (must be true (and ZF must be
        // clear) in a UP case).
        //
        // Determine if the HAL us UP by acquiring the dispatcher
        // lock and examining it to see if the HAL actually did
        // anything to it.
        //

        OldIrql = KfAcquireSpinLock(&Ki486CompatibilityLock);
        if (Ki486CompatibilityLock == 0) {

            //
            // KfAcquireSpinLock is in the HAL and it did not
            // change the value of the lock.  This is a UP HAL.
            //

            extern UCHAR KeTryToAcquireQueuedSpinLockAtRaisedIrqlUP;
            PUCHAR PatchTarget, PatchSource;
            UCHAR Byte;

            #define RET 0xc3

            *(PUCHAR)(KeAcquireQueuedSpinLockAtDpcLevel) = RET;
            *(PUCHAR)(KeReleaseQueuedSpinLockFromDpcLevel) = RET;

            //
            // Copy the UP version of KeTryToAcquireQueuedSpinLockAtRaisedIrql
            // over the top of the MP versin.
            //

            PatchSource = &(KeTryToAcquireQueuedSpinLockAtRaisedIrqlUP);
            PatchTarget = (PUCHAR)(KeTryToAcquireQueuedSpinLockAtRaisedIrql);

            do {
                Byte = *PatchSource++;
                *PatchTarget++ = Byte;
            } while (Byte != RET);

            #undef RET
        }
        KeReleaseSpinLock(&Ki486CompatibilityLock, OldIrql);

#endif

        //
        // Performance architecture independent initialization.
        //

        KiInitSystem();

        //
        // Initialize idle thread process object and then set:
        //
        //      1. all the quantum values to the maximum possible.
        //      2. the process in the balance set.
        //      3. the active processor mask to the specified process.
        //

        DirectoryTableBase[0] = 0;
        DirectoryTableBase[1] = 0;
        KeInitializeProcess(Process,
                            (KPRIORITY)0,
                            (KAFFINITY)(0xffffffff),
                            &DirectoryTableBase[0],
                            FALSE);

        Process->ThreadQuantum = MAXCHAR;

#if !defined(NT_UP)

    } else {

        //
        // Adjust global cpu setting to represent lowest of all processors
        //

        FxsrPresent = ((FeatureBits & KF_FXSR) ? TRUE:FALSE);
        if (FxsrPresent != KeI386FxsrPresent) {
            //
            // FXSR support must be available on all processors or on none
            //
            KeBugCheckEx (MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, KF_FXSR, 0, 0, 0);
        }

        XMMIPresent = ((FeatureBits & KF_XMMI) ? TRUE:FALSE);
        if (XMMIPresent != KeI386XMMIPresent) {
            //
            // XMMI support must be available on all processors or on none
            //
            KeBugCheckEx (MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, KF_XMMI, 0, 0, 0);
        }

        if (NpxFlag != KeI386NpxPresent) {
            //
            // NPX support must be available on all processors or on none
            //

            KeBugCheckEx (MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, 0x387, 0, 0, 0);
        }

        if ((ULONG)(Prcb->CpuType) != KeI386CpuType) {

            if ((ULONG)(Prcb->CpuType) < KeI386CpuType) {

                //
                // What is the lowest CPU type
                //

                KeI386CpuType = (ULONG)Prcb->CpuType;
                KeProcessorLevel = (USHORT)Prcb->CpuType;
            }
        }

        if ((KiBootFeatureBits & KF_CMPXCHG8B)  &&  !(FeatureBits & KF_CMPXCHG8B)) {
            //
            // cmpxchg8b must be available on all processors, if installed at boot
            //

            KeBugCheckEx (MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, KF_CMPXCHG8B, 0, 0, 0);
        }

        if ((KeFeatureBits & KF_GLOBAL_PAGE)  &&  !(FeatureBits & KF_GLOBAL_PAGE)) {
            //
            // Global page support must be available on all processors, if on boot processor
            //

            KeBugCheckEx (MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, KF_GLOBAL_PAGE, 0, 0, 0);
        }

        if ((KeFeatureBits & KF_PAT)  &&  !(FeatureBits & KF_PAT)) {
            //
            // PAT must be available on all processors, if on boot processor
            //

            KeBugCheckEx (MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, KF_PAT, 0, 0, 0);
        }

        if ((KeFeatureBits & KF_MTRR)  &&  !(FeatureBits & KF_MTRR)) {
            //
            // MTRR must be available on all processors, if on boot processor
            //

            KeBugCheckEx (MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED, KF_MTRR, 0, 0, 0);
        }

        if ((KeFeatureBits & KF_FAST_SYSCALL) != (FeatureBits & KF_FAST_SYSCALL)) {
            //
            // If this feature is not available on all processors
            // don't use it at all.
            //

            KiFastSystemCallDisable = 1;
        }

        if ((KeFeatureBits & KF_XMMI64) != (FeatureBits & KF_XMMI64)) {

            //
            // If not all processors support Streaming SIMD Extensions
            // 64bit FP don't use it at all.
            //

            KeFeatureBits &= ~KF_XMMI64;
        }

        //
        // Use lowest stepping value
        //

        if (Prcb->CpuStep < KeI386CpuStep) {
            KeI386CpuStep = Prcb->CpuStep;
            if (Prcb->CpuID == 0) {
                KeProcessorRevision = 0xFF00 |
                                      ((Prcb->CpuStep >> 8) + 'A') |
                                      (Prcb->CpuStep & 0xf);
            } else {
                KeProcessorRevision = Prcb->CpuStep;
            }
        }

        //
        // Use subset of all NT feature bits available on each processor
        //

        KeFeatureBits &= FeatureBits;

        //
        // Lower IRQL to DISPATCH level.
        //

        KeLowerIrql(DISPATCH_LEVEL);

#endif

    }

    //
    // Update processor features
    //

    SharedUserData->ProcessorFeatures[PF_MMX_INSTRUCTIONS_AVAILABLE] =
        (KeFeatureBits & KF_MMX) ? TRUE : FALSE;

    SharedUserData->ProcessorFeatures[PF_COMPARE_EXCHANGE_DOUBLE] =
        (KeFeatureBits & KF_CMPXCHG8B) ? TRUE : FALSE;

    SharedUserData->ProcessorFeatures[PF_XMMI_INSTRUCTIONS_AVAILABLE] =
        ((KeFeatureBits & KF_FXSR) && (KeFeatureBits & KF_XMMI)) ? TRUE : FALSE;

    SharedUserData->ProcessorFeatures[PF_XMMI64_INSTRUCTIONS_AVAILABLE] =
        ((KeFeatureBits & KF_FXSR) && (KeFeatureBits & KF_XMMI64)) ? TRUE : FALSE;

    SharedUserData->ProcessorFeatures[PF_3DNOW_INSTRUCTIONS_AVAILABLE] =
        (KeFeatureBits & KF_3DNOW) ? TRUE : FALSE;

    SharedUserData->ProcessorFeatures[PF_RDTSC_INSTRUCTION_AVAILABLE] =
        (KeFeatureBits & KF_RDTSC) ? TRUE : FALSE;

    //
    // Initialize idle thread object and then set:
    //
    //      1. the initial kernel stack to the specified idle stack.
    //      2. the next processor number to the specified processor.
    //      3. the thread priority to the highest possible value.
    //      4. the state of the thread to running.
    //      5. the thread affinity to the specified processor.
    //      6. the specified processor member in the process active processors
    //          set.
    //

    KeInitializeThread(Thread, (PVOID)((ULONG)IdleStack),
                       (PKSYSTEM_ROUTINE)NULL, (PKSTART_ROUTINE)NULL,
                       (PVOID)NULL, (PCONTEXT)NULL, (PVOID)NULL, Process);
    Thread->NextProcessor = Number;
    Thread->Priority = HIGH_PRIORITY;
    Thread->State = Running;
    Thread->Affinity = (KAFFINITY)(1<<Number);
    Thread->WaitIrql = DISPATCH_LEVEL;
    SetMember(Number, Process->ActiveProcessors);

    //
    // Initialize the processor block. (Note that some fields have been
    // initialized at KiInitializePcr().
    //

    Prcb->CurrentThread = Thread;
    Prcb->NextThread = (PKTHREAD)NULL;
    Prcb->IdleThread = Thread;
    Pcr->NtTib.StackBase = Thread->InitialStack;

    //
    // call the executive initialization routine.
    //

    try {
        ExpInitializeExecutive(Number, LoaderBlock);

    } except(KeBugCheckEx(PHASE0_EXCEPTION,
                          (ULONG)GetExceptionCode(),
                          (ULONG_PTR)GetExceptionInformation(),
                          0,0), EXCEPTION_EXECUTE_HANDLER) {
        ; // should never get here
    }

    //
    // If the initial processor is being initialized, then compute the
    // timer table reciprocal value and reset the PRCB values for the
    // controllable DPC behavior in order to reflect any registry
    // overrides.
    //

    if (Number == 0) {
        KiTimeIncrementReciprocal = KiComputeReciprocal((LONG)KeMaximumIncrement,
                                                        &KiTimeIncrementShiftCount);

        Prcb->MaximumDpcQueueDepth = KiMaximumDpcQueueDepth;
        Prcb->MinimumDpcRate = KiMinimumDpcRate;
        Prcb->AdjustDpcThreshold = KiAdjustDpcThreshold;
    }

    if (Number == 0) {

        //
        // Processor 0's DPC stack was temporarily allocated on
        // the Double Fault Stack, switch to a proper kernel
        // stack now.
        //

        PVOID DpcStack;

        DpcStack = MmCreateKernelStack(FALSE, 0);

        if (DpcStack == NULL) {
            KeBugCheckEx(NO_PAGES_AVAILABLE, 1, 0, 0, 0);
        }
        Prcb->DpcStack = DpcStack;

        //
        // Allocate 8k IOPM bit map saved area to allow BiosCall swap
        // bit maps.
        //

        Ki386IopmSaveArea = ExAllocatePoolWithTag(PagedPool,
                                                  PAGE_SIZE * 2,
                                                  '  eK');
        if (Ki386IopmSaveArea == NULL) {
            KeBugCheckEx(NO_PAGES_AVAILABLE, 2, PAGE_SIZE * 2, 0, 0);
        }
    }

    //
    // Set the priority of the specified idle thread to zero, set appropriate
    // member in KiIdleSummary and return to the system start up routine.
    //

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    KeSetPriorityThread(Thread, (KPRIORITY)0);

    //
    // if a thread has not been selected to run on the current processors,
    // check to see if there are any ready threads; otherwise add this
    // processors to the IdleSummary
    //

    KeAcquireQueuedSpinLockAtDpcLevel(KeQueuedSpinLockContext(LockQueueDispatcherLock));
    if (Prcb->NextThread == (PKTHREAD)NULL) {
        SetMember(Number, KiIdleSummary);
    }

    KeReleaseQueuedSpinLockFromDpcLevel(KeQueuedSpinLockContext(LockQueueDispatcherLock));

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // This processor has initialized
    //

    LoaderBlock->Prcb = (ULONG)NULL;

    return;
}

VOID
KiInitializePcr (
    IN ULONG Processor,
    IN PKPCR    Pcr,
    IN PKIDTENTRY Idt,
    IN PKGDTENTRY Gdt,
    IN PKTSS Tss,
    IN PKTHREAD Thread,
    IN PVOID DpcStack
    )

/*++

Routine Description:

    This function is called to initialize the PCR for a processor.  It
    simply stuffs values into the PCR.  (The PCR is not inited statically
    because the number varies with the number of processors.)

    Note that each processor has its own IDT, GDT, and TSS as well as PCR!

Arguments:

    Processor - Processor whose PCR to initialize.

    Pcr - Linear address of PCR.

    Idt - Linear address of i386 IDT.

    Gdt - Linear address of i386 GDT.

    Tss - Linear address (NOT SELECTOR!) of the i386 TSS.

    Thread - Dummy thread object to use very early on.

Return Value:

    None.

--*/
{
    // set version values

    Pcr->MajorVersion = PCR_MAJOR_VERSION;
    Pcr->MinorVersion = PCR_MINOR_VERSION;

    Pcr->PrcbData.MajorVersion = PRCB_MAJOR_VERSION;
    Pcr->PrcbData.MinorVersion = PRCB_MINOR_VERSION;

    Pcr->PrcbData.BuildType = 0;

#if DBG
    Pcr->PrcbData.BuildType |= PRCB_BUILD_DEBUG;
#endif

#ifdef NT_UP
    Pcr->PrcbData.BuildType |= PRCB_BUILD_UNIPROCESSOR;
#endif

#if defined (_X86PAE_)
    if (Processor == 0) {
        //
        //  PAE feature must be initialized prior to the first HAL call.
        //

        SharedUserData->ProcessorFeatures[PF_PAE_ENABLED] = TRUE;
    }
#endif

    //  Basic addressing fields

    Pcr->SelfPcr = Pcr;
    Pcr->Prcb = &(Pcr->PrcbData);

    //  Thread control fields

    Pcr->NtTib.ExceptionList = EXCEPTION_CHAIN_END;
    Pcr->NtTib.StackBase = 0;
    Pcr->NtTib.StackLimit = 0;
    Pcr->NtTib.Self = 0;

    Pcr->PrcbData.CurrentThread = Thread;

    //
    // Init Prcb.Number and ProcessorBlock such that Ipi will work
    // as early as possible.
    //

    Pcr->PrcbData.Number = (UCHAR)Processor;
    Pcr->PrcbData.SetMember = 1 << Processor;
    KiProcessorBlock[Processor] = Pcr->Prcb;

    Pcr->Irql = 0;

    //  Machine structure addresses

    Pcr->GDT = Gdt;
    Pcr->IDT = Idt;
    Pcr->TSS = Tss;
    Pcr->PrcbData.DpcStack = DpcStack;

    //
    // Initially, set this processor as only member of SMT set.
    //

    Pcr->PrcbData.MultiThreadProcessorSet = Pcr->PrcbData.SetMember;

    return;
}

#if 0
VOID
KiInitializeDblFaultTSS(
    IN PKTSS Tss,
    IN ULONG Stack,
    IN PKGDTENTRY TssDescriptor
    )

/*++

Routine Description:

    This function is called to initialize the double-fault TSS for a
    processor.  It will set the static fields of the TSS to point to
    the double-fault handler and the appropriate double-fault stack.

    Note that the IOPM for the double-fault TSS grants access to all
    ports.  This is so the standard HAL's V86-mode callback to reset
    the display to text mode will work.

Arguments:

    Tss - Supplies a pointer to the double-fault TSS

    Stack - Supplies a pointer to the double-fault stack.

    TssDescriptor - Linear address of the descriptor for the TSS.

Return Value:

    None.

--*/

{
    PUCHAR  p;
    ULONG   i;
    ULONG   j;

    //
    // Set limit for TSS
    //

    if (TssDescriptor != NULL) {
        TssDescriptor->LimitLow = sizeof(KTSS) - 1;
        TssDescriptor->HighWord.Bits.LimitHi = 0;
    }

    //
    // Initialize IOPMs
    //

    for (i = 0; i < IOPM_COUNT; i++) {
            p = (PUCHAR)(Tss->IoMaps[i]);

        for (j = 0; j < PIOPM_SIZE; j++) {
            p[j] = 0;
        }
    }

    //  Set IO Map base address to indicate no IO map present.

    // N.B. -1 does not seem to be a valid value for the map base.  If this
    //      value is used, byte immediate in's and out's will actually go
    //      the hardware when executed in V86 mode.

    Tss->IoMapBase = KiComputeIopmOffset(IO_ACCESS_MAP_NONE);

    //  Set flags to 0, which in particular disables traps on task switches.

    Tss->Flags = 0;


    //  Set LDT and Ss0 to constants used by NT.

    Tss->LDT  = 0;
    Tss->Ss0  = KGDT_R0_DATA;
    Tss->Esp0 = Stack;
    Tss->Eip  = (ULONG)KiTrap08;
    Tss->Cs   = KGDT_R0_CODE || RPL_MASK;
    Tss->Ds   = KGDT_R0_DATA;
    Tss->Es   = KGDT_R0_DATA;
    Tss->Fs   = KGDT_R0_DATA;


    return;

}
#endif


VOID
KiInitializeTSS (
    IN PKTSS Tss
    )

/*++

Routine Description:

    This function is called to initialize the TSS for a processor.
    It will set the static fields of the TSS.  (ie Those fields that
    the part reads, and for which NT uses constant values.)

    The dynamic fields (Esp0 and CR3) are set in the context swap
    code.

Arguments:

    Tss - Linear address of the Task State Segment.

Return Value:

    None.

--*/
{

    //  Set IO Map base address to indicate no IO map present.

    // N.B. -1 does not seem to be a valid value for the map base.  If this
    //      value is used, byte immediate in's and out's will actually go
    //      the hardware when executed in V86 mode.

    Tss->IoMapBase = KiComputeIopmOffset(IO_ACCESS_MAP_NONE);

    //  Set flags to 0, which in particular disables traps on task switches.

    Tss->Flags = 0;


    //  Set LDT and Ss0 to constants used by NT.

    Tss->LDT = 0;
    Tss->Ss0 = KGDT_R0_DATA;

    return;
}

VOID
KiInitializeTSS2 (
    IN PKTSS Tss,
    IN PKGDTENTRY TssDescriptor
    )

/*++

Routine Description:

    Do part of TSS init we do only once.

Arguments:

    Tss - Linear address of the Task State Segment.

    TssDescriptor - Linear address of the descriptor for the TSS.

Return Value:

    None.

--*/
{
    PUCHAR  p;
    ULONG   i;
    ULONG   j;

    //
    // Set limit for TSS
    //

    if (TssDescriptor != NULL) {
        TssDescriptor->LimitLow = sizeof(KTSS) - 1;
        TssDescriptor->HighWord.Bits.LimitHi = 0;
    }

    //
    // Initialize IOPMs
    //

    for (i = 0; i < IOPM_COUNT; i++) {
        p = (PUCHAR)(Tss->IoMaps[i].IoMap);

        for (j = 0; j < PIOPM_SIZE; j++) {
            p[j] = (UCHAR)-1;
        }
    }

    //
    // Initialize Software Interrupt Direction Maps
    //

    for (i = 0; i < IOPM_COUNT; i++) {
        p = (PUCHAR)(Tss->IoMaps[i].DirectionMap);
        for (j = 0; j < INT_DIRECTION_MAP_SIZE; j++) {
            p[j] = 0;
        }
        // dpmi requires special case for int 2, 1b, 1c, 23, 24
        p[0] = 4;
        p[3] = 0x18;
        p[4] = 0x18;
    }

    //
    // Initialize the map for IO_ACCESS_MAP_NONE
    //
    p = (PUCHAR)(Tss->IntDirectionMap);
    for (j = 0; j < INT_DIRECTION_MAP_SIZE; j++) {
        p[j] = 0;
    }

    // dpmi requires special case for int 2, 1b, 1c, 23, 24
    p[0] = 4;
    p[3] = 0x18;
    p[4] = 0x18;

    return;
}

VOID
KiSwapIDT (
    )

/*++

Routine Description:

    This function is called to edit the IDT.  It swaps words of the address
    and access fields around into the format the part actually needs.
    This allows for easy static init of the IDT.

    Note that this procedure edits the current IDT.

Arguments:

    None.

Return Value:

    None.

--*/
{
    LONG    Index;
    USHORT Temp;

    //
    // Rearrange the entries of IDT to match i386 interrupt gate structure
    //

    for (Index = 0; Index <= MAXIMUM_IDTVECTOR; Index += 1) {
        Temp = IDT[Index].Selector;
        IDT[Index].Selector = IDT[Index].ExtendedOffset;
        IDT[Index].ExtendedOffset = Temp;
    }
}

ULONG
KiGetCpuVendor(
    VOID
    )

/*++

Routine Description:

    (Try to) Determine the manufacturer of this processor based on
    data returned by the CPUID instruction (if present).

Arguments:

    None.

Return Value:

    One of the members of the enumeration CPU_VENDORS (defined above).

--*/
{
    PKPRCB Prcb;
    ULONG  Junk;
    ULONG  Buffer[4];

    Prcb = KeGetCurrentPrcb();
    Prcb->VendorString[0] = 0;

    if (!Prcb->CpuID) {
        return CPU_NONE;
    }

    CPUID(0, &Junk, Buffer+0, Buffer+2, Buffer+1);
    Buffer[3] = 0;

    //
    // Copy vendor string to Prcb for debugging (ensure it's NULL
    // terminated).
    //

    RtlCopyMemory(
        Prcb->VendorString,
        Buffer,
        sizeof(Prcb->VendorString) - 1
        );

    Prcb->VendorString[sizeof(Prcb->VendorString) - 1] = '\0';

    if (strcmp((PVOID)Buffer, CmpIntelID) == 0) {
        return CPU_INTEL;
    } else if (strcmp((PVOID)Buffer, CmpAmdID) == 0) {
        return CPU_AMD;
    } else if (strcmp((PVOID)Buffer, CmpCyrixID) == 0) {
        return CPU_CYRIX;
    } else if (strcmp((PVOID)Buffer, CmpTransmetaID) == 0) {
        return CPU_TRANSMETA;
    } else if (strcmp((PVOID)Buffer, CmpCentaurID) == 0) {
        return CPU_CENTAUR;
    }
    return CPU_UNKNOWN;
}

ULONG
KiGetFeatureBits (
    VOID
    )

/*++

Routine Description:

    Examine the processor specific feature bits to determine the
    Windows 2000 supported features supported by this processor.

Arguments:

    None.

Return Value:

    Returns a Windows 2000 normalized set of processor features.

--*/

{
    ULONG           Junk;
    ULONG           Temp;
    ULONG           ProcessorFeatures;
    ULONG           NtBits;
    ULONG           ExtendedProcessorFeatures;
    ULONG           ProcessorSignature;
    ULONG           CpuVendor;
    PKPRCB          Prcb;
    BOOLEAN         ExtendedCPUIDSupport = TRUE;

    Prcb = KeGetCurrentPrcb();

    NtBits = KF_WORKING_PTE;

    //
    // Determine the processor type
    //

    CpuVendor = KiGetCpuVendor();

    //
    // If this processor does not support the CPUID instruction,
    // don't try to use it.
    //

    if (CpuVendor == CPU_NONE) {
        return NtBits;
    }

    //
    // Determine which NT compatible features are present
    //

    CPUID (1, &ProcessorSignature, &Temp, &Junk, &ProcessorFeatures);

    //
    // CPUID(1) now returns information in EBX.  On the grounds that
    // the low functions are supposed to be standard, we record the
    // information regardless of processor vendor even though it may
    // be 0 or undefined on older implementations.
    //

    Prcb->InitialApicId = (UCHAR)(Temp >> 24);

    //
    // AMD specific stuff
    //

    if (CpuVendor == CPU_AMD) {

        //
        // Check for K5 and above.
        //

        if ((ProcessorSignature & 0x0F00) >= 0x0500) {

            if ((ProcessorSignature & 0x0F00) == 0x0500) {

                switch (ProcessorSignature & 0x00F0) {

                case 0x0010: // K5 Model 1

                    //
                    // for K5 Model 1 stepping 0 or 1 don't set global page
                    //

                    if ((ProcessorSignature & 0x000F) > 0x03) {

                        //
                        // K5 Model 1 stepping 2 or greater
                        //

                        break;
                    }

                    //
                    // K5 Model 1 stepping 0 or 1, FALL THRU.
                    //

                case 0x0000:        // K5 Model 0

                    //
                    // for K5 Model 0 or model unknown don't set global page
                    //

                    ProcessorFeatures &= ~0x2000;
                    break;

                case 0x0080:        // K6 Model 8 (K6-2)

                    //
                    // All steppings >= 8 support MTRRs.
                    //

                    if ((ProcessorSignature & 0x000F) >= 0x8) {
                        NtBits |= KF_AMDK6MTRR;
                    }
                    break;

                case 0x0090:        // K6 Model 9 (K6-3)

                    NtBits |= KF_AMDK6MTRR;
                    break;

                default:            // anything else, nothing to do.

                    break;
                }
            }

        } else {

            //
            // Less than family 5, don't set GLOBAL PAGE, LARGE
            // PAGE or CMOV.  (greater than family 5 will have the
            // bits set correctly).
            //

            ProcessorFeatures &= ~(0x08 | 0x2000 | 0x8000);

            //
            // We don't know what this processor returns if we
            // probe for extended CPUID support.
            //

            ExtendedCPUIDSupport = FALSE;
        }
    }

    //
    // Intel specific stuff
    //

    if (CpuVendor == CPU_INTEL) {
        if (Prcb->CpuType >= 6) {
            WRMSR (0x8B, 0);
            CPUID (1, &Junk, &Junk, &Junk, &ProcessorFeatures);
            Prcb->UpdateSignature.QuadPart = RDMSR (0x8B);
        }

        else if (Prcb->CpuType == 5) {
            KiI386PentiumLockErrataPresent = TRUE;
        }

        if ( ((ProcessorSignature & 0x0FF0) == 0x0610 &&
              (ProcessorSignature & 0x000F) <= 0x9) ||

             ((ProcessorSignature & 0x0FF0) == 0x0630 &&
              (ProcessorSignature & 0x000F) <= 0x4)) {

            NtBits &= ~KF_WORKING_PTE;
        }

        //
        // Don't support prior attempts at implementing syscall/sysexit
        // instructions.
        //

        if ((Prcb->CpuType < 6) ||
            ((Prcb->CpuType == 6) && (Prcb->CpuStep < 0x0303))) {

            ProcessorFeatures &= ~KI_FAST_SYSCALL_SUPPORTED;
        }
    }

    //
    // Cyrix specific stuff
    //

    if (CpuVendor == CPU_CYRIX) {

        //
        // Workaround bug 324467 which is caused by INTR being
        // held high too long during an FP instruction and causing
        // random Trap07 with no exception bits.
        //

        extern BOOLEAN KiIgnoreUnexpectedTrap07;

        KiIgnoreUnexpectedTrap07 = TRUE;

        //
        // Workaround CMPXCHG bug to Cyrix processors where
        // Family = 6, Model = 0, Stepping <= 1.  Note that
        // Prcb->CpuStep contains both model and stepping.
        //
        // Disable Locking in one of processor specific registers
        // (accessible via i/o space index/data pair).
        //

        if ((Prcb->CpuType == 6) &&
            (Prcb->CpuStep <= 1)) {

            #define CRC_NDX (PUCHAR)0x22
            #define CRC_DAT (CRC_NDX + 1)
            #define CCR1    0xc1

            UCHAR ValueCCR1;

            //
            // Get current setting.
            //

            WRITE_PORT_UCHAR(CRC_NDX, CCR1);

            ValueCCR1 = READ_PORT_UCHAR(CRC_DAT);

            //
            // Set the NO_LOCK bit and write it back.
            //

            ValueCCR1 |= 0x10;

            WRITE_PORT_UCHAR(CRC_NDX, CCR1);
            WRITE_PORT_UCHAR(CRC_DAT, ValueCCR1);

            #undef CCR1
            #undef CRC_DAT
            #undef CRC_NDX
        }
    }

    //
    // Check the standard CPUID feature bits.
    //
    // The following bits are known to work on Intel, AMD and Cyrix.
    // We hope (and assume) the clone makers will follow suit.
    //

    if (ProcessorFeatures & 0x00000002) {
        NtBits |= KF_V86_VIS | KF_CR4;
    }

    if (ProcessorFeatures & 0x00000008) {
        NtBits |= KF_LARGE_PAGE | KF_CR4;
    }

    if (ProcessorFeatures & 0x00000010) {
        NtBits |= KF_RDTSC;
    }

    //
    // N.B. CMPXCHG8B MUST be done in a generic manner or clone processors
    // will not be able to boot if they set this feature bit.
    //
    // This was incorrect in NT4 and resulted processor vendors claiming
    // not to support cmpxchg8b even if they did.   Whistler requires
    // cmpxchg8b, work around this problems for the cases we know about.
    //
    // Because cmpxchg8b is a requirement for whistler, winnt32 needs to
    // be modified if new processors are added to the following list.
    // Also, setupldr.   Both executables were modified so as to warn
    // the user rather than installing an unbootable system.
    //

    if ((ProcessorFeatures & 0x00000100) == 0) {

        ULONGLONG MsrValue;

        if ((CpuVendor == CPU_TRANSMETA) &&
            (Prcb->CpuType >= 5)         &&
            (Prcb->CpuStep >= 0x402)) {

            //
            // Transmeta processors have a cpuid feature bit 'mask' in
            // msr 80860004.   Unmask the cmpxchg8b bit.
            //

            MsrValue = RDMSR(0x80860004);
            MsrValue |= 0x100;
            WRMSR(0x80860004, MsrValue);

            ProcessorFeatures |= 0x100;

        } else if ((CpuVendor == CPU_CENTAUR) &&
                   (Prcb->CpuType >= 5)) {

            //
            // Centaur/IDT processors turn on the cmpxchg8b
            // feature bit by setting bit 1 in MSR 107.
            //

            ULONG CentaurFeatureControlMSR = 0x107;

            if (Prcb->CpuType >= 6) {

                //
                // Centaur processors (Cyrix III) turn on the cmpxchg8b
                // feature bit by setting bit 1 in MSR 1107.
                //
            
                CentaurFeatureControlMSR = 0x1107;
            }

            MsrValue = RDMSR(CentaurFeatureControlMSR);
            MsrValue |= 2;
            WRMSR(CentaurFeatureControlMSR, MsrValue);

            ProcessorFeatures |= 0x100;
        }
    }

    if (ProcessorFeatures & 0x00000100) {
        NtBits |= KF_CMPXCHG8B;
    }

    if (ProcessorFeatures & KI_FAST_SYSCALL_SUPPORTED) {
        NtBits |= KF_FAST_SYSCALL;
        KiFastSystemCallIsIA32 = TRUE;
    }

    if (ProcessorFeatures & 0x00001000) {
        NtBits |= KF_MTRR;
    }

    if (ProcessorFeatures & 0x00002000) {
        NtBits |= KF_GLOBAL_PAGE | KF_CR4;
    }

    if (ProcessorFeatures & 0x00008000) {
        NtBits |= KF_CMOV;
    }

    if (ProcessorFeatures & 0x00010000) {
        NtBits |= KF_PAT;
    }

    if (ProcessorFeatures & 0x00200000) {
        NtBits |= KF_DTS;
    }

    if (ProcessorFeatures & 0x00800000) {
        NtBits |= KF_MMX;
    }

    if (ProcessorFeatures & 0x01000000) {
        NtBits |= KF_FXSR;
    }

    if (ProcessorFeatures & 0x02000000) {
        NtBits |= KF_XMMI;
    }

    if (ProcessorFeatures & 0x04000000) {
        NtBits |= KF_XMMI64;
    }

    if (ProcessorFeatures & 0x10000000) {
        NtBits |= KF_SMT;
        Prcb->LogicalProcessorsPerPhysicalProcessor = (UCHAR)(Temp >> 16);
    } else {
        Prcb->LogicalProcessorsPerPhysicalProcessor = 1;
    }

    //
    // Check extended functions.   First, check for existance,
    // then check extended function 0x80000001 (Extended Processor
    // Features) if present.
    //
    // Note: Intel guarantees that no processor that doesn't support
    // extended CPUID functions will ever return a value with the
    // most significant bit set.   Microsoft asks all CPU vendors
    // to make the same guarantee.
    //

    if (ExtendedCPUIDSupport != FALSE) {

        CPUID(0x80000000, &Temp, &Junk, &Junk, &Junk);

        //
        // Sanity check the result, assuming there are no more
        // than 256 extended feature functions (should be valid
        // for a little while).
        //

        if ((Temp & 0xffffff00) == 0x80000000) {

            //
            // Check extended processor features.  These, by definition,
            // can vary on a processor by processor basis.
            //

            if (Temp >= 0x80000001) {

                CPUID(0x80000001, &Temp, &Junk, &Junk, &ExtendedProcessorFeatures);

                //
                // With these, we can only do what we're told.
                //

                switch (CpuVendor) {
                case CPU_AMD:

                    if (ExtendedProcessorFeatures & 0x80000000) {
                        NtBits |= KF_3DNOW;
                    }

#if 0

                    //
                    // There is a security hole with this implementation
                    // of fast system call such that it is possible to
                    // end up in the trap01 handler running on the user
                    // stack (ie not kernel stack).   Unfortunately this
                    // prohibits use of this instruction pair.
                    //

                    if (ExtendedProcessorFeatures & 0x00000800) {

                        //
                        // This processor supports AMD's implementation
                        // of SYSENTER/SYSEXIT (SYSCALL/SYSRET).  Use this
                        // unless it also supports the IA32 version.
                        //

                        if ((NtBits & KF_FAST_SYSCALL) == 0) {
                            NtBits |= KF_FAST_SYSCALL;
                        }
                    }

#endif

#if 0

                    if (ExtendedProcessorFeatures & 0x00100000) {
                        Temp = (ULONG)RDMSR(0xc0000080);
                        Temp |= 0x800;
                        WRMSR(0xc0000080, (ULONGLONG)Temp);
                        KeErrorMask = 0x9;
                        MmPaeErrMask = 0x8;
                        MmPaeMask = 0x8000000000000000UI64;
                    }
#endif

                    break;
                }
            }
        }
    }

    return NtBits;
}

VOID
KiGetCacheInformation(
    VOID
    )
{
#define CPUID_REG_COUNT 4
    ULONG CpuidData[CPUID_REG_COUNT];
    ULONG Line = 64;
    ULONG Size = 0;
    ULONG AdjustedSize = 0;
    UCHAR Assoc = 0;
    ULONG CpuVendor;
    PKPCR Pcr;

    //
    // Set default.
    //

    Pcr = KeGetPcr();

    Pcr->SecondLevelCacheSize = 0;

    //
    // Determine the processor manufacturer
    //

    CpuVendor = KiGetCpuVendor();

    if (CpuVendor == CPU_NONE) {
        return;
    }

    //
    // Obtain Cache size information for those processors on which
    // we know how.
    //

    switch (CpuVendor) {
    case CPU_INTEL:

        CPUID(0, CpuidData, CpuidData+1, CpuidData+2, CpuidData+3);

        //
        // Check this processor supports CPUID function 2 which is the
        // one that returns cache size info.
        //

        if (CpuidData[0] >= 2) {

            //
            // The above returns a series of bytes.    (In EAX, EBX, ECX
            // and EDX).   The least significant byte (of EAX) gives the
            // number of times CPUID(2 ...) should be issued to return
            // the complete set of data.   The bytes are self describing
            // data.
            //
            // In particular, the bytes describing the L2 cache size
            // will be in the following set (and meaning)
            //
            // 0x40       0  bytes
            // 0x41     128K bytes
            // 0x42     256K bytes
            // 0x43     512K bytes
            // 0x44    1024K bytes
            // 0x45    2048K bytes
            // 0x46    4096K bytes
            //
            // I am extrapolating the above as anything in the range
            // 0x41 thru 0x4f can be computed as
            //
            //   128KB << (descriptor - 0x41)
            //
            // The Intel folks say keep it to a reasonable upper bound,
            // eg 49.
            //
            // N.B. the range 0x80 .. 0x86 indicates the same cache
            // sizes but 8 way associative.
            //
            // Also, the most significant bit of each register indicates
            // whether not the register contains valid information.
            // 0 == Valid, 1 == InValid.
            //

            ULONG CpuidIterations;
            ULONG i;
            ULONG CpuidReg;

            BOOLEAN FirstPass = TRUE;

            do {
                CPUID(2, CpuidData, CpuidData+1, CpuidData+2, CpuidData+3);

                if (FirstPass) {

                    //
                    // Get the iteration count from the first byte
                    // of the returned data then replace that byte
                    // with 0 (a null descriptor).
                    //

                    CpuidIterations = CpuidData[0] & 0xff;
                    CpuidData[0] &= 0xffffff00;

                    FirstPass = FALSE;
                }

                for (i = 0; i < CPUID_REG_COUNT; i++) {

                    CpuidReg = CpuidData[i];

                    if (CpuidReg & 0x80000000) {

                        //
                        // Register doesn't contain valid data,
                        // skip it.
                        //

                        continue;
                    }

                    while (CpuidReg) {

                        //
                        // Get LS Byte from this DWORD and remove the
                        // byte.
                        //

                        UCHAR Descriptor = (UCHAR)(CpuidReg & 0xff);
                        CpuidReg >>= 8;

                        if (Descriptor == 0) {

                            //
                            // NULL descriptor
                            //

                            continue;
                        }

                        if (((Descriptor > 0x40) && (Descriptor <= 0x47)) ||
                            ((Descriptor > 0x78) && (Descriptor <= 0x7c)) ||
                            ((Descriptor > 0x80) && (Descriptor <= 0x87))) {

                            //
                            // L2 descriptor.
                            //
                            // To date, for all the descriptors we know
                            // about those above 0x78 are 8 way and those
                            // below are 4 way.
                            //

                            Assoc = Descriptor >= 0x79 ? 8 : 4;

                            if (((Descriptor & 0xf8) == 0x78) &&
                                (Line < 128)) {
                                Line = 128;
                            }
                            Descriptor &= 0x07;

                            //
                            // Assert the descriptor is in the range we
                            // officially know about.   If this hits on
                            // a checked build, check with Intel about
                            // the interpretation.
                            //

                            ASSERT(Descriptor <= 0x6);

                            Size = 0x10000 << Descriptor;
                            if ((Size / Assoc) > AdjustedSize) {
                                AdjustedSize = Size / Assoc;
                                Pcr->SecondLevelCacheSize = Size;
                                Pcr->SecondLevelCacheAssociativity = Assoc;
                            }

                        } else if ((Descriptor > 0x21) && (Descriptor <= 0x29)) {
                            if (Line < 128) {
                                Line = 128;
                            }
                            Assoc = 8;
                            switch (Descriptor) {
                            case 0x22:
                                Size = 512 * 1024;
                                Assoc = 4;
                                break;
                            case 0x23:
                                Size = 1024 * 1024;
                                break;
                            case 0x25:
                                Size = 2048 * 1024;
                                break;
                            case 0x29:
                                Size = 4096 * 1024;
                                break;
                            default:
                                Size = 0;
                                break;
                            }
                            if ((Size / Assoc) > AdjustedSize) {
                                AdjustedSize = Size / Assoc;
                                Pcr->SecondLevelCacheSize = Size;
                                Pcr->SecondLevelCacheAssociativity = Assoc;
                            }
                        } else if ((Descriptor > 0x65) && (Descriptor < 0x69)) {

                            //
                            // L1 Descriptor with line size of 64 bytes.
                            // N.B. These are the only ones we know about,
                            // we will get it wrong on future processors
                            // unless a less brain dead way of determining
                            // line size is provided.
                            //

                            KePrefetchNTAGranularity = 64;
                        }

                        //
                        // else if (do other descriptors)
                        //

                    } // while more bytes in this register

                } // for each register

                //
                // Note: Always run thru all iterations indicated by
                // the first to ensure a subsequent call won't start
                // part way thru.
                //

            } while (--CpuidIterations);
        }
        break;
    case CPU_AMD:

        //
        // Get L1 Cache Data.
        //

        CPUID(0x80000000, CpuidData, CpuidData+1, CpuidData+2, CpuidData+3);
        if (CpuidData[0] < 0x80000005) {

            //
            // This processor doesn't support L1 cache details.
            //

            break;
        }
        CPUID(0x80000005, CpuidData, CpuidData+1, CpuidData+2, CpuidData+3);
        KePrefetchNTAGranularity = CpuidData[2] & 0xff;

        //
        // Get L2 data.
        //

        CPUID(0x80000000, CpuidData, CpuidData+1, CpuidData+2, CpuidData+3);
        if (CpuidData[0] < 0x80000006) {

            //
            // This processor doesn't support L2 cache details.
            //

            break;
        }
        CPUID(0x80000006, CpuidData, CpuidData+1, CpuidData+2, CpuidData+3);
        Line = CpuidData[2] & 0xff;
        switch ((CpuidData[2] >> 12) & 0xf) {
        case 0x2:   Assoc = 2;  break;
        case 0x4:   Assoc = 4;  break;
        case 0x6:   Assoc = 8;  break;
        case 0x8:   Assoc = 16; break;

        //
        // ff is really fully associative, just represent as 16 way.
        //
        case 0xff:  Assoc = 16; break;
        default:    Assoc = 1;  break;
        }
        Size = (CpuidData[2] >> 16) << 10;
        if ((Pcr->PrcbData.CpuType == 0x6) &&
            (Pcr->PrcbData.CpuStep == 0x300)) {

            //
            // Model 6,3,0 uses a different algorithm to report cache
            // size.
            //

            Size = 64 * 1024;
        }

        Pcr->SecondLevelCacheAssociativity = Assoc;
        Pcr->SecondLevelCacheSize = Size;
        break;
    }

    if (Line > KeLargestCacheLine) {
        KeLargestCacheLine = Line;
    }

#undef CPUID_REG_COUNT
}

#define MAX_ATTEMPTS    10

BOOLEAN
KiInitMachineDependent (
    VOID
    )
{
    KAFFINITY       ActiveProcessors, CurrentAffinity;
    ULONG           NumberProcessors;
    IDENTITY_MAP    IdentityMap;
    ULONG           Index;
    ULONG           Average;
    ULONG           Junk;
    struct {
        LARGE_INTEGER   PerfStart;
        LARGE_INTEGER   PerfEnd;
        LONGLONG        PerfDelta;
        LARGE_INTEGER   PerfFreq;
        LONGLONG        TSCStart;
        LONGLONG        TSCEnd;
        LONGLONG        TSCDelta;
        ULONG           MHz;
    } Samples[MAX_ATTEMPTS], *pSamp;
    PUCHAR          PatchLocation;

    //
    // If PDE large page is supported, enable it.
    //
    // We enable large pages before global pages to make TLB invalidation
    // easier while turning on large pages.
    //

    if (KeFeatureBits & KF_LARGE_PAGE) {
        if (Ki386CreateIdentityMap(&IdentityMap,
                                   &Ki386EnableCurrentLargePage,
                                   &Ki386EnableCurrentLargePageEnd )) {

            KiIpiGenericCall (
                (PKIPI_BROADCAST_WORKER) Ki386EnableTargetLargePage,
                (ULONG)(&IdentityMap)
            );
        }

        //
        // Always call Ki386ClearIdentityMap() to free any memory allocated
        //

        Ki386ClearIdentityMap(&IdentityMap);
    }

    //
    // If PDE/PTE global page is supported, enable it
    //

    if (KeFeatureBits & KF_GLOBAL_PAGE) {
        NumberProcessors = KeNumberProcessors;
        KiIpiGenericCall (
            (PKIPI_BROADCAST_WORKER) Ki386EnableGlobalPage,
            (ULONG)(&NumberProcessors)
        );
    }

#if !defined(NT_UP)

    //
    // If some processor doesn't have proper MP PTE implementation,
    // then use a synchronous TB shoot down handler
    //

    if (!(KeFeatureBits & KF_WORKING_PTE)) {
        NumberProcessors = KeNumberProcessors;
        KiIpiGenericCall (
            (PKIPI_BROADCAST_WORKER) Ki386UseSynchronousTbFlush,
            (ULONG)(&NumberProcessors)
        );
    }

#endif

    //
    // If PAT or MTRR supported but the HAL indicates it shouldn't
    // be used (eg on a Shared Memory Cluster), drop the feature.
    //

    if (KeFeatureBits & (KF_PAT | KF_MTRR)) {

        NTSTATUS Status;
        BOOLEAN  UseFrameBufferCaching;
        ULONG    Size;

        Status = HalQuerySystemInformation(
                     HalFrameBufferCachingInformation,
                     sizeof(UseFrameBufferCaching),
                     &UseFrameBufferCaching,
                     &Size
                     );

        if (NT_SUCCESS(Status) &&
            (UseFrameBufferCaching == FALSE)) {

            //
            // Hal says don't use.
            //

            KeFeatureBits &= ~(KF_PAT | KF_MTRR);
        }
    }


    //
    // If PAT is supported then initialize it.
    //

    if (KeFeatureBits & KF_PAT) {
        KiInitializePAT();
    }


    //
    // Check to see if the floating point emulator should be used.
    //

    SharedUserData->ProcessorFeatures[PF_FLOATING_POINT_PRECISION_ERRATA] =
            FALSE;

    switch (KeI386ForceNpxEmulation) {
    case 0:

        //
        // Use the emulator based on the value in KeI386NpxPresent
        //

        break;

    case 1:

        //
        // Only use the emulator if any processor has the known
        // Pentium floating point division problem.
        //

        if (KeI386NpxPresent) {

            //
            // A coprocessor is present, check to see if the precision
            // errata exists.
            //

            double  Dividend, Divisor;
            BOOLEAN PrecisionErrata = FALSE;

            ActiveProcessors = KeActiveProcessors;
            for (CurrentAffinity = 1; ActiveProcessors; CurrentAffinity <<= 1) {

                if (ActiveProcessors & CurrentAffinity) {
                    ActiveProcessors &= ~CurrentAffinity;

                    //
                    // Run calculation on each processor.
                    //

                    KeSetSystemAffinityThread(CurrentAffinity);
                    _asm {

                        ;
                        ; This is going to destroy the state in the coprocesssor,
                        ; but we know that there's no state currently in it.
                        ;

                        cli
                        mov     eax, cr0
                        mov     ecx, eax    ; hold original cr0 value
                        and     eax, not (CR0_TS+CR0_MP+CR0_EM)
                        mov     cr0, eax

                        fninit              ; to known state
                    }

                    Dividend = 4195835.0;
                    Divisor  = 3145727.0;

                    _asm {
                        fld     Dividend
                        fdiv    Divisor     ; test known faulty divison
                        fmul    Divisor     ; Multiple quotient by divisor
                        fcomp   Dividend    ; Compare product and dividend
                        fstsw   ax          ; Move float conditions to ax
                        sahf                ; move to eflags

                        mov     cr0, ecx    ; restore cr0
                        sti

                        jc      short em10
                        jz      short em20
em10:                   mov     PrecisionErrata, TRUE
em20:
                    }
                    if (PrecisionErrata) {
                        KeI386NpxPresent = FALSE;
                        SharedUserData->ProcessorFeatures[PF_FLOATING_POINT_PRECISION_ERRATA] = TRUE;
                        break;
                    }
                }
            }

        }
        break;

    default:

        //
        // Unknown setting - use the emulator
        //

        KeI386NpxPresent = FALSE;
        break;
    }

    //
    // Setup processor features, and install emulator if needed
    //

    SharedUserData->ProcessorFeatures[PF_FLOATING_POINT_EMULATED] =
            !KeI386NpxPresent;

    if (!KeI386NpxPresent) {

        //
        // MMx, fast save/restore, streaming SIMD not available when
        // emulator is used.  (Nor FP errata).
        //

        KeFeatureBits &= ~(KF_MMX | KF_FXSR | KF_XMMI | KF_XMMI64);
        KeI386XMMIPresent = FALSE;
        KeI386FxsrPresent = FALSE;

        SharedUserData->ProcessorFeatures[PF_MMX_INSTRUCTIONS_AVAILABLE]      =
        SharedUserData->ProcessorFeatures[PF_XMMI_INSTRUCTIONS_AVAILABLE]     =
        SharedUserData->ProcessorFeatures[PF_3DNOW_INSTRUCTIONS_AVAILABLE]    =
        SharedUserData->ProcessorFeatures[PF_XMMI64_INSTRUCTIONS_AVAILABLE]   =
        SharedUserData->ProcessorFeatures[PF_FLOATING_POINT_PRECISION_ERRATA] =
            FALSE;
    }

    //
    // If CR4 exists, enable DE extensions for IO breakpoints
    //

    if (KeFeatureBits & KF_CR4) {
        NumberProcessors = KeNumberProcessors;

        KiIpiGenericCall (
            (PKIPI_BROADCAST_WORKER) Ki386EnableDE,
            (ULONG)(&NumberProcessors)
        );
    }

    //
    // If FXSR feature is supported, set OSFXSR (bit 9) in CR4
    //

    if (KeFeatureBits & KF_FXSR) {
        NumberProcessors = KeNumberProcessors;

        KiIpiGenericCall (
            (PKIPI_BROADCAST_WORKER) Ki386EnableFxsr,
            (ULONG)(&NumberProcessors)
        );


        //
        // If XMMI feature is supported,
        //    a. Hook int 19 handler
        //    b. Set OSXMMEXCPT (bit 10) in CR4
        //    c. Enable use of fast XMMI based zero page routines.
        //    d. Remove return instruction at start of prefetch routine.
        //

        if (KeFeatureBits & KF_XMMI) {
            KiIpiGenericCall (
                (PKIPI_BROADCAST_WORKER) Ki386EnableXMMIExceptions,
                (ULONG)(&NumberProcessors)
            );

            KeZeroPage = KiXMMIZeroPage;
            KeZeroPageFromIdleThread = KiXMMIZeroPageNoSave;

            *(PUCHAR)&RtlPrefetchMemoryNonTemporal = 0x90;
        }


    } else {
#ifndef NT_UP
        //
        // Patch the fxsave instruction in SwapContext to use
        // "fnsave {dd, 31}, fwait {9b}"
        //
        ASSERT( ((ULONG)&ScPatchFxe-(ULONG)&ScPatchFxb) >= 3);

        PatchLocation = (PUCHAR)&ScPatchFxb;

        *PatchLocation++ = 0xdd;
        *PatchLocation++ = 0x31;
        *PatchLocation++ = 0x9b;

        while (PatchLocation < (PUCHAR)&ScPatchFxe) {
            //
            // Put nop's in the remaining bytes
            //
            *PatchLocation++ = 0x90;
        }
#endif
    }

    //
    // If the system (ie all processors) supports fast system
    // call/return, initialize the machine specific registers
    // required to support it.
    //

    KiRestoreFastSyscallReturnState();

    ActiveProcessors = KeActiveProcessors;
    for (CurrentAffinity=1; ActiveProcessors; CurrentAffinity <<= 1) {

        if (ActiveProcessors & CurrentAffinity) {

            //
            // Switch to that processor, and remove it from the
            // remaining set of processors
            //

            ActiveProcessors &= ~CurrentAffinity;
            KeSetSystemAffinityThread(CurrentAffinity);

            //
            // Determine the MHz for the processor
            //

            KeGetCurrentPrcb()->MHz = 0;

            if (KeFeatureBits & KF_RDTSC) {

                Index = 0;
                pSamp = Samples;

                for (; ;) {

                    //
                    // Collect a new sample
                    // Delay the thread a "long" amount and time it with
                    // a time source and RDTSC.
                    //

                    CPUID (0, &Junk, &Junk, &Junk, &Junk);
                    pSamp->PerfStart = KeQueryPerformanceCounter (NULL);
                    pSamp->TSCStart = RDTSC();
                    pSamp->PerfFreq.QuadPart = -50000;

                    KeDelayExecutionThread (KernelMode, FALSE, &pSamp->PerfFreq);

                    CPUID (0, &Junk, &Junk, &Junk, &Junk);
                    pSamp->PerfEnd = KeQueryPerformanceCounter (&pSamp->PerfFreq);
                    pSamp->TSCEnd = RDTSC();

                    //
                    // Calculate processors MHz
                    //

                    pSamp->PerfDelta = pSamp->PerfEnd.QuadPart - pSamp->PerfStart.QuadPart;
                    pSamp->TSCDelta = pSamp->TSCEnd - pSamp->TSCStart;

                    pSamp->MHz = (ULONG) ((pSamp->TSCDelta * pSamp->PerfFreq.QuadPart + 500000L) /
                                          (pSamp->PerfDelta * 1000000L));


                    //
                    // If last 2 samples matched within a MHz, done
                    //

                    if (Index) {
                        if (pSamp->MHz == pSamp[-1].MHz ||
                            pSamp->MHz == pSamp[-1].MHz + 1 ||
                            pSamp->MHz == pSamp[-1].MHz - 1) {
                                break;
                        }
                    }

                    //
                    // Advance to next sample
                    //

                    pSamp += 1;
                    Index += 1;

                    //
                    // If too many samples, then something is wrong
                    //

                    if (Index >= MAX_ATTEMPTS) {

#if DBG
                        //
                        // Temp breakpoint to see where this is failing
                        // and why
                        //

                        DbgBreakPoint();
#endif

                        Average = 0;
                        for (Index = 0; Index < MAX_ATTEMPTS; Index++) {
                            Average += Samples[Index].MHz;
                        }
                        pSamp[-1].MHz = Average / MAX_ATTEMPTS;
                        break;
                    }

                }

                KeGetCurrentPrcb()->MHz = (USHORT) pSamp[-1].MHz;
            }

            //
            // If MTRRs are supported and PAT not supported, initialize MTRRs
            // per processor
            //

            if (KeFeatureBits & KF_MTRR) {
                KiInitializeMTRR ( (BOOLEAN) (ActiveProcessors ? FALSE : TRUE));
            }

            //
            // If the processor is a AMD K6 with MTRR support then
            // perform processor specific initialization.
            //

            if (KeFeatureBits & KF_AMDK6MTRR) {
                KiAmdK6InitializeMTRR();
            }

            //
            // Apply Pentium workaround if needed
            //

            if (KiI386PentiumLockErrataPresent) {
                KiI386PentiumLockErrataFixup ();
            }

            //
            // If this processor supports fast floating save/restore,
            // determine the MXCSR mask value that should be used.
            //

            if (KeFeatureBits & KF_FXSR) {

                //
                // Get base of NPX save area.
                //
                //

                PFX_SAVE_AREA NpxFrame;
                KFLOATING_SAVE Save;
                ULONG MXCsrMask = 0xFFBF;

                NpxFrame = (PFX_SAVE_AREA)
                    (((ULONG)(KeGetCurrentThread()->InitialStack) -
                    sizeof(FX_SAVE_AREA)));

                NpxFrame->U.FxArea.MXCsrMask = 0;
                Kix86FxSave(NpxFrame);

                //
                // If the processor supplied a mask value, use
                // that, otherwise set the default value.
                //

                if (NpxFrame->U.FxArea.MXCsrMask != 0) {
                    MXCsrMask = NpxFrame->U.FxArea.MXCsrMask;
                }

                //
                // All processors must use the same (most restrictive)
                // value.
                //

                if (KiMXCsrMask == 0) {
                    KiMXCsrMask = MXCsrMask;
                } else if (KiMXCsrMask != MXCsrMask) {
                    KeBugCheckEx(MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED,
                                 KF_FXSR,
                                 KiMXCsrMask,
                                 MXCsrMask,
                                 0);
                }

                KiMXCsrMask &= MXCsrMask;
            }
        }
    }

    KeRevertToUserAffinityThread();
    return TRUE;
}


VOID
KeOptimizeProcessorControlState (
    VOID
    )
{
    Ke386ConfigureCyrixProcessor ();
}



VOID
KeSetup80387OrEmulate (
    IN PVOID *R3EmulatorTable
    )

/*++

Routine Description:

    This routine is called by PS initialization after loading NTDLL.

    If this is a 386 system without 387s (all processors must be
    symmetrical) then this function will set the trap 07 vector on all
    processors to point to the address passed in (which should be the
    entry point of the 80387 emulator in NTDLL, NPXNPHandler).

Arguments:

    HandlerAddress - Supplies the address of the trap07 handler.

Return Value:

    None.

--*/

{
    PKINTERRUPT_ROUTINE HandlerAddress;
    KAFFINITY           ActiveProcessors, CurrentAffinity;
    KIRQL               OldIrql;
    ULONG               disposition;
    HANDLE              SystemHandle, SourceHandle, DestHandle;
    NTSTATUS            Status;
    UNICODE_STRING      unicodeString;
    OBJECT_ATTRIBUTES   ObjectAttributes;

    if (!KeI386NpxPresent) {

        //
        // Use the user mode floating point emulator
        //

        HandlerAddress = (PKINTERRUPT_ROUTINE) ((PULONG) R3EmulatorTable)[0];
        Ki387RoundModeTable = (PVOID) ((PULONG) R3EmulatorTable)[1];

        ActiveProcessors = KeActiveProcessors;
        for (CurrentAffinity = 1; ActiveProcessors; CurrentAffinity <<= 1) {

            if (ActiveProcessors & CurrentAffinity) {
                ActiveProcessors &= ~CurrentAffinity;

                //
                // Run this code on each processor.
                //

                KeSetSystemAffinityThread(CurrentAffinity);

                //
                // Raise IRQL and lock dispatcher database.
                //

                KiLockDispatcherDatabase(&OldIrql);

                //
                // Make the trap 07 IDT entry point at the passed-in handler
                //

                KiSetHandlerAddressToIDT(I386_80387_NP_VECTOR, HandlerAddress);
                KeGetPcr()->IDT[I386_80387_NP_VECTOR].Selector = KGDT_R3_CODE;
                KeGetPcr()->IDT[I386_80387_NP_VECTOR].Access = TRAP332_GATE;


                //
                // Unlock dispatcher database and lower IRQL to its previous value.
                //

                KiUnlockDispatcherDatabase(OldIrql);
            }
        }

        //
        // Set affinity back to the original value.
        //

        KeRevertToUserAffinityThread();

        //
        // Move any entries from ..\System\FloatingPointProcessor to
        // ..\System\DisabledFloatingPointProcessor.
        //

        //
        // Open system tree
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &CmRegistryMachineHardwareDescriptionSystemName,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = ZwOpenKey( &SystemHandle,
                            KEY_ALL_ACCESS,
                            &ObjectAttributes
                            );

        if (NT_SUCCESS(Status)) {

            //
            // Open FloatingPointProcessor key
            //

            InitializeObjectAttributes(
                &ObjectAttributes,
                &CmTypeName[FloatingPointProcessor],
                OBJ_CASE_INSENSITIVE,
                SystemHandle,
                NULL
                );

            Status = ZwOpenKey ( &SourceHandle,
                                 KEY_ALL_ACCESS,
                                 &ObjectAttributes
                                 );

            if (NT_SUCCESS(Status)) {

                //
                // Create DisabledFloatingPointProcessor key
                //

                RtlInitUnicodeString (
                    &unicodeString,
                    CmDisabledFloatingPointProcessor
                    );

                InitializeObjectAttributes(
                    &ObjectAttributes,
                    &unicodeString,
                    OBJ_CASE_INSENSITIVE,
                    SystemHandle,
                    NULL
                    );

                Status = ZwCreateKey( &DestHandle,
                                      KEY_ALL_ACCESS,
                                      &ObjectAttributes,
                                      0,
                                      NULL,
                                      REG_OPTION_VOLATILE,
                                      &disposition
                                      );

                if (NT_SUCCESS(Status)) {

                    //
                    // Move it
                    //

                    KiMoveRegTree (SourceHandle, DestHandle);
                    ZwClose (DestHandle);
                }
                ZwClose (SourceHandle);
            }
            ZwClose (SystemHandle);
        }
    }
}



NTSTATUS
KiMoveRegTree(
    HANDLE  Source,
    HANDLE  Dest
    )
{
    NTSTATUS                    Status;
    PKEY_BASIC_INFORMATION      KeyInformation;
    PKEY_VALUE_FULL_INFORMATION KeyValue;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    HANDLE                      SourceChild;
    HANDLE                      DestChild;
    ULONG                       ResultLength;
    UCHAR                       buffer[1024];           // hmm....
    UNICODE_STRING              ValueName;
    UNICODE_STRING              KeyName;


    KeyValue = (PKEY_VALUE_FULL_INFORMATION)buffer;

    //
    // Move values from source node to dest node
    //

    for (; ;) {
        //
        // Get first value
        //

        Status = ZwEnumerateValueKey(Source,
                                     0,
                                     KeyValueFullInformation,
                                     buffer,
                                     sizeof (buffer),
                                     &ResultLength);

        if (!NT_SUCCESS(Status)) {
            break;
        }


        //
        // Write value to dest node
        //

        ValueName.Buffer = KeyValue->Name;
        ValueName.Length = (USHORT) KeyValue->NameLength;
        ZwSetValueKey( Dest,
                       &ValueName,
                       KeyValue->TitleIndex,
                       KeyValue->Type,
                       buffer+KeyValue->DataOffset,
                       KeyValue->DataLength
                      );

        //
        // Delete value and get first value again
        //

        Status = ZwDeleteValueKey (Source, &ValueName);
        if (!NT_SUCCESS(Status)) {
            break;
        }
    }


    //
    // Enumerate node's children and apply ourselves to each one
    //

    KeyInformation = (PKEY_BASIC_INFORMATION)buffer;
    for (; ;) {

        //
        // Open node's first key
        //

        Status = ZwEnumerateKey(
                    Source,
                    0,
                    KeyBasicInformation,
                    KeyInformation,
                    sizeof (buffer),
                    &ResultLength
                    );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        KeyName.Buffer = KeyInformation->Name;
        KeyName.Length = (USHORT) KeyInformation->NameLength;

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            Source,
            NULL
            );

        Status = ZwOpenKey(
                    &SourceChild,
                    KEY_ALL_ACCESS,
                    &ObjectAttributes
                    );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Create key in dest tree
        //

        InitializeObjectAttributes(
            &ObjectAttributes,
            &KeyName,
            OBJ_CASE_INSENSITIVE,
            Dest,
            NULL
            );

        Status = ZwCreateKey(
                    &DestChild,
                    KEY_ALL_ACCESS,
                    &ObjectAttributes,
                    0,
                    NULL,
                    REG_OPTION_VOLATILE,
                    NULL
                    );

        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Move subtree
        //

        Status = KiMoveRegTree(SourceChild, DestChild);

        ZwClose(DestChild);
        ZwClose(SourceChild);

        if (!NT_SUCCESS(Status)) {
            break;
        }

        //
        // Loop and get first key.  (old first key was deleted by the
        // call to KiMoveRegTree).
        //
    }

    //
    // Remove source node
    //

    return NtDeleteKey (Source);
}

VOID
KiI386PentiumLockErrataFixup (
    VOID
    )

/*++

Routine Description:

    This routine is called once on every processor when
    KiI386PentiumLockErrataPresent is TRUE.

    This routine replaces the local IDT with an IDT that has the first 7 IDT
    entries on their own page and returns the first page to the caller to
    be marked as read-only.  This causes the processor to trap-0e fault when
    the errata occurs.  Special code in the trap-0e handler detects the
    problem and performs the proper fixup.

Arguments:

    FixupPage   - Returns a virtual address of a page to be marked read-only

Return Value:

    None.

--*/

{
    KDESCRIPTOR IdtDescriptor;
    ULONG       OrginalBase;
    PUCHAR      NewBase, BasePage;
    BOOLEAN     Enable;
    BOOLEAN     Status;


#define IDT_SKIP   (7 * sizeof (KIDTENTRY))

    //
    // Allocate memory for a new copy of the processor's IDT
    //

    BasePage = MmAllocateIndependentPages (2*PAGE_SIZE, 0);

    //
    // The IDT base is such that the first 7 entries are on the
    // first (read-only) page, and the remaining entries are on the
    // second (read-write) page
    //

    NewBase = BasePage + PAGE_SIZE - IDT_SKIP;

    //
    // Disable interrupts on this processor while updating the IDT base
    //

    Enable = KeDisableInterrupts();

    //
    // Copy Old IDT to new IDT
    //

    _asm {
        sidt IdtDescriptor.Limit
    }

    RtlCopyMemory ((PVOID) NewBase,
                   (PVOID) IdtDescriptor.Base,
                   IdtDescriptor.Limit + 1
                  );

    IdtDescriptor.Base = (ULONG) NewBase;

    //
    // Set the new IDT
    //

    _asm {
        lidt IdtDescriptor.Limit
    }

    //
    // Update the PCR
    //

    KeGetPcr()->IDT = (PKIDTENTRY) NewBase;

    //
    // Restore interrupts
    //

    KeEnableInterrupts(Enable);

    //
    // Mark the first page which contains IDT entries 0-6 as read-only
    //

    Status = MmSetPageProtection (BasePage, PAGE_SIZE, PAGE_READONLY);
    ASSERT (Status);
}

VOID
KiLogMcaErrors (
    VOID
    )

/*++
    Routine Description:
        This routine is called to check for remembered machine checks.
        If a machine check crashed the system, this is the last chance
        to save information about it, at the time the system reboots.

    Arguments:
        none

    Return Value:
        none
--*/

{
    PIO_ERROR_LOG_PACKET ErrLog;
    MCA_EXCEPTION Exception;
    PKPRCB        Prcb;
    PWSTR         PDest;
    PWSTR         PSrc;
    WCHAR         PString[20];
    NTSTATUS      Status;
    ULONG         ToDo;
    ULONG         Length;
    PUCHAR        PData;
    ULONG         RegSet;
    KAFFINITY     ActiveProcessors, CurrentAffinity;
    HAL_MCA_INTERFACE   Mca;
    UCHAR       BankNumber;

    //
    // Current Pentium IIIs don't support the retention of machine
    // check information across a warm reset.  This should've meant
    // that this function wouldn't generate any eventlog entries on
    // those processors.  However, this code was logging non-fatal
    // MCAs created by BIOS initialization resulting in spurious
    // eventlog entries that did not indicate a reliability problem.
    //
    // Now this code is only run on Intel processors that are
    // Pentium 4-derived or later i.e. where the MCA warm reset retention
    // functionality is definitely implemented.
    //

    Prcb = KeGetCurrentPrcb();
    if ((strcmp((PCHAR) Prcb->VendorString, CmpIntelID) == 0) &&
        (KeProcessorLevel < 0xF)) {
        return;
    }

    //
    // Obtain the HAL interface to the Machine Check Architecture
    // register set.
    //

    Status = HalQuerySystemInformation(HalQueryMcaInterface,
                                       sizeof(Mca),
                                       &Mca,
                                       &Length);

    if (Status != STATUS_SUCCESS) {
        return;
    }
    ASSERT(Length == sizeof(Mca));

    //
    // Clear the exception data and indicate to the HAL that we
    // support extended MCA data. (VersionNumber = 2).
    //

    RtlZeroMemory(&Exception, sizeof(Exception));
    Exception.VersionNumber = 2;

    //
    // Obtain exclusive access to the MCA registers.
    //

    Mca.Lock();

    //
    // Check for remembered machine check errors on each processor
    // in the system.
    //

    ActiveProcessors = KeActiveProcessors;

    for (CurrentAffinity = 1; ActiveProcessors; CurrentAffinity <<= 1) {

        if ((CurrentAffinity & ActiveProcessors) == 0) {
            continue;
        }
        ActiveProcessors ^= CurrentAffinity;

        KeSetSystemAffinityThread(CurrentAffinity);

        //
        // Look for a machine check on this processor.
        //

        for (BankNumber = 0; TRUE; BankNumber++) {

            Status = Mca.ReadRegister(BankNumber, &Exception);

            if (Status == STATUS_UNSUCCESSFUL) {

                //
                // No error this bank, examine next.
                //

                continue;
            }

            if (Status != STATUS_SUCCESS) {

                //
                // No such register, done looking on this processor.
                //

                break;
            }

            //
            // Have a machine check, try to report it.
            //

            ErrLog = IoAllocateGenericErrorLogEntry(ERROR_LOG_MAXIMUM_SIZE);
            if (!ErrLog) {

                //
                // Unable to allocate an error log entry?   Give up.
                //

                break;
            }

            //
            // Fill it in and write it out.
            //
            // "Application popup: %1 %2"
            //

            ErrLog->DumpDataSize = (USHORT)MCA_EXCEPTION_V1_SIZE;
            ErrLog->NumberOfStrings = 0;
            ErrLog->StringOffset =
                FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData)
                + MCA_EXCEPTION_V1_SIZE;
            ErrLog->StringOffset =
                (ErrLog->StringOffset + sizeof(PWSTR)-1)
                / sizeof(PWSTR);
            ErrLog->StringOffset *= sizeof(PWSTR);
            ErrLog->ErrorCode = STATUS_LOG_HARD_ERROR;
            ErrLog->UniqueErrorValue = Exception.u.Mca.BankNumber;
            ErrLog->FinalStatus = STATUS_LOG_HARD_ERROR;

            RtlCopyMemory(ErrLog->DumpData, &Exception, MCA_EXCEPTION_V1_SIZE);

            PDest = (PWSTR)((PCHAR)ErrLog+ErrLog->StringOffset);
            PSrc = L"Machine Check:";
            RtlCopyMemory(PDest, PSrc, (wcslen(PSrc)+1) * sizeof(WCHAR));
            PDest += wcslen(PSrc)+1;
            ErrLog->NumberOfStrings++;

            PSrc = L"Banks";
            RtlCopyMemory(PDest, PSrc, (wcslen(PSrc)+1) * sizeof(WCHAR));
            PDest += wcslen(PSrc)+1;
            ErrLog->NumberOfStrings++;

            IoWriteErrorLogEntry(ErrLog);

            //
            // There are Exception.ExtCnt entries in Exception.ExtReg,
            // plus Exception.ExtCnt itself.
            //

            ToDo = (Exception.ExtCnt+1) * sizeof(Exception.ExtReg[0]);
            PData = ((PUCHAR)&Exception)+MCA_EXCEPTION_V1_SIZE;
            RegSet = 0;
            while (ToDo > 0) {

                //
                // Have additional machine check data, try to report it.
                //

                if (ToDo > 8 * sizeof(ULONGLONG)) {
                    Length = 8 * sizeof(ULONGLONG);
                } else {
                    Length = ToDo;
                }
                ErrLog = IoAllocateGenericErrorLogEntry(ERROR_LOG_MAXIMUM_SIZE);
                if (!ErrLog) {
                    break; // Inner loop only
                }

                //
                // Fill it in and write it out.
                //
                // "Application popup: %1 %2"
                //

                ErrLog->DumpDataSize = (USHORT)Length;
                ErrLog->NumberOfStrings = 0;
                ErrLog->StringOffset =
                    FIELD_OFFSET(IO_ERROR_LOG_PACKET, DumpData)
                    + (USHORT)Length;
                ErrLog->StringOffset =
                    (ErrLog->StringOffset + sizeof(PWSTR)-1)
                    / sizeof(PWSTR);
                ErrLog->StringOffset *= sizeof(PWSTR);
                ErrLog->ErrorCode = STATUS_LOG_HARD_ERROR;
                ErrLog->UniqueErrorValue = RegSet;
                ErrLog->FinalStatus = STATUS_LOG_HARD_ERROR;

                RtlCopyMemory(ErrLog->DumpData, PData, Length);

                PDest = (PWSTR)((PCHAR)ErrLog+ErrLog->StringOffset);
                PSrc = L"Machine Check: Regs";
                RtlCopyMemory(PDest, PSrc, (wcslen(PSrc)+1) * sizeof(WCHAR));
                PDest += wcslen(PSrc)+1;
                ErrLog->NumberOfStrings++;

                PSrc = _itow(RegSet, PString, 10);
                RtlCopyMemory(PDest, PSrc, (wcslen(PSrc)+1) * sizeof(WCHAR));
                PDest += wcslen(PSrc)+1;
                ErrLog->NumberOfStrings++;

                IoWriteErrorLogEntry(ErrLog);
                PData += Length;
                ToDo  -= Length;
                RegSet+= 8;
            }

            //
            // Reset for next iteration.
            //

            RtlZeroMemory(&Exception, sizeof(Exception));
            Exception.VersionNumber = 2;
        }
    }
    KeRevertToUserAffinityThread();
    Mca.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\kimacro.inc ===
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       kimacro.inc
;
;   Abstract:
;
;       This module contains the macros used by kernel assembler code.
;       It includes macros to manipulate interrupts, support system
;       entry and exit for syscalls, faults, and interrupts, and
;       manipulate floating point state.
;
;   Author:
;
;       Shie-Lin (shielint) 24-Jan-1990
;
;   Revision History:
;
;       BryanWi 17-Aug-90
;           Replace GENERATE_MACHINE... and RESTORE... with ENTER_...
;           and EXIT_ALL macros.
;
;--

;++
;
;   These constants are used by the fpo directives in this file.
;   This directive causes the assembler to output a .debug$f segment
;   in the obj file.  The segment will contain 1 fpo record for each
;   directive present during assembly.
;
;   Although the assembler will accept all valid values, the value of 7
;   in the FPO_REGS field indicates to the debugger that a trap frame is
;   generated by the function.  The value of 7 can be used because the
;   C/C++ compiler puts a maximum value of 3 in the field.
;
FPO_LOCALS      equ     0         ; 32 bits, size of locals in dwords
FPO_PARAMS      equ     0         ; 32 bits, size of parameters in dwords
FPO_PROLOG      equ     0         ; 12 bits, 0-4095, # of bytes in prolog
FPO_REGS        equ     0         ; 3 bits, 0-7, # regs saved in prolog
FPO_USE_EBP     equ     0         ; 1 bit, 0-1, is ebp used?
FPO_TRAPFRAME   equ     1         ; 2 bits, 0=fpo, 1=trap frame, 2=tss
;
;--


;++
;
;   POLL_DEBUGGER
;
;   Macro Description:
;
;       Call the debugger so it can check for control-c.  If it finds
;       it, it will report our iret address as address of break-in.
;
;       N.B. This macro should be used when all the caller's registers
;            have been restored. (Otherwise, the kernel debugger register
;            dump will not have correct state.)  The only exception is
;            fs.  This is because Kd may need to access PCR or PRCB.
;
;   Arguments:
;
;       There MUST be an iret frame on the stack when this macro
;       is invoked.
;
;   Exit:
;
;       Debugger will iret for us, so we don't usually return from
;       this macro, but remember that it generates nothing for non-DEVL
;       kernels.
;--

POLL_DEBUGGER   macro
local   a, b, c_

if  DEVL
        EXTRNP   _DbgBreakPointWithStatus,1
        stdCall _KdPollBreakIn
        or      al,al
        jz      short c_
        stdCall _DbgBreakPointWithStatus,<DBG_STATUS_CONTROL_C>
c_:
endif   ; DEVL
endm

;++
;
;   ASSERT_FS
;
;   Try to catch funky condition wherein we get FS=r3 value while
;   running in kernel mode.
;
;--

ASSERT_FS   macro
local   a,b

if DBG
        EXTRNP   _KeBugCheck,1

        mov     bx,fs
        cmp     bx,KGDT_R0_PCR
        jnz     short a

        cmp     dword ptr fs:[0], 0
        jne     short b

a:
        stdCall   _KeBugCheck,<-1>
align 4
b:
endif
endm



;++
;
;
;   Copy data from various places into base of TrapFrame, net effect
;   is to allow dbg KB command to trace accross trap frame, and to
;   allow user to find arguments to system calls.
;
;   USE ebx and edi.
;--

SET_DEBUG_DATA  macro

ife FPO

;
; This macro is used by ENTER_SYSTEM_CALL, ENTER_TRAP and ENTER_INTERRUPT
; and is used at the end of above macros.  It is safe to destroy ebx, edi.
;

        mov     ebx,[ebp]+TsEbp
        mov     edi,[ebp]+TsEip
        mov     [ebp]+TsDbgArgPointer,edx
        mov     [ebp]+TsDbgArgMark,0BADB0D00h
        mov     [ebp]+TsDbgEbp,ebx
        mov     [ebp]+TsDbgEip,edi
endif

endm


;++
;
;   ENTER_DR_ASSIST     EnterLabel, ExitLabel, NoAbiosAssist, NoV86Assist
;
;   Macro Description:
;
;       Jumped to by ENTER_ macros to deal with DR register work,
;       abios work and v86 work.  The main purpose of this macro is
;       that interrupt/trap/systemCall EnterMacros can jump here to
;       deal with some special cases such that most of the times the
;       main ENTER_ execution flow can proceed without being branched.
;
;       If (previousmode == usermode) {
;           save DR* in trapframe
;           load DR* from Prcb
;       }
;
;   Arguments:
;       EnterLabel - label to emit
;       ExitLabel - label to branch to when done
;
;   Entry-conditions:
;     Dr work:
;       DebugActive == TRUE
;       (esi)->Thread object
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;
;     Abios work:
;     v86 work:
;
;   Exit-conditions:
;     Dr work:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax, edx
;     Abios work:
;     v86 work:
;
;--

ENTER_DR_ASSIST macro   EnterLabel, ExitLabel, NoAbiosAssist, NoV86Assist, V86R
        local   a,b

        public  Dr_&EnterLabel
align 4
Dr_&EnterLabel:

;
; Test if we came from user-mode.  If not, do nothing.
;

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     short a

        test    dword ptr [ebp]+TsSegCs,MODE_MASK
        jz      Dr_&ExitLabel          ; called from kmode, go continue


;
; Save user-mode Dr* regs in TrapFrame
;
; We are safe to destroy ebx, ecx, edi because in ENTER_INTERRUPT and
; ENTER_TRAP these registers are saved already.  In ENTER_SYSTEMCALL
; ebx, edi is saved and ecx is don't-care.
;

a:      mov     ebx,dr0
        mov     ecx,dr1
        mov     edi,dr2
        mov     [ebp]+TsDr0,ebx
        mov     [ebp]+TsDr1,ecx
        mov     [ebp]+TsDr2,edi
        mov     ebx,dr3
        mov     ecx,dr6
        mov     edi,dr7
        mov     [ebp]+TsDr3,ebx
        mov     [ebp]+TsDr6,ecx
        mov     ebx,0
        mov     [ebp]+TsDr7,edi

;
; Make Dr7 safe before loading junk from save area
;
        mov     dr7,ebx

;
; Load KernelDr* into processor
;

        mov     edi,dword ptr fs:[PcPrcb]
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr0
        mov     ecx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr1
        mov     dr0,ebx
        mov     dr1,ecx
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr2
        mov     ecx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr3
        mov     dr2,ebx
        mov     dr3,ecx
        mov     ebx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr6
        mov     ecx,[edi].PbProcessorState.PsSpecialRegisters.SrKernelDr7
        mov     dr6,ebx
        mov     dr7,ecx

ifnb <V86R>
        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jz      short b
        jmp     Dr_&V86R
endif
b:
        jmp     Dr_&ExitLabel


ifb <NoAbiosAssist>

        public  Abios_&EnterLabel
align 4
Abios_&EnterLabel:

;
;   INTERRUPT_STACK16_TO_STACK32
;
;       This macro remaps current 32bit stack to 16bit stack at interrupt
;       time.
;
;   Arguments:
;
;       (esp)->trap frame.
;       (eax)->Entry Esp.
;

        mov     eax, [esp].TsErrCode    ; (eax) = Entry Esp
        mov     ecx, KGDT_R0_DATA
        mov     edx, esp
        shl     eax, 16
        add     edx, fs:[PcstackLimit]
        mov     [esp].TsErrCode, eax
        mov     ss, cx
        mov     esp, edx                ; Interrupts are off
        mov     ebp, edx
        jmp     Abios_&ExitLabel

endif   ; NoAbiosAssist

ifb <NoV86Assist>

        public  V86_&EnterLabel
align 4
V86_&EnterLabel:

;
;   Move the V86 segment registers to the correct place in the frame
;
        mov     eax,dword ptr [ebp].TsV86Fs
        mov     ebx,dword ptr [ebp].TsV86Gs
        mov     ecx,dword ptr [ebp].TsV86Es
        mov     edx,dword ptr [ebp].TsV86Ds
        mov     [ebp].TsSegFs,ax
        mov     [ebp].TsSegGs,bx
        mov     [ebp].TsSegEs,cx
        mov     [ebp].TsSegDs,dx
        jmp     V86_&ExitLabel

endif   ; NoV86Assist

        endm

;++
;
;   ENTER_SYSCALL       AssistLabel, TagetLabel, NoFSLoad
;
;   Macro Description:
;
;       Build the frame and set registers needed by a system call.
;
;       Save:
;           Errorpad,
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode
;
;       Don't Save:
;           Volatile regs
;           Seg regs
;           Floating point state
;
;       Set:
;           FS,
;           ExceptionList,
;           PreviousMode,
;           Direction
;
;   Arguments:
;       AssistLabel - label ENTER_ASSIST macro is at
;       TargetLabel - label to emit for ENTER_ASSIST to jump to
;       NoFSLoad    - Don't set FS(it is already set to KGDT_R0_PCR at entry).
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax, edx
;
;   Note:
;       The DS: reference to PreviousMode is *required* for correct
;       functioning of lazy selector loads.  If you remove this use
;       of DS:, put a DS: override on something.
;
;--

ENTER_SYSCALL macro     AssistLabel, TargetLabel, NoFSLoad


.FPO ( FPO_LOCALS, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

ifdef KERNELONLY

;
; Construct trap frame.
;
; N.B. The initial part of the trap frame is constructed by pushing values
;      on the stack. If the format of the trap frame is changed, then the
;      following code must alos be changed.
;

        push    0                       ; put pad dword for error on stack
        push    ebp                     ; save the non-volatile registers
        push    ebx                     ;
        push    esi                     ;
        push    edi                     ;
ifb <NoFSLoad>
        push    fs                      ; save and set FS to PCR.
        mov     ebx,KGDT_R0_PCR         ; set PCR segment number
        mov     fs,bx                   ;
else
        ; FS already contains KGDT_R0_PCR(entry via PentiumPro fast system call)
        push    KGDT_R3_TEB OR RPL_MASK
endif  ; NoFSLoad

;
; Save the old exception list in trap frame and initialize a new empty
; exception list.
;

        push    PCR[PcExceptionList]    ; save old exception list
        mov     PCR[PcExceptionList],EXCEPTION_CHAIN_END ; set new empty list

;
; Save the old previous mode in trap frame, allocate remainder of trap frame,
; and set the new previous mode.
;

        mov     esi,PCR[PcPrcbData+PbCurrentThread] ; get current thread address
        push    [esi]+ThPreviousMode    ; save old previous mode
        sub     esp,TsPreviousPreviousMode ; allocate remainder of trap frame
        mov     ebx,[esp+TsSegCS]       ; compute new previous mode
        and     ebx,MODE_MASK           ;
        mov     [esi]+ThPreviousMode,bl ; set new previous mode

;
; Save the old trap frame address and set the new trap frame address.
;

        mov     ebp,esp                 ; set trap frame address
        mov     ebx,[esi].ThTrapFrame   ; save current trap frame address
        mov     [ebp].TsEdx,ebx         ;
        mov     [esi].ThTrapFrame,ebp   ; set new trap frame address
        cld                             ; make sure direction is forward

        SET_DEBUG_DATA                  ; Note this destroys edi

        test    byte ptr [esi]+ThDebugActive,-1 ; test if debugging active
        jnz     Dr_&AssistLabel         ; if nz, debugging is active on thread

Dr_&TargetLabel:                        ;
        sti                             ; enable interrupts

else
        %out    ENTER_SYSCAL outside of kernel
        .err
endif
        endm

;++
;
;   ENTER_INTERRUPT     AssistLabel, TargetLabel
;
;   Macro Description:
;
;       Build the frame and set registers needed by an interrupt.
;
;       Save:
;           Errorpad,
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode
;           Volatile regs
;           Seg regs from V86 mode
;           DS, ES, GS
;
;       Don't Save:
;           Floating point state
;
;       Set:
;           FS,
;           ExceptionList,
;           Direction,
;           DS, ES
;
;       Don't Set:
;           PreviousMode
;
;   Arguments:
;       AssistLabel - label ENTER_ASSIST macro is at
;       TargetLabel - label to emit for ENTER_ASSIST to jump to
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax, ecx, edx
;
;--

ENTER_INTERRUPT macro   AssistLabel, TargetLabel, PassParm
        local b

.FPO ( FPO_LOCALS+2, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

;
;   Fill in parts of frame we care about
;

ifb <PassParm>
        push    esp                 ; Use Error code field to save 16bit esp
endif
        push    ebp                 ; Save the non-volatile registers
        push    ebx
        push    esi
        push    edi

        sub     esp, TsEdi
        mov     ebp,esp

        mov     [esp]+TsEax, eax    ; Save volatile registers
        mov     [esp]+TsEcx, ecx
        mov     [esp]+TsEdx, edx
if DBG
        mov     dword ptr [esp]+TsPreviousPreviousMode, -1 ; ThPreviousMode not pushed on interrupt
endif

        test    dword ptr [esp].TsEflags,EFLAGS_V86_MASK
        jnz     V86_&AssistLabel

        cmp     word ptr [esp]+TsSegCs, KGDT_R0_CODE
        jz      short @f

        mov     [esp]+TsSegFs, fs  ; Save and set FS to PCR.
        mov     [esp]+TsSegDs, ds
        mov     [esp]+TsSegEs, es
        mov     [esp]+TsSegGs, gs

V86_&TargetLabel:
        mov     ebx,KGDT_R0_PCR
        mov     eax,KGDT_R3_DATA OR RPL_MASK
        mov     fs, bx
        mov     ds, ax
        mov     es, ax
@@:
        mov     ebx, fs:[PcExceptionList] ;Save, set ExceptionList
        mov     fs:[PcExceptionList],EXCEPTION_CHAIN_END
        mov     [esp]+TsExceptionList, ebx

ifnb <PassParm>
        lea     eax, [esp].TsErrCode
        lea     ecx, [esp].TsEip    ; Move eax to EIP field
        mov     ebx, ss:[eax]       ; (ebx) = parameter to pass
        mov     ss:[eax], ecx       ; save 16bit esp
endif

;
; Remap ABIOS 16 bit stack to 32 bit stack, if necessary.
;

        cmp     esp, 10000h
        jb      Abios_&AssistLabel

        mov     dword ptr [esp].TsErrCode, 0 ; Indicate no remapping.
Abios_&TargetLabel:

;
; end of Abios stack checking
;

        cld

ifnb <PassParm>
        push    ebx                 ; push parameter as argument
endif


        SET_DEBUG_DATA

        test    byte ptr PCR[PcDebugActive], -1
        jnz     Dr_&AssistLabel

Dr_&TargetLabel:

        endm

;++
;
;   ENTER_INTERRUPT_FORCE_STATE   AssistLabel, TargetLabel
;
;   Macro Description:
;
;       Build the frame and set registers needed by an interrupt.
;
;       This macro is the same as ENTER_INTERRUPT except that it forces the
;       needed state and does not save previous state.
;
;       This macro is currently only used by HalpApicRebootService which does not
;       return;
;
;       Save:
;           Errorpad,
;           Non-volatile regs,
;           ExceptionList,
;           PreviousMode
;           Volatile regs
;           Seg regs from V86 mode
;
;       Don't Save:
;           FS,
;           DS, ES, GS
;           Floating point state
;
;       Set:
;           FS,
;           ExceptionList,
;           Direction,
;           DS, ES
;
;       Don't Set:
;           PreviousMode
;
;   Arguments:
;       AssistLabel - label ENTER_ASSIST macro is at
;       TargetLabel - label to emit for ENTER_ASSIST to jump to
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax, ecx, edx
;
;--

ENTER_INTERRUPT_FORCE_STATE macro   AssistLabel, TargetLabel, PassParm
        local b

.FPO ( FPO_LOCALS+2, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

;
;   Fill in parts of frame we care about
;

ifb <PassParm>
        push    esp                 ; Use Error code field to save 16bit esp
endif
        push    ebp                 ; Save the non-volatile registers
        push    ebx
        push    esi
        push    edi

        sub     esp, TsEdi
        mov     ebp,esp

        mov     [esp]+TsEax, eax    ; Save volatile registers
        mov     [esp]+TsEcx, ecx
        mov     [esp]+TsEdx, edx
if DBG
        mov     dword ptr [esp]+TsPreviousPreviousMode, -1 ; ThPreviousMode not pushed on interrupt
endif

        test    dword ptr [esp].TsEflags,EFLAGS_V86_MASK
        jnz     V86_&AssistLabel

V86_&TargetLabel:
        mov     ebx,KGDT_R0_PCR
        mov     eax,KGDT_R3_DATA OR RPL_MASK
        mov     fs, bx
        mov     ds, ax
        mov     es, ax
@@:
        mov     ebx, fs:[PcExceptionList] ;Save, set ExceptionList
        mov     fs:[PcExceptionList],EXCEPTION_CHAIN_END
        mov     [esp]+TsExceptionList, ebx

ifnb <PassParm>
        lea     eax, [esp].TsErrCode
        lea     ecx, [esp].TsEip    ; Move eax to EIP field
        mov     ebx, ss:[eax]       ; (ebx) = parameter to pass
        mov     ss:[eax], ecx       ; save 16bit esp
endif

;
; Remap ABIOS 16 bit stack to 32 bit stack, if necessary.
;

        cmp     esp, 10000h
        jb      Abios_&AssistLabel

        mov     dword ptr [esp].TsErrCode, 0 ; Indicate no remapping.
Abios_&TargetLabel:

;
; end of Abios stack checking
;

        cld

ifnb <PassParm>
        push    ebx                 ; push parameter as argument
endif


        SET_DEBUG_DATA

        test    byte ptr PCR[PcDebugActive], -1
        jnz     Dr_&AssistLabel

Dr_&TargetLabel:

        endm

;++
;
;   ENTER_TRAP      AssistLabel, TargetLabel
;
;   Macro Description:
;
;       Build the frame and set registers needed by a trap or exception.
;
;       Save:
;           Non-volatile regs,
;           FS,
;           ExceptionList,
;           PreviousMode,
;           Volatile regs
;           Seg Regs from V86 mode
;           DS, ES, GS
;
;       Don't Save:
;           Floating point state
;
;       Set:
;           FS,
;           Direction,
;           DS, ES
;
;       Don't Set:
;           PreviousMode,
;           ExceptionList
;
;   Arguments:
;       AssistLabel - label ENTER_ASSIST macro is at
;       TargetLabel - label to emit for ENTER_ASSIST to jump to
;
;   Exit-conditions:
;       Interrupts match input state (this routine doesn't change IEF)
;       (esp)->base of trap frame
;       (ebp)->base of trap frame
;       Preserves entry eax
;
;--

ENTER_TRAP macro    AssistLabel, TargetLabel
        local b

.FPO ( FPO_LOCALS, FPO_PARAMS, FPO_PROLOG, FPO_REGS, FPO_USE_EBP, FPO_TRAPFRAME )

;
;   Fill in parts of frame we care about
;

if DBG
ifndef  _Ki16BitStackException
    EXTRNP   _Ki16BitStackException
endif
endif ; DBG

        mov     word ptr [esp+2], 0 ; Clear upper word of ErrorCode

        push    ebp                 ; Save the non-volatile registers
        push    ebx
        push    esi
        push    edi

        push    fs                  ; Save and set FS to PCR.
        mov     ebx,KGDT_R0_PCR
        mov     fs,bx
        mov     ebx, fs:[PcExceptionList] ;Save ExceptionList
        push    ebx
if DBG
        push    -1                  ; Don't need to save ThPreviousMode from trap
else
        sub     esp, 4              ; pad dword
endif
        push    eax                 ; Save the volatile registers
        push    ecx
        push    edx

        push    ds                  ; Save segments
        push    es
        push    gs

;
;   Skip allocate reset of trap frame and Set up DS/ES, they may be trash
;

        mov     ax,KGDT_R3_DATA OR RPL_MASK
        sub     esp,TsSegGs
        mov     ds,ax
        mov     es,ax

if DBG
;
; The code here check if the exception occurred in ring 0
; ABIOS code. If yes, this is a fatal condition.  We will
; put out message and bugcheck.
;

        cmp     esp, 10000h             ; Is the trap in abios?
        jb      _Ki16BitStackException       ; if b, yes, switch stack and bugcheck.

endif ; DBG

        mov     ebp,esp
        test    dword ptr [esp].TsEflags,EFLAGS_V86_MASK
        jnz     V86_&AssistLabel

V86_&TargetLabel:

        cld
        SET_DEBUG_DATA

        test    byte ptr PCR[PcDebugActive], -1
        jnz     Dr_&AssistLabel

Dr_&TargetLabel:

        endm
;++
;
;   EXIT_ALL    NoRestoreSegs, NoRestoreVolatiles, NoPreviousMode
;
;   Macro Description:
;
;       Load a syscall frame back into the machine.
;
;       Restore:
;           Volatile regs, IF NoRestoreVolatiles blank
;           NoPreviousMode,
;           ExceptionList,
;           FS,
;           Non-volatile regs
;
;       If the frame is a kernel mode frame, AND esp has been edited,
;       then TsSegCs will have a special value.  Test for that value
;       and execute special code for that case.
;
;       N.B. This macro generates an IRET!  (i.e. It exits!)
;
;   Arguments:
;
;       NoRestoreSegs - non-blank if DS, ES, GS are NOT to be restored
;
;       NoRestoreVolatiles - non-blank if Volatile regs are NOT to be restored
;
;       NoPreviousMode - if nb pop ThPreviousMode
;
;   Entry-conditions:
;
;       (esp)->base of trap frame
;       (ebp)->Base of trap frame
;
;   Exit-conditions:
;
;       Does not exit, returns.
;       Preserves eax, ecx, edx, IFF NoRestoreVolatiles is set
;
;--

?adjesp = 0
?RestoreAll = 1

EXIT_ALL macro  NoRestoreSegs, NoRestoreVolatiles, NoPreviousMode
local   a, b, f, x
local   Dr_ExitHelp, Dr_ExitHelp_Target
local   Db_NotATrapFrame, Db_A, Db_NotValidEntry, NonFlatPm_Target

;
; Sanity check some values and setup globals for macro
;

?adjesp = TsSegGs
?RestoreAll = 1

ifnb <NoRestoreSegs>
    ?RestoreAll = 0
    ?adjesp = ?adjesp + 12
endif

ifnb <NoRestoreVolatiles>
    if ?RestoreAll eq 1
        %out "EXIT_ALL NoRestoreVolatiles requires NoRestoreSegs"
        .err
    endif
    ?adjesp = ?adjesp + 12
endif

ifb <NoPreviousMode>
ifndef KERNELONLY
        %out    EXIT_ALL can not restore previousmode outside kernel
        .err
endif
endif

; All callers are responsible for getting here with interrupts disabled.

if DBG
        pushfd
        pop     edx

        test    edx, EFLAGS_INTERRUPT_MASK
        jnz     Db_NotValidEntry

        cmp     esp, ebp                    ; make sure esp = ebp
        jne     Db_NotValidEntry

; Make sure BADB0D00 sig is present.  If not this isn't a trap frame!
Db_A:   sub     [esp]+TsDbgArgMark,0BADB0D00h
        jne     Db_NotATrapFrame
endif

        ASSERT_FS

        mov     edx, [esp]+TsExceptionList
if DBG
        or      edx, edx
        jnz     short @f
    int 3
@@:
endif
        mov     ebx, fs:[PcDebugActive]     ; (ebx) = DebugActive flag
        mov     fs:[PcExceptionList], edx   ; Restore ExceptionList

ifb <NoPreviousMode>
        mov     ecx, [esp]+TsPreviousPreviousMode ; Restore PreviousMode
if DBG
        cmp     ecx, -1     ; temporary debugging code
        jne     @f          ; to make sure no one tries to pop ThPreviousMode
    int 3                   ; when it wasn't saved
@@:
endif
        mov     esi,fs:[PcPrcbData+PbCurrentThread]
        mov     [esi]+ThPreviousMode,cl
else
if DBG
        mov     ecx, [esp]+TsPreviousPreviousMode
        cmp     ecx, -1     ; temporary debugging code
        je     @f           ; to make sure no one pushed ThPreviousMode and
    int 3                   ; is now exiting without restoreing it
@@:
endif
endif

        test    ebx, 0fh
        jnz     Dr_ExitHelp

Dr_ExitHelp_Target:

        test    dword ptr [esp].TsEflags,EFLAGS_V86_MASK
        jnz     V86ExitHelp

        test    word ptr [esp]+TsSegCs,FRAME_EDITED
        jz      b                           ; Edited frame pop out.


if ?RestoreAll eq 0
.errnz MODE_MASK-1
        cmp     word ptr [esp]+TsSegCs,KGDT_R3_CODE OR RPL_MASK ; set/clear ZF
        bt      word ptr [esp]+TsSegCs,0    ; test MODE_MASK      set/clear CF
        cmc                                 ;       (CF=1 and ZF=0)
        ja      f                           ; jmp if CF=0 and ZF=0
endif
ifb <NoRestoreVolatiles>
        mov     edx, [esp]+TsEdx            ; Restore volitales
        mov     ecx, [esp]+TsEcx
                                            ; must restore eax before any
        mov     eax, [esp].TsEax            ; selectors! (see trap0e handler)
endif

        cmp     word ptr [ebp]+TsSegCs, KGDT_R0_CODE
        jz      short @f

ifb <NoRestoreSegs>
        lea     esp, [ebp]+TsSegGs
        pop     gs                          ; Restore Segs
        pop     es
        pop     ds
endif
NonFlatPm_Target:
        lea     esp, [ebp]+TsSegFs
        pop     fs
@@:
        lea     esp, [ebp]+TsEdi            ; Skip PreMode, ExceptList and fs

        pop     edi                         ; restore non-volatiles
        pop     esi
        pop     ebx
        pop     ebp

;
; Esp MUST point to the Error Code on the stack.  Because we use it to
; store the entering esp.
;

        cmp     word ptr [esp+8], 80h ; check for abios code segment?
        ja      AbiosExitHelp

        add     esp, 4              ; remove error code from trap frame

ifnb <NoRestoreVolatiles>

        public  _KiSystemCallExitBranch
        public  _KiSystemCallExit
        public  _KiSystemCallExit2
        public  _KiSystemCallExit3

; NoRestoreVolatiles is only used for return from System Service.
; If returning to Kernel mode, the processor state does not need
; to be altered (CS, CPL stays the same etc), so simply unwind the
; kernel frame and branch to the saved EIP.

        test    dword ptr [esp+4], MODE_MASK

; If the following branch is taken, we are returning to usermode.
; If this processor supports the SYSEXIT instruction, the branch
; will be adjusted at boot time to use the appropriate code sequence.

_KiSystemCallExitBranch:
        jnz     short _KiSystemCallExit

        ; Exit to kernel mode from system call, faster than IRETD,
        ; unwind the frame and branch to return address.

        pop     edx                 ; get eip
        pop     ecx                 ; remove CS from stack
        popfd                       ; restore eflags
        jmp     edx

if 0

        ; one day we should test and see if the following is faster
        ; than the above (and still valid).

        sti                         ; reenable interrupts
        ret     8                   ; return to @esp and pop CS and EFLAGs
endif


_KiSystemCallExit:

        iretd                       ; return

_KiSystemCallExit2:

        pop     edx                 ; pop EIP
        add     esp, 8              ; Remove CS & Eflags
        pop     ecx                 ; pop ESP

        sti                         ; sysexit does not reload flags

        iSYSEXIT

_KiSystemCallExit3:

        ; AMD

        pop     ecx                 ; pop EIP
        add     esp, 8
        pop     esp
;        mov     esp, [esp+8]        ; remove CS & Eflags, get ESP

        iSYSRET

endif  ;; <NoRestoreVolatiles>

        iretd                       ; return

if DBG
Db_NotATrapFrame:
        add     [esp]+TsDbgArgMark,0BADB0D00h   ; put back the orig value
Db_NotValidEntry:
        int 3
        jmp     Db_A
endif

;
;   EXIT_HELPER
;
;       if (PreviousMode == UserMode) {
;           DR* regs = TF.Dr* regs
;       }
;
;   Entry-Conditions:
;
;       DebugActive == TRUE
;       (ebp)->TrapFrame
;
;--

align dword
Dr_ExitHelp:

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     short x

        test    dword ptr [ebp]+TsSegCs,MODE_MASK
        jz      Dr_ExitHelp_Target

x:      mov     ebx,0
        mov     esi,[ebp]+TsDr0
        mov     edi,[ebp]+TsDr1
        mov     dr7,ebx
        mov     dr0,esi
        mov     ebx,[ebp]+TsDr2
        mov     dr1,edi
        mov     dr2,ebx
        mov     esi,[ebp]+TsDr3
        mov     edi,[ebp]+TsDr6
        mov     ebx,[ebp]+TsDr7
        mov     dr3,esi
        mov     dr6,edi
        mov     dr7,ebx

        jmp     Dr_ExitHelp_Target

;
if ?RestoreAll eq 0
;
;   Restore segs and volatiles for non-flat R3 PM (VDM in PM)
;

f:      mov     eax,[esp].TsEax     ; restore eax before any selectors
                                        ; (see trap0e handler)
        add     esp,TsSegGs

        pop     gs
        pop     es
        pop     ds

        pop     edx
        pop     ecx
        jmp     NonFlatPm_Target

endif   ; not ?RestoreAll


;
;   TsSegCs contains the special value that means the frame was edited
;   in a way that affected esp, AND it's a kernel mode frame.
;   (Special value is null selector except for RPL.)
;
;   Put back the real CS.
;   push eflags, eip onto target stack
;   restore
;   switch to target stack
;   iret
;

b:      mov     ebx,[esp]+TsTempSegCs
        mov     [esp]+TsSegCs,ebx

;
;   There is no instruction that will load esp with an arbitrary value
;   (i.e. one out of a frame) and do a return, if no privledge transition
;   is occuring.  Therefore, if we are returning to kernel mode, and
;   esp has been edited, we must "emulate" a kind of iretd.
;
;   We do this by logically pushing the eip,cs,eflags onto the new
;   logical stack, loading that stack, and doing an iretd.  This
;   requires that the new logical stack is at least 1 dword higher
;   than the unedited esp would have been.  (i.e.  It is not legal
;   to edit esp to have a new value < the old value.)
;
;   KeContextToKframes enforces this rule.
;

;
;   Compute new logical stack address
;

        mov     ebx,[esp]+TsTempEsp
        sub     ebx,12
        mov     [esp]+TsErrCode,ebx

;
;   Copy eip,cs,eflags to new stack.  note we do this high to low
;

        mov     esi,[esp]+TsEflags
        mov     [ebx+8],esi
        mov     esi,[esp]+TsSegCs
        mov     [ebx+4],esi
        mov     esi,[esp]+TsEip
        mov     [ebx],esi

;
;   Do a standard restore sequence.
;
;   Observe that RestoreVolatiles is honored.  Editing a volatile
;   register has no effect when returning from a system call.
;
ifb     <NoRestoreVolatiles>
        mov     eax,[esp].TsEax
endif
;        add     esp,TsSegGs
;
;ifb     <NoRestoreSegs>
;        pop     gs
;        pop     es
;        pop     ds
;else
;        add     esp,12
;endif

ifb     <NoRestoreVolatiles>
        mov     edx, [esp]+TsEdx
        mov     ecx, [esp]+TsEcx
endif

;ifnb <NoPreviousMode>
;        add     esp, 4              ; Skip previous mode
;else
;        pop     ebx                 ; Restore PreviousMode
;        mov     esi,fs:[PcPrcbData+PbCurrentThread]
;        mov     ss:[esi]+ThPreviousMode,bl
;endif
;
;       pop     ebx
;
;       mov     fs:[PcExceptionList], ebx ;Restore ExceptionList
;       pop     fs

        add     esp, TsEdi
        pop     edi                 ; restore non-volatiles
        pop     esi
        pop     ebx
        pop     ebp

;
;   (esp)->TsErrCode, where we saved the new esp
;

        mov     esp,[esp]           ; Do move not push to avoid increment
        iretd

        endm


;++
;
;   INTERRUPT_EXIT
;
;   Macro Description:
;
;       This macro is executed on return from an interrupt vector service
;       service routine.  Its function is to restore privileged processor
;       state, and continue thread execution. If control is returning to
;       user mode and there is a user  APC pending, then APC level interupt
;       will be requested and control is transfered to the user APC delivery
;       routine, if no higher level interrupt pending.
;
;   Arguments:
;
;       (TOS)   = previous irql
;       (TOS+4) = irq vector to eoi
;       (TOS+8 ...) = machine_state frame
;       (ebp)-> machine state frame (trap frame)
;
;--

INTERRUPT_EXIT     macro    DebugCheck
local   a

ifnb <DebugCheck>
        POLL_DEBUGGER
endif
if DBG                                          ; save current eip for
a:      mov     esi, offset a                   ; debugging bad trap frames
endif

ifdef __imp_Kei386EoiHelper@0
        cli
        call    _HalEndSystemInterrupt@8
        jmp     dword ptr [__imp_Kei386EoiHelper@0]

else
        cli
        call    dword ptr [__imp__HalEndSystemInterrupt@8]
        jmp     Kei386EoiHelper@0
endif
endm


;++
;
;   SPURIOUS_INTERRUPT_EXIT
;
;   Macro Description:
;
;       To exit an interrupt without performing the EOI.
;
;   Arguments:
;
;       (TOS) = machine_state frame
;       (ebp)-> machine state frame (trap frame)
;
;--

SPURIOUS_INTERRUPT_EXIT  macro
local   a
if DBG                                          ; save current eip for
a:      mov     esi, offset a                   ; debugging bad trap frames
endif
ifdef __imp_Kei386EoiHelper@0
        jmp     dword ptr [__imp_Kei386EoiHelper@0]
else
        jmp     Kei386EoiHelper@0
endif
endm

;++
;
;   ENTER_TRAPV86
;
;   Macro Description:
;
;       Construct trap frame for v86 mode traps.
;
;--

ENTER_TRAPV86 macro DRENTER,V86ENTER
        sub     esp, TsErrCode
        mov     word ptr [esp].TsErrCode + 2, 0
        mov     [esp].TsEbx, ebx
        mov     [esp].TsEax, eax
        mov     [esp].TsEbp, ebp
        mov     [esp].TsEsi, esi
        mov     [esp].TsEdi, edi
        mov     ebx, KGDT_R0_PCR
        mov     eax, KGDT_R3_DATA OR RPL_MASK
        mov     [esp].TsEcx, ecx
        mov     [esp].TsEdx, edx
if DBG
        mov     [esp].TsPreviousPreviousMode, -1
        mov     [esp]+TsDbgArgMark, 0BADB0D00h
endif
        mov     fs, bx
        mov     ds, ax
        mov     es, ax
        mov     ebp, esp
        cld                             ; CHECKIT_SUDEEP ; do we really need it
        test    byte ptr PCR[PcDebugActive], -1
        jnz     Dr_&DRENTER

Dr_&V86ENTER:
endm


;
; Taken from ntos\vdm\i386\vdmtb.inc
;

FIXED_NTVDMSTATE_LINEAR_PC_AT equ 0714H
FIXED_NTVDMSTATE_LINEAR_PC_98 equ 0614H
MACHINE_TYPE_MASK equ 0ff00H
VDM_VIRTUAL_INTERRUPTS  equ 0200H

;++
;
;   EXIT_TRAPV86
;
;   Macro Description:
;
;       if UserApc is pending deliver it
;       if User Context is v86 mode
;          Exit from kernel (does not return)
;       else
;          return (expected to execute EXIT_ALL)
;--

EXIT_TRAPV86 macro
        local w, x, y, z

z:      mov     ebx, PCR[PcPrcbData+PbCurrentThread]
        mov     byte ptr [ebx]+ThAlerted, 0
        cmp     byte ptr [ebx]+ThApcState.AsUserApcPending, 0
        jne     short w

        ;
        ; Kernel exit to V86 mode
        ;

        add     esp,TsEdx
        pop     edx
        pop     ecx
        pop     eax
        test    byte ptr PCR[PcDebugActive], -1
        jnz     short x
y:
        add     esp,12              ; unused fields
        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
        add     esp,4               ; clear error code
        iretd

x:      mov     esi,[ebp]+TsDr0
        mov     edi,[ebp]+TsDr1
        mov     ebx,[ebp]+TsDr2
        mov     dr0,esi
        mov     dr1,edi
        mov     dr2,ebx
        mov     esi,[ebp]+TsDr3
        mov     edi,[ebp]+TsDr6
        mov     ebx,[ebp]+TsDr7
        mov     dr3,esi
        mov     dr6,edi
        mov     dr7,ebx
        jmp     short y

w:
        ;
        ; Dispatch user mode APC
        ; The APC routine runs with interrupts on and at APC level
        ;

        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql
        push    eax                              ; Save OldIrql
        sti

        stdCall _KiDeliverApc, <1, 0, ebp>       ; ebp - Trap frame
                                                 ; 0 - Null exception frame
                                                 ; 1 - Previous mode

        pop     ecx                              ; (TOS) = OldIrql
        fstCall KfLowerIrql

        cli

        ;
        ; UserApc may have changed to vdm Monitor context (user flat 32)
        ; If it has cannot use the v86 only kernel exit
        ;

        test    dword ptr [ebp]+TsEFlags,EFLAGS_V86_MASK
        jnz     short z

        ; Exit to do EXIT_ALL
endm


;++
;
;   KERNEL ICECAP PROBE MACROS
;
;   Macro Description:
;
;       Used to wrap selected calls in .asm routines with the same
;       probe calls inserted by the C compiler when /fastcap is used.
;       The X-suffix versions of the probe calls are used only in
;       KiSystemService and log additional information such as
;       Pid, Tid, image file name, etc.
;
;   Arguments:
;
;       Current Function
;       Called Function
;
;--

IFDEF _CAPKERN
        extrn   __CAP_Start_Profiling@8:PROC
        extrn   __CAP_End_Profiling@4:PROC

CAPSTART macro ArgList
       stdCall __CAP_Start_Profiling, <ArgList>
endm

CAPEND macro ArgList
       stdCall __CAP_End_Profiling, <ArgList>
endm

CAPSTARTX macro ArgList
        push eax
        stdCall __CAP_ThreadID
        pop eax
       stdCall __CAP_Start_Profiling, <ArgList>
endm

CAPENDX macro ArgList
       stdCall __CAP_End_Profiling, <ArgList>
        push eax
        stdCall __CAP_SetCPU
        pop eax
endm

ELSE

CAPSTART macro ArgList
endm
CAPEND macro ArgList
endm
CAPSTARTX macro ArgList
endm
CAPENDX macro ArgList
endm

ENDIF

;++
;
;   PERF_GET_TIMESTAMP
;
;   Macro Description:
;
;
;   Return a time stamp that for event tracing in EDX:EAX
;
;   NOTE: This may trash ECX
; 
;   In retail, get the clock value from WmiGetCpuClock.  Else if using
;   reserved memory for logging, get cycle counter.  
; 
;--
PERF_GET_TIMESTAMP macro
        extrn   _WmiGetCpuClock:DWORD

        call    [_WmiGetCpuClock]

endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\kix86.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    kix86.h

Abstract:

    This module contains the private (internal) platform specific header file
    for the kernel.

Author:

    David N. Cutler (davec) 17-May-2000

Revision History:

--*/

#if !defined(_KIX86_)
#define _KIX86_

//
// VOID
// KiIpiSendSynchronousPacket (
//   IN PKPRCB Prcb,
//   IN KAFFINITY TargetProcessors,
//   IN PKIPI_WORKER WorkerFunction,
//   IN PVOID Parameter1,
//   IN PVOID Parameter2,
//   IN PVOID Parameter3
//   )
//
// Routine Description:
//
//   Similar to KiIpiSendPacket except that the pointer to the
//   originating PRCB (SignalDone) is kept in the global variable
//   KiSynchPacket and is protected by the context swap lock.  The
//   actual IPI is sent via KiIpiSend with a request type of
//   IPI_SYNCH_REQUEST.  This mechanism is used to send IPI's that
//   (reverse) stall until released by the originator.   This avoids
//   a deadlock that can occur if two processors are trying to deliver
//   IPI packets at the same time and one of them is a reverse stall.
//
//   N.B. The low order bit of the packet address is set if there is
//        exactly one target recipient. Otherwise, the low order bit
//        of the packet address is clear.
//

#define KiIpiSendSynchronousPacket(Prcb,Target,Function,P1,P2,P3)       \
    {                                                                   \
        extern PKPRCB KiSynchPacket;                                    \
                                                                        \
        Prcb->CurrentPacket[0] = (PVOID)(P1);                           \
        Prcb->CurrentPacket[1] = (PVOID)(P2);                           \
        Prcb->CurrentPacket[2] = (PVOID)(P3);                           \
        Prcb->TargetSet = (Target);                                     \
        Prcb->WorkerRoutine = (Function);                               \
        if (((Target) & ((Target) - 1)) == 0) {                         \
           KiSynchPacket = (PKPRCB)((ULONG_PTR)(Prcb) | 1);             \
        } else {                                                        \
           KiSynchPacket = (Prcb);                                      \
           Prcb->PacketBarrier = 1;                                     \
        }                                                               \
        KiIpiSend((Target),IPI_SYNCH_REQUEST);                          \
    }

VOID
KiInitializePcr (
    IN ULONG Processor,
    IN PKPCR Pcr,
    IN PKIDTENTRY Idt,
    IN PKGDTENTRY Gdt,
    IN PKTSS Tss,
    IN PKTHREAD Thread,
    IN PVOID DpcStack
    );

VOID
KiFlushNPXState (
    PFLOATING_SAVE_AREA SaveArea
    );

//
// Kix86FxSave(NpxFame) - performs an FxSave to the address specificied
//

__inline
VOID
Kix86FxSave(
    PFX_SAVE_AREA NpxFrame
    )
{
    _asm {
        mov eax, NpxFrame
        ;fxsave [eax]
        _emit  0fh
        _emit  0aeh
        _emit   0
    }
}

//
// Kix86FnSave(NpxFame) - performs an FxSave to the address specificied
//

__inline
VOID
Kix86FnSave(
    PFX_SAVE_AREA NpxFrame
    )
{
    __asm {
        mov eax, NpxFrame
        fnsave [eax]
    }
}

//
// Load Katmai New Instruction Technology Control/Status
//

__inline
VOID
Kix86LdMXCsr(
    PULONG MXCsr
    )
{
    _asm {
        mov eax, MXCsr
        ;LDMXCSR [eax]
        _emit  0fh
        _emit  0aeh
        _emit  10h
    }
}

//
// Store Katmai New Instruction Technology Control/Status
//

__inline
VOID
Kix86StMXCsr(
    PULONG MXCsr
    )
{
    _asm {
        mov eax, MXCsr
        ;STMXCSR [eax]
        _emit  0fh
        _emit  0aeh
        _emit  18h
    }
}

VOID
Ke386ConfigureCyrixProcessor (
    VOID
    );

ULONG
KiCopyInformation (
    IN OUT PEXCEPTION_RECORD ExceptionRecord1,
    IN PEXCEPTION_RECORD ExceptionRecord2
    );

VOID
KiSetHardwareTrigger (
    VOID
    );

#ifdef DBGMP

VOID
KiPollDebugger (
    VOID
    );

#endif

VOID
FASTCALL
KiIpiSignalPacketDoneAndStall (
    IN PKIPI_CONTEXT Signaldone,
    IN ULONG volatile *ReverseStall
    );

extern KIRQL KiProfileIrql;

BOOLEAN
KeInvalidateAllCaches (
    IN BOOLEAN AllProcessors
    );

//
// PAE definitions.
//

#define MAX_IDENTITYMAP_ALLOCATIONS 30

typedef struct _IDENTITY_MAP  {
    PHARDWARE_PTE   TopLevelDirectory;
    ULONG           IdentityCR3;
    ULONG           IdentityAddr;
    ULONG           PagesAllocated;
    PVOID           PageList[ MAX_IDENTITYMAP_ALLOCATIONS ];
} IDENTITY_MAP, *PIDENTITY_MAP;


VOID
Ki386ClearIdentityMap(
    PIDENTITY_MAP IdentityMap
    );

VOID
Ki386EnableTargetLargePage(
    PIDENTITY_MAP IdentityMap
    );

BOOLEAN
Ki386CreateIdentityMap(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PVOID StartVa,
    IN     PVOID EndVa
    );

BOOLEAN
Ki386EnableCurrentLargePage (
    IN ULONG IdentityAddr,
    IN ULONG IdentityCr3
    );

extern PVOID Ki386EnableCurrentLargePageEnd;

#if defined(_X86PAE_)
#define PPI_BITS    2
#define PDI_BITS    9
#define PTI_BITS    9
#else
#define PPI_BITS    0
#define PDI_BITS    10
#define PTI_BITS    10
#endif

#define PPI_MASK    ((1 << PPI_BITS) - 1)
#define PDI_MASK    ((1 << PDI_BITS) - 1)
#define PTI_MASK    ((1 << PTI_BITS) - 1)

#define KiGetPpeIndex(va) ((((ULONG)(va)) >> PPI_SHIFT) & PPI_MASK)
#define KiGetPdeIndex(va) ((((ULONG)(va)) >> PDI_SHIFT) & PDI_MASK)
#define KiGetPteIndex(va) ((((ULONG)(va)) >> PTI_SHIFT) & PTI_MASK)

#endif // _KIX86_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\largepag.c ===
#include "ki.h"

PVOID
Ki386AllocateContiguousMemory(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     ULONG Pages,
    IN     BOOLEAN Low4Meg
    );

BOOLEAN
Ki386IdentityMapMakeValid(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PHARDWARE_PTE PageTableEntry,
    OUT    PVOID *Page OPTIONAL
    );

BOOLEAN
Ki386MapAddress(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     ULONG Va,
    IN     PHYSICAL_ADDRESS PhysicalAddress
    );

PVOID
Ki386ConvertPte(
    IN OUT PHARDWARE_PTE Pte
    );

PHYSICAL_ADDRESS
Ki386BuildIdentityBuffer(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PVOID StartVa,
    IN     ULONG Length,
    OUT    PULONG PagesToMap
    );

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT,Ki386AllocateContiguousMemory)
#pragma alloc_text(INIT,Ki386BuildIdentityBuffer)
#pragma alloc_text(INIT,Ki386ClearIdentityMap)
#pragma alloc_text(INIT,Ki386ConvertPte)
#pragma alloc_text(INIT,Ki386CreateIdentityMap)
#pragma alloc_text(INIT,Ki386EnableTargetLargePage)
#pragma alloc_text(INIT,Ki386IdentityMapMakeValid)
#pragma alloc_text(INIT,Ki386MapAddress)

#endif

#define PTES_PER_PAGE (PAGE_SIZE / sizeof(HARDWARE_PTE))

BOOLEAN
Ki386CreateIdentityMap(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PVOID StartVa,
    IN     PVOID EndVa
    )
{
/*++

    This function creates an identity mapping for a region of memory.

    If the region of memory passed in includes memory that lies above
    4G, then a new buffer is allocated below 4G.

Arguments:

    IdentityMap - Pointer to the structure which will be filled with the newly
                  created top-level directory address.  It also provides
                  storage for the pointers used in alloating and freeing the
                  memory.

    StartVa - Pointer to the first byte of the region of memory that is to be
              memory mapped.

    EndVa - Pointer to the byte immediately after the last byte of the region
            that is to be memory mapped.

Return Value:

    TRUE if the function succeeds, FALSE otherwise.

    Note - Ki386ClearIdentityMap() should be called even on FALSE return to
    free any memory allocated.

--*/

    ULONG pageDirectoryIndex;
    ULONG pagesToMap;
    PCHAR currentVa;
    ULONG length;
    BOOLEAN result;
    PHARDWARE_PTE pageDirectory;
    PHARDWARE_PTE pageDirectoryEntry;
    PHYSICAL_ADDRESS identityAddress;

#if defined(_X86PAE_)

    ULONG pageDirectoryPointerTableIndex;
    PHARDWARE_PTE pageDirectoryPointerTable;
    PHARDWARE_PTE pageDirectoryPointerTableEntry;

#endif

    //
    // Initialize the IdentityMap structure to a known state.
    //

    RtlZeroMemory( IdentityMap, sizeof(IDENTITY_MAP) );
    length = (PCHAR)EndVa - (PCHAR)StartVa;

    //
    // Get the physical address of the input buffer (or suitable copy).
    //

    identityAddress = Ki386BuildIdentityBuffer( IdentityMap,
                                                StartVa,
                                                length,
                                                &pagesToMap );
    if( identityAddress.QuadPart == 0) {

        //
        // The input buffer was not contiguous or not below 4G, and a
        // suitable buffer could not be allocated.
        //

        return FALSE;
    }

    IdentityMap->IdentityAddr = identityAddress.LowPart;

    //
    // Set up the mappings.
    //

    currentVa = StartVa;
    do {

        //
        // Map in the virtual address
        //

        result = Ki386MapAddress( IdentityMap,
                                  (ULONG)currentVa,
                                  identityAddress );
        if (result == FALSE) {
            return FALSE;
        }

        //
        // Map in the identity (physical) address
        //

        result = Ki386MapAddress( IdentityMap,
                                  identityAddress.LowPart,
                                  identityAddress );
        if (result == FALSE) {
            return FALSE;
        }

        //
        // Advance both the Va and identityAddress pointers in anticipation
        // of mapping in another page.
        //

        currentVa += PAGE_SIZE;
        identityAddress.QuadPart += PAGE_SIZE;
        pagesToMap -= 1;

    } while (pagesToMap > 0);

    //
    // Now go through the page directory pointer table and page directories,
    // converting virtual page frames to physical ones.
    //

#if defined(_X86PAE_)

    //
    // This PAE-only outer loop walks the page directory pointer table entries
    // and processes each valid page directory referenced.
    //

    pageDirectoryPointerTable = IdentityMap->TopLevelDirectory;
    for (pageDirectoryPointerTableIndex = 0;
         pageDirectoryPointerTableIndex < (1 << PPI_BITS);
         pageDirectoryPointerTableIndex++) {

        pageDirectoryPointerTableEntry =
            &pageDirectoryPointerTable[ pageDirectoryPointerTableIndex ];

        if (pageDirectoryPointerTableEntry->Valid == 0) {
            continue;
        }

        pageDirectory =
            (PHARDWARE_PTE)Ki386ConvertPte( pageDirectoryPointerTableEntry );

#else
        pageDirectory = IdentityMap->TopLevelDirectory;
#endif

        for (pageDirectoryIndex = 0;
             pageDirectoryIndex < PTES_PER_PAGE;
             pageDirectoryIndex++) {

            pageDirectoryEntry = &pageDirectory[ pageDirectoryIndex ];
            if (pageDirectoryEntry->Valid == 0) {
                continue;
            }

            Ki386ConvertPte( pageDirectoryEntry );
        }

#if defined(_X86PAE_)
    }
#endif

    identityAddress = MmGetPhysicalAddress( IdentityMap->TopLevelDirectory );
    IdentityMap->IdentityCR3 = identityAddress.LowPart;

    return TRUE;
}

PVOID
Ki386AllocateContiguousMemory(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     ULONG Pages,
    IN     BOOLEAN Low4Meg
    )
/*++

    This function allocates page-aligned, physically contiguous memory.
    The allocation is recorded in the IdentityMap structure, so that it
    can be freed on cleanup.

Arguments:

    IdentityMap - Context pointer for this identity mapping.

    Pages - Number of pages to allocate

    Low4Meg - Indicates whether the allocation must be below 4M.

Return Value:

    Pointer to the new page on success, NULL otherwise.

--*/
{
    ULONG pageListIndex;
    PVOID page;
    ULONG allocationSize;
    PHYSICAL_ADDRESS highestAddress;

    if (Low4Meg != FALSE) {

        //
        // The caller has specified that a page must reside physically
        // below 4 MB.
        //

        highestAddress.LowPart = 0xFFFFFFFF;
        highestAddress.HighPart = 0;

    } else {

        //
        // Memory can reside anywhere
        //

        highestAddress.LowPart = 0xFFFFFFFF;
        highestAddress.HighPart = 0xFFFFFFFF;
    }

    allocationSize = Pages * PAGE_SIZE;
    page = MmAllocateContiguousMemory( allocationSize, highestAddress );
    if (page != NULL) {

        //
        // Record that this page was allocated so that it can be freed when
        // the IdentityMap structure is cleared.
        //

        pageListIndex = IdentityMap->PagesAllocated;
        IdentityMap->PageList[ pageListIndex ] = page;
        IdentityMap->PagesAllocated++;

        //
        // Initialize it.
        //

        RtlZeroMemory( page, allocationSize );
    }

    return page;
}

BOOLEAN
Ki386IdentityMapMakeValid(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PHARDWARE_PTE PageTableEntry,
    OUT    PVOID *Page OPTIONAL
    )
/*++

    If the page table has the valid bit set, this function merely returns
    the address referenced by the page table entry.

    If the page table does not have the valid bit set, then another page
    is allocated and inserted into the page table entry and the entry is
    marked valid.

    NOTE: At this point, PTE frames are virtual.  After the entire mapping
          is built, we go through and convert all virtual frames to physical
          ones.

Arguments:

    IdentityMap - Context pointer for this identity mapping.

    PageTableEntry - Pointer to the page table entry.

    Page - Virtual address now referenced by the PTE, whether it was
           valid before or not.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    PVOID page;

    if (PageTableEntry->Valid != 0) {

        //
        // If it already is present, there is nothing to do except record
        // the virtual page number that is already there.
        //

        page = (PVOID)((ULONG)(PageTableEntry->PageFrameNumber << PAGE_SHIFT));

    } else {

        //
        // The page table entry is not valid.  Allocate a new page table.
        //

        page = Ki386AllocateContiguousMemory( IdentityMap, 1, FALSE );
        if (page == NULL) {
            return FALSE;
        }

        //
        // Insert it into the page table entry and mark it valid.
        //
        // NOTE: Virtual page numbers are inserted into the page table
        //       structure as it is being built.  When it is finished, we walk
        //       the tables and convert all of the virtual page numbers to
        //       physical page numbers.
        //

        PageTableEntry->PageFrameNumber = ((ULONG)page) >> PAGE_SHIFT;
        PageTableEntry->Valid = 1;
    }

    if (ARGUMENT_PRESENT( Page )) {
        *Page = page;
    }

    return TRUE;
}

BOOLEAN
Ki386MapAddress(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     ULONG Va,
    IN     PHYSICAL_ADDRESS PhysicalAddress
    )

/*++

    Creates a new virtual->physical mapping in the identity map.

Arguments:

    IdentityMap - Context pointer for this identity mapping.

    Va - Virtual address to map.

    PhysicalAddress - Physical address to map.

Return Value:

    TRUE on success, FALSE otherwise.

--*/
{
    PHARDWARE_PTE pageTable;
    PHARDWARE_PTE pageTableEntry;
    PHARDWARE_PTE pageDirectory;
    PHARDWARE_PTE pageDirectoryEntry;
    PVOID table;
    ULONG index;
    BOOLEAN result;

#if defined(_X86PAE_)
    PHARDWARE_PTE pageDirectoryPointerTable;
    PHARDWARE_PTE pageDirectoryPointerTableEntry;
#endif

    if (IdentityMap->TopLevelDirectory == NULL) {

        //
        // Allocate a top-level directory structure, either a page directory
        // or a page directory pointer table.
        //

        table = Ki386AllocateContiguousMemory( IdentityMap, 1, TRUE );
        if (table == FALSE) {
            return FALSE;
        }

        IdentityMap->TopLevelDirectory = table;
    }

#if defined(_X86PAE_)

    index = KiGetPpeIndex( Va );
    pageDirectoryPointerTable = IdentityMap->TopLevelDirectory;
    pageDirectoryPointerTableEntry = &pageDirectoryPointerTable[ index ];

    result = Ki386IdentityMapMakeValid( IdentityMap,
                                        pageDirectoryPointerTableEntry,
                                        &pageDirectory );
    if (result == FALSE) {
        return FALSE;
    }

#else

    pageDirectory = IdentityMap->TopLevelDirectory;

#endif

    //
    // Get a pointer to the appropriate page directory entry.  If it is
    // not valid, allocate a new page table and mark the page directory
    // entry valid and writeable.
    //

    index = KiGetPdeIndex( Va );
    pageDirectoryEntry = &pageDirectory[ index ];
    result = Ki386IdentityMapMakeValid( IdentityMap,
                                        pageDirectoryEntry,
                                        &pageTable );
    if (result == FALSE) {
        return FALSE;
    }
    pageDirectoryEntry->Write = 1;

    //
    // Get a pointer to the appropriate page table entry and fill it in.
    //

    index = KiGetPteIndex( Va );
    pageTableEntry = &pageTable[ index ];

#if defined(_X86PAE_)
    pageTableEntry->PageFrameNumber = PhysicalAddress.QuadPart >> PAGE_SHIFT;
#else
    pageTableEntry->PageFrameNumber = PhysicalAddress.LowPart >> PAGE_SHIFT;
#endif
    pageTableEntry->Valid = 1;

    return TRUE;
}

PVOID
Ki386ConvertPte(
    IN OUT PHARDWARE_PTE Pte
    )
/*++

    Converts the virtual frame number in a PTE to a physical frame number.

Arguments:

    Pte - Pointer to the page table entry to convert.

Return Value:

    None.

--*/
{
    PVOID va;
    PHYSICAL_ADDRESS physicalAddress;

    va = (PVOID)(Pte->PageFrameNumber << PAGE_SHIFT);
    physicalAddress = MmGetPhysicalAddress( va );

#if defined(_X86PAE_)
    Pte->PageFrameNumber = physicalAddress.QuadPart >> PAGE_SHIFT;
#else
    Pte->PageFrameNumber = physicalAddress.LowPart >> PAGE_SHIFT;
#endif

    return va;
}

PHYSICAL_ADDRESS
Ki386BuildIdentityBuffer(
    IN OUT PIDENTITY_MAP IdentityMap,
    IN     PVOID StartVa,
    IN     ULONG Length,
    OUT    PULONG PagesToMap
    )
{

/*++

    This function checks to see if the physical memory backing a virtual
    buffer is physically contiguous and lies completely below 4G.

    If these requirements are met, then the physical address of StartVa is
    returned.

    If not, then a physically contiguous buffer is allocated, the contents
    of the region is copied in, and its address is returned.

Arguments:

    IdentityMap - Pointer to the identity map building structure.

    StartVa - Virtual address of the start of the region for which a
              physically contiguous copy is desired.

    Length - Length of the region for which a physically contiguous copy
             is desired.

--*/

    ULONG pagesToMap;
    ULONG pagesRemaining;
    PCHAR nextVirtualAddress;
    PHYSICAL_ADDRESS nextPhysicalAddress;
    PHYSICAL_ADDRESS physicalAddress;
    PHYSICAL_ADDRESS firstPhysicalAddress;
    ULONG pageOffset;
    PCHAR identityBuffer;

    //
    // Count the number of pages in the buffer, and record the physical
    // address of the start of the buffer.
    //

    pagesToMap = ADDRESS_AND_SIZE_TO_SPAN_PAGES( StartVa, Length );
    nextVirtualAddress = StartVa;
    firstPhysicalAddress = MmGetPhysicalAddress( StartVa );
    nextPhysicalAddress = firstPhysicalAddress;

    //
    // Examine each page in the region.
    //

    pagesRemaining = pagesToMap;
    while (TRUE) {

        physicalAddress = MmGetPhysicalAddress( nextVirtualAddress );
        if (physicalAddress.QuadPart != nextPhysicalAddress.QuadPart) {

            //
            // The buffer is not physically contiguous.
            //

            break;
        }

        if (physicalAddress.HighPart != 0) {

            //
            // The buffer does not lie entirely below 4G
            //

            break;
        }

        pagesRemaining -= 1;
        if (pagesRemaining == 0) {

            //
            // All of the pages in the buffer have been examined, and have
            // been found to meet the critera.  Return the physical address
            // of the start of the buffer.
            //

            *PagesToMap = pagesToMap;
            return firstPhysicalAddress;
        }

        nextVirtualAddress += PAGE_SIZE;
        nextPhysicalAddress.QuadPart += PAGE_SIZE;
    }

    //
    // The buffer does not meet the criteria and so its contents must be
    // copied to a buffer that does.
    //

    identityBuffer = Ki386AllocateContiguousMemory( IdentityMap,
                                                    pagesToMap,
                                                    TRUE );
    if (identityBuffer == 0) {

        //
        // A contiguous region of the appropriate size could not be located
        // below 4G physical.
        //

        physicalAddress.QuadPart = 0;

    } else {

        //
        // Got an appropriate physical buffer, now copy in the data
        //

        pageOffset = (ULONG)StartVa & (PAGE_SIZE-1);
        identityBuffer += pageOffset;

        RtlCopyMemory( identityBuffer, StartVa, Length );
        physicalAddress = MmGetPhysicalAddress( identityBuffer );

        *PagesToMap = pagesToMap;
    }

    return physicalAddress;
}



VOID
Ki386ClearIdentityMap(
    IN PIDENTITY_MAP IdentityMap
    )
{
/*++

    This function just frees the page directory and page tables created in
    Ki386CreateIdentityMap().

--*/

    ULONG index;
    PVOID page;

    //
    // IdentityMap->PageList is an array of addresses of pages allocated with
    // MmAllocateContiguousMemory().  Walk the array, freeing each page.
    //

    for (index = 0; index < IdentityMap->PagesAllocated; index++) {

        page = IdentityMap->PageList[ index ];
        MmFreeContiguousMemory( page );
    }
}

VOID
Ki386EnableTargetLargePage(
    IN PIDENTITY_MAP IdentityMap
    )
{
/*++

    This function just passes info on to the assembly routine
    Ki386EnableLargePage().

--*/

    Ki386EnableCurrentLargePage(IdentityMap->IdentityAddr,
                                IdentityMap->IdentityCR3);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\ldtsup2.asm ===
title  "Ldt Support 2 - Low Level"
;++
;
; Copyright (c) 1991  Microsoft Corporation
;
; Module Name:
;
;    ldtsup2.asm
;
; Abstract:
;
;    This module implements procedures to load a new ldt and to flush
;    segment descriptors.
;
; Author:
;
;    Bryan M. Willman (bryanwi)  14-May-1991
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include mac386.inc
include callconv.inc
        .list

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
; VOID
; KiLoadLdtr(
;    VOID
;    )
;
; Routine Description:
;
;    This routine copies the Ldt descriptor image out of the currently
;    executing process object into the Ldt descriptor, and reloads the
;    the Ldt descriptor into the Ldtr.  The effect of this is to provide
;    a new Ldt.
;
;    If the Ldt descriptor image has a base or limit of 0, then NULL will
;    be loaded into the Ldtr, and no copy to the Gdt will be done.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiLoadLdtr, 0

        push    esi
        push    edi

        mov     eax,fs:PcPrcbData+PbCurrentThread   ; (eax)->CurrentThread
        mov     eax,[eax]+(ThApcState+AsProcess)    ; (eax)->CurrentProcess

        lea     esi,[eax]+PrLdtDescriptor           ; (esi)->Ldt value
        xor     dx,dx                               ; assume null value
        cmp     word ptr [esi],0                    ; limit == 0?
        jz      kill10                              ; yes limit 0, go load null

;
;   We have a non-null Ldt Descriptor, copy it into the Gdt
;

        mov     edi,fs:PcGdt
        add     edi,KGDT_LDT                        ; (edi)->Ldt descriptor

        movsd
        movsd                                       ; descrip. now matches value

        mov     dx,KGDT_LDT

kill10: lldt    dx

        pop     edi
        pop     esi

        stdCall   _KiFlushDescriptors

        stdRET    _KiLoadLdtr

stdENDP _KiLoadLdtr



;++
;
; VOID
; KiFlushDescriptors(
;    VOID
;    )
;
; Routine Description:
;
;    Flush the in-processor descriptor registers for the segment registers.
;    We do this by reloading each segment register.
;
;    N.B.
;
;       This procedure is only intended to support Ldt operations.
;       It does not support operations on the Gdt.  In particular,
;       neither it nor Ke386SetDescriptorProcess are appropriate for
;       editing descriptors used by 16bit kernel code (i.e. ABIOS.)
;
;       Since we are in kernel mode, we know that CS and SS do NOT
;       contain Ldt selectors, any such selectors will be save/restored
;       by the interrupt that brought us here from user space.
;
;       Since we are in kernel mode, DS must contain a flat GDT descriptor,
;       since all entry sequences would have forced a reference to it.
;
;       Since we are in kernel mode, FS points to the PCR, since all
;       entry sequences force it to.
;
;       Therefore, only ES and GS need to be flushed.
;
;       Since no inline kernel code ever uses GS, we know it will be
;       restored from a frame of some caller, or nobody cares.  Therefore,
;       we load null into GS.  (Fastest possible load.)
;
;       ES is restored to KGDT_R3_DATA, because kernel exit will not restore
;       it for us.  If we do not put the correct value in ES, we may wind
;       up with zero in ES in user mode.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _KiFlushDescriptors ,0

        xor     ax,ax
        mov     gs,ax
        push    ds
        pop     es
        stdRET    _KiFlushDescriptors

stdENDP _KiFlushDescriptors


_TEXT$00   ends
        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\mi.inc ===
;++
;
;   Copyright (c) 1989	Microsoft Corporation
;
;   Module Name:
;
;       MI.INC
;
;   Abstract:
;
;       This module contains equates for x86 machine instructions
;
;   Author:
;
;       Dave Hastings 2 May 1991
;
;   Notes:
;       
;       This information used to reside in Trap.asm, but is now needed in
;       multiple source files.
;
;   Revision History:
;--


MAX_INSTRUCTION_LENGTH		EQU	15
MAX_INSTRUCTION_PREFIX_LENGTH	EQU	4
MI_LOCK_PREFIX			EQU	0F0H
MI_ADDR_PREFIX			EQU	067H
MI_TWO_BYTE			EQU	0FH
MI_HLT				EQU	0F4H
MI_LTR_LLDT			EQU	0
MI_LGDT_LIDT_LMSW		EQU	01H
MI_MODRM_MASK			EQU	38H
MI_LLDT_MASK			EQU	10h
MI_LTR_MASK			EQU	18H
MI_LGDT_MASK			EQU	10H
MI_LIDT_MASK			EQU	18H
MI_LMSW_MASK			EQU	30H
MI_SPECIAL_MOV_MASK		EQU	20H
MI_REP_INS_OUTS 		EQU	0F3H
MI_MIN_INS_OUTS 		EQU	06CH
MI_MAX_INS_OUTS 		EQU	06FH
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\ldtsup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ldtsup.c

Abstract:

    This module implements interfaces that support manipulation of i386 Ldts.
    These entry points only exist on i386 machines.

Author:

    Bryan M. Willman (bryanwi) 14-May-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"

//
// Low level assembler support procedures
//

VOID
KiLoadLdtr(
    VOID
    );

VOID
KiFlushDescriptors(
    VOID
    );

//
// Local service procedures
//

VOID
Ki386LoadTargetLdtr (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
Ki386FlushTargetDescriptors (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

VOID
Ke386SetLdtProcess (
    IN PKPROCESS Process,
    IN PLDT_ENTRY Ldt,
    IN ULONG Limit
    )
/*++

Routine Description:

    The specified LDT (which may be null) will be made the active Ldt of
    the specified process, for all threads thereof, on whichever
    processors they are running.  The change will take effect before the
    call returns.

    An Ldt address of NULL or a Limit of 0 will cause the process to
    receive the NULL Ldt.

    This function only exists on i386 and i386 compatible processors.

    No checking is done on the validity of Ldt entries.


    N.B.

    While a single Ldt structure can be shared amoung processes, any
    edits to the Ldt of one of those processes will only be synchronized
    for that process.  Thus, processes other than the one the change is
    applied to may not see the change correctly.

Arguments:

    Process - Pointer to KPROCESS object describing the process for
        which the Ldt is to be set.

    Ldt - Pointer to an array of LDT_ENTRYs (that is, a pointer to an
        Ldt.)

    Limit - Ldt limit (must be 0 mod 8)

Return Value:

    None.

--*/

{

    KGDTENTRY LdtDescriptor;
    BOOLEAN LocalProcessor;
    KIRQL OldIrql;
    PKPRCB Prcb;
    KAFFINITY TargetProcessors;

    //
    // Compute the contents of the Ldt descriptor
    //

    if ((Ldt == NULL) || (Limit == 0)) {

        //
        //  Set up an empty descriptor
        //

        LdtDescriptor.LimitLow = 0;
        LdtDescriptor.BaseLow = 0;
        LdtDescriptor.HighWord.Bytes.BaseMid = 0;
        LdtDescriptor.HighWord.Bytes.Flags1 = 0;
        LdtDescriptor.HighWord.Bytes.Flags2 = 0;
        LdtDescriptor.HighWord.Bytes.BaseHi = 0;

    } else {

        //
        // Insure that the unfilled fields of the selector are zero
        // N.B.  If this is not done, random values appear in the high
        //       portion of the Ldt limit.
        //

        LdtDescriptor.HighWord.Bytes.Flags1 = 0;
        LdtDescriptor.HighWord.Bytes.Flags2 = 0;

        //
        //  Set the limit and base
        //

        LdtDescriptor.LimitLow = (USHORT) ((ULONG) Limit - 1);
        LdtDescriptor.BaseLow = (USHORT)  ((ULONG) Ldt & 0xffff);
        LdtDescriptor.HighWord.Bytes.BaseMid = (UCHAR) (((ULONG)Ldt & 0xff0000) >> 16);
        LdtDescriptor.HighWord.Bytes.BaseHi =  (UCHAR) (((ULONG)Ldt & 0xff000000) >> 24);

        //
        //  Type is LDT, DPL = 0
        //

        LdtDescriptor.HighWord.Bits.Type = TYPE_LDT;
        LdtDescriptor.HighWord.Bits.Dpl = DPL_SYSTEM;

        //
        // Make it present
        //

        LdtDescriptor.HighWord.Bits.Pres = 1;

    }

    //
    // Acquire the context swap lock so a context switch cannot occur.
    //

    KiLockContextSwap(&OldIrql);

    //
    // Set the Ldt fields in the process object.
    //

    Process->LdtDescriptor = LdtDescriptor;

    //
    // Tell all processors active for this process to reload their LDTs
    //

#ifdef NT_UP

    KiLoadLdtr();

#else

    Prcb = KeGetCurrentPrcb();
    TargetProcessors = Process->ActiveProcessors & ~Prcb->SetMember;
    if (TargetProcessors != 0) {
        KiIpiSendPacket(TargetProcessors,
                        Ki386LoadTargetLdtr,
                        NULL,
                        NULL,
                        NULL);
    }

    KiLoadLdtr();
    if (TargetProcessors != 0) {

        //
        //  Stall until target processor(s) release us
        //

        KiIpiStallOnPacketTargets(TargetProcessors);
    }

#endif

    //
    // Restore IRQL and release the context swap lock.
    //

    KiUnlockContextSwap(OldIrql);
    return;
}

VOID
Ki386LoadTargetLdtr (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )
/*++

Routine Description:

    Reload local Ldt register and clear signal bit in TargetProcessor mask

Arguments:

    Argument - pointer to a ipi packet structure.
    ReadyFlag - Pointer to flag to be set once LDTR has been reloaded

Return Value:

    none.

--*/
{

    //
    // Reload the LDTR register from currently active process object
    //

    KiLoadLdtr();
    KiIpiSignalPacketDone(SignalDone);
    return;
}

VOID
Ke386SetDescriptorProcess (
    IN PKPROCESS Process,
    IN ULONG Offset,
    IN LDT_ENTRY LdtEntry
    )
/*++

Routine Description:

    The specified LdtEntry (which could be 0, not present, etc) will be
    edited into the specified Offset in the Ldt of the specified Process.
    This will be synchronzied accross all the processors executing the
    process.  The edit will take affect on all processors before the call
    returns.

    N.B.

    Editing an Ldt descriptor requires stalling all processors active
    for the process, to prevent accidental loading of descriptors in
    an inconsistent state.

Arguments:

    Process - Pointer to KPROCESS object describing the process for
        which the descriptor edit is to be performed.

    Offset - Byte offset into the Ldt of the descriptor to edit.
        Must be 0 mod 8.

    LdtEntry - Value to edit into the descriptor in hardware format.
        No checking is done on the validity of this item.

Return Value:

    none.

--*/

{

    PLDT_ENTRY Ldt;
    KIRQL OldIrql;
    PKPRCB Prcb;
    KAFFINITY TargetProcessors;

    //
    // Compute address of descriptor to edit.
    //

    Ldt =
        (PLDT_ENTRY)
         ((Process->LdtDescriptor.HighWord.Bytes.BaseHi << 24) |
         ((Process->LdtDescriptor.HighWord.Bytes.BaseMid << 16) & 0xff0000) |
         (Process->LdtDescriptor.BaseLow & 0xffff));
    Offset = Offset / 8;
    KiLockContextSwap(&OldIrql);

#ifdef NT_UP

    //
    // Edit the Ldt.
    //

    Ldt[Offset] = LdtEntry;

#else

    Prcb = KeGetCurrentPrcb();
    TargetProcessors = Process->ActiveProcessors & ~Prcb->SetMember;
    if (TargetProcessors != 0) {
        KiIpiSendSynchronousPacket(
            Prcb,
            TargetProcessors,
            Ki386FlushTargetDescriptors,
            (PVOID)&Prcb->ReverseStall,
            NULL,
            NULL);

        KiIpiStallOnPacketTargets(TargetProcessors);
    }

    //
    // All target processors have flushed the segment descriptors and
    // are waiting to proceed. Edit the ldt on the current processor,
    // then continue the execution of target processors.
    //

    Ldt[Offset] = LdtEntry;
    if (TargetProcessors != 0) {
        Prcb->ReverseStall += 1;
    }

#endif

    //
    // Restore IRQL and release the context swap lock.
    //

    KiUnlockContextSwap(OldIrql);
    return;
}

VOID
Ki386FlushTargetDescriptors (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Proceed,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )

/*++

Routine Description:

    This function flushes the segment descriptors on the current processor.

Arguments:

    Argument - pointer to a _KIPI_FLUSH_DESCRIPTOR structure.

    ReadyFlag - pointer to flag to syncroize with

Return Value:

    none.

--*/

{
    //
    // Flush the segment descriptors on the current processor and signal that
    // the descriptors have been flushed.
    //

    KiFlushDescriptors();
    KiIpiSignalPacketDoneAndStall (SignalDone, Proceed);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\misc.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This module implements machine dependent miscellaneous kernel functions.

Author:

    Ken Reneris     7-5-95

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#include "fastsys.inc"

extern BOOLEAN KeI386FxsrPresent;
extern BOOLEAN KeI386XMMIPresent;
extern UCHAR KiSystemCallExitBranch[];
extern UCHAR KiFastCallEntry[];
extern UCHAR KiDefaultSystemCall[];
extern UCHAR KiSystemCallExit[];
extern UCHAR KiSystemCallExit2[];
extern UCHAR KiSystemCallExit3[];
extern UCHAR KiFastSystemCallIa32[];
extern UCHAR KiFastSystemCallAmdK6[];
extern ULONG_PTR KiSystemCallExitAdjust;
extern ULONG KiFastSystemCallDisable;
PVOID KiFastSystemCallCode = KiDefaultSystemCall;

ULONG_PTR KiSystemCallExitAdjust;
UCHAR KiSystemCallExitAdjusted;
BOOLEAN KiFastSystemCallIsIA32;
BOOLEAN KiFastCallCopyDoneOnce = FALSE;

VOID
KeRestoreMtrr (
    VOID
    );

VOID
KeRestorePAT(
    VOID
    );
//
//
// Internal format of the floating_save structure which is passed
//
typedef struct _CONTROL_WORD {
    USHORT      ControlWord;
    ULONG       MXCsr;
} CONTROL_WORD, *PCONTROL_WORD;

typedef struct {
    UCHAR       Flags;
    KIRQL       Irql;
    KIRQL       PreviousNpxIrql;
    UCHAR       Spare[2];

    union {
        CONTROL_WORD    Fcw;
        PFX_SAVE_AREA   Context;
        ULONG_PTR       ContextAddressAsULONG;
    } u;
    ULONG       Cr0NpxState;

    PKTHREAD    Thread;         // debug

} FLOAT_SAVE, *PFLOAT_SAVE;


#define FLOAT_SAVE_COMPLETE_CONTEXT     0x01
#define FLOAT_SAVE_FREE_CONTEXT_HEAP    0x02
#define FLOAT_SAVE_VALID                0x04
#define FLOAT_SAVE_ALIGN_ADJUSTED       0x08
#define FLOAT_SAVE_RESERVED             0xF0

//
// Allocate Pool returns a pointer which is 8 byte aligned.  The
// floating point save area needs to be 16 byte aligned.  When 
// allocating the save area we add the difference and adjust if
// needed.
//

#define ALIGN_ADJUST                    8


NTSTATUS
KeSaveFloatingPointState (
    OUT PKFLOATING_SAVE     PublicFloatSave
    )
/*++

Routine Description:

    This routine saves the thread's current non-volatile NPX state,
    and sets a new initial floating point state for the caller.

Arguments:

    FloatSave - receives the current non-volatile npx state for the thread

Return Value:

--*/
{
    PKTHREAD Thread;
    PFX_SAVE_AREA NpxFrame;
    KIRQL                   Irql;
    USHORT                  ControlWord;
    ULONG                   MXCsr;
    PKPRCB                  Prcb;
    PFLOAT_SAVE             FloatSave;

    //
    // If the system is using floating point emulation, then
    // return an error
    //

    if (!KeI386NpxPresent) {
        return STATUS_ILLEGAL_FLOAT_CONTEXT;
    }

    //
    // Get the current irql and thread
    //

    FloatSave = (PFLOAT_SAVE) PublicFloatSave;

    Irql = KeGetCurrentIrql();
    Thread = KeGetCurrentThread();

    ASSERT (Thread->NpxIrql <= Irql);

    FloatSave->Flags           = 0;
    FloatSave->Irql            = Irql;
    FloatSave->PreviousNpxIrql = Thread->NpxIrql;
    FloatSave->Thread          = Thread;

    //
    // If the irql has changed we need to save the complete floating
    // state context as the prior level has been interrupted.
    //

    if (Thread->NpxIrql != Irql) {

        //
        // If this is apc level we don't have anyplace to hold this
        // context, allocate some heap.
        //

        if (Irql == APC_LEVEL) {
            FloatSave->u.Context = ExAllocatePoolWithTag (
                                        NonPagedPool,
                                        sizeof (FX_SAVE_AREA) + ALIGN_ADJUST,
                                        ' XPN'
                                        );

            if (!FloatSave->u.Context) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            FloatSave->Flags |= FLOAT_SAVE_FREE_CONTEXT_HEAP;

            //
            // ExAllocatePoolWithTag returns an 8 byte aligned pointer.
            // The FXSAVE instruction requires 16 byte alignment.  Adjust
            // the base address of the save area if needed.
            //

            if ((FloatSave->u.ContextAddressAsULONG & ALIGN_ADJUST) != 0) {
                FloatSave->u.ContextAddressAsULONG += ALIGN_ADJUST;
                FloatSave->Flags |= FLOAT_SAVE_ALIGN_ADJUSTED;
            }
            ASSERT((FloatSave->u.ContextAddressAsULONG & 0xF) == 0);

        } else {

            ASSERT (Irql == DISPATCH_LEVEL);
            FloatSave->u.Context = &KeGetCurrentPrcb()->NpxSaveArea;

        }

        FloatSave->Flags |= FLOAT_SAVE_COMPLETE_CONTEXT;
    }

    //
    // Stop context switching and allow access to the local fp unit
    //

    _asm {
        cli
        mov     eax, cr0
        mov     ecx, eax
        and     eax, not (CR0_MP|CR0_EM|CR0_TS)
        cmp     eax, ecx
        je      short sav10

        mov     cr0, eax
sav10:
    }

    Prcb = KeGetCurrentPrcb();

    //
    // Get ownership of npx register set for this context
    //

    if (Prcb->NpxThread != Thread) {

        //
        // If the other context is loaded in the npx registers, flush
        // it to that threads save area
        //
        if (Prcb->NpxThread) {

            NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Prcb->NpxThread->InitialStack) -
                        sizeof(FX_SAVE_AREA)));

            if (KeI386FxsrPresent) {
                Kix86FxSave(NpxFrame);
            } else {
                Kix86FnSave(NpxFrame);
            }

            NpxFrame->NpxSavedCpu = 0;
            Prcb->NpxThread->NpxState = NPX_STATE_NOT_LOADED;

        }

        Prcb->NpxThread = Thread;
    }

    NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->InitialStack) -
                sizeof(FX_SAVE_AREA)));


    //
    // Save the previous state as required
    //

    if (FloatSave->Flags & FLOAT_SAVE_COMPLETE_CONTEXT) {

        //
        // Need to save the entire context
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {
            if (KeI386FxsrPresent) {
                Kix86FxSave((FloatSave->u.Context));
            } else {
                Kix86FnSave((FloatSave->u.Context));
            }

            FloatSave->u.Context->NpxSavedCpu = 0;
            FloatSave->u.Context->Cr0NpxState = NpxFrame->Cr0NpxState;

        } else {
            RtlCopyMemory (FloatSave->u.Context, NpxFrame, sizeof(FX_SAVE_AREA));
            FloatSave->u.Context->NpxSavedCpu = 0;

        }

    } else {

        //
        // Save only the non-volatile state
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            _asm {
                mov     eax, FloatSave
                fnstcw  [eax] FLOAT_SAVE.u.Fcw.ControlWord
            }

            if ((KeI386FxsrPresent) && (KeI386XMMIPresent)) {
                Kix86StMXCsr(&FloatSave->u.Fcw.MXCsr);
            }

        } else {
            //
            // Save the control word from the npx frame.
            //

            if (KeI386FxsrPresent) {
                FloatSave->u.Fcw.ControlWord = (USHORT) NpxFrame->U.FxArea.ControlWord;
                FloatSave->u.Fcw.MXCsr = NpxFrame->U.FxArea.MXCsr;

            } else {
                FloatSave->u.Fcw.ControlWord = (USHORT) NpxFrame->U.FnArea.ControlWord;
            }
        }


        //
        // Save Cr0NpxState, but clear CR0_TS as there's not non-volatile
        // pending fp exceptions
        //

        FloatSave->Cr0NpxState = NpxFrame->Cr0NpxState & ~CR0_TS;
    }

    //
    // The previous state is saved.  Set an initial default
    // FP state for the caller
    //

    NpxFrame->Cr0NpxState = 0;
    Thread->NpxState = NPX_STATE_LOADED;
    Thread->NpxIrql  = Irql;
    ControlWord = 0x27f;    // 64bit mode
    MXCsr = 0x1f80;

    _asm {
        fninit
        fldcw       ControlWord
    }

    if ((KeI386FxsrPresent) && (KeI386XMMIPresent)) {
        Kix86LdMXCsr(&MXCsr);
    }

    _asm {
        sti
    }

    FloatSave->Flags |= FLOAT_SAVE_VALID;
    return STATUS_SUCCESS;
}


NTSTATUS
KeRestoreFloatingPointState (
    IN PKFLOATING_SAVE      PublicFloatSave
    )
/*++

Routine Description:

    This routine retores the thread's current non-volatile NPX state,
    to the passed in state.

Arguments:

    FloatSave - the non-volatile npx state for the thread to restore

Return Value:

--*/
{
    PKTHREAD Thread;
    PFX_SAVE_AREA NpxFrame;
    ULONG                   Cr0State;
    PFLOAT_SAVE             FloatSave;

    ASSERT (KeI386NpxPresent);

    FloatSave = (PFLOAT_SAVE) PublicFloatSave;
    Thread = FloatSave->Thread;

    NpxFrame = (PFX_SAVE_AREA)(((ULONG)(Thread->InitialStack) -
                sizeof(FX_SAVE_AREA)));


    //
    // Verify float save looks like it's from the right context
    //

    if ((FloatSave->Flags & (FLOAT_SAVE_VALID | FLOAT_SAVE_RESERVED)) != FLOAT_SAVE_VALID) {

        //
        // Invalid floating point save area.
        //

        KeBugCheckEx(INVALID_FLOATING_POINT_STATE,
                     0,
                     FloatSave->Flags,
                     0,
                     0);
    }

    if (FloatSave->Irql != KeGetCurrentIrql()) {

        //
        // Invalid IRQL.   IRQL now must be the same as when the
        // context was saved.  (Why?   Because we save it in different
        // places depending on the IRQL at that time).
        //

        KeBugCheckEx(INVALID_FLOATING_POINT_STATE,
                     1,
                     FloatSave->Irql,
                     KeGetCurrentIrql(),
                     0);
    }

    if (Thread != KeGetCurrentThread()) {

        //
        // Invalid Thread.   The thread this floating point context
        // belongs to is not the current thread (or the saved thread
        // field is trash).
        //

        KeBugCheckEx(INVALID_FLOATING_POINT_STATE,
                     2,
                     (ULONG_PTR)Thread,
                     (ULONG_PTR)KeGetCurrentThread(),
                     0);
    }


    //
    // Synchronize with context switches and the npx trap handlers
    //

    _asm {
        cli
    }

    //
    // Restore the required state
    //

    if (FloatSave->Flags & FLOAT_SAVE_COMPLETE_CONTEXT) {

        //
        // Restore the entire fp state to the threads save area
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            //
            // This state in the fp unit is no longer needed, just disregard it
            //

            Thread->NpxState = NPX_STATE_NOT_LOADED;
            KeGetCurrentPrcb()->NpxThread = NULL;
        }

        //
        // Copy restored state to npx frame
        //

        RtlCopyMemory (NpxFrame, FloatSave->u.Context, sizeof(FX_SAVE_AREA));

    } else {

        //
        // Restore the non-volatile state
        //

        if (Thread->NpxState == NPX_STATE_LOADED) {

            //
            // Init fp state and restore control word
            //

            _asm {
                fninit
                mov     eax, FloatSave
                fldcw   [eax] FLOAT_SAVE.u.Fcw.ControlWord
            }


            if ((KeI386FxsrPresent) && (KeI386XMMIPresent)) {
                Kix86LdMXCsr(&FloatSave->u.Fcw.MXCsr);
            }


        } else {

            //
            // Fp state not loaded.  Restore control word in npx frame
            //

            if (KeI386FxsrPresent) {
                NpxFrame->U.FxArea.ControlWord = FloatSave->u.Fcw.ControlWord;
                NpxFrame->U.FxArea.StatusWord = 0;
                NpxFrame->U.FxArea.TagWord = 0;
                NpxFrame->NpxSavedCpu = 0;
                NpxFrame->U.FxArea.MXCsr = FloatSave->u.Fcw.MXCsr;

            } else {
                NpxFrame->U.FnArea.ControlWord = FloatSave->u.Fcw.ControlWord;
                NpxFrame->U.FnArea.StatusWord = 0;
                NpxFrame->U.FnArea.TagWord = 0xffff;
            }

        }

        NpxFrame->Cr0NpxState = FloatSave->Cr0NpxState;
    }

    //
    // Restore NpxIrql and Cr0
    //

    Thread->NpxIrql = FloatSave->PreviousNpxIrql;
    Cr0State = Thread->NpxState | NpxFrame->Cr0NpxState;

    _asm {
        mov     eax, cr0
        mov     ecx, eax
        and     eax, not (CR0_MP|CR0_EM|CR0_TS)
        or      eax, Cr0State
        cmp     eax, ecx
        je      short res10
        mov     cr0, eax
res10:
        sti
    }

    //
    // Done
    //

    if ((FloatSave->Flags & FLOAT_SAVE_FREE_CONTEXT_HEAP) != 0) {

        //
        // If FXSAVE area was adjusted for alignment after allocation,
        // undo that adjustment before freeing.
        //

        if ((FloatSave->Flags & FLOAT_SAVE_ALIGN_ADJUSTED) != 0) {
            FloatSave->u.ContextAddressAsULONG -= ALIGN_ADJUST;
        }
        ExFreePool (FloatSave->u.Context);
    }

    FloatSave->Flags = 0;
    return STATUS_SUCCESS;
}

VOID
KiDisableFastSyscallReturn(
    VOID
    )

/*++

Routine Description:

    The fast syscall/return feature cannot be used until
    certain processor specific registers have been initialized.
    This routine is called when the system is switching to a
    state where not all processors are powered on.

    This routine adjusts the exit path for system calls to
    use the iretd instruction instead of the faster sysexit
    instruction, it accomplishes this by adjusting the offset
    of a branch.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (KiSystemCallExitAdjusted) {
        KiSystemCallExitBranch[1] -= KiSystemCallExitAdjusted;
        KiSystemCallExitAdjusted = 0;
    }
}

VOID
KiEnableFastSyscallReturn(
    VOID
    )

/*++

Routine Description:

    The fast syscall/return feature cannot be used until
    certain processor specific registers have been initialized.
    This routine is called once the registers are known to
    have been set on all processors.

    This routine adjusts the exit path for system calls to
    use the appropriate sequence for the processor, it does
    this by adjusting the offset of a branch.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Adjust the second byte of the two byte branch instruction.
    // It can never be otherwise, but, make sure we aren't going
    // to adjust it out of range.
    //

    //
    // The following is a workaround for the fact that in resume
    // from hibernate the kernel is read only.   Basically, we
    // won't try to do it again, we also don't undo it when
    // hibernating/suspending.
    //

    if ((KiSystemCallExitAdjusted == KiSystemCallExitAdjust) &&
        KiFastCallCopyDoneOnce) {

        //
        // It's already done, don't try to do it again.
        //

        return;
    }

    if ((KiSystemCallExitAdjust + KiSystemCallExitBranch[1]) < 0x80) {

        //
        // It's good, undo any previous adjustment.
        //

        KiDisableFastSyscallReturn();

        //
        // Adjust the branch.
        //

        KiSystemCallExitAdjusted = (UCHAR)KiSystemCallExitAdjust;
        KiSystemCallExitBranch[1] += KiSystemCallExitAdjusted;

        //
        // Copy the appropriate system entry code into user shared
        // data where it can be executed from user mode.
        //

        RtlCopyMemory(SharedUserData->SystemCall,
                      KiFastSystemCallCode,
                      sizeof(SharedUserData->SystemCall));
        KiFastCallCopyDoneOnce = TRUE;
    }
}

VOID
KePrepareToLoseProcessorSpecificState(
    VOID
    )
{
    //
    //  The kernel has been marked read only, adjusting
    //  code right now won't work.   Fortunately, we
    //  don't actually need to do this as the SYSEXIT
    //  instruction doesn't depend on the SYSENTER MSRs.
    //
    // KiDisableFastSyscallReturn();
}

VOID
KiLoadFastSyscallMachineSpecificRegisters(
    IN volatile PLONG Void
    )

/*++

Routine Description:

    Load MSRs used to support Fast Syscall/return.  This routine is
    run on all processors.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (KiFastSystemCallIsIA32) {

        //
        // Use Intel defined way of doing this.
        //

        WRMSR(MSR_SYSENTER_CS,  KGDT_R0_CODE);
        WRMSR(MSR_SYSENTER_EIP, (ULONGLONG)(ULONG)KiFastCallEntry);
        WRMSR(MSR_SYSENTER_ESP, 0);

#if 0

    } else {

        //
        // Use the non-Intel way. (Note: Now that Intel has also
        // defined a way, most new processors do it that way).
        //

        LARGE_INTEGER Value;

        Value.u.HighPart = ((KGDT_R3_CODE | 3) << 16) | KGDT_R0_CODE;
        Value.u.LowPart = (ULONG)KiFastCallEntry;
        WRMSR(MSR_SYSCALL_TARGET_ADDR, Value.QuadPart);

        //
        // Now enable the feature.
        //

        Value.QuadPart = RDMSR(MSR_EXT_FEATURE_ENABLE);
        Value.u.LowPart |= MSR_EFER_SCE;
        WRMSR(MSR_EXT_FEATURE_ENABLE, Value.QuadPart);

#endif

    }
}

VOID
KiRestoreFastSyscallReturnState(
    VOID
    )
{
    ULONG_PTR Void = 0;

    if (KeFeatureBits & KF_FAST_SYSCALL) {

        if (KiFastSystemCallDisable == 0) {

            //
            // Fast system call is enabled.
            //

            if (KiFastSystemCallIsIA32 == TRUE) {
                KiSystemCallExitAdjust = KiSystemCallExit2 - KiSystemCallExit;
                KiFastSystemCallCode = KiFastSystemCallIa32;
            } else {
                KiSystemCallExitAdjust = KiSystemCallExit3 - KiSystemCallExit;
                KiFastSystemCallCode = KiFastSystemCallAmdK6;
            }
        } else {

            //
            // Fast system call has been explicitly disabled or is
            // not implemented on all processors in the system.
            //

            KeFeatureBits &= ~KF_FAST_SYSCALL;
        }
    }
    if (KeFeatureBits & KF_FAST_SYSCALL) {

        //
        // On all processors, set the MSRs that support syscall/sysexit.
        //

        KiIpiGenericCall(
            (PKIPI_BROADCAST_WORKER)KiLoadFastSyscallMachineSpecificRegisters,
            Void
            );

    }

    //
    // Set the appropriate code for system call into the system
    // call area of the shared user data area.
    //

    KiEnableFastSyscallReturn();
}

VOID
KeRestoreProcessorSpecificFeatures(
    VOID
    )

/*++

Routine Description:

    Restore processor specific features.  This routine is called
    when processors have been restored to a powered on state to
    restore those things which are not part of the processor's
    "normal" context which may have been lost.  For example, this
    routine is called when a system is resumed from hibernate or
    suspend.

Arguments:

    None.

Return Value:

    None.

--*/
{
    KeRestoreMtrr();
    KeRestorePAT();
    KiRestoreFastSyscallReturnState();
}


#if !defined(NT_UP)

VOID
FASTCALL
KiAcquireQueuedSpinLockCheckForFreeze(
    IN PKSPIN_LOCK_QUEUE QueuedLock,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine is called to acquire a queued spin lock while at high
    priority.   While the lock is not available, a check is made to see
    if another processor has requested this processor freeze execution.
    
    Note: This routine must be called with current IRQL at or above
    dispatch lever, or interrupts disabled.

Arguments:

    QueuedLock  Supplies the address of the queued spinlock.
    TrapFrame   Supplies the address of the trap frame to pass to
                KiFreezeTargetExecution.

Return Value:

    None.

--*/

{
    PKSPIN_LOCK_QUEUE Previous;
    PKSPIN_LOCK Lock;
    PKPRCB Prcb;
    volatile ULONG_PTR * LockPointer;

    LockPointer = (volatile ULONG_PTR *)&QueuedLock->Lock;

    Previous = InterlockedExchangePointer(QueuedLock->Lock, QueuedLock);

    if (Previous == NULL) {

        //
        // This processor now owns this lock.
        //

        *LockPointer |= LOCK_QUEUE_OWNER;

    } else {

        //
        // Lock is already held, update thew next pointer in the
        // previous queue entry to point to this new waiter and 
        // wait until the lock is granted.
        //
        // The following loop is careful not to write ANYTHING
        // while waiting unless a freeze execution has been
        // requested.   This includes any stack variables or
        // return addresses.
        //

        *LockPointer |= LOCK_QUEUE_WAIT;
        Previous->Next = QueuedLock;

        Prcb = KeGetCurrentPrcb();

        while (*LockPointer & LOCK_QUEUE_WAIT) {
            if (Prcb->RequestSummary & IPI_FREEZE) {
                ULONG OldSummary;
                ULONG NewSummary;
                ULONG Summary;

                OldSummary = Prcb->RequestSummary;
                NewSummary = OldSummary & ~IPI_FREEZE;
                Summary = InterlockedCompareExchange((PVOID)&Prcb->RequestSummary,
                                                     NewSummary,
                                                     OldSummary);

                //
                // If something else edited the RequestSummary, we'll
                // get it next time around (unless the IPI has been
                // handled).
                //

                if (Summary == OldSummary) {

                    //
                    // IPI_FREEZE cleared in RequestSummary.   Now
                    // freeze as requested.
                    //

                    KiFreezeTargetExecution(TrapFrame, NULL);
                }
            }

            //
            // Don't be a hog.
            //

            KeYieldProcessor();
        }
    }

    //
    // Lock has been acquired.
    //
}

#endif


/*++

QLOCK_STAT_GATHER

    If this flag is defined, the queued spinlock routines are
    replaced by wrappers used to gather performance characteristics
    of the code acquiring the locks.

--*/

#if defined(QLOCK_STAT_GATHER)

#define QLOCK_STAT_CLEAN
#define QLOCKS_NUMBER   16
#define QLOCKS_MAX_LOG  512

ULONG
FASTCALL
KiRDTSC(
    PULONGLONG Time
    );

//
// The following structure is used to accumulate data about each
// acquire/release pair for a lock.
//

typedef struct {
    ULONGLONG   Key;
    ULONGLONG   Time;
    ULONGLONG   WaitTime;
    ULONG       Count;
    ULONG       Waiters;
    ULONG       Depth;
    ULONG       IncreasedDepth;
    ULONG       Clean;
} QLOCKDATA, *PQLOCKDATA;

//
// House keeping data for each lock.
//

typedef struct {

    //
    // The following fields are used to keep data from acquire
    // to release.
    //

    ULONGLONG   AcquireTime;
    ULONGLONG   WaitToAcquire;
    ULONG_PTR   AcquirePoint;
    BOOLEAN     Clean;

    //
    // Remaining fields accumulate global stats for this lock.
    //

    ULONG       Count;
    ULONG       Pairs;
    ULONG       FailedTry;
    UCHAR       MaxDepth;
    UCHAR       PreviousDepth;
    ULONG       NoWait;
} QLOCKHOUSE, *PQLOCKHOUSE;

QLOCKDATA   KiQueuedSpinLockLog[QLOCKS_NUMBER][QLOCKS_MAX_LOG];
QLOCKHOUSE  KiQueuedSpinLockHouse[QLOCKS_NUMBER];

//
// Implement the lock queue mechanisms in C for when we are
// gathering performance data.
//

VOID
FASTCALL
KiAcquireQueuedLock(
    IN PKSPIN_LOCK_QUEUE QueuedLock
    )
{
    PKSPIN_LOCK_QUEUE Previous;
    PKSPIN_LOCK Lock;
    volatile ULONG_PTR * LockPointer;

    LockPointer = (volatile ULONG_PTR *)&QueuedLock->Lock;

    Previous = InterlockedExchangePointer(QueuedLock->Lock, QueuedLock);

    if (Previous == NULL) {

        //
        // This processor now owns this lock.
        //

#if defined(QLOCK_STAT_CLEAN)

        ULONG LockNumber;

        LockNumber = QueuedLock - KeGetCurrentPrcb()->LockQueue;

        //
        // The following check allows the conversion from QueuedLock to
        // lock number to work (validly) even if in stack queued spin
        // locks are using this routine.
        //

        if (LockNumber < QLOCKS_NUMBER) {
            KiQueuedSpinLockHouse[LockNumber].Clean = 1;
        }
        
#endif

        *LockPointer |= LOCK_QUEUE_OWNER;

    } else {

        //
        // Lock is already held, update thew next pointer in the
        // previous queue entry to point to this new waiter and 
        // wait until the lock is granted.
        //

        *LockPointer |= LOCK_QUEUE_WAIT;
        Previous->Next = QueuedLock;

        while (*LockPointer & LOCK_QUEUE_WAIT) {
            KeYieldProcessor();
        }
    }

    //
    // Lock has been acquired.
    //
}

VOID
FASTCALL
KiReleaseQueuedLock(
    IN PKSPIN_LOCK_QUEUE QueuedLock
    )
{
    PKSPIN_LOCK_QUEUE Waiter;

    //
    // Get the address of the actual lock and strip out the bottom
    // two bits which are used for status.
    //

    ASSERT((((ULONG_PTR)QueuedLock->Lock) & 3) == LOCK_QUEUE_OWNER);
    QueuedLock->Lock = (PKSPIN_LOCK)((ULONG_PTR)QueuedLock->Lock & ~3);

    Waiter = (PKSPIN_LOCK_QUEUE)*QueuedLock->Lock;

    if (Waiter == QueuedLock) {

        //
        // Good chance noone is queued on this lock, to be sure
        // we need to do an interlocked operation on it.
        // Note: This is just an optimization, there is no point
        // in doing the interlocked compare exchange if someone
        // else has already joined the queue.
        //

        Waiter = InterlockedCompareExchangePointer(QueuedLock->Lock,
                                                   NULL,
                                                   QueuedLock);
    }
    if (Waiter != QueuedLock) {

        //
        // There is another waiter.  It is possible for the waiter
        // to have only just performed the exchange that put its 
        // context in the lock and to have not yet updated the
        // 'next' pointer in the previous context (which could be 
        // this context), so we wait for our next pointer to be
        // non-null before continuing.
        //

        volatile PKSPIN_LOCK_QUEUE * NextQueuedLock = &QueuedLock->Next;

        while ((Waiter = *NextQueuedLock) == NULL) {
            KeYieldProcessor();
        }

        //
        // Pass the lock on to the next in line.
        //

        *((PULONG_PTR)&Waiter->Lock) ^= (LOCK_QUEUE_WAIT | LOCK_QUEUE_OWNER);
        QueuedLock->Next = NULL;
    }
}

KIRQL
FASTCALL
KiQueueStatAcquireQueuedLock(
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )
{
    KIRQL PreviousIrql;

    PreviousIrql = KfRaiseIrql(DISPATCH_LEVEL);
    KiAcquireQueuedLock(&KeGetCurrentPrcb()->LockQueue[Number]);
    return PreviousIrql;
}

KIRQL
FASTCALL
KiQueueStatAcquireQueuedLockRTS(
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )
{
    KIRQL PreviousIrql;

    PreviousIrql = KfRaiseIrql(SYNCH_LEVEL);
    KiAcquireQueuedLock(&KeGetCurrentPrcb()->LockQueue[Number]);
    return PreviousIrql;
}

LOGICAL
FASTCALL
KiQueueStatTryAcquire(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN PKIRQL OldIrql,
    IN KIRQL NewIrql
    )
{
    KIRQL PreviousIrql;
    LOGICAL Acquired = FALSE;
    PKSPIN_LOCK_QUEUE Previous;
    PKSPIN_LOCK_QUEUE QueuedLock;
    ULONG_PTR * LockPointer;
    ULONG_PTR Lock;

    _disable();

    QueuedLock = &KeGetCurrentPrcb()->LockQueue[Number];
    LockPointer = (ULONG_PTR *)&QueuedLock->Lock;
    Lock = *LockPointer;

    Previous = InterlockedCompareExchangePointer(Lock, QueuedLock, NULL);

    if (Previous == NULL) {

        //
        // This processor now owns this lock.  Set the owner bit in
        // the queued lock lock pointer, raise IRQL to the requested
        // level, set the old IRQL in the caller provided location
        // and return success.
        //

        Lock |= LOCK_QUEUE_OWNER;
        *LockPointer = Lock;
        Acquired = TRUE;
        PreviousIrql = KfRaiseIrql(NewIrql);
        *OldIrql = PreviousIrql;
    }
    
    _enable();

    return Acquired;
}

VOID
FASTCALL
KiQueueStatReleaseQueuedLock(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN KIRQL OldIrql
    )
{
    KiReleaseQueuedLock(&KeGetCurrentPrcb()->LockQueue[Number]);
    KfLowerIrql(OldIrql);
}

UCHAR
FASTCALL
KiQueuedLockDepth(
    IN PKSPIN_LOCK_QUEUE QueuedLock
    )
{
    //
    // Run down the list of waiters and see how many there are.
    //

    ULONG Depth = 0;
    ULONG_PTR LastAcquire;
    ULONG Debug;


    //
    // Get address of last acquirer in queue (stip the status bits
    // out of the address).
    //

    LastAcquire = (ULONG_PTR)QueuedLock->Lock;
    LastAcquire &= ~3;
    LastAcquire = *(PULONG_PTR)LastAcquire;

    //
    // Run down the list advancing QueuedLock until the end is reached.
    //

    while (LastAcquire != (ULONG_PTR)QueuedLock) {
        Debug = 0;

        //
        // If the waiter is not at the end of the list and has not yet
        // updated the forward pointer, wait for that update to happen.
        //

        if (QueuedLock->Next == NULL) {
            volatile PKSPIN_LOCK_QUEUE * NextQueuedLock = &QueuedLock->Next;

            while (*NextQueuedLock == NULL) {
                KeYieldProcessor();
                if (++Debug > 10000000) {
                    DbgBreakPoint();
                    Debug = 0;
                }
            }
        }
        Depth++;
        QueuedLock = QueuedLock->Next;
    }

    return Depth;
}

//
// The following routines complete the queued spinlock package.
//

VOID
FASTCALL
KeAcquireInStackQueuedSpinLockAtDpcLevel(
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )
{
    LockHandle->LockQueue.Next = NULL;
    LockHandle->LockQueue.Lock = SpinLock;
    KiAcquireQueuedLock(&LockHandle->LockQueue);
}

VOID
FASTCALL
KeReleaseInStackQueuedSpinLockFromDpcLevel (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )
{
    KiReleaseQueuedLock(&LockHandle->LockQueue);
}

//
// Although part of the queued spinlock package, the following 
// routines need to be implemented in assembly code to gather
// lock statistics.
//

#if 0
VOID
FASTCALL
KeAcquireQueuedSpinLockAtDpcLevel(
    IN PKSPIN_LOCK_QUEUE QueuedLock
    )
{
    KiAcquireQueuedLock(QueuedLock);
}

VOID
FASTCALL
KeReleaseQueuedSpinLockFromDpcLevel (
    IN PKSPIN_LOCK_QUEUE QueuedLock
    )
{
    KiReleaseQueuedLock(QueuedLock);
}

#endif

VOID
FASTCALL
KiQueueStatTrySucceeded(
    IN PKSPIN_LOCK_QUEUE QueuedLock,
    IN ULONG_PTR CallersAddress
    )
{
    PKPRCB      Prcb;
    ULONG       LockNumber;

    Prcb = KeGetCurrentPrcb();
    LockNumber = QueuedLock - Prcb->LockQueue;

    //
    // Record time now.
    //

    KiRDTSC(&KiQueuedSpinLockHouse[LockNumber].AcquireTime);
    KiQueuedSpinLockHouse[LockNumber].WaitToAcquire = 0;
    KiQueuedSpinLockHouse[LockNumber].AcquirePoint = CallersAddress;
}

VOID
FASTCALL
KiQueueStatTryFailed(
    IN PKSPIN_LOCK_QUEUE QueuedLock
    )
{
    PKPRCB      Prcb;
    ULONG       LockNumber;

    Prcb = KeGetCurrentPrcb();
    LockNumber = QueuedLock - Prcb->LockQueue;

    KiQueuedSpinLockHouse[LockNumber].FailedTry++;
}

VOID
FASTCALL
KiQueueStatTry(
    IN PULONG Everything
    )

/*++

Routine Description:

    Log success or failure of a TryToAcquire.   

    If success, logs the same data as KiQueueStatAcquire except
    the wait time is 0.

Arguments:

    Argument points to an array of ULONG data.

        +0   xxxxxxRR    RR is result (1 = success, 0 = fail)
        +4   aaaaaaaa    Argument to try to acquire (ie lock number)
        +8   cccccccc    Caller address


Return Value:

    None.

--*/

{

    UCHAR Success = *(PUCHAR)Everything;
    ULONG LockNumber = Everything[1];

    if (!Success) {
        KiQueuedSpinLockHouse[LockNumber].FailedTry++;
        return;
    }

    KiRDTSC(&KiQueuedSpinLockHouse[LockNumber].AcquireTime);
    KiQueuedSpinLockHouse[LockNumber].WaitToAcquire = 0;
    KiQueuedSpinLockHouse[LockNumber].AcquirePoint = Everything[2];
}

VOID
FASTCALL
KiQueueStatAcquire(
    IN PULONG Everything
    )

/*++

Routine Description:

    This routine is called when a lock has been acquired.  It's
    purpose it to record wait time, acquisition time and who
    acquired the lock.

Arguments:

    Argument points to an array of ULONG data.

        +0   aaaaaaaa    LockNumber
        +4   tltltltl    time low  = time wait to acquire began
        +8   thththth    time high =
        +c   cccccccc    Caller address


Return Value:

    None.

--*/

{
    ULONG LockNumber = Everything[0];
    PQLOCKHOUSE LockHome;

    //
    // Make this routine work with either a lock number of lock address.
    //

    if (LockNumber > QLOCKS_NUMBER) {

        LockNumber = ((PKSPIN_LOCK_QUEUE)Everything[0]) -
                     KeGetCurrentPrcb()->LockQueue;
    }

    LockHome = &KiQueuedSpinLockHouse[LockNumber];
    LockHome->WaitToAcquire = *(PULONGLONG)&Everything[1];
    LockHome->AcquirePoint = Everything[3];
    KiRDTSC(&LockHome->AcquireTime);
}

VOID
FASTCALL
KiQueueStatRelease(
    IN PULONG Everything
    )

/*++

Routine Description:

    This routine is called when a lock is released to log statistics
    about the lock.   This routine is called with the lock still held,
    the statistics update is protected by the lock itself.

Arguments:

    Argument points to an array of ULONG data.

        +0   aaaaaaaa    Lock number
        +4   cccccccc    Caller address

Return Value:

    None.

--*/

{

    PQLOCKDATA Entry;
    ULONGLONG Key;
    ULONGLONG Now;
    UCHAR Waiters;
    PQLOCKHOUSE LockHome;
    ULONG LockNumber = Everything[0];
    LONGLONG HoldTime;
    ULONG Clean;

    KiRDTSC(&Now);

    //
    // Make this routine work with either a lock number of lock address.
    //

    if (LockNumber > QLOCKS_NUMBER) {
        LockNumber = ((PKSPIN_LOCK_QUEUE)Everything[0]) -
                     KeGetCurrentPrcb()->LockQueue;
    }

    LockHome = &KiQueuedSpinLockHouse[LockNumber];

    //
    // Make up the key for this acquire/release pair.
    //

    ((PLARGE_INTEGER)&Key)->HighPart = LockHome->AcquirePoint;
    ((PLARGE_INTEGER)&Key)->LowPart  = Everything[1];

    //
    // Get the count of processors now waiting on this lock.
    //

    Waiters = KiQueuedLockDepth(&KeGetCurrentPrcb()->LockQueue[LockNumber]);
    if (Waiters > LockHome->MaxDepth) {
        LockHome->MaxDepth = Waiters;
    }

    //
    // Reset per acquire/release data.  This is data we don't want
    // lying around for the next pair if we happen to throw away this
    // particular data point.
    //

    Clean = LockHome->Clean;
    LockHome->Clean = 0;
    LockHome->AcquirePoint = 0;

    HoldTime = Now - LockHome->AcquireTime;
    if (HoldTime < 0) {

        //
        // This happens when KeSetSystemTime is called.  
        // Drop any negative results.
        //

        return;
    }

    //
    // Update global statistics.
    //

    LockHome->Count++;
    LockHome->NoWait += Clean;

    //
    // Search for a match in the log and add in the new data.
    //

    for (Entry = KiQueuedSpinLockLog[LockNumber]; TRUE; Entry++) {
        if (Entry->Key == 0) {

            //
            // We have reached the end of the list of valid
            // entries without finding a key match.   If there's
            // room, create a new entry.
            //

            if (LockHome->Pairs >= QLOCKS_MAX_LOG) {

                //
                // No room, just return.
                //

                return;
            }
            LockHome->Pairs++;
            Entry->Key = Key;
        }

        if (Entry->Key == Key) {

            //
            // Found a match (or created a new pair).  Update statistics
            // for this acquire/release pair.
            //

            Entry->Time += HoldTime;
            if (LockHome->WaitToAcquire) {
                Entry->WaitTime += (LockHome->AcquireTime - LockHome->WaitToAcquire);
            }
            Entry->Count++;
            Entry->Waiters += (Waiters != 0);
            Entry->Depth += Waiters;

            //
            // There should be one less waiter now than there was
            // before we acquired the lock.   If not, a new waiter
            // has joined the queue.  This is is condition we want
            // to know about as it indicates contention on this
            // lock.
            //
            
            if ((Waiters) && (Waiters >= LockHome->PreviousDepth)) {
                Entry->IncreasedDepth++;
            }
            LockHome->PreviousDepth = Waiters;
            Entry->Clean += Clean;
            break;
        }
    }
}

#endif

#ifdef _X86_
#pragma optimize("y", off)      // RtlCaptureContext needs EBP to be correct
#endif


VOID
__cdecl
KeSaveStateForHibernate(
    IN PKPROCESSOR_STATE ProcessorState
    )
/*++

Routine Description:

    Saves all processor-specific state that must be preserved
    across an S4 state (hibernation).

    N.B. #pragma surrounding this function is required in order
         to create the frame pointer than RtlCaptureContext relies
         on.
    N.B. _CRTAPI1 (__cdecl) decoration is also required so that
         RtlCaptureContext can compute the correct ESP.

Arguments:

    ProcessorState - Supplies the KPROCESSOR_STATE where the
        current CPU's state is to be saved.

Return Value:

    None.

--*/

{
    RtlCaptureContext(&ProcessorState->ContextFrame);
    KiSaveProcessorControlState(ProcessorState);
}
#ifdef _X86_
#pragma optimize("", on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\mtrr.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mtrr.h

Abstract:

    This module contains the i386 specific mtrr register 
    hardware definitions.

Author:

    Ken Reneris (kenr)  11-Oct-95

Environment:

    Kernel mode only.

Revision History:

--*/

//
// MTRR MSR architecture definitions
//

#define MTRR_MSR_CAPABILITIES       0x0fe
#define MTRR_MSR_DEFAULT            0x2ff
#define MTRR_MSR_VARIABLE_BASE      0x200
#define MTRR_MSR_VARIABLE_MASK     (MTRR_MSR_VARIABLE_BASE+1)

#define MTRR_PAGE_SIZE              4096
#define MTRR_PAGE_MASK              (~(MTRR_PAGE_SIZE-1))

//
// Memory range types
//

#define MTRR_TYPE_UC            0
#define MTRR_TYPE_USWC          1
#define MTRR_TYPE_WT            4
#define MTRR_TYPE_WP            5
#define MTRR_TYPE_WB            6
#define MTRR_TYPE_MAX           7

//
// MTRR specific registers - capability register, default
// register, and variable mask and base register
//

#include "pshpack1.h"

typedef struct _MTRR_CAPABILITIES {
    union {
        struct {
            ULONG   VarCnt:8;
            ULONG   FixSupported:1;
            ULONG   Reserved_0:1;
            ULONG   UswcSupported:1;
            ULONG   Reserved_1:21;
            ULONG   Reserved_2;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_CAPABILITIES, *PMTRR_CAPABILITIES;

typedef struct _MTRR_DEFAULT {
    union {
        struct {
            ULONG   Type:8;
            ULONG   Reserved_0:2;
            ULONG   FixedEnabled:1;
            ULONG   MtrrEnabled:1;
            ULONG   Reserved_1:20;
            ULONG   Reserved_2;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_DEFAULT, *PMTRR_DEFAULT;

typedef struct _MTRR_VARIABLE_BASE {
    union {
        struct {
            ULONG       Type:8;
            ULONG       Reserved_0:4;
            ULONG       PhysBase_1:20;
            ULONG       PhysBase_2:4;
            ULONG       Reserved_1:28;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_VARIABLE_BASE, *PMTRR_VARIABLE_BASE;

#define MTRR_MASK_BASE  0x0000000ffffff000

typedef struct _MTRR_VARIABLE_MASK {
    union {
        struct {
            ULONG      Reserved_0:11;
            ULONG      Valid:1;
            ULONG      PhysMask_1:20;
            ULONG      PhysMask_2:4;
            ULONG      Reserved_1:28;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} MTRR_VARIABLE_MASK, *PMTRR_VARIABLE_MASK;

#define MTRR_MASK_MASK  0x0000000ffffff000

//
// Masks/constants to check for non-contiguous masks,
// mask out reserved bits of variable MTRR's, 
// and construct MTRR variable register masks 
//

#define MASK_OVERFLOW_MASK  (~0x1000000000)
#define MTRR_RESVBIT_MASK   0xfffffffff
#define MTRR_MAX_RANGE_SHIFT    36

#include "poppack.h"

typedef struct _PROCESSOR_LOCKSTEP {
    ULONG               Processor;
    volatile ULONG      TargetCount;
    volatile ULONG      *TargetPhase;
} PROCESSOR_LOCKSTEP, *PPROCESSOR_LOCKSTEP;

VOID
KiLockStepExecution(
    IN PPROCESSOR_LOCKSTEP Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\mtrr.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    mtrr.c

Abstract:

    This module implements interfaces that support manipulation of
    memory type range registers.

    These entry points only exist on x86 machines.

Author:

    Ken Reneris (kenr)  11-Oct-95

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#include "mtrr.h"

#define STATIC

#define IDBG    0

#if DBG
#define DBGMSG(a)   DbgPrint(a)
#else
#define DBGMSG(a)
#endif

//
// Internal declarations
//

//
// Range in generic terms
//

typedef struct _ONE_RANGE {
    ULONGLONG           Base;
    ULONGLONG           Limit;
    UCHAR               Type;
} ONE_RANGE, *PONE_RANGE;

#define GROW_RANGE_TABLE    4

//
// Range in specific mtrr terms
//

typedef struct _MTRR_RANGE {
    MTRR_VARIABLE_BASE  Base;
    MTRR_VARIABLE_MASK  Mask;
} MTRR_RANGE, *PMTRR_RANGE;

//
// System static information concerning cached range types
//

typedef struct _RANGE_INFO {

    //
    // Global MTRR info
    //

    MTRR_DEFAULT        Default;            // h/w mtrr default
    MTRR_CAPABILITIES   Capabilities;       // h/w mtrr Capabilities
    UCHAR               DefaultCachedType;  // default type for MmCached

    //
    // Variable MTRR information
    //

    BOOLEAN             RangesValid;        // Ranges initialized and valid.
    BOOLEAN             MtrrWorkaround;     // Work Around needed/not.
    UCHAR               NoRange;            // No ranges currently in Ranges
    UCHAR               MaxRange;           // Max size of Ranges
    PONE_RANGE          Ranges;             // Current ranges as set into h/w

} RANGE_INFO, *PRANGE_INFO;


//
// Structure used while processing range database
//

typedef struct _NEW_RANGE {
    //
    // Current Status
    //

    NTSTATUS            Status;

    //
    // Generic info on new range
    //

    ULONGLONG           Base;
    ULONGLONG           Limit;
    UCHAR               Type;

    //
    // MTRR image to be set into h/w
    //

    PMTRR_RANGE         MTRR;

    //
    // RangeDatabase before edits were started
    //

    UCHAR               NoRange;
    PONE_RANGE          Ranges;

    //
    // IPI context to coordinate concurrent processor update
    //

    ULONG               NoMTRR;

    PROCESSOR_LOCKSTEP  Synchronize;
    ULONG               Processor;
} NEW_RANGE, *PNEW_RANGE;

//
// Prototypes
//

VOID
KiInitializeMTRR (
    IN BOOLEAN LastProcessor
    );

BOOLEAN
KiRemoveRange (
    IN PNEW_RANGE   NewRange,
    IN ULONGLONG    Base,
    IN ULONGLONG    Limit,
    IN PBOOLEAN     RemoveThisType
    );

VOID
KiAddRange (
    IN PNEW_RANGE   NewRange,
    IN ULONGLONG    Base,
    IN ULONGLONG    Limit,
    IN UCHAR        Type
    );

VOID
KiStartEffectiveRangeChange (
    IN PNEW_RANGE   NewRange
    );

VOID
KiCompleteEffectiveRangeChange (
    IN PNEW_RANGE   NewRange
    );

STATIC ULONG
KiRangeWeight (
    IN PONE_RANGE   Range
    );

STATIC ULONG
KiFindFirstSetLeftBit (
    IN ULONGLONG    Set
    );

STATIC ULONG
KiFindFirstSetRightBit (
    IN ULONGLONG    Set
    );

VOID
KiLoadMTRRTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID Context,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

NTSTATUS
KiLoadMTRR (
    IN PNEW_RANGE Context
    );

ULONGLONG
KiMaskToLength (
    IN ULONGLONG    Mask
    );

ULONGLONG
KiLengthToMask (
    IN ULONGLONG    Length
    );

#if IDBG
VOID
KiDumpMTRR (
    PUCHAR      DebugString,
    PMTRR_RANGE MTRR
    );
#endif

//
// --- AMD - Prototypes for AMD K6 MTRR Support functions. ---
//

NTSTATUS
KiAmdK6MtrrSetMemoryType (
    IN ULONG BaseAddress,
    IN ULONG NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    );

VOID
KiAmdK6MtrrWRMSR (
    VOID
    );

// --- AMD - End ---

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,KiInitializeMTRR)
#pragma alloc_text(PAGELK,KiRemoveRange)
#pragma alloc_text(PAGELK,KiAddRange)
#pragma alloc_text(PAGELK,KiStartEffectiveRangeChange)
#pragma alloc_text(PAGELK,KiCompleteEffectiveRangeChange)
#pragma alloc_text(PAGELK,KiRangeWeight)
#pragma alloc_text(PAGELK,KiFindFirstSetLeftBit)
#pragma alloc_text(PAGELK,KiFindFirstSetRightBit)
#pragma alloc_text(PAGELK,KiLoadMTRR)
#pragma alloc_text(PAGELK,KiLoadMTRRTarget)
#pragma alloc_text(PAGELK,KiLockStepExecution)
#pragma alloc_text(PAGELK,KiLengthToMask)
#pragma alloc_text(PAGELK,KiMaskToLength)

#if IDBG
#pragma alloc_text(PAGELK,KiDumpMTRR)
#endif

#endif

//
// KiRangeLock - Used to synchronize accesses to KiRangeInfo
//

KSPIN_LOCK          KiRangeLock;

//
// KiRangeInfo - Range type mapping information.  Details specific h/w support
//               and contains the current range database of how physical
//               addresses have been set

RANGE_INFO          KiRangeInfo;

VOID
KiInitializeMTRR (
    IN BOOLEAN LastProcessor
    )
/*++

Routine Description:

    Called to incrementally initialize the physical range
    database feature.   First processor's MTRR set is read into the
    physical range database.

Arguments:

    LastProcessor - If set this is the last processor to execute this routine
    such that when this processor finishes, the initialization is complete.

Return Value:

    None - if there was a problem the function
    KeSetPhysicalCacheTypeRange type is disabled.

--*/
{
    BOOLEAN             Status;
    ULONG               Index, Size;
    MTRR_DEFAULT        Default;
    MTRR_CAPABILITIES   Capabilities;
    NEW_RANGE           NewRange;
    MTRR_VARIABLE_BASE  MtrrBase;
    MTRR_VARIABLE_MASK  MtrrMask;
    ULONGLONG           Base, Mask, Length;
    BOOLEAN             RemoveThisType[MTRR_TYPE_MAX];
    NTSTATUS            NtStatus;
    PKPRCB              Prcb;

    Status = TRUE;
    RtlZeroMemory (&NewRange, sizeof (NewRange));
    NewRange.Status = STATUS_UNSUCCESSFUL;

    //
    // If this is the first processor, initialize some fields
    //

    if (KeGetPcr()->Number == 0) {
        KeInitializeSpinLock (&KiRangeLock);

        KiRangeInfo.Capabilities.u.QuadPart = RDMSR(MTRR_MSR_CAPABILITIES);
        KiRangeInfo.Default.u.QuadPart = RDMSR(MTRR_MSR_DEFAULT);
        KiRangeInfo.DefaultCachedType = MTRR_TYPE_MAX;

        //
        // If h/w mtrr support is not enabled, disable OS support
        //

        if (!KiRangeInfo.Default.u.hw.MtrrEnabled ||
            KiRangeInfo.Capabilities.u.hw.VarCnt == 0 ||
            KiRangeInfo.Default.u.hw.Type != MTRR_TYPE_UC) {

            DBGMSG("MTRR feature disabled.\n");
            Status = FALSE;

        } else {

            //
            // If USWC type is supported by hardware, but the MTRR
            // feature is not set in KeFeatureBits, it is because
            // the HAL indicated USWC should not be used on this
            // machine.  (Possibly due to shared memory clusters).
            //

            if (KiRangeInfo.Capabilities.u.hw.UswcSupported &&
                ((KeFeatureBits & KF_MTRR) == 0)) {

                DBGMSG("KiInitializeMTRR: MTRR use globally disabled on this machine.\n");
                KiRangeInfo.Capabilities.u.hw.UswcSupported = 0;
            }

            //
            // Allocate initial range type database
            //

            KiRangeInfo.NoRange = 0;
            KiRangeInfo.MaxRange = (UCHAR) KiRangeInfo.Capabilities.u.hw.VarCnt + GROW_RANGE_TABLE;

            //
            // Don't allocate a new range on reinitialization from
            // hibernate.
            //

            if (KiRangeInfo.Ranges == NULL) {
                KiRangeInfo.Ranges = ExAllocatePoolWithTag (NonPagedPool,
                                        sizeof(ONE_RANGE) * KiRangeInfo.MaxRange,
                                        '  eK');
            }
            if (KiRangeInfo.Ranges != NULL) {
                RtlZeroMemory (KiRangeInfo.Ranges,
                               sizeof(ONE_RANGE) * KiRangeInfo.MaxRange);
            }
        }
    }

    //
    // Workaround for cpu signatures 611, 612, 616 and 617
    // - if the request for setting a variable MTRR specifies
    // an address which is not 4M aligned or length is not
    // a multiple of 4M then possible problem for INVLPG inst.
    // Detect if workaround is required
    //

    Prcb = KeGetCurrentPrcb();
    if (Prcb->CpuType == 6  &&
        (Prcb->CpuStep == 0x0101 || Prcb->CpuStep == 0x0102 ||
         Prcb->CpuStep == 0x0106 || Prcb->CpuStep == 0x0107 )) {

        if (strcmp(Prcb->VendorString, "GenuineIntel") == 0) {

            //
            // Only do this if it's an Intel part, other
            // manufacturers may have the same stepping
            // numbers but no bug.
            //

            KiRangeInfo.MtrrWorkaround = TRUE;
        }
    }

    //
    // If MTRR support disabled on first processor or if
    // buffer not allocated then fall through
    //

    if (!KiRangeInfo.Ranges){
        Status = FALSE;
    } else {

        //
        // Verify MTRR support is symmetric
        //

        Capabilities.u.QuadPart = RDMSR(MTRR_MSR_CAPABILITIES);

        if ((Capabilities.u.hw.UswcSupported) &&
            ((KeFeatureBits & KF_MTRR) == 0)) {
            DBGMSG ("KiInitializeMTRR: setting UswcSupported FALSE\n");
            Capabilities.u.hw.UswcSupported = 0;
        }

        Default.u.QuadPart = RDMSR(MTRR_MSR_DEFAULT);

        if (Default.u.QuadPart != KiRangeInfo.Default.u.QuadPart ||
            Capabilities.u.QuadPart != KiRangeInfo.Capabilities.u.QuadPart) {
            DBGMSG ("KiInitializeMTRR: asymmetric mtrr support\n");
            Status = FALSE;
        }
    }

    NewRange.Status = STATUS_SUCCESS;

    //
    // MTRR registers should be identically set on each processor.
    // Ranges should be added to the range database only for one
    // processor.
    //

    if (Status && (KeGetPcr()->Number == 0)) {
#if IDBG
        KiDumpMTRR ("Processor MTRR:", NULL);
#endif

        //
        // Read current MTRR settings for various cached range types
        // and add them to the range database
        //

        for (Index=0; Index < Capabilities.u.hw.VarCnt; Index++) {

            MtrrBase.u.QuadPart = RDMSR(MTRR_MSR_VARIABLE_BASE+Index*2);
            MtrrMask.u.QuadPart = RDMSR(MTRR_MSR_VARIABLE_MASK+Index*2);

            Mask = MtrrMask.u.QuadPart & MTRR_MASK_MASK;
            Base = MtrrBase.u.QuadPart & MTRR_MASK_BASE;

            //
            // Note - the variable MTRR Mask does NOT contain the length
            // spanned by the variable MTRR. Thus just checking the Valid
            // Bit should be sufficient for identifying a valid MTRR.
            //

            if (MtrrMask.u.hw.Valid) {

                Length = KiMaskToLength(Mask);

                //
                // Check for non-contiguous MTRR mask.
                //

                if ((Mask + Length) & MASK_OVERFLOW_MASK) {
                    DBGMSG ("KiInitializeMTRR: Found non-contiguous MTRR mask!\n");
                    Status = FALSE;
                }

                //
                // Add this MTRR to the range database
                //

                Base &= Mask;
                KiAddRange (
                    &NewRange,
                    Base,
                    Base + Length - 1,
                    (UCHAR) MtrrBase.u.hw.Type
                    );

                //
                // Check for default cache type
                //

                if (MtrrBase.u.hw.Type == MTRR_TYPE_WB) {
                    KiRangeInfo.DefaultCachedType = MTRR_TYPE_WB;
                }

                if (KiRangeInfo.DefaultCachedType == MTRR_TYPE_MAX  &&
                    MtrrBase.u.hw.Type == MTRR_TYPE_WT) {
                    KiRangeInfo.DefaultCachedType = MTRR_TYPE_WT;
                }
            }
        }

        //
        // If a default type for "cached" was not found, assume write-back
        //

        if (KiRangeInfo.DefaultCachedType == MTRR_TYPE_MAX) {
            DBGMSG ("KiInitializeMTRR: assume write-back\n");
            KiRangeInfo.DefaultCachedType = MTRR_TYPE_WB;
        }
    }

    //
    // Done
    //

    if (!NT_SUCCESS(NewRange.Status)) {
        Status = FALSE;
    }

    if (!Status) {
        DBGMSG ("KiInitializeMTRR: OS support for MTRRs disabled\n");
        if (KiRangeInfo.Ranges != NULL) {
            ExFreePool (KiRangeInfo.Ranges);
            KiRangeInfo.Ranges = NULL;
        }
    } else {

        // if last processor indicate initialization complete
        if (LastProcessor) {
            KiRangeInfo.RangesValid = TRUE;
        }
    }
}

VOID
KeRestoreMtrr (
    VOID
    )
/*++

Routine Description:

    This function reloads the MTRR registers to be the current
    known values.   This is used on a system wakeup to ensure the
    registers are sane.

    N.B. The caller must have the PAGELK code locked

Arguments:

    none

Return Value:

    none

--*/
{
    NEW_RANGE           NewRange;
    KIRQL               OldIrql;

    if (KiRangeInfo.RangesValid) {
        RtlZeroMemory (&NewRange, sizeof (NewRange));
        KeAcquireSpinLock (&KiRangeLock, &OldIrql);
        KiStartEffectiveRangeChange (&NewRange);
        ASSERT (NT_SUCCESS(NewRange.Status));
        KiCompleteEffectiveRangeChange (&NewRange);
        KeReleaseSpinLock (&KiRangeLock, OldIrql);
        return;
    }

    //
    // If the processor is a AMD K6 with MTRR support then perform
    // processor specific implentaiton.
    //

    if (KeFeatureBits & KF_AMDK6MTRR) {
        KeAcquireSpinLock (&KiRangeLock, &OldIrql);
        KiLoadMTRR(NULL);
        KeReleaseSpinLock (&KiRangeLock, OldIrql);
    }
}


NTSTATUS
KeSetPhysicalCacheTypeRange (
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberOfBytes,
    IN MEMORY_CACHING_TYPE CacheType
    )
/*++

Routine Description:

    This function sets a physical range to a particular cache type.
    If the system does not support setting cache policies based on
    physical ranges, no action is taken.

Arguments:

    PhysicalAddress - The starting address of the range being set

    NumberOfBytes   - The length, in bytes, of the range being set

    CacheType       - The caching type for which the physical range is
                      to be set to.

                     NonCached:
                        Setting ranges to be NonCached is done for
                        book keeping reasons.  A return of SUCCESS when
                        setting a range NonCached does not mean it has
                        been physically set to as NonCached.  The caller
                        must use a cache-disabled virtual pointer for
                        any NonCached range.

                     Cached:
                        A successful return indicates that the physical
                        range has been set to cached.   This mode requires
                        the caller to be at irql < dispatch_level.

                     FrameBuffer:
                        A successful return indicates that the physical
                        range has been set to be framebuffer cached.
                        This mode requires the caller to be at irql <
                        dispatch_level.

                     USWCCached:
                        This type is to be satisfied only via PAT and
                        fails for the MTRR interface.

Return Value:

    STATUS_SUCCESS - if success, the cache attributes of the physical range
                     have been set.

    STATUS_NOT_SUPPORTED - either feature not supported or not yet initialized,
                           or MmWriteCombined type not supported and is
                           requested, or input range does not match restrictions
                           imposed by workarounds for current processor stepping
                           or is below 1M (in the fixed MTRR range), or not yet
                           initialized.

    STATUS_UNSUCCESSFUL - Unable to satisfy request due to
                        - Unable to map software image into limited # of
                          hardware MTRRs.
                        - irql was not < DISPATCH_LEVEL.
                        - Failure due to other internal error (out of memory).

  STATUS_INVALID_PARAMETER - Incorrect input memory type.

--*/
{
    KIRQL               OldIrql;
    NEW_RANGE           NewRange;
    BOOLEAN             RemoveThisType[MTRR_TYPE_MAX];
    BOOLEAN             EffectRangeChange, AddToRangeDatabase;

    //
    // If caller has requested the MmUSWCCached memory type then fail
    // - MmUSWCCached is supported via PAT and not otherwise
    //

    if (CacheType == MmUSWCCached) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Addresses above 4GB, below 1MB or not page aligned and
    // page length are not supported.
    //

    if ((PhysicalAddress.HighPart != 0)               ||
        (PhysicalAddress.LowPart < (1 * 1024 * 1024)) ||
        (PhysicalAddress.LowPart & 0xfff)             ||
        (NumberOfBytes & 0xfff)                          ) {
        return STATUS_NOT_SUPPORTED;
    }

    ASSERT (NumberOfBytes != 0);

    //
    // If the processor is a AMD K6 with MTRR support then perform
    // processor specific implentaiton.
    //

    if (KeFeatureBits & KF_AMDK6MTRR) {

        if ((CacheType != MmWriteCombined) && (CacheType != MmNonCached)) {
            return STATUS_NOT_SUPPORTED;
        }

        return KiAmdK6MtrrSetMemoryType(PhysicalAddress.LowPart,
                                        NumberOfBytes,
                                        CacheType);
    }

    //
    // If processor doesn't have the memory type range feature
    // return not supported.
    //

    if (!KiRangeInfo.RangesValid) {
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Workaround for cpu signatures 611, 612, 616 and 617
    // - if the request for setting a variable MTRR specifies
    // an address which is not 4M aligned or length is not
    // a multiple of 4M then return status not supported
    //

    if ((KiRangeInfo.MtrrWorkaround) &&
        ((PhysicalAddress.LowPart & 0x3fffff) ||
         (NumberOfBytes & 0x3fffff))) {

            return STATUS_NOT_SUPPORTED;
    }

    RtlZeroMemory (&NewRange, sizeof (NewRange));
    NewRange.Base  = PhysicalAddress.QuadPart;
    NewRange.Limit = NewRange.Base + NumberOfBytes - 1;

    //
    // Determine what the new mtrr range type is.   If setting NonCached then
    // the database need not be updated to reflect the virtual change.  This
    // is because non-cached virtual pointers are mapped as cache disabled.
    //

    EffectRangeChange = TRUE;
    AddToRangeDatabase = TRUE;
    switch (CacheType) {
        case MmNonCached:
            NewRange.Type = MTRR_TYPE_UC;

            //
            // NonCached ranges do not need to be reflected into the h/w state
            // as all non-cached ranges are mapped with cache-disabled pointers.
            // This also means that cache-disabled ranges do not need to
            // be put into mtrrs, or held in the range, regardless of the default
            // range type.
            //

            EffectRangeChange = FALSE;
            AddToRangeDatabase = FALSE;
            break;

        case MmCached:
            NewRange.Type = KiRangeInfo.DefaultCachedType;
            break;

        case MmWriteCombined:
            NewRange.Type = MTRR_TYPE_USWC;

            //
            // If USWC type isn't supported, then request can not be honored
            //

            if (!KiRangeInfo.Capabilities.u.hw.UswcSupported) {
                DBGMSG ("KeSetPhysicalCacheTypeRange: USWC not supported\n");
                return STATUS_NOT_SUPPORTED;
            }
            break;

        default:
            DBGMSG ("KeSetPhysicalCacheTypeRange: no such cache type\n");
            return STATUS_INVALID_PARAMETER;
            break;
    }

    NewRange.Status = STATUS_SUCCESS;

    //
    // The default type is UC thus the range is still mapped using
    // a Cache Disabled VirtualPointer and hence it need not be added.
    //

    //
    // If h/w needs updated, lock down the code required to effect the change
    //

    if (EffectRangeChange) {
        if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {

            //
            // Code can not be locked down.   Supplying a new range type requires
            // that the caller calls at irql < dispatch_level.
            //

            DBGMSG ("KeSetPhysicalCacheTypeRange failed due to calling IRQL == DISPATCH_LEVEL\n");
            return STATUS_UNSUCCESSFUL;
        }

        MmLockPagableSectionByHandle(ExPageLockHandle);
    }

    //
    // Serialize the range type database
    //

    KeAcquireSpinLock (&KiRangeLock, &OldIrql);

    //
    // If h/w is going to need updated, then start an effective range change
    //

    if (EffectRangeChange) {
        KiStartEffectiveRangeChange (&NewRange);
    }

    if (NT_SUCCESS (NewRange.Status)) {

        //
        // If the new range is NonCached, then don't remove standard memory
        // caching types
        //

        memset (RemoveThisType, TRUE, MTRR_TYPE_MAX);
        if (NewRange.Type != MTRR_TYPE_UC) {
            //
            // If the requested type is uncached then the physical
            // memory region is mapped using a cache disabled virtual pointer.
            // The effective memory type for that region will be the lowest
            // common denominator of the MTRR type and the cache type in the
            // PTE.  Therefore for a request of type UC, the effective type
            // will be UC irrespective of the MTRR settings in that range.
            // Hence it is not necessary to remove the existing MTRR settings
            // (if any) for that range.
            //

            //
            // Clip/remove any ranges in the target area
            //

            KiRemoveRange (&NewRange, NewRange.Base, NewRange.Limit, RemoveThisType);
        }

        //
        // If needed, add new range type
        //

        if (AddToRangeDatabase) {
            ASSERT (EffectRangeChange == TRUE);
            KiAddRange (&NewRange, NewRange.Base, NewRange.Limit, NewRange.Type);
        }

        //
        // If this is an effect range change, then complete it
        //

        if (EffectRangeChange) {
            KiCompleteEffectiveRangeChange (&NewRange);
        }
    }

    KeReleaseSpinLock (&KiRangeLock, OldIrql);
    if (EffectRangeChange) {
        MmUnlockPagableImageSection(ExPageLockHandle);
    }

    return NewRange.Status;
}

BOOLEAN
KiRemoveRange (
    IN PNEW_RANGE   NewRange,
    IN ULONGLONG    Base,
    IN ULONGLONG    Limit,
    IN PBOOLEAN     RemoveThisType
    )
/*++

Routine Description:

    This function removes any range overlapping with the passed range, of
    type supplied in RemoveThisType from the global range database.

Arguments:

    NewRange        - Context information

    Base            - Base & Limit signify the first & last address of a range
    Limit           - which is to be removed from the range database

    RemoveThisType  - A TRUE flag for each type which can not overlap the
                      target range


Return Value:

    TRUE  - if the range database was altered such that it may no longer
            be sorted.

--*/
{
    ULONG       i;
    PONE_RANGE  Range;
    BOOLEAN     DatabaseNeedsSorted;


    DatabaseNeedsSorted = FALSE;

    //
    // Check each range
    //

    for (i=0, Range=KiRangeInfo.Ranges; i < KiRangeInfo.NoRange; i++, Range++) {

        //
        // If this range type doesn't need to be altered, skip it
        //

        if (!RemoveThisType[Range->Type]) {
            continue;
        }

        //
        // Check range to see if it overlaps with range being removed
        //

        if (Range->Base < Base) {

            if (Range->Limit >= Base  &&  Range->Limit <= Limit) {

                //
                // Truncate range to not overlap with area being removed
                //

                Range->Limit = Base - 1;
            }

            if (Range->Limit > Limit) {

                //
                // Target area is contained totally within this area.
                // Split into two ranges
                //

                //
                // Add range at end
                //

                DatabaseNeedsSorted = TRUE;
                KiAddRange (
                    NewRange,
                    Limit+1,
                    Range->Limit,
                    Range->Type
                    );

                //
                // Turn current range into range at beginning
                //

                Range->Limit = Base - 1;
            }

        } else {

            // Range->Base >= Base

            if (Range->Base <= Limit) {
                if (Range->Limit <= Limit) {
                    //
                    // This range is totally within the target area.  Remove it.
                    //

                    DatabaseNeedsSorted = TRUE;
                    KiRangeInfo.NoRange -= 1;
                    Range->Base  = KiRangeInfo.Ranges[KiRangeInfo.NoRange].Base;
                    Range->Limit = KiRangeInfo.Ranges[KiRangeInfo.NoRange].Limit;
                    Range->Type = KiRangeInfo.Ranges[KiRangeInfo.NoRange].Type;

                    //
                    // recheck at current location
                    //

                    i -= 1;
                    Range -= 1;

                } else {

                    //
                    // Bump beginning past area being removed
                    //

                    Range->Base = Limit + 1;
                }
            }
        }
    }

    if (!NT_SUCCESS (NewRange->Status)) {
        DBGMSG ("KiRemoveRange: failure\n");
    }

    return DatabaseNeedsSorted;
}


VOID
KiAddRange (
    IN PNEW_RANGE   NewRange,
    IN ULONGLONG    Base,
    IN ULONGLONG    Limit,
    IN UCHAR        Type
    )
/*++

Routine Description:

    This function adds the passed range to the global range database.

Arguments:

    NewRange        - Context information

    Base            - Base & Limit signify the first & last address of a range
    Limit           - which is to be added to the range database

    Type            - Type of caching required for this range

Return Value:

    None - Context is updated with an error if the table has overflowed

--*/
{
    PONE_RANGE      Range, OldRange;
    ULONG           size;

    if (KiRangeInfo.NoRange >= KiRangeInfo.MaxRange) {

        //
        // Table is out of space, get a bigger one
        //

        OldRange = KiRangeInfo.Ranges;
        size = sizeof(ONE_RANGE) * (KiRangeInfo.MaxRange + GROW_RANGE_TABLE);
        Range  = ExAllocatePoolWithTag (NonPagedPool, size, '  eK');

        if (!Range) {
            NewRange->Status = STATUS_UNSUCCESSFUL;
            return ;
        }

        //
        // Grow table
        //

        RtlZeroMemory (Range, size);
        RtlCopyMemory (Range, OldRange, sizeof(ONE_RANGE) * KiRangeInfo.MaxRange);
        KiRangeInfo.Ranges = Range;
        KiRangeInfo.MaxRange += GROW_RANGE_TABLE;
        ExFreePool (OldRange);
    }

    //
    // Add new entry to table
    //

    KiRangeInfo.Ranges[KiRangeInfo.NoRange].Base = Base;
    KiRangeInfo.Ranges[KiRangeInfo.NoRange].Limit = Limit;
    KiRangeInfo.Ranges[KiRangeInfo.NoRange].Type = Type;
    KiRangeInfo.NoRange += 1;
}


VOID
KiStartEffectiveRangeChange (
    IN PNEW_RANGE   NewRange
    )
/*++

Routine Description:

    This functions sets up the context information required to
    track & later effect a range change in hardware

Arguments:

    NewRange        - Context information

Return Value:

    None

--*/
{
    ULONG   size;

    //
    // Allocate working space for MTRR image
    //

    size = sizeof(MTRR_RANGE) * ((ULONG) KiRangeInfo.Capabilities.u.hw.VarCnt + 1);
    NewRange->MTRR = ExAllocatePoolWithTag (NonPagedPool, size, '  eK');
    if (!NewRange->MTRR) {
        NewRange->Status = STATUS_UNSUCCESSFUL;
        return ;
    }

    RtlZeroMemory (NewRange->MTRR, size);

    //
    // Save current range information in case of an error
    //

    size = sizeof(ONE_RANGE) * KiRangeInfo.NoRange;
    NewRange->NoRange = KiRangeInfo.NoRange;
    NewRange->Ranges = ExAllocatePoolWithTag (NonPagedPool, size, '  eK');
    if (!NewRange->Ranges) {
        NewRange->Status = STATUS_UNSUCCESSFUL;
        return ;
    }

    RtlCopyMemory (NewRange->Ranges, KiRangeInfo.Ranges, size);
}


VOID
KiCompleteEffectiveRangeChange (
    IN PNEW_RANGE   NewRange
    )
/*++

Routine Description:

    This functions commits the range database to hardware, or backs
    out the current changes to it.

Arguments:

    NewRange        - Context information

Return Value:

    None

--*/
{
    BOOLEAN         Restart;
    ULONG           Index, Index2, RemIndex2, NoMTRR;
    ULONGLONG       BestLength, WhichMtrr;
    ULONGLONG       CurrLength;
    ULONGLONG       l, Base, Length, MLength;
    PONE_RANGE      Range;
    ONE_RANGE       OneRange;
    PMTRR_RANGE     MTRR;
    BOOLEAN         RoundDown;
    BOOLEAN         RemoveThisType[MTRR_TYPE_MAX];
    PKPRCB          Prcb;
    KIRQL           OldIrql, OldIrql2;
    KAFFINITY       TargetProcessors;


    ASSERT (KeGetCurrentIrql() == DISPATCH_LEVEL);
    Prcb = KeGetCurrentPrcb();

    //
    // Round all ranges, according to type, to match what h/w can support
    //

    for (Index=0; Index < KiRangeInfo.NoRange; Index++) {
        Range = &KiRangeInfo.Ranges[Index];

        //
        // Determine rounding for this range type
        //

        RoundDown = TRUE;
        if (Range->Type == MTRR_TYPE_UC) {
            RoundDown = FALSE;
        }

        //
        // Apply rounding
        //

        if (RoundDown) {
            Range->Base  = (Range->Base  + MTRR_PAGE_SIZE - 1) & MTRR_PAGE_MASK;
            Range->Limit = ((Range->Limit+1) & MTRR_PAGE_MASK)-1;
        } else {
            Range->Base  = (Range->Base  & MTRR_PAGE_MASK);
            Range->Limit = ((Range->Limit + MTRR_PAGE_SIZE) & MTRR_PAGE_MASK)-1;
        }
    }

    do {
        Restart = FALSE;

        //
        // Sort the ranges by base address
        //

        for (Index=0; Index < KiRangeInfo.NoRange; Index++) {
            Range = &KiRangeInfo.Ranges[Index];

            for (Index2=Index+1; Index2 < KiRangeInfo.NoRange; Index2++) {

                if (KiRangeInfo.Ranges[Index2].Base < Range->Base) {

                    //
                    // Swap KiRangeInfo.Ranges[Index] with KiRangeInfo.Ranges[Index2]
                    //

                    OneRange = *Range;
                    *Range = KiRangeInfo.Ranges[Index2];
                    KiRangeInfo.Ranges[Index2] = OneRange;
                }
            }
        }

        //
        // At this point the range database is sorted on
        // base address. Scan range database combining adjacent and
        // overlapping ranges of the same type
        //

        for (Index=0; Index < (ULONG) KiRangeInfo.NoRange-1; Index++) {
            Range = &KiRangeInfo.Ranges[Index];

            //
            // Scan the range database. If ranges are adjacent/overlap and are of
            // the same type, combine them.
            //

            for (Index2 = Index+1; Index2 < (ULONG) KiRangeInfo.NoRange; Index2++) {

                l = Range[0].Limit + 1;
                if (l < Range[0].Limit) {
                    l = Range[0].Limit;
                }

                if (l >= KiRangeInfo.Ranges[Index2].Base  &&
                    Range[0].Type == KiRangeInfo.Ranges[Index2].Type) {

                    //
                    // Increase Range[0] limit to cover Range[Index2]
                    //

                    if (KiRangeInfo.Ranges[Index2].Limit > Range[0].Limit) {
                        Range[0].Limit = KiRangeInfo.Ranges[Index2].Limit;
                    }

                    //
                    // Remove KiRangeInfo.Ranges[Index2]
                    //

                    if (Index2 < (ULONG) KiRangeInfo.NoRange - 1 ) {

                        //
                        // Copy everything from Index2 till end
                        // of range list. # Entries to copy is
                        // (KiRangeInfo.NoRange -1) - (Index2+1) + 1
                        //

                        RtlCopyMemory(
                            &(KiRangeInfo.Ranges[Index2]),
                            &(KiRangeInfo.Ranges[Index2+1]),
                            sizeof(ONE_RANGE) * (KiRangeInfo.NoRange-Index2-1)
                            );
                    }

                    KiRangeInfo.NoRange -= 1;

                    //
                    // Recheck current location
                    //

                    Index2 -= 1;
                }
            }
        }

        //
        // At this point the range database is sorted on base
        // address and adjacent/overlapping ranges of the same
        // type are combined. Check for overlapping ranges -
        // If legal then allow else truncate the less "weighty" range
        //

        for (Index = 0; Index < (ULONG) KiRangeInfo.NoRange-1  &&  !Restart; Index++) {

            Range = &KiRangeInfo.Ranges[Index];

            l = Range[0].Limit + 1;
            if (l < Range[0].Limit) {
                l = Range[0].Limit;
            }

            //
            // If ranges overlap and are not of same type, and if the
            // overlap is not legal then carve them to the best cache type
            // available.
            //

            for (Index2 = Index+1; Index2 < (ULONG) KiRangeInfo.NoRange && !Restart; Index2++) {

                if (l > KiRangeInfo.Ranges[Index2].Base) {

                    if (Range[0].Type == MTRR_TYPE_UC ||
                        KiRangeInfo.Ranges[Index2].Type == MTRR_TYPE_UC) {

                        //
                        // Overlap of a UC type with a range of any other type is
                        // legal
                        //

                    } else if ((Range[0].Type == MTRR_TYPE_WT &&
                                KiRangeInfo.Ranges[Index2].Type == MTRR_TYPE_WB) ||
                               (Range[0].Type == MTRR_TYPE_WB &&
                                KiRangeInfo.Ranges[Index2].Type == MTRR_TYPE_WT) ) {
                        //
                        // Overlap of WT and WB range is legal. The overlap range will
                        // be WT.
                        //

                    } else {

                        //
                        // This is an illegal overlap and we need to carve the ranges
                        // to remove the overlap.
                        //
                        // Pick range which has the cache type which should be used for
                        // the overlapped area
                        //

                        if (KiRangeWeight(&Range[0]) > KiRangeWeight(&(KiRangeInfo.Ranges[Index2]))){
                            RemIndex2 = Index2;
                        } else {
                            RemIndex2 = Index;
                        }

                        //
                        // Remove ranges of type which do not belong in the overlapped area
                        //

                        RtlZeroMemory (RemoveThisType, MTRR_TYPE_MAX);
                        RemoveThisType[KiRangeInfo.Ranges[RemIndex2].Type] = TRUE;

                        //
                        // Remove just the overlapped portion of the range.
                        //

                        Restart = KiRemoveRange (
                           NewRange,
                           KiRangeInfo.Ranges[Index2].Base,
                           (Range[0].Limit < KiRangeInfo.Ranges[Index2].Limit ?
                                    Range[0].Limit : KiRangeInfo.Ranges[Index2].Limit),
                           RemoveThisType
                           );
                    }
                }
            }
        }

    } while (Restart);

    //
    // The range database is now rounded to fit in the h/w and sorted.
    // Attempt to build MTRR settings which exactly describe the ranges
    //

    MTRR = NewRange->MTRR;
    NoMTRR = 0;
    for (Index=0;NT_SUCCESS(NewRange->Status)&& Index<KiRangeInfo.NoRange;Index++) {
        Range = &KiRangeInfo.Ranges[Index];

        //
        // Build MTRRs to fit this range
        //

        Base   = Range->Base;
        Length = Range->Limit - Base + 1;

        while (Length) {

            //
            // Compute MTRR length for current range base & length
            //

            if (Base == 0) {
                MLength = Length;
            } else {
                MLength = (ULONGLONG) 1 << KiFindFirstSetRightBit(Base);
            }
            if (MLength > Length) {
                MLength = Length;
            }

            l = (ULONGLONG) 1 << KiFindFirstSetLeftBit (MLength);
            if (MLength > l) {
                MLength = l;
            }

            //
            // Store it in the next MTRR
            //

            MTRR[NoMTRR].Base.u.QuadPart = Base;
            MTRR[NoMTRR].Base.u.hw.Type  = Range->Type;
            MTRR[NoMTRR].Mask.u.QuadPart = KiLengthToMask(MLength);
            MTRR[NoMTRR].Mask.u.hw.Valid = 1;
            NoMTRR += 1;

            //
            // Adjust off amount of data covered by that last MTRR
            //

            Base += MLength;
            Length -= MLength;

            //
            // If there are too many MTRRs, and currently setting a
            // Non-USWC range try to remove a USWC MTRR.
            // (ie, convert some MmWriteCombined to MmNonCached).
            //

            if (NoMTRR > (ULONG) KiRangeInfo.Capabilities.u.hw.VarCnt) {

                if (Range->Type != MTRR_TYPE_USWC) {

                    //
                    // Find smallest USWC type and drop it
                    //
                    // This is okay only if the default type is UC.
                    // Default type should always be UC unless BIOS changes
                    // it. Still ASSERT!
                    //

                    ASSERT(KiRangeInfo.Default.u.hw.Type == MTRR_TYPE_UC);

                    BestLength = (ULONGLONG) 1 << (MTRR_MAX_RANGE_SHIFT + 1);

                    for (Index2=0; Index2 < KiRangeInfo.Capabilities.u.hw.VarCnt; Index2++) {

                        if (MTRR[Index2].Base.u.hw.Type == MTRR_TYPE_USWC) {

                            CurrLength = KiMaskToLength(MTRR[Index2].Mask.u.QuadPart &
                                                 MTRR_MASK_MASK);

                            if (CurrLength < BestLength) {
                                WhichMtrr = Index2;
                                BestLength = CurrLength;
                            }
                        }
                    }

                    if (BestLength == ((ULONGLONG) 1 << (MTRR_MAX_RANGE_SHIFT + 1))) {
                        //
                        // Range was not found which could be dropped.  Abort process
                        //

                        NewRange->Status = STATUS_UNSUCCESSFUL;
                        Length = 0;

                    } else {
                        //
                        // Remove WhichMtrr
                        //

                        NoMTRR -= 1;
                        MTRR[WhichMtrr] = MTRR[NoMTRR];
                    }

                } else {

                    NewRange->Status = STATUS_UNSUCCESSFUL;
                    Length =0;
                }
            }
        }
    }

    //
    // Done building new MTRRs
    //

    if (NT_SUCCESS(NewRange->Status)) {

        //
        // Update the MTRRs on all processors
        //

#if IDBG
        KiDumpMTRR ("Loading the following MTRR:", NewRange->MTRR);
#endif

        NewRange->Synchronize.TargetCount = 0;
        NewRange->Synchronize.TargetPhase = &Prcb->ReverseStall;
        NewRange->Synchronize.Processor = Prcb->Number;

        //
        // Previously enabled MTRRs with index > NoMTRR
        // which could conflict with existing setting should be disabled
        // This is taken care of by setting NewRange->NoMTRR to total
        // number of variable MTRRs.
        //

        NewRange->NoMTRR = (ULONG) KiRangeInfo.Capabilities.u.hw.VarCnt;

        //
        // Synchronize with other IPI functions which may stall
        //

        KiLockContextSwap(&OldIrql);

#if !defined(NT_UP)
        //
        // Collect all the (other) processors
        //

        TargetProcessors = KeActiveProcessors & ~Prcb->SetMember;
        if (TargetProcessors != 0) {

            KiIpiSendSynchronousPacket (
                Prcb,
                TargetProcessors,
                KiLoadMTRRTarget,
                (PVOID) NewRange,
                NULL,
                NULL
                );

            //
            // Wait for all processors to be collected
            //

            KiIpiStallOnPacketTargets(TargetProcessors);

            //
            // All processors are now waiting.  Raise to high level to
            // ensure this processor doesn't enter the debugger due to
            // some interrupt service routine.
            //

            KeRaiseIrql (HIGH_LEVEL, &OldIrql2);

            //
            // There's no reason for any debug events now, so signal
            // the other processors that they can all disable interrupts
            // and begin the MTRR update
            //

            Prcb->ReverseStall += 1;
        }
#endif

        //
        // Update MTRRs
        //

        KiLoadMTRR (NewRange);

        //
        // Release ContextSwap lock
        //

        KiUnlockContextSwap(OldIrql);


#if IDBG
        KiDumpMTRR ("Processor MTRR:", NewRange->MTRR);
#endif

    } else {

        //
        // There was an error, put original range database back
        //

        DBGMSG ("KiCompleteEffectiveRangeChange: mtrr update did not occur\n");

        if (NewRange->Ranges) {
            KiRangeInfo.NoRange = NewRange->NoRange;

            RtlCopyMemory (
                KiRangeInfo.Ranges,
                NewRange->Ranges,
                sizeof (ONE_RANGE) * KiRangeInfo.NoRange
                );
        }
    }

    //
    // Cleanup
    //

    ExFreePool (NewRange->Ranges);
    ExFreePool (NewRange->MTRR);
}


STATIC ULONG
KiRangeWeight (
    IN PONE_RANGE   Range
    )
/*++

Routine Description:

    This functions returns a weighting of the passed in range's cache
    type.   When two or more regions collide within the same h/w region
    the types are weighted and that cache type of the higher weight
    is used for the collision area.

Arguments:

    Range   - Range to obtain weighting for

Return Value:

    The weight of the particular cache type

--*/
{
    ULONG   Weight;

    switch (Range->Type) {
        case MTRR_TYPE_UC:      Weight = 5;     break;
        case MTRR_TYPE_USWC:    Weight = 4;     break;
        case MTRR_TYPE_WP:      Weight = 3;     break;
        case MTRR_TYPE_WT:      Weight = 2;     break;
        case MTRR_TYPE_WB:      Weight = 1;     break;
        default:                Weight = 0;     break;
    }

    return Weight;
}


STATIC ULONGLONG
KiMaskToLength (
    IN ULONGLONG    Mask
    )
/*++

Routine Description:

    This function returns the length specified by a particular
    mtrr variable register mask.

--*/
{
    if (Mask == 0) {
        // Zero Mask signifies a length of      2**36
        return(((ULONGLONG) 1 << MTRR_MAX_RANGE_SHIFT));
    } else {
        return(((ULONGLONG) 1 << KiFindFirstSetRightBit(Mask)));
    }
}

STATIC ULONGLONG
KiLengthToMask (
    IN ULONGLONG    Length
    )
/*++

Routine Description:

    This function constructs the mask corresponding to the input length
    to be set in a variable MTRR register. The length is assumed to be
    a multiple of 4K.

--*/
{
    ULONGLONG FullMask = 0xffffff;

    if (Length == ((ULONGLONG) 1 << MTRR_MAX_RANGE_SHIFT)) {
        return(0);
    } else {
        return(((FullMask << KiFindFirstSetRightBit(Length)) &
            MTRR_RESVBIT_MASK));
    }
}

STATIC ULONG
KiFindFirstSetRightBit (
    IN ULONGLONG    Set
    )
/*++

Routine Description:

    This function returns a bit position of the least significant
    bit set in the passed ULONGLONG parameter. Passed parameter
    must be non-zero.

--*/
{
    ULONG   bitno;

    ASSERT(Set != 0);
    for (bitno=0; !(Set & 0xFF); bitno += 8, Set >>= 8) ;
    return KiFindFirstSetRight[Set & 0xFF] + bitno;
}

STATIC ULONG
KiFindFirstSetLeftBit (
    IN ULONGLONG    Set
    )
/*++

Routine Description:

    This function returns a bit position of the most significant
    bit set in the passed ULONGLONG parameter. Passed parameter
    must be non-zero.

--*/
{
    ULONG   bitno;

    ASSERT(Set != 0);
    for (bitno=56;!(Set & 0xFF00000000000000); bitno -= 8, Set <<= 8) ;
    return KiFindFirstSetLeft[Set >> 56] + bitno;
}

#if IDBG
VOID
KiDumpMTRR (
    PUCHAR          DebugString,
    PMTRR_RANGE     MTRR
    )
/*++

Routine Description:

    This function dumps the MTRR information to the debugger

--*/
{
    static PUCHAR Type[] = {
    //  0       1       2       3       4       5       6
        "UC  ", "USWC", "????", "????", "WT  ", "WP  ", "WB  " };
    MTRR_VARIABLE_BASE  Base;
    MTRR_VARIABLE_MASK  Mask;
    ULONG       Index;
    ULONG       i;
    PUCHAR      p;

    DbgPrint ("%s\n", DebugString);
    for (Index=0; Index < (ULONG) KiRangeInfo.Capabilities.u.hw.VarCnt; Index++) {
        if (MTRR) {
            Base = MTRR[Index].Base;
            Mask = MTRR[Index].Mask;
        } else {
            Base.u.QuadPart = RDMSR(MTRR_MSR_VARIABLE_BASE+2*Index);
            Mask.u.QuadPart = RDMSR(MTRR_MSR_VARIABLE_MASK+2*Index);
        }

        DbgPrint ("  %d. ", Index);
        if (Mask.u.hw.Valid) {
            p = "????";
            if (Base.u.hw.Type < 7) {
                p = Type[Base.u.hw.Type];
            }

            DbgPrint ("%s  %08x:%08x  %08x:%08x",
                p,
                (ULONG) (Base.u.QuadPart >> 32),
                ((ULONG) (Base.u.QuadPart & MTRR_MASK_BASE)),
                (ULONG) (Mask.u.QuadPart >> 32),
                ((ULONG) (Mask.u.QuadPart & MTRR_MASK_MASK))
                );

        }
        DbgPrint ("\n");
    }
}
#endif


VOID
KiLoadMTRRTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID NewRange,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )
{
    PNEW_RANGE Context;

    Context = (PNEW_RANGE) NewRange;

    //
    // Wait for all processors to be ready
    //

    KiIpiSignalPacketDoneAndStall(SignalDone,
                                  Context->Synchronize.TargetPhase);

    //
    // Update MTRRs
    //

    KiLoadMTRR (Context);
}



#define MOV_EAX_CR4   _emit { 0Fh, 20h, E0h }
#define MOV_CR4_EAX   _emit { 0Fh, 22h, E0h }

NTSTATUS
KiLoadMTRR (
    IN PNEW_RANGE Context
    )
/*++

Routine Description:

    This function loads the memory type range registers into all processors

Arguments:

    Context     - Context which include the MTRRs to load

Return Value:

    All processors are set into the new state

--*/
{
    MTRR_DEFAULT        Default;
    BOOLEAN             Enable;
    ULONG               HldCr0, HldCr4;
    ULONG               Index;

    //
    // Disable interrupts
    //

    Enable = KeDisableInterrupts();

    //
    // Synchronize all processors
    //

    if (!(KeFeatureBits & KF_AMDK6MTRR)) {
        KiLockStepExecution (&Context->Synchronize);
    }

    _asm {
        ;
        ; Get current CR0
        ;

        mov     eax, cr0
        mov     HldCr0, eax

        ;
        ; Disable caching & line fill
        ;

        and     eax, not CR0_NW
        or      eax, CR0_CD
        mov     cr0, eax

        ;
        ; Flush caches
        ;

        ;
        ; wbinvd
        ;

        _emit 0Fh
        _emit 09h

        ;
        ; Get current cr4
        ;

        _emit  0Fh
        _emit  20h
        _emit  0E0h             ; mov eax, cr4
        mov     HldCr4, eax

        ;
        ; Disable global page
        ;

        and     eax, not CR4_PGE
        _emit  0Fh
        _emit  22h
        _emit  0E0h             ; mov cr4, eax

        ;
        ; Flush TLB
        ;

        mov     eax, cr3
        mov     cr3, eax
    }

    if (KeFeatureBits & KF_AMDK6MTRR) {

        //
        // Write the MTRRs
        //

        KiAmdK6MtrrWRMSR();

    } else {

        //
        // Disable MTRRs
        //

        Default.u.QuadPart = RDMSR(MTRR_MSR_DEFAULT);
        Default.u.hw.MtrrEnabled = 0;
        WRMSR (MTRR_MSR_DEFAULT, Default.u.QuadPart);

        //
        // Load new MTRRs
        //

        for (Index=0; Index < Context->NoMTRR; Index++) {
            WRMSR (MTRR_MSR_VARIABLE_BASE+2*Index, Context->MTRR[Index].Base.u.QuadPart);
            WRMSR (MTRR_MSR_VARIABLE_MASK+2*Index, Context->MTRR[Index].Mask.u.QuadPart);
        }
    }
    _asm {

        ;
        ; Flush caches (this should be a "nop", but it was in the Intel reference algorithm)
        ; This is required because of aggressive prefetch of both instr + data
        ;

        ;
        ; wbinvd
        ;

        _emit 0Fh
        _emit 09h

        ;
        ; Flush TLBs (same comment as above)
        ; Same explanation as above
        ;

        mov     eax, cr3
        mov     cr3, eax
    }

    if (!(KeFeatureBits & KF_AMDK6MTRR)) {

        //
        // Enable MTRRs
        //

        Default.u.hw.MtrrEnabled = 1;
        WRMSR (MTRR_MSR_DEFAULT, Default.u.QuadPart);
    }

    _asm {
        ;
        ; Restore CR4 (global page enable)
        ;

        mov     eax, HldCr4
        _emit  0Fh
        _emit  22h
        _emit  0E0h             ; mov cr4, eax

        ;
        ; Restore CR0 (cache enable)
        ;

        mov     eax, HldCr0
        mov     cr0, eax
    }

    //
    // Wait for all processors to reach the same place,
    // restore interrupts and return.
    //

    if (!(KeFeatureBits & KF_AMDK6MTRR)) {
        KiLockStepExecution (&Context->Synchronize);
    }

    KeEnableInterrupts (Enable);
    return STATUS_SUCCESS;
}


VOID
KiLockStepExecution (
    IN PPROCESSOR_LOCKSTEP  Context
    )
{

#if !defined(NT_UP)

    ULONG               CurrentPhase;
    volatile ULONG      *TargetPhase;
    PKPRCB              Prcb;

    TargetPhase = Context->TargetPhase;
    Prcb = KeGetCurrentPrcb();

    if (Prcb->Number == (CCHAR) Context->Processor) {

        //
        // Wait for all processors to signal
        //

        while (Context->TargetCount != (ULONG) KeNumberProcessors - 1) {
            KeYieldProcessor ();
        }

        //
        // Reset count for next time
        //

        Context->TargetCount = 0;

        //
        // Let waiting processor go to next synchronization point
        //

        InterlockedIncrement ((PULONG) TargetPhase);


    } else {

        //
        // Get current phase
        //

        CurrentPhase = *TargetPhase;

        //
        // Signal that we have completed the current phase
        //

        InterlockedIncrement ((PULONG) &Context->TargetCount);

        //
        // Wait for new phase to begin
        //

        while (*TargetPhase == CurrentPhase) {
            KeYieldProcessor ();
        }
    }

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\mpipia.asm ===
title  "mpipia"
;++
;
; Copyright (c) 1989-1995  Microsoft Corporation
;
; Module Name:
;
;    mpipia.asm
;
; Abstract:
;
;    This module implements the x86 specific fucntions required to
;    support multiprocessor systems.
;
; Author:
;
;    David N. Cutler (davec) 5-Feb-1995
;
; Environment:
;
;    Krnel mode only.
;
; Revision History:
;
;--

.586p
        .xlist
include ks386.inc
include mac386.inc
include callconv.inc
        .list

        EXTRNP  HalRequestSoftwareInterrupt,1,IMPORT,FASTCALL
        EXTRNP  HalRequestSoftwareInterrupt,1,IMPORT,FASTCALL
        EXTRNP  _HalRequestIpi,1,IMPORT
        EXTRNP  _KiFreezeTargetExecution, 2
ifdef DBGMP
        EXTRNP  _KiPollDebugger
endif
        extrn   _KiProcessorBlock:DWORD

DELAYCOUNT  equ    2000h

_DATA   SEGMENT DWORD PUBLIC 'DATA'

public  _KiSynchPacket
_KiSynchPacket dd  0

_DATA   ENDS



_TEXT  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; BOOLEAN
; KiIpiServiceRoutine (
;     IN PKTRAP_FRAME TrapFrame,
;     IN PKEXCEPTION_FRAME ExceptionFrame
;     )
;
; Routine Description:
;
;     This routine is called at IPI level to process any outstanding
;     interporcessor requests for the current processor.
;
; Arguments:
;
;     TrapFrame - Supplies a pointer to a trap frame.
;
;     ExceptionFrame - Not used.
;
; Return Value:
;
;     A value of TRUE is returned, if one of more requests were service.
;     Otherwise, FALSE is returned.
;
;--

cPublicProc _KiIpiServiceRoutine, 2

ifndef NT_UP

cPublicFpo 2, 3
        push    ebx                     ; save nonvolatile registers
        push    esi                     ;
        push    edi                     ;

        mov     esi, PCR[PcPrcb]        ; get current processor block address

        xor     ebx, ebx                ; set exchange value
        xor     ecx, ecx                ;
        mov     eax, [esi].PbRequestSummary ; get current request summary
        mov     edx, [esi].PbSignalDone ; get current request packet

isr05:                                  ;

   lock cmpxchg8b qword ptr PbRequestSummary[esi] ; capture and clear request data
        jnz     short isr05             ; if nz, compare exchange failed
        mov     ebx, eax                ; save request summary
        mov     edi, edx                ; save request packet

;
; Check for freeze request or synchronous request.
;

        test    bl, IPI_FREEZE + IPI_SYNCH_REQUEST ; test for freeze or packet
        jnz     short isr50             ; if nz, freeze or synch request

;
; For RequestSummary's other then IPI_FREEZE set return to TRUE
;

        mov     bh, 1                   ; set return value

;
; Check for Packet ready.
;
; If a packet is ready, then get the address of the requested function
; and call the function passing the address of the packet address as a
; parameter.
;

isr10:  test    edi, edi                ; test for request packet
        jz      short isr20             ; if z set, no packet ready
        mov     edx, edi                ; clear low bit in packet address
        btr     edx, 0                  ;
        push    [edx].PbCurrentPacket + 8 ; push parameters on stack
        push    [edx].PbCurrentPacket + 4 ;
        push    [edx].PbCurrentPacket + 0 ;
        push    edi                     ; push source processor block address
        mov     eax, [edx].PbWorkerRoutine ; get worker routine address
        mov     edx, [esp + 16 + 4*4]   ; get current trap frame address
        mov     [esi].PbIpiFrame, edx   ; save current trap frame address
        call    eax                     ; call worker routine
        mov     bh, 1                   ; set return value

;
; Check for APC interrupt request.
;

isr20:  test    bl, IPI_APC             ; check if APC interrupt requested
        jz      short isr30             ; if z, APC interrupt not requested

        mov     ecx, APC_LEVEL          ; request APC interrupt
        fstCall HalRequestSoftwareInterrupt ;

;
; Check for DPC interrupt request.
;

isr30:  test    bl, IPI_DPC             ; check if DPC interrupt requested
        jz      short isr40             ; if z, DPC interrupt not requested

        mov     ecx, DISPATCH_LEVEL     ; request DPC interrupt
        fstCall HalRequestSoftwareInterrupt ;

isr40:  mov     al, bh                  ; return status
        pop     edi                     ; restore nonvolatile registers
        pop     esi                     ;
        pop     ebx                     ;

        stdRET  _KiIpiServiceRoutine

;
; Freeze or synchronous request
;

isr50:  test    bl, IPI_FREEZE          ; test if freeze request
        jz      short isr60             ; if z, no freeze request

;
; Freeze request is requested
;

        mov     ecx, [esp] + 20         ; get exception frame address
        mov     edx, [esp] + 16         ; get trap frame address
        stdCall _KiFreezeTargetExecution, <edx, ecx> ; freeze execution
        test    bl, not IPI_FREEZE      ; Any other IPI RequestSummary?
        setnz   bh                      ; Set return code accordingly
        test    bl, IPI_SYNCH_REQUEST   ; test if synch request
        jz      isr10                   ; if z, no sync request

;
; Synchronous packet request.   Pointer to requesting PRCB in KiSynchPacket.
;

isr60:  mov     eax, _KiSynchPacket     ; get PRCB of requesting processor
        mov     edx, eax                ; clear low bit in packet address
        btr     edx, 0                  ;
        push    [edx].PbCurrentPacket+8 ; push parameters on stack
        push    [edx].PbCurrentPacket+4 ;
        push    [edx].PbCurrentPacket+0 ;
        push    eax                     ; push source processor block address
        mov     eax, [edx].PbWorkerRoutine ; get worker routine address
        mov     edx, [esp + 16 + 4*4]   ; get current trap frame address
        mov     [esi].PbIpiFrame, edx   ; save current trap frame address
        call    eax                     ; call worker routine
        mov     bh, 1                   ; set return value
        jmp     isr10                   ; join common code

else

        xor     eax, eax                ; return FALSE

        stdRET  _KiIpiServiceRoutine

endif

stdENDP _KiIpiServiceRoutine


;++
;
; VOID
; FASTCALL
; KiIpiSend (
;    IN KAFFINITY TargetProcessors,
;    IN KIPI_REQUEST Request
;    )
;
; Routine Description:
;
;    This function requests the specified operation on the targt set of
;    processors.
;
; Arguments:
;
;    TargetProcessors (ecx) - Supplies the set of processors on which the
;        specified operation is to be executed.
;
;    IpiRequest (edx) - Supplies the request operation code.
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KiIpiSend, 2

ifndef NT_UP

cPublicFpo 0, 2
        push    esi                     ; save registers
        push    edi                     ;
        mov     esi, ecx                ; save target processor set

        shr     ecx, 1                  ; shift out first bit
        lea     edi, _KiProcessorBlock  ; get processor block array address
        jnc     short is20              ; if nc, not in target set

is10:   mov     eax, [edi]              ; get processor block address
   lock or      [eax].PbRequestSummary, edx ; set request summary bit

is20:   shr     ecx, 1                  ; shift out next bit
        lea     edi, [edi+4]            ; advance to next processor
        jc      short is10              ; if target, go set summary bit
        jnz     short is20              ; if more, check next

        stdCall _HalRequestIpi, <esi>   ; request IPI interrupts on targets

        pop     edi                     ; restore registers
        pop     esi                     ;
endif
        fstRet  KiIpiSend

fstENDP KiIpiSend

;++
;
; VOID
; KiIpiSendPacket (
;     IN KAFFINITY TargetProcessors,
;     IN PKIPI_WORKER WorkerFunction,
;     IN PVOID Parameter1,
;     IN PVOID Parameter2,
;     IN PVOID Parameter3
;     )
;
; Routine Description:
;
;    This routine executes the specified worker function on the specified
;    set of processors.
;
; Arguments:
;
;   TargetProcessors [esp + 4] - Supplies the set of processors on which the
;       specfied operation is to be executed.
;
;   WorkerFunction [esp + 8] - Supplies the address of the worker function.
;
;   Parameter1 - Parameter3 [esp + 12] - Supplies worker function specific
;       paramters.
;
; Return Value:
;
;     None.
;
;--*/

cPublicProc _KiIpiSendPacket, 5

ifndef NT_UP

cPublicFpo 5, 2
        push    esi                     ; save registers
        push    edi                     ;

;
; Store function address and parameters in the packet area of the PRCB on
; the current processor.
;

        mov     edx, PCR[PcPrcb]        ; get current processor block address
        mov     ecx, [esp] + 12         ; get target processor set
        mov     eax, [esp] + 16         ; get worker function address
        mov     edi, [esp] + 20         ; get worker function parameter 1
        mov     esi, [esp] + 24         ; get worker function parameter 2

        mov     [edx].PbTargetSet, ecx  ; set target processor set
        mov     [edx].PbWorkerRoutine, eax ; set worker function address

        mov     eax, [esp] + 28         ; get worker function parameter 3
        mov     [edx].PbCurrentPacket, edi ; set work function parameters
        mov     [edx].PbCurrentPacket + 4, esi ;
        mov     [edx].PbCurrentPacket + 8, eax ;

;
; Determine whether one and only one bit is set in the target set.
;

        mov     edi, ecx                ; copy recipient target set
        lea     esi, dword ptr [ecx-1]  ; compute target set - 1
        and     edi, esi                ; and target set with target set - 1
        neg     edi                     ; negate result (CF = 0 if zero)
        sbb     edi, edi                ; compute result as one if the
        inc     edi                     ; target set has one bit set
        jnz     short isp5              ; if nz, target set has one bit
        mov     [edx].PbPacketBarrier, ecx ; set packet barrier
isp5:   add     edx, edi                ; set low order bit if appropriate

;
; Loop through the target processors and send the packet to the specified
; recipients.
;

        shr     ecx, 1                  ; shift out first bit
        lea     edi, _KiProcessorBlock  ; get processor block array address
        jnc     short isp30             ; if nc, not in target set
isp10:  mov     esi, [edi]              ; get processor block address
isp20:  mov     eax, [esi].PbSignalDone ; check if packet being processed
        or      eax, eax                ;
        jne     short isp20             ; if ne, packet being processed

   lock cmpxchg [esi].PbSignalDone, edx ; compare and exchange

        jnz     short isp20             ; if nz, exchange failed

isp30:  shr     ecx, 1                  ; shift out next bit
        lea     edi, [edi+4]            ; advance to next processor
        jc      short isp10             ; if c, in target set
        jnz     short isp30             ; if nz, more target processors

        mov     ecx, [esp] + 12         ; set target processor set
        stdCall _HalRequestIpi, <ecx>   ; send IPI to targets

        pop     edi                     ; restore register
        pop     esi                     ;
endif

        stdRet  _KiIpiSendPacket

stdENDP _KiIpiSendPacket

;++
;
; VOID
; FASTCALL
; KiIpiSignalPacketDone (
;     IN PKIPI_CONTEXT Signaldone
;     )
;
; Routine Description:
;
;     This routine signals that a processor has completed a packet by
;     clearing the calling processor's set member of the requesting
;     processor's packet.
;
; Arguments:
;
;     SignalDone (ecx) - Supplies a pointer to the processor block of the
;         sending processor.
;
;         N.B. The low order bit of signal done is set if the target set
;              has one and only one bit set.
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KiIpiSignalPacketDone, 1

ifndef NT_UP

        btr     ecx, 0                          ; test and clear bit 0
        jc      short spd20                     ; if c set, only one bit set
        mov     edx, PCR[PcPrcb]                ; get current processor block address
        mov     eax, [edx].PbSetMember          ; get processor bit
   lock xor     [ecx].PbTargetSet, eax          ; clear processor set member
        jnz     short spd10                     ; if nz, more targets to go
        xor     eax, eax                        ; clear packet barrier
        mov     [ecx].PbPacketBarrier, eax      ;

spd10:  fstRET  KiIpiSignalPacketDone

;
; One and only one bit is set in the target set. Since this is the only
; processor that can clear any bits in the target set, the target set can
; be cleared with a simple write.
;

spd20:  xor     eax, eax                        ; clear target set
        mov     [ecx].PbTargetSet, eax          ;

endif

        fstRET  KiIpiSignalPacketDone

fstENDP KiIpiSignalPacketDone


;++
;
; VOID
; FASTCALL
; KiIpiSignalPacketDoneAndStall (
;     IN PKIPI_CONTEXT Signaldone
;     IN PULONG ReverseStall
;     )
;
; Routine Description:
;
;     This routine signals that a processor has completed a packet by
;     clearing the calling processor's set member of the requesting
;     processor's packet, and then stalls of the reverse stall value
;
; Arguments:
;
;     SignalDone (ecx) - Supplies a pointer to the processor block of the
;         sending processor.
;
;         N.B. The low order bit of signal done is set if the target set
;              has one and only one bit set.
;
;     ReverseStall (edx) - Supplies a pointer to the reverse stall barrier
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall KiIpiSignalPacketDoneAndStall, 2
cPublicFpo 0, 2

ifndef NT_UP

        push    ebx                             ; save register
        mov     ebx, dword ptr [edx]            ; get current value of barrier
        btr     ecx, 0                          ; test and clear bit 0
        jc      short sps10                     ; if c set, only one bit set
        mov     eax, PCR[PcPrcb]                ; get processor block address
        mov     eax, [eax].PbSetMember          ; get processor bit
   lock xor     [ecx].PbTargetSet, eax          ; clear processor set member
        jnz     short sps20                     ; if nz, more targets to go
        xor     eax, eax                        ; clear packet barrier
        mov     [ecx].PbPacketBarrier, eax      ;
        jmp     short sps20                     ;

;
; One and only one bit is set in the target set. Since this is the only
; processor that can clear any bits in the target set, the target set can
; be cleared with a simple write.
;

sps10:  xor     eax, eax                        ; clear target set
        mov     [ecx].PbTargetSet, eax          ;

;
; Wait for barrier value to change.
;

sps20:  mov     eax, DELAYCOUNT
sps30:  cmp     ebx, dword ptr [edx]            ; barrier set?
        jne     short sps90                     ; yes, all done

        YIELD
        dec     eax                             ; P54C pre C2 workaround
        jnz     short sps30                     ; if eax = 0, generate bus cycle

ifdef DBGMP
        stdCall _KiPollDebugger                 ; Check for debugger ^C
endif

;
; There could be a freeze execution outstanding.  Check and clear
; freeze flag.
;

.errnz IPI_FREEZE - 4
        mov     eax, PCR[PcPrcb]                ; get processor block address
   lock btr     [eax].PbRequestSummary, 2       ; Generate bus cycle
        jnc     short sps20                     ; Freeze pending?

cPublicFpo 0,4
        push    ecx                             ; save target processor block
        push    edx                             ; save barrier address
        stdCall _KiFreezeTargetExecution, <[eax].PbIpiFrame, 0> ;
        pop     edx                             ; restore barrier address
        pop     ecx                             ; restore target procssor block
        jmp     short sps20                     ;

sps90:  pop     ebx                             ; restore register

endif
        fstRET  KiIpiSignalPacketDoneAndStall

fstENDP KiIpiSignalPacketDoneAndStall

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\mtrramd.c ===
#include "ki.h"

#define STATIC

#define IDBG    0

#if DBG
#define DBGMSG(a)   DbgPrint(a)
#else
#define DBGMSG(a)
#endif

//
// Externals.
//

NTSTATUS
KiLoadMTRR (
    PVOID Context
    );

// --- AMD Structure definitions ---

// K6 MTRR hardware register layout.

// Single MTRR control register.

typedef struct _AMDK6_MTRR {
    ULONG       type:2;
    ULONG       mask:15;
    ULONG       base:15;
} AMDK6_MTRR, *PAMDK6_MTRR;

// MSR image, contains two control regs.

typedef struct _AMDK6_MTRR_MSR_IMAGE {
    union {
        struct {
            AMDK6_MTRR    mtrr0;
            AMDK6_MTRR    mtrr1;
        } hw;
        ULONGLONG   QuadPart;
    } u;
} AMDK6_MTRR_MSR_IMAGE, *PAMDK6_MTRR_MSR_IMAGE;

// MTRR reg type field values.

#define AMDK6_MTRR_TYPE_DISABLED    0
#define AMDK6_MTRR_TYPE_UC          1
#define AMDK6_MTRR_TYPE_WC          2
#define AMDK6_MTRR_TYPE_MASK        3

// AMD K6 MTRR MSR Index number

#define AMDK6_MTRR_MSR                0xC0000085

//
// Region table entry - used to track all write combined regions.
//
// Set BaseAddress to AMDK6_REGION_UNUSED for unused entries.
//

typedef struct _AMDK6_MTRR_REGION {
    ULONG                BaseAddress;
    ULONG                Size;
    MEMORY_CACHING_TYPE  RegionType;
    ULONG                RegionFlags;
} AMDK6_MTRR_REGION, *PAMDK6_MTRR_REGION;

#define MAX_K6_REGIONS          2		// Limit the write combined regions to 2 since that's how many MTRRs we have available.

//
// Value to set base address to for unused indication.
//

#define AMDK6_REGION_UNUSED     0xFFFFFFFF

//
// Flag to indicate that this region was set up by the BIOS.    
//

#define AMDK6_REGION_FLAGS_BIOS 0x00000001

//
// Usage count for hardware MTRR registers.
//

#define AMDK6_MAX_MTRR        2

//
// AMD Function Prototypes.
//

VOID
KiAmdK6InitializeMTRR (
    VOID
    );

NTSTATUS
KiAmdK6RestoreMTRR (
    );

NTSTATUS
KiAmdK6MtrrSetMemoryType (
    ULONG BaseAddress,
    ULONG Size,
    MEMORY_CACHING_TYPE Type
    );

BOOLEAN
KiAmdK6AddRegion (
    ULONG BaseAddress,
    ULONG Size,
    MEMORY_CACHING_TYPE Type,
    ULONG Flags
    );

NTSTATUS
KiAmdK6MtrrCommitChanges (
    VOID
    );

NTSTATUS
KiAmdK6HandleWcRegionRequest (
    ULONG BaseAddress,
    ULONG Size
    );

VOID
KiAmdK6MTRRAddRegionFromHW (
    AMDK6_MTRR RegImage
    );

PAMDK6_MTRR_REGION
KiAmdK6FindFreeRegion (
MEMORY_CACHING_TYPE Type
    );

#pragma alloc_text(INIT,KiAmdK6InitializeMTRR)
#pragma alloc_text(PAGELK,KiAmdK6RestoreMTRR)
#pragma alloc_text(PAGELK,KiAmdK6MtrrSetMemoryType)
#pragma alloc_text(PAGELK,KiAmdK6AddRegion)
#pragma alloc_text(PAGELK,KiAmdK6MtrrCommitChanges)
#pragma alloc_text(PAGELK,KiAmdK6HandleWcRegionRequest)
#pragma alloc_text(PAGELK,KiAmdK6MTRRAddRegionFromHW)
#pragma alloc_text(PAGELK,KiAmdK6FindFreeRegion)

// --- AMD Global Variables ---

extern KSPIN_LOCK KiRangeLock;

// AmdK6Regions - Table to track wc regions.

AMDK6_MTRR_REGION AmdK6Regions[MAX_K6_REGIONS];
ULONG AmdK6RegionCount;

// Usage counter for hardware MTRRs.

ULONG AmdMtrrHwUsageCount;

// Global variable image of MTRR MSR.

AMDK6_MTRR_MSR_IMAGE    KiAmdK6Mtrr;

// --- AMD Start of code ---

VOID
KiAmdK6InitializeMTRR (
    VOID
    )
{
    ULONG    i;
    KIRQL    OldIrql;

    DBGMSG("KiAmdK6InitializeMTRR: Initializing K6 MTRR support\n");

    KiAmdK6Mtrr.u.hw.mtrr0.type = AMDK6_MTRR_TYPE_DISABLED;
    KiAmdK6Mtrr.u.hw.mtrr1.type = AMDK6_MTRR_TYPE_DISABLED;
    AmdK6RegionCount = MAX_K6_REGIONS;
    AmdMtrrHwUsageCount = 0;

    //
    // Set all regions to free.
    //

    for (i = 0; i < AmdK6RegionCount; i++) {
        AmdK6Regions[i].BaseAddress = AMDK6_REGION_UNUSED;
        AmdK6Regions[i].RegionFlags = 0;
    }

    //
    // Initialize the spin lock.
    //
    // N.B. Normally this is done by KiInitializeMTRR but that
    // routine is not called in the AMD K6 case.
    //

    KeInitializeSpinLock (&KiRangeLock);

    //
    // Read the MTRR registers to see if the BIOS has set them up.
    // If so, add entries to the region table and adjust the usage
    // count.  Serialize the region table.
    //

    KeAcquireSpinLock (&KiRangeLock, &OldIrql);
                
    KiAmdK6Mtrr.u.QuadPart = RDMSR (AMDK6_MTRR_MSR);

    //
    // Check MTRR0 first.
    //

    KiAmdK6MTRRAddRegionFromHW(KiAmdK6Mtrr.u.hw.mtrr0);

    //
    // Now check MTRR1.
    //

    KiAmdK6MTRRAddRegionFromHW(KiAmdK6Mtrr.u.hw.mtrr1);

    //
    // Release the locks.
    //

    KeReleaseSpinLock (&KiRangeLock, OldIrql);
}

VOID
KiAmdK6MTRRAddRegionFromHW (
    AMDK6_MTRR RegImage
    )
{
    ULONG BaseAddress, Size, TempMask;

    //
    // Check to see if this MTRR is enabled.
    //
        
    if (RegImage.type != AMDK6_MTRR_TYPE_DISABLED) {

        //
        // If this is a write combined region then add an entry to
        // the region table.
        //

        if ((RegImage.type & AMDK6_MTRR_TYPE_UC) == 0) {

            //
            // Create a new resion table entry.
            //

            BaseAddress = RegImage.base << 17;

            //
            // Calculate the size base on the mask value.
            //

            TempMask = RegImage.mask;
            
            //
            // There should never be 4GB WC region!
            //

            ASSERT (TempMask != 0);

            //
            // Start with 128 size and search upward.
            //

            Size = 0x00020000;

            while ((TempMask & 0x00000001) == 0) {
                TempMask >>= 1;
                Size <<= 1;
            }

            //
            // Add the region to the table.
            //
            
            KiAmdK6AddRegion(BaseAddress,
                             Size,
                             MmWriteCombined,
                             AMDK6_REGION_FLAGS_BIOS);

            AmdMtrrHwUsageCount++;
        }
    }
}


NTSTATUS
KiAmdK6MtrrSetMemoryType (
    ULONG BaseAddress,
    ULONG Size,
    MEMORY_CACHING_TYPE Type
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    KIRQL       OldIrql;

    switch(Type) {
    case MmWriteCombined:

        //
        // H/W needs updating, lock down the code required to effect
        // the change.
        //

        if (KeGetCurrentIrql() >= DISPATCH_LEVEL) {

            //
            // Code can not be locked down.   Supplying a new range type
            // requires that the caller calls at irql < dispatch_level.
            //

            DBGMSG ("KeAmdK6SetPhysicalCacheTypeRange failed due to calling IRQL == DISPATCH_LEVEL\n");
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Lock the code.
        //

        MmLockPagableSectionByHandle(ExPageLockHandle);
        
        //
        // Serialize the region table.
        //

        KeAcquireSpinLock (&KiRangeLock, &OldIrql);

        Status = KiAmdK6HandleWcRegionRequest(BaseAddress, Size);
        
        //
        // Release the locks.
        //

        KeReleaseSpinLock (&KiRangeLock, OldIrql);
        MmUnlockPagableImageSection(ExPageLockHandle);
        
        break;  // End of WriteCombined case.

    case MmNonCached:

        //
        // Add an entry to the region table.
        //

	// Don't need to add these to the region table.  Non-cached regions are 
	// accessed using a non-caching virtual pointer set up in the page tables.

        break;

    case MmCached:

        //
        // Redundant.  These should be filtered out in
        // KeAmdK6SetPhysicalCacheTypeRange();
        //

        Status = STATUS_NOT_SUPPORTED;
        break;

    default:
        DBGMSG ("KeAmdK6SetPhysicalCacheTypeRange: no such cache type\n");
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    return Status;
}

NTSTATUS
KiAmdK6HandleWcRegionRequest (
    ULONG BaseAddress,
    ULONG Size
    )
{
    ULONG               i;
    ULONG               AdjustedSize, AdjustedEndAddress, AlignmentMask;
    ULONG               CombinedBase, CombinedSize, CombinedAdjustedSize;
    PAMDK6_MTRR_REGION  pRegion;
    BOOLEAN             bCanCombine, bValidRange;

    //
    // Try and find a region that overlaps or is adjacent to the new one and
    // check to see if the combined region would be a legal mapping.
    //

    for (i = 0; i < AmdK6RegionCount; i++) {
        pRegion = &AmdK6Regions[i];
        if ((pRegion->BaseAddress != AMDK6_REGION_UNUSED) &&
            (pRegion->RegionType == MmWriteCombined)) {

            //
            // Does the new start address overlap or adjoin an
            // existing WC region?
            //

            if (((pRegion->BaseAddress >= BaseAddress) &&
                 (pRegion->BaseAddress <= (BaseAddress + Size))) ||
                 ((BaseAddress <= (pRegion->BaseAddress + pRegion->Size)) &&
                  (BaseAddress >= pRegion->BaseAddress))) {

                //
                // Combine the two regions into one.
                //

                AdjustedEndAddress = BaseAddress + Size;

                if (pRegion->BaseAddress < BaseAddress) {
                    CombinedBase = pRegion->BaseAddress;
                } else {
                    CombinedBase = BaseAddress;
                }

                if ((pRegion->BaseAddress + pRegion->Size) >
                    AdjustedEndAddress) {
                    CombinedSize = (pRegion->BaseAddress + pRegion->Size) -
                           CombinedBase;
                } else {
                    CombinedSize = AdjustedEndAddress - CombinedBase;
                }

                //
                // See if the new region would be a legal mapping.
                //
                //
                // Find the smallest legal size that is equal to the requested range.  Scan
                // all ranges from 128k - 2G. (Start at 2G and work down).
                //
        
                CombinedAdjustedSize = 0x80000000;
                AlignmentMask = 0x7fffffff;
                bCanCombine = FALSE;
                
                while (CombinedAdjustedSize > 0x00010000) {

                    //
                    // Check the size to see if it matches the requested limit.
                    //

                    if (CombinedAdjustedSize == CombinedSize) {

                        //
                        // This one works.
                        // Check to see if the base address conforms to the MTRR restrictions.
                        //

                        if ((CombinedBase & AlignmentMask) == 0) {
                            bCanCombine = TRUE;
                        }

                        break;

                    } else {

                        //
                        // Bump it down to the next range size and try again.
                        //

                        CombinedAdjustedSize >>= 1;
                        AlignmentMask >>= 1;
                    }
                }

                if (bCanCombine) {
                    //
                    // If the resized range is OK, record the change in the region
                    // table and commit the changes to hardware.
                    //
                    
                    pRegion->BaseAddress = CombinedBase;
                    pRegion->Size = CombinedAdjustedSize;
                
                    //
                    // Reset the BIOS flag since we now "own" this region (if we didn't already).
                    //
                
                    pRegion->RegionFlags &= ~AMDK6_REGION_FLAGS_BIOS;

                    return KiAmdK6MtrrCommitChanges();
                }
            }
        }
    }

	// A valid combination could not be found, so try to create a new range for this request.
    //
    // Find the smallest legal size that is less than or equal to the requested range.  Scan
    // all ranges from 128k - 2G. (Start at 2G and work down).
    //
        
    AdjustedSize = 0x80000000;
    AlignmentMask = 0x7fffffff;
    bValidRange = FALSE;

    while (AdjustedSize > 0x00010000) {

        //
        // Check the size to see if it matches the requested limit.
        //

        if (AdjustedSize == Size) {

            //
            // This one works.
            //
            // Check to see if the base address conforms to the MTRR restrictions.
            //

            if ((BaseAddress & AlignmentMask) == 0) {
                bValidRange = TRUE;
            }
            
            //
            // Stop looking.
            //
            
            break;

        } else {

            //
            // Bump it down to the next range size and try again.
            //

            AdjustedSize >>= 1;
            AlignmentMask >>= 1;
        }
    }

    //
    // Couldn't find a legal region that fit.
    //
    
    if (!bValidRange) {
        return STATUS_NOT_SUPPORTED;
    }
    
    
    //
    // If we got this far then this is a new WC region.
    // Create a new region entry for this request.
    //

    if (!KiAmdK6AddRegion(BaseAddress, AdjustedSize, MmWriteCombined, 0)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Commit the changes to hardware.
    //
        
    return KiAmdK6MtrrCommitChanges();
}

BOOLEAN
KiAmdK6AddRegion (
    ULONG BaseAddress,
    ULONG Size,
    MEMORY_CACHING_TYPE Type,
    ULONG Flags
    )
{
    PAMDK6_MTRR_REGION pRegion;

    if ((pRegion = KiAmdK6FindFreeRegion(Type)) == NULL) {
        return FALSE;
    }
    pRegion->BaseAddress = BaseAddress;
    pRegion->Size = Size;
    pRegion->RegionType = Type;
    pRegion->RegionFlags = Flags;
    
    return TRUE;
}

PAMDK6_MTRR_REGION
KiAmdK6FindFreeRegion (
    MEMORY_CACHING_TYPE Type
    )
{
    ULONG    i;

    //
    // If this is a MmWriteCombined request, limit the number of
    // regions to match the actual hardware support.
    //

    if (Type == MmWriteCombined) {
        if (AmdMtrrHwUsageCount >= AMDK6_MAX_MTRR) {

            //
            // Search the table to see if there are any BIOS entries
            // we can replace.
            //

            for (i = 0; i < AmdK6RegionCount; i++) {
                if (AmdK6Regions[i].RegionFlags & AMDK6_REGION_FLAGS_BIOS) {
                    return &AmdK6Regions[i];
                }
            }

            //
            // No free HW MTRRs and no reusable entries.
            //

            return FALSE;
        }
    }

    //
    // Find the next free region in the table.
    //

    for (i = 0; i < AmdK6RegionCount; i++) {
        if (AmdK6Regions[i].BaseAddress == AMDK6_REGION_UNUSED) {

            if (Type == MmWriteCombined) {
                AmdMtrrHwUsageCount++;
            }
            return &AmdK6Regions[i];
        }
    }


    DBGMSG("AmdK6FindFreeRegion: Region Table is Full!\n");

    return NULL;
}

NTSTATUS
KiAmdK6MtrrCommitChanges (
    VOID
    )

/*++

Routine Description:

    Commits the values in the table to hardware.

    This procedure builds the MTRR images into the KiAmdK6Mtrr variable and
    calls KiLoadMTRR to actually load the register.

Arguments:

   None.

Return Value:

   None.

--*/

{
    ULONG    i, dwWcRangeCount = 0;
    ULONG    RangeTemp, RangeMask;

    //
    // Reset the MTRR image for both MTRRs disabled.
    //

    KiAmdK6Mtrr.u.hw.mtrr0.type = AMDK6_MTRR_TYPE_DISABLED;
    KiAmdK6Mtrr.u.hw.mtrr1.type = AMDK6_MTRR_TYPE_DISABLED;

    //
    // Find the Write Combining Regions, if any and set up the MTRR register.
    //

    for (i = 0; i < AmdK6RegionCount; i++) {

        //
        // Is this a valid region, and is it a write combined type?
        //

        if ((AmdK6Regions[i].BaseAddress != AMDK6_REGION_UNUSED) &&
            (AmdK6Regions[i].RegionType == MmWriteCombined)) {
            
            //
            // Calculate the correct mask for this range size.  The
            // BaseAddress and size were validated and adjusted in
            // AmdK6MtrrSetMemoryType().
            //
            // Start with 128K and scan for all legal range values and
            // build the appropriate range mask at the same time.
            //

            RangeTemp = 0x00020000;
            RangeMask = 0xfffe0000;            

            while (RangeTemp != 0) {
                if (RangeTemp == AmdK6Regions[i].Size) {
                    break;
                }
                RangeTemp <<= 1;
                RangeMask <<= 1;
            }
            if (RangeTemp == 0) {

                //
                // Not a valid range size.  This can never happen!!
                //

                DBGMSG ("AmdK6MtrrCommitChanges: Bad WC range in region table!\n");

                return STATUS_NOT_SUPPORTED;
            }

            //
            // Add the region to the next available register.
            //

            if (dwWcRangeCount == 0)  {

                KiAmdK6Mtrr.u.hw.mtrr0.base = AmdK6Regions[i].BaseAddress >> 17;
                KiAmdK6Mtrr.u.hw.mtrr0.mask = RangeMask >> 17;
                KiAmdK6Mtrr.u.hw.mtrr0.type = AMDK6_MTRR_TYPE_WC;
                dwWcRangeCount++;

            }  else if (dwWcRangeCount == 1) {

                KiAmdK6Mtrr.u.hw.mtrr1.base = AmdK6Regions[i].BaseAddress >> 17;
                KiAmdK6Mtrr.u.hw.mtrr1.mask = RangeMask >> 17;
                KiAmdK6Mtrr.u.hw.mtrr1.type = AMDK6_MTRR_TYPE_WC;
                dwWcRangeCount++;

            } else {

                //
                // Should never happen!  This should have been caught in
                // the calling routine.
                //

                DBGMSG ("AmdK6MtrrCommitChanges: Not enough MTRR registers to satisfy region table!\n");

                return STATUS_NOT_SUPPORTED;
            }
        }
    }

    //
    // Commit the changes to hardware.
    //

    KiLoadMTRR(NULL);

    return STATUS_SUCCESS;
}

VOID
KiAmdK6MtrrWRMSR (
    VOID
    )

/*++

Routine Description:

    Write the AMD K6 MTRRs.

    Note: Access to KiAmdK6Mtrr has been synchronized around this
    call.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Write the MTRRs
    //

    WRMSR (AMDK6_MTRR_MSR, KiAmdK6Mtrr.u.QuadPart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\pat.h ===
/*++
Copyright (c) 1997-8  Microsoft Corporation

Module Name:

    pat.h

Abstract:

    This module contains the i386 specific Page Attribute
    Table (PAT) register hardware definitions.

Author:

    Shivnandan Kaushik (Intel Corp)

Environment:

    Kernel mode only.

Revision History:

--*/
//
// PAT MSR architecture definitions
//

//
// PAT model specific register
//

#define PAT_MSR       0x277

//
// PAT memory attributes
//

#define PAT_TYPE_STRONG_UC  0       // corresponds to PPro PCD=1,PWT=1
#define PAT_TYPE_USWC       1
#define PAT_TYPE_WT         4
#define PAT_TYPE_WP         5
#define PAT_TYPE_WB         6
#define PAT_TYPE_WEAK_UC    7       // corresponds to PPro PCD=1,PWT=0
#define PAT_TYPE_MAX        8       

#include "pshpack1.h"

typedef union _PAT {
    struct {
        UCHAR Pat[8];
    } hw;
    ULONGLONG   QuadPart;
} PAT, *PPAT;

#include "poppack.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\pat.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    pat.c

Abstract:

    This module implements interfaces that set the Page Attribute
    Table. These entry points only exist on i386 machines.

Author:

    Shivnandan Kaushik (Intel Corp.)

Environment:

    Kernel mode only.

Revision History:

--*/

#include "ki.h"
#include "pat.h"

//
// Use lockstep mechanism from mtrr code.
//

#include "mtrr.h"

#if DBG
#define DBGMSG(a)   DbgPrint(a)
#else
#define DBGMSG(a)
#endif

//
// Structure used for PAT initialization
//

typedef struct _NEW_PAT {

    PAT                 Attributes;

    //
    // IPI context to coordinate concurrent PAT update
    //

    PROCESSOR_LOCKSTEP  Synchronize;
} NEW_PAT, *PNEW_PAT;

// Prototypes

VOID
KeRestorePAT (
    VOID
    );

VOID
KiInitializePAT (
    VOID
    );

VOID
KiLoadPAT (
    IN PNEW_PAT Context
    );

VOID
KiLoadPATTarget (
    IN PKIPI_CONTEXT    SignalDone,
    IN PVOID            Context,
    IN PVOID            Parameter2,
    IN PVOID            Parameter3
    );

#if DBG
VOID
KiDumpPAT (
    PUCHAR      DebugString,
    PAT         Attributes
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK,KiInitializePAT)
#pragma alloc_text(PAGELK,KiLoadPAT)
#pragma alloc_text(PAGELK,KiLoadPATTarget)
#endif

VOID
KeRestorePAT (
    VOID
    )
/*++
Routine Description:

    Reinitialize the Page Attribute Table (PAT) on all processors.

    N.B. The caller must have the PAGELK code locked

  Arguments:

    None.

Return Value:

    None.
--*/
{
    if (KeFeatureBits & KF_PAT) {
        KiInitializePAT();
    }
}

VOID
KiInitializePAT (
    VOID
    )
/*++

Routine Description:

    Initialize the Page Attribute Table (PAT) on all processors. PAT
    is setup to provide WB, WC, STRONG_UC and WEAK_UC as the memory
    types such that mm macros for enabling/disabling/querying caching
    (MI_DISABLE_CACHING, MI_ENABLE_CACHING and MI_IS_CACHING_ENABLED)
    are unaffected.

    PAT_Entry   PAT Index   PCD PWT     Memory Type
    0            0           0   0       WB
    1            0           0   1       WC *
    2            0           1   0       WEAK_UC
    3            0           1   1       STRONG_UC
    4            1           0   0       WB
    5            1           0   1       WC *
    6            1           1   0       WEAK_UC
    7            1           1   1       STRONG_UC

    N.B. The caller must have the PAGELK code locked and ensure that the
    PAT feature is supported.

  Arguments:

    None.

Return Value:

    None.

--*/
{
    PAT         PatAttributes;
    ULONG       Size;
    KIRQL       OldIrql, NewIrql;
    PKPRCB      Prcb;
    NEW_PAT     NewPAT;
    KAFFINITY   TargetProcessors;

    ASSERT ((KeFeatureBits & KF_PAT) != 0);

    //
    // Initialize the PAT
    //

    PatAttributes.hw.Pat[0] = PAT_TYPE_WB;
    PatAttributes.hw.Pat[1] = PAT_TYPE_USWC;
    PatAttributes.hw.Pat[2] = PAT_TYPE_WEAK_UC;
    PatAttributes.hw.Pat[3] = PAT_TYPE_STRONG_UC;
    PatAttributes.hw.Pat[4] = PAT_TYPE_WB;
    PatAttributes.hw.Pat[5] = PAT_TYPE_USWC;
    PatAttributes.hw.Pat[6] = PAT_TYPE_WEAK_UC;
    PatAttributes.hw.Pat[7] = PAT_TYPE_STRONG_UC;

    //
    // Synchronize with other IPI functions which may stall
    //

    KiLockContextSwap(&OldIrql);

    Prcb = KeGetCurrentPrcb();

    NewPAT.Attributes = PatAttributes;
    NewPAT.Synchronize.TargetCount = 0;
    NewPAT.Synchronize.TargetPhase = &Prcb->ReverseStall;
    NewPAT.Synchronize.Processor = Prcb->Number;


#if !defined(NT_UP)

    //
    // Collect all the (other) processors
    //

    TargetProcessors = KeActiveProcessors & ~Prcb->SetMember;
    if (TargetProcessors != 0) {

        KiIpiSendSynchronousPacket (
            Prcb,
            TargetProcessors,
            KiLoadPATTarget,
            (PVOID) (&NewPAT),
            NULL,
            NULL
            );

        //
        // Wait for all processors to be collected
        //

        KiIpiStallOnPacketTargets(TargetProcessors);

        //
        // All processors are now waiting.  Raise to high level to
        // ensure this processor doesn't enter the debugger due to
        // some interrupt service routine.
        //

        KeRaiseIrql (HIGH_LEVEL, &NewIrql);

        //
        // There's no reason for any debug events now, so signal
        // the other processors that they can all begin the PAT update
        //

        Prcb->ReverseStall += 1;
    }

#endif

    //
    // Update PAT
    //

    KiLoadPAT(&NewPAT);

    //
    // Release ContextSwap lock and lower to initial irql
    //

    KiUnlockContextSwap(OldIrql);
    MmEnablePAT();
    return;
}

VOID
KiLoadPATTarget (
    IN PKIPI_CONTEXT SignalDone,
    IN PVOID NewPAT,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    )
/*++

Routine Description:

    Synchronize with target processors prior to PAT modification.

Arguments:

    Context     - Context which includes the PAT to load

Return Value:

    None

--*/
{
    PNEW_PAT Context;

    Context = (PNEW_PAT) NewPAT;

    //
    // Wait for all processors to be ready
    //

    KiIpiSignalPacketDoneAndStall(SignalDone,
                                  Context->Synchronize.TargetPhase);

    //
    // Update PAT
    //

    KiLoadPAT (Context);
}

VOID
KiLoadPAT (
    IN PNEW_PAT Context
    )
/*++

Routine Description:

    This function loads the PAT to all processors.

Arguments:

    Context - Context which includes new PAT to load

Return Value:

    PAT on all processors programmed to new values

--*/
{
    BOOLEAN             Enable;
    ULONG               HldCr0, HldCr4, Index;

    //
    // Disable interrupts
    //

    Enable = KeDisableInterrupts();

    //
    // Synchronize all processors
    //

    KiLockStepExecution (&Context->Synchronize);

    _asm {
        ;
        ; Get current CR0
        ;

        mov     eax, cr0
        mov     HldCr0, eax

        ;
        ; Disable caching & line fill
        ;

        and     eax, not CR0_NW
        or      eax, CR0_CD
        mov     cr0, eax

        ;
        ; Flush caches
        ;

        ;
        ; wbinvd
        ;

        _emit 0Fh
        _emit 09h

        ;
        ; Get current cr4
        ;

        _emit  0Fh
        _emit  20h
        _emit  0E0h             ; mov eax, cr4
        mov     HldCr4, eax

        ;
        ; Disable global page
        ;

        and     eax, not CR4_PGE
        _emit  0Fh
        _emit  22h
        _emit  0E0h             ; mov cr4, eax

        ;
        ; Flush TLB
        ;

        mov     eax, cr3
        mov     cr3, eax
    }

    //
    // Load new PAT
    //

    WRMSR (PAT_MSR, Context->Attributes.QuadPart);

    _asm {

        ;
        ; Flush caches.
        ;

        ;
        ; wbinvd
        ;

        _emit 0Fh
        _emit 09h

        ;
        ; Flush TLBs
        ;

        mov     eax, cr3
        mov     cr3, eax
    }

    _asm {
        ;
        ; Restore CR4 (global page enable)
        ;

        mov     eax, HldCr4
        _emit  0Fh
        _emit  22h
        _emit  0E0h             ; mov cr4, eax

        ;
        ; Restore CR0 (cache enable)
        ;

        mov     eax, HldCr0
        mov     cr0, eax
    }

    //
    // Wait for all processors to reach the same place,
    // restore interrupts and return.
    //

    KiLockStepExecution (&Context->Synchronize);
    KeEnableInterrupts (Enable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntos\ke\i386\newsysbg.asm ===
title  "System Startup"
;++
;
; Copyright (c) 1989, 2000  Microsoft Corporation
;
; Module Name:
;
;    systembg.asm
;
; Abstract:
;
;    This module implements the code necessary to initially startup the
;    NT system.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 07-Mar-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   John Vert (jvert) 25-Jun-1991
;       Major overhaul in order to move into new osloader architecture
;       Removed old debugger hacks
;
;--
.386p
        .xlist
include ks386.inc
include i386\kimacro.inc
include mac386.inc
include callconv.inc
        .list

        option  segment:flat

        extrn   _KiBootFeatureBits:DWORD
        EXTRNP  _KdInitSystem,2
        EXTRNP  _KdPollBreakIn,0
        EXTRNP  KfRaiseIrql,1,IMPORT,FASTCALL
        EXTRNP  KfLowerIrql,1,IMPORT,FASTCALL
        EXTRNP  _KiInitializeKernel,6
        EXTRNP  GetMachineBootPointers
        EXTRNP  KiIdleLoop,0,,FASTCALL
        EXTRNP  _KiInitializePcr,7
        EXTRNP  _KiSwapIDT
        EXTRNP  _KiInitializeTSS,1
        EXTRNP  _KiInitializeTSS2,2
        extrn   _KiTrap08:PROC
        extrn   _KiTrap02:PROC
        EXTRNP  _KiInitializeAbios,1
        EXTRNP  _KiInitializeMachineType
        EXTRNP  _HalInitializeProcessor,2,IMPORT

if NT_INST
        EXTRNP  _KiAcquireSpinLock, 1
        EXTRNP  _KiReleaseSpinLock, 1
endif
        extrn   _KiFreezeExecutionLock:DWORD
        extrn   _IDT:BYTE
        extrn   _IDTLEN:BYTE            ; NOTE - really an ABS, linker problems
        extrn   _KeNumberProcessors:BYTE
        extrn   _KeActiveProcessors:DWORD
        extrn   _KeLoaderBlock:DWORD
        extrn   _KiIdleProcess:BYTE
        extrn   _KiIdleThread0:BYTE

ifndef NT_UP
        extrn   _KiBarrierWait:DWORD
        EXTRNP  _KiProcessorStart
endif

;
; Constants for various variables
;

_DATA   SEGMENT PARA PUBLIC 'DATA'

;
; Statically allocated structures for Bootstrap processor
; double fault stack for P0
; idle thread stack for P0
;

        align   16
        public  _KiDoubleFaultStack
        db      DOUBLE_FAULT_STACK_SIZE dup (?)
_KiDoubleFaultStack label byte

        public  P0BootStack
        db   